一直以来，无论是还是、的应用中，为了提升应用的加载等待这段时间的用户感知体验，各种奇门遁甲之术层出不穷。其中，菊花图以及由它衍生各种加载动画是一个非常大的流派，如下图所示：

由它衍生而出的各种加载动画也是遍地开花：

在很多的应用的交互中，这种菊花的加载的设计已然要一统江湖了。
不过，现在对于加载的设计体验有了比菊花加载体验更棒的方法，即本文要讲的  ，中文一般叫做骨架屏。骨架屏听起来总觉得怪怪的，本文还是沿用英文的叫法  。
所谓  即表示在页面完全渲染完成之前，用户会看到一个样式简单，描绘了当前页面的大致框架，感知到页面正在逐步加载，加载完成后，最终骨架屏中各个占位部分将被真实的数据替换。
一图胜千言，来看看微信阅读的客户端，它就使用了  来提升它的加载体验，可以下载它的客户端实际感受下：

现在好多和客户端都已经放弃了以前的那种菊花的加载体验，转而使用  ，比如、以及等。国内的饿了么、掘金等也都使用  来提升它们的加载体验。

下面这段话，是中关于加载体验的交互设计标准的一个说明：

’            ’                 ’           —     

使用  也充分遵循了人机交互设计指南。本文就来讲讲如何使用来实现  。
实现思路
在本文中，我们将会使用组件  功能来实现一个  ，如下图所示：

具体组件  功能这里就不详讲了，可以去官方的文档看看详细的信息。
这里推荐一个模拟开发数据的开源服务，类似经常使用的图片占位服务一样，它提供了在开发中一些常见数据类型的服务，比如文章、评论、用户系统等，都提供了对应的接口，在开发调试阶段还是非常方便的。
比如我们做的这个例子要用到用户系统，直接使用这个用户数据接口就行了。
首先，主要的工作是实现  加载动画，先使用常规的和来实现这个动画。
动画效果如下所示：

先定义好结构：
  =
    =
      = 
      = 
      = 
      = 
      = 
      = 
      = 
   

下面来说说实现动画的主要思路：
要实现这样的效果，需要使用一点点小技巧。先在图层定义一个大的渐变背景，然后在不需要显示背景图的位置，定义几个占位的结构填充为白色就可以实现上图所示的展现形式。最后使用来移动背景图片的位置，就可以实现图中的动画效果。
详细的代码可以去这里查看，。
主要的效果实现了，下面就可以正式开工来定义我们的  组件。
 {
    
   `
       =
       =
    `
}

 {
   ` =
      = 
      = 
      = 
      = 
      = 
      = 
      = 
   `
}
上面定义了两个组件，一个是用来显示用户信息数据的组件；一个在加载完之前来显示  效果的组件。
定义好组件后，然后在主文件定义好对应的结构来注册使用组件：
 =
   =   = =
     = =
  
   =   =
    
  

根据上面定义好的组件，上面的代码表示，当数据加载完后，显示用户数据。当还没有加载完用户数据，则显示预先定义好的加载组件即。
  =  {
   
   {
     
     
     
  }
   {
      {
      ``
         = 
         = {
           = 
           = 
        }
    }
  }
    {
     = {
      
    } 
  }
}
一个简单优雅的  就完成了。
通过上面简单的实例，可以明显感受到当使用  来代替传统的菊花图在体验上更加好一些。
使用  ，可以利用一些视觉元素来将内容的轮廓更快显示在屏幕上，让用户在等待加载的过程中对将要加载的内容有一个更加清晰的预期，特别是在弱网络的场景下，  的体验无疑是更好的，用起来吧。
对于  ，你有什么样的看法呢？欢迎在评论区留言一起分享你的看法。
参考资料：
_

     当前官网仅包含、、、的发布包，并无 包，并且官网也注明了并不保证除以外库的稳定性，在功能方面也是最完善的。众所周知，在开发效率、易用性上有着巨大的优势，但作为一个解释性语言，在性能方面还是存在比较大的缺陷，在各类服务化过程中，采用作为模型快速构建工具，使用高级语言如，作为服务化程序实现是大势所趋。本文重点介绍 服务化过程中实现方式及遇到的各种问题。
实现方案
 对于 库的使用，有两种方法：
 最佳方式当然是直接用构建，但是当前库并不像 那样。可参照         中还包含和的数字内核实现的类，可用以添加新的。可参照__
 常用的方式，调用生成好的。本文主要介绍该方案。
实现步骤
 编译源码  模型训练输出结果 模型固化 模型加载及运行 运行问题
 源码编译
环境要求： 公司版本， 版本 = 安装组件：       机器要求： 内存
 安装

  
 安装 
下载

         
 安装

  
 _
 编译源码
最好采用最新版本：

  _
编译过程中可能遇到的问题：问题一：        
安装或以上版本问题二：     

    
问题三： 内存不够
 模型训练与输出
模型训练输出可参照改用例去实践， 上也很多，模型训练保存好得到下面文件：

 模型固化
模型固化方式有三种：
 _ 工具

  _  _ 
        _= 
        _= 
        _=_ 
        __=
 利用_工具
             
 
__ = 
__ = 
__ = _

__ = _ __
___ = 
_ = 
__ = _ _  

         _
__ =  
__ = _
__ = 
__ = _ __
_ = 

____ ___
                          _ __
                          __ __
                          __ __
                          _
 利用 
  

   
   _

 = ____

 __
         
     = ___
    _ = __

             
    __ = _
    _ = __  _
     _
                 
                        
                
    __ = 

                   
    _ = 

             
     = ___   _=_

          
     = __
    __ = __

        
       __
          == 
             = 
               
                 _  
                     =   
          == 
             = 
             _    _

             
       
         _

                   
        __ = ____
                     
            __   _       
            __            
         

                   
         _   
            __
               __


 ____ == ____
     = 
    __ = =   
     = _

    __
坑  

在具体实际项目，用方式一与方式二将生成的模型利用  加载，报以上错误，采用 加载模型报同样错：

原因是模型中用到了，修复方式如上面中给出的方案
 模型加载及运行
构建输入输出
模型输入输出主要就是构造输入输出矩阵，相比的库，提供的和还是非常难用的，特别是动态矩阵创建，如果你的编译器支持，可以用库，和一样强大，并且用法机器类似。如果是版本就好好看看库和文档吧。例举集中简单的用法：
矩阵赋值：
 ___ { ___ ___ __}
 _ = __ 
 _  =    _ 
{
     _  =    ___ 
    {
         _  =    ___ 
        {
            _    = _  
        }
    }
}

     
{
       = 
     _ =   
      __ = _
     _  __
}
模型加载及初始化：
_   _  
{
      =  _ 
     
    {
        _     _
         ____
    }

     _
     =  _ _
      
    {
        _      _
         ____
    }

     = __
      
    {
        _     _
         ____
    }

     
}
运行：
以上的库是线程安全的，因此可多线程调用
_       
{
    
     _ = _ 

     __ 
    _ = 
       = {
        {_ _}
        {_ _}
    } 

     
      = _ {} {} 
     
    {
        _     _
         ___
    }
    
      =  
    
     
}
 运行问题
问题一：运行告警
   __                      
   __                      
   __                      
   __                      
 是因为在编译 库的时候没有把这些加速指令编译进去，因此可以在编译的时候加入加速指令，在没有条件下，加入这些库实测可以将计算提高左右。

    = = == =  _
 需要注意的是并不是所有都支持这些指令，一定要实机测试，以免。
问题二  和 混用
 为验证加载模型调用的准确性，利用将 封装成了库供调用，在同时   和封装好的 接口时， 

该问题官方并不打算解决作者：尹堃
团队：腾讯移动品质中心

一、引言
随着移动互联网的蓬勃发展，国内手机用户已经达到亿以上，但由于移动的产品迭代周期短，且使用的机型、网络和场景，都比原来端更加多样化和复杂化。传统的测试方法，在测试时间、机型网络覆盖等问题上，都显得力不从心。企鹅众测也称平台力图通过让用户协助测试的方式，来解决上述问题。
企鹅众测产品白皮书下称”白皮书”将从产品研发背景、功能特点、典型应用、工作流程和收费模式几个方面来介绍企鹅众测平台。
二、产品研发背景
、行业现状
目前，国内在软件众测领域，主要有企鹅众测、百度众测和众测三个众测平台。
百度众测
主要服务于内部的数据收集类任务，偏向于众包形式。
众测
提供第三方产品的探索服务，团队作业人，业务模式单一。
企鹅众测
累计服务腾讯内部几十款产品，并获得良好口碑。业务模式上，除了探索，还提供竞品对比评测、软件性能评测、跨 测试、定位、产品体验等服务，并可动态指定测试用户人数最多单任务可达到千人级别。
、企鹅众测的优势

图企鹅众测的优势
用户覆盖广
主要体现在遍布全国的真实用户、覆盖上千款机型和所有运营商网络，真实的用户使用场景。
同时，支持按照地区、网络、机型的多重条件过滤
快速的交付
普通任务两天内交付结果报告。
紧急任务小时内交付报告。
详尽的报告
任务用户反馈统计报告，版本质量一目了然
反馈详情：提供文字、图片、视频、、机型等各种信息
三、企鹅众测介绍
、概述
企鹅众测是让真实用户参与测试的一个平台，研发团队提出众测需求给平台，平台将众测需求下发给用户，并收集用户反馈，最后生成测试报告给研发团队。
企鹅众测支持应用、游戏、混合应用等多种产品形态，节将详细介绍支持的能力类型。
、能力介绍
目前支持下面的服务探索、产品调研、数据收集和产品评测四大类任务类型。

图企鹅众测支持的任务类型
探索
真人真机众测
真实用户参与测试，包括模块化测试、全量测试等，用户的使用场景多样，机型、网络和地域分布广泛，能够发现更多内部测试无法发现的问题。同时，可以让产品预先知道产品上线后的情况，增加发布信心。
机型适配兼容性测试
针对某个或者部分出现问题的机型，下发给该机型的用户进行测试，节省了大量购买手机的费用和时间。
复现
对于某些用户反馈的，内部无法复现或者复现代价过大，可以交给众测，让成千山万用户同时协助进行复现。
产品调研
问卷调查
针对产品的某项功能或产品原型，下发调查问卷收集用户的想法和意见，辅助产品经理对功能进行决策和了解功能在用户中的口碑。
数据收集
数据标注
数据标注类任务，主要解决因数量庞大而内部需耗费大量人力和时间的问题。最常见的是：地理位置收集类、小说内容错误类等。 
问题库建设
问题库建设，主要是满足项目组可以快速拿到出现问题的样本进行验证的需求，问题库一般包括但不限于：文件库、视频库、网页库等。
在产品开发过程中，经常出现用户反馈了问题，但是内部无法拿到相应的问题样本进行验证的情况，比如：手机浏览器的文件打开功能，经常出现用户反馈某类文件显示有问题，但是内部无法找到出现该问题的文档。
产品评测
产品评测
产品评测类，主要是让用户对产品进行深度体验，并提供功能体验报告，报告内容涉及：产品各项功能体验情况、对产品的建议，并提出不合理的设计和。
竞品对比
竞品对比主要是从用户角度，实际体验产品和竞品之间在功能、性能等负面的差异，包括但不限于：用户主观感受、性能数据、优劣势等。
、用户介绍
平台用户量
目前，众测平台用户注册数万，每月活跃用户接近万，用户来自全国各个省份地区，覆盖了国内所有的运营商网络，基本覆盖了所有安卓主流机型上千款。
年龄和职业分布
众测平台的用户偏向于年轻化，岁以下的用户居多，大部分是高中和大学生。

图众测用户年龄、学历分布 
机型覆盖
众测用户覆盖上千款机型，机型为小米、魅族、华为、联想等国内主流机型；安卓系统方面，覆盖了的所有操作系统。

图众测用户机型分布 

图众测用户系统分布
网络覆盖
众测用户覆盖国内三大运营商的所有网络类型，运营商包括：移动、联通和电信；网络类型包括：、、和。

图众测用户网络分布
地域覆盖
从地域上看，众测用户覆盖全国所有省份和地区，其中以广东、河南、山东为最。

图众测用户地域分布
四、典型应用和案例
、典型应用场景

表：企鹅众测典型应用场景
、典型应用案例
探索
真人真机众测

表：企鹅众测案例探索
机型适配兼容性测试

表：企鹅众测案例探索
复现

表：企鹅众测案例探索
数据收集
数据标注快速判断

表：企鹅众测案例数据收集 

表：企鹅众测案例数据收集
问题库建设

表：企鹅众测案例数据收集 
产品评测
竞品对比

表：企鹅众测案例产品评测
五、工作流程

图众测接入流程
、需求沟通
需求提供方，只需要提供下面材料给众测平台接口人即可：
需求关注点；
需求关注点对应的截图；
如果是内测软件，请提供安装包；
『可选』众测平台提供自动上传附件功能包括项目组自己打的、记录文件等，如果需要众测协助上传，只需要将附件写到指定目录下即可；
众测平台接口人收到测试需求后，会第一时间与需求提供方进行沟通确认，确认完毕便可向用户发布众测任务，确认阶段耗时一般不会超过半小时。
、任务分发
通过众测平台后台，向用户分发众测任务，发布的用户群体支持机型、地区、网络等多种维度的筛选，满足任务条件的用户可以在客户端网页端接收测试任务。
任务分发到用户侧，天内召集的测试用户，天内可以召集的测试用户。任务分发的时间长短，由需求提供方指定。分发过程由众测平台完成，项目组不需要投放人力参与。 
、反馈收集
用户通过客户端端网页端，可以方便的提交反馈到后台，后台会自动将反馈提交到对应的任务。
普通任务上线天，便可以完成反馈收集的目的。反馈的数量，跟众测的产品和任务需求息息相关，普通测试类任务，一般能够收到个以上的用户反馈。
、反馈跟进
需求提供方通过众测后台对反馈进行跟进，包括对反馈进行查看和标注标为重点关注，标注完成后，非重点关注的反馈，将由众测平台统一关闭。反馈支持一键导出到，如果是腾讯内部产品，支持一键转到。
在此阶段，需求提供方需要投入人力对用户反馈进行跟进，而如果对每个用户反馈的问题都跟进，势必会投入过多的人力和时间，众测平台建议按照优先级从高到底来跟进用户反馈：
严重提单跟进；
反馈人数在两个以上的提单跟进；
可复现或者有信息充足的提单跟进；
其他的，视投入产出比而定。 
、任务报告
当项目组筛选完用户反馈之后，众测平台会自动生成任务报告。
、反馈举例
下面通过一个具体的，来介绍用户反馈包含的内容：文字描述、截图、视频、、机型、网络等信息。
在详情页面，可以通过点击用户号，直接跟用户进行联系，省去添加好友的繁琐步骤。

图众测详情举例
搜索微信公众号：腾讯移动品质中心，获取更多测试干货！是基于实现的跨平台调试代理工具，类似的工具有平台上的，基于实现的，及公司同事基于实现的等等；与所有的调试代理工具一样，主要功能也是用于查看、修改、、的请求响应或者作为代理服务器，但不同于、和通过断点的方式修改请求响应，采用的是类似配置方式，通过配置修改请求响应，且提供规则分组功能及通过域名、路径、正则三种匹配方式系统的配置只支持域名匹配，特别针对终端调试提供了，等功能，并支持通过模块进行扩展。
基本功能
地址

安装启动
安装启动，需要以下四个步骤： 安装、安装、启动、配置代理。

安装建议安装最新版本，版本或当前版本都可以，如果已安装可以忽略此步骤： 安装：
    = 

 、用户可能需要加
     = 

安装及在公司网络访问外网需要用到的插件插件：
    

 、用户可能需要加
     

启动 默认端口为，如果要修改端口号，可以这么启动：   重启： 关闭： 更多内容请查看命令行帮助： 
配置代理需要手动配置浏览器代理或者系统代理代理的为所在机器的，如果是本机就填；端口号为启动时设置的端口号，默认为

配置浏览器代理推荐使用安装代理插件： 插件 或者  安装代理插件：  

配置系统代理：  





使用方法
安装、安装、启动、配置代理后可以开始使用，用浏览器打开配置管理页面
界面相关操作参见界面功能
配置模式
传统的配置模式：
 单个
 

 组合
    

 例如
 
   
的配置模式：
 单个操作
 
 如果和不同时为域名或路径的一种组合，位置可以调换
 

 组合模式
    
 和不同时为域名或路径的一种组合，可以如下配置
    
其中，可以为：

域名：所有该域名下的请求都会匹配
路径： 及其子路径的请求都会匹配，或不加协议，可以为、、、及其子路径的请求都会匹配
正则\\\\及其子路径的请求都会匹配，且在中可以通过   获取里面的子匹配

由上述基本功能抽象成的形如的，会根据匹配的的及修改请求或响应，和的详细内容参见帮助文档及协议列表。
例如：
 修改的响应
 
 或
 

 同时修改多个自定域名或路径
 \  
 修改的带端口、和响应的
   
一些例子

拦截
不开启拦截，无法在看到和请求响应的明文，且只能通过对和设置、代理等有限的操作，要通过完全操作、请求响应，需要开启拦截及在系统或浏览器安装的根证书，具体参见：

配置
 传统配置
   等价于：   
   

 支持带端口
   等价于：   ：
   

 支持通过域名获取
   等价于：   
   

 支持通过正则表达式匹配
 \  等价于： \  ：
 \ \

 支持路径匹配
   等价于：  ：
  
完整功能参见协议列表。

修改请求
以下功能都支持通过域名、路径、正则匹配方式，为方便只以域名匹配方式为例，其它同理：
 修改参数
 \\        

 请求方法
 

 添加请求头
 ==

 修改修改快捷方法
 

 修改修改请求快捷方法
 {}

 修改请求表单
 {}
对象可以存在本地文件，或存在界面的，也可以内联到配置里面，具体参见实现原理、数据格式。完整功能参见协议列表。

修改响应
以下功能都支持通过域名、路径、正则匹配方式，为方便只以域名匹配方式为例，其它同理：
 修改响应状态码
   请求不会发送到后台服务器，可以用来模拟、请求
   请求返回后再修改

 添加响应头
 ==

 修改响应类型修改响应类型的快捷方法
   或者：  

 请求替换
 

 本地替换中目录分割符可以用`\`，也可以用``
 \  等价于：  
 或
 
 如果要让本地没有对应文件的请求继续请求线上，可以采用
 \

 本地替换
 \   {}{ }
 \   {}{ }

 注入、、会自动根据响应类型封装后注入
 
 
 
对象或注入的文本可以存在本地文件，或存在界面的，也可以内联到配置里面，

设置代理
以下功能都支持通过域名、路径、正则匹配方式，为方便只以域名匹配方式为例，其它同理：
 代理
   等价于：  
 同时设置多个
   

 代理
   等价于：  
 同时设置多个
   

 脚本
 设置办公网脚本如果安装了，则无需设置
 
 设置办公网脚本如果安装了，则无需设置
 _
完整功能参见协议列表。

移动端调试
打开配置界面右上角的按钮获取当前的和端口，移动设备根据相应的和端口配置代理确保移动设备和要在同一网段；配置完后如果还是无法访问，可能需要关闭防火墙或者设置白名单。
 调试网页结构
 

 输出网页打印的日志
 {}
具体参见：、
完整功能参见协议列表。

其它功能
以下功能都支持通过域名、路径、正则匹配方式，为方便只以域名匹配方式为例，其它同理：
 禁用缓存
 

 忽略规则
 ||
完整功能参见协议列表。


插件扩展及应用
支持通过模块的方式扩展功能，具体参见：插件开发。
插件的一些应用：

代理服务器功能：本地代理里面的和的功能分别对应两个插件、
扩展协议功能：前端本地调试环境
扩展界面功能：

用户反馈
有问题可以先查帮助文档；
如果还是无法解决或者有建议、贡献代码等可以使用下面任一种方式：
最后，如果对你有帮助，给项目加个： 

相关推荐
基于  的跨平台播放器实现作者：

接上篇：《微信  模块化架构重构实践上》
取舍和选择
对于架构重构，我们也曾放眼行业内已经发布过的各种方案，希望从中找到一些解决思路。
我们参考了很多业界开放和发表的架构设计。总的来说，目前端整体架设计上，除了聚焦在“大前端”之外，基本上都在“插件化应用沙盒”上面下功夫。可以参考如、、、等等方案，不难发现让模块最终具备动态性是它们最核心的能力。
“大前端”是个热门的方向。我们结合自身情况，考虑到迁移已有代码不是一件容易事，让团队彻底切换编程工具短期不现实。这种“远水解不了近渴”的感觉，也只能暂且作罢。
我们把目光投向了“插件化应用沙盒”。沙盒的好处是它具备很强的隔离性，有些方案可以彻底隔离代码和资源，边界限制性极强，效果很好。此外，多数方案也都具备动态更新能力、补丁能力，动态性基本成为标配。所以这时我们在考虑需不需要走上这样的路。
一切从自身情况出发。在微信的角度看，我们最关心的问题是如何能约束住代码边界，如何防止架构劣化，如何提高开发效率。这样的情况下，重新审视了具备动态性的插件化和沙盒方案。先从动态性上考虑，回看业内的使用经验，目前的动态性通常有两个主要的用途：作为热补丁使用；业务并行发布需求强烈，例如运营需求，作为快速发布的手段。对于第二点，就目前的微信团队来说是较少遇到的弱需求。相较之下，工具类和电商类应用常有符合的使用场景。而对于第一点，我们则期望在实现模块化上，目标相对纯粹一些，专心解决代码自身问题，之后再通过在开发阶段之外实现热补丁上的动态性需要。
再来看隔离性。需要说明的是，这里的隔离型主要来自于沙盒架构效果。对于非独立插件化工程需要编译依赖其他插件除了动态性，它的作用和普通在代码隔离上没有区别，不做讨论。
我们心里很期盼代码与代码之间那种干净清爽的分割效果，但事与愿违。
图  模块依赖示意图
从上面这张模块依赖示意图看到，微信业务模块之间数据关系相当复杂，模块间相互访问数据、共享某些功能的行为如此普遍。而实际情况比示意图更麻烦。
面对微信业务数据相互间频繁的调用，沙盒隔离容易导致代码复用困难和相互调用麻烦，想在微信上实现，目前困难极大。重构难度不谈，单是隔离的收益就很有可能无法弥补开发效率上的损失。
从开发模式上看也是一样。微信团队目前每个迭代大概三四十人参与，内部沟通成本不算高到不可接受。通常开发同学可能要同时开发和修改几个模块并保证他们相互模块独立，同时又可能有频繁的模块间通信。这种时候，模块调用方不方便显得很重要。
此外还需要考虑的问题，从几个成熟方案中都能看到 框架、修改、替换或包装  、代理组件等等设计。这些方案的复杂度和兼容性代价，不能忽视。使用和维护它们需要仔细权衡。
所以思前想后我们仍选择了重走最开始的模块化之路。一切问题的根本还是在那个说的很多年的代码边界、解耦和内聚上。只要有了清晰独立的代码模块，才有将来其他变化的可能性。
代码之外，架构之内
模块负责人制度
有这样一句话，“不被监管的权利一定会发生腐败” 。如果放到软件开发的行当来说，就是“不被监管的代码也一定会发生劣化”。所以代码应该要接受“监管”。
为了能长期有效的保持代码质量，我们开始执行新的代码审查机制——模块负责人制度。
代码审查的好处毋庸置疑。在这之前，微信由于业务发展快速，同学们经常会变换需求的开发方向。面对着业务模块数量比人多的情况，开发同学经常一个人需要开发多个模块。也因此许多模块被无数人维护过，基础的支撑工程更是如此。这种类似游击战的方式，开发效率很高，支撑了微信快速的研发节奏，但也导致了“无主代码”特别多。大家缺少对代码的“归属感”，也降低了改进优化模块的欲望。另外在这之前，代码审查是由对申请回流主干的 进行，这导致效率较低且容易遗漏问题。合理的代码审查更应该是全员性质的。
模块负责人制度尝试改变这些现状。通过大家认领模块，对模块的代码和设计负责，对模块对外提供的接口服务负责，对其他人修改自己模块的行为进行监督。这些情况明显提高开发同学的代码所有感，改变大家修改优化和修改代码的动机。
推动模块负责人制度，渐进式的推动了大范围的代码审查，这样的方式很适合像微信这样没有从一开始执行全员性质 的项目。目前模块负责人机制运转顺利，代码审查率和模块认领率都在提高。
重构与开发者心态的关系
在一个长期没有改进的框架下，开发者的习惯可能会逐步变成跟随式、保守式的开发。这大概可以被描述成“只要别人这样做，我也这样做，哪怕这么样的设计不好，但也不会错”。随着心态逐渐普遍，另一种情形出现：经常能听到有同学吐槽一些代码，却更少看到代码在被改进。这说明一些沉积的问题不是没有被大家发现，只是没有人愿意去修改。这种情况下代码和框架会随着时间变得越来越差，有些问题逐渐变成“陈年旧病”。 面对这个问题首先要说，这不是开发者合格与否的问题，实际上有想法的开发人员有很多，但想将每个想法转换成代码并让大家接受，并不是一件很容易的事。尤其在一个大框架下，尝试改变的代价很大。如果他的主要任务不在改进某些模块上，那么很多想法最后都无法变成现实。这也是为什么保守和跟随的习惯会逐渐变的普遍。
保守的气氛需要被打破。当开启一次重构之后，你会发现团队中会有很多积极的声音响应，他们会把积压的想法和意见抛出来。一次问题的解决，可能会为另一个问题的解决带来机会，其他开发同学的一些想法也许就能更容易落地。所以不定期的推动一些模块的重构，将一些对代码的不满释放出来，是一种不错的激活。
此外在重构之后，还要考虑引导开发的代码组织方式切换，多用模板、正确的代码实例等，让他们可以放心参考。
模块划分经验谈
维持代码边界
代码的边界就像一堵墙，架构的劣化都是从这堵墙的瓦解开始的。从以往的经验来看，编译上的隔离是最好的约束手段，单纯的约定或准则并不能永远的保持下去。 所以在任何情况下都尽可能不要放开编译上的约束。接着，将接口和实现分离，其他工程只依赖接口而不依赖实现，这样的边界效果更好。当然破坏无处不在，例如遇到某个紧急需求要某模块新增若干接口，就可能出现跳过接口直接依赖实现工程进行开发的情况。这时可以考虑通过代码的审查进行监督，也可以通过开发简单的编译脚本，检查是否有不当依赖产生。
划定模块边界的细节问题
当对代码进行解耦时，即便大体上的模块职责划分已经清晰，但因为模块间的各种业务关系，细节上仍会遇到纠缠不清的情况。事实上，因为需求及功能的不同，并没有哪一种模块划分的规则是完全适用于每个应用的。随着业务的发展和变化，模块边界出现不合适的情况完全符合预期。
那么如何让模块划分更让大家觉得合理，或者说当遇到一个两难选择时，按照什么样的方式大家会更好理解？我们建议的方法其实也很简单：试着对代码“讲一个符合逻辑的故事”，哪个故事讲得通，你就可以将之作为拆分的选择。因为代码解耦从来不是问题，纠结的只是解耦行为能不能让人理解。例如一些模块间通信用的数据结构究竟属于那个模块的问题就可以用这种方式仲裁。在纠结的时候，能自圆其说的方案往往就足够了。我们要尽力避免的，应该是随意拼凑和单纯为了类型解耦而解耦的情况。
模块的一般组织方式 
设计一个模块，我们有一个一般性的组织方式，可以将模块分成三个工程：工程、工程、工程。
工程提供逻辑的实现。工程提供对外的接口和数据结构。工程，则提供该模块的一些工具类。
从另一个角度看，工程实际上是和应用的状态、生命周期相关的，它的执行依赖于各种应用状态。而工程则不关心这些状态。因此也可以看做提供某种功能，则是如何运用这种功能。例如，我们实现一个表情模块，工程提供表情的资源、表情的渲染和播放能力，工程提供了使用表情的服务接口，工程则提供了的实现，及何时开始加载表情资源、缓存管理、以及其他表情功能例如商店等等。
当然，这是一个指导性的建议，很多时候工程和工程之间没有明显边界也很正常。但强烈建议至少要有工程和工程。
分析依赖关系的工具
解耦代码时，快速分析代码的依赖关系能很好的提升工作效率。 提供了一个不错的工具。
图   工具
文件、资源以及工程，都可以进行依赖分析。有了分析结果，接下来一步一步把代码分离就简单多了。
最后
重构整体架构不是一件容易事，通常也不太可能让整个团队停下来只做重构。所以一直以来微信的重构都是随着版本迭代进行“拆分” “灰度”  “回流”的循环节奏。
“设计系统的组织，其产生的设计和架构等价于组织间的沟通结构”。对于微信几年间走过的路程，时至今日团队内的沟通形式还可以做到较多的直接沟通。这些情况决定了微信如今的技术选择。所以在方案选择上我们就更愿意寻求相对简单合适的方式解决问题——用纯粹的模块化保持后续架构的灵活性和健壮性，重新强调依赖、强调应用状态和生命周期、强化代码的边界。
除了代码上的设计，代码之外我们也做了些努力。我们认同代码审查的意义，也开始推行模块负责人的审查机制。此外我们还打算强化文档的使用，当然这个还在规划中。
最后希望我们分享的一点经验能对大家有些价值，欢迎留言交流。伴随新的支付方式出现，近年来移动支付蓬勃发展，如何分析、利用海量交易数据，已成为当前支付企业面对的巨大难题。日志作为数据的载体，蕴含着丰富的信息，传统的日志分析方式低效而固化，无法应对数据体量大、格式不统一、增长速度快的现状，在交易出现异常及失败时，更难以满足实时处理、快速响应的需求。
本文讲述某支付公司采用日志易后，通过日志大数据实现业务深度分析及风险控制的实践经验。

本次分享结合企业自身对支付行业的理解，将支付行业的需求总结为以下三点：
一、监管合规
、人民银行对支付机构的日志审计和安全合规规定
、开发访问日志的权限管理。
二、安全性
安全是支付公司非常重视的，安全风险有时会引起一些舆论导向，比如某些金融机构案件被媒体标注为特别关注某某支付公司发现了资金线的问题，消费者的钱不知去向等，这些都是一个社会的关注的焦点。结合市场风险及大环境，支付行业的安全性需求具体表现在：
、支付交易的安全性要求
、数据访问的安全性要求
、防止敏感信息的泄露等。
对支付行业来说，日志易产品在数据访问、权限要求等方面体现出很好的应用价值。
三、可靠性
、定位及解决问题的时效性
、系统流程的可靠性。
众多支付公司，当前做的产品主要针对新兴支付行业，特别是当前较热门的移动支付。那么移动支付的优势在哪里最主要的是便捷，而便捷的基础就是时效性强，可靠性高。为了更好发挥移动支付的便捷，支付公司对时效性，可靠性的要求很高，而这才是使用日志易大数据分析平台的深层次原因，日志易帮支付公司解决了最根本的行业需求，在可靠性方面展现了产品的价值。
支付公司日常业务方面的需求，涉及到以下场景：
、多种不同的访问失败类型进行分类
、每天需要做应答码的统计排名、占比以及走势图
、每个分类统计结果在一张图分别展示每个应答码趋势
、统计当日支付失败数量并分析
、需要导出访问失败类型的汇总统计表
、成功交易占比分析。
该公司原有的解决方案存在一定的局限性，比如：手动工作耗时量大、实时性差、人为造成失误、分析维度不能灵活变动及决策滞后等等。
支付公司有时会根据业务需要，对数据进行收集、清理，包括日志数据的清理等。当人为参与数据操作过多时，会引起部分意想不到的失误，从而引发问题。另外一点就是，原有方案实时性差，会导致公司的很多业务流程优化非常滞后。支付行业  人都知道，支付的维度是非常非常多的，做任何一笔支付，基础维度包括时间、金额、笔数等，还会有像交易地点、客户习性或者说需要根据支付数据研究客户的习性等等。一家支付公司不可能单纯做一个支付产品，所以支付产品包罗万象，聚合起来维度就更为复杂。
面对支付企业众多需求和行业的原有解决方案的短板，客户选择部署日志易产品后，实现了如下功能：
、各交易系统中每笔交易的状态等信息，按时间戳归类进行分析统计、实时报表展示
、根据日志易实时统计的多个维度的报表、图表，更准确的做出故障点判断
、决策层更直观的看到每天、每周、每种交易类型的故障高峰期及故障问题分布。

图  日志易解决方案
该支付公司使用日志易产品实现的解决方案及一些需求：
、产品角度来说，第一就是优化，充分满足客户需求，提升用户体验，第二是产品分析，第三是数字营销方面的要求
、从业务流程的角度或者说从合规角度来说，第一就是我们的业务流程分析，第二是后续的设备性能管理方面的要求。第三是合规方面的要求，最后是运维系统的预防性维护工作
、从日志易的数据收集角度来说，产品可以从支付公司的业务数据，也就是从交易数据抽取，然后可以从运维方面的  数据、安全数据抽取，甚至可以从物联网去抽取一些数据。

图  交易失败及类型统计可视化界面
图  是基于一些测试数据的呈现，因为支付有敏感性的要求，图标显示的  是随便举的一个渠道的简称。其中，对于一些访问，包括一些支付的实地情况可以做一个可视化的分析。上图呈现的一些可视化分析，包括对实时支付进行快速分析，统计其状态码，可以对其进行排名统计，做相关告警监控。伴随产品的深入应用，日志易产品也会被接入到支付全流程分析和监控。

图  图表示例
电子支付如今已渗透入网购、转账、生活缴费、基金债券等居民的日常生活中，关系着国家经济及居民的生活质量，可谓任重而道远。日志易作为国内首家海量日志分析企业，一直致力于开发一款配置方便、功能强大的日志管理工具，以高品质的产品为金融行业用户信息化建设搭建高可靠平台，共同面对数字浪潮中更多的未知与挑战，实现支付企业对日志分析管理产品高效、实时、安全的需求。
更多内容，欢迎关注公众号：日志易腾讯云业务架构师王之捷分享了腾讯云在人工智能、尤其在智能云方面的最新进展，以及如何将这些能力应用到工作当中。
腾讯云业务架构师王之捷
王之捷表示，不断增强的计算能力、日益积累的海量数据，和先进的模型算法作为三大基石支撑并促进了人工智能的发展。
在计算能力方面，腾讯云拥有强大的基础设施，这主要得益于腾云遍布国内的服务器，使得腾讯云能够在大范围使用，同时输出，并且能够在全球个国家和地区能够接触到；在海量数据方面，依托、微信亿级别的用户群应用，每天都能积累超过数千万的图片数据、数十万小时的语音数据和千亿级别的文本量数据，为机器深度学习提供了强大的数据基础；在先进的模型算法方面， 、优图实验室、微信智能语音等，并且在这些领域吸引了数十名国内外专家，使腾讯云的算法能力始终保持在业界领先水平。
尤其在智能语音领域，腾讯云年开始深入研究语音深度学习模型和等，后来则采取了双向，再结合识别，形成模型，再到现在端到端模型，实现了语音和文本的智能双向转换。后来，针对数据量的几何级增长，借助加速的矩阵运算，语音识别的准确率不断提升。在噪音场景下，识别错误率由年的降低到了，对日常口语识别错误率也由以前的下降到；而在标准朗读的情况下，识别错误率更从原来的降低到了，换言之，识别准确率高达，处于业界领先水平。不仅如此，腾讯云独创的创新方法还支持语言模型的并行解码，可以在一套系统上面同时加载多个语言模型，在同时识别的时候自动挑选一个识别效果最好模式，由此解决了垂直领域的定制问题。汇总国外社区相关文章，覆盖 等内容：

            
链接： 
点评：介绍  和   协同工作，体验 所带来的魔力
 
链接：
点评：  顾名思义就是的池化，在网络编程等很多地方都需要这样的一个数据结构，本文介绍的 这个类
   
链接：
点评：人们对  生态系统怨声载道的时候，这篇文章让你看到希望，比任何时候都要兴奋
       
链接：
点评：新版本的   数据提供程序已经支持  当 表示在  发布之前都不会支持的时候，你有理由抛弃选择。
   –   
链接：
点评：这是一系列的 的知识点的视频

      
链接：
点评：大前端是潮流， 通过  全面拥抱大前端各大框架，， 等
     
链接： 
点评：用户刷新页面的时候防止表单的重复提交  模式在 上面怎么玩。
      
链接：
点评：介绍一个  的实用的函数包，可以和作者一起来丰富这个包

     
链接： 
点评：这是为开发人员而写的系列文章，作者已经写了篇，可前往作者博客学习
     
链接：
点评：这是一篇介绍上使用  的安装文章，图文并茂。 月  日，腾讯云安全中心监测到   修复了个严重级别的漏洞， 分别为： 信息泄露漏洞、远程代码执行漏洞，在某些场景下，攻击者将分别能通过这两个漏洞，获取用户服务器上  文件的源代码，或是通过精心构造的攻击请求，向用户服务器上传恶意  文件，通过上传的  文件 ，可在用户服务器上执行任意代码。

云鼎实验室通过对于漏洞描述，搭建漏洞环境，并对其进行复现。此漏洞为高危漏洞，即使是非默认配置，但是一旦存在漏洞，那么攻击者可以成功上传 ，并控制服务器。
复现
根据描述，在  服务器下，将  参数设置为  时，即可通过  方式创建一个  文件，并可以执行任意代码。
通过阅读  文件，可以发现： 远程代码执行漏洞分析及补丁 
默认  为 ，当  设置为  时，可以通过    进行文件操控。
配置  为 ：
启动 ，利用  请求创建文件： 远程代码执行漏洞分析及补丁 
提示 。通过描述中的  受影响，可以结合  的特性。其一是  文件流，其二是文件名的相关限制如  中文件名不能以空格结尾来绕过限制：
访问发现可以正常输出： 远程代码执行漏洞分析及补丁 
分析
 的  是在  配置的，通过配置文件可知，当后缀名为  和  的时候，是通过处理请求的：
而其他的静态文件是通过处理的：
可以得知，“ ”末尾有一个和空格并不能匹配到 ，而是会交由去处理。当处理  请求时：
会调用：
 为：
调用 创建文件：
又由于  不允许“ ”作为文件名结尾，所以会创建一个  文件，导致代码执行。
 分析
然而，经过黑盒测试，当  地址为时，仍然会创建 ，会影响  和  服务器，并且  了之前的补丁，分析如下。
在进入  函数时，会声明一个  变量：
进入  后，会对  进行 

最后得到的  就是没有最后  的  了

影响
由于存在去掉最后的  的特性，那么这个漏洞自然影响  以及  版本。而且经过测试，这个漏洞影响全部的  版本，从  到  无不中枪。目前来说，最好的解决方式是将  中对于  的  设置为 ，才能防止漏洞。

本文作者：腾讯云安全团队，转载请注明来自相信吴恩达公布新项目之一——在线课程已经刷遍朋友圈了，顺带的，连他的生平背景也顺便给缕了一个遍了，科技大本营就不凑这个热闹了。
不过，本着一丝不苟出产干货的原则，今天，我们要来扒一扒，这个课程到底肿么样？

吴恩达亲自上阵授课
欲知真相如何，总得对比着来看。那我们就把大火的搬出来对比一下。
我们采访到了一位此前参与了 “深度学习纳米学位”的资深学员，正好他也刚刚体验完吴恩达推出的深度学习课程，他从视频质量及练习题质量等方面对两者进行了详细的对比。
  
我今年三月份报名参加了  的深度学习纳米学位，经过几个月的学习，基本了解了神经网络、、、 的概念，并且通过五个项目的联系，具备了一定的动手能力。我的体会是， 的这个纳米学位课程，精华在于项目。
坦率的说，他们家的视频课程的理论讲授部分本身并不是很出色，很多内容我听得云里雾里，比如和 的理论介绍部分，说真的有走过场的感觉。但是这个纳米学位的项目作业的设计不得不点赞。五个大项目，每一个都有详细的目标和完备的 。 的内容之清晰，考虑之周到，在我参加过的在线培训课程中无出其右。所有的项目作业都由  的老师手工批改，这一点尤其令人感动，批改细致，不但告诉你对不对，还告诉你为什么，有什么更好的做法。更有趣的是，这些改卷的老师还经常跟我说一些鼓励的话，让我很有成就感。
按照  的要求，你必须反复听课，甚至要参考很多课外资料才能把题目做出来。如果说我从这个过程中学到了一点东西，是被项目逼出来的，不是靠听课听出来的。
在五个必做项目之外，其实课程本身还示范了上十个项目，比如文本生成、股票价格预测等等，我知道有些同学超级认真，也超级有时间，所有这些示范项目也都完成了，想必学到的东西和编程功力会远在我之上。
另外一个要点赞的是这个课程的论坛，非常活跃，超级有爱。
现在吴恩达的课程一上线，我马上就注册了，看了几节课，更重要的是看了一下项目的设计。我曾经上过吴恩达的机器学习课程，对他讲授理论的水平超级钦佩，看上去很复杂的问题，他抽丝剥茧、举重若轻的就给讲明白了。
在这个新的深度学习课里，我非常激动的感到，吴恩达继续保持了他强大的脑波发射力，真的能帮我把理论上的很多不足和坑填上。
从内容来说，其实两个课程覆盖的东西差不多，但吴恩达的课程在结构上明显更具匠心，比如说把 、 这些技术都归于  之下，就非常容易帮我搞清楚它们的定位和关系。而我学习  课程时，搞了半天都不知道这两个技术的目的是什么，还是参考了很多第三方资料才有所理解。
再比如吴恩达课程里专门把超参调校拎出来作为一个模块来讲，这个太重要了。有人说，认为深度学习只是调超参的人，实际上一定是连超参都不会调，所以调超参背后的理论，真的是太重要了。
现在很多技术类课程都以“实战”为荣，以“理论”为耻。我觉得这个态度在深度学习这门课里绝对要不得，因为理论太重要了。理论如果不搞懂，你照猫画虎做几个例子就以为自己掌握了，但一遇到新的问题立刻就会抓瞎。从这个意义上来说，吴恩达的课程如果能够延续自己之前在《机器学习》课程中的理论教授水平，那毫无疑问对我们学习者来说是一个巨大的福利。
再谈谈练习层面。我看了这个课程当中的一些练习，感觉相比于  还是略有进步。
第一是可以在线练习、在线训练、在线提交。 开了一个伴侣网站叫做 ，这个课程的作业以在线  的形式放在这个伴侣网站上，我们在这个网站上昨晚练习之后，点一个键就可以提交了。而  的作业需要自己在本机上做完之后，打包成  文件上传，或由  方式提交，比较麻烦。在这方面吴恩达课程是有优势的。
现在我还不知道当做 、 的时候， 课程是否会自动分配  资源。在  上，我们需要自己去找  资源课程官方推荐了一个  云，但是得自己去注册使用，如果  能够在背后自动动态配置  资源给学员，那就太牛了。
第二是项目练习的题目质量，我觉得目前评价还为时尚早。因为吴恩达课程的第四、第五门，也就是  和  的课还没推出来，看不到他会给学生设计怎样的练习题。但是  的习题还是不错的，特别是，我再强调一遍， 的批改老师真的很负责。
总之，最近这段时间学习深度学习的朋友们心情大爽，前有  的深度学习纳米学位，后有《深度学习》花皮书，现在又来了吴恩达的课程。深度学习者的盛宴时代开始了，酷！
此外，鲁朗软件北京有限公司联合创始人，花伴侣团队机器学习负责人，科技大本营智库专家智亮老师第一时间看到吴恩达课程大纲后，也分享了他的看法：

从课程大纲来看，这次的五节内容最大的特点是两个：
一个是比较新，思路清晰，且全面，基本上涵盖了学术界最新的进展，虽然还属于比较基础和通用的部分，但是和吴恩达原来的机器学习课程相比，已经算是和学术界的接轨了。
第二个特点就是偏工业，目标比较明确，可以培养工业适用的经济适用型程序猿，它的实战项目确实都非常贴近近期的工业焦点，如自动驾驶、医疗等。习题和项目做完之后，确实足够去做相关行业的工作了。
吴恩达有将复杂问题抽丝剥茧讲得很明白的实力，以及他对工业的了解，很可能再次成为一个爆款课程。

那么，吴恩达的课程内容有哪些？课程结构如何？有哪些练习题？
以下是本次吴恩达即将开启的在线深度学习专项课程的详细介绍，科技大本营在第一时间将其全部翻译完毕，来看看吴恩达到底会给想要学习的程序猿们带来什么惊喜？
课程详细介绍
目标：
通过这门课程，你将学会深度学习的基础，弄懂如何搭建神经网络，并掌握如何组织起一个成功的机器学习项目。
具体技能：

你将会学到卷积网络、、、、、、 等；
了解并学习深度学习在医疗、自动驾驶、手语识别、音乐生成、自然语言处理等领域的真实案例；通过这一“机器学习飞行模拟器”的学习，特别是通过其中具体案例的研究，你将获得接近于真实的“行业经验”，并为面向工业界的机器学习研究做好准备；
学到和，并亲手打造最先进的深度学习模型。


此外，每一门课，你都将能听到来自深度学习顶级专家们的分享，他们会讲讲自己的深度学习故事，并为你的深度学习之路提一些建议。
目前，会同英伟达的深度学习研究院  在一些专门的深度学习高等话题上合作，为学生的编程作业提供运算。你将有机会在最先进的工业级环境中打造自己的深度学习项目。
▌第一课  神经网络与深度学习

即将开课的班次：月日—月日
课程学习时间：周，每周小时
字幕：英语



课程概述：如果你想学习最前言的知识，本门课程刚好能帮到你。深度学习工程师正受到高度热捧，掌握深度学习相关知识会为您带来无数的全新机遇。深度学习还是一种全新的“超能力”，能让你做出几年前不可能实现的人工智能系统。

在本课程中，您将学到深度学习的基础知识。学习完本课程，您将：

理解推动深度学习的主要技术趋势
能够构建、训练和应用全连接深度神经网络
知道如何实现高效矢量化神经网络
了解神经网络架构中的关键参数

本课程还会带你了解深度学习事实上的运作机制，而非仅提供粗略或表层的描述。 完成本课程后，你将能把深度学习应用到你自身的领域之中。如果您想寻求一份与相关的工作，学完本课程，您将能够回答一些基本的面试问题。
这是深度学习专项课程的的第一门课。

第周：深度学习介绍

这部分主要介绍推动深度学习兴起的主要趋势，了解当下深度学习应用的具体方面，以及如何来应用它。
吴恩达视频采访： 

吴恩达通过视频采访 截图

第周：神经网络基础

这一部分我们将学习如何用神经网络来解决机器学习问题，学会如何用矢量化来加速模型。

图片截取自第二周课程的 专题在线课程
吴恩达视频采访： 

第周：浅层神经网络

这一部分我们将学习使用前向传播和反向传播构建一个带有隐含层的神经网络。
吴恩达视频采访： 
截取自吴恩达面对面采访 的视频


第  周：深度神经网络

在这部分，你将了解深度学习中的关键计算，使用它们来构建和训练深度神经网络，并将其应用于计算机视觉。
▌第二课  改进深层神经网络：超参数调优、正则化与最优化

即将开课的班次：月日—月日
课程学习时间：周，每周小时
字幕：英语
课程概述：本课程教你的将是如何把深度学习用得更好的“魔法”。深度学习的内部过程不该是个黑箱，您应当理解性能表现背后的因素，进而更为系统地各种优秀结果。 您还将学会。

通过周的学习，您将：

理解打造深度学习应用的行业最佳实践；
能够有效地利用普通神经网络的“技巧”，包括初始化、和退出正则化、归一化、梯度校验；
能够实现和运用各种优化算法，小型梯度下降，，和，并能检验它们的收敛性；
理解深度学习时代设置 训练开发测试 数据集并分析 误差方差 的全新最佳实践；
能够在中实现神经网络。

这是深度学习专项课程的第二门课。

第周：深度学习实践

吴恩达视频采访： 

第周：算法优化

吴恩达视频采访：林元庆

第周：超参数调优、归一化与编程框架

▌第三课  构建机器学习项目

即将开课的班次：月日—月日
课程学习时间：周，每周小时
字幕：英语
课程概述：您将学会如何打造出一个成功的机器学习项目。如果您渴望成为领域的技术领导者，并想弄懂如何团队工作设定方向，本课程将为指明道路。

本门课程的多数内容来自我开发和推广深度学习产品的经验，其他任何地方均从未有教授。本课程还设有两个用于练习机器学习项目领导决策的“飞行模拟器”，能够提供给你只有经历数年机器学习工作实践才能获取到的“行业经验”。通过周的学习，您将：

弄懂如何诊断机器学习系统中的错误
有能力筛选出最有希望降低错误的工作方向
理解复杂的机器学习设置，如 训练测试 数据集的不配备，并能对比 和或 实现超越人类水平的表现
弄懂如何应用端对端学习、迁移学习和多任务学习

我遇到过仅仅因为不理解一些机器学习原则而而浪费数月甚至数年时间的团队，所以我要用一门课程来教授这里的原则，希望这个为期两周的课程能帮您省下这些时间。
本课程是一门独立课程，只要具备基本的机器学习知识就可以参加。这是深度学习专项课程的第三门课。

第周：深度学习策略 

吴恩达视频采访： 

第周：深度学习策略 

吴恩达视频采访： 
▌第四课  卷积神经网络

课程内容及时间安排将在数周内公布
字幕：英语
课程概述：本课程将教您如何构建卷积神经网络并用它来处理图像数据。在深度学习的驱动下，计算机视觉近两年来取得了巨大的进步，从安全的自动驾驶到精确的面部识别再到医学放射影像的自动读取，出现了无数激动人心的应用研究成果。

您将：

理解如何构建卷积神经网络，包括它最新的变体，如残差网络。
弄懂得如何用卷积神经网络来完成视觉检测和识别任务。
弄懂如何用风格转换器创造艺术图像。
能用这些算法来处理各种各样的图像、视频，以及其他或数据。

这是深度学习专项课程的第四门课。
▌第五课  序列模型

课程内容及时间安排将在数周内公布
字幕：英语
课程概述：本课程将教会你为自然语言、音频和其他序列数据构建模型。在深度学习的驱动下，序列算法近两年来取得了巨大的进步，语音识别、音乐合成、聊天机器人、机器翻译、自然语言理解等领域涌现出无数激动人心的成果。

您将：

弄懂如何构建并训练递归神经网络及其常用的变体，如、。
能用序列模型解决自然语言问题，包括文本合成问题。
能用序列模型实现音频应用，包括语音识别和音乐合成。

这是深度学习专项课程的第五门课，也是最后一门。
课程相关信息
国外媒体称吴恩达此次的在线深度学习项目“  ”是迄今为止，最全面、系统和容易获取的深度学习在线课程。登陆可以观看。
日前，门课程中，前门课已经就绪，由吴恩达亲自出镜授课。
课程将按月费收费，每月美元。不过，根据的规则，用户申请的在线课程，前天里可以无限量访问。

目前，天的免费试用已经开启，感兴趣的小朋友可以火速前往课程围观。

不过，这个在线课程在中国大陆无法正常观看，有需要的小伙伴你懂的
附： 深度学习纳米学位课程大纲
部分 ：神经网络
神经网络是深度学习的基石。在这部分课程中，你将学习神经网络的基本原理，并在实战项目中从头开始构建一个神经网络。
部分 ：卷积神经网网络
卷积神经网络是解决视觉问题的标准答案。 在无人驾驶车，面部识别，医学影像等领域，都有它的应用。在这部分课程中，你将了解卷积神经网络的基本原理，并在实战项目中用它来解决图片分类问题。
部分 ：循环神经网络
循环神经网络对预测音乐和文本等有序数据非常有用。利用这个神经网络，你可以生成新音乐，翻译文本，或通过脑电图预测癫痫发作。在这部分课程中，我们将教你如何搭建和训练一个循环神经网络。
部分 ：生成对抗网络
生成对抗网络是无监督学习的一种。在生成对抗网络中，两个神经网络相互竞争，通常可用于生成图像数据。在这部分课程中，你将学习如何搭建自己的生成对抗网络，并让两个神经网络互相竞争。
相关链接

 月  日， 北京分会会员、 联合创始人兼  黄东旭作为  线上分享第二季嘉宾，与超过  位  会员交流了自己在开源软件和创业方面的感悟。本文为根据口述内容整理的实录。

口述｜黄东旭
整理｜赵新龙
为什么要做开源和基础软件
我是黄东旭， 联合创始人和  。今天刚好回想起来，我拥有第一台电脑是在  年的，到今年  年，我编程刚好  年。而且今天也是   正式版发布的日子，在这个日子分享，我觉得蛮有纪念意义的。
我是一个基础软件工程师，一直在做分布式系统和数据库相关的研发，之前我在豌豆荚期间完成了一个使用比较广的开源分布式缓存方案  ，很多朋友之前也是通过  认识我的。
缘起
我最早是在豌豆荚基础软件团队维护  集群时有了这个想法。当时豌豆荚的整体技术架构比较朴素，上层用  支撑分布式缓存，底层数据库是  和一部分  。当时  大概有  个分片，就是最传统的分库分表。当时豌豆荚还没有全职   ，维护  就由我们基础架构团队负责。
当时我们非常痛苦，每一次数据库扩容和调整都感觉要掉一层皮。主生产库不能容忍停机，同时每一个分片有自己的储备，扩容一次不仅要把主节点拆分，还同时要在业务层上做拆分；而且在业务层有很多的工作，比如说语句的所有请求必须带着   ，不能做  的事务或者稍微复杂的查询。当时大家很希望有办法解决这些问题。
我跟另一个合伙人刘奇，现在是   ，都在豌豆荚的基础架构团队，当时就想做一个  中间件解决这个问题。这有点像   了。我们做了一段时间，发现做出来既没有太多的创新，也不会彻底解决问题，当时干得还挺不开心。
那段时间我们看到了   的论文，觉得未来的数据库应该是这样的。我们希望能够有这样的东西，解放后端程序员，解决关系型数据库在面对海量数据高并发时的扩展性问题。
然后我们就开始做这个数据库。
蹒跚学步
我们从第一天就坚定地要走开源路线。我们研究了国外有名的开源项目是如何发展起来的，包括  、 、 ，同时我们在  项目上也积累了一些国内社区运营经验。
公司头三个月都是三五个人的状态，早期员工都是我们三个创始人的前同事和朋友，没有依赖猎头，也没有依赖第三方的中介。早期我们的目标非常简单，就是写代码。整个阶段大概持续半年，我们开源了第一个  版本。
说起来非常好玩，第一个  的版本是不能存数据的，只开源了  协议处理层跟一个简单的  优化器，数据只能存储在本地，并不是一个真正的分布式的数据库。当然了，现在我们已经是完整的分布式数据库。
我觉得做开源就是这样，不是一下子把所有东西做好，而是一步一步让开发者社区看到进展，这一点非常重要。所以当时我们就决定在第一个可以  的版本就把整个代码开源，看看社区有什么反馈，在社区发发声音，同时开始组织线下的一些技术  聚集人气。
通过持续的分享，我们逐渐在社区积累了外部贡献者，也有了几个试用的客户，比如当时华为的一个团队对项目非常感兴趣，也投入工程师参与开发。我们慢慢积累了社区影响力， 年底完成  万美金  轮融资。这时候，距离公司成立一年多，公司逐渐变得比较正规，不再是“软件作坊”。
小步快跑
 轮完成之后，我们加快人员结构调整，开始扩大工程师团队。开源有个好处就是，好的项目会让很多人快速知道，在社区有影响力，很多能力不错也一直在贡献代码的工程师对项目非常感兴趣，他们本身是我们公司很好的人才储备。
我们从社区里“招安”了一些优秀工程师，吸纳到  开发团队。最开始的  个人持续了一年左右，从  个工程师到  个工程师也用了差不多一年，这段时间正好是项目从比较粗糙变得完整精致的转折点。到现在，每个核心组件有  到  人团队负责，他们本身是社区贡献者，同时是  员工，全职工作就是提交代码、在社区讨论、跟社区协作制定未来的开发计划。另外有大概差不多  人的工程师团队主要做商业产品、商业化周边工具等。
我们在  年  月发布了  版本，今天  年  月  日正式发布了   版。现在也基本完成了美国的分公司的事情。
为什么要出海？
在中国，大家会遇到  的扩展性问题，在美国也会遇到。所以这两个市场对于基础软件公司来说，不会像  端产品公司那样难以复制或者难以进军海外。基础软件领域是没有国界限制的，这是我们的优势。
开源项目怎么运营
在过去很长一段时间理，中国都没有在世界范围内的特别成功的开源项目。
我觉得这是有原因的。很多早期知名的开源项目，比如  、 ，都是国外草根开发者出于个人兴趣而投入大量时间和精力做出来的；运转过程中，开发者重度参与开源项目，也都是自发和出于兴趣。我称之为开源  。
这种模式不适合中国国情。在国外，整个社会是类似于  为主的文化，开源社区里的协作模式跟现实生活非常像。而中国是没有类似的文化背景的。另一方面比较实际，国外工程师的时间挺多挺宽松，国内工程师和开发者很难凭兴趣爱好在业余时间重度参与非常庞大的项目。另一方面，技术能力和语言可能也是一个问题。
最近几年，开源社区构成有了非常大的变化。很多主流开源项目背后都有商业公司支持，甚至项目本身就是商业公司发起，比如  背后的  、 背后的  和  ，以及最近上市的  背后的  公司。这一类开源项目，我称为开源  。这时候，开源软件的发起不是纯粹的开发者个人兴趣，而是有商业公司把开源作为很好的开发模式和市场手段。
回到开源社区的运营，我觉得  并不是简简单单的   ，把代码开源出来、把代码放到  上就行了。
介绍一下我们早期是怎么做的：

在项目开始阶段，我们的文档比代码还要多。这个阶段需要把项目的理念和设计详细的展示给社区。   开始国际化，最早的  没有中文文档，所有的注释和每一个  提交记录必须是英文，所有的设计文档都要放到  上。早期使用者有问题会直接微信或者邮件联系我，我也建议他们把问题放到 。我甚至会帮早期提出  的人，把中文翻译成英文。
珍惜每一个  。即使提交非常小的   ，可能就是改一行文档、改一个标点符号，我都会亲笔为他写一个明信片，还有赠送水杯或者恤。没多少成本投入，贡献代码的朋友会有荣誉感。
严格的   流程，摆在社区面前，通过  和代码测试覆盖率量化代码质量。

开源项目怎么挣钱
这个问题是我被问过无数遍的。
每一个开源项目的挣钱路径是不一样的。代码本身一毛钱都不值。一个开源项目挣不挣钱，不取决于是否开源，而是取决于项目本身面向的市场是什么样的、面向的人是什么样的、背后的商业价值是什么样的。举个例子，比如  的挣钱路径一定是跟  、 和  不一样的。这很好理解，容器跟数据库是两个不同的类别，它本身的商业价值跟开源没关系。
有了这个前提，讲一下我们认为数据库或者存储资领域的商业模式是个怎么样的。现在主流的盈利模式大致有两种，一种是内核开源，企业版和周边商业工具收费，比如  、数据导入导出迁移工具、安全、审计、自动化部署的套件。
开源的数据库本身是可以随意使用的，如果在核心生产系统里面用到关键数据库，业务数据非常重要而你用的是社区版数据库，这时候很多公司要不成立  团队，要不就找商业公司购买服务。这种模式是比较传统的卖  ，或者卖服务的模式。这种模式的大的问题在于，基本上是一锤子买卖。我卖一批  ，后续就只能收维护费，维护费可能跟  不太对等。
另外一种我比较推崇的商业模式类似于订阅。比如和云厂商合作或者私有部署，你在云上可以无限制地使用我的数据库或者开源软件，你要为占用的资源付费，有点像订阅模式 —— 我每个月或者说每半年有一个  。乍看之下跟卖  差不多，对于创业公司来说， 能保持比较健康的现金流。
我们的类似  的模式目前不限制用户环境下的使用规模。我已经订阅了，那我用   和   都是一样的价格，我可以把尽多的数据放到你的平台里面。这种模式对大的用户更加友好如果我们的维护和支持自动化程度越高，  部署和   部署区别不大，而且对我们来说更能锻炼产品，对用户来说更放心的使用，不用担心用超了。如果是  模式，业务缩减了，购买了  个 却只用着三个，对用户来说是浪费。订阅模式是更符合时代的、新的商业的模式。
代码本身并不值钱，只有用户在使用、用它解决问题的时候，你提供的服务、你提供的价值能被用户长期认可，你的开源项目提供了什么东西能让用户有黏性，这是值钱的。
中美企业服务市场的差异
大家都基本上去默认中国的企业服务市场是并不挣钱的，但是我倒是觉得这个假设可能快过时了。
我先分析一下为什么大家觉得过去中国的企业服务市场不挣钱，或者说不是一个特别好的生意。过去，中国做企业服务的厂商基本都是软件集成商，这样的大型  经销商的竞争力是做产品的整合和周边开发。简单来说，他们的商业模式是卖人，招一些工程师，快速把产品做出来满足用户需求，算是外包模式。外包模式的问题是他难以复制，或者说很难扩展。因为每一家的需求都不太一样。
中国没有  这样的大公司，有几个原因。一是过去  年中国开发者整体水平不是太高，很难做出有核心技术竞争力的产品，另外就是过去中国不够尊重  知识产权，盗版是一个长期问题，还有就是过去大家都喜欢自己造轮子，因为中国工程师在过去非常便宜，对于公司来说，我养一个团队、我自己去做，整个成本反而是更低的；我在外面找到软件供应商，产品质量也参差不齐，还可能涉及到跨公司跨项目协作的各种扯皮。
这就导致过去中国软件行业基本上是渠道导向、销售导向甚至关系导向的市场，并不是产品导向。这样活生生把毛利特别高的企业软件行业变成了毛利特别低的行业。
美国商业环境比中国好，法律制度非常健全，公司都比较具有契约精神，这是第一。第二就是，销售本身虽然重要，但核心还是产品。在美国，可能是一个很小的公司，如果你的产品确实满足客户需求 ——  阶段可能在客户那边做，测试持续时间可能会比较长，但是一旦测试通过的话，基本上事情就成了。
而且在美国，软件预算不会跟硬件绑定，为软件付费的概念是在国外是比较根深蒂固的。
不过我们观察到在，中国在发生一些变化。第一个变化是互联网公司有钱了。过去很多人都奉劝我，不要做互联网公司的生意。但是我发现，现在很多  和  都会算账，产品质量和服务都不错的情况下，自己造轮子的成本跟购买技术软件提供商的成本对比一下，很明显的购买服务是更划算的。
另一方面，也不是一下子能招到合适人选，何况工程师薪水也是水涨船高。第二个是，中国的人力成本慢慢向美国靠拢，这就给企业服务带来巨大机会。美国的企业服务市场是中国的  倍，中间存在巨大利差。过去中国不太接受企业服务是因为人太便宜，当人力成本上升到企业主不能忽视的级别时，购买软件服务会成为主流。这是中国的优秀企业服务公司的好机会。
而且， 目前的付费用户大多数是互联网相关行业的公司。
如何看待云的崛起
现在中小型公司完全上云是大势所趋，称得上是“标准答案”。技术软件公司必须顺应云的时代，云化自己的产品。很多开源软件作者一直认为，公有云是开源软件最大敌人。举个例子， 从  挣的钱，根本连亚马逊从  上挣的钱的零头都不到。那么  给  贡献了多少代码、投入了多少工程师维护？很少很少。有人说公有云有点像吸血鬼，一边在用开源软件，一边大把挣钱。
话虽然如此，但是云化是不可逆转的趋势。我是坚定地相信云，相信未来一切都是在云上的 —— 开源也好，闭源也好，公有也好，私有也好， 基础设施一定是在云上。所以要做的就是，怎么让你的开源软件来适应云，你不能说我的软件只能跑在我的专用机房或者我的专有硬件，一定要是云化的，  的。
眼光再放稍微长远一点，未来大家一定都把基础设施网云上迁移，但是真正有钱的企业和大企业不可能把自己绑定在一个云提供商上。他一定需要在几个公有云  之上提供一套独立第三方的统一的数据访问接口，它不可能被一个云的私有方案绑定。这就是开源软件或者说开源公司的比较大的机会。开源软件的优势，是独立于云、独立于云提供商的解决方案，比如说我可以去用  的数据分析服务，但是我也可以去用  来做分析，用  的话，我可以平滑的迁移到  或者  上。或者，我的数据可能是跨云存储的，一来提供了更大的灵活性，二来对云服务提供商有了更大的议价能力。
比如摩根斯坦利没有选择   而是选择了  —— 如果他完全绑定  ，他以后就丧失了很多话语权，比如他想切换到   就很难。所以跨云的数据同步和跨云的需求方面能产生很多的开源软件，而且这是开源软件独有的东西。这上面可以做很多文章。
我的观点是，需要想办法跟云做好沟通或者说保持合作关系，并不是说云就是你的敌人，或者云会把你吃掉。我觉得还是需要合作，这种合作的态度比较重要。

：你在  创业踩过什么坑吗？怎么解决的？
我可以分享两个坑，一个是技术上的，一个是商业上的。
第一个是技术上的坑。我们当时打算把  层写出来以后直接对接  ，对外发布第一个版本，投入了我本人一两个月的精力一直再去做事情，但是后来没有什么效果。后来想想，在  上去实现第一个分布式的存储引擎，基本是无用功。我得到的启示就是，开源项目一切都要维护围绕主线目标。很多人会告诉你我需要功能、我需要功能，我的需求非常急迫……经常会有这样的诱惑，而且大家不好意思拒绝，这就可能导致错误地投入到并没有什么收益的方向上。好在我们看到问题后及时止损，果断转回主线方向。
第二个是商业上的坑。我跟刘奇   都是码农，我们没有在国内做商业化的经验，也没做过生意。当时国内不少集成商和一些比较传统的企业来找我们，说一起合作或者搞些什么，经常有比较虚的合作。在早期没有判断得特别准确，投入了一些精力。在早期阶段精力是非常宝贵的。至少到现在为止，我们最重要的目标是技术、产品的质量和社区。比如当下能挣快钱的事情 —— 我们以前可能会妥协，现在不会了。创业公司贵在专注和快。
：公司团队异地协调一直是个难题，想问一下咱们开源公司是怎么解决的？有哪些软件、工具或者方法？
我们是特别典型的异地协同公司，差不多一半工程师是分布在全球各地的。我觉得这个问题会因公司而异， 本身的产品形态是数据库，可能跟其他公司会有不少区别。
文档协作全部采用  
远程协作团队的沟通成本非常高的，不可能没件事情都    地沟通，甚至多说几遍也无所谓。我们的文档协作全部采用   ，不同人可以  ，还可以大家协同编辑。同时讨论结果必须得转成  文档放到  上，要求一切讨论都需要落地。
重度依赖 
 是我们所有消息的中转平台，包括项目持续集成、  、跟社区成员的交互信息都会汇总在  。它既是我们的聊天工具，也是公司内部的  。同时，我们也在用  ，用于追踪客户进展和做重要的会议记录，它可以很好地跟  做整合。
以自动化和工具化替代人工操作
我们花了很多时间做持续集成、自动化测试和   等东西。我们现在基本上做到了，每提交一行代码，不需要找人   ，不需要找人手动测试，一切环节和流程都是自动的。你提交了代码，马上就在  上看到自动化构建的项目在  ；测试成功还是失败，代码覆盖率是多少，一目了然。如果代码审核没有通过，那么代码合并按钮是无法显示绿色，是无法点击提交的。一切需要人工保证的流程，我们尽可能把它变成自动化和用工具实现的。当前为了满足比较火热的移动  端直播需求 一系列的  直播技术迅速的发展了起来
常见的可用于  的直播技术有   与  今天我要向大家介绍一下  与  相关的内容 并在最后通过一个实际的例子 来展示其具体的用法
大纲
 协议介绍

   介绍

 介绍

 介绍

 展示




通常的  应用都是围绕着  的请求响应模型而构建的 所有的  通信都是通过客户端来控制的 都是由客户端向服务器发出一个请求 服务器接收和处理完毕后再返回结果给客户端 客户端再将数据展现出来 这种模式不能满足实时应用的需求 于是出现了   等 “服务器推” 的长连接技术
 是直接基于  连接之上的通信协议 可以在单个  连接上进行全双工的通信  在  年被  定为标准   并被  所补充规范   被  定为标准
 是独立的创建在  上的协议  协议中的那些概念都不复存在 和  的唯一关联是使用  协议的  状态码进行协议切换 使用的  端口是  可以用于绕过大多数防火墙的限制

 握手
为了更方便地部署新协议， 引入了  机制 它使得客户端和服务端之间可以借助已有的  语法升级到其它协议 这个机制在  的    一节中有详细描述
要发起  协议升级，客户端必须在请求头部中指定这两个字段
 
 
如果服务端同意升级 那么需要这样响应
   
 
 

      
可以看到   响应的状态码是   并且响应正文可以使用新协议定义的数据格式
 握手就利用了这种   机制 一旦握手完成，后续数据传输就直接在  上完成
  
目前主流的浏览器提供了  的  接口 可以发送消息文本或者二进制给服务器 并且接收事件驱动的响应数据
 检查浏览器是否支持 
 {
     代码
}
 建立连接
  =  
 注册回调函数以及收发数据
分别注册  对象的    以及  回调函数
通过  来进行发送数据 这里不仅可以发送字符串 也可以发送  或  类型的数据
如果接收的是二进制数据，需要将连接对象的格式设为  或 
 = 
  
服务器端  库我推荐使用  自己的   可以非常方便的与  一起使用
可以将  的   通过  转换成   这样就可以跟  库一起使用了
然后通过  来接收数据 通过  来发送数据
具体代码可以看下面的  部分

在介绍  之前 我们先看看   和有哪些限制
和标签的限制

不支持流

不支持  和加密

很难自定义控制 以及保持跨浏览器的一致性

编解码和封装在不同浏览器支持不同

 是解决  的流问题

    是一个主流浏览器支持的新的    是一个  标准 允许  动态的构建  和  的媒体流 他定义了对象 允许  传输媒体流片段到一个 

通过使用  你可以动态地修改媒体流而不需要任何的插件 这让前端  可以做更多的事情 我们可以在  进行转封装 处理 甚至转码
虽然  不能让流直接传输到   上 但是  提供了构建跨浏览器播放器的核心技术 让浏览器通过   来推音视频到   上
现在每个客户端平台都开始逐步开放流媒体相关的   平台有   平台有    而  上对应的就是标准的  由此可以看出 未来的趋势是在客户端可以做越来越多的事情
 
通过  来检查是否浏览器支持情况

通过 可以进一步地检查   类型是否支持
比较常用的视频封装格式有  和 
 和  是两个姊妹项目 都是由  赞助的 由于  是基于  的容器格式 所以天生是流式的 很适合用在流媒体领域里
下面着重介绍一些  格式
我们都知道  是由一系列的  组成的 普通的  的是嵌套结构的 客户端必须要从头加载一个  文件 才能够完整播放 不能从中间一段开始播放
而  由一系列的片段组成 如果你的服务器支持  请求 那么 这些片段可以独立的进行请求到客户端进行播放 而不需要加载整个文件
为了更加形象的说明这一点 下面我介绍几个常用的分析  文件的工具
 原名  是一个媒体开发框架 在其源码下有大量的媒体分析工具可以使用  是  的  版本 一个专门用于  的分析工具在线  文件分析工具    
下面一个   文件通过  分析后的截图

下面一个   文件通过  分析后的截图

 在今年的  大会上宣布会在     的  中支持 
值得一提的是    其实都是类似的东西
  
从高层次上看  提供了  一套   来构建 `   一个拼接和缓存模型  识别一些  流类型            `
 内部结构

 本身的设计是不依赖任务特定的编解码和容器格式的 但是不同的浏览器支持程度是不一样的 可以通过传递一个  类型的字符串到静态方法  来检查
比如
  
  
 =   
获取    的方法可以通过在线的  或者使用命令行  |  
可以得到类似如下结果

❯  |  
      
      
当前    的  容器在所有的浏览器都支持
普通的  文件是不能和  一起使用的 需要将  进行  化
检查一个  是否已经  的方法
  |  \
如果是  会显示类似信息
❯   |  \
 =
 =
   =
     =
       =
       =
     =
       =
       =
             =
     =
如果已经  会显示如下类似信息
❯   |  \ |   
 =
   =
     =
       =
       =
             =
     =
       =
       =
     =
       =
       =
     =
       =
       =
   =
     =
 =
   =
 =
 =
   =
 =
 =
   =
 =
 =
   =
 =
 =
把一个   转换成 
可以使用  的 来转换
对于原始文件为非  文件
  _      __ _
对于原始文件已经是  文件
  _  __ 或者使用 
  


   展示利用  和  实现一个点播服务

   展示利用  和  实现一个直播服务


  
       
  
       


来自：我的排查思路
        找占用
没有占用，找占用的文件句柄  |  
重启大法试一试
解挂除根 和  的挂载点，然后   
记一次根分区满的服务故障排查记录
有台运行的机器，的根分区不要问为什么是，这么小
突然报根目录没空间啦，好吧，赶紧上来处理，根满会影响许多服务异常
先进行第一步      所有空间的占用都不够，当然  这个目录例外，我已经挂载了独立的分区
然后第二步，使用   |   没有可疑的占用文件

好吧，试试重启大法 有些时候系统需要彻底重启才能释放文件
后，根目录依然人行我素，还是占用。
最剩下最后一招，解挂除 以外的挂载点
注释

手动解挂点
   `  `

     

然后   
   文件
  
 
果不其然，被挂载后的目录给隐藏住。

那为什么会造成这次故障呢？
看 目录下的文件，是的程序写入的大量数据文件
推测是  的设备  未挂载前，就已启动。
因为根目录下  这里是挂目录下的文件 是空目录，类似 这样的 目录。
仍然能启动，它只是视作它为一个新的逻辑目录。云计算正在经历全新的变革，在强大的计算力之上，业务场景正在驱动技术的创新与变革。月日，腾讯云正式发布第三代云服务器矩阵，最新的计算、存储、网络和异构计算实例首次亮相。截至目前，腾讯云提供的云服务器矩阵包含了款实例，全面覆盖电商、视频、游戏、金融、基因测序、智能语音、汽车、医疗、物联网等种业务场景，开启全行业的计算提速。
全新实例闪亮登场  构建全栈式解决方案
云服务器是云计算服务中的最基础的模块。针对不同业务场景的实际需求，腾讯云云服务器产品矩阵为用户提供了业界最全的实例选项。用户可以根据业务需要，基于不同实例构建业务。

▲腾讯云云服务器矩阵
在通用场景下，腾讯云基于新一代的 推出标准型、计算型和内存型等三款新实例，其计算性能整体提升，并提供最高的内网带宽，网络收发包性能相比上一代提升倍。基于 系列的实例，提供最高核规格的实例配置，有效满足客户对超大核数的计算需求。
面向存储业务场景，腾讯云推出大数据机型和密集型两款新的存储优化型实例，大数据型实例采用吞吐型本地盘，顺序读写带宽最高可达，相比普通本地盘提升倍适合对磁盘吞吐要求高的大数据业务；密集型实例则采用本地 硬盘，随机最高可达 ，相比本地盘，随机读写提升倍，适合给对性能要求高的业务使用。
针对网络性能要求高的业务场景，腾讯云推出新型网络优化型实例。该实例采用新型智能网卡，把原先在宿主机上虚拟交换机的实现到智能网卡，通过硬件来加速包转发，使网络转发性能从原有的提高到，以及高达的网络带宽，网络延时大大降低，实现接近物理网卡的网络延时。这既可以满足用户高速计算的需求，也让用户能够在虚拟化网络中得到媲美物理机的性能体验。
在云盘产品上，腾讯云基于新一代的块存储技术推出两款新的云盘产品。其中，主打高性能的超高性能云盘，相比较现在的云盘，从 提升到，性能提升 倍，能有效满足大型关系数据库、数据库等业务场景中对云盘高的性能要求；而主打高吞吐的吞吐优化云盘，相比较现在的普通云盘，其最大吞吐从提升到，提升５倍，满足大数据等业务对云盘高吞吐和数据安全性的双重要求。
在异构计算上，腾讯云将会推出一款新型计算型实例，这款实例搭载新一代  和最新一代英伟达  卡，单机最高支持卡，在计算性能上相比较第一代实例将会有一个极大的提升，单精度浮点运算性能将提升倍，双精度浮点运算性能将提升倍，将计算性能推向极致进一步加速人工智能应用在各行业的落地。
而作为国内在云服务中走得最快的云服务商，腾讯云还将推出两款新一代的计算实例，其中基于赛灵思 卡的实例，单机最高支持卡，每块卡大约包含万个逻辑单元，个数字信号处理引擎， 峰值计算性能相比前一代实例提升倍；基于  卡的实例，单机最高支持卡， 每块卡大约包含万个逻辑单元，个数字信号处理引擎，单精度浮点运算性能达。
、存储、网络全面升级 “三位一体”激发更强计算力
腾讯云始终致力于加速云计算的进化过程。在技术上，腾讯云的第一代云服务器，采用第一代虚拟化架构，搭配腾讯云自研的云管理平台，支持腾讯云开服初期的网站服务；从第二代云服务器开始，整体架构设计进化为“全万兆双网络”，在计算、存储和网络能力方面进行了升级，首次加入了异构计算，大幅提升了计算性能和系统稳定性，为电商、视频、游戏、金融等领域的客户提供服务。

第三代腾讯云服务器则进行了更加彻底的技术革新与升级，它基于  至强处理器，全面支持双网络环境，并采用了诸如分布式块存储技术、网络虚拟化技术和虚拟化技术等一系列业界领先的技术。
升级：定制化全新处理器平台　腾讯云第三代云服务器采用腾讯云定制  至强处理器，最高睿频可达。与过往采用至强系列处理器的云服务器相比，使用定制化处理器的新一代云服务器具有更高计算性能、更大内存带宽、更强存储性能、更低网络时延等优势。
升级：全面拥抱网络环境数据中心的网络架构正在从万兆转向，网络环境将成为构建下一代数据中心网络架构的主流。腾讯云第三代服务器将在今年下半年全面铺开网络环境，内网带宽将扩大至，包转发率提升超，时延约降低，能全面支持游戏业务、视频业务、金融分析等实时性要求高的业务场景。此外，腾讯云还在实验室环境下展开了网络建设。
升级：分布式块存储技术　得益于网络的大带宽传输，采用基于的超高性能网络框架的第四代分布式块存储技术带来了存储性能的全面提升。新推出的超高性能云盘，其高达，性能提升倍，能有效满足大型关系数据库如、 、数据库、、数据检索场景如 、等业务场景中对云盘的性能要求。此外，新推出的吞吐优化云盘的峰值吞吐性能可达，性能提升倍。
升级：网络虚拟化技术　腾讯云采用智能网卡实现网络性能加速，提出基于智能硬件的第二代网络虚拟化方案，推出国内首款基于智能网卡的云服务器实例——网络优化型实例，完美解决了传统虚拟化网络绕行到母机网卡的问题，使得网络收发包性能提升倍，性能高达万。
升级：虚拟化技术新一代虚拟化技术能够支持更多的硬件虚拟化，提供更加丰富的功能。与此同时，它支持超高速热迁移，秒内可以完成不同物理机间实例漂移，让腾讯云成为业界首个大规模稳定应用热迁移的互联网云厂商。
技术革新与生态建设并举 为产业智能未来赋能
随着基因测序、智能语音、无人驾驶、物联网等一系列新兴应用场景的不断涌现，企业对于计算力的需求正在发生转变。以构建更强计算力，为产业智能未来赋能为出发点，腾讯云积极采取技术革新与生态建设并举的开放战略，联合更多合作伙伴提供更好的企业级计算服务，让更多业务场景能够在云中落地。
以为例。长期以来，由于开发过程需要使用、等抽象程度低的硬件描述语言，开发难度比较高。此外，硬件成本高、灵活性差、一次性采购投入大，需要高昂的费用和巨大的精力进行的定制和采购。为此，腾讯云联合第三方合作伙伴来构建云生态，提供一系列优秀的压缩、加解密、图片处理、视频编解码、基因算法加速等，用户只需要调用就能轻易集成加速的功能到自己的应用里。
一方面，这让开发者享受到云主机性能优越、开发便捷、计费灵活的技术红利，把开发从传统的硬件迁移到云上。另一方面，通过建立和壮大第三方 市场，让第三方开发者可以将他们的以服务方式在 市场上对外提供，而应用的第三方开发者可以很方便地从 市场获取到资源，应用的第三方只需要专注在上层应用和服务开发上，而不需要再关注编码、调试等繁琐细节。
腾讯云计算产品中心总监沙开波介绍，腾讯云正通过解决云服务器的部署、提供者分享以及开发者购买等核心问题，以推动开发者生态的构建与完善。腾讯云率先在国内搭建起了一个简单、可靠的 市场，不仅让创新的思路和优秀的解决方案在市场不断涌现，还帮助更多用户以更加经济、便捷的方式享受到带来的价值。”
“计算是一切云端上层业务落地的基础。作为腾讯‘连接一切’的重要基础设施，腾讯云致力于以云为原动力，连接智能未来。凭借领先的技术、深厚的基础设施以及丰富的互联网服务经验，我们能够针对不同应用场景提供定制化服务。”沙开波表示，“通过不断日益丰富的第三代云服务器产品矩阵，我们将携手合作伙伴为下一代云基础设施提供坚实的基础，创造高性能、高稳定性的弹性伸缩的计算服务，全面赋能各类新兴应用，加速企业业务转型的步伐。”
是一套基于协程和驱动的高性能框架，可以帮助开发者快速开发和部署具备高吞吐能力的服务。
具备以下特点：

基于，相比等语言具有更高的开发效率

基于强大的异步、定时器能力，极大的扩展了框架能力

实现了协程能力，通过同步的开发方式就可以实现异步的能力

支持服务监控恢复能力


经过内部多次迭代开发，即将升级到版本，将带来更多特性，敬请期待！
基于协程和驱动的高性能框架 正式开源
地址：
请给  一个 ！欢迎提出你的  和 作者：李跃森

年月，腾讯云对外发布云数据库，提供腾讯自研的内核优化版和社区版两个版本，以及提供分布式集群架构分布式集群内部代号两种方案。
本文将重点介绍，是腾讯的数据库团队基于开源数据库开发的分布式关系数据库集群，作为平台重要的数据库产品能力，用户可在云端轻松设置、操作，且无需负责基础运维工作，以及为灾难恢复而进行的数据备份。
、分布式集群：
腾讯是由社区版本地化而来，能支撑水平扩展数据库集群。虽然很强大，但在性能、扩展性、安全、运维方面还是有明显的瓶颈，而腾讯经过多年的积累，在这些方面都有较大提升和强化。一般用于金融行业等核心数据库，腾讯被定位为安全、高效，稳定，可靠的数据库集群。那么做了哪些优化和改进呢？
事务管理系统的优化：
在事务管理系统方案本身有一个明显的缺点，那就是事务管理机制会上成为系统的瓶颈，  全局事务管理器会限制系统的扩展规模。如图所示，是每个请求过来 协调节点都会向申请必需的全局事务和全局快照信息，并把这些信息随着语句本身一起发往数据库节点进行执行。另外，的管理机制，只有主才会获取的，而备没有自己的，因此无法提供只读服务，对系统也是不小的浪费。
▲图
而腾讯改进了事务管理机制，改进后，不再从获取和，每个节点使用自己的本地事务和快照，如此便不会成为系统的瓶颈；并且，备机就还可以提供只读服务，充分利用系统闲置资源。如图，优化后的事务管理系统架构如下：
▲图
备机只读实现与优化：
当然，事务管理系统的优化为进行备只读提供了基础，然而原始集群并没有负载、调度等能力。在这方面，我们也做了大量的创新，总结起来包括：

正常和只读进行分离；
正常存储主用的元数据信息；
只读存储备用的元数据信息；
之间使用 热备份保护模式进行日志同步。

通过这些方式，集群可以提供带有智能负载能力的备只读功能，充分利用系统资源。
▲图
业务最小中断的扩容方案：
业务的快速增长不可避免的需要对资源进行扩容，社区版本的实现使得扩容成本高昂，需要对业务进行长时间的中断。因为，在社区版本中，通过“  =  ”的方式决定一条记录的存储节点：
也就是说，先对分布列计算值，然后使用这个值对集群中的节点个数取模来决定记录去哪个节点如图。
这种方案简单，但实际应用中需要长时间停机扩容。这是因为，扩容后节点数会变多，数据无法按照原有的分布逻辑进行读写，需要重新分布节点数据。而再均衡数据需要停机并手工迁移再均衡到各个节点。对于规模较大的交易系统来说，由于原有节点存储的是海量数据，再均衡过程可能会持续好几天。相信这是业务完全无法忍受的。
▲图
因此我们引入了一种新的分表方法— 。的数据分布采用如下图的方式：

引入一个抽象的中间层 。 中每一项存储和的映射关系；
 中的每条记录通过   来决定记录存储到哪个，通过查询的存储的；
每个上存储分配到本节点信息，进而进行可见性的判断。

通过上面的方案，在扩容新加节点时，就只需要把一些中的映射到新加的节点，并把对应的数据搬迁过去就可以了。扩容也仅仅需要切换中映射关系的，时间从几天缩短到几秒

▲图
数据倾斜解决方案：
数据倾斜是指，在分布式数据库系统中会因为物理节点、或分布原因，导致某些物理空间不足，而另外的物理空间剩余较大。例如，如果以商户作为分布，京东每天的数据量和一个普通电商的数据量肯定是天地差别。可能某个大商户一个月的数据就会把一个的物理空间塞满，这时系统只有停机扩容一条路。因此我们必须要有一个有效的手段来解决数据倾斜，保证在表数据分布不均匀时系统仍然能够高效稳定的运行。
首先我们把系统的分为如下图，每个里面：

包含一个或者多个；
每个有一个；
在建表时，可以指定存储的，也就是要么存储在，要么；
可以访问所有的，而且上也存储所有表的访问方式信息。

▲图
对于系统中数据量较大用户进行特别的识别，并为他们创建白名单，使用不同的数据分布逻辑如下图：普通用户使用默认的数据分布逻辑，也就是：
 =   
大商户使用定制的数据分布逻辑，也就是：
 =     _  
▲图
通过在大商户分布逻辑中加入日期偏移，来实现同一个用户的数据在内部多个节点间均匀分布。从而有效的解决数据分布不均匀问题。
下面是一个例子如下图：

多数据记录高效排序解决方案：
业务在列表查询场景下会收到如下的查询：

假设这样一个场景，需要面向一个月高达数据级数据进行快速排序，而且业务逻辑要求需要秒级输出，快速获取排序结果。

为此，我们提供表定义方案，即建立集群分区表。根据上述需求，可以采用按月分表，即每个月一张表，并对排序字段_建立索引，这样每个分区进行扫描是可以使用索引。

我们再通过一系列执行计划的优化，下推 和 子句到；上在执行对应的使用使用 算子对各个子表执行的结果进行汇总输出，这个算子本身会保证输出是有序的，也就是说对子表进行索引扫描，同时 又对各个子表的结果进行归并，进而保证节点本身的结果是排序的。对多个的结果同样使用 进行归并，保证整个输出结果是有序的，从而完成整个排序过程。
下面是我们对排序进行的性能测试结果：
通过在核，内存的机型上进行测试，数据的排序在最短可以在 内完成，最高可达。
并行优化：
随着当前硬件的发展，系统资源越来越丰富，多大内存成了系统标配，充分利用这些资源可以有效的提升的处理效率优化性能。腾讯在年底开始进行多核执行优化。
目前社区版也会包含部分并行化特性，但是没有我们这边这么丰富，下面介绍下腾讯并行化的原理和效果：


系统创建一个全局的共享内存管理器，使用管理算法进行管理；
系统启动时创建一定数据的，这些用来执行执行计划的碎片；
系统会创建一个计划队列，所有的都会在任务队列上等待计划；
每个对应一个任务结果队列，在输出结果时就把结果的指针挂到结果队列中去；
计划队列，结果队列，计划分片执行结果都存放在共享内存管理器中，这样所有的进程都可以访问到这些结构；
会话进程在收到时，判断是否可以并行化，并进行任务的分发；在结果队列中有结果时就读出返回。

我们完成优化的算子：


 
 
 
 
 


通过在核，内存的机型下测试，各个算子的优化结果：





整体来说性能普遍是优化前的倍，优化的效果比较明显。
、两地三中心容灾：
两地三中心容灾是数据库的必备能力，对金融类业务来说，数据安全是最基本也是最重要诉求，因此我们为了保障高效稳定的数据容灾能力，也为建设了完善的两地三中心自动容灾能力。具体的两地三中心部署结构如下：

同城节点间采用强同步方式，保障数据强一致；异地采用专网异步同步。
节点内，每台物理机上部署，收集机器状态并进行上报，并进行相应的告警和倒换执行功能。
每个至少部署一个，负责收集上报每个上报的状态到集群。这么多个中只有一个是主用，主用的除了进行状态上报还进行故障裁决和倒换。在主用的异常后，系统通过自动裁决挑选一个备用的升主。
和是两地三中心的控制和裁决节点。
对于数据库节点，在每个至少部署一个。在每个中心部署一个，一个为主，另外两个并联作为备机放在主机上，一个为同步备机，另外一个为异步备机。
在主机故障宕机时，优先选择同城的备机升主。

原文来自：  公众号前言
测试对于产品和运营优化的重要性有目共睹。为了能更快的得到试验结果，试验流量越大越好。
但是当流量不够的时候怎么办呢？小流量测试能不能做？能！那么，怎么做？
下面是个节约流量的方法。
消除异常数据的影响
当点击量作为指标时，有时会看到少量设备贡献了数万的点击。这些设备可能是出了处于异常状态，也可能是在运行自动化测试，总之不会是正常的业务数据。如果将这些数据计入统计结果，将会对结果的准确性产生很大的影响。严重的情况只能重做试验，相当于本次试验流量全浪费掉了。所以极端用户的数据不进行统计，实践中让点击量最大的用户数据不参与计算。
正确统计进入试验的用户数
转化漏斗中的每个步骤都可以进行测试。假设在转化漏斗的第层的页面进行测试，在统计试验的时候，比较科学的方法是将进入到该页面的用户统计为试验，而不是所有访客。如果没进入该页面的用户也统计为试验，则会稀释试验数据。
假设到达该页面的访客为，该页面转化率为，如果想检测出的提升提升到，根据公式计算大概需要试验样本，对应总访客。如果把所有访客作为试验样本参与统计，则该种算法下页面转化率为只有原来的十分之一，同样想检测出的提升提升到，则需要试验样本，对应总访客也是。
这个例子里节约了大概的流量，如果试验页面的转化率更高，前面漏斗的转化率更低，节约效果会更明显。
点击转化率比点击数量更容易获得统计显著的结果
有些场景下，如果认为用户多次点击和单次的点击差别并不大比如下载，注册，看广告等，可以观察点击转化率指标的统计结果。转化率是去重的，用户只要点击过就计算为，否则计算为。同样的试验样本，点击量的标准差是一定大于转化率的。
仍然用上面提到的公式举例：
假设用户点击量的分布为次，次，次，次，次。
则点击量均值为方差为，想检测出的提升需要样本量。
转化率为，方差为，想检测出的提升需要样本量。
这个例子里节约了的样本量，如果点击量的分布更加分散，节约效果会更明显。
原始版本的流量不要浪费掉
在有些情况下，为了稳妥起见往往只会让一小部分流量比如总用户的看到试验版本，的用户看到原始版本，如果统计试验数据的时候，看到原始版本的用户只挑出和看到试验版本用户数相同的人数总用户的来参与统计，则另外的流量相当于浪费了，他们实际上是对试验有帮助的。当试验版本和原始版本样本数不相同时，有一个计算等效样本数的公式：
 ＝   
当 ＝ 时计算得出 ＝／
如果原始版本即版本的流量全部参与统计，则  计算得出 ＝
等效样本数量翻倍了，相当于又节约了的流量。
善用分层试验
想优化的地方太多了，同时跑多个试验是常态，是不是流量就不够用了？如果试验之间互相不会干扰，可以考虑分层试验。分层试验即允许同一个用户同时参加多个试验，通过流量分配的随机算法保证试验结果的代表性。原来流量只能做一个试验，现在不相关的试验可以一起做了，效率成倍增加。
同层试验共用原始版本数据
同层的多个试验，大家的原始版本是完全相同的，分开各自统计显然浪费了数据。以个试验为例：
如果每个试验有独立的原始版本和试验版本，流量分配都是总流量的，则根据上面提到的等效样本量公式，每个试验的等效样本数为总流量的。如果个试验的原始版本合并为公共的原始版本占总流量，则每个试验的等效样本数为总流量的。等效样本量提升了。
如果多个测试试验优化的是同一指标，还可以进一步的对公共原始版本的流量进行微调。令为试验数量，则  =  时等效样本数量达到最大值。＝代入得到原始版本占总流量，每个试验版本占总流量，最终每个试验的等效样本数为总流量的。等效样本量又提升了。没事打开小程序，和附近的人剪刀石头布，想来就来，想走就走。谁能成为武林高手？！
微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 ，在这个平台上面的想象空间很大。
腾讯云拿到了小程序内测资格，研究了一番之后，发现微信支持  还是很值得玩味的。这个特性意味着我们可以做一些实时同步或者协作的小程序。
这篇文章分享一个简单的剪刀石头布的小游戏的制作，希望能对想要在小程序中使用  的开发者有帮助。

整个游戏非常简单，连接到服务器后自动匹配在线玩家没有则分配一个机器人，然后两人进行剪刀石头布的对抗游戏。当对方进行拳头选择的时候，头像会旋转，这个过程使用  会变得简单快速。
部署和运行
拿到了本小程序源码的朋友可以尝试自己运行起来。
整体架构

小程序的架构非常简单，这里有两条网络同步，一条是  通路，用于常规请求。对于  请求，会先走  后再切换协议到  的  连接，从而实现全双工通信。 
 准备域名和证书
在微信小程序中，所有的网络请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：

只允许和在  中配置好的域名进行通信，如果还没有域名，需要注册一个。

网络请求必须走  协议，所以你还需要为你的域名申请一个证书。


域名注册好之后，可以登录微信公众平台配置通信域名了。

 云主机和镜像部署
剪刀石头布的服务器运行代码和配置已经打包成腾讯云  镜像，大家可以直接使用。
腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。

镜像已包含「剪刀石头布」和「小相册」两个小程序的服务器环境与代码，需要体验两个小程序的朋友无需重复部署
 配置 
镜像中已经部署了，需要在下修改配置中的域名、证书、私钥。

配置完成后，即可启动 。

 域名解析
我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行  服务。
在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 。

解析生效后，我们在浏览器使用域名就可以进行  访问。

 启动  服务
在镜像的  配置中，已经把 的请求转发到 处理。我们需要把  实现的  服务在这个端口里运行起来。
进入镜像中源码位置：
 
使用 启动服务：
  

 启动微信小程序
在微信开发者工具中修改小程序源码中的  配置，把通讯域名修改成上面申请的域名。完成后点击调试即可连接到  服务进行游戏。

配置完成后，运行小程序就可以看到成功搭建的提示！

为什么要用 
使用传统的  轮询或者长连接的方式也可以实现类似服务器推送的效果，但是这类方式都存在资源消耗过大或推送延迟等问题。而  直接使用  连接保持全双工的传输，可以有效地减少连接的建立，实现真正的服务器通信，对于有低延迟有要求的应用是一个很好的选择。
目前浏览器对  的支持程度已经很好，加上微信小程序的平台支持，这种可以极大提高客户端体验的通信方式将会变得更加主流。
 端需要实现  协议，才能支持微信小程序的  请求。鉴于  被广泛使用，剪刀石头布的小程序，我们选用了比较著名的  作为服务端的实现。
  的使用比较简单，仅需几行代码就可启动服务。
   {

      {
              
         = 

                  
         = 

            
         =  {  }

            
          = {
              
        }
    }

     {
        
        `     {} `
    }
}

  =  


但是， 和一些其它的服务器端实现，都有其配套的客户端来完成上层协议的编码解码。但是由于微信的限制不能使用  等对象，  的客户端代码在微信小程序平台上是无法运行的。
经过对  通信进行抓包以及研究其客户端源码，笔者封装了一个大约  行适用于微信小程序平台的 类，可以帮助开发者快速使用  来进行  通信。
  =  
  =      
 {   }
如果想要使用微信原生的 ，那么在服务器端也可以直接使用  来实现  标准的接口。不过  支持多进程的特性，对于后续做横向扩张是很有帮助的。腾讯云在后面也会有计划推出支持大规模业务需求的  连接服务，减小业务的部署成本。
通信协议设计
实现一个多客户端交互的服务，是需要把中间涉及到所有的消息类型都设计清楚的，就像是类似剪刀石头布这样一个小程序，都有下面这些消息类型。



消息
方向
说明





 = 
客户端连上后发送  信息，告知服务器自己身份以及位置。



 = 
服务器响应客户端打招呼，并且反馈附近有多少人



 = 
客户端请求加入一个房间进行游戏



 = 
客户端请求退出房间



 = 
房间里面全部人都  后，会发送游戏开始的信号，并且告知客户端游戏时间。



 = 
客户端选择出剪刀、石头还是布



 = 
客户端更新自己的表情



 = 
有用户更新选择或者更新表情会通知其它用户



 = 
超过选择时间后，游戏结束，广播游戏结果



具体每个消息的参数可以参考源码里的
服务器逻辑
服务器的逻辑很简单：

收到用户请求加入房间，就寻找还没满的房间 找到房间，则加入 没找到房间，创建新房间

有用户加入的房间检查是否已满，如果已满，则：给房间里每个用户发送开始游戏的信号启动计时器，计时器结束后进行游戏结算

游戏结算两两之间 ，赢方分数加一，输方减一，最终得每个玩家基本得分 对于每个玩家，如果分数  大于 ，则视为胜利，连胜次数加一，否则连胜次数归零本局得分为分数  乘以连胜次数

发送本局游戏结果给房间里的每位玩家


微信端实现
微信小程序直接使用上面的协议，针对不同的场景进行渲染。整体的状态机如下。

状态机整理清楚后，就是根据状态机来控制什么时候发送消息，接到消息后如何处理的问题了。具体实现请参照 里的源码。众所周知， 已经是业界主流的流时处理框架， 被广泛应用于实时分析，在线机器学习，持续计算、分布式远程调用等领域。当前无论是内部还是外部论坛介绍原理的文档都比较多，但主要都是从运行机制和原理方面的介绍，在  方面的介绍甚少，今天我试着向大家介绍一下  ，一方面可以让大家了解一下  的机制，另外也可以让大家更好的使用好   协助大家自助解决使用过程中的问题。
一、数据上报及展示流程


数据上报流程： 会定时上报统计信息到 
数据展现流程： 调用  的服务从  中取出数据进行分类聚合汇总，然后展示到前端

二、数据类型
通常我们要真正理解一个事物，通常都会从来龙去脉进行解剖；理解   也是，想理解  有什么数据，那么先去理解  有哪些动作就事半功倍了，以下是  中  的基本操作及对应的数据类型，左边为操作，右边为数据。



：

：向下游提交 ，对应的统计数据为 ，= 执行数量，= 执行数量  下游  个数
： 成功流转之后的操作，对应的统计数据为 ，=成功流转次数 =成功流转平均时间
：失败流转之后的操作 对应的统计数据为 ，=失败流转次数


：

：接收到上游数据之后的执行操作 对应的统计数据为 ，=执行次数 =平均执行时间
：与  相同
： 完成  主动发起的  操作，对应的数据为 ，=执行次数



通常数据的统计会对系统的性能造成一定的影响，那么  中为了平衡这种影响，采取了抽样的方式进行上报数据；  中把此值默认为 ，即每执行  次则执行一次数据累加 = ，当然我们也可以修改抽样的配置值为 ，那么就是逐条上报了。


 ：增加  节点，对应的会向  注册一条  信息，包含：     

 ：删除  节点，那么会从  中删除一条  信息

 ：启动了一个 ，那么  的    会发生变化

 ：关闭一个 ，那么  的   会发生变化




 ：增加一个  节点，那么会向  注册一条  信息，包含：    

 ：删除一个  节点，那么会从  中删除一条  信息
 ： 发生变更，那么对应的  中的  发生变化



三、页面展现结构
在上述的第二点中已经说明了基本操作及对应的数据类型，那么在页面中就可以很好的对应了，先从整体视图来看看我们   有什么信息，此   为我们数平自己开发维护的 ，一方面用  页把      分类展示，另外加了很多快捷链接入口用于查看到关注的内容，以及把常用的   操作移动到首页。
、首页初始化


 ： 展示集群的整体信息，包含版本、在线时间、启动时间、管理的  个数、总的节点数、已用节点数、空闲节点数、在运行的  数

 ： 展示所有正在运行的  信息，包含名称、、状态、在线时间、提交时间、占用的  数、拥有的  数、拥有的  数、快捷关闭按钮


、首页 ： 展示所有的  节点，包含 、主机名称、在线时间、启动时间、总的  节点数、已经使用的  节点数  

、首页 ： 展示所有的  节点，包含主机名称、端口号、是否 、版本号、在线时间、启动时间  

、首页 ： 把配置信息以列表展现出来  

、 详情页 


 ：与首页对应的   对应。

 ：用于  的一些操作：激活、注销、重分配、 、修改日志级别。

 ：按时间窗口展现统计数据：十分钟表示近十分钟的统计， 小时表示近  小时的统计等。

： 组件的统计数据，数据含义在第二点的数据类型已有说明。

： 组件的统计数据，数据含义在第二点的数据类型已有说明。

 ：展示  的拓扑结构图及数据传输情况。

 ：展示  的配置信息。


、 详情页 


 ：展示  的 、 个数、 个数、 日志。

 ：提供  的   操作。

 ：按时间窗口展示数据，数据含义在第二点的数据类型已有说明。

 ：输入流数据，包含上游 、、执行时间、执行次数、 正常流转的处理时间、 数、失败数。

 ：输出流数据，包含 、 个数、 个数。

： 数据，包含 ，在线时间、所在主机及端口、 个数、 个数、执行时间、执行个数、成功流转直接、 个数、失败个数。

  ：用于诊断  的运行情况，执行  等操作对  进行检测输出到文件，供用户下载打开查看  的运行情况。


四、用户角度考虑的信息展示
了解完上面的介绍，相信都会有大概的一些印象，但仅有那些信息是否已经足够呢？我们不妨从使用者的角度来思考一下：
、 每次提交  都要去登陆到后台去提交，很麻烦，是否可以在  中提供页面去提交呢？—增加提交  页面 


、一个  的  分布在哪些节点？每个  都有哪些 ？每个  的  内存情况、进程内存情况？—增加  详情页面 

、 一个  有哪些启动了的 ？ 每个  有哪些 ？ 

五、常见的操作流程
我们在使用  的过程中，会不定时的出现一些问题，熟练   可以更好的协助自己分析解决问题。以下是常见的几个例子：
、 上游发的次数与下游接收执行的次数不一致，怎么办？ 
首先理解  的数据类型，可参照第二点的说明，然后进入  详情页面进行对比。
、好不容易写了一个 ，提交之后，发现一直没有数据输出，可能是启动失败了，怎么办？ 
点击   的  链接查看  日志，查看任务是否分配成功；  
点击   的  链接  日志，查看  是否有启动相应的   ；
点击   的   链接到  页面，选择对应的  查看 ，查看  是否有正常启动。
、下游说发送的数据与预期不一样，我想看看  究竟传输的是什么数据，有没办法看？ 
想查看整个  中各个  传输的  数据，那么在  详情页面启动 ，输入百分比参数，那么  会按照比率把  信息输出到 ，然后在  详情页中点开  链接就可以看到传输的数据是什么。当然也可以选择指定的  进行 ，那么就只对一个  进行日志输出。
、 写的  加了很多  级别日志输出，但是发现  的日志级别是  级别的，自己想看的日志无法输出啊，怎么办？好捉急啊！！ 
 中提供了修改日志级别的操作，只需要点两下修改一下日志级别为 ，日志就源源不断输出到  了，好欢喜。
、 提交的  在运行过程中，发现  数不够用了，某个组件积压太多了，想加多几个  怎么办？ 
在  详情页面点击  输入相应的参数就可以重新分配了。
、 发现几个  的  占用好高啊，该怎么办？ 
进入  详情页面进行  操作，执行  获取  运行堆栈，打开  文件进行分析。 月  日，腾讯云在 「云未来」峰会上推出了战略新品——智能云，宣布将腾讯积累近  年的  能力向政府、企业和开发者开放，其中首批开放计算机视觉、智能语音识别、自然语言处理的三大核心能力。腾讯云技术社区陆续推出了系列文章，向普通开发者分享如何快速接入并使用这三大  能力，节省自身的开发成本，同时极大提升开发效率和用户体验。
本文将为广大云开发者介绍如何将历史数据迁移到腾讯云万象优图。
 历史数据迁移
在使用万象优图以前，您的图片数据可能存在服务器本地文件系统、分布式文件系统以及其他云存储等，我们提供迁移工具，方便您将这些历史图片迁移到万象，目前支持种存储方式的迁移：

图片在服务器本地存储，直接将某目录下的所有文件上传到万象优图。

指定列表文件，文件中每一行是一张图片的。工具会下载列表文件中的每一张图片并上传到万象优图。

指定七牛云存储的账号和空间名，迁移该指定空间中的所有文件或部分文件到万象优图。


本工具目前支持类操作系统。推荐在或  下使用 运行。
 迁移工具下载地址

 迁移工具安装使用方法
从上通过获取，或者下载压缩包解压到服务器上，然后进入工具目录
 
 启动迁移
运行脚本，工具会按照配置文件中的配置开始运行启动前请修改配置，否则会运行失败。如果要迁移的文件较多，可后台运行，运行命令：
 
上传完成后再次运行会重试失败的任务。
脚本首先扫描待上传的任务提交到任务列表，然后开始上传。如果第一个过程被打断，下次运行会重新扫描待上传的任务；如果第二个过程被打断，下次运行会继续上传。如果需要强制刷新任务列表请运行以下命令：
  
 查看迁移进度
启动后可查看迁移状态，运行脚本，会在屏幕上持续输出迁移状态，按退出查看。

该脚本输出内容如下图：
数字有三列，第一列：失败的文件数；第二列：成功迁移的文件数；第三列：要迁移的文件总数

 停止迁移
若启动后想做配置调整或任何异常发生，可停止迁移，运行。

在迁移过程中运行脚本停止迁移，这一过程可能需要等待几秒钟的时间以保证已经开始的任务正常结束并写入日志。如果需要强制停止，运行 。
停止迁移之后如果没有清空日志并且没有修改配置信息，再次启动迁移会继续上次的迁移任务，重试所有失败记录但已经迁移成功的文件不会重传。
 获取失败信息
获取迁移失败的文件列表及信息，运行_。
_
 清除日志
若想开始一次新迁移，可清空之前的日志信息，运行。请慎用，因为日志文件会作为增量断点续传的参考信息，删除后再执行相同任务所有文件会重新上传。
 修改配置
配置文件为位于目录 配置文件中 和 不区分大小写。
 
 迁移类型设置
设置 为
 表示迁移本地文件系统的文件 表示迁移列表文件中所有指向的文件 表示迁移七牛某空间的文件

 = 
 本地文件系统
若迁移类型为，则需要配置上传的本地根目录位置，必须为绝对路径。上传后的 不包含根目录。例如：

__ = 
迁移后图片的访问路径：
 上传的万象空间域名图片相对于所配置的根目录的相对路径
比如，设置的本地目录： 有一张图片路径为：，上传后访问路径： 上传的万象空间域名
 列表文件
若迁移类型为，则需要配置列表文件的位置，必须为绝对路径。例如：

___ = _
迁移后图片的访问路径：
 上传的万象空间域名原的路径
比如，原为   ，上传后访问路径： 上传的万象空间域名

注意：若原中有参数，上传后的文件名是去掉参数后的，比如，原为    ==，上传后访问路径： 上传的万象空间域名

 七牛
若迁移类型为，则需要配置七牛云存储账号相关信息。
填写被迁移的空间名；为七牛域名，需要包含协议类型如 ； 若只迁移一部分则需要提供_和_，_从计；若空间开启了防盗链，需要在中指定访问来源域名，同样需要包含协议类型如 ； 如果是私有空间，将设置为，否则设置为。


 = __
 = _
 = 
 = 
 = 
 = 
迁移后图片的访问路径：
 上传的万象空间域名原七牛
比如，原图片下载路径为    ， 上传后访问路径： 上传的万象空间域名
 万象优图账号信息
从万象优图图片空间中查看项目和空间名称，分别填写到和；
从万象优图项目设置中查看 和 分别填写到和。


 = 
 = 
 = 
 =
 上传设置
控制同时运行的上传进程数目，请根据上行带宽和机器配置适当调整该数值。必须提供一个大于的整数。
控制上传结果写回日志的时间间隔，单位为秒，应该提供一个合法的正整数或浮点数或正无穷。如果进程意外结束，未写回的日志将丢失。此值设置过小将严重影响性能，一般情况下使用默认值即可。
、、是控制任务队列和内存缓冲区的选项，一般情况下使用默认值即可。

 = 
 = 
 = 
 = 
 = 
使工具在提交任务时忽略 符合指定条件的任务。
使工具在提交任务时忽略 不符合指定条件的任务。
使工具在重试出错任务时忽略错误日志符合指定条件的任务。
以上三个选项若启用则应提供一个正则表达式，否则留空，语法参考   。如果同时提供了和，并且某个 同时符合两个正则表达式，那么它会被忽略。
如忽略 操作系统下的_文件，不重试错误码为的任务：

 = _
 = 
 =  有个朋友的服务，因为在线用户数目平常波动很大，按照最大在线数部署服务器显然太浪费，所以选择了腾讯云的弹性伸缩服务，在每天用户集中上线的时间点上快速扩容服务器加入到集群中分散压力。因此在集群遭遇到突发的访问压力的时候，快速的自动扩容能力就显得非常重要了。前阵子还专门为此请教了腾讯云专家，解析了快速生成主机的不传之秘 。
但是快速生成了主机并加入集群，并不能确保主机快速的分担压力，因为腾讯云的负载均衡目前只支持  和按权重轮询两种方式，这两种分配算法在新服务器加入后都需要经过一段短时间的预热才能逐步分配到流量。因此扩容后的曲线常常会是这样子的刚刚进行的扩容实测，为了降低对业务影响测试了分钟就停掉了：

注意红色曲线和横轴重合的部分：
第一分钟
第二分钟
第三分钟
也就是说，虽然生成一台服务器我们可以优化到数十秒，但是新服务器加入集群后的前面几分钟几乎没有请求分发到新服务器上，随后才步入正轨。这样显然延长了压力缓解过程，让更多用户忍受了几分钟的恶劣体验。
那有没有办法缩短这个过程呢？腾讯云近期将推出的新的负载均衡轮询算法就可以解决这个问题。新算法被称为“最小连接数”算法，也就是会随时判断哪台主机上的连接数最少，然后尽量把新的请求分发给它。经过一番软磨硬泡，终于从负载均衡团队磨到了新算法的内测体验资格，立刻做了一个扩容实验。我们来看看效果：

可以看到，最开始和横轴重合的一段消失了，新服务器在接入的第一时间立刻分摊到了访问量并输出流量，集群中过载的服务器压力也就立刻得到了缓解。
不只是扩容过程会从新算法中收益，实际上在以往的算法中，集群中的服务器都难以即时分担彼此的压力，当某一台或者几台服务器压力过大的时候，只会继续按照权重随机的分配新的请求给它，而不是降低它的权重，让它缓一缓。而在新算法中，如果一台服务器负担压力过重导致请求无法及时响应完成，就会观察到它的连接数增加，并把更多的请求分配给连接数更少的服务器，从而达到更优的负载均衡效果。
当然，要充分获得这些优势都要取决于接入服务器已经实现了『无状态化』这个前提，否则负载均衡也无法随意的把一台服务器的压力转移到另一台上面。

相关推荐【腾讯】和开发一起写代码，让测试左移起来手游兼容性测试【专项测试】—冲突测试作者：
团队：腾讯移动品质中心
导语
眼镜层出不穷， 应用如雨后春笋，它们消费的内容主要有图片，视频和游戏种。当前优酷，搜狐，乐视，爱奇艺，等比较大的视频网站，都推出了视频专区，各种比较小的专注视频的网站多不胜数，其中比较有名的有，等。用户在使用手机浏览器过程中视频的播放量很大，其中不可避免的会有视频。
视频一般是格式，与普通视频无异。视频里面并没有标记这是一个普通视频，还是一个视频。一般网站或者应用里面区分视频的做法是，在后台的数据库里面有个字段标记。但是浏览器里面的播放器只能拿到一个视频的，无法知道这是一个普通视频还是视频，所以播放的时候只能按照普通视频去渲染。

视频眼镜播放模式可以转动手机查看周围

视频普通播放模式
如何判断视频是不是视频
前面已经说了，浏览器的视频播放器只能拿到一个视频的播放地址，所以判断是否视频，只能从视频本身出发。观察以下视频和普通视频的截图两端红框区域，发现视频的两端边缘相似度较高，而普通视频的边缘相似度很差。视频识别的算法就是基于这个现象，获取一个视频多个帧的图片，然后给出视频是视频的概率。

视频截图

普通视频截图
算法存在的问题
通过上面的介绍，知道这个算法是根据图片边缘相似性得到结果，出于效率的考虑检查的图片数量和检查的粒度不能设置太高，那么它得到的结果会有两个不可避免的问题：将视频识别为普通视频；将普通视频识别为视频。如以下示例：

视频被识别为普通视频画面昏暗的视频很容易误判

普通视频被识别为视频边缘相似度较高的普通视频
对于这样一个计算概率性的算法，需要找到尽量多的失败用例，然后根据失败的特点来改进算法。为了发现失败用例，需要一个很大的测试集，这个测试集合里面包含了一个视频集合，以及一个普通视频的集合。这个集合的作用是尽量使视频正确识别，又要保证普通视频不会被识别为视频。这个集合最好还要易于增加测试源，用来验证算法的有效性。
测试集的建立
最开始测试集合是到网络上下载视频，保存到本地，然后用来测试验证。这种方式的优点是测试的速度很快，因为都是本地视频。但是缺点也很明显，视频的太大 分钟的视频经常会上 本地保存比较麻烦；每次去网上找下载太耗时，不容易增加，而且容易重复。
现在的测试集合保存的是视频网页的网址，网址有爬虫爬取。当前做了个网站的爬虫，基本包含了国内主流的视频网站和 视频网站。

支持的主流网站表
在爬虫里记录了网站经常更新的页面一般是网站的分类网址：如优酷的电视剧，电影分类的 ，爬虫运行时将爬去到的页面地址保存到表。保存前会自动分析页面的特征，判断该页面的视频是不是  视频，并将结果一起保存到表，从而建立视频集合以及普通视频集合。
测试过程中如果发现有的视频源已经失效，需要在表中标记无效，不用删除视频源，避免下次再次加入。如果是自动化能识别的失效可以自动化标记如：视频已经下线跳转到页面，否则需要人工根据测试结果标记。

测试集合内的视频 表
当前测试集合的视频数量有个，普通视频数量有 个，由于现在的测试工具尚不支持的测试源，所以有些视频还没有测试过。
测试准备
有了爬虫就可以建立测试集，有了测试集还需要测试工具。测试工具是开发提供的一个程序，程序的调用方式：     ，调用后的返回结果是视频为视频的概率，如果出错返回 。
测试集和测试结果都保存在数据库中，数据库中有  张表。上面已经介绍了和表，分别支持的网站和爬虫爬取的视频网页。还有一个表，用来记录每次测试的结果，另外还有一个表，用来记录每个视频的测试结果。

测试结果 表

具体视频的结果 表
测试流程

测试成效

以上是最近的一次测试结果，更新算法后，验证  视频的成功率提升了 ，验证非 视频的成功率下降了 。 使用该方案后，能快速了解算法对视频识别率的影响，并能方便获取失败用例，用来改进算法。
对于  视频的检测，你是否有更好的方法呢？
欢迎留言探讨。
获取更多测试干货，关注腾讯移动品质中心公众号。微服务框架又添新成员了！继和之后，现在支持了和两门语言。
 
特性介绍
：

：客户端部分提供了代理生成，路由和网络通讯等功能。服务器端提供了远程服务暴露、请求派发、网络通讯等功能；
：将应用适配到环境，十分强大的工具。
：包括服务监控和特性监控。
：基于实现的库。
：上报业务或框架的告警消息至平台。
：基于的日志组件，支持染色日志、滚动日志。
：
目前实现了部分，支持编解码，用来从生成的工具，主动调用，部分正在建设中，敬请期待。

开源
取名于电影“星际穿越”中的机器人，是支持多语言的高性能开发框架和配套一体化的服务治理平台。在月初正式开源后天数突破一千，并在一个月的时间得到了腾讯开源的置顶推荐。目前数已突破。
截止目前，每周活跃交流的用户达多人，同时能得到条以上的反馈。 
在公司内部，目前已在多个业务如手机浏览器、应用宝、手机管家、手机、手机游戏等在多万台服务器上使用。
在公司外部，公司旗下的子公司以及从公司离开的同事开始使用，也开始有一些企业主动联系我们沟通合作的意向。
拓展阅读：《开源之路：大公司开源并非易事，如何用产品思维去做？》《你所不知的，却帮阅文集团完成技术架构变革！》
请在上 ！ 一、配置防火墙，开启端口、端口
 默认使用的是作为防火墙，这里改为防火墙。
、关闭：
            停止
            禁止开机启动
、安装防火墙
    
   
                 
                    
                         
            
              
              
              
                   
                 
                 
                         
                         
                         
                 
                 
            
            最后重启防火墙使配置生效
            设置防火墙开机启动
二、关闭
   
=         注释掉
=         注释掉
=             增加
       使配置立即生效
三、安装
     
        启动
        停止
            重启
            设置开机启动
在客户端浏览器中打开服务器地址，会出现下面的界面，说明安装成功

四、安装
 中，已经使用替代了数据库
      
        启动
        停止
        重启
        设置开机启动
        拷贝配置文件注意：如果目录下面默认有一个，直接覆盖即可
  __    给设置密码
回车，根据提示输入
输入次密码，回车
根据提示一路输入
最后出现：   
密码设置完成，重新启动 
    
五、安装
     
安装组件，使支持 
                      安装组件，使支持 
        重启
            重启
六、配置篇
、配置
       编辑文件
              添加，在错误页中显示的版本，为不显示
               修改为：   允许服务器执行及，禁止列出目录
              　修改为：    允许扩展名为的脚本运行
             　 修改为：  允许
             　修改为： 　添加为默认编码
               修改为  不在浏览器上显示树状目录结构
              修改为：     设置默认首页文件，增加
              添加  增加同时连接数
            重启
         删除默认测试页
、配置
   
             =  把前面的分号去掉，改为 = 
            _ = __________________ ___ _______ ___ _ ___ _____ _______
            列出可以禁用的函数，如果某些程序需要用到这个函数，可以删除，取消禁用。
            _ =  禁止显示版本的信息
            __ =  支持短标签
            _ =  设置表示允许访问当前目录即脚本文件所在之目录和目录可以防止木马跨站如果改了之后安装程序有问题例如：织梦内容管理系统，可以注销此行，或者直接写上程序的目录
     重启
     重启
七、测试篇
   
   



注意：默认的程序目录是权限设置：   至此， 安装配置服务器教程完成！铁匠运维网

相关推荐
系统安装环境
 安裝桌面、、、
下环境配置一．背景
我们小组需要从  部门同步客户信息和机构信息到本地，这两部分数据大概各 ，总共  的数据量。 部门提供两个存储过程用于分别获取这两部分数据，因此在使用  处理数据时，只能调用存储过程将两部分数据分别一次性全部读入内存再处理。每个存储过程从  部门的数据库获取数据大概需要  的时间，总共  的样子。
二  问题
之前一位已经离开公司的同事已经实现了一个版本的该需求的功能，思路是一个  类的两个方法分别处理客户信息和机构信息，使用  模块拼接一条  语句便插入一条数据。在实际执行过程中的现象是程序大概执行了  个小时，然后进程被  的  __  机制给杀掉了。下图是截取自  的系统日志，可以看到  系统的物理内存是  多些，然而进程使用的  虚拟内存已经到达了 。

这样就有两个问题需要优化处理：

处理时间过长，扣除固定的获取数据的 ，竟然  个多小时都没能将  的数据入本地 。

内存溢出，内存使用过大被  内核杀死导致入库的数据不完整。


三 定位与解决
 时间优化
通过打印处理时间，可以很容易发现处理时间主要都消耗在数据入本地  上。原始的入库逻辑是拼接一条  语句，然后执行一次入库动作，这样的效率肯定不高。提升数据库入库的效率的一条原则就是以“  …”来代替多次插入单条数据。因此对代码进行改造，简单粗暴地将读入的  数据拼接成一条“  …”的  语句。但是执行的结果就是“     __ ”，原来  对输入  语句长度有限制，最大能够多长就是有“__”这个参数决定的。


数据库才允许  的输入，而  的数据将就  的长度，肯定处理不了。另外查资料发现“__”不支持热修改，也就是或者修改配置文件然后重启 ，或者执行“  __=”语句，但是要重新登录。这样对于  脚本的执行都不太友好，所以想到的办法是把  的数据进行拆分，组装成小于  的  语句执行。思路：使用迭代器对查询的结果集进行分割处理，返回“”形式的  语句后半部分，以便拼接  字符串。
 
     ____   _
         查询结果集
        _ = _
         结果集长度
         = _
         分割间距
         = 
         =     
         需要进行插入字段名称列表
         = 
         = 

     ____
         

     
         = 
          = 
                
                 =     
                 超过最大范围则返回
                  = _
                    
                 = _
                 =     
                 替换实际的数据
                   
                     =    \ 
                 = 
             = 
             去除开头多余的逗号
             
                 

         
使用方法：
 需要插入的字段名称列表
 = _ _ _ _ _  _ _ _
 初始化迭代器用于获取  值
_ =   __
   _

     

      

    =   ______ _______    

    = _
上述代码以  条记录为分割，拼接  的  语句入库。实验  条记录为分割也可以，但是为了防止过长的记录集中在一起导致超长，所以选择  为间隔。时间优化提升：

“ ”开始执行，到“ ”通过存储过程获取  条数据，使用时间  分钟，而“ ”数据入  完成，只有了  分钟，从  小时到  分钟时间优化提升挺明显的。
  解决
通过观察  的  命令的输出以及  日志的打印，发现在处理完第一个方法里面涉及的  数据后，系统内存使用了  左右。第二个方法需要处理另外  的数据，但是在第二个方法执行时内存没有减少，是在  的基础上持续增加，当增加到  左右时，被   干掉。
可以看出第一个方法使用的内存没有被释放掉，这种现象很奇怪，理论上说第一个方法作用域结束后，内部的局部变量的引用计数应该都变为  了，应该会被内存回收机制清理掉，但是没有被清理。所以当时怀疑是否  内存回收机制没有触发，于是做了对第一个方法里面的所有表面能看到的变量进行了“”，主动减少其引用计数，并调用了“”主动回收内存。但是  依然存在，现在一样。
由于之前过长的  语句插入  会报错，顺着这个思路怀疑是否是  中拼接  的  占用了大量的内存没回收。因为  中的  使用了常量池技术，创建一个不同内容的  就会在常量池中存在一份， 记录的  语句量也是很大的。于是又尝试了“” 变量以及使用  可变的“”代替原来的  变量。但  依然存在，没办法只能查看  运行时的内存到底是怎么样了。
选择安装了  模块查看  运行时的内存。下载位置： ， 安装简单“  ”“  ”两条命令就安装完成。另外  对原来的代码侵入性也比较小，下面三行代码几乎就能将  运行时的内存大概情况看清楚：
   
 = 

介绍得很详细。
查看第一个方法执行完内存的使用情况，可以看到总共使用了  的内存，而使用的内存中 是  类型的数据占用了 。

这个“”提示挺明显的，在我们的方法里面没有什么大的 ，这么大的  只有通过存储过程查询出来的结果集了。顺着这个线索检查发现在一个连接对象中竟然留有对结果集的引用，导致结果集在执行第二个方法前没有被回收。即： 对象的  和  方法分别处理  数据，这两个方法中的所有对象引用都已经释放。同时  对象又有一个叫 _ 的属性，这个属性是被封装的数据库连接对象，当它查询结果集时，同时有留有了这个结果集的引用。所以， 执行完后，_ 依然保持着结果集引用导致无用内存没有被释放。_ 的引用也“”之后，内存使用情况：

可以看到内存迅速减小，只剩下  左右， 占用内存也不存在。整个  脚本能够顺利执行，不再出现  问题。不同于传统的   或者是移动 ，在客厅盒子端，接大屏显示器下，许多能流畅运行于  端、移动端的  动画，受限于硬件水平，在盒子端的表现的往往不尽如人意。
基于此，对于  动画的性能问题，仅仅停留在感觉已经优化的之上，是不够的，想要在盒子端跑出高性能接近   的流畅动画，就必须要刨根问底，深挖每一处可以提升的方法。
流畅动画的标准
理论上说， 越高，动画会越流畅，目前大多数设备的屏幕刷新率为  次秒，所以通常来讲  为  时动画效果最好，也就是每帧的消耗时间为 。
直观感受，不同帧率的体验

帧率能够达到  ～   的动画将会相当流畅，让人倍感舒适；
帧率在  ～   之间的动画，因各人敏感程度不同，舒适度因人而异；
帧率在   以下的动画，让人感觉到明显的卡顿和不适感；
帧率波动很大的动画，亦会使人感觉到卡顿。

盒子端动画优化
在客厅盒子端， 动画未进行优化之前，一些复杂动画的帧率仅有    ，卡顿感非常明显，带来很不好的用户体验。
而进行优化之后，能将    的动画优化至    ，虽然不算优化到最完美，但是当前盒子硬件的条件下，已经算是非常大的进步。
盒子端  动画性能比较
首先先给出在盒子端不同类型的 动画的性能比较。经过对比，在盒子端  动画的性能要优于  动画，而在  动画里，使用  硬件加速的动画性能要优于不使用硬件加速的性能。
所以在盒子端，实现一个  动画，优先级是：
 硬件加速  动画  非硬件加速  动画   动画
动画性能上报分析
要有优化，就必须得有数据做为支撑。对比优化前后是否有提升。而对于动画而言，衡量一个动画的标准也就是  值。
所以现在的关键是如何计算出每个动画运行时的帧率，这里我使用的是  这个函数近似的得到动画运行时的帧率。
原理是，正常而言  这个方法在一秒内会执行  次，也就是不掉帧的情况下。假设动画在时间  开始执行，在时间  结束，耗时  。而中间  一共执行了  次，则此段动画的帧率大致为：    。
核心代码如下，能近似计算每秒页面帧率，以及我们额外记录一个 ，用于记录  的执行次数，用于计算每次动画的帧率 ：
  =   {
     
         ||
         ||
          {
               
        }
    
}

  = 
  = 
  = 
  = 

  =   {
      = 
      =   
      =   

     = 
     不置 ，在动画的开头及结尾记录此值的差值算出 
    
    

          {
          =       
           每秒 
         = 
         = 
    }

    
}
研究结论
所以，我们的目标就是在使用  硬件加速的基础之上，更深入的去优化  动画，先给出最后的一个优化步骤方案：

精简  ，合理布局
使用  代替 、，减少使用耗性能样式
控制频繁动画的层级关系
考虑使用 
使用  时间线  观察，找出导致高耗时、掉帧的关键操作

下文会有每一步骤的具体分析解释。
 每一帧的渲染
要想达到  ，每帧的预算时间仅比  毫秒多一点  秒  =  毫秒。但实际上，浏览器有整理工作要做，因此您的所有工作需要尽量在  毫秒内完成。
而每一帧，如果有必要，我们能控制的部分，也是像素至屏幕管道中的关键步骤如下：

完整的像素管道     样式  布局  绘制  合成：
 。一般来说，我们会使用  来实现一些视觉变化的效果。比如用  的  函数做一个动画、对一个数据集进行排序或者往页面里添加一些  元素等。当然，除了 ，还有其他一些常用方法也可以实现视觉变化效果，比如： 、 和   。
 样式计算。此过程是根据匹配选择器例如  或   __计算出哪些元素应用哪些   规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。
 布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如  元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。
 绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面通常称为层上完成的。
 合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。
当然，不一定每帧都总是会经过管道每个部分的处理。我们的目标就是，每一帧的动画，对于上述的管道流程，能避免则避免，不能避免则最大限度优化。
优化动画步骤
先给出一个步骤，调优一个动画，有一定的指导原则可以遵循，一步一步深入动画
精简  ，合理布局
这个没什么好说的，如果可以，精简  结构在任何时候都是对页面有帮助的。
使用  代替 、，减少使用耗性能样式
现代浏览器在完成以下四种属性的动画时，消耗成本较低：

位置   
比例缩放： 
旋转 ： 
透明度：： 

如果可以，尽量只使用上述四种属性去控制动画。
不同样式在消耗性能方面是不同的，改变一些属性的开销比改变其他属性要多，因此更可能使动画卡顿。
例如，与改变元素的文本颜色相比，改变元素的  将需要开销大很多的绘图操作。 改变元素的  可能比改变其  要多一些开销。如  属性，从渲染角度来讲十分耗性能，原因就是与其他样式相比，它们的绘制代码执行时间过长。
这就是说，如果一个耗性能严重的样式经常需要重绘，那么你就会遇到性能问题。其次你要知道，没有不变的事情，在今天性能很差的样式，可能明天就被优化，并且浏览器之间也存在差异。
开启  硬件加速
归根结底，上述四种属性的动画消耗较低的原因是会开启了  硬件加速。动画元素生成了自己的图形层。
通常而言，开启  加速的方法我们可以使用

 

这会使声明了该样式属性的元素生成一个图形层，告诉浏览器接下来该元素将会进行  变换，让浏览器提前做好准备。

使用  并不一定会有性能的提升，因为即使浏览器预料到会有这些更改，依然会为这些属性运行布局和绘制流程，所以提前告诉浏览器，也并不会有太多性能上的提升。这样做的好处是，创建新的图层代价很高，而等到需要时匆忙地创建，不如一开始直接创建好。

对于  及一些旧版本浏览器，它们不能识别 ，则需要使用某种   进行 ，通常会使用

 

所以，正常而言，在生产环境下，我们可能需要使用如下代码，开启硬件加速：
{
 
 
}
控制频繁动画的层级关系
动画层级的控制的意思是尽量让需要进行  动画的元素的  保持在页面最上方，避免浏览器创建不必要的图形层，能够很好的提升渲染性能。
，这里又提到了图形层，这是一个浏览器渲染原理相关的知识内核下。它能对动画进行加速，但同时也存在相应的加速坑！

图： 
简单来说，浏览器为了提升动画的性能，为了在动画的每一帧的过程中不必每次都重新绘制整个页面。在特定方式下可以触发生成一个合成层，合成层拥有单独的 。
需要进行动画的元素包含在这个合成层之下，这样动画的每一帧只需要去重新绘制这个   即可，从而达到提升动画性能的目的。
那么一个元素什么时候会触发创建一个   层？从目前来说，满足以下任意情况便会创建层：

硬件加速的  元素比如  嵌入的页面中有合成层
硬件加速的插件，比如  等等
使用加速视频解码的 元素
 或者 硬件加速的   元素
 或透视变换 、 的  属性
对自己的  做  动画或使用一个动画变换的元素
拥有加速  过滤器的元素
元素有一个包含复合层的后代节点换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里
元素有一个  较低且包含一个复合层的兄弟元素

本小点中说到的动画层级的控制，原因就在于上面生成层的最后一条：

元素有一个  较低且包含一个复合层的兄弟元素。

这里是存在坑的地方，首先我们要明确两点：

我们希望我们的动画得到  硬件加速，所以我们会利用类似   这样的方式生成一个   层。
  虽好，但不是越多越好，每一帧的渲染内核都会去遍历计算当前所有的   ，并计算他们下一帧的重绘区域，所以过量的   计算也会给渲染造成性能影响。

记住这两点之后，回到上面我们说的坑。
假设我们有一个轮播图，有一个  列表，结构如下：
 =
 =轮播图
 =
列表
列表
列表
列表


假设给他们定义如下 ：
 {
 
   
}

 {
 
}

  {
 {
   
}
}
由于给  添加了    动画，所以它会生成一个  ，如下图所示，用开发者工具可以打开层的展示，图形外的黄色边框即代表生成了一个独立的复合层，拥有独立的   。

图； 
但是！在上面的图中，我们并没有给下面的  也添加任何能触发生成   的属性，但是它也同样也有黄色的边框，生成了一个独立的复合层。
原因在于上面那条元素有一个  较低且包含一个复合层的兄弟元素。我们并不希望  元素也生成   ，但是由于  层级定义原因，下面的  的层级高于上面的 ，所以它被动的也生成了一个   。
使用 ，我们也可以观察到这种层级关系，可以看到  的层级高于 ：

图：  
所以，下面我们修改一下  ，改成：
 {
 
 
}

 {
 
}
这里，我们明确使得  的层级高于  ，再打开开发者工具观察一下：
图：  
可以看到，这一次， 元素已经没有了黄色外边框，说明此时没有生成   。再看看层级图：

图：  
此时，层级关系才是我们希望看到的， 元素没有触发生成   。而我们希望需要硬件加速的  保持在最上方，每次动画过程中只会独立重绘这部分的区域。
总结
这个坑最早见于张云龙发布的这篇文章硬件加速也有坑，这里还要总结补充的是：

 硬件加速也会有坑，当我们希望使用利用类似   这样的方式开启  硬件加速，一定要注意元素层级的关系，尽量保持让需要进行  动画的元素的  保持在页面最上方。

  不是越多越好，每一帧的渲染内核都会去遍历计算当前所有的   ，并计算他们下一帧的重绘区域，所以过量的   计算也会给渲染造成性能影响。

可以使用  ，用上面介绍的两个工具对自己的页面生成的   和元素层级进行观察然后进行相应修改。

上面观察页面层级的  工具非常吃内存？好像还是一个处于实验室的功能，分析稍微大一点的页面容易直接卡死，所以要多学会使用第一种观察黄色边框的方式查看页面生成的   这种方式。


 使用  可以在元素属性真正发生变化之前提前做好对应准备
 示例
{
 
}
上面已经提到过  了。
 为  开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。
值得注意的是，用好这个属性并不是很容易：

在一些低端盒子上， 会导致很多小问题，譬如会使图片模糊，有的时候很容易适得其反，所以使用的时候还需要多加测试。

不要将  应用到太多元素上：浏览器已经尽力尝试去优化一切可以优化的东西了。有一些更强力的优化，如果与  结合在一起的话，有可能会消耗很多机器资源，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。

有节制地使用：通常，当元素恢复到初始状态时，浏览器会丢弃掉之前做的优化工作。但是如果直接在样式表中显式声明了  属性，则表示目标元素可能会经常变化，浏览器会将优化工作保存得比之前更久。所以最佳实践是当元素变化之前和之后通过脚本来切换  的值。

不要过早应用  优化：如果你的页面在性能方面没什么问题，则不要添加  属性来榨取一丁点的速度。  的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。它不应该被用来预防性能问题。过度使用  会导致生成大量图层，进而导致大量的内存占用，并会导致更复杂的渲染过程，因为浏览器会试图准备可能存在的变化过程，这会导致更严重的性能问题。

给它足够的工作时间：这个属性是用来让页面开发者告知浏览器哪些属性可能会变化的。然后浏览器可以选择在变化发生前提前去做一些优化工作。所以给浏览器一点时间去真正做这些优化工作是非常重要的。使用时需要尝试去找到一些方法提前一定时间获知元素可能发生的变化，然后为它加上  属性。


 使用  时间线  观察，找出导致高耗时、掉帧的关键操作
对比屏幕快照，观察每一帧包含的内容及具体的操作
找到掉帧的那一帧，分析该帧内不同步骤的耗时占比，进行有针对性的优化
观察是否存在内存泄漏
对于  的使用用法，这里有个非常好的教程，通俗易懂，可以看看：
浏览器渲染优化  课程
对于盒子端  动画的性能，很多方面仍处于探索中，本文的优化方案研究同样适用于   及移动 ，文章难免有错误及疏漏，欢迎不吝赐教。什么是  性能监控方案 
 性能监控方案 是将  产生的性能数据上报及处理和分析 提供适度加工的数据 平台及合适的方法协助应用发现对用户影响最大的性能问题 并且用累积数据一步步回归验证 最终使应用数据上报 数据存储与分析 报表及邮件推送  产生及回归验证 行业经验沉淀成为一个完整的闭环 使应用的性能可以得到持续的监控与提升。
 哇 好正式的开场啊 稳！
为什么要使用腾讯云相比于传统机房 

降低运维成本 将精力集中于构建上层业务 曾经一段时间 后台的维护与开发耗时比例高达 

可更快速的扩容 大部分云上资源都可以即时分配

更好的支持独立部署和成本核算 毕竟后台需要使用大量的计算资源 最后的产生的成本需要接入的产品共同承担

大部分腾讯云服务都会有监控告警能力，而自建服务还是需要大量精力用来构建这方面的能力


 哇 好有说服力的原因啊 稳！
那么，一张图说清楚后台架构

  是一个供上报的后台服务 用以接收客户端的上报请求并将数据存储到 并将大文件落地到文件存储服务。
 集群用以缓解数据峰值带来的压力，并且作为数据中转站，为各个模块进行解耦。
  是主要的后台 作为的主要 将用户上报的数据存储到进行数据计算，另外有一些需要分析的数据会发送到独立的模块进行分析。
  是项目的服务 主要提供数据展示及交互 产品及邮件配置等。
腾讯云使用资源清单



服务
用途
优势不足




容器服务
容器编排
底层使用，业界主流发展方向。服务内置与腾讯云负载均衡服务无缝衔接



大数据计算
华丽的前台界面，即使小白也可以轻松构建数据工作流 缺点 目前还没有自动化配置方案



数据存储
目前腾讯云最稳定的海量存储方案 缺点 目前还没有客户端 我们是自己开发的



配置下发
服务稳定，时延低，新手使用的话，“自助故障诊断”功能很好用



关系型数据存储
数据类型丰富，例如  有丰富的插件 缺点 目前在单表过十亿条的场景 性能不如分布式数据库



存储
服务带宽真心高 我们单机带宽可达  以上


云文件存储
云文件存储
对于云文件场景 在腾讯云的唯一可选项。且可与容器服务无缝结合



腾讯云服务在项目应用的细节

腾讯云容器服务，后台所有容器均依赖容器服务运行

腾讯云  用于加速和堆栈的翻译速度

腾讯云  数据库，用于结果表的存储及产品配置

腾讯云  服务，用于文件存储

腾讯云  服务，用于配置下发




腾讯云  用于定时计算指标数据并出库到 供页面展示

 使用 腾讯云容器服务
建立集群
  编辑集群信息  选择容器宿主机配置  最后的一些琐事
运行服务
说到运行服务，不得不提到有两种方式，适合于不同场景
 通过腾讯云控制台创建服务
 适用于新手用户，简单快捷，覆盖到了常用功能

 通过  命令行工具创建服务
 适用于进阶用户，解锁全部服务能力，例如 ，等等，并且服务配置可纳入版本管理系统

登陆任意一台集群内主机即可使用  命令行
    可为设置命令行自动补全
 只要附带了证书信息，是不必非要在腾讯云主机才能操作，详见下面文档

腾讯云容器服务官方文档相关操作的描述已经很详细了 
使用负载均衡暴露服务
说到负载均衡，不得不提到有两种方式，适合于不同场景 ～
 通过腾讯云控制台创建负载均衡
 适用于新手用户，简单快捷，覆盖到了常用功能
网页操作比较简单，这里不在细说。可参考腾讯云容器负载均衡官方文档 
 通过  命令行创建负载均衡
 适用于进阶用户，可将负载均衡配置纳入版本管理系统 关于负载均衡的详细配置，例如检测周期等，需要在控制台配置
这部分内容较多，详情请参阅官方文档 
 使用 腾讯云

基本配置

申请权限 

创建表，这里建议大家使用创建，并且把放到版本管理系统中。




腾讯云  配置接入层的正在内测 只对白名单用户开放



腾讯云  配置接入层的


数据入库
数据入库的流程稍微复杂些，解释一下

首先我们应该编写一个配置，可以配置的为一个文件，看起来像这样的

配置里面有一个声明文件路径的地方，写一个自定义路径。可以将数据写入到这个数据，会将里面的文件自动上报到云端后台

写入数据到文件，这里要注意字段的顺序需要和配置保持严格一致


数据出库

配置出库数据库
编写  工作流
启动工作流，就可以丢下鼠标等胜利啦！

关于后台构建，有啥重点么？
整个数据处理流程十分简单 只有接入层 缓冲层 处理层 用户交互层
为什么呢  保持简单很重要 一个系统走到尽头的原因通常都是拥有了无数个无关痛痒的功能而最终导致代码臃肿不堪 最终迎来一次彻底的重构。这也是项目迁移到腾讯云的重要原因之一 以为已经太过臃肿 需要一次换血。所以说 系统的架构图就不会使用下面这样的 
任意两个模块间无直接交互 全部通过  以  的关系进行数据传递
为什么呢 ？  拥有很高的水平扩容能力 如果后台模块间无直接耦合 那么水平扩容所需做的仅仅是增加业务容器个数和集群规模即可啦
绝对 绝对不要更改字段的值或者删除字段
为什么呢  遵守上面的原则便可维护数据不可变性。在海量数据下 可以保证数据容忍重复消费 数据回滚等操作 因为数据回滚需要做的事情仅仅是删除几个字段然后把数据重新放回队列
一个字段在客户端 后台 数据库 前端都只能有一个名字
为什么呢  说出来都是泪，这个还是要具体经历过字段混乱带来的灾难后才可以体会。。。
 做好健康检查很重要
为什么呢  这不就使用    的原因么？希望发现异常使通过重启容器，解决大部分运行时问题，提升服务可用性。所以，要花力气检查好容器是否是正常工作才可以团建时候不被工单电话骚扰呀 
但是究竟有哪些点 自己项目和腾讯云都获得了成长 
近代著名思想家孔子日 双赢是最佳实践的入场券

在使用腾讯云 可以在低资源成本下不到经费 使我们快速搭建项目的原型 并得到现网环境的验证 | 关键字 低成本 快速验证

在我们的使用过程中 遇到的或者体验问题 及时反馈给了腾讯云同学 并快速得到了解决 | 关键字 合作 改进

项目作为基础服务 支持独立部署后 可作为平台能力 为腾讯云带来更多潜在用户 | 关键字 共同利益 发展


 上面的标准式回答真的是太假了 能不能来些足够感性的栗子 

腾讯云的  服务在使用初期 事实上处于内测阶段 会不时出现任务失败的情况，所以会经常反馈问题。

对话风格由   鲁班 今天任务又失败啦 帮忙看下原因哈 ［鲜花］变成了         我 你们业务今天有任务跑失败啦 是不是最近改了任务配置呢 ？
这是系统后台监控越来越完善的例子有米有   | 关键字 先于用户发现问题

在使用过过程中 遇到了腾讯云缺少客户端的问题 在进度压力下 我们开发了  客户端并在后续版本与腾讯云共同维护 | 关键字 共同承担

在使用  的  插件上报数据时 会偶尔出现进程因为网络不稳定退出的问题 我们把 的插件化后 由做健康检查来维持进程存活并将方案同步给了腾讯云的同学 腾讯云的同学积极响应 并在两天内完成了插件稳定性的提升工作 | 关键字 互相督促


如果有腾讯云流式数据处理或者能力建设相关的问题或者经验，欢迎在本文留言一起讨论。接《  摄影中的深度捕捉     上篇》
   

是显示如何使用  拍摄照片和电影的示范代码。

注意，虽然已经添加了深入支持，但是你看不到任何相关的东西。因为当能够拍摄这些铅笔时，实际上并没有看到深度的表现，而是存储在照片中。

照相结束后，打开相册后编辑，上面有了景深的按钮，可以对景深做效果处理。在 中，以人像模式拍摄的所有照片现在都会在照片中存储深度信息，因此它们会为您的新创意应用程序添加素材。
  
当拍摄深度照片时，支持很多的捕获选项。

可以使用深度进行闪光拍摄，可以静态图像稳定带深度信息。 甚至可以自动曝光括号，例如加，减 。 可以使 带有深度信息。
   

，这是去年推出的一个类，它是  的继承者。它处理复杂的照片请求非常出色。
编程模型是填写一个称为  的请求，通过传递请求和稍后再调用的代理来启动照片捕获。而且是捕获实时照片，裸图像和 宽色图像的唯一界面。此外，在 中，它是捕获文件格式的唯一方法。 需要进行许多更改以支持，因此在 中，为了适应这些许多变化，添加了新的委托回调。
一个简单示例：

 _     
  
这是替代将获得示例缓冲区的回调。现在得到一个名为  的新对象。 是深度唯一的传递媒介，所以如果想要深度，需要通过实现这个新的代理回调来操作。
   

此外，在开始会话之前需要明确地选择 。它需要放大到倍，使焦距匹配，并且需要锁定自己，禁止缩放。
开始运行会话之前，告诉我想要 ，然后在每个照片请求的基础上，这里是当你实际拍摄照片，你会填写一个设置对象，并且再一次我想在这张照片中深度。
然后，可以使用产生的，它具有一个名为  的访问器。
    

在上，大多数格式都具有比流式分辨率更高的静态图像分辨率。也是同理。
如果是流式深度，用实时的方式来满足 ，有很多工作需要做，但是如果是照片，有一点额外的时间，因为它不需要实时发送，所以可以达到非常高品质的，超过流分辨率的两倍。
长宽比与视频的长宽比一致。
    
捕获和嵌入照片的深度图都是畸变的。
之前展示的所有相机图是针孔相机。 针孔相机没有镜头，因此图像是直线的 也就是说，光以直线穿过小孔，并在图像平面上呈现几何完美的复制倒置物体。

如果有一个这样的完美的正方形网格，并用针孔相机拍摄它，它将在图像平面上看起来像这样，但是颠倒的。直线会保持直线。
但是在现实世界中，需要让更多的光线进入，所以需要镜头，镜头有径向变形。这些失真也存在于捕获的图像中，因为它们以稍微奇怪的方式弯曲成图像传感器。
在极端情况下，通过不良镜头捕获的直线可能看起来像这样：

在比较广角和长焦图像之前，必须做一个额外的步骤：
必须使那些扭曲的图像直线化 也就是说，使用校准的系数集合来解决它们，并且这些系数表征了镜头的失真。
  

现在可以确定地比较两个图像中的点，并找到一个完美的，真实的，直线的视差图，看起来像这样：

差距图匹配物理世界，但它与刚刚拍摄的图像不符，因为镜头有扭曲，所以现在必须做另一个步骤，就是将视差图重新映射回图像，使用一组逆透镜系数来做到这一点，最后的视差图具有与其伴随图像相同的几何失真。


这意味着开箱即用的附带的照片适用于过滤器，适用于效果。不完美的是重建场景。 如果想这样做，应该使它们是直线的：
   
简单地介绍图像文件中的深度数据的物理结构。

 苹果有两种图像支持深度。第一个是 ，新格式，也称为文件，对深度的支持是最好的。文件内有一个称为辅助图像的区域，可以存储视差或深度或透明度，这就是存储的地方。
我们将其编码为单色，还存储对于深度工作非常重要的元数据，例如有关滤光器的信息，精度，相机校准信息如镜头失真以及一些渲染指令。所有这些都与辅助图像一起编码为。

第二个就是，虽然这并不是很好的方法，但还是支持了。是位有损，如果它被过滤，或者如果它没有一个数字，使用位无损编码来保存所有非数字，苹果将它作为第二个图像存储在的底部，如果你熟悉的话，它就像一个多画面对象。同样编码是。
  
对于双摄像机最需要的开发者功能，双重照片捕获。
到目前为止，当使用双相机拍照时，仍然只能获得一张图像。 它是来自广角还是来自长焦，取决于缩放的位置，或者如果在和之间的区域，可能会获得两者的一部分，因为苹果进行了一些混合，使得到更好的图片，但仍然只有一个。

现在，苹果两张图片都给了：通过单一请求，可以获得广角和长焦的全部万像素的照片。
   

与上述的深度操作非常相似。设置两个属性    为。照片的回调就会给两份。
假设你要求 和 双照。 那么会得到份，因为将得到两个广角和两个长焦的和。
  

现在，我们支持与深度相关的所有功能，可以使用双摄照片，自动，曝光等级，可以根据需要选择深度。
    

假设你的应用程序只显示长焦的视野。 那么广角摄像机有更多的信息，所以如果你拍照，实际上给人的可见区域以外的东西，这可能是一个隐私的关注。所以如果是缩放，苹果提供双重照片，但外部变黑，使它们与预览中看到的视野相匹配。
如果您想要完整的图像，可以不要设置缩放。
怎么知道外面是否有黑色区域？在图像内部，存储一个纯净的孔径矩形，它定义了有效像素的区域。

也可以使用相机校准数据传送双重照片。相机校准数据是进行增强现实，虚拟现实，镜头失真校正等需要的数据。 因此，无论是广角的还是长焦和相机校准数据，都可以制作自己的深度图。
 

相机校准的属性。 是相机校准的类。如果要求深度，可以得到一个 。 这就是  的属性。 如果从中选择了此功能，也可以获得该功能。 所以选择加入这个照片来说，我想用相机进行相机校准，这个照片效果很好。
如果正在进行双重照片拍摄，需要双面照片，并要求相机校准，将获得两张照片回调，并且可以获得具有广角效果的广角校准，和具有长焦效果的长焦校准。


和之前的 情况很相似。但是仅仅是这样深度数据的分辨率可能非常低，所以苹果又提供了一套单独的维度。通常，它们是传感器的完整尺寸，因此，您以获得很多精度，在  中有很高的分辨率。


：这是描述相机在真实世界中姿势的属性。当使用从立体矫正摄像机得到的图像进行三角测量时，需要将其与另一个相比较。而外在特征被表现为一个单一的矩阵，但是两种矩阵被挤压在一起。
左边是旋转矩阵。这是一个，它描述了相机相对于真实世界如何旋转。

还有一个矩阵，描述了相机的翻转，或与世界边缘的距离。注意，当使用双摄像头时，长焦摄像机是世界的边缘，这使得它非常容易。
如果只是得到一个长焦图像，你得到的矩阵将是一个单位矩阵。 如果正在使用广角和长焦，广角将不是单位矩阵，因为它描述了与长焦镜头的姿态和距离。 但是，使用，可以计算广角与长焦之间的基线。

这里有两个属性需要注意。一个是 。这描述了传感器上与镜头失真中心重合的点。这通常与镜头的光学中心不同。
就像上图的扭曲，透镜上的径向扭曲像树环一样，这将是树环的中心。
同时还有一个属性是，可以将其视为将  连接到最长半径的多个浮点数。 是包含在数据中的浮点数组。如果沿着这些虚线的每个点都是，那么就拥有了世界上唯一一个完美的镜头，因为这就根本没有径向畸变了。
如果是正值，则表示半径有延长。如果是负值，则表示有压缩。
将整个表格整合在一起，就可以了解镜头的颠簸情况。
要对图像应用失真校正，需要以一个空目标缓冲区开始，然后逐行迭代，并且对于每个点，都使用  在失真的图像中找到相应的值，然后将该值写入到输出缓冲区中的正确位置。

这个是比较难实现的代码，苹果在  中提供了一个参考实现。实际是把代码放到了头文件里面。全都有注释。是个很大的 函数。它描述了如何纠正图像或如何反扭曲图像，具体取决于传给它的表格。还有一个表格的逆，它描述了如何从扭曲回到非扭曲。



  双摄像头不是飞行时间相机系统，是系统。
此外，苹果平台上对深度的规范表示是 。
了解了、、 的信息。都是  的属性。
了解了，它提供了可以过滤的流式深度。
可以使用  捕获带有深度信息的照片。
最后讲到了双摄像头，双照片，对于某些计算机视觉可以单独用到广角和长焦的照片。随着越来越多的企业逐步把自身基础设施服务迁移到云上，云上的安全风险趋势到底如何？近期重大勒索事件频频发生，企业该如何去有效提升自身的安全防护能力？在这里，我想跟大家分享一下我们云鼎实验室对云上安全风险的趋势观察，以及对企业用户的一些建议。

▲腾讯云鼎实验室负责人  在  
云上安全风险趋势
数据库类服务端口风险高。端口就是服务器的入口，入侵者往往使用扫描器对目标机器进行端口扫描，然后实施攻击和入侵。在去年和今年年初，爆出了多起企业数据库服务被加密勒索事件，需要支付比特币才可以获得数据解密；今年月号，我们云鼎实验室发布的《 成勒索新目标，数据服务基线安全问题迫在眉睫》就对这些事件进行了分析，主要是企业在在公网上开放了、、等数据服务端口，同时由于存在弱密码或者没有密码，黑客可以直接访问，导致被黑客入侵勒索。
漏洞是造成入侵的主要途径。根据我们对被入侵机器的入侵原因分析结果来看，漏洞是造成服务器被入侵的主要途径，约超过的入侵事件跟漏洞有关。而国内企业，对漏洞的修复情况是非常不理想的。方程式漏洞被公布以后，我们针对漏洞的修复进展进行监测发现，某企业在爆发一个月后只对其中约的漏洞机器进行了修复，两个月后，还有的漏洞机器并未修复，这样就给入侵者提供了可乘之机。而在小型企业，整体修复比例往往还要低得多。
密码破解攻击呈现常态化。相对于应用漏洞，暴力破解的利用方式比较简单，成功后可以直接获得目标服务器权限，从而进一步进行植入木马、后门等操作，整个过程通过自动化程序实现，是一种成本极低的攻击方式。而据公开资料说，某上日均遭受破解攻击万次左右，腾讯云上每台机器日均被攻击次。云主机相对遭受的破击攻击次数少，这主要归功于云平台厂商在网络出口对一些恶意的破解行为做了自动化拦截。
高危漏洞的出现，容易造成木马病毒感染高峰。漏洞包公开漏洞期间，木马检出量先后发生了两次爆发。当前云上监测到的木马文件主要分为两大类型，占比及二进制木马占比。主要通过应用漏洞上传写入，主要在入侵过程起到跳板的作用，方便进一步进行提权、植入恶意文件等操作；而二进制木马主要带有挖矿、端口扫描、等恶意行为，是整个入侵的最终目标植入。目前，利用漏洞包漏洞传播的病毒最多的并不是，而是挖矿病毒。而已经具有很强的免杀特性，建站工具弱口令问题则是的上传主要来源。
服务器上安全软件使用率偏低。目前，云上只有约的服务器使用了安全软件，整体使用比例偏低，这里面，其中有很大一部分的用户使用了安全防护软件来解决服务器安全防护需求，说明目前国内的服务器安全防护软件在市场上影响力不大，也在一定程度上反映国内的服务器安全软件市场值得继续大力投入。
云上更安全
企业面临的整体安全环境并不乐观，漏洞仍然是造成入侵的主要途径；黑客也在逐步升级自己的技术，一些低成本高收益的攻击逐渐自动化，例如密码破解攻击呈现常态化趋势；随着比特币这类匿名电子货币的兴起，使得黑客变现的主要方式从劫持肉鸡流量进行变现，变成了加密勒索。
但前段时间，在和暗云事件的爆发中，我们对云上用户和普通用户的感染风险进行了对比。云上更安全的显著统计差异，坚定了我继续深耕云安全的决心。
勒索病毒的爆发，使得全球个国家受到了影响，在我们国内也有万左右的用户中招。据统计，全球因此造成的损失达亿美元，并且深入影响到金融，能源，医疗等众多行业，造成严重的危机管理问题。部分企业的应用系统和数据库文件被加密后，导致无法正常工作。然而在云上的企业用户，因为及时做了大量的预警和防护工作，被感染的比例很小。
而近年来感染用户最多的木马之一，暗云，它的功能比较复杂，通过修改多个游戏微端，采用多种技术方案逃开杀软检测，还自掏腰包买流量，推广感染的游戏微端，更新频繁，影响用户数百万。病毒团队通过各种手段获取暴利，更发动针对国内多家云服务商的攻击。我们云鼎实验室在第一时间发现并确认了样本关联性，并联合腾讯电脑管家和多个安全合作伙伴进行全网清理，有效降低了暗云木马的影响。
对企业用户提四点安全建议
第一是要重视数据备份。任何企业都需要考虑一些突发灾难或者黑客攻击带来的业务中断，一旦遭受这类黑天鹅事件，快速恢复业务才能把损失降到最低，所以数据备份是一个十分重要且不可忽视的工作。我们在云上，可以方便的通过云平台提供的镜像备份，云存储服务来实现对重要数据进行备份。
其次是软件要及时更新。前面提到，造成入侵的主要原因是自身存在漏洞，事实上，新漏洞爆发出来时，软件生产者都会第一时间公布修复补丁或者方案，对于运维人员来说，及时打上补丁就可以消除漏洞风险，目前看来，及时打补丁依然是对抗漏洞风险最有效的手段。
第三是提升员工安全意识。安全意识一定程度上代表了企业安全事件的出现几率，很多企业发生的安全事件都是因为内部员工安全意识薄弱导致的。例如，某员工将公司网站代码储存到某第三方平台，被发现后被大面积曝光，导致公司出现了严重的数据泄露风险。事实上，行业内安全做得不错的成熟型企业，都有一些机制来促使员工在日常工作中更多的思考安全风险，定期进行员工安全意识培训和考试还是容易做得到的。
最后一点建议就是基础设施上云。业务上云后，你会发现，便利性提升的同时，整体安全防护水平也会提升。因为在基础设施层面，云平台厂商会提供统一的安全运维保障，而在服务和应用层，云平台厂商同样会提供丰富的安全解决方案供企业选择，所以，相对于云下，企业在云上可以低成本、更灵活地构建起安全防护体系。近两年，“野蛮生长”的国内手游市场开始呈现降温态势，而在市场趋于理性、成熟的过程中，开发者将面临更激烈的用户争夺。据移动大数据服务平台最新趋势报告显示，手游行业正在经历增速放缓、玩家增长趋于饱和、流量获取成本增高等瓶颈难题。数据表明，用户日平均打开游戏款数较去年呈下降趋势，手游玩家偏好更加挑剔，用户流量将集中在少数应用。这意味着新竞争格局下，唯有精耕细作的精品化手游路线才能突破重围，站稳市场。
近日，腾讯云联合腾讯重磅上线一站式手游质量提升方案，全面开放内部全链路测试解决方案，涵盖兼容、安全、性能——测试三部曲，输出腾讯级“魔鬼式”测试流程和技术评审标准，帮助客户在各个环节高效完成手游精品化打磨。
诊断时间|你的游戏遇到以下了吗？
•     游戏崩溃、闪退版本的兼容性问题是手游上线前最常见的，涉及超过种机型、多种系统版本、加上各异的软硬件环境，适配起来难度可想而知。据腾讯年全年测试调研数据显示，兼容问题出现最多的类型包括：安装失败、异常、、崩溃等。而这四个问题中的任何一个，都足以让玩家直接放弃游戏。
对症|兼容测试

全量兼容测试的个环节测试专家建议，手游上线前，必须对个环节进行全量兼容测试，以确保游戏在上千台安卓机型、和主流  机型上可以兼容。针对关键游戏场景，则有必要进行深入测试，以保障玩家的优质体验。
三种场景，有的放矢腾讯云根据客户实际需要，灵活提供三大兼容测试模式，覆盖台安卓主流机型，供开发者在手游研发、上线前后等不同阶段组合使用。
    标准兼容测试，快速自动化地发现适配问题，保障人工测试品质、提高测试效率的多机同步助手    专家兼容测试，面向重度兼容问题的细分需求，由腾讯金牌测试专家手工整理报告，提供全程技术支持，共享腾讯游戏测试流程及审核标准，如腾讯严格问题评级、腾讯测试审核标准等
更高级的游戏制作水平意味着更苛刻的兼容要求，例如现象级精品游戏《王者荣耀》的自动化测试。团队针对性研发了框架，获得官方推荐，现为腾讯游戏的标配框架，被应用于《火影忍者》、《龙之谷》等众多项目的各种测试场景中。

坚守人工品质目前，在腾讯游戏内部，大部分的兼容性测试仍然使用人工完成，其实内部成本相当高企。但经过团队实际测试对比验证，相比第三方自动化测试，无论是在验证必现性、测试深度、还是复杂问题操作上，人工测试服务都能提供更精准、有效率的精品化路径指引。
 腾讯兼容测试更有效定位严重必现缺陷，覆盖更多核心内容
•     游戏外挂、漏洞近几年如此火热的手游市场吸引了大量外挂、辅助、工作室等非法盈利团队，外挂直接破坏游戏的公正性，严重影响了游戏的收益、口碑，缩短游戏的生命周期，同时暗藏安全隐患。
对症|手游安全专家测试 
在腾讯内部，通常在游戏版本转功能测试的阶段就介入了安全模块的测试。腾讯的手游安全测试开放的独家漏洞挖掘技术，针对静态安全漏洞和动态安全漏洞的不同特性，分别进行差异化的测试和修复。
根据对漏洞类型的提炼，安全测试团队紧密结合具体玩法，完全模拟外挂工作室分析游戏作弊点的过程，找到通过非正常途径的获益点，进而准确预判游戏中可能产生的诸如钻石盗刷、服务器宕机、无敌秒杀等风险点，生成可实操的执行用例，形成完整闭环。

该团队的工程师均来自实战经验丰富的腾讯手游漏洞测试团队，曾服务过逾款腾讯自研、代理游戏，累积服务产品版本超过个。在《梦幻诛仙手游》项目测试阶段，手游安全测试团队累计挖掘出了个致命级漏洞，个高危级漏洞，个中危级漏洞，并第一时间制定修复方案，评估和验收结果与风险，为《梦幻诛仙手游》的稳定运行提供了坚实的技术保障。
•     游戏延迟、卡顿据全年测试数据显示，手游内存问题在低档机型上尤其严重；而在游戏类型上，角色扮演、动作冒险、体育运动类游戏是重灾区。随着玩家对游戏流畅度的需求日益苛刻，延迟、卡顿等游戏性能问题，将直接影响游戏体验，造成用户流失。

对症|客户端性能测试 
腾讯内部对于手游性能的测试和监控非常重视，新版本发布之前会再三确认性能是否符合发布标准，哪怕是的偏差也会被退回、无法发布，用户常见的闪退、花屏等性能问题，也被内部的专家团队细分成具体的性能问题指标，再之上做处理和优化，堪称“魔鬼式”手游锻造流程。
腾讯推出了专门的性能测试工具来帮助用户实现精准定位。除支持通用的、、内存等问题外，针对现在越来越多的引擎游戏，上线 资源分析、内存、重度性能等多款工具，帮助手游开发者简化性能测试的环节，更精准地定位问题。
  手游标准性能分析结果部分截图
 资源报告分析结果部分截图
真正的一站式质量提升解决方案
除兼容、安全、性能必备测试三部曲之外，腾讯云手游测试解决方案还囊括了真人游戏体验游戏评测以及产品口碑和评论监测企鹅风讯，提供真正一站式手游精品化打磨服务。开发者只需要针对游戏类型的评估，参照上线流程指引，选择所需服务，即可开启精品化手游锻造之旅。月日，一种名为“”的新型勒索病毒席卷了欧洲，乌克兰等国家，多家银行和公司，包括政府大楼的电脑都出现问题。同时，在日点左右，腾讯云联合腾讯电脑管家发现相关样本在国内出现，腾讯云已实时启动用户防护引导，截止目前为止，云上用户尚无感染案例，但建议没打补丁用户尽快打补丁避免感染风险。
经云鼎实验室确认，这是一种类似于“”的勒索病毒新变种，传播方式与“”类似，其利用 永恒之蓝和   机制漏洞进行传播，同时还具备局域网传播手法。腾讯云主机防护产品云镜已第一时间检测该蠕虫，云鼎实验室将持续关注该事件和病毒动态，第一时间更新相关信息，请及时关注，修复相关漏洞，避免遭受损失。
病毒特征
在中了该病毒后，电脑将会被锁住，出现以下勒索提示信息，并要求支付美元的比特币才能解锁。

图：勒索提示信息
影响范围
通过分析，我们发现病毒采用多种感染方式，其中通过邮件投毒的方式有定向攻击的特性，在目标中毒后会在内网横向渗透，通过下载更多载体进行内网探测。
网络管理员可通过，监测相关域名，拦截病毒下载，统计内网感染分布：







网络管理员可通过如下关键排查内网感染情况：




防护方案
经过确认，勒索病毒是利用  进行传播，可以采用以下方案进行防护和查杀：
  腾讯云用户请确保安装和开启云镜主机保护系统，云镜可对海量主机集中管理，进行补丁修复，病毒监测。
 更新对应漏洞补丁补丁下载地址：

=






 终端用户使用电脑管家进行查杀和防护
电脑管家已支持对  的免疫和补丁修复，也支持对该病毒的查杀，可以直接开启电脑管家进行防护和查杀。
相关推荐
主机安全云镜前言：
上一篇《引擎资源管理代码分析  》主要分析了引擎的、、等接口的实现。本篇则着重分析相关的资源加卸载接口，并对所有的资源加卸载优劣做一个简明的总结和对比。
       、
前文中提到，使用类的接口来单独卸载一个及其下子节点和挂接资源已经无望，那如果我们把一个或多个打包到一个单独的中，然后再通过来管理资源是否就可以达到加卸载部分资源的目的呢？
假设我们已通过类或等接口完成了本身的加载，让我们先来分析下从中加载资源的接口。由于通过加载资源的代码跟上文联系更加紧密，因此有关加载的接口我们留到后续的章节中再具体讲解。
的对应函数实现
        
{

      = 
      = 

     
    
     
         

     
}
的对应函数实现
        
{
      = 
    
}
由代码可见，这两个函数其实最终都是通过这个内部函数来加载内的资源对象的。只不过在函数中，是先通过函数根据资源名称收集了同名的对象列表。而在函数中，则是粗暴地获取了所有对象的列表。
注意这个函数的实现很像我们在讲解接口时提到的函数，它会获取所有小写同名的对象，而不论类型是否相同。但在对象加载完成后，函数却只返回了数组中的第一个对象。而此时其它的同名对象其实也已经被加载了，白白浪费了时间。甚至有可能加载上来的对象并不是我们想要的那个对象，从而产生错误。
 函数的内部实现则非常的简单，它只是遍历了下每个对象中包含的对象列表，然后通过函数去强制访问其指针，从而调用了  这个指针引用重载操作符。接下来的实现就和一样，在  的全局对象列表中没有找到这个对象的实例，如果没找到则通过去加载它。只不过在中这个对象对应的文件标识符指向了包含它的文件。
       
接下来我们分析下接口。这个接口并没有用来指定具体需要卸载哪个资源的参数，而是只有一个用来控制是否要卸载内所有对象的参数 。
 对应的函数为，根据参数的不同，它的执行流程有所不同。
当为时，这个函数会通过将所有关联到这个文件的对象全部删除，无论这些对象还有没有被别的对象所引用。该函数不会删除文件数据，可以用来卸载资源对象。
当为时，则只会从中删除所有对象到这个文件的关联关系，而不删除对象本身。
之后的流程则无论参数如何都一样，删除对应的对象，清空所有的两进制文件数据流。
除此之外，当我们加载多个存在依赖关系的时会有特殊的情况出现。例如我们打了两个，和，中包含和，中包含引用这个和资源的。但由于此时在中，和资源是关联到中的，而是被关联到中的。因此当我们加载时必须先加载、再加载，如果先加载则会找不到对应的加载文件。而当我们卸载时，如果只卸载了，则只会卸载，和不会被卸载。如果先卸载了，会发现下的和对象已经变为了。所以在使用时必须严格遵照之间的依赖关系来顺序地执行加载和卸载操作。
      、
在讲解这两个接口之前我们需要先了解下这个引擎内部的类，它有两个主要功能：
 当我们使用网页平台的引擎客户端时，也就是通过呈现游戏内容负责从网上下载的原始数据。通过引擎自己实现的下载代码
 使用单独的线程将的原始数据解压缩，并保存在其中。如果输入是压缩格式的。
在和平台上，实际上只有的解压缩功能是发挥作用的。而和这两个接口就是通过这个类来完成数据的加载和解压缩的。
的函数执行流程如下：
 直接在主线程中了一个对象，并将传入的内存数据填充到其中。
 启动类自己创建的异步解压缩线程，然后在主线程中等待其解压完成。
解压完成后，调用这个函数，将包含已解压数据的对象传入其中，并使用其已解压的数据在中建立对应的内存流对象。
完成对象的初始化，建立其中和对象的数据映射关系。
的函数执行流程如下：
 创建了一个继承于基类的异步操作执行对象，并加入异步操作执行队列。忘记实现原理的读者请参阅前文中关于接口的相关说明。
 在的构造函数中一个成员对象，然后将内存数据复制到其中。
开启对象的数据异步解压缩线程。如果需要解压缩
在创建的异步处理线程中调用对象的函数，并在函数中等待的异步解压缩线程完成其解压工作。
函数执行完毕后，会在主线程中再次调用的函数，并在其中调用函数。
调用函数，其内部执行步骤与相同。
由此可以看出，和相比，函数只是没有在当前帧阻塞式地等待数据的解压缩过程，其它的实现是基本相同的。
由于这两个函数都会在对象内复制一份原始的数据，因此算上传入数据的原始空间占用，它们的峰值内存占用都至少在原始数据容量的两倍以上。如果是压缩的，则还要分配解压缩，则峰值内存占用有可能达到三倍以上。

这个接口在引擎内部的实现也是调用函数，但是不同于接口调用的传入对象的函数，它调用的是传入文件路径字符串参数的重载版。这个重载版的函数会直接通过文件系统读取文件头，并判断其是否为压缩格式的。如果为压缩格式则直接报错返回。如果是非压缩格式则在中建立映射到磁盘文件的对象，而并非一次性地将全部文件数据读取到内存中。这样做的好处是即用即读，不会造成过大的内存开销。
  通过加载
类的功能是根据地址下载原始数据，它的内部实现为， 一个第三方的基于的数据传输库。当我们通过 “  ”这行代码创建一个对象时，底层就会创建一个类的对象，并开启一个单独的线程调用的进行数据的传输。如果地址为“ ”开头的本地文件地址会自动进行磁盘文件的读取。当所有数据传输完毕后，类会创建一个对象，传入的内存数据，并启动的解压缩线程开始进行解压缩操作。
 这里我们需要注意的是，如果在完对象后不对 属性进行任何访问，引擎则不会等待对象传输完数据，更不会等待对象的解压缩线程结束。只有在第一次尝试访问 属性时，引擎才会调用底层的___函数，开始阻塞式地等待解压完成，之后再通过函数创建真正的对象。因此我强烈建议大家在游戏场景资源加载完成之前，对所有的 对象进行一次显式的访问，例如   =  以完成的加载。
 最后提醒大家，由于的类只有在它的析构函数中才会真正释放掉为分配的数据内存。而在的实现中，如果不显式调用的接口，则只有在自动执行垃圾回收时才会真正删除的对象，并调用其析构释放掉分配的内存。所以建议大家不要同时创建多个对象进行的加载，而应该通过队列把加载工作都放到一个协程内来进行。
四、总结
前文中对 版本引擎中常用的资源加卸载接口实现逐一进行了分析，下面我们从应用角度对各类的优劣及适用性进行一个简明的概括，以方便大家对比和使用。



最后感谢大家耐心地阅读完了本文，作者我表示感激涕零。由于时间紧张还没有深入地对源码的每一处实现细节都做出完整的分析，如有疏漏敬请提出！这是《使用腾讯云学习深度学习》系列文章的第六篇，本文以如何识别马路上的行人、车辆为主题，介绍了基于  的  模型如何应用在物体识别定位项目中。本系列文章主要介绍如何使用腾讯云服务器进行深度学习运算，前面主要介绍原理部分，后期则以实践为主。
往期内容：

使用腾讯云  学习深度学习系列之一：传统机器学习的回顾
使用腾讯云  学习深度学习系列之二： 简明原理
使用腾讯云  学习深度学习系列之三：搭建深度神经网络
使用腾讯云  学习深度学习系列之四：深度学习的特征工程
使用腾讯云学习深度学习系列之五：文字的识别与定位


我们在第三讲中，提到过如何搭建一个简单的深度神经网络，识别一张图片中的单一物体。进而在上一节中，以车牌为例，谈到如何识别多个物体。
但是实际上，上一讲提到的技术，在实际应用过程中，会遇到问题，就是我们需要识别的物体，未必会给我们机会去“摆拍”。比如对于车牌识别，我们想要的数据是这样的：

但是我们从摄像头拿到的车牌数据，可能是这样的：

这下我们上一讲提到的 “ 识别准确率”，可能就一点用都没有了，因为我们 不仅要识别目标，更需要对目标进行定位——没有人会帮我们用截图工具从第二张图中“抠图”，得到第一张图中的样式，再给我们去训练深度学习模型。而我们接下来要讲的，就是如何同时实现物体的识别与定位。这里我们以  模型为例，谈一谈如何在上图中，识别车辆和行人。

 物体识别与定位原理
 思路——基于网格搜索
首先是物体 识别问题，这里回顾下第三讲最后的  分类。
 给出了物体的截图信息：

下一步可以根据这些截图，训练一个分类器：
__ _ _=_
                    _=_
                    _=_ _
                    =

我们训练好分类器  之后，可以载入新的图片，用训练好的模型预测分类结果：
 使用训练好的模型，预测输入图片属于  哪个类
 
__ = 
__ = __  
 = __

有了分类器，接下来要做的，就是 用分类器扫描整张图像，定位特征位置。这里关键的方法，就是用什么算法扫描，比如可以将图片分成若干网格，用分类器一个格子、一个格子扫描，这种方法有几个问题：

问题： 目标正好处在两个网格交界处，就会造成分类器的结果在两边都不足够显著，造成漏报 。
问题： 目标过大或过小，导致网格中结果不足够显著，造成漏报。

针对第一点，可以采用相互重叠的网格。比如一个网格大小是  像素，那么就网格向下移动时，只动  个像素，走四步才完全移出以前的网格。针对第二点，可以采用大小网格相互结合的策略， 网格扫完， 网格再扫描一次， 网格也再扫一次。
但是这样会带来其他问题——我们为了保证准确率，对同一张图片扫描次数过多，严重影响了计算速度，造成这种策略 无法做到实时标注。也就是说，如果应用在无人驾驶汽车时，如果前面突然出现一个行人，此时模型一遍一遍扫描整个图片、终于完成标注之后，可能已经是三四秒以后了，此时汽车已经开出去几十米，会造成很大的危险。
 深度学习框架对网格搜索的改进
于是，为了快速、实时标注图像特征，对于整个识别定位算法，就有了诸多改进方法。
一个最基本的思路是，合理使用卷积神经网络的内部结构，避免重复计算。如前几篇文章所述，用卷积神经网络扫描某一图片时，实际上卷积得到的结果已经存储了不同大小的网格信息，这一过程实际上已经完成了我们上一部分提出的改进措施，如下图所示，我们发现前几层卷积核的结果更关注细节，后面的卷积层结果更加关注整体：

对于问题，如果一个物体位于两个格子的中间，虽然两边都不一定足够显著，但是两边的基本特征如果可以合理组合的话，我们就不需要再扫描一次。而后几层则越来越关注整体，对问题，目标可能会过大过小，但是特征同样也会留下。也就是说，用卷积神经网络扫描图像过程中，由于深度神经网络本身就有好几层卷积、实际上已经反复多次扫描图像，以上两个问题可以通过合理使用卷积神经网络的中间结果得到解决。
我们先回顾下  之前的算法，在  算法之前，， 法都采用了两步的策略，即第一步通过深度神经网络，对潜在的目标物体进行定位，即先产生；至于 里面的物体如何分类，这里再进行第二步计算。此外第一代的  算法可以做到一步完成计算加定位，但是结构中采用了全连接层，而我们在 第三讲 的  部分提到过全连接层有很多问题，并且正在逐步被深度神经网络架构“抛弃”。

图片来源山人七深度学习知乎专栏
 就是一种一步完成计算、不采用全连接层的计算架构。一步到位的计算框架可以使计算速度更快，并且由于完全抛弃全连接层， 第三讲 的  部分提到全连接层带来的过拟合问题也会得到改善。：

图片来源山人七深度学习知乎专栏
 算法原理
构建 的深度神经网络框架

图片来源山人七深度学习知乎专栏
大体思路就是，用 深度神经网络的前五层，在额外多加六层结构。然后提取其中几层进过卷积后的结果，进行网格搜索，找目标特征。
代码：
_ = 
        _= 
        _=
        __=
        _=     
        _=           
        __= 
        _= 
                       
                       
                       
                       
                       
        _= 
                          
                          
                          
                        
                        
        _=     
        _=
        =     
        _=   


 _
            _=__
            _=__
            _=__
            _=__
            =_
            _=
            __=
            _=
            =
            =__
      
    
    _ = {}
     _ __  =
        
         前五个 ，首先照搬  架构   
         注意这里使用 _ 标注中间结果 
        
          
         =       =
        _ = 
         = _   =
          
         =       =
        _ = 
         = _   =
          
         =       =
        _ = 
         = _   =
          
         =       =
        _ = 
         = _   =
          
         =       =
        _ = 
         = _   = =

        
         后六个 ，使用额外卷积层      
        
                 
         =     = =
        _ = 
         =  =__ =_
               
         =     =
        _ = 
         =  =__ =_

                  
        _ = 
         __
             =     =
             = _ = 
             =     = = =
        __ = 
        _ = 
         __
             =     =
             = _ = 
             =     = = =
        __ = 
        _ = 
         __
             =     =
             =     = =
        __ = 
        _ = 
         __
             =     =
             =     = =
        __ = 

            
        
         每个中间层 _ 返回中间结果   
         将各层预测结果存入列表，返回给优化函数 
        
         = 
         = 
         = 
            _
             _  _
                  = ___
                                          _
                                          _
                                          _
                                          
            _
            
            

            _

在卷积的结果中搜索网格的位置：
这里的关键是生成网格。首先，由于  大小的卷积核，在卷积神经网络部分已经扫描了整个输入图像，并且还反复扫了很多层，所以这里不再需要考虑手动分网格是否会遗漏信息，因为各种卷积核已经将整张图像完全扫描一遍了。同时，我们注意到  卷基层的像素大小在逐步降低，而各层表示的都是同样的输入图像，也就是说，单个像素所能表征的物体大小，是在逐步增加的，所以也不需要考虑物体大小的影响。
根据刚才的网络定义， 会在 、、、、、 这六层生成搜索网格 ，并且其位置也是固定的。这几层搜索网格特征如下：



层数
卷积操作后特征大小
网格增强比例
单个网格增强得到网格数目
总网格数目





 
 

    



 
   

    



 
   

    



   
   

      



   
 

      



   
 

      



注意：单个网格增强得到网格数目 = 原有  同时缩小  网格增强数目长缩小宽放大、长扩大宽缩小
网格增强比例，指的是在同一位置，原有宽度乘以一个系数、长度除以一个系数，得到新的长宽。当这个系数是  时，增强结果如下图：

整个过程如图所示：

图片来源晓雷机器学习笔记知乎专栏。最早应该是在  网站上，但是 版本过早，晓雷对部分图片有修改。
这一步代码如下：
 对所有层生成网格                                  
 ____
                           ___
                           _==
    _ = 
        _
        _ = ____  
                                _ _ 
                                _ = =
        __
     _

 对其中一层生成网格
 ____
                         _
                         
                         
                         
                         =
                         =
      = _ _
     =       _
     =       _
     = _ =
     = _ =

    _ =   
     = _  =
     = _  =
          =
     =   _
     =   _
     = 
       
         =     _
         =     _
         = 
        
         =   _  
         =   _  
        

训练模型
训练模型的损失函数如下定义：

根据公式，写代码：
 =========================================================================== 
   
 =========================================================================== 
 _ 
                 
               _=
               _=
               =
               _=
               =
               =
     _ _
         = _ 
        _ = 
        _ = 

            
         = 
         = 
         = 
         = 
         = 
           
              _
             
             
              
              

            
         =  =
         =  =
         =  =
         =  =
         =  =
         = 

            
         =   _
         =  
        _ = _

           
         控制 负样本正样本_ 在  左右
        _ =  
         = 
         = __
                                 
         =  
         = 
                            
                             
        _ =  
              
        __ = _ 
        _ = _  _   _
        _ = _ __

          = __ =_
        __ = 
           
         = _   __
         =  

         识别物体损失函数 
         识别为分类物体
         ___
             = _____=
                                                                  =
             = _   _ =
            _
         识别为背景
         ___
             = _____=
                                                                  =_
             = _   _ =
            _

         预测位置误差损失函数 
         _
                   
             = _   =
             = __  
             = _   _ =
            _

在多个  训练模型，完整代码见  。核心代码：
 =================================================================== 
 定义单个  训练模型
 =================================================================== 
 __
         
      _
      
    _ _ _ _ = \
        ___ _

       
    _ = ___=_
                                  _=_
     __
           _ = \
            __ _=
       
    _ 
                   _ _ _
                   _=_
                   _=_
                   =_
                   _=_
     _

  实战
我们使用数据集， 到  大小的图像输入， 发表文章给出的训练结果，作为模型，来标注我们自己的输入图片以及视频。首先，安装需要的包，然后下载  程序
  
  
 __

 下载测试图片
   

 数据集总共有  个类别

导入必要的模块：
 
 
 
 

   
   
 

   
   


   __ _ _
   __

              
_ = _=
 = __= _=_
 = =

 = 

 

__ = 
                            
                                      
                        
                           


 定义数据格式
_ =  
_ =       ，  的格式

 预处理，以   将输入图片大小改成 ，作为下一步输入
_ =  =  
_ _ _ _ = ____
    _ 
     
     
    _ 
    _ 
    =___

_ = __ 

 定义  模型结构
 =   _    
_ = __
 ____=_
      _ _ = __ _= =

 导入官方给出的  模型参数
_ = __
__
 = 
 _

 在网络模型结构中，提取搜索网格的位置
_ = __

加载几个辅助做图的函数：
 _ _=
     =   _
    _ = 
       _
         = 
          
            _      
        
            _    
     _


 ___     =
     = 
       
         = 
         = 
           
         =      
         =      
            
          
         =    __ 
         =  
           __   

_ = _ _=

_ 函数可以对新的图片进行标注
    
 _ _= _= _= 
       
       _ = _   _
                                                              _={_ }

            
       = ___
              _
            _=_ _=_ _= =

     = ___ 
       = __   _=
       = __   _=_
              
     = ___ 
    ___    _ =
     

 = 
 =  _
_


看起来标注的还可以。
然后我们再标注一段视频，
为了处理视频文件，需要额外使用   两个包，而使用 ，则需要经过  安装 ：
 

   

视频摄于中关村附近，读者也可以上传自己的视频：
 _ _ _
     =  _
     = __
     __ =

___ 

    
   
|██████████|   
 
     

          
   
这个短视频使用华为荣耀拍摄，长度在  左右，每秒记录  帧图像，而  模型的实际处理速度在我的    上，则达到了每秒钟  帧图像，真正实现了图像的实时处理。处理结果如下，基本实现了对周围物体的标注：

结果是 格式，这里转换成  动图，做了些图像压缩，原版视频：

目前腾讯云  服务器已经在月日盛大公测，本章代码在普通云服务器上尝试，同样可以运行，但是无法做到图像的实时处理。要想做到实时标注处理图像数据，必须租用 云服务器 。服务器的租用方式、价格，详情请见 腾讯云  云服务器今日全量上线！接《霍金没有提威胁论，他的新目标是带领人类移民外星球 上篇》
姚期智：量子力学=？

量子计算专家、图灵奖获得者姚期智院士  
以下为姚期智演讲实录
大家好！今天非常荣幸能够有机会来参加这个盛典，谢谢主办人邀请我来这里和大家交流。
今天的题目是量子计算时代的来临。量子计算在学术的期刊上，在普通的报纸杂志上，现在是一个相当热门的常常被谈到的题目，那到底量子计算是什么？为什么量子计算比经典的计算机能够快那么多，仍然对大多数人来讲，还很神秘。
所以我今天的演讲来揭开这个面纱，我先给一个简短的介绍，也是一个相当有深度的介绍。
多年以前量子计算机被发现有一个非常奇怪的功能，大家知道是一个现在常用的密码系统，大家觉得这是一个高度的安全的密码系统，但是这个密码系统如果有了量子计算机以后，科学家证明它就变得不安全了，怎么一回事？
比如说我们想用一个的密码系统，用位数的整数来做一个密钥的话，用现在用最大的、最好的超级计算机，需要万年才能够做出来。但是如果在将来有了一个量子计算机有相当的储存功能的话，三个钟头就可以做出来。我这里用的数字是科学家的最保守的估计，一般人都认为它能够比三个钟头小的很多的时间就可以做出来。光是这样你就可以看到量子计算机能够破解现在没有办法破解的密码，这个震惊了世界学术界。
在我的演讲里面，我们想要回答两个一般人最想问的问题：
第一，量子计算为什么是一个革命性的计算原理，它和经典的计算机到底不同在哪里？它为什么会这么快？
第二，量子计算机什么时候会出现？
对于第二个问题，我们的了解是量子计算机现在基本上已经是呼之欲出，可以称为     。我们已经进入一个能看到量子计算机将要做出来的时间段，我们可以把它叫做最后的一里路，但这会是一个非常艰难的，也是需要经过一段时间的最后一里路。
所以说我在演讲里面，我要给大家一个有深度的解答，关于这两个问题。
第一，它到底是什么原理。
第二，它为什么是非常长的一里路。我们现在这些一般做量子计算机的科学家，他们现在的研究到底是哪一类的工作？
最后，量子计算机虽然它能够做很多事情，我们想要把它放到更大的视野来看，量子计算在整个计算的框架，甚至在整个世纪的科学里面，它有什么样的位置？有没有更高的价值？
我们先谈量子计算机它为什么和传统计算机完全不一样。我们中国有一个很古的寓言，是说“杨子见歧路而哭之”，杨朱看到有一只羊走失了，他走到了分叉的地方，他不知道羊在哪一条路上，这个时候他就不能够决定，觉得很悲伤，因为看起来唯一的方法，就是你必须先去走一条路，然后再走另外一条路。这代表着我们在做计算机的一个计算问题的时候，我们想要找一个答案，常常要搜索好几个不同的方向，来看到底哪一个方向才能够给你一个答案。所以说传统计算机就有这样的一个问题。在量子世界里面，这个问题能够得到解决。
我们可以这样想，在传统的世界里面，杨子看到有歧路，我们脑筋里面出现的一个景象，最好的解决方法是什么呢？如果杨子是孙悟空的话，这个问题就解决了，因为我在头上拔几根毛，变出很多个小孙悟空，每个人都走不同的路。这样的话，大家可以同时搜索，搜索的时间就短了，一个难的问题就变得容易了。
而在量子世界的时候，这些最微小的粒子本身就具有孙悟空一样的能力。所以，这是一个非常神奇的事情，在这种最微小的量子世界里面，一个小孙悟空可以一下子变成两个孙悟空，有一半的他走一条路，另外一半走另外一条路。
所以在量子世界里面，在这些最小的分子、原子之下，他们这些小孙悟空，如果我们在一种适合的情况下，他们真的能够有一个非常好的配合，能够让他们所有的分身全部分开，大家一起合作。换句话说，这个就是达到了我们的平行计算，基本上等于有无限多个能够运作的计算器给你用。
这里画了一个图见附图，是它的一个方法，一个孙悟空可以变成两个小孙悟空。这种能够分身的魔术，并不是在所有的计算问题里面，都能够达到这个效果，不幸的是，量子物理世界在原理上还有其他结果。但是，有时候它可以做到。
我们现在看看，我们刚刚讲的密码破解的时候，他用的原理是怎么一回事。在经典物理里面，它有一个和量子相似的情况，这个就是光，刚才你看到一个光，光有一个性质，大家碰到一起的时候，能够帮助消长。一个非常经典的光学实验，你如果从一个光源，放出一个光，经过一个屏幕，上面有很多的小洞，你在后面再放第二个屏幕，在第二个屏幕上，你就会看到，如果你看的精细的话，屏幕上的这个光，会有一个周期性的现象，有的时候亮，有时候暗，从亮到暗，可以看出有一个不同的变化。到底长的什么样子，它是跟光学的原理判断的。
重要的一点是，它这个变化怎么决定的，是由前面的波长、屏幕上的针孔之间的距离、参数所决定的。所以，你如果把这个问题反过来看，你如果看到结果以后，会告诉你原本的光源里面的性质。这个波的传播，从计算机的角度来讲，这个并不是太难做，是可以计算的。
在量子里面，我们怎么样用到刚才这件事情？在量子里面，如果说我们有一个密码，我们想要破解，我们可以把它代表成为量子里面的量子态，那么，这个量子态如果你设计它的光学设计，设计得好的话，它就有一个很有意思的结果，它是说你如果去量一量后面的这个的话，它会告诉你这个密码。
光学实验中，如果我们有了量子计算机，就可以指数性地把时间降下来。这样的话你在一个不太长的时间，你就能够量出这些有意思的，你把它反过去就可以查出来它本来的密码，到底它里面的秘密是什么。这并不是随便写出来的，我们刚刚讲的破解，就是用这个原理。
当然做量子计算机，除了想破解密码还有很多事情，它最重要的一个应用，如果我们有了量子计算机，我们就可以像现在能够模仿古典的物理，用我们的计算机做各种事情。如果有了量子计算机就可以解量子方程式，量子方程式它是最重要的一个方程式，如果你能解量子方程式的话，你可以解决很多物理上的问题、化学上的问题、生物上的问题，你能够做很多的事情。
同时量子计算机和人工智能也有关系。实际上有很多地方，经过这十几、二十多年的努力，在实践的建设量子计算机过程里面，现在取得了相当大的进步，我现在就把现在世界上做量子计算机所用的科学技术介绍一下，同时我介绍一下在我们清华大学量子信息中心所做的一些工作。
我们现在基本上经过这多年的努力，科学家已经了解到什么样的材料是最适合做量子计算机的，而且知道这个蓝图基本上是有了，但是它还是一个非常难的实践过程。现在大家已经可以听到，也许在以后的半年、一年有很多地方都会宣布，能够有个量子比特、个量子比特的机器。
这些当然令人兴奋，这离实用还差的很远，大家都还没有考虑怎么纠错，因为在量子计算机里面纠错是一个非常难的问题，我们可以看到我们现在进到了最后一里路，但也是非常长的一里路。
我想告诉大家，在清华大学量子信息中心做什么事情。现在有用超导做量子比特，也有用离子来做量子比特，甚至用钻石做量子比特，它们都各有优劣。比如说钻石，我们大家都喜欢钻石，但是它真正的好处是，它是一个固体，同时能够在常温工作，不需要用很多的冰箱来冰它，如果有一天要做一个钻石量子计算机，像钻石量子计算机又赏心悦目又有面子，你就可以放在你的桌子上。
另外还做一些拓扑的量子计算，对纠错特别好的，我们在六年以前觉得这个时机已经到了，理论都已经成熟了，工作也都知道往哪个方向，所以我们成立一个量子计算机所，在这个中心里面，所有的科技我们都做。我们经过这六年，已经成为世界上相当知名的一个量子计算机中心。
譬如我们做出第一个能够纠错的量子计算机，虽然只是在一个很小的基础上做。
在量子计算机里面最重要的事情是要做记忆，一是它需要有很多的存储，我们最近的一个工作就是在原子上面能够做出个记忆体，这个比以前增加了倍。
我们还希望量子比特存储得久，比如说秒就消失了，我们最近做的一项工作，用的是离子的量子计算。离子很有意思，它是先把原子用电离的方式做成变成离子，然后用镭射固定、冷却，同时操纵它。
我们有一个新的观念，能够做出一个存储很久的量子存储。不只用一种离子，是用两种不同的离子，就是一个离子来做存储，另外一个离子帮它的忙，给它散热，所以这个时间比以前增加很多倍。
最后，我讲讲量子计算在科学里面占什么样的地位，我想和大家说，对我来讲最兴奋的将来，就是我们现在两个最热门的题目，量子计算和人工智能可以结合在一起。因为人工智能可以是人类想要了解自然界，怎么样做出这么聪明的人，我们想要达到这个境界。
如果说，我们能够把量子计算用到这个里面，我们可能比大自然更聪明，所以在量子计算和人工智能中间，我们也做了一些工作见附图。
如果站在我们现在的视角，我们看这个宇宙，宇宙给我们两个很大的挑战，第一个就是宇宙告诉我们，量子物理能够做出一个很精妙的事情，如果没有量子计算机我们就不能引领它。在软件方面，我们人类能不能到达大自然所做出来的，孕育出来的物种。
我们，如果能够把量子计算机和放在一起，我们可能做出连大自然都没有想到会有如此结果的事情，谢谢大家！
附：姚期智演讲






















本来来源于 科技大本营 微信公众号一、 初始化
本质上，客户端实现的原理就是动态代理技术，中间的网络传输就是协议编解码和序列化技术，协议部分放到后面探讨，本节将围绕客户端初始化过程，生成代理对象和发起远程调用三个方面展开。
客户端生成代理对象之前需要做一些准备工作，整个初始化过程可概括如下，下面分点叙述：

 初始化
，即远程通讯器，用于发起远程调用时创建出代理对象，是整个调用的入口。
通讯器采用工厂生成单例模式，同一通讯器配置只会对应一个通讯器对象，配置一样可以从模版文件中读取，主要配置项包括：主控路由地址、同步调用超时时间、异步调用的超时时间、模块名、是否启用分组、上报服务状态的周期、最大连接数默认为个、最大线程数、队列长度、默认日志路径和级别等。
初始化过程中会根据以上配置的配置项基于算法为生成一个唯一性标识，接着初始化客户端日志设置默认日志路径和日志级别，构建客户端线程池，每个通讯器或模块对应一个业务线程池。代码如下：
      {
      {
        
    }
    
     {
          {
             {
                 
                  {
                     =  
                }  {
                     =  
                }
                 = 
                 = 
                
            }    {
                
                  
            }
        }
    }  {
        
    }
}
是事先定义好的远程代理接口，动态代理生成时将会继承该接口，同时继承传入的业务接口，绑定调用处理器。动态代理类同样采用单例模式，同一个服务标识只会对应同一个动态代理对象。如图：

远程调用的核心逻辑就放在调用处理器中，那么接下来要探究的核心问题就在于如何根据代理对象执行的不同方法触发相应的网络请求了，以下过程均用于创建并初始化调用处理器。
 初始化服务代理配置
首先根据初始化服务代理配置，同时设置远程服务名；这里要特别说明的是服务代理配置中有一项为是否直连的配置项，

直连即客户端不走主控直接通过 ： 向服务节点发起连接请求；
非直连则客户端会定期通过主控查询刷新并拉取到该服务的所有部署上线的服务节点的路由地址信息，同时将路由信息保存到本地；之后如果从主控拉取失败则会直接从本地读取。

如果通过直连的方式进行连接，不仅增加了繁琐的配置工作，且假设这些配置的服务节点都宕机那么服务也就不可用了，但是通过主控可以实现服务路由地址的定期查询和更新，客户端无需事先知道实际的路由地址，也就是说这个过程对客户端开发是透明的，因此一般使用非直连的方式。
路由信息跟在服务名之后，配置规范如下：
              表示  表示  
 初始化负载均衡策略
服务多节点部署，发起服务请求时应该选择哪个服务节点最为合理呢？
这就需要在请求路由分发时遵守一个支持负载均衡的策略，目前支持的负载均衡策略有轮询、带权重轮询、、带权重、一致性； 默认使用的策略是轮询，若客户端调用时在请求上下文中对应的有设置对应的参数则优先使用相应的策略，策略选用的优先级为： 一致性    。
负载均衡策略具体放到后文深入探讨，这里不做展开。
 初始化构造器
根据接口类的注解声明生成对应的协议解析器用于协议编解码，以此创建并初始化服务协议的构造器 ，在其构造方法中执行初始化。
同时，取得业务接口中支持的协议之后可以考虑扩展到其他协议的所有方法信息放入 存储接口方法名对应方法参数和返回值
每个远程服务对应一个，每个  对应一个  管理器，同时维护着该服务可用的服务节点列表 ；
 初始化
根据前面已经获取到的服务路由地址初始化列表，每个会对应创建一个，因此每个即对应一个远程服务节点，同时一个默认有个，每个对应一个连接，初始化连接时，注册在线程中 。通过参数指定了连接的相关属性，主要有 是否开启、连接超时时间、同步和异步调用超时时间、是否更改为协议默认为等，初始化代码如下：
    {
      = 
     {
          = __ 
          = __ __
          = __ __
          = __ __
          = __ 

          ==  {
             =     
        }

         =     
        
        
        
        

        将真正向服务端发起连接延迟到调用之前
    }    {
               |    |   
    }
     
}
发起请求时通过简单轮询的方式选择一个连接，以此达到一定的负载均衡，实现代码也很简单： 
   {
      ==       _  
}
以上所述关系图如下：

在完成初始化之后，还会创建两个定期执行的任务：

定期更新服务路由若为非直连方式， 每次更新服务路由的同时更新列表；
定期上报服务的监控状态信息如：成功率、耗时和流量等。

附，客户端整体类图：

二、生成代理对象
初始化工作完成，一切准备就绪，此时就可以指定要调用的服务接口接口代码由定义接口描述语言自动生成，参考：协议部分，通过生成用于发起远程调用的代理对象了。
通常每个远程服务对应一个代理对象，使用动态代理技术生成，代码如下：
       {
          
          {   } 
}
其中，第一个参数是类加载器对象，即指定用哪个类加载器来加载这个代理类到的方法区，这里当然指定为当前线程的类加载器啦；第二个参数是代理接口，指定了生成的动态代理继承于那些接口，即为我们要传进去的业务服务接口；第三个参数就是调用处理器类实例，即，当代理对象的某个方法被执行时，实际上会转而去执行该实例相应的处理方法即发起网络请求。
需要注意的是，在 动态代理模式中，由于代理类都会实现类，受单继承特性的限制该方法只能针对接口创建代理类考虑有些动态代理技术如：、等就没有这种限制。
下面看类图：

其中，代理接口就是代理类和委托类同时继承的接口，同时传入业务接口，保证了行为的一致性，对于访问者来说两者没有什么区别，通过代理类这一中间层我们很好地屏蔽和保护了委托类对象，同时巧妙地加入了对委托类不同控制策略，在设计上获得了更大的灵活性。亦可以看到，动态代理机制近乎完美地实践了以上代理模式的设计理念，很好地避免了人工地去编写大量代理类重复代码，将代理类交由编译器在运行时动态生成。
三、远程调用
经过上述过程初始化、调用的方法，现在我们终于拿到了业务接口的代理对象，调用代理对象的接口方法就能发起远程调用了。
实际上，所有的接口方法都会委托到调用处理器的方法上，结合上述内容和之前介绍的线程模型去理解，不难将发送和接收请求过程概括如下：

核心实现如下：

          {
      = 
      = 
    构造一次调用的上下文
      =   
     {
         负载均衡容错，从服务列表中选择一台
          =  
         
    }    {
          {
                  |   
        }
            {
                
        }
            
    }
}
值得注意的地方，在选取节点时除了考虑如上所述的负载均衡策略之外，客户端每次发起请求时都会对列表执行死活检查，屏蔽掉一定时间内异常的节点，根据一定的容错策略选取当前列表中的正常节点或重试被屏蔽的异常节点重试后更新上次重试时间，在该执行请求结束后重新检查活性，具体的容错策略下节再具体探讨，这里也不做展开了。
如上所述，执行如下：
       {
      = 

      = __
      = 
      = 
      = 
      = __|_ 

     {
          =  
        异步调用
          {
             =   
             
        }
        调用
           {
               
        }
        同步调用
         {
              =   
             =  ==   __  __
              =  {
                 
            }
             
        }
    }    {
            {
             = __
        }      {
             = __
        }  {
             = __
        }
         
    }  {
          ||  ||  = __ {
             同步调用或者发起异步调用失败 
             死活检查 
              
             上报的调用情况
                     
        }    {
             发起异步调用成功，但是无 
             死活检查 
              
        }
        其余的异步调用在中进行死活检查和上报调用情况
    }
}
从代码中可以发现，上图中处理响应回包的过程根据业务需要有几种不同的方式根据方法名做判别，根据客户端调用发起请求后是否等待，可将调用方式分成如下三种：
 同步调用
同步调用发起请求后会一直等待直到服务端响应回包或调用超时，实现上采用了一个闭锁的同步工具类，另外出于非阻塞处理，引入了票据  的概念来保存一次请求和响应的上下文，每次请求用一个唯一的 来标识，通过 管理器定期检查回收过期的票据，同步调用实现代码如下：
         {
      = 
      = 
     {
        
        _
         =   

          = 
        
        等待直到服务端响应回包或调用超时
           {
              =    = _ {
                     |  
            }  {
                          |  
            }
        }
         = 
          ==  {
                 
        }
         
    }    {
        
    }  {
          =  {
            
        }
    }
     
}
 异步调用
异步调用发起请求后不会等待响应回包而是继续往下执行，将回调注册到对应的 中，当接收到服务端响应回包时执行相应的回调方法根据解析后的响应码判别执行成功或异常回调；若超过异步调用超时时间，则票据被管理器回收，执行相应的过期处理方法。核心代码逻辑如下：
           {
      = 

     {
        
        _
         =    

          = 
        
        不等待
    }    {
          =  {
            
        }
                
    }
}
接收到响应回包
   
{
     = 
      =  
      =  
}
定期检查回收
 
{
     
    {
          = 

           
        {
              = 
             = 
               
            {
                      {
                    
                    
                }
            }
        }

    }   
}
过期处理
  
{
     = 
      =  
    
      =  
}
 调用
调用与同步调用比较类似，注册回调到 中此回调函数与异步回调有所区别，将封装到中作为返回值直接返回，此时不等待服务端响应，之后根据业务需要再调用的方法获取到的返回结果，此时客户端会停止等待直到接收到响应回包，实现代码如下：
       
                                                                     {
      = 
     {
        
        _
         =    

          = 
        
           
    }    {
          =  {
            
        }
                
    }
}
 其他
此外，客户端调用还有一种单向调用的方式，即调用之后不需要任何服务端的响应和业务回调。实现上我们直接复用异步调用逻辑即可，此时函数为，将标识设置到请求报文中，同时此类请求不计入节点服务上报中。
另外在异步调用的实现上版本有一种基于协程的方式，且当下比较火的也在方式上提供了很好的支持即，是可以从本质上解决业务逻辑的割裂问题的优雅方案，而在语言层面上不支持特性，但可以在上做框架级或基于其他语言如的实现，如早期的以及后面比较成熟的，而则从语言级支持了 。目前还没有实现这种方式，设想以后可以从这个方面多学习思考，对比分析一下。
感谢阅读，有错误之处还请不吝赐教。近经常会收到一些 “用  怎么写” 的问题，作为有经验的程序员，我们已经掌握了一门或者多门语言，那么学  的时候就经常会有类似 “ ‘再见’用日语怎么说？”、“ ‘你好’ 用西班牙语怎么说？” 的问题，所以我决定把一些常用的语法对照列举出来，如果大家熟悉 ，那么快速上手  会变得非常地容易。
这篇文章主要是写给需要快速上手  的  程序员看的，这时候他们关注的是如何  写出类似某些  的写法，所以本文基本不涉及  的高级特性。
 如何定义变量
 定义变量的写法：
  = 
基本等价的  定义变量的写法：
   = 
 定义  变量的写法：
   = 
注意到前面的是一个编译期常量， 当中应该这么写：
    = 
同样是  变量， 这么写：
   = 
注意到，这个不是编译期常量， 这么写：
   = 
另外，  有类型推导的特性，因此上述变量定义基本上都可以省略掉类型 。
 如何定义函数
 当中如何定义函数，也就是方法，需要定义到一个类当中：
   {
    
}
等价的  写法：
    {
    
}
注意到返回值的位置放到了参数之后。
 如何定义静态变量、方法
 的静态方法或者变量只需要加一个  即可：
  {
        = 

       {
        
         
    }
}
用  直译过来就是：
 {
     {
           = 

        
          = 

    }
}
注意  的写法。  这个注解会将  这个方法编译成与  的静态方法一样的签名，如果不加这个注解， 当中无法像调用  静态方法那样调用这个方法。
另外，对于静态方法、变量的场景，在  当中建议使用包级函数。
 如何定义数组
 的数组非常简单，当然也有些抽象，毕竟是编译期生成的类：
  =  {  }
  =  
 的数组其实更真实一些，看上去更让人容易理解：
   =   
   = 
注意到，  即数组元素的类型。另外， 表示可以为  的  类型。
数组的使用基本一致。需要注意的是，为了避免装箱和拆箱的开销， 对基本类型包括 、、、、、、 等基本类型提供了定制版数组类型，写法为 ，例如  的定制版数组为 ，如果我们要定义一个整型数组，写法如下：
  =   
 如何写变长参数
 的变长参数写法如下：
  {
    
}
 的变长参数写法如下：
   {

}
 如何写三元运算符
 可以写三元运算符：
  =   
很多人抱怨  为什么没有这个运算符。。。据说是因为  当中  使用的场景比  复杂得多，因此如果加上这个三元运算符的话，会给语法解析器带来较多的麻烦， 也是类似的情况。那么这中情况下，我们用  该怎么写呢？
  =    
注意到，  这样的语句也是表达式，这一点与  不同。
 如何写  函数
 的写法只有一种：
 {
        {
        
    }
}
注意到参数可以是变长参数或者数组，这二者都可。
对应 ， 函数的写法如下：
 {
     {
        
           {

        }
    }
}
 可以有包级函数，因此我们并不需要声明一个类来包装  函数：
  {
    
}
 如何实例化类
 和  这样的语言，在构造对象的时候经常需要用到  这个关键字，比如：
  =  
 构造对象时，不需要  这个关键字，所以上述写法等价于：
  = 
 如何写  和  方法
 的  和  是一种约定俗称，而不是语法特性，所以定义起来相对自由：
  {
       = 

       {
         
    }

        {
         = 
    }
}
 是有属性的：
 {
       = 
         {  =  }
         = 
}
注意看到，我们为  显式定义了  和 ， 是  背后真正的变量，所以  当中其实就是为  赋值，而  则是返回 。如果你想要对  的访问做控制，那么你就可以通过自定义  和  来实现了：
 {
       = 
         {
              =  {
                  
            }
              {
                    
            }{
                 = 
            }
        }
        {
               
             
        }   
}
 如何延迟初始化成员变量
 定义的类成员变量如果不初始化，那么基本类型被初始化为其默认值，比如  初始化为 ， 初始化为 ，非基本类型的成员则会被初始化为 。
  {
      
}
类似的代码在  当中直译为：
 {
        = 
}
使用了可空类型，副作用就是后面每次你想要用  的时候，都需要判断其是否为 。如果不使用可控类型，需要加  关键字：
 {
        
}
 是用来告诉编译器， 这个变量后续会妥善处置的。
对于  的成员变量， 要求它们必须在构造方法或者构造块当中对他们进行初始化：
  {
        = 
}
也就是说，如果我要想定义一个可以延迟到一定实际再使用并初始化的  变量，这在  中是做不到的。
 有办法，使用  这个  即可：
 {
        {
         
    }
}
只有使用到  这个属性的时候， 后面的  才会执行， 的值才会真正计算出来。
 如何获得  的实例
 当中：
  {
    
}



  = 

  =  
  = 
前面我们展示了两种获得  的途径，一种直接用类名，一种通过类实例。刚刚接触  的时候，获取   的方法却是容易让人困惑。
 

  = 

  = 
  = 
同样效果的  代码看上去确实很奇怪，实际上  拿到的是  的 ，这个是  的类型，如果想要拿到  的  实例，那么就需要前面的办法了。为什么要有灰度发布与监控
《海量服务之道》里的《灰度发布》和《全方位监控》这两门课想必技术同事都已经学习过了。我觉得这两个方法论是非常具有行业特色的，也是非常具有腾讯特色的。
笔者在加入腾讯后台团队之前，曾经在电信行业、金融行业做过几年开发工作。刚进入腾讯时，觉得技术上很多地方让人耳目一新：

后台系统都是部署在非常多的廉价服务器上，每个人都会管理非常多的机器，让人觉得很有成就感很富有

有比较精确的设备预算计算模型，每个服务器的性能在考虑容灾冗余的前提下，通常被压榨到刚刚好，负责人会深入的洞悉整个系统的性能、容灾、柔性等方方面面。能负责一个海量的系统是很荣耀的一件事情

没有专职的测试人员，经过开发者自测后，灰度发布加详细的监控，主要的系统几乎每两周都会被发布一轮，作为后台技术人员，自己的工作直接影响数以亿计的用户，有点手握核弹处于上帝视角的感觉

监控系统我们内部一个叫的系统真的是太方便了，一条条曲线直观的展示整个系统运作的各种指标，如果有异常短信和电话就会响起来，让人觉得一切尽在掌控，有一种面对着大量仪表盘操控着航母游弋或者是战斗机挂着核弹翱翔的感觉。


好了，赶紧结束程序员意淫的美好感觉，我想说的重点是：灰度发布和监控真的是互联网海量服务必备的两大利器，能够极大的提高后台服务可用性和运营水平。
当然，灰度发布不只是一部分一部分的发布新代码，监控也不只是绘制曲线和告警短信那么简单，这里面深究下去会有很多东西，背后的哲学是持续交付、用户测试和尽在掌控。
毫秒服务引擎 取英文名    的首字母组合是腾讯一个开源框架，其创作冲动和构建经验，来自后台团队超过年的运营思考。灰度发布能监控是毫秒服务引擎设计的重要考量点。
毫秒引擎里是怎么做的？
灰度发布
在服务配置管理页点击“制定发布计划”

选择这一次灰度要发布的目标机器和发布类型：

在接下来的向导中选择正确版本的配置文件、外部库、业务插件等，这样就完成了发布计划的制作：

接着，点击菜单 “运维发布”，可以查询所有发布计划，对于已经发布的计划，可以做回滚操作。点击详情可以查看发布计划更详细信息，并执行发布：

监控
关于监控，在第二篇：和路由管理那里讲得已经比较详细了，这里不赘述，只说明一下：除了和框架本身自动上报的一些信息，还支持业务自定义上报信息例如我想上报第级用户登录的次数，且支持对于关键指标的波动、最大值、最小值设置告警：

结语
灰度发布和监控是互联网海量服务必备的两大利器，能够极大的提高后台服务可用性和运营水平，背后的哲学是持续交付、用户测试和尽在掌控。借助毫秒服务引擎，初创团队可以快速获得这两大利器。详细的可见腾讯云服务市场、毫秒服务引擎官网，或者微信公众号

相关推荐后台服务标准化运营谈谈后台服务的和路由管理作者简介： 肖攀， 腾讯高级工程师。

最近开始使用编码，编码效率和代码质量提升不少，把目前我遇到的提升效率和代码质量的新特性都总结一下。备注：这里不会列出所有的新特性，只会列出我编码过程中实际用到的新特性
一、关键字，这个关键字作用类似里的，可以自动判断变量类型。在实际编码中，这个变量真的可以省很多代码，比如
   = __是一个返回 变量的函数。
特别的，当循环 这个变量的时候，要写一个迭代器，但是定义  ，一行代码就被占了一半了，吐血。换成，代码就少多了。
二、循环，支持 这种模式了，其中是一个支持迭代器的集合，是中的一个元素，配合关键字，循环的代码就清爽多了：
之前：
        =   =   {}
现在：
         {}
三、在定义类成员变量的时候初始化。比如：
     

    {

           = 

    }

这个特性看起来貌似没啥用，但是实际用起来才发现可以少写很多代码，想想每增加一个成员变量，都要去构造函数初始化列表里添一点东西就烦。
四、库，之前没有提供标准的线程库，要么裸用系统提供的，要么自己封装一下。现在提供了，而且非常简洁，如下：
    这里借用一下函数

     {      }
一个用子线程运行打印 的功能就完成了。
五、函数，就是匿名函数，看各种介绍说很牛的样子，不过目前我用的很少，应该是在这类函数里用比较好。或者可以用来实现里_的特性。
六、，里新提供了类，这个类主要提供两个功能，时间点和时间段功能，由衍生出，，等时间单位，并且提供他们的加减和换算功能。把我们在看代码时，从一个整型到底是一个时间点还是一个时间段的纠结里解放出来。另外，提供了_和_两个时钟，一个用来单调递增，一个用来表示系统时间，也方便了不少。
目前用到的主要就这六个地方，后续有觉得新的好特性再继续总结。：上的编译器，在的实现里有一个，本意是系统能提供的最长时间段，但是在的实现里，这里溢出了，变成了负数，所以意思就变成类似的作用，用的时候需要注意下绕过这个坑

相关推荐
下相关知识总结
数据库设计总结
做开发十年，我总结出了这些开发经验由腾讯公司举办的腾讯  前端大会将于  年年中在深圳热力开启。本次大会将邀请全国各地前端从业者参加，共同探讨前端最新技术、海量用户服务优化和运营心得，以及未来行业发展风向，此次大会精彩纷呈，不容错过。
腾讯前端大会将是腾讯面向国内最具影响力的一次  前端大会，其目标是成为一个纯干货的业界分享平台。 

腾讯作为国内最大的互联网公司之一，创造过众多服务亿万用户的应用。从空间、、邮箱到现在的兴趣部落、直播、微信小程序等等，腾讯的前端工程师在此期间也积累了许多丰富而宝贵的前端经验。无论是新技术、新框架在实际开发中的运用，还是具有腾讯特色的面向海量用户的极致性能优化和运营手段等，都有着不少心得体会。
但这些年以来，腾讯的前端工程师们并没有太多机会对外输出这些宝贵经验。这一方面跟腾讯公司低调内敛的风格有关；另一方面，腾讯所在的华南地区，前端开发者社区一直不够活跃。然而从现在起，我们准备改变这一切。正因为我们坚信腾讯前端工程师们所积累下来的宝贵经验，可以帮助更多正在面对与将要面对海量用户业务的同行们。
今年腾讯公司的前端通道、以及腾讯学院将联合挑选高质量的分享内容，力争为参会者带来最具实践价值、最接地气的前端开发经验。会议内容将涵盖新技术、、各类框架、工程化等前端的主要技术方向。这些分享都是各位讲师在多年前端工作中提炼总结出来的工作方法和成果结晶，对广大前端开发者大有裨益。

同时我们也邀请了部分外部讲师。他们都是来自国内外的前端知名大牛，包括著名流行框架的作者，知名前端书籍的作者，工程化方面的权威，和对新技术有独特理解的全能工程师等等。他们将齐聚一堂，共同探讨前端最新技术、最佳实践和行业新风向。
大会议程为天，将设置多个分会场，面向不同的方向和领域，满足大家的不同需求。除了讲师之外，我们还将邀请许多前端大牛，如：黄老师、玉伯、张云龙、司徒正美、迷渡、张鑫旭、大漠穷秋、寸志等担任大会讲师或特邀嘉宾，参会同学届时可以在会场跟各位专家讨论所有前端相关的话题，来一次思想与灵感的碰撞。
点此进入 腾讯  前端大会 官网报名！ 引言
突然就对项目中的有了强烈的好奇心，这个的实现够高效吗，和 _ 的效率比较性能如何 他们的插入效率、查找效率、空间使用率对比起来是分别是什么样的？也没有找到相关的测评，于是就自己动手，测试了一下，并对一些影响性能的地方修改、验证自己的猜想，最终得到一个比较好的的实践。整个过程还是比较有意思的，现记录并分享出来。
 好了别的不说了给我结论就好
好吧，大家都很忙，先给一下简要结论，时间紧迫的同学也可以直接跳到文尾查看结论小节

 的哈希算法算出来的哈希值散列度不够，的长度越长，散列能力越差，性能越差。
因为冲突处理的缘故，本文所做的几个用例中，极端情况下  的表现比 _ 差倍
哈希算法散列程度足够的时候， 的表现比 _ 好。前者的插入效率是后者的倍，查找效率倍
存储同样的数据 耗内存多于 _

    
本文用到的测试代码和测试结果全部在 中，有兴趣的同学可以下载查看。
仓库路径
成文时仓库版本 
内存 
 核     
 编译时预设的容量是 万

测试用例
  ± » _
 _   
    
     
    
    
      
     
      
     
类型



项目
说明





递增： 万



==


用例
分别顺序插入万条数据每万条记录一次耗时


用例
搜索部分存在的，获得每次检索的耗时


用例
搜索不存在的，获得每次检索的耗时



用例结果
执行_   获得数据，并绘制图表如下画图数据经过省略，但关键信息还在下同

图 插入耗时 

 图查找耗时 
总体来看，两个实现的效率都很高，稳定斜率不变，意味着单位时间内插入条数没有变化，插入万条数据最多只需要， 在使用 插入数据的时候，甚至能够达到 _的倍；当不存在的时候， 查找速度也比 _ 快倍，  存在的时候，容量少于万条时， 比 _ 快，只有大于万时，两者查找的速度才相差不大。
这次测试看起来  实现得非常完美，很好地解决了预设需求，插入效率高、查找效率高。虽然耗费的内存多，仅存万个的  需要  的内存，但现代服务器内存充足，这个缺点似乎是可以忍受的。
除了内存之外， 的实现就没有其他的缺点了吗？ 很快，我就想到了他的  函数和冲突处理，决定从这里入手继续分析。
 隐忧算法
 的  算法实现是将  的 ，按照  字节累加，并将其结果和哈希表容量进行取余，简单粗暴，而且似乎也符合大道至简的理论。但是仔细想想这个地方的实现违背了哈希算法的原则均衡性。一个不够均衡性的算法会导致大量冲突，最终使得在反复的冲突处理中疲于奔命。
很简单，按照这个算法下面的这些数据算得到的哈希值都是一样的而且这样的数据可以轻易地构造

 
  
   
最为对比，我们都知道构造两个拥有同样值的数据是何等的困难。
而且仔细分析一下可以知道  用例刚好绕过了这个算法的缺陷，取到的都不会相互冲突 这时候的测试结果恰恰是最优结果
如果冲突了会怎么样测试结果变成怎么样 在好奇心驱使下，我马上进行  用例的测试。
 类型



项目
说明





递增： 万””



==


用例
分别顺序插入万条数据每万条记录一次耗时



用例结果
执行_   获得数据，并绘制图表如下

图： 插入耗时 
从上图可以看到，对于类型的性能表现差异很大
从的图来看，越到后面斜率越大，说明到后面的时候，插入单位条数的耗时已经急剧增长。这是符合我们的设想的，此时程序在拼命进行冲突处理！
从图中还可以得到一个信息，插入万条数据，的耗时是接近秒也就是分钟
至于_上图已经分析不出什么东西来，和比起来，它的变化太缓慢了。我只能抽出来单独分析，图如下

 图：插入耗时_ 
_ 斜率几乎不变，可以知道每次插入的耗时是相同的稳定，插入万条数据，耗时，差不多是他的倍。
从上面的测试结果可知  的效率的确是急剧下降，但是这个急剧下降是  算法引起的吗？ 还是需要定量分析！
  算法比较
 _
_ 是引进的老版本也有，只是没有提供接口出来供外部使用。
恰好手头上有   的代码，于是一探究竟
    代码片段 ==================
    _ 
    _ __   _  _ 
    {
         _  = 
        _  =   
           = _ 

                 
         = 
        {
            _  = _
             = 
             =   
             = 
             = 
             = 
             = 
             = 
        }

                 
        
        {
             
                 = _   
             
                 = _   
             
                 = _ 
                 = 
        }

                
         =   
         = 
         =   
         
    }
对于可以转换成 _ 类型的，提供了几个特化哈希函数，直接返回_，上面的哈希函数是类型的哈希函数，传入起始地址，得到哈希值。这个算法用了几个魔数，各种位运算得到一个  的值，好吧，此时我已经不知道怎么才能构造两个碰撞数据了。
最为对比，的函数如下
  _  _  _  _  _
 _ _ _ _ _ _    
{
    _  = 
       = 

    目前算法实现比较简单只是将值的每个字节的值加起来并对取模
      
      =        
    {
           = 
          
         = 
    }

         
    {
           =  
         =      
           = 
              
         = 
    }

     =    
     =   _
     
}
 用例设计



项目
说明





递增： 万””


用例
分别用两个函数计算上面的万个的哈希值，并统计碰撞次数的数量



 用例结果
执行_   获得数据，并绘制图表如下碰撞太频繁了，为了可读性，这里对原始数据做了二次统计。统计每一个冲突链表的长度，以及数量和占比。数量之和是 万，占比之和是。



冲突处理链表长度
数量
占比












































以上





这个表格就一目了然了

我们最期望的结果是没有冲突，也就是链表长度为，仅占比
绝大部分的冲突链表长度在以上 占了总量的 
最长的链表达到了 以上，而且占比 有 ，比我们期望的不冲突的占比还多了倍。也就是说最差情况的比最好情况多了倍。

作为对比，_ 的结果就好看很多了甚至都不需要进行二次统计、处理



冲突处理链表长度
数量
占比





















　



那么，猜想一下，如果替换掉  的哈希算法，是不是测试的效果就会好很多呢？
 升级 算法之后测试
开搞，把的哈希算法移植到 并放到一个新命名空间中，另存为文件 。 重做的测试用例 _   获得数据，并绘制图表如下



冲突处理链表长度
数量
占比























































可见升级哈希算法之后冲突还是存在，但是冲突链表过长的现象已经不存在了，最长的冲突链表长度也只有。此时可以想象耗时数据肯定好了很多。

 图：插入耗时 
可见，调整较小，但是效果比较明显

 的插入耗时是 _ 的 
 斜率很稳，可见插入耗时比较稳定

 结论
从上面的实验可以看出，影响  效率的主要是 哈希算法 和 内存分配算法在哈希算法足够散列的情况下，预分配方式的效率更高。
空间换时间的策略是对的，两个影响因素，另个不够好的时候，靠空间得到的优势反而会损失；作者 | 衡阵编辑 | 京露

衡阵，年加入腾讯，先后经历，互联，手后台等相关的工作，目前负责直播的后台开发工作。热爱后台开发，喜欢研究新的技术。对等都非常感兴趣。

最近基于 实现一个通用的的协议代理，把来自的请求转换成内部的通信协议。内部协议是基于的，所以关键就是实现和请求中的参数的转换。
研究生成的源码发现，生成的的结构体中已经自带的的，可以很方便的在和之间互转。

于是想到，可以以一个请求参数来传来实现。
 ={}
 ==

这样在服务端先拿到的数据，直接用库就可以转成相关的结构体。
这样实现虽然简单，但并不直观。对用户来说，更习惯用。
 ==
这种形式来请求。由于其他语言习惯把请求参数存在一个中，于是想是不是也可以这样处理。于是问题变成一个和的转换的故事。搜下网上发现有人提出类似的问题，还是上的一个练习。代码如下：
  {}    {}  {
     = 
     = 

      {
               
    }

      {
              
    }

     = 
     = 
      =  {
                
    }

    
     
}

   {
     
      
}

    {}  {
       =   {
         =   
          =  {
             
        }
    }
     
}

  {
     = {}
     = 
     = 

     = {}
     = 
      =  {
        
    }
    
}
这个代码实现了简单的到的转换，但要求类型强一致。所以需要实现弱类型的转换。后来发现，上已经有一个开源的实现。
 通过很简单的代码就可以实现我们想要的功能
   = {}
     =     {
         = 
    }
      {
        
    }    {
        
    }
     =  
到了这里，大部分场景都可以实现了。但有些请求是有消息嵌套的，虽然是支持嵌套转换的，但我们的请求参数只是一层的。
这种情况无能为力了。看下的源码，逻辑比较简单，既然你不支持，就改到你支持。我们定义如果有结构体嵌套，二级参数要是一个字符串。在处理结构提的地方，如果发现传入的是个字符串，就尝试用去处理一下，然后再走后面的逻辑。

在的地方也同样处理

这样处理完了之后试了一下，果然处理嵌套的结构体了。但是在实际使用的时候发现，有人竟然在中定义普通的字符串为，这样在生成的代码中就是类型。这种情况很不巧也会走到的逻辑，而我们并没有考虑兼容。事实上这个框架就没有考虑这种情形。按定义的标准，类型要以编码，我们也遵循这种规范。于是加上这个代码：

至此，这个转换基本完美。但是发现一使用，发现还是有坑存在，对应文件中定义的带下划线的字段，生成的成员代码是驼峰型的。标准库中的可以通过反射拿到中的原始名称正常的输出。但我们用默认是以字段名来解析的。
本来以为要自己处理一下，在修改一下的源码，然而阅读代码的时候发现，支持指定要处理的。并且处理逻辑是兼容生成的 的。我们只要在解析时指定一下即可。


相关推荐
单元测试基本篇单元测试进阶篇导语
入职接到的第一个需求是实现一个关于歌实体售卖的系统，管理系统过去做过不少，这次打算换个姿势，基于时下正热但早已不新鲜的 技术实现。本文首先对的相关技术进行简单介绍与分析，接着总结开发实践主要描述  实践过程中的流程规范，并记录在此过程中遇到的问题与关键点，最后做出一点实践的总结与思考。


图：  
简介
众所周知，如今的前端框架解决方案数不胜数，从最初的，到和等，这当中有很多都为前端的工程化管理和建设提供了一整套解决方案，是一种“大”框架，但这样的框架往往具备一定的排它性，使得开发的自由和灵活度受到限制。
与此不同的是，对自己的定位是一个渐进式的框架，它最核心的部分是只是为了解决视图层方面的问题，提供声明式渲染和组件化管理模式。同时对于路由管理、状态管理和构建工作方面又有自己的解决方案，开发者可以自由地选择或者组合，从而能够更加灵活自如地进行项目开发。
响应式原理
手动改变操作是件损耗性能的事情，几乎所有框架都遵循一个原则：视图的状态应该由数据描述，并且通过数据驱动变化。

图：双向数据绑定
采用发布者订阅者模式实现双向数据绑定，首先将会获取到需要监听的对象的所有属性，通过  方法完成对象属性的劫持，将其转化为和，当属性被访问或修改时，立即将变化通知给订阅者，并由订阅者完成相应的逻辑操作，主要流程下图所示。

图：响应式原理
整个过程中主要涉及了 、 和 三个类，相关源码已精简如下：

主要处理属性监听逻辑，将监听属性转化为属性，当属性被访问时，调用 方法，而属性被修改时，则调用了方法。
   
   
   
   
 {
    =  
   监听属性的和方法
    {
     
     
        {
      
       
    }
        {
       = 
      
    }
  }
}

担任发布者的角色，维护订阅者列表，负责订阅者的添加和通知工作，上面所提到的和方法在这里实现。
    {
   
   订阅者列表
   
   添加订阅者
     {
    
  }
   属性被访问时调用该方法，通知依赖的目标即订阅者添加该依赖，
   同时将其加入订阅者列表中调用方法
    {
      {
      
    }
  }
   当监听到依赖的属性发生改变时，通知订阅者执行状态更新操作
    {
      = 
       =   =      {
      
    }
  }
}

担任订阅者角色，即上述代码中的 ，可以订阅多个，在每次收到发布者消息通知时触发方法执行更新逻辑。
    {
   
   
   
         
   为该指令添加依赖发布者
     {
      = 
    
    
    
  }
   更新视图逻辑，依赖的属性值发生改变时触发
    {
     省略
  }
}
状态管理
过去为了实现父子组件或者平行组件的数据通信，常见的做法是直接或间接地使用  属性和  方法来实现，这样的做法耦合度强，且难以应付复杂场景下的状态管理。
 的出现可以很好地规避此类问题，它是一种应用的专用状态管理模式，负责集中式地存储和管理整个应用程序的组件状态，实现更好的状态共享。将组件状态的存储和管理放在了  里面，并为其提供了种特性，分别是 、、 和 ：

，作为驱动应用的数据源，保存了组件的各种状态；
，类似于事件，是改变  的唯一入口，且里面的操作必须是同步的；
，类似于 ，里面可以进行一些如  请求等异步的逻辑操作，但如果想对  的状态进行修改，必须通过  完成；
，可以对  进行某些处理动作，并对处理后的结果提供访问接口。


图：状态管理
状态管理流程如上图所示，主要分为如下四个步骤：

视图层中的  通过  或  方法从  中获取数据并渲染；
用户在  中执行某些动作如点击按钮数据时，通过调用  方法将执行动作的指令发送到  中对应的方法；
 解析请求指令，完成相应的逻辑如数据请求，并在最后请求结束后通过  方法通知  对  状态进行修改；
 收到  请求后，对  进行赋值操作，以完成数据的修改。


图： 
对于开发过程中  状态的追踪，可以通过   的 “” 一栏进行查看，如上图所示，安装方法可以自行搜索。
项目实践

图：歌
简单介绍
全民歌初期在试水麦克风售卖活动中取得了良好的市场反馈，为继续推动周边实体的售卖，现在期望搭建一个属于自己的售卖平台。整个需求分为和两部分，其中为用户购买实体周边的入口，则是对用户的订单数据进行管理。本项目为需求中的部分，共由订单数据概览、待审核、待发货、已发货和退换货五页组成。

图：项目页面
页面具体介绍如下：

概览页，包含了整个平台上的交易数据，货品的实时库存以及当前用户的待办事项；
待审核，显示最新的订单数据，用户可以在该页中执行订单审核动作；
待发货，已经通过审核的订单将会移动至该页，该页为管理员提供了物流信息导入和已经确认发货的动作；
已发货，显示已经发货的订单列表，用户可以对发货的地址进行修改，同时也可以执行申请退款的操作；
退换货，包含了“待处理“、“”已通过“和“已拒绝”的页。其中待处理显示了前端发起退货或上执行“申请退款“的订单列表，而用户在该列表中执行的动作允许拒绝退款将会使数据移至“”已通过“或“已拒绝”的列表中。

此外，对于所有的列表页，需要提供批量操作，如批量审核、发货退款和物流信息导入等，并提供分页操作。同时登陆需要通过歌扫码完成，所有的调用需要在歌的登陆态下进行。
项目构建
项目的构建使用  完成，具体操作流程如下：

图： 构建项目
由于公司网络原因，在执行    时会出现无法下载模板库的错误，解决办法可以是通过设置如图中所示的  代理，或者是直接下载  模板中的库并在本地运行完成。
开始动手

图： 开发实践 
 目录规划
本文针对  构建出的项目进行结构上的调整，最终得出如下所示的目录结构：

图：项目目录结构
如上图，目录为客户端的主要开发目录，主要包含了程序入口文件 、客户端路由文件 、客户端视图曾、组件模块和应用状态管理层即。
 规范
前面已经提到，订单相关的页面共有四页，对应着待审核、待发货、已发货和退换货四种状态，由于每种状态的相关操作逻辑不同，在开发过程中将中的模块划分为、、和四个子模块。下面代码展示了一个简化的子模块的代码，其他模块的代码与之类似，都包含了 、、和对象。
 
  = {
  __ {}
}
  = {
  ___   {
    __ = 
  }
}
  = {
  __  = __
}
  = {
   {   }  {
    {
       
      {
         
        _ __
      }
    } = {      
      ___ 
    }
  }
}
  {
  
  
  
  
}
此时你也许注意到，被划分成多个模块，而每个模块里面可能又会有更细粒度的划分。在实际的运行过程中，需要对这些模块进行整合，这里需要用到提供的属性，相关代码如下：
   
   
   

  =  {
   {
    
    
    
  }
}
 组件调用
组件对中状态的调用逻辑通常是放在  或  属性中，但需要注意的是，如果期望得到的是响应式的数据，则必须将调用逻辑放在计算属性  中，这样当每次状态发生变化时， 属性中的数据都会被重新计算，同时重新触发更新视图。此外组件也可以直接调用中的和事件，这通常放在属性中进行。
 其他
路由处理，对于一个单页应用，自然少不了路由处理，项目的路由使用官方的处理，使用方法在每次路由跳转前进行拦截，判断用户是否登录，如没有登录则跳转至登录页。
网络请求， 开始不再维护 ，转而推荐  作为标准的网络请求库，但是由于  不支持  跨域方式，遂放弃，在项目中使用了团队的  模块。
延迟加载，项目使用了作为打包构建工具，打包结束后默认情况下会产生两个文件：和，而项目在一开始就已经加载了这两个文件，如果要想实现路由的延迟加载，需要将路由请求的组件定位为异步组件，并结合的代码分割特性实现，方法是通过  的方式引入组件。
最后说句
本篇文章前半部分对  进行了浅析：分析关于响应式方面的源码，了解具体的实现原理与模式，并对 数据管理做了知识梳理与流程说明。后半部分则是在项目中应用了  的技术栈，并对实践过程中的代码细节和关键点做了总结。
在整个开发过程中，能够较为深刻地体会到对于代码编写的舒适性来自于组件化的管理方式以及对于代码组织方面的优雅。另外由于时间上的关系实际上是因为懒， 还没有仔细了解关于 渲染方面的原理，希望可以找个时间在后续补上这部分内容。
谢谢阅读，欢迎指正 =_=
参考文献

 中，“渐进式框架”和“自底向上增量开发的设计”这两个概念是什么？
 ——渐进式前端解决方案
深入 响应式原理
月日举办了一次非常火爆的沙龙，对于这次沙龙的演讲主题，三位资深老炮：极客帮创始合伙人  创始人蒋涛，副总裁孟岩，鲁朗软件北京有限公司联合创始人智亮跟现场众多程序员们聊了聊开发者转型的事儿：机会在哪，转型中会遇到的哪些问题，技术实操等。
为了方便大家学习，我们精心整理了本次沙龙的嘉宾演讲。另外，你也可以在微信公众号会话中回复“沙龙”，下载本次分享嘉宾蒋涛、孟岩和智亮老师的演讲。

演讲 | 蒋涛，孟岩，智亮整理 | 苏靖芝，鸽子
   蒋涛：时代，端比端更有机会

这几年我也在做投资，从一个比较宏观的角度给大家讲一下，就是说为什么人工智能这么重要。
上上周，百度开了一个开发者大会，叫大会，是由史以来中国最像开发者大会的开发者大会。

 为什么像开发者大会？
因为有很多大会打着开发者大会的名义，其实都是在推销自己的东西，并没有真正提供给开发者实际的资源。
第二个也没有建立所谓的开发者生态，因为我们开发者生态都是建立在国外的公司的基础上。
百度这场会含义还是非常深的，也是陆奇去作为百度的二号人物，第一次大的亮相，他讲了一句话：未来属于创作者，的未来属于开发者，开发者成功才是百度真正的成功，这句话有一定的逻辑关系，我后面给大家解读一下，为什么开发者变得这么的重要，然后为什么成为百度的一个重要的基石。
时代回顾
首先让我们来回顾一下历史。
历史上，最大的开发者大会是微软年开的，为什么？
因为这是时代，时代最核心的是入口就是操作系统，或者是的桌面，它是建立在因特尔的芯片技术上。围绕着这个，我们才有了时代，也诞生了开发者的时代。

 他们为开发者做了什么东西？
在时代，我们看最大的一个公司，出现了几类：
一个是行业，公司百亿级别，如，，，他们为企业提供信息化的软件和工具，包括数据库、，还有做外包，因为各个行业都需要信息化。
另外一个就是端的业务，服务个人。在个人市场只产生了两类大的公司：
一类是做游戏的，暴雪公司，，这是游戏行业，也是非常大的一个产业。
还有一类是工具厂商，如图像工具。
移动互联网时代
接着我们迎来了移动互联网时代，大家都开始找入口，一开始是门户，后来发现不是门户。

比如，一开始最厉害的是新浪，三大门户，还有网易。
后来随着时间的发展，发现最重要的入口是搜索引擎。谷歌和百度等掌握了绝大部分流量的分发权。
电商也是很大一块入口。比如淘宝，同城，大家一般都直接去到淘宝，而不是用百度搜索，因此不会被百度卡了脖子。
这是整个互联网的发展，这时候我们开发者在做什么呢？
他们在建立各种各样的网站，但是你的网站呢，很重要一点是要服务这些端的用户。
第二个，可能要做好跟搜索引擎之间的关联。
这是互联网，到了移动互联网，才是一个开发者大显身手的时候。
到了移动互联网时候，入口变成了，就是说你做一个应用，原来是关健词搜索，现在是你的应用名字比较重要，你的应用名字能不能在用户之间建立它的认知。

 微信作为一个巨大的入口，对开发者没起什么作用，倒是对内容起到一个巨大的作用，不少内容生产者立足微信做创业。
因为互联网跟人的连接还是比较远一点，而手机是随身携带的，因此移动支付发展起来。
跟生活比较贴近的，如做天气的，也发展得很好，因为它跟生活连在一起，就可以接入更多的服务。
现在已极大丰富，上有万个，你现在需要分走用户的注意力比较难了，基本上能做的都被大家做了一遍。
第二个用户没有增长了，获得新用户的成本越来越高。
这是整个移动互联网时代。
时代
今天什么百度要提出这么一个战略？
因为百度发现，它在移动互联网的时候抓瞎了，因为它不是入口，入口变成、变成微信，变成小米手机，手机成为一个入口，还有应用宝商店，腾讯开了个应用宝，百度买了个也不是很成功，所以在移动互联网上，百度就掉。
掉以后，战略也不是很成功，这次他们下了很大的决心要做的，做的生态。

那的是什么呢？
以后所有的东西都要和互联网连接。摄像机可以连网，摄像机带人脸识别。摄像机识别以后，怎么跟你互动呢？
百度提了一个口号叫唤醒万物，你说索尼摄像机，它就知道是在叫它。这个大概三年内就会发生，这就是说，语音会作为一个入口。
有了入口以后，后面是什么？
你把它唤醒了，它得和你进行交互，它得有算法在背后，而这个算法是要靠大量的硬件驱动。
百度认为，未来的每个行业，每个硬件都可能变智能，而智能化一定要有一个核心的来驱动它，所以这就是一个是入口。
但是现在这个生态刚刚开始，机会在哪里呢？
第一个你要做端的应用，还是很有挑战的，因为现在做人工智能的应用，要有数据，没有数据你的算法就没有办法做出精确度。
那么数据在哪？
数据都在手上，他们有大量的数据，有一大堆端的公司，他们每天都产生大量的数据，饿了吗，滴滴，摩拜等。有了信息，他就能判断你的意图。比如，现在亚马逊在美国就能根据你过去的购买记录，预测你会喜欢什么样的书，于是它会提前把书送到你家。你回家就能看到本新书，想看就留下，不想看就退。
所以在端，实际上我们的机会就不是很大了，因为这些公司手上的数据太大了。其实在端，时代产业端布局会比移动互联网更大。
时代，端机会更大
为什么这么说端机会更大呢？
我来详细解释一下。
移动互联网大量解决的是端的问题，而端有很多问题没有解决，端也面临巨大的变革，他们做了第一步的信息化，但是他们没有把业务进行重构，但是人工智能来了以后，会有一个非常大重构的机会。
这其中最大的重构就是无人驾驶汽车，这是一个上万亿美金的市场，围绕着它配套的产业，光售后就有八千亿，如果汽车都变成无人驾驶了，现有的很多服务都会瓦解。
所以我们看到有很多大的公司在这里面下重注。
这是从投资角度看到的一个非常大的机会。
深度学习可以做什么
那从整个产业的角度，人工智能为什么现在变得这么热？
当然第一个原因是阿法狗在去年打败了李世石。
实际上，真正历史性的转折点在年。
在年比赛中，深度学习的使用，将识别错误率大大降低，引起了人们的关注。也就是说，原来人工智能技术被一道墙堵住了，过不去，进步很小，但是采用深度学习后，这个墙相当于被凿开了一个窟窿。下图中紫色代表采用深度学习，蓝色代表传统方式，可以看出其中的跨越式的变化。

 如下图，计算机采用深度学习可以做到精确的识别，把这张图描述出来。

我们常说代码时代结束了，其实它指的不是所有代码，而是原来我们是用各种各样的规则和技术，现在可以用深度学习，用神经网络来建立模型，用以取代原来人工设立的规则。

 这是很大的一个不同，而且这个技术不是说只是用在识别领域，它可以用在非常多，以及看起来很小的领域。

这是发布的数据源，展示出自己内部哪些项目用到了深度学习。
从年开始，他们就开始用，一开始几个项目，到年已经有个项目使用深度学习。到年，已经有个。目前内部的所有项目，以上都用到了深度学习来改进。
比较小的地方，大家意想不到的地方，比如做缩略图的时候作，同比例放缩就看不清楚人了，所以用深度学习技术来改进。

 如上图，图片里有人头，当你同比例缩小的时候，就有点看不清了，不方便浏览。于是，我就可以用深度学习来识别头像，以此在缩放的时候，做一个调整，让人像看起来吐出一些方便查找。
还有做压缩，利用这个技术，还可以再压缩，因为机器会学习，知道哪里更重要，压缩的时候主要内容保持质量，其他次要内容进一步压缩。

 现在我们已经进入到新应用时代。

图片上这个人是深度学习的网红，原来在  ，刚刚跳槽到特斯拉做无人驾驶的首席科学家。

他曾经拿托尔斯泰的作品来做一个学习，用机器去模拟，程序只有几百行，但就能让机器创造出来作品，虽然还达不到托尔斯泰的水平。
很多行业，都面临着这个巨大的挑战。
围棋行业已经被颠覆了，后面还有律师、金融，包括程序员，美国已经有不只一家公司做自动化编程，取代程序员的一部分工作。

 上图是调用了的做识别，这个人是斯坦福机器人研究室的一个博士，花一百美金左右买了这些设备，就做出来原来需要花万美金的东西。这说明什么，说明智能应用时代是真的来临了。

 这是来自的分析图。从上图可以看出，学术界的突破在年，从年起进入创业高峰期，年进入爆发期。
现在被我们捧得非常热，但是要很好地解决我们实际面临的困难和问题，达到大家期望，还需要经历一个过程，我们把它分三个阶段。
发展的三个阶段

 目前还是算法红利期。现在大家都下重注去挖算法的优秀人才，年薪开到上千万美金，这是一个优秀算法掌舵的时代。
学术界的进步对我们非常重要，因为论文的一个突破就可能带来技术上应用上的一个大突破，一个快速发展期。
不过这个阶段很快会稳定下来，变成局部很小的改进，不再是大的突破。
这之后是工程技术期，会在到年后到来，这个时期就可以真正去做出各行各业的应用，而且对这些行业会产生比较大的价值。
再后面才是平台，谁拥有最多的数据，谁就拥有最大的商业资源，谁就更强大。
我记得我很早时，跟微软谈事的时候，他们内部就说过，我们公司没有亿美金以上收入的项目，都不会列入我们的计划。但是无人驾驶他们是可以杀进去的，这是一百亿一千亿的市场，但是我们可以在很多行业都找到这样的机会往里去切入，但是等到这个市场变得非常巨大的时候，你不一定打得过平台，或者你要先把这个平台要做的事做好，才有空间。

 现在是同样的情况，我们可以调用谁呢？
是在这个领域做得最好，百度是目前最大，我把他们做了个对比，开放的能力大家可以去看一下，包括百度推的语音唤醒，现在还没有。视频内容比较分析，就是一个视频封面，我刚才讲，你怎么去选视频里面的哪一帧，作为你封面的展示页，百度也把它公布出来了，这些都是他们很大的积累了。
所以呢，这些技术的丰富，包括框架的成熟，就像安卓时代，时代，也不太成熟，我大概是参加了  大会，那时候才有了点气象，也不是像现在这样，安卓一定会胜利，大概是在的时候会确定。
时代，我们要做什么
那顺便说说我们最近在做些什么。
最近花了很大的精力在组建我们自己的社区——，其中媒体公众号为科技大本营。它可能是个升级的，或者升级版的社区。一方面我还要把工程师、专家聚集起来，为他们提供内容，交流的平台。第二方面，把行业的资源带入进来。

 正如刚才所说，我们的基本判断是说端的应用可能没有那么大机会，而端有太多的事情可以做。所以，一开始，你马上切入核心业务也很难，一个是说，它固有的模式不容易马上变化；第二个是说，你也不知道从哪去切入。
所以我们现在跟这些行业分别做一些合作，把他们的数据集，它内部的商业需求和项目开放出来，甚至呢，提供相应的资金，这资金可能是作为一个项目的资金，也可能作为一个比赛的奖金。
比如说最近的一个比赛就是智能电视的项目，智能电视记录对于你看多长时间，怎么切换过去的信息，都可以记录下来，那我们用这个来做一个收视率的预测。
包括医疗行业、教育行业等都在给我们提供数据。因为对这些公司来说，你是愿意自建一个研发的团队，或者的研究院吗？不会，成本非常昂贵，且不一定能做的出来，所以还是通过我们这样一个新的社区的平台来做更省钱省力。
通过社区的平台，一方面我们能够做更多的尝试，一方面也能发现更多的人才，这是我们下面要做的一件主要的事情。
我们要做的是将工程师、技术和产业真正连接起来。
对工程师来说，你的成长最终是要做市场应用，这才是真正的成长。你学了这些，人工智能，图像识别，语音识别，我们能够给你找到应用的场所。
总结来说，我们做有两点。
第一、人才的增长。假设现在有一千万名工程师，年之内，中国应该有的人要成为的工程师。
第二、每个行业都会变成一个以技术驱动和数据驱动来引领。对于企业来说，一定要了解数据在公司里面到底该怎么去应用。现在互联网公司有数据，但很多行业还不够智能，没有数据，因此我们也希望帮助三十万家企业走向智能化。
接《关于程序员转型  这件事，三位老炮跟你聊些干货中》

文章来源：科技大本营

相关推荐：
关于程序员转型这件事，三位老炮跟你聊些干货中关于程序员转型这件事，三位老炮跟你聊些干货下大家好，文章来源于的公众号。
 作者：，曾是一名，现在是鹅厂视频部门的后台开发。这里主要记录工作中的技术架构与经验、计算机相关的技术、数学、算法、生活上好玩的东西。

前言
听了图片的压缩算法，发现蛮有意思的，这里分享一下。
一、整体思想
有损压缩算法是一个可逆的算法，所以这里重点介绍压缩部分，对于逆过程这里就不谈了。
整体压缩流程如下：

色彩空间转换

缩减取样

变换

量化

熵编码技术


下面分别讲一下这几部分都是做什么的吧！

这里先强调一个思想：
有损压缩的本质就是抛弃那些不影响大局的信息。
从而做到使用更小的储存来表达对应的信息。

二、色彩空间转换
颜色具体显示的时候需要是的形式，比如每个像素由三个字节的数字组成。
这样的表示相当于使用三个互相独立的颜色矩阵组合成了一张图片。
每个颜色矩阵是等价的，且任何一个颜色矩阵数据有较大偏差时，我们人眼都能明显感知到。

生物学上，研究发现人眼对亮度差异比较敏感，但是颜色的差异变化并不是那么敏感。
所以就有人想到转化为亮度和颜色的表示形式。

大概有下面几种算法：， 和 ， 而这里采用的是转化算法。 
维度代表一个像素的亮度，和维度用来代表颜色。
这个转换的好处是后续的步骤中对维度只能稍微抛弃一些的信息，对于维度可以大量的抛弃信息。
实际使用中由于小数的精度和性能优化，可能导致实际处理中出现一丢丢数据丢失。
当然这一丢丢数据的丢失我们可以接受，然后就可以进入下一部分了。
三、缩减取样
既然有损压缩代表需要抛弃部分数据，那我们主动抛弃一些数据吧。比如一整图片像素那么多，常见的方式是在和维度隔一行取一个信息这样在维度上数据直接较少一半了
这一部分是第一次对数据有损抛弃，两个维度直接减少了一半，整体的话就是减少了三分之一。
四、变换
变换的含义是离散余弦变换。
色彩空间转换小节中我们看到数据三个维度是完全等价的，导致不能尽情的抛弃数据。于是我们转化为数据，然后就可以对维度尽情的抛弃数据还不会影响整体数据质量。

那现在我们遇到同样的问题。
对于每一维度都是一个矩阵，矩阵的每一个点对我们来说还是完全等价的。
我们能不能对矩阵进行转化，然后就可以对矩阵的一部分数据尽情的抛弃数据呢？

这样变换的方法有很多，比如傅里叶变换，变换，正弦变换，余弦变换，斜变换，哈尔变换，变换等等。
这里采用的是余弦变换。
余弦变换后的效果是矩阵左上角的数据权重较高，对于右下角的数据权重较低。
这些变换和色彩空间转换一样，都是可逆的，无损的。
但是变换后的特性允许我们对不同部分的数据进行不同程度的有损。
五、量化
量化的作用就是对于权重较低的数据进行大量有损抛弃，而对权重较高的数据稍微有损抛弃。
这里实际操作就是对矩阵的每个数据进行若干比例的缩小。
矩阵的数据缩小之后有了另外一个特性：大多连续数据是相同的了，右下角的数据大部分是了。
这里需要提到的一点是对矩阵等比例缩小实际上就是乘以另外一个矩阵。而这个矩阵称为量化表，一般这个量化表是固定的。

前段时间宣传提高了的压缩率，实际上就是找到了一个整体情况更好的量化表应该是这样。
由于最终有损压缩出的图片很难使用机器或算法来判断是否优劣，所以这里就没有更好的方法来自动计算最优的量化表了。
之所以得到了更好的量化表，是使用数据挖掘机器学习？神经网络？模拟了人眼，然后用这个人眼来反馈图片的压缩质量，最终找到更好的量化表。

六、熵编码技术
我们使用量化表抛弃了很多影响不大的信息，但是我们并没有进行任何压缩，只是为这一步的压缩准备了条件。
上面提到了，量化后有个特性：大多连续数据是相同的。 
于是我们就需要编排数据，然后使用算法进行无损压缩。
是的，这一步的优化也是无损可逆的。
而且实际处理中为了性能，我们往往是已经有一个经验码表。
这样就不需要进行概率计算了。

唯一的缺点就是中没有储存这个码表，这样导致这个码表用于没办法更新了。
当然，码表也比较大，如果储存起来也极大可能导致压缩后数据更大的可能性了吧。

七、总结
经过上面五大步操作，图片就完成了压缩。
可以看到这个压缩算法分工很明确：
算法上：

色彩空间转换，变换都是无损可逆的转换算法。
缩减取样和量化是有损可逆的算法。
熵编码技术是无损可逆压缩算法。

依赖上

色彩空间转换算法为缩减取样与量化做好了准备：维度的轻重分离。
变换也为量化做好准备：矩阵的轻重分离。
量化为熵编码技术做好了准备：重复数据连续性特点。

这个算法挺有意思的，后续遇到其他有意思的算法继续分享给大家。
八、参考资料

主要是部门的分享，了解了这个算法的思想。

 。

论文   微信号中可索要此论文。在我们提供的安防监控体系中，每个监控系统每天会产生几个  的视频数据，这些未经处理的视频数据一般需要存储几个星期，经过剪辑和压缩处理的视频数据可能需要归档存储三个月至半年。如此大量的视频数据，如果在本地备份并归档，将长期占用硬盘存储空间，不仅扩容麻烦，而且很容易出现单点故障，难以保证数据备份归档安全。因此，我们考虑依托公有云服务，来实现海量音视频监控数据的存储、备份以及归档。
由于业务特性安防监控的数据存储要求安全、海量、上传下载快，所以我们对现有的公有云产品做了调研，了解到，腾讯云的对象存储目前可支持：、理论上无限大的存储空间；、可以存储无限大的单个文件；、对每一个文件都进行重文件备份，可确保文件不会因单点故障而损坏或丢失。除却业务需求之外，在价格上，由于我们的存储量较大，所以和客服取得了联系，并得到了一定的优惠。综合各方面考虑，我们决定使用腾讯云来实现数据迁移上云。
在我们的安防监控中，各类型的摄像头会采集音视频数据，然后将数据上传至本地服务器。监控中心从本地服务器调取音视频数据，进行日常监控以及定期备份。本地服务器承载了大量的存储压力，所以，云化改造的第一步，就是实现音视频数据的上传下载。

于是，我们基于腾讯云  提供的   ，对现网的监控探头做了简单的二次开发，修改了“存储管理”和“网络传输”模块，使其能够将录好的音视频文件，通过公网直接上传至腾讯云  。经过改造后的视频源生成系统，本地服务器只负责管理  相关的签名鉴权和云端存储路径。只要视频源系统和腾讯云  之间的网络畅通，监控所得的音视频、图片等数据，就可随时迁移上云。
对于监控中心，只需将原先配置中的本地服务器域名改为腾讯云  的域名即可，对上层业务基本无影响。
对于移动端的监督用户，在云化改造之前，要想回放监控视频，必须去访问监控系统的本地服务器，限于物理距离和网络带宽，回放很容易出现卡顿。在云化改造之后，腾讯云提供了  来加速  上的资源分发，使得移动端用户即使是在全国漫游时，也能流畅稳定的拉取到  中的音视频资源，极大的提高了用户体验，并且，经  渠道拉取  资源，费用比直接访问  的  更为便宜。其改造过程和监控中心类似，只要配置得当，可以沿用以往的资源相对路径，仅需替换服务器域名即可。
在将存储和上传下载业务迁移上云后，我们随之考虑引入关于智能语音、视频格式转化、万象优图图片处理和人脸识别等腾讯云大数据与  产品，以期能拓展安防监控的业务领域，深挖行业潜力，通过集成创新来推动产品升级。
在这些产品中，对安防系统优化效果最显著的莫过于文件存储大小的压缩和智能语音识别。其中，对于视频清晰度，腾讯云提供了“超清高清标清手机”这四种选择，可以在云端自动对存储到  中的视频进行清晰度转码。

当请求视频资源时，通过设定参数，即可取得对应清晰度的视频。

基于此功能，我们实现了视频的定期转码和归档存储。比如，每隔一个星期，将视频的清晰度降低一个级别，以节省存储空间，逐步进入归档存储。
同理，对于图片的存储，也可以采用腾讯云的格式转换功能，将图片由  转为  格式，这样，图片大小能够被压缩得很低但是清晰度仍然足够，从而实现图片文件的归档存储。
对于智能语音的应用场景，我们目前有三个：

对于外出巡察的值班人员，可以在巡察过程中口述巡察情况，安防系统将实时接收并存储音频文件。

对于单元楼门口的语音对讲门铃，安防系统将记录语音。

对于群众的求助、投诉或建议电话，我们将做录音。


这两个场景将产生大量的音频文件，在归档存储时，我们将该音频文件先经过腾讯云的智能语音识别，转化为文字，然后删除很久之前的语音文件，只归档存储文字。
在云端大数据技术的集成和应用方面，还有很多场景可供挖掘，未来，我们还将加入人脸识别、区域人流分析、自然语言呼救等功能，从而不断完善我们的产品，打造“监控识别告警处理”快速反应的一体化防治系统。

相关推荐深入浅出腾讯云：缓存篇【腾讯云的种玩法】 整合  对象存储服务，享受无限容量存储服务导语
腾讯云 集群版已经有数千用户，售出数十容量，那么  是如何做配置管理的呢？通用的集群系统都需要做配置管理分发，成员健康度检查，希望能带给您启发。
 集群版改造自  后台存储数据库 ，拥有十多年的技术积累与传承，由  即通平台部公共组件组多年研发，数据运营部  组持续运维运营。目前部署有上万台的集群，每秒承受上亿的访问。 集群主要是由管理机、接入机、存储机三种角色组成。配置中心会部署在管理机上，配置客户端则会部署在集群的每台机器上。

配置管理模块，由上图的“配置中心” 与 “配置客户端”组成，是一套实现的架构。配置中心是一个单进程多线程架构，每个线程负责单独的功能。配置中心进程启动后，首先进行初始化，然后启动各个工作线程。初始化的分析因为不是重点，所以放在文末。现在介绍各个主要的工作模块：

配置加载：将配置信息从加载到内存中  服务端配置
存活更新：将的存活状态做改变 客户端状态  服务端配置
筛选机器：筛选出需要接收配置的机器 客户端状态  服务端配置
推送配置：将配置推送到指定机器 服务端配置  客户端
接收心跳：接收心跳并更新客户端状态 客户端  服务端配置


主要的角色：配置客户端    配置中心 客户端状态，服务端配置    
配置加载
该模块由一个独立的线程实施，会把数据库中最新的配置信息加载到共享内存，加载前会有一些合法性校验。
  = _   
  
 {
 ______   \
  
 }
我们一般是如何来更新集群的配置信息呢？
 运营系统提交的 语句 更改中的配置信息； 执行  __  _=_ 更新序列号；
该模块的逻辑包裹在循环中，循环间隔 ，这也就是说，当我们在中更新配置后，大概秒会加载到共享内存中；
线程会在中执行  __  _，主要是为了取得_这个序列号。历史上会用_字段的信息，但现在已弃用，不作为需要加载的标志；
线程每读一次，都会执行这么一条语句，以更新最后一次读的时间。 _  _____ = _ 这是用于主备配置中心的死机切换判断的。更新失败上报  主设置最后读时间失败，更新成功上报  和  主设置最后读时间成功。我们通过 ______  _就能看到，每秒_____值都会被更新一次。
如果 _已经与进程的全局变量 _不同，则意味着需要把的最新配置信息加载到共享内存中了，因为运维人员对中的配置信息可能有误操作，所以在加载到共享内存前，程序有严格的合法性校验，以免取得错误的配置信息，破坏集群的安全。
那么合法性校验具体是怎么做的呢？
 把所有配置加载到待更新的临时配置中 把数组两个元素指向的配置，进行一个比对，这里检验条件就非常多了，如新加的_与旧的_要行程等差数列，_相同的条目_必须不同等等，这里就不一一列举。
下面这个结构体，我们看到数组可以保存两个元素，一个保存在用的配置，另一个保存待更新的临时配置
  
{
   指向最新更新的配置共享内存的指针 
   
} 
配置合法性检查不通过，上报 配置中心装载新配置时，因检查不合格而拒绝装载。这是一个比较重要的上报，因为同时变量_ =  ，后面介绍的推送配置模块，如果发现该变量为，则会终止推送，那么诸如主备切换等新集群信息，也无法下发了，所以需要尽快处理。而我们的运营系统是通过看日志来检测配置是否加载成功的。成功的话，后会把 成功日志写到文件中。
______    
如果失败，不用任何秒数，直接就会写失败日志：______   = 
所以我们校验加载配置是否失败，只需要在数据库 后，过秒后，检验日志文件，是否同时出现了以及 字眼，如果是，那么就是加载配置失败了。
假如配置的的确是发生了改变，那么线程会生成一个配置包待下发，这是因为有时发生了改变不一定意味着配置有改变，所以还需看。生成配置包失败会上报 数据生成配置包失败，成功会上报 启动，生成配置。
然后进行临时内存结构体与运行内存结构体的切换，以达到启用新配置的目的，
_
_ = 
 _

 
_ = 
最后我们还会更新由新配置生成的信息。
_
上述我们看到了结构体，这里我也把相关的需要参考的结构体一并列出。

 管理所有配置信息的数据结构
 
{
  
  
  
  
  
  
} 
 管理所有_的数据结构
  
{
 _  有多少个虚拟机
  ______ 保存所有虚拟机数据结构的数组
} 
 ____   单拷贝最大虚拟机数量
 __   最大拷贝数量

 一个虚拟机的数据结构
  
{
 _     主键
 _    名字，用于做用。多份拷贝的机器采用一一对应方式，一一对应的机器名字相同。这样前端寻址时候值才能一样。
 _   存储机地址，存储的时候用主机序来存储
 _   该虚拟机在物理机器中的编号
 _   角色 同_中的_ 
 _   该机器的虚拟节点个数
 _   所归属的 
 _   每个虚拟机器的进程数目 
 _   工作状态配置，人工设置是否处于运行状态和_中_定义相同 
 _   扩容标记 非扩容，扩容中 
 _   读写同步配置，人工设置是否处于读写或者同步
 _ 
 _  
 _   机器上报运行非运行状态 
 _   拷贝
 __
 _ 
 _ 
 __
 _   盘设备名，如，互为备份的该字段可以不同

 __  __   

 _  
}

 _客户端的更新信息
  
{
 _ 
  ______ 
} 

一条_客户端的更新信息
  
{
 _   虚拟机编号
 _  最后上报时间，用于判断存活心跳
 _  最后上报时客户端配置的优先级
 _  最近上报的值 
 _  配置最后推送时间
 _   保留字节
} 

管理所有  机器的配置更新信息
  
{
 _ 
  ___ 
} 

  机器信息
  
{
 _   
 _  最后上报时间
 _   最后上报时客户端配置的优先级
 _   最近上报的值 
 _   给 下发配置的最新时间
 _ 
} 

  
{
 _  
  ______
}
 ____   单拷贝最大物理机器数量
 __   最大拷贝数量

 物理机器 和虚拟机 的对应关系
 便于根据寻找虚拟机器
  
{
 _  
 _ 
 _ ____
}
 ____   每台物理机器最多有多少台虚拟机器
备注：集群的一台物理存储机，逻辑上会划分为个或多个，每个对于集群就是一个独立的存储机，独立提供服务，这有点虚拟化的意思。 
存活更新
该模块由线程单独实施，会跟进客户端状态列表中机器的心跳情况，来更新客户端状态，可能是从_，或者从_。改变状态后，还会产生推送配置包并放置到推送队列中。
逻辑包裹在循环中，循环间睡眠间隔秒，遍历每一个，获取其最后一次上报与当前的时间差距秒，
 =  
如果  已经大于某个伐值如分钟：如果当前该我们记载是状态，那么我们就就要将其转为_了。如果是_则什么都不用做。如果  小于等于某个伐值如分钟，这说明了已经有心跳上报了：如果当前是_，则转为。如果当前是，则什么都不用做。
按照如上逻辑：死了的机器是过一段时间可配才会被置为，后面的请求才不会转发到这，但机器如果复活了，可能不到秒就能判断其活了。这就是状态转换的时间差别。
 如果间隔时间超过伐值
    __ 这两个配置参考上述初始化时从配置文件读入的项
 { 
  当前是的
  == 
 {
  = 
 
   = 
   = {}
   = {}
  = _
  ______
  = _
  ______
 _  = 
 ______    _        ____ __ 
 }
 }
  如果最近短时间内就有过心跳上报
 {  如果是_的话，我们就要考虑把他置为了。
  _== 
 {
  = 
 
   = 
   = {}
   = {}
  = _
  ______
  = _
  ______
 _  = 
 ______    _        ____ __
 }
 }
从上述代码我们能看出来，需要进行状态转换的，都会把被加到数组中，所有都加到数组以后，我们就对该数组进行遍历，并且把对应的状态进行变换。
 更新状态
   =     
 {
  = 
  =  
   == 
 {
 ______    
 _ 根据获取信息失败
 
 }
  =   
   == 
 {
 ______    
 _ 根据获取信息失败
 
 }
  如果当前是那么就改为_
  == 
 {
 ______   _ 
  = _
  = 
 }
  如果当前是_，就改为
 
 {
 ______   _ 
  = 
  = 
 }
 }
如果配置加载模块，该线程最后会更新服务器配置的值，以及为新的配置生成配置包，并推送到队列中。
筛选机器
线程  负责筛选出需要发送配置的机器，从这里我们知道，配置并不是需要推送到所以机器上的，而之后客户端状态的与服务器状态有差异时，我们才会推送配置给该客户端。这个模块主要就是用来筛选出需要接受配置包的机器。
业务逻辑都在循环中，循环至少间隔秒 ： 获取当前消息队列 _ 中，未发送的消息数量机器数量有多少。这里失败上报 推送调度，获取消息队列数据失败，成功上报 推送调度，消息队列数据还没有处理完。
如果消息数量不为，也就是上一轮发送还未完，那么放弃本轮循环的操作，进入下一次循环。
如果消息数量为，也就是之前的消息机器都处理完了，那么我们这次就来看看，是否有需要接收配置信息的客户端。
把这个结构体推送至消息队列 _，表明这里开始新的一轮，宏定义如下。失败会上报推送调度将放入消息队列失败。
 
  
{
 _ =宏值是
 _ =
 _ =服务器最新配置位
} 

  
{
  = 
 ___ =  
 ___ = 
 _____ = 
  = 
} _
接下来还会执行

具体的逻辑是，遍历  机器的客户端状态列表  ，如果发现其最后上报心跳时间超时了，说明可能死机了，那么将其上报置，这样不一致会导致配置一直往其发送，这样后续机器复活后也能获得新配置。
如果发现最后上报心跳时间没有超时，比较上报的与服务器保存的；
如果一致的话，说明无需推送配置已经是最新；
如果不一致，那么上报 推送配置，优先级较低，并将如下结构体压入消息队列，并且将该配置的最后推送时间置为当前时间；过程出现问题上报 推送调度将放入消息队列失败
  
{
 _ =宏___值是
 _ =的
 _ =服务器最新配置
} 
接下来还会执行

具体的逻辑是，遍历所有  机器，获取每个机器上的第一个一个机器可能有若干个，根据这个，获取该的服务器配置与客户端状态信息。如果该机器当前是_状态，那么很可能该机器就死机了，就将其值置空，以防止机器重启后一直获取不到配置的问题。这里与上述遍历机器的机器的逻辑有点相似，但上述是要计算是否已经超时，而机器本身就有与_状态，就不用再计算。然后就对比服务器与客户端的值，
如果一致的话，说明无需向该推送配置，并且到下一个循环。
如果不一致，则说明该需要获取最新的配置了，我们把这个结构体压进消息队列：
  
{
 _ =宏___值是
 _ =的
 _ =服务器最新配置
} 
压入消息队列成功后，还需要更新该下所有  的 最后推送配置时间  更改成当前时间。
如果上面的确有需要推送的机器被压入队列，那么就把与值压到队列中，否则把与空的值压入到队列中。所以你猜到了，后面的推送模块，看到这个后，还得判断值是否全，来判断是否有要推送的机器。
  如果有需要推送的机器把标记也压到消息队列中
    
 {
 
 }
  如果没有需要推送的机器也把标记压到消息队列中然后把为的值也压入
 
 {
 _ 
  
 
 }

  
{
 _ =宏值是
 _ =
 _ =服务器最新配置 或者 
} 
配置推送
这个模块是将最新的配置信息，推送到 筛选机器模块中指定的机器上。这个模块有个特点，为了加速配置的推送，会创建很多线程，数量根据配置文件中的配置项  来定一般是
 =_
{
  = _   
  
 {
 ______   \
  
 }
}
中具体的逻辑是什么呢？线程会不断地循环，每次循环会固定睡眠秒： 然后会获取消息队列中的一个数据结构消息结构如上，不能读出消息队列为空，则，读出的话，解释出其地址，再解释其字段。
如果 = ，这说明还没有需要推送的机器，到下一个循环。
如果 = ，那么说明本轮配置已经全部下发。这里会比较这个消息结构的与服务器配置的是否一致，
如果不一致也就是全的情况：那么说明本轮其实并没有需要下发配置的机器，到下个循环。
如果一致，说明本轮确认是进行过机器的配置下发。那么检查一下配置推送的结果，主要看： 成功推送配置的数量 ；应该推送的数量，没有推送错误的数量，如果小于很可能别的线程在发送并且未发送完，并且没有错误量的发生，那么我们稍微等一段时间可配。最后将这三者的结果打印日志，以及入库与上报等等。我们查问题是： __  __来看某次具体的下发是否成功，是代表成功，代表失败。
如果非也非，那么向刚才解释出来的，客户端端口，推送配置。这才是最重要的。推送失败上报 推送配置到指定失败并且把对应结果加如果成功，把对应结果加推送成功，会记录推送的耗时时间并上报。
 下发配置时间在 单位毫秒，书醒从至都是记录推送时间的。
接《 腾讯云  集群版配置管理揭秘  下 》本文紧接上篇《高并发性能测试经验分享上》
内存泄漏
虽然解决了 ，但是另外一个问题又浮出了水面，就是高并发测试时，会出现内存泄漏，大概一个小时的样子。
的缺点
出现内存泄漏或者内存问题，大家第一时间都会想到。是一款非常优秀的软件，不需要重新编译程序就能够直接测试。功能也非常强大，能够检测常见的内存错误包括内存初始化、越界访问、内存溢出、错误等都能够检测出来。推荐大家使用。
 运行的基本原理是：待测程序运行在提供的模拟上，会纪录内存访问及计算值，最后进行比较和错误输出。我通过测试也发现了一些内存方面的错误，简单分享下测试的经验：
通常都是使用 子进程的方式运行，使用–=来追踪子进程的信息。测试  时，在使用函数的地方会提示很多内存错误。比如       ，       等。这是由于数据需要一些熵，未初始化是正常的。如果需要去掉提示错误，编译时需要加一个选项：。如果进程较多，比如超过个时，会导致的错误日志打印混乱，尽量减小工作进程保持为个。因为一般的内存错误其实和进程数目都是没有关系的。
上面说了的功能和使用经验，但是也有一个非常大的缺点，就是它会显著降低程序的性能，官方文档说使用工具时，降低倍。也就是说，如果完全握手性能是 那么使用测试，性能就只有 左右。对于一般的内存问题，降低性能没啥影响，但是我这次的内存泄漏是在大压力测试时才可能遇到的，如果性能降低这么明显，内存泄漏的错误根本检测不出来。只能再考虑其他办法了。
的优点
 简称是一个用来检测程序的快速内存检测工具。相比的优点就是速度快，官方文档介绍对程序性能的降低只有倍。对原理有兴趣的同学可以参考的算法这篇文章，它的实现原理就是在程序代码中插入一些自定义代码，如下：
编译前： =        =  编译后：
  {
  
}
 =      = 
和明显不同的是，需要添加编译开关重新编译程序，好在不需要自己修改代码。而不需要编程程序就能直接运行。 集成在了编译器中， 版本以上才支持。我们线上程序使用的版本较低，于是我测试时直接使用重新编译：

—=”” \
—=”  = ”
其中是指定编译器，指定编译选项， =就是开启功能。
由于对的影响较小，所以大压力测试时也能达到上万的并发，内存泄漏的问题很容易就定位了。这里就不详细介绍内存泄漏的原因了，因为跟的错误处理逻辑有关，是我自己实现的，没有普遍的参考意义。最重要的是，知道和的使用场景和方法，遇到内存方面的问题能够快速修复。
性能热点分析
到此，经过改造的程序没有 和内存泄漏方面的风险了。但这显然不是我们最关心的结果因为代码本该如此，我们最关心的问题是：代码优化前，程序的瓶颈在哪里？能够优化到什么程度？代码优化后，优化是否彻底？会出现哪些新的性能热点和瓶颈？这个时候我们就需要一些工具来检测程序的性能热点。
性能分析工具
世界有许多非常好用的性能分析工具，我挑选几款最常用的简单介绍下：
应该是最全面最方便的一个性能检测工具。由内核携带并且同步更新，基本能满足日常使用。推荐大家使用。
，我觉得是一个较过时的性能检测工具了，基本被取代，命令使用起来也不太方便。比如 —   —等命令启动，然后是 —，  —，  停止，查看结果等，一大串命令和参数。有时候使用还容易忘记初始化，数据就是空的。
主要是针对应用层程序的性能分析工具，缺点是需要重新编译程序，而且对程序性能有一些影响。不支持内核层面的一些统计，优点就是应用层的函数性能统计比较精细，接近我们对日常性能的理解，比如各个函数时间的运行时间，，函数的调用次数等，很人性易读。
 其实是一个运行时程序或者系统信息采集框架，主要用于动态追踪，当然也能用做性能分析，功能最强大，同时使用也相对复杂。不是一个简单的工具，可以说是一门动态追踪语言。如果程序出现非常麻烦的性能问题时，推荐使用 。
这里再多介绍一下命令，系统上默认都有安装，比如通过 就能列举出当前系统或者进程的热点事件，函数的排序。 能够纪录和保存系统或者进程的性能事件，用于后面的分析，比如接下去要介绍的火焰图。 
火焰图  
有一个缺点就是不直观。火焰图就是为了解决这个问题。它能够以矢量图形化的方式显示事件热点及函数调用关系。比如我通过如下几条命令就能绘制出原生在_  下的性能热点：       —    |    

直接通过火焰图就能看到各个函数占用的百分比，比如上图就能清楚地知道___和___函数占用了的采样比例。那我们要优化的对象也就非常清楚了，能不能避免这两个函数的计算？或者使用非本地方案实现它们的计算？当然是可以的，我们的异步代理计算方案正是为了解决这个问题。
从上图可以看出，热点事件里已经没有相关的计算了。至于是如何做到的，后面有时间再写专门的文章来分享。
心态
为了解决上面提到的 和内存泄漏问题，花了大概三周左右时间。基本上月份对我来说就是黑色的，压力很大，精神高度紧张，感觉有些狼狈，看似几个很简单的问题，搞了几周时间。心里当然不是很爽，会有些着急，特别是项目的关键上线期。但即使这样，整个过程我还是非常自信并且斗志昂扬。我一直在告诉自己：
调试是一次非常难得的学习机会，不要把它看成是负担。不管是线上还是线下，能够主动地，高效地追查特别是有难度的，对自己来说一次非常宝贵的学习机会。面对这么好的学习机会，自然要充满热情，要如饥似渴，回首一看，如果不是因为这个，我也不会对一些工具有更深入地了解和使用，也就不会有这篇文档的产生。
不管什么样的，随着时间的推移，肯定是能够解决的。这样想想，其实会轻松很多，特别是接手新项目，改造复杂工程时，由于对代码，对业务一开始并不是很熟悉，需要一个过渡期。但关键是，你要把这些问题放在心上。白天上班有很多事情干扰，上下班路上，晚上睡觉前，大脑反而会更加清醒，思路也会更加清晰。特别是白天上班时容易思维定势，陷入一个长时间的误区，在那里调试了半天，结果大脑一片混沌。睡觉前或者上下班路上一个人时，反而能想出一些新的思路和办法。
开放地讨论。遇到问题不要不好意思，不管多简单，多低级，只要这个问题不是你一下就能得到的结论，大胆地，认真地和组内同事讨论。一、数据插入篇
有唯一主键或者存在时，避免重复插入的方法
在一些报名拉票类型活动中， 往往需要对做唯一键处理，限制个用户只能有条报名记录。 为避免并发时重复数据的插入，
常用方法有种：

  

 

   


假设有表如下：

使用   ：
基本语法：
        
分析：
 的好处是，当存在唯一主键冲突时，则直接忽略最新的操作，返回不报错；没有冲突则正常插入数据。一句话概括就是：“无则添加，有则忽略”。
假设原数据库已有数据：

执行 重复插入，提示插入了行表示忽略此次操作：

执行 插入，无主键重复，则正常插入新行：

使用  
 ，也是可以用于避免数据重复插入的方法，但它与 最大的不同就是： 当有唯一主键冲突时， 是直接忽略新数据，而  是用新数据整行替换旧数据， 它会先从数据表中删除唯一主键冲突的行，再尝试插入新行。
基本语法：
        
关于返回：
 执行后会返回受影响的行数，该数是被删除和被插入的行数总和。如果返回数是，则说明是首次插入数据； 若返回数是，则说明在新行插入前，有一行旧数据被删除；若是返回数大于，则一般是表中有多个唯一索引，有可能是一个单一行替换了多个旧行。
假设原数据库已有数据：

执行上述语句后， 有主键重复，则先删除原有重复记录，再执行新插入，影响行数行：

执行无主键冲突，则是插入新行，影响行数：

特殊说明：
如果表中有一个自增主键，则不建议用 ，因为后新旧记录的主键值不同，若是还有其他表中与本表主键有关联数据的话，关联关系就会被破坏。再者，频繁的 ，自增值迅速变大，会有溢出风险。
使用    
常用语法：
             ==
语法解析：
当在时若遇到主键唯一键冲突，则会在原语句上执行后面的操作， 无重复时则正常插入。
   适用的场景比较特定：就是当数据入库时，若遇到主键唯一键重复存在的数据时，则需要去修改它；不存在时则新增。
假设原数据库已有数据：

执行    有主键重复时，在原来语句上执行，影响行数行：

在使用上    也可以支持多行插入，多行插入时，可以使用列名函数引用列值进行更新操作。
方法如下：
        ，       =
以上语句意思就是说：插入数据时，若当前行存在唯一键冲突，则引用当前行时的列来更新字段，无重复存在的记录则正常插入。
假设原数据库已有数据：

上述语句执行后，结果如下：

分析：
为遇到主键重复，所以是在原语句上的，将值为当前语句的，也就是=，影响行数是行。 而为的行没有主键重复，所以是新增插入， 影响行数是行。 故，总影响行数是行。
二、数据查询篇
、 和    的差别
基于 数据取值原理，如果抛开索引和，光从 和   的效率来说实际是相差不大的，如下图：

这和内部数据存储结构有关，详细原因有兴趣的可以参考的数据查找原理。这里呢就重点说说，两者在编程习惯上和扩展性上的差别：
不管是  还是    ，查询效率重点还是取决于后面的索引设计
原则上，尽量少用 
虽然从扩展性而已，如果表结构变更比较频繁，使用 会减少不少的代码变更，但是在营销活动开发的应用场景上说， 每个活动都是短期存在的，且表结构变化不大，每条语句读取的字段都比较明确，建议优先使用   。
    可以减少网络传输，减少服务器的开销。
、  、、列名的区别
整理中。。。
、关于的妙用
整理中。。。本文是【开源项目贡献指南】系列的第一章的下篇，接上篇《 开源项目贡献指南如何给开源项目做贡献 上》。
高效率的沟通
不管你是一个一次性的贡献者还是想要加入社区，和他人合作是你在参与开源项目过程中会培养的一项重要技能。

作为一个新的贡献者，我很快意识到如果我想关掉  的话我得问一些问题。我浏览了一下代码架构，当我对项目有了基本的把握之后，我便询问我下一步该做什么。最后，当我了解了我所需要的所有细节之后，我能够解决那个  了。
—   ’         

在你打开一个  或者 发起一个   或者在聊天室问一个问题之前，把下面这些要点记清楚以此来更好的表达你的想法。
给出上下文：帮助人们快速了解你提出的东西。如果你遇到了一个问题，解释你想做什么和怎样重重现该问题，如果你是在表达一个新的想法，解释一下为什么你觉得对项目来说这个想法是有用的而不仅仅是对你而言
正确示例 “当我做甲的时候，乙为什么不出现”
错误示例 “这个啥啥啥出问题了，麻烦修复它”
提前做好功课：无知是没问题的，但是告诉别人你已经尽力了。在寻求帮助之前，一定要先看看  文件，文档，开着的关着的都要看，邮件列表，在网上也找一找。当你展示除了一种想要学习的态度的时候别人会很乐意帮助你。
正确示例 “我不确定怎么实现这个，我查看了帮助文档但是没有找到相关的内容”
错误示例 “我怎样做才能啥啥啥”
保持你的请求简短清晰：就像是发邮件一样，每一次贡献，不管是多么简单或者多么有帮助，都需要有人审查。很多项目提问的数量远远多于提供帮助的人。保持简洁，你会增加别人帮助你的概率。
正确示例 “我想写一个  使用教程”
错误示例 “当我有一天下高速加气的时候突然想到了关于我们正在做的事情的一个牛逼的点子，在我解释之前，让我先展示…”
保持所有交流都是公开的：就算私下联系项目的维护者是很诱人的，但是除非你要分享一些敏感信息比如一个有关安全的  或者是严重违反守则的行为，否则就不要这么做。当你让对话保持公开，更多人可以从你们的对话中学到更多。讨论本身也是一种对项目的贡献。
正确示例对于评论” 你好！我们应该怎么处理这个 ”
错误示例 对于邮件 “你好 不好意思通过邮件打扰你，但是我想问一下你是否有时间审查一下我的”
可以问问题但是一定要耐心！： 从某种程度上来说，每个人都是某个项目的新人，即使是对于有经验的贡献者，当他们刚开始接触一个项目的时候也要费点力气。同样，即使是长时间维护项目的人也不是对项目的所有细节都了如指掌。如果你想让他们对你有耐心的话你首先得对他们有耐心。
正确示例 “麻烦你看一下这个错误。我采取了你的建议，这是输出。”
错误示例 “为什么你没解决我的问题，这不是你的项目吗？”
尊重社区的决定：你的想法可能和社区优先考虑的事情或者说看问题的视角不一样。他们可能会给你反馈或者拒绝你的想法。然而你应该和他们讨论然后寻求妥协，维护者会比你在决定方向上话费更多时间，如果你不同意他们的方向，你可以一直在你  的仓库上工作，或者自己创建一个新项目。
正确示例 “你没能支持我想要的特性我很失望，但是就像你解释的那样，它只会对一部分的用户有用，我知道为什么。感谢你聆听我的建议”
错误示例 “为啥那么你不支持我的需求呢？这简直没法儿接受！”
总之，保持优雅的状态：开源项目是由来自全世界的协作者一起创造的。这意味着开源协作的背景是多语言，多文化，跨地理位置，跨时间区的。除此之外，用键盘敲出来的文字无法传达音调和情感。所以在交谈中要呈现出善意的一面。礼貌的在一个想法上表达不同看法，或者询问更多细节，表明自己的立场，都是可以的。努力让网络空间变得更美好。
收集背景信息
在你做任何事之前，快速检查一下你的想法还没在别处被讨论过。浏览项目的  文件，开着的关闭的，邮件列表，  。你不需要花费数小时去浏览所有的信息，但是对一两个关键词的快速搜索也会大有帮助。
如果你在别的地方找不到你的问题，你就可以搞事情了。如果项目是在  上的，以可以通过开  或者发   和别人交流。

 就是发起一次交谈或者对话。

  验证某一种解决方案

  ，比如一个    待翻译，在   上提问， ， ，或者其他的聊天频道，如果你所在项目有的话。


在你开  或者   之前，查看项目的贡献文档通常是一个叫  的文件，或者就在  里面，看看里面有没有你要的信息。举个例子，他们可能会让你遵照一个模板，或者要求你包含一个测试。
如果你想要做做一次比较大的贡献，先开一个  问一下。最好是  这个项目在  上，你可以点击 “” 这样你可以接受所有对话的通知，然后认识一下社区的成员，因为你的工作并不会被他们接受。
开一个 
在以下的情况你就应该开一个 

报告一个你自己解决不了的错误

讨论一个高级别的话题或者想法比如社区，这个自己体会。。，政策

提出一个新功能或者其他的关于项目的想法


在  中交流的小贴士：

如果你看到了一个开着的  ，而且你想解决他 在  中评论让人们知道你在尝试解决他，这样别人就不会重复你的工作了。

如果一个 已经打开一段时间了，有可能这个  别人已经在解决了，或者早就已经搞定了，所以在你开始动手之前在相应  的评论里面问一下比较好。

如果你打开了一个  ，但是最后自己解决了， 在  的评论里面告诉别人，然后关掉这个  。甚至以文档的形式把你的成果展示出来也是对项目的一种贡献。


发一个  
在以下的情况下你就可以发一个  了。

提交一个小问题的修复比如手误，挂掉的链接，或者明显的错误

准备实现一个早就有人提过的需求，或者是解决在某个  中讨论的问题


一个   不需要是现在已经搞定了的工作。通常最好是在这之前就发起开一个   ，这样别人可以查看你的工作情况，或者对你现在的进度给予反馈。只要在标题行打上  正在进行中的标签就行了。你可以稍后添加更多的信息。
如果项目是在 上的话，这里展示了如果提交了个  ：

复刻仓库 然后克隆到本地。通过把它添加到  就把你的本地仓库和远程的“上游”仓库链接起来了。要经常从你的“上游仓库”拉取代码以此来保证同步从而当你提交你的   的时候，合并冲突就变得更容易了。从这里查看更多教程

创建分支 用来编辑代码。

引用任何相关的  或者在你的  顺便附上相关信息比如 “关掉  ”

包括修改之前和之后的截图 如果你的改动包含  文件。拖放图片到   的正文。

测试你的改动 在你的改动上运行已经存在的测试，有必要的话创建新的测试。不管之前有没有测试，都要保证你的改动不会破坏项目已有的功能。

按照项目的风格改动 将你的能力发挥到最好。这意味着会使用和你自己仓库不一样的缩进，分好和注释风格。但是这会方便维护者合并，其他人在以后也好理解。


当你提交一次贡献的时候发生了什么
你做到了！恭喜成为一个开源贡献者。而我们希望这仅仅是开始！
当你提交你的  之后，可能会发生以下几种情况。
你并没有得到回应
在你做贡献之前你还满怀希望的检查了标志项目活跃的要求。即使是一个活跃的项目，然后还是有可能你的贡献得不到回应。
如果你在一周之内都没有得到回应，你可以有礼貌的找别人帮你审查。如果你知道帮你审查贡献的合适人选的名字，你可以他们。
不要私戳那个人；要时刻记住公开交流对开源项目来说是必要的。
如果这样还没人理你，那么就可能不会有人理你了，永远。这让人感到不爽，但是别因为这打击到你。每个人都可能会遇到这种情况！你没得到回复的原因有很多，包括你不能控制的私人原因。尝试着找另外一个项目做贡献。总之，在社区其他人还没参与和相应进来的时候你就不要话太多的事情在某个问题上面。
有人想改动你的
被要求改动你的贡献是很常见的，要么是对你的想法，要么是对你的代码。
当有人想改动你的的时候，务必回复！因为他们花时间审查了你的代码。你开个就跑路是不好的！如果你不知道怎么改，好好研究一下问题所在，如果需要的话可以寻求帮助
如果你没时间再搞某个  了举个例子，如果对话已经过去数月了，而且你的情况也有所改变，让维护者知道从而他们就不会等着你的反馈了。可能另外某个人会开心的接手你的工作。
你的贡献被拒绝了
到最后你的贡献不一定会被接受。如果你也没在这上面花太多功夫那是最好，如果你不确定为什么没有接受，你有完美的理由去询问维护者给你反馈和解释。不要争吵或者怀恨在心。如果你不认同它的看法你大可  一份搞自己的版本。
你的贡献被接受了！
万岁！你已经完成了一个开源贡献！
你做到了！
不管你是已经完成了你的第一个开源贡献还是在寻找贡献的新途径，我们都希望你可以立即行动起来。即使你的贡献可能不会被接受，但是不要忘记当维护者花时间帮助你的时候要说声谢谢。开源世界就是由无数像你这样的人创造的：一个  ， ，评论和每一次的庆祝。作者：李光，现任职于腾讯社交网络运营部织云产品团队，负责织云监控告警平台规划与运维新产品开发工作，具有多年业务运维、运营规划经验。

前言
金融行业的业务对于大多数运维同学来说，可能是即熟悉又陌生，熟悉的是在我们每天的生活中都要应用它们的服务，例如 日常购物支付、理财与投资等等，陌生的是金融行业的业务运维管理方式与业务运维平台的侧重性，特别是现在如火如荼的在金融行业如何演进落地等。
金融行业是国家命脉行业，受限于银监会、证监会等监管机构的安全合规的要求与商业竞争的考虑，一般不会把核心业务搬上公有云，而更偏向自行搭建或者采用第三方厂商的成熟方案 例如腾讯金融云，因此在将来很长的一段时间内，银行与券商等机构还是主要采用私有云与混合云的管理方案。
织云  是腾讯的一站式企业级运维管理平台，本文优先讨论的是织云如何帮助现有金融云客户银行与券商管理私有云层资源，对于织云如何管理上层业务、中间件、云组件等因篇幅关系暂不涉及，后续会逐步展开讨论。

、、这三个概念想必大家是耳熟能详了，其实就是云计算的三个分层，基础设施即服务，平台即服务，软件即服务。
层其实就是一些显性可见的资源，如 服务器物理或者虚拟、网络设备与存储设备等。层也是最基础的就类似于建筑的地基与水电等基础设施，上层的服务都是依赖于层，假定层管理不好，那么与的高效与可控管理其实也是非常难了，甚至可以说空谈了。
层的不稳定会直接导致企业对外的服务质量大打折扣。我自己在负责手机业务的时候，名下有多的机器，如果没有一套高效与可度量的管理平台，光凭人肉去管理多的机器，那基本和噩梦差不多了。
这里出一个问题，现在形态多样的金融云、医疗云、政务云、游戏云与各个银行与券商搭建的私有云，这里有什么共同点与不同点呢？先抛砖引玉的给出答案。
共同点：
对于形态各异的云来说，层的资源组成都是基本相同的，基本就是、服务器、网络设备、网络专线与存储设备等显性资源组成的。
不同点：

不同行业的云所承载的的业务形态、权限、架构、逻辑与管理流程等等差异。
在公有云环境中，用户所能接触到的虚拟资源、云主机、云数据库等，公有云都会提供配套的自动化管理系统与监控系统。从控制权这个维度来说，公有云的用户对资源控制力度相对私有云较弱，因为都依赖于云服务商所提供的能力，而且很多资源管控能力是不会对用户开放的。
而在私有云环境中，所有的基础架构设施均有用户自行管理，同样在对资源控制权这个维度来说用户对于资源控制力度较强，对资源的管控力度完全由用户的需要而定了。

织云层管理模型
综上所述层也是由各个资源组合而成，每个独立的资源，我们都可以看成是一个对象，那么管理也就是对这些不同的对象所展开的。那么针对这些不同的对象，织云是如何抽象出通用的层的对象管理模型呢？

对象类别管理：某台服务器、某台网络设备与网络专线，每个对象都有自己的固有描述信息，例如服务器，型号、厂商、、内存等等
对象数量管理动态变化：成套基础设施用了多少服务器？多少网络设备自发现与静态录入等
对象关系关联的管理：例如某台服务器关联哪个机架、那台交换机、那个集群、哪个负责人等，一般来说关联是可递进的。
对象动作的管理：例如服务器就是重启、部署、上架、迁移等。
对象状态的管理：待运营、运营中、故障中、待下线与待加电等
对象的分析质量、性能、容量：例如某台服务的当前资源使用率、网络设备某个端口的流量、网络专线的丢包率等一系列具化的指标。
对象的监控与告警：例如服务器了、网络设备的运行异常了等要能监控到视图展示并且及时的告警出来。基于对这些维度的管理，我们也基本可以勾勒出，管理层需要那些功能模块的支持，下面将会依次为大家介绍。
对于现网环境中众多的管理对象，织云的理念是先配置在操作，反之就无法行之有效的的去管理与度量。在云时代，不仅仅是单一的资产管理也不只是管理层，而应该是一个数据可维护、动态流转、供外围关联系统所使用的”数据中心”这里的数据动态流转是双向的，且本身具有数据生产与消费的双重属性。如上文所述对象的多个维度都可以纳入到中来管理，如对象的类别、数量、关系、状态等

在现在的织云中，纳管了多种层资源，例如服务器、网络设备、网络专线等对象，并且通过与监控平台实时联动也保障了每个对象的服务质量的可控与可度量。下面两张是客户环境示例图服务器与网络设备，我们通过将客户的层资源统一纳管，同样每个不同的对象都具有自己的属性与动作。

将的层资源纳管到只是开始，后续还需要对每个对象有完善的监控、告警、数据分析等，这样才能对于每个纳管对象做到精细化运营，织云的理念是先纳管在监控。监控监控与告警是每个运维小伙伴每天都会用到的平台能力，这里先抛出一个问题，对于一个好的监控体系要做到那几点？

全：监控对象的广度，监控点的覆盖率
快：监控的性能，数据流的处理能力
准：智能分析与收敛、监控对象收拢

在对于层资源的监控上，织云的监控体系会覆盖到客户层资源的全对象，例如服务器、网络设备、专线、网络出口与云组件等等。对于每个监控对象来说，从数据的维度看我们要监控到对象的状态数据、负载性能数据、服务质量数据这三个维度。
  
用网络设备举例来说，我们现在一个证券行业的客户网络设备有台左右交换机、防火墙与路由器，对于每台网络设备来说，织云的监控的粒度是细化到：

网络设备的物理端口的监控与告警
网络设备的逻辑端口物理端口的逻辑组合的监控与告警
网络设备的设备运行日志的监控与告警

对于这部分，因为各个厂商的日志并没有统一标准，织云在这里是会允许用户根据自己的设备厂商设定待匹配的关键字来监控与告警。下图为客户的某台交换机的部分指标展示
 
网络流量分析
对于私有云层运维同学来说，除了常态的单个设备的监控数据，也会需要的是对于网络专线、网络出口等资源的流量分析，相信运维小伙伴们多多少少都会遇到以下的场景：

这条专线当前利用率多少？
在已经使用的流量中，具体是那个业务或者那个使用了多少带宽资源？
这些所消耗的带宽是基于什么协议与方向？ 
专线的丢包率与时延是怎么样的？

等等高频使用场景。织云基于厂商的协议可以捕获到网络内的相关会话信息端口维度，并对于每个会话进行量化的分析与展示。为什么在这里说是呢？是因为各个主流厂商例如与的协议就不相同，织云目前可以支持主流厂商的不同协议。

总结
为了更好的运维管理我们设计了这套平台，平台里面非常重要的一个设计理念点：“简”，化繁为简。做运维平台产品要简单，解决这么复杂的用户环境、场景的情况下，其实“简”是非常重要的。我们根据多年海量业务与等的实践经验，减少运维管理对象、标准化运维模型与简化运维操作。
 

 欢迎关注【腾讯织云】公众号，了解最新技术资讯。说到的内容替换功能，大部分人应该都听说过内置的的_替换模块，但是这个模块有个缺憾，就是只能替换一次，而且还不支持正则表达式，这就有些鸡肋了。
不过，我们可以集成一个第三方的替换模块：____，来实现我们的各种需求。
经过测试，这个模块至少有如下实用功能：

支持多次替换

支持正则替换

支持中文替换


：略有遗憾的是，这个替换不能使用到  判断模块内，否则就超神了。。。
下面，简单介绍下 ____ 的安装实用以及一些实用案例。
一、编译集成
和所有非内置模块一样，添加模块需要在编译的时候指定模块源码包来集成。当然，可以使用动态模块加载的功能，这里就不细说了。
①、下载模块源码包并解压，最后列出目录位置备用
    ____ ____
   ____
   ____ 
____
手动下载地址：____
②、在服务器上执行   查看当前   编译参数，比如：
    
   
         
   
  = __ __ ___ __ =__ __
③、加上模块参数，重新编译
找到服务器上原来安装时留下的  源码目录如果没有请重新下载并解压，此处不赘述，进入目录后，在第②步中的参数基础上新增集成替换模块请注意前面需要加上   ： 原有参数 =____例如：
 = __ __ ___ __ =__ __ =____
再往后，则是以及平滑升级，请参考之前的文章完成：
在线服务状态下平滑升级或新增模块的详细操作记录
正确完成后，就具备内容替换功能了。
二、使用说明
模块的主页其实已经有了很详细的说明了，这里就简单的做下搬运工。
使用示例：
  {
    __    
    _ \  
    _  
    _  
}
从给出的使用示例来看，这个模块涉及个指令：
 __
__ 语法： __  
默认： __ 
适用： ， ， 
__ 是用来指定替换文件类型的 默认仅仅替换类型的文件。

 _
_ 语法： _ _ _ 
默认： 
适用： ，，
_ 是用来替换文本的，可以使用正则
默认：替换匹配项。
  ：区分大小写的匹配
  只匹配发现的第一个。
   正则匹配。
三、案例分享
①、全站
有了这个功能，要实现全站也就是非常简单了，只要把本站的协议代码全部替换成即可。当然，替换时要注意匹配范围，免得把不支持的外链也一起替换了。。。比如，将如下代码添加到网站配置内即可完成替换
  {  新增如下代码
    _    将页面中的链接全部替换为
②、域名替换
这个模块在方面同样简单实用！比如，我们网站要用到七牛，不管是纯代码还是插件，那都是靠代码来进行替换的，性能肯定就不如直接替换来的简单粗暴了。
  {  新增如下代码将静态文件域名替换成七牛
    _ \\|||||  
：经测试，在使用正则模式时，不能使用内置变量，比如：，否则会出现如下报错：           
③、解决前台暴露管理员账号风险
前段时间，看到有博客在说  会在前台暴露管理员登陆账户的问题，然后给出了较为复杂的解决办法：通过修改  内核函数来隐藏账户名。
修改内核函数，一般是非常无奈，没有其他解决方法的时候才会用到，所以，我看到这个问题第一件时间想到的办法就是替换。
使用替换是非常简单的，参考博客之前分享的文章即可搞定：
简单代码开启七牛及集成七牛缩略图的方法
而对于本文来说，替换方案依然过于复杂，因为本文一行规则即可解决问题，比如将登录名替换为：
  {
     替换管理员登录名  为 
    _   
其他登录名，请自行参考，若有多个登录名可以另起多行或使用正则表达式均可。鉴于篇幅有限，就分享这三个实用技巧吧，其他就靠自己发掘了，比如镜像网站做内容替换什么的规则：一般情况可以选择存储引擎，如果需要事务支持必须使用存储引擎。
注意：存储引擎 索引有一个很大的限制：参与一个索引的所有字段的长度之和不能超过字节。另外数据和索引是分开，而的数据存储是按聚簇索引有序排列的，主键是默认的聚簇索引，因此虽然在一般情况下，查询性能比高，但的以主键为条件的查询性能是非常高的。
规则：命名规则。

数据库和表名应尽可能和所服务的业务模块名一致

服务与同一个子模块的一类表应尽量以子模块名或部分单词为前缀或后缀

表名应尽量包含与所存放数据对应的单词

字段名称也应尽量保持和实际数据相对应

联合索引名称应尽量包含所有索引键字段名或缩写，且各字段名在索引名中的顺序应与索引键在索引中的索引顺序一致，并尽量包含一个类似的前缀或后缀，以表明期对象类型是索引。

约束等其他对象也应该尽可能包含所属表或其他对象的名称，以表明各自的关系


规则：数据库字段类型定义

经常需要计算和排序等消耗的字段应该尽量选择更为迅速的字段，如用个字节，最小值 代替个字节，最小值 通过整型替代浮点型和字符型

变长字段使用，不要使用

对于二进制多媒体数据，流水队列数据如日志，超大文本数据不要放在数据库字段中


规则：业务逻辑执行过程必须读到的表中必须要有初始的值。避免业务读出为负或无穷大的值导致程序失败
规则：并不需要一定遵守范式理论，适度的冗余，让尽量减少
规则：访问频率较低的大字段拆分出数据表。有些大字段占用空间多，访问频率较其他字段明显要少很多，这种情况进行拆分，频繁的查询中就不需要读取大字段，造成资源的浪费。
规则：大表可以考虑水平拆分。大表影响查询效率，根据业务特性有很多拆分方式，像根据时间递增的数据，可以根据时间来分。以划分的数据，可根据数据库个数的方式来拆分。
一数据库索引
规则：业务需要的相关索引是根据实际的设计所构造语句的条件来确定的，业务不需要的不要建索引，不允许在联合索引或主键中存在多于的字段。特别是该字段根本不会在条件语句中出现。
规则：唯一确定一条记录的一个字段或多个字段要建立主键或者唯一索引，不能唯一确定一条记录，为了提高查询效率建普通索引
规则：业务使用的表，有些记录数很少，甚至只有一条记录，为了约束的需要，也要建立索引或者设置主键。
规则：对于取值不能重复，经常作为查询条件的字段，应该建唯一索引主键默认唯一索引，并且将查询条件中该字段的条件置于第一个位置。没有必要再建立与该字段有关的联合索引。
规则：对于经常查询的字段，其值不唯一，也应该考虑建立普通索引，查询语句中该字段条件置于第一个位置，对联合索引处理的方法同样。
规则：业务通过不唯一索引访问数据时，需要考虑通过该索引值返回的记录稠密度，原则上可能的稠密度最大不能高于，如果稠密度太大，则不合适建立索引了。
当通过这个索引查找得到的数据量占到表内所有数据的以上时，则需要考虑建立该索引的代价，同时由于索引扫描产生的都是随机，生其效率比全表顺序扫描的顺序低很多。数据库系统优化的时候有可能不会用到这个索引。
规则：需要联合索引或联合主键的数据库要注意索引的顺序。语句中的匹配条件也要跟索引的顺序保持一致。
注意：索引的顺势不正确也可能导致严重的后果。
规则：表中的多个字段查询作为查询条件，不含有其他索引，并且字段联合值不重复，可以在这多个字段上建唯一的联合索引，假设索引字段为 则查询条件      =可以用到索引，查询条件中字段的位置与索引中的字段位置是一致的。
规则：联合索引的建立原则以下均假设在数据库表的字段上建立联合索引

联合索引中的字段应尽量满足过滤数据从多到少的顺序，也就是说差异最大的字段应该房子第一个字段

建立索引尽量与语句的条件顺序一致，使语句尽量以整个索引为条件，尽量避免以索引的一部分特别是首个条件与索引的首个字段不一致时作为查询的条件

 = =   =    =  =  =为条件可以用到此联合索引；而这些语句 = = =  =则无法用到这个联合索引。

当需要查询的数据库字段全部在索引中体现时，数据库可以直接查询索引得到查询信息无须对整个表进行扫描这就是所谓的，能大大的提高查询效率。当，，与其他表字段关联查询时可以用到索引

当，，顺序而不是，，，为顺序执行 或者不要时可以用到索引

以下情况时，进行表扫描然后排序可能比使用联合索引更加有效  表已经按照索引组织好了  被查询的数据站所有数据的很多比例。


规则：重要业务访问数据表时。但不能通过索引访问数据时，应该确保顺序访问的记录数目是有限的，原则上不得多于
二语句与应用系统优化
规则：合理构造语句

语句中，根据测试，批量一次插入条时效率最高，多于条时，要拆分，多次进行同样的插入，应该合并批量进行。注意语句的长度要小于的参数 __

查询条件中各种逻辑操作符性能顺序是因此在查询条件中应该尽量避免使用在大集合中使用

永远用小结果集驱动大记录集，因为在中，只有 一种方式，就是说的是通过嵌套循环来实现的。通过小结果集驱动大记录集这个原则来减少嵌套循环的循环次数，以减少总量及运算次数

尽量优化 内层循环。

只取需要的，尽量不要使用  

仅仅使用最有效的过滤字段， 字句中的过滤条件少为好

尽量避免复杂的和子查询
在并发这块做得并不是太好，当并发量太高的时候，整体性能会急剧下降，这主要与内部资源的争用锁定控制有关，用表锁，好一些用行锁。


规则：应用系统的优化

合理使用，对于变化较少的部分活跃数据通过应用层的缓存到内存中，对性能的提升是成数量级的。

对重复执行相同的进行合并，减少次数。

事务相关性最小原则



相关推荐 云数据库 云数据库使用入门导语 对的基础原理研究，并在的库中进行选型对比，选出最适合我们的库。本文分为两章，第一张对基础原理进行研究，第二章将从库中选出最适合的库。

第一章：研究

连接本质上是连接，在网页打开后通过协议握手之后建立长连接。真正实现了的实时通信，使模式具备了模式的实时通信能力
的生命周期

分为三个阶段：
第一阶段：由客户端发起的握手阶段，握手后建立连接第二阶段：数据交换，客户端与服务端可以互相主动发送消息第三阶段：关闭连接，可以由任意一端发起关闭的命令
的握手协议
握手请求
  
 
 
 
 
 
 
 
           
    
 ==
 ==
  ___

   必须是，协议应不小于
，并且其值为 
，并且其值为
，其值采用编码的随机字节长的字符序列
，服务器可以从决定是否接受该连接
，当前值必须是握手响应


   
 
 
 =
 

首行返回的是协议版本和状态码，表示变换协议 
，其值为 
，其值为
，加密处理后的握手消息体组成


的消息并非没有额外信息，除了业务数据以外，消息体也包含一些额外信息。只不过相对的头会小很多，一般只有个

： 指示这个是消息的最后片段。第一个片段可能也是最后的片段。
   每个 必须是，除非一个扩展协商为非零值定义含义。如果收到一个非零值且没有协商的扩展定义这个非零值的含义，接收端点必须失败连接。
  定义了“负载数据”的解释。如果收到一个未知的操作码，接收端点必须失败连接。定义了以下值。 代表一个继续帧 代表一个文本帧 代表一个二进制帧 保留用于未来的非控制帧 代表连接关闭 代表 代表 保留用于未来的控制帧
  定义是否“负载数据”是掩码的。如果设置为，一个掩码键出现在，且这个是用于根据节解掩码“负载数据”。从客户端发送到服务器的所有帧有这个位设置为。
      或者  “负载数据”的长度，以字节为单位：如果，这是负载长度。如果，之后的两字节解释为一个位的无符号整数是负载长度。如果，之后的字节解释为一个位的无符号整数最高有效位必须是是负载长度。多字节长度数量以网络字节顺序来表示。注意，在所有情况下，最小数量的字节必须用于编码长度，例如，一个字节长的字符串的长度不能被编码为序列，，。负载长度是“扩展数据”长度“应用数据”长度。“扩展数据”长度可能是零，在这种情况下，负载长度是“应用数据”长度。
    客户端发送到服务器的所有帧通过一个包含在帧中的位值来掩码。如果位设置为，则该字段存在，如果位设置为，则该字段缺失。详细信息请参见节 客户端到服务器掩码。
   “负载数据”定义为“扩展数据”连接“应用数据”。
   “扩展数据”是字节除非已经协商了一个扩展。任何扩展必须指定“扩展数据”的长度，或长度是如何计算的，以及扩展如何使用必须在打开阶段握手期间协商。 如果存在，“扩展数据”包含在总负载长度中。
   任意的“应用数据”，占用“扩展数据”之后帧的剩余部分。“应用数据”的长度等于负载长度减去“扩展数据”长度。

                = 业务数据以外的消息大小               = 
与对比
以发送字符串 {“”””} 为例，字符串本身 通过发送的话，消息总大小 通过发送的话，消息总大小是 
第二章： 的模块选型
由于工作原因，主要用进行开发，因此只对比实现的库上面，用实现的库非常多，我挑选了几个靠前的库进行对比

 
 
 
本地环境   


在本地环境，对比与发送消息的耗时。可以看到的耗时远远低于

本地环境 不同消息大小的耗时对比库对比
在本地环境，处理不同消息大小的耗时对比。测试结果：       

因为本地环境与生产环境并不一样，因此上面的数据仅作环境参考。因为下面在生产环境进行对比后，数据会有较大差异
以下生产环境测试，都是在内存、个环境下进行的测试对比
生产环境 不同消息大小的耗时对比库对比
这个测试与上一个测试是一样的，但结果完全不同。表现最好测试结果：       

生产环境 测试内存波动
使用同样大小的消息，对服务发起大量的请求。测试服务的内存消耗。 表现都不错，比较稳定。表现最差，占用内存高。测试结果：      

生产环境 测试波动
使用同样大小的消息，对服务发起大量的请求。测试服务的占用情况。表现最差，占比很高。测试结果： =     

生产环境 测试最大连接数
在内存的服务器上，测试各个库的最大连接数。最好的结果也是差异巨大。最好的是最差的的近三倍测试结果：      

 在连接数超过的时候，连接速度比较慢。服务器没响应，但之前的连接不会断开而和在到极限的时候，会出现异常。所有连接会断开 连接在左右 的时候，就非常慢了
生产环境 测试最大连接数时的内存与波动
测试最大连接数的时候，同时监控了内存和的波动。
内存
在内存方面，的增长最为平缓，而早早的攀升到了极限最后挂掉了测试结果：      


在方面，同样保持稳定，占用比也非常低。测试结果：      

总结
按第一得分，第二得分，第三得分，第四得分计算各个库的得分情况



库
得分





















表现最好简单易用，连接数最大，内存和控制的稳定。缺点是在到达最大连接数极限之后，会断开所有连接作者 ： 周翔

背景
今天，一则热门新闻炸开了锅：  系统近日居然自己写了一串机器学习代码，其效率竟然超过了专业的研发工程师。这让我们人类的优越感何存？你们这些机器人学生啊，学习能力不要太强哦
人工智能可谓是目前最热门的行业，与此同时，相关人才的身价也跟着水涨船高。根据拉勾网的数据， 年，人工智能招聘领域， 人以上大公司平均薪酬 。
而领英的数据则显示，截至  年一季度，基于领英平台的全球领域技术人才数量已经超过  万，排名全球第一的美国相关人才总数超  万，相较而言，位列第七的中国只有  万人左右，缺口巨大。
在高需求和高薪资的双重刺激下，不管是学生物的，还是学材料的，想要转战  的人越来越多，这也从侧面验证了为什么吴恩达等  大牛每次推出新的在线课程都能引发一轮“集体高潮”。
不过，想要转行的同学要抓紧了， 既然可以速记员，取代翻译，未来有没有可能取代程序员呢？ 
 个月前，谷歌开发出的  自主设计的深度学习模型已经比创造它的工程师还要好了，如今这个  系统又更进一步，在某些复杂任务上的表现也超越了人类工程师。
对此，你怎么看？
前言
在人工智能的浪潮下，深度学习模型已经广泛应用于语音识别、机器翻译、图像识别等诸多领域，并取得了非常不错的成果。但是深度学习模型的设计却是一个艰辛且繁复的过程，因为所有可能组合模型背后的搜索空间非常庞大，比如一个典型的  层神经网络就有种神经网络组合，为了应对这样庞大的数量级，神经网络的设计不仅耗时，而且需要机器学习专家积累大量的先验知识。

图： 架构，从最初的卷积架构开始，这种神经网络的设计需要进行多年的细心试验和调试。
在人工智能顶级人才匮乏的情况下，为了让机器学习模型的设计过程更加简单，提升研发效率，谷歌于今年  月推出了“”，顾名思义， 实际上就是一种让模型设计过程自动化的机器学习软件，该系统会进行数千次模拟来确定代码的哪些方面可以作出改进，并在改变后继续该过程，直到达成目标。
为了测试 ，谷歌将其自行设计的模型用在了专注图像识别的  与语言建模的   两大数据集上。实验证明， 设计的模型的性能表现与目前机器学习专家所设计的先进模型不相上下。令人尴尬的是，有些模型甚至还是  团队的成员设计的，也就是说， 在某种程度上超越了自己的缔造者。
 个月过后， 又往前迈进了一部。据外媒  报导，在某个图像识别任务中， 设计的模型实现了创纪录的  的准确率。即使在一些复杂的人工智能任务中，其自创建的代码也比人类程序员更好，比如，在为图像标记多个对象的位置这一任务中，它的准确率达到了 ；作为对比，人类打造的软件只有  。
 的进展超出了很多人的预期，那么为何机器在设计深度学习模型这一任务上表现的如此出色？先让我们来了解下  的工作原理。
 是如何设计模型的？
作为  领域的领头羊，谷歌其实暗地里做了不少尝试，包括进化算法 和强化学习算法  等，并且都展现了不错的前景，而  则是谷歌大脑团队利用强化学习取得的成果。
在  架构中，有一个名为“ 控制器”的 循环神经网络，它可以设计出一种被称为“”的模型架构子模型，而这个“子模型”在训练后可以通过特定任务来进行质量评估。随后，反馈的结果返回到控制器中，以此来帮助提升下一次循环中的训练设定。如下图所示：

生成新的架构、测试、把反馈传送给控制器以吸取经验——这一过程将重复几千次，最终，控制器会倾向于设计那些在数据集上取得更好的准确性的架构。
工程师古筱凡表示， 的运作过程实际上可以分成以下两部分：

元学习的热启动：在机器学习框架中寻找效果好的算法；计算不同数据集之间的相似度，相似的数据可以采取类似的超参数。
超参数优化，算法包括： 算法；基于随机森林；。输入不同的超参数为，以损失函数为准确率，调优器会在随机选择一些值的基础上，利用贪心算法去寻优。

下图的两个模型是基于   数据集设计的预测模型，其中左边是人类专家设计的，右边则是  设计的。

谷歌团队表示，机器自行选择架构的过程其实和人类设计模型架构的过程是有共通之处的，比如两者都采用了合并输入，并借鉴了前向的隐藏层。不过， 也有一些值得一提的亮点，比如机器选择的架构包含了乘法组合  ，比如上图中  设计的模型的最左边的“_”。对  而言，出现这种组合的情况并不常见，可能是因为研究人员并没有发现这种组合有什么明显优势。但是有意思的地方在于，近来正好有人提议过这种方法，并认为乘法组合能够有效缓解梯度消失爆炸的问题。这意味着，机器选择的架构对探索新的神经网络架构有很大的帮助。
此外，这种方法或许还能教会人类：为何某些特定类型神经网络的效果更好？比如上图右边的架构有非常多的 ，因此梯度可以向后传递，这也解释了为何   的表现比标准  的性能更好。
 开源地址是 ，感兴趣的读者可以自己动手尝试一下。
 会取代  工程师吗？
 能在短时内取得显著进步，证明了用机器设计模型这个方向是有前途的，但是  的终极目的是为了取代  工程师吗？
现如今， 专家必须通过本能和试错来不断调试神经网络的内部架构。加州大学伯克利分校研究员   表示 ：“工程师的很大一部分工作本质上非常无聊，需要尝试各种配置来看哪些神经网络效果更好。” 认为，因为要解决的问题越来越难，神经网络也越来越深，未来设计一个深度学习模型的将会是一个艰巨的挑战。
而从理论上来讲， 未来设计一个深度神经网络所耗费的时间，与人类专家相比几乎可以忽略不计，而且这个由机器设计的模型的效果也会更好，显然  将大有可为。

但是，这并不意味着  会将人类从  系统的开发过程中剔除出去。
实际上， 的主要目的会降低机器学习的门槛，促进  的民主化。要知道，即便实力雄厚如谷歌，也不敢说自己已经拥有足够的  人才，因此降低门槛，提高效率，对  行业的发展至关重要。
谷歌首席执行官   在上周的发布会上表示：“如今，这些 系统都是机器学习专家亲手搭建的，而全世界只有几千名科学家能够做到这一点。我们希望让成千上万的开发者也能够做到这一点。” 
因此，虽然  可能没有继承谷歌顶尖工程师的理论基础和数学才华，但是它却可以帮助  工程师节省时间，或者启发他们，为他们提供灵感。 
古筱凡也认为， 是真正的机器学习，它把经验性的工作自动化，现在的机器学习只是半成品。 能极大地降低未来机器学习的门槛，将是普通人使用机器学习的利器。
据悉， 团队将会对机器所设计的架构进行深入的分析和测试，帮助  工程师重新审视自身对这些架构的理解。如果谷歌成功，这意味着  将有可能引发新的神经网络类型的诞生，也能让一些非专业研究人员根据自己的需要创造神经网络，造福全人类。
 可能不会取代  工程师，但是机器都这么努力了，你还有什么借口偷懒！

就在这篇文章的留言区，营长找到了好几条评论称：“作为工程师的我，感到了深深的压力。机器学习能力照着么发展下去，没准饭碗儿就真丢了”
参考资料：






文章来源于  科技大本营微信公众号作者 | 程丽萍编辑 | 顾乡

搜狗是搜狐公司的旗下子公司，现搜狗成为仅次于百度的第二大中文搜索引擎。在搜索业务的同时，也推出搜狗输入法、搜狗高速浏览器，在行业中占据重要位置。
客户挑战
 原服务提供商提供加速时延较高，命中率较低，且长期无法提升相关指数，影响现网业务体验及未来业务拓展。
腾讯解决方案
、定制化优化方案：如提供接口控制实现对图片等不同文件类型进行刷新并与现有运维机制进行整合；针对等特殊功能进行快速适配优化开发。定制中间源策略减少源站压力及提升响应速度；配合客户预制文件实施监控方案，实时监控业务加速情况；制定预拉热服务，保障业务的平滑过渡。
、专业完善的支撑团队：从客户、业务、时间、技术等多重纬度指定割接计划，保障业务的平稳运行。提供小时不间断专业服务，包含企业服务、工单系统服务及值班电话服务等多种服务渠道。
为客户带来收益
   、依托于腾讯全球节点优势以及多家运营商线路、机房支持，全量切换后，平均时延下降，客户业务体验效果有明显提升。

图：月日期时切换后，时延明显下降
、命中率，资源可用性

图：月日切换前后，域名带宽使用情况

图：月日切换前后，域名命中情况
、平稳完成切换，源站流量稳定导语： 总所周知，机器学习中特征工程处于十分重要的位置，整个学习中至少会花二分之一甚至更多的时间用于特征工程至少对于统计学习。但是如何能够有效地实现特征的自动化扩展、组合和量化，大家都会有各自的方法，但也是相对较繁杂且可控性不太好的方法。本文将结合我在特征自动化实现中的一些发现与大家分享，希望能够对大家的工作有所帮助。

一、背景：
机器学习是通过机器来处理大量的、有效的数据来获得我们所需的信息，因此学习其本质就是处理海量数据并训练模型、寻找规则的过程。由著名的“天下没有免费的午餐”等可知，机器学习中特征工程的作用是不言而喻的。然而除了对特征关联性的求解外，特征的量化和变换也是十分重要的。这就类似于侦探在分析案件时能够很好地通过现有的信息找到关键线索，并且将这些线索转成有利的破案证据，以及将这些线索进行组合和处理找到新的线索。然而在做特征量化和特征扩展的过程中，通常会遇到如下三个问题：
、特征简单量化后无意义、不可解释：如数据中存在城市这样的特征且假设有个城市，简单处理就是将每个城市映射成一个阿拉伯数字如下左图。
   
学习结果中可能会出现上右图的效果，不禁发问这样的划分是啥意思呢？南方、北方，还是西方、东方呢？还是说这样的特征可解释性差就不用了呢？
、特征扩展和组合可控性不好：对于离散特征不愿将其丢掉，而是想通过特征值打平扩展的形式使用，如上述中城市的特征，可以扩成是否是深圳、是否是上海，，是否是南京这样个特征，这样就能够将这样城市的特征考虑进去。还有当如果存在有特征组合的需求时，如想了解人们购物的习惯，那么就可能将性别和省市组合起来成为一个新的特征。想了解消费者购房的情况，那么可能将年龄和收入组合成一个新的特征等。
特征的扩展和组合在学习中很有用，大家通常使用不可控、全量展开的独热编码。但当出现有很多长尾的特征值的时候，就会展开或组合成很多没有意义的特征，这样会大大消耗我们的计算资源和降低我们的执行效率。如用户城市这样的特征，可能聚集的也就是个以内大多为国内，但是业务是全球的所以还有几千个城市的量都是个位这样很小的。如果这样需要扩展和组合的特征不可控那么效果是很差的。
如下图所示左边的图是量相对大的特征值，也是我们想要处理的特征值，而右图则是长尾的特征值，其量很少以至于我们认为这样的特征值在训练中是不会有影响的。 
、当离散特征是类似衣服大小码、、等数据时，我们希望能够使用上这样的可比较大小的特征，但是这样的数据中也会存在有一部分数据量较大可单独存在，而有一部分数据量很好我们希望设定这样的数据为其他。如下图所示，特征值中可能就和占量交大我们希望单独成为一个节点，而剩余的量很少的特征值可能有个、个我们之希望他们为“其他”。

二、当前通用方式：
现在大家在遇到离散特征时的处理方式主要有有种我所了解和资料显示的。第一种就是在做前期数据分析的时候，将想要扩展和组合的数据提前处理好，在做数据处理的时候就把这样的数据给处理成特征数据。但是是人工处理，而且基本是写死成数据的，后期模型训练中不易调整。第二种是使用类似独热编码的方案，将特征值全量打开实现特征的自动化扩展。但是数据是全量打开，以至过程和结果是不可控的，且可能存在无意义特征的爆炸导致不可计算或者计算效率低等。
这里讲到了独热编码，简单的介绍以下：
独热编码即  编码，又称一位有效编码，其方法是使用位状态寄存器来对个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候，其中只有一位有效。例如：
自然状态码为：
独热编码为：
可以这样理解，对于每一个特征，如果它有个可能值，那么经过独热编码后，就变成了个二元特征。并且，这些特征互斥，每次只有一个激活。因此，数据会变成稀疏的。
   

 = 

           

  
输出结果：

                 
其实中的_也可以实现独热编码的效果：
_ = _‘_’

 =   _
三、本文方法
本文的方法主要是通过将要处理的离散特征的特征值情况进行展现，然后基于其实际情况进行有选择可控制的特征自动化扩展和组合。通过使用这样的方法可以很好地解决背景中存在的问题，并且可以独立成为特征模块应用于不同的学习过程。本方法的大前提是类似的原则，海量数据学习过程中，有效的影响因素一定是相对量较大的，如果量很少则认为其为可不考虑因素。如有一个万的训练集或者更多，其中有几个量较大的值且之和为总和的以上。剩下的还有许多特征值每个不到的量，之和也是总和的很小一部分。那么我们就可以认为我们不需要展开、组合这些量很小的特征值，或者可以将这部分特征值定位“其他”。
方法如下：
、产生离散特征值的量的情况：通过循环多个离散特征，使用中的_函数如‘_’_，或者中的等。将各个离散特征值的量以倒叙的形式存放在数据结构中，或者保存到项目本地的文件中。
、处理排序后的特征值：该步骤十分关键，控制了参与扩展和组合的特征值，以及特征值展示效果确定哪些是“其他”，或者分等级等。实现方式有：
 通过打开文件或者展示数据结构中的数据情况，手动的进行删除或合并操作；
 设置比例阀值，如设置=，那么可以自动实现对小于总量的特征值进行自动删除或合并操作；
 设置个数阀值，如设置=，那么就可以自动地选择量排在前的特征值进行扩展或组合操作；
 当然也可以通过不删除或合并任何特征值，实现类似的独热编码全量的效果。
、基于选择、处理后的特征值扩展特征：遍历所有的处理过的离散特征，每一个特征逐个顺序取每个特征值作为一个新特征_ ，并且这样的特征是特征值的  的情况也就是等于该特征值为，否则为。如实现如下：
   
     =     
     
         = 
           
             = 
            _ =      ==   
、基于选择、处理后的特征值组合特征：很多时候我们希望一些特征之间能够通过组合产生新的特征，这些组合特征有时会表现出非常好的效果。如性别和省市组合，我们可以研究不同省市男、女购物的偏爱等。实现如下：
 _  
      _  
          = ____

_
     =  ___


、特征量化：原有离散特征或产生的新特征，都可能是以字符串或中文等形式存在的值，需要对这样的特征进行量化后才可进行训练。实现如下：
 = 

 _  
     _
 = 

_ =    ____  
 = _
、关键特征的规范化：训练结束后特征可能因为编码问题，或者需要以特定的形式展示，所以需要对结果特征或关键特征做规范化处理。这时可以通过不同的算法模型的特性获取其结果特征，并通过预设值或者修改的方式进行规范化。
特征工程对于机器学习来说是十分重要的，上述的一些方法是我在做机器学习过程中的一点积累。可以针对具体的问题使用其中的一个或者多个方式，也可以是基于这些方式的进一步优化。当然，特征还应该做与结果指标关联性分析，这个就可以根据具体的数据选择相应的关联算法实现。最后，希望大家可以多花些时间在数据质量和特征工程上，必将为你带来令你满意的效果。做开发的同学都非常熟悉代理模式，为避免代码耦合，代理模式的委托者任务交给代理执行，代理执行完毕之后再把回调告诉委托者。委托者不关心代理是怎么执行任务的，只关心结果是成功还是失败。代理模式就像是杀手与雇主的关系一样。
但是代理模式也不完美，代理多了，雇主也管不过来了，委托在处，收结果却要在处。有的时候，雇主也希望能在同一个地方既可以发配任务，也可以接收结果。闭包就能帮雇主解决这个问题了。无论是系统的，还是平时随手封装一个  的实现，都让代码的可读性有了一定的提升。
无论是代理模式，还是闭包，在处理单一任务的时候，都出色的完成了任务。可是当两种模式要相互配合，一起完成一系列任务，并且每个任务之间还要共享信息，相互衔接，雇主就要头疼了。当然可以只用一种模式来实现，代理模式就不说了，过于分散，不善于处理这种流程性的事务。那我用闭包来举一个例子：我们需要顺序执行 、、 三个任务，、、依次执行，任务完成之后都使用闭包来回调并开始下一个任务。代码如下：
 
{
  ____  {
      {
          {
             {
                  
            }
         }
     }
 }
}
上面的代码看起来挺清晰，可读性也还可。如果加上一些  的分支判断，再加上一些参数的传递，代码不知不觉的向右延伸，最终超出了屏幕的宽度，形成一个倒金字塔的形状。写  的同学会说：你已经掉进了回调陷阱，赶紧用设计模式来跳坑吧。
 设计模式的原理
设计模式把每一个异步操作都封装成一个对象，这个对象就是这个异步操作执行完毕的结果，但是这个结果是可变的，就像薛定谔的猫，只有执行了才知道。通过这种方式，就能提前获取到结果，并处理下一步骤。
 使用  作为关键字，回调最终结果。  是整个设计模式的核心，必须要被实现。另外还有其它几个关键字用来表示一个对象的状态：

 任务执行中，状态可能会进入下面的或者二者之一
 任务完成了，返回结果
 任务失败，并返回错误

更多可以参考 官方规范  。

如上图所示，与的状态都是不可逆转的，保证了结果的唯一性。
除了  ，一些对  的实现还有几个关键字用来扩展，让代码可读性更强：

 任务失败，处理
 无论是遇到  还是  分支，最终都会执行的回调
 多个异步任务执行完毕之后才会回调

模式的实现
设计模式在  平台的最佳实践是由大名鼎鼎的的作者   写的一个支持 的异步编程框架 –    作者的另一个广为人知的趣事是因为没有写出反转二叉树而没有拿到的。
我们先抛出对上面改良函数使用的实现，再看原理
 
{
     {
          
    }{
          
    }{
          
    }
}
调试后，发现执行的结果与我们期待的一致，但是上面的代码对我来说有几个疑惑点：

 是怎么串起来的；
怎么实现的顺序调用；
如果传递参数，参数是怎么传递的。

带着问题，来看的源码：
   {
      {
         ___ 
    }
}
如果对不是很熟悉，可能不太理解这段代码，实际上，灵活的使用了作为函数的返回值来实现链式调用。相比原来的嵌套模式，使用将多个  串联起来，解决了 。
接着来继续看下一个问题。
  
           __     
{
    __  
    __  

    __ {
          = _
            

         = __    {

             =  

            __   = 

            ___ {
                  = _
                    

                __  
                 =      {
                     =  {
                            
                    }
                }
                _  {
                        
                }
            }

                 
        }
    }

        
}
代码有点长，不过也可以理解。这个方法是上面的调用的，接受两个参数，第一个参数是一个的，第二个参数是一个的。一个在执行完毕之后，无论状态是变成还是都通过这个方法，执行对应的 ，并返回一个对象。上面的函数中，有一个，是栅栏的意思，一般来说如果我们有多个异步任务，但是希望他们按照一定的顺序执行，就可以使用这个方法。在这里通过实现了的依次调用。在这个方法内部，一个是会去看当前是否已经有下一个要执行的，如果没有就生成一个新的，另一个把对应的 放到队列，依次执行。
参数传递
这里需要思考的另外一个问题是，既然多个任务之间有依次调用的关系，那么这样的一种任务流之间如何互相通信呢？用了一个比较有趣的办法来实现相邻对象的参数传递。
在万物皆消息的语言内部，每一个方法，包括在内都是有类型签名的。这个类型签名对象就是 

    {

   

     ___


那么对于，怎么获取类型签名呢自己定义了一个的结构体：
  {
      
     
     
       
     _ {
                 
                      __
         _          
         _                
                                 
    } 
}
熟悉的同学都知道，按照位保存了一些的附加信息，在 的这个可以找到是否有类型签名，剩下的就是通过移动指针，找到所在的内存空间了。找到了，也就获取到了参数个数与函数返回值这些信息。函数返回值的类型是经过编码的，具体的对照表可以参考官方文档 。
 ___    {
      = 
       = 
       = 
        =  
       ==   
                  
                  
}
有了函数签名，就能知道的信息了。上面只截取了部分代码，简单来说， 通过动态的获取的参数个数与返回类型来决定的调用。一般来说，  在调用的时候最多只支持传递一个参数，在必要的时候，把这些参数放在一个数组里面，这个数组就是  ，当检测到这个参数是一个数组的时候，就依次取出数组内的元素作为参数传递。
从而支持了多个参数的传递。
总结
至此 对的一些解释也就结束了，有的版本，也有支持了的版本。如果你非常享受这样的书写方式，可以接入很多扩展的版本，可以写出看起来优雅又舒服的代码，比如  
 {  

} {  
    …
}
还有很多的扩展与关键字的支持，这里都不再展开。
而对于我来说，设计模式能够解决我对散落在各处的代理模式产生的代码的烦恼，也让我避免了跳进回调陷阱，就值得总结了。

内容转载自腾讯课堂  学院 数据分析
大赛题目是转化率预估，这也是第一次接触这类赛题，所以遇到的问题比较多。首先是对数据的理解就花了不少心思，数据中有不少除不同外其他数据都相同的样本，刚开始也是像处理其他问题一样将这些样本看作是噪音，只保留了为正的样本，后来发现在线上测试集中同样存在一部分数据都相同的样本，这时训练出来的模型对这些样本的预测值都是相同的，所以对于这些样本就不能简单的当作噪音来处理了。目前我们针对这种情况的处理参考了之前大神分享的经验，通过添加一些特征来标记他们之间的先后顺序。还有关于不准确问题的处理，因为有些回流的时间超过天还有最后几天的回流可能还没有反馈回来，这些就会使得取值不准确。针对这种情况，我们通过统计所有数据的回流时间，发现：的回流发生在一天之内，的回流发生在两天之内，的回流发生在三天之内。这一分析我们如何构造选取线下训练集和验证集很有帮助。
 模型选择
关于模型选择，看到好多人都选择，而我们选择的是，之所以选择它是因为之前做比赛的时候对比过这两者的训练时间与预测结果。有实验表明在学习效率与准确率上都比表现得好，而且它还有这更低的内存消耗。
 构造训练集
通过之前的数据分析，我们直接舍弃了日的数据。考虑自身设备情况，我们仅选取了两天的样本作为训练集。比如以，两天的样本为测试集，以日样本为线下验证集。这样构造训练以及验证集可以有效避免数据泄露问题。具体构造训练集与测试集可以根据自身设备情况多取几天的样本。比赛开始阶段，我们使用一个模型进行预测，后期，使用了模型融合，分别训练了个模型，对此，数据集的划分如图所示。
 特征工程
我们首先对数据中属性进行了等值域划分，然后通过统计找出对原始数据中维度较小那些基本特征，对这些特征进行了编码，这样不至于出现特征维数很大的情况。其次就是组合特征了，组合特征是相对比较重要的。组合特征是不能盲目胡乱组合，要多想想实际情况，做一些统计分析，当然也可简单的通过训练结果的来测试组合特征的重要性。
 基本特征与特征
选取原始数据中维数较小的特征进行编码，主要包括用户的年龄、性别、婚恋状态、教育程度，广告的、、，上下文的和。
 特征交叉
不同特征之间的组合能起到更大的作用，我们分别使用户的年龄、性别、婚恋状态、教育程度、居住地与广告的、和两两进行交叉，同时记录在这两个特征交叉时，广告的排序特征。
 特征贝叶斯平滑
在交叉得到的特征中，经观察，发现很多广告的值并不准确，某些广告值因为该广告总点击数较少而导致较高，所以进行了贝叶斯平滑，贝叶斯平滑过程主要借鉴了博客上的思路。
 离散化
在得到基本特征和处理后的特征后，主要针对统计出的广告特征进行离散化，这种操作的目的是保证广告值可以再预估时按照自身的重要性发挥不同的价值。
竞赛刚开始阶段，并没有注重交叉特征的构造和特征的贝叶斯平滑操作，只针对基本特征和基本特征上的统计特征进行处理，结果非常差，后来加入交叉特征和对特征进行贝叶斯平滑后，效果慢慢变好。这部分内容可以参看很多博客文章。
目前阶段，我们对特征的总体处理如图表示。图中其他特征包括了除图中列举出的特征以外的其他特征，绝大多数是统计特征。
 模型融合
四个模型分别采用进行训练，使用四个模型进行预测，对个预测结果进行线性融合以得到最终结果。融合后的结果比单个模型的预测结果好，但是线性模型融合需要调整个模型参数，加大了工作量。
 比赛心得
首先，要保证训练集的构造没有问题，如果训练集有问题，再怎么提特征，调参数都没用。下来是特征的提取，可以说这个过程是整个过程中最重要的，因为特征的好坏直接决定了预测结果的好坏，特征不好，模型调的再好结果还是不行。最后就是模型调参了，这部分相对也比较重要，调参要理解参数背后的意义以及调参后会带来的影响，毫无规律的乱试能调出好的参数的概率渺茫。导语
可以通过获取摄像头的像素数据，用于渲染到纹理或者图像相关计算。 由于等各系统平台和硬件环境下， 用于渲染和图像计算时表现不完全一致，很容易造成图像渲染或者计算不正确，给调试带来很大麻烦，所以在这里总结一下。
可以通过获取摄像头的像素数据，用于渲染到纹理或者图像相关计算。
由于等各系统平台和硬件环境下， 用于渲染和图像计算时表现不完全一致，很容易造成图像渲染或者计算不正确，给调试带来很大麻烦，所以在这里总结一下。
纹理渲染和图像计算的像素坐标系
用一张像素的图片来表示，纹理渲染像素顺序如下：





















左下角为原点，向上和向右为正方向排布像素点
进行图像计算的时候，像素顺序如下：





















左上角为原点，向下和向右为正方向
 在各平台下的表现

渲染时像素顺序：





















获取的像素点数组排布顺序：





















读入像素计算时，将图像在方向上翻转就可以了
 后置摄像头
同
 前置摄像头
同
但是此处有一点要注意的是，前置摄像头需要的实际上是左右调换的镜面成像，所以实际上需要的像素点排布顺序是：





















在纹理渲染和图像计算时，最好是同时做一个方向上的翻转，以得到上边的像素点顺序
后置摄像头
后置摄像头获取的像素顺序与计算时的顺序一致，若直接渲染会上下颠倒。
其像素点排布顺序是：





















所以在使用后置摄像头获取帧并渲染时，应注意在方向上对图像做翻转
前置摄像头
前置摄像头获取的像素点排布顺序是：






















渲染时可不对图像做任何处理，这就是前置摄像头需要的左右镜面效果
读取时，按照与一致的读取方式，将图像读取为





















即可
读取顺序
从 中获取的像素点用数组来表示
     摘要 
                
     = 
    
      
    {
         摘要 
                 
          
        
         摘要 
                 
          
        
         摘要 
                 
          
        
         摘要 
                 
          

        
         摘要 
                       
        
         参数 
           
        
           
        
           
        
           
                
    }
读取该数组内存地址的像素点数据，在所有平台下，读取的顺序都是 全部  下载地址：=
本来这个文章应该在很早之前就写的，可惜一直没时间，写的时候断断续续。关键是这次  拓展又见晓生，每次见到他都会提醒我，这总结居然还没有写。
下面就由小  来总结下我在这次  究竟学了啥。两个关键字，大数据和泛智能，关键是能给大家一些启发。
先说大数据
在分层测试的概念里面，最后一环是发布运营，这是我们对于质量监控的延伸。而这种延伸其实就已经涉及到大数据了。这里我很喜欢一个概念，大数据 = 交易资料 互动资料 观察资料

而在这几年，包括 ，用户行为监控，其实都是在这上面做文章。对于专项测试而言，我们的  的思路就是利用外网的大数据来提升专项质量的实践，包括  树，触顶聚类。而同样来自我自己专题《 移动专项最佳实践》的腾讯互娱的何老师的分享《 腾讯手游性能优化之路》也介绍了互娱的 ，其中一个比较有意思的实践就是利用用户在地图的位置 发现 的数据在  后台展示王者荣耀的地图上聚类展示  的点。
交互资料的建设上，比较有意思的是 《网易乐得 无埋点数据采集实践之路》，他其实是用户行为上报的一种实践，通过无埋点可以解决很多数据上报的固有问题，如验证测试、需要人工配置的漏斗模型等等。在技术上， 采用的  的方式进行静态插桩， 通过   ，主要是从控件角度来 ，当然这里方案还有很多种，特别是  还有动态  的方式，但是从现在  方案对于   的支持情况来看，  确实是没有办法的办法了。比较值得推荐的原因是， 在分享中介绍了许多用这个技术面对的具体的坑， 对列表控件的行为上报的特殊理解，来挖掘用户对列表局部内容的关注度。
出了大数据的数据采集的维度，数据展示和数据分析也有一些不错的开源组件和对应的实践。这些开源组件包括：
    ：硅谷大数据技术专题的《 ：大数据的实时处理时代》
特点：无论在  还多系统中都广泛使用的消息队列组件，分享中我影响比较深刻的是它数据的两种状态，出了众所周知的  还有 。另外   可以用来回溯和重建。
   ：大数据应用专题的《基于  构建实时用户行为分析引擎》
特点：跟 ， 不同的另外一种大数据存储的选择。
   ：硅谷大数据技术专题的《分布式海量二进制文件存储系统》
特点：接口简单， 性能出色，多中心同步
    ：硅谷大数据技术专题的《 的核心日志系统》
特点：工作流系统
    ：硅谷大数据技术专题的《 的核心日志系统》
特点：跟我们的叮咚系统类似，但是功能和组件都非常丰富的开源的报表系统。



关于数据异常分析和展示的论文《     》，在  中可以下载。

这个附带了一些感悟，国外的这些公司真的很热衷开源
再说泛智能
有了大数据，经过数据清洗，训练，验证，落地应用就变成了现在说的机器学习。为什么说泛智能呢？因为，在整个  确实大量充斥着人工智能，机器学习，当然也不乏挂羊头卖狗肉和炫技，而不是为了解决问题。但是无论如何，这是趋势，什么东西都加上智能，运维智能，测试智能等等，我们也需要思考这里有什么东西，可以帮助我们解决问题。因此这里不论一些智能的落地效果，但是想法对于  质量提升上还是有启发的。

根据我现在知道的一些应用，我做的一些分类。主要按照监督和无监督类型来展开。
监督类
 生成用例：杨老师的《 用人工智能高效测试移动应用》，爬 ，根据  的界面特征建模，生成测试用例。例如新的购物类 ，上传到网站上，就会自动生成购物流程的测试用例。
 拟合算分：罗老师的《 直面音视频测试之痛》，使用机器学习，把各个维度的客观数据与  分进行拟合。
 告警：《 智能运维里的时间序列》，使用机器学习，预测时间推移的数据变化情况，如果跟预测的不同，触发告警，通过这种方式弥补传统阈值或者简单傅立叶变换导致的误报，进而提升外网发布运营在质量上的响应速度和敏感度，

 原因分析：这算是个我认为比较特别的用法，利用机器学习对数据生成决策树，然后分析决策树，分析触发问题的充分必要条件。这算是找问题原因的一个不错的方法。
无监督
 解决长尾问题：《美团  监控分析系统优化之路： 率从千分位到万分位》，通过数据聚类，可以聚合同类问题，也可以帮助快速发现新增问题
类似的我们部门内的实践，在测试用例上，利用  聚类，减少重复用例，其实也是一种长尾问题通过聚合减少的应用。
 分析原因：这个是自己  的，例如聚类高活跃的用户的用户行为，然后帮助更快地分析活跃的原因。
 
小结一下，可以看到机器学习其实可以给我们带来，聚类、分类、回归、预测、告警，大家也可以从这些方向想一下可以用来解决我们现在面对的什么问题。
其他
有诗和远方，也有眼前的苟且。除了高大尚的大数据，这里也附带分享也写我觉得不错的知识点。
《 和  性能优化感悟》：

这个金字塔其实归纳得很好，做性能优化的时候，有一定的指导意义。

《 构建日请求千亿级为服务实践》：
利用对象池减少 ，=  
《 服务器性能优化实战与经验》：
利用  来编译 ，提升性能

  限制，不能有效地使用多线程，那么就用多进程，但是进程内存消耗大， 进程不共享内存，内存浪费。他们利用  做共享内存 ， _  这个可以给  入库使用。
 
《  ：提速移动  交付》：
快速通过自动化做界面测试：

利用模拟器做自动化测试
 ， 已经在更早之前使用的类似的技术，关键的坑在启动模拟器的数量关键瓶颈在内存，大约  个模拟器耗费  的内存。
《 移动  性能监测实践》：
很多人会错误使用  ，具体可见：
《            》
这设计到后台性能调优，后台的性能，其实涉及到软件和硬件，就像一个数据库的调优，可以涉及 ，操作系统参数，数据库本身的参数调整，如何获取最优的参数组合，会有一些工具与方法论，例如 

很多时候，在各大公司的后台服务中，其实  利用率其实并不高，从一些论文里面会有不少研究解决方案的。例如：     的论文，利用给应用分为后台类应用和前台快速响应类应用来充分利用 ，甚至深入到  如何保证前台快速响应类应用的 。
其实大家不妨定期阅读一些论文，说不定真能拓展思路。今天，我们打开手机就能查看一公里内实时气温、降水情况以及小时后的变化；人脸识别系统在个月内帮助寻回百余名走失的儿童、老人；通过马航掉落的机翼位置找到失联的马航飞机黑匣子；计算几百年来全球地震情况和地壳运动来预测地震等次生灾害；通过语音精准识别，快递公司快捷录入地址…

越来越多的高科技已经深入到我们的生活中，科技的进步意味着我们的生活越来越智能。然而，你知道吗？现在地球中个月产生的信息数据比过去年的总和还多。
在中国的西南地区，腾讯云高性能计算数据中心即将落地，未来每日将吞吐着数以的数据量。对于企业而言，采购成本高、硬件型号无法及时匹配应用需求、计算资源无法灵活配置成为企业科技转型的阻碍。腾讯超算云提供的高性能计算解决方案帮助科研院所和企业处理大规模科学计算问题，应用于生命科学、基因测序、流体力学、工业设计等众多尖端领域，致力于创造更智慧的生活。

微信语音识别、的变脸功能、翻译、儿童学习机器人……人工智能已然成为我们享受智慧生活中让我们意识不到的背后服务。而企业站在风口浪尖上，进可成君，退则败兵。近日，一份届互联网校招高薪清单在网络流传，人工智能火年薪万早已成白菜价。

在发展越来越顶尖的人工智能背后，人才的争抢固然重要，而随着深度学习的商业化，企业是否需要一个更加高效的平台来降低人才成本？帮助企业获得在产业突破性进展中立足不败之地？

腾讯超算云所提供的平台开放计算机视觉、智能语音识别、自然语言处理三大核心功能，帮助企业一键式完成算法和模型的开发、调试、评估、部署和预测，快速对接生产系统，降低中小企业研发成本，帮助更多的人才专家减少重复工作量，提升效率。
深度学习平台让算法工程师和数据科学家不再需要关注深度学习底层繁琐细节和资源，更专注于职业发展和算法调优。
图解腾讯超算云在人工智能领域的解决方案
不仅如此，腾讯云早已渗透到人类生活中最离不开的衣食住行中，高楼拔地而起，汽车川流不息，太空工程不断探索。在工期漫长设计严谨的工业设计领域中，需要对产品的结构以及施工制作过程的各项环节进行前处理、仿真建模和后期优化处理，不断地收集数据组合最优方案，提升工业设计效率和品质。
腾讯超算云应用案例而腾讯超算云为这些工业设计企业提供专门平台，让企业即时获取资源和快速扩容，无需关注资源和调度平台，节约企业成本，更专注于产品创新和研究。
无论是人工智能、工业设计还是基因测序，在腾讯超算云的平台上，变得更有，更便捷高效。当我们提到未来科技时，有人说那是对于未来的幻想，但我们认为是基于超算云所带来的技术革新的预测，让企业“一键”享受到便利和服务，最大程度促进产品研发、提升服务水平，助力人们更快地邂逅智慧未来。作者：
原文：         

你听说过吗？这是由  ，等几家大公司合作发起的一个关于面向的通用二进制和文本格式的项目。现在就让我们来看看到底是个啥？为什么它的出现和未来的发展跟我们每个人都息息相关，即使你并不是一个程序猿媛
至少在某种程度上，它将改变生态。

–世界的汇编语言
我们有许多面向应用的开发规范，这些设计优良的规范让开发者们的工作变得更加的简单。我们很难想象自己所创建和网站或应用没有任何规则、编程语言、框架和开发理念可以遵循。
而将所有这些事情组合到一起的规范有一个众所周知的名字：！
基本上已经成为了平台的标准开发语言。而随着越来越多的软件成为了应用，更是获得了极大的发展。
但在过去几年，我们看到越来越多的项目问世，它们试图通过开发编译程序，将其他语言代码转化为 ，以此让开发者克服  自身存在的一些短板。其中一些项目专注于给编程语言增加新的功能，比如微软的 和的，或是加快  的执行速度，例如  的  项目和的。
在默认环境下， 文档其实就是简单的文本文件，先是从服务器下载，然后由浏览器中的  引擎解析并编译。用户可以通过技术在浏览网页时与服务器进行通信。

在浏览器端目前是使用来实现与用户进行动态交互等功能，虽然很多框架都致力于性能优化，但是一套基于字节码的系统仍然会有更快更好的性能表现。
所以，到底是个什么鬼？
是一种新的字节码格式。它的缩写是， 为文件名后缀，是一种新的底层安全的二进制语法。。它被定义为“精简、加载时间短的格式和执行模型”，并且被设计为 多编程语言目标文件格式。这意味着浏览器端的性能会得到极大提升，它也使得我们能够实现一个底层构建模块的集合，例如，强类型和块级作用域。原文：                    这句话我实在不知如何翻译。。。不过别搞错了，这并不意味着是为了取代 而生哟就像 说的：“会活得很好，因为世界上只有两种类型的语言：一类语言被人们不断的地吐槽，而另一类语言压根儿没人用！”而 认为：“最好不要把仅仅当做一门编程语言，实际上它更像是一个编译器。”
从到？

是一个的一个严格的子集，可以被用来作为一个底层的、高效的编译器目标语言。提供了一个类似于虚拟机的抽象实现，包括一个可有效负载和存储的大型二进制堆、整型和浮点运算、高阶函数定义、函数指针等。

的思想是使用它所规定的方法来编写代码，支持的引擎会将代码转变为十分高效的机器码。如果你是将代码编译为，将在浏览器端获得极大的性能提升。相较于的优势主要是涉及到性能方面。根据 的描述：在移动设备上，对于很大的代码库，仅仅解析就需要花费秒，而实验显示的加载速度比快了倍，这主要是因为相比解析  代码， 引擎破译二进制格式的速度要快得多。
这玩意儿到底好在哪？
你很可能会问：“为啥所有人都在谈论？”这是因为对于来说绝对是一个巨大的改进，但我们常常会问自己：“这样，就够了吗？”当然不是，对于浏览器来说也有着非同一般的意义。支持的浏览器可以识别二进制格式的文本，它有能力编译比文本小得多的二进制包。这将给应用带来类似与本地应用的性能体验！这四不四听起来很棒啊？！如果浏览器不得不解析完整的代码，这将会耗去好多时间特别是在移动平台上，而浏览器对格式的解码速度显然要快得多得多得多：下面献上作者大神的演讲视频地址油管，需翻墙：              
都有谁入了的坑？
包括 ，只是这一长串名单中的少数几家公司。项目带头人们发起了  这一社区，这个团队的愿景是“在一种新的，轻量的编码格式的基础上，促进浏览器厂商们的合作”不过，项目还只是刚刚启动，虽然它有一个美妙的开头，但在成为一个大众认可的标准之前，它还有很长的路要走。
为啥这玩意会影响每一个开发者
因为让开发者有能力选择之前那些不能用来开发应用的语言来进行开发，或者他们也可以继续使用简单易用的！   给出了一些的用例，它们展示了如何使得开发者更加轻松的工作 

一些执行效率更高的语言可以被编译成在平台上执行的代码。
提供了在浏览器端的开发者工具
更加快捷的企业级应用客户端例如：数据库

的用途很多。举几个栗子：可以被嵌入到已经开发好的代码中或者某款应用的主要框架可以使用  模块如动画、可视化和压缩等，而用户界面仍然可以主要使用 语言编写。
精简的代码，更好的性能，更少的？
据的开发团队描述，使用意味着更少的原代码。与相比，它减少了大约的代码量。虽然这仅仅是一个原型。现在你可能很想知道如何获取关于的最新进展，下面这些资源将会对你很有帮助：

   
   
   
     这篇文章也说得很棒，有空也可以翻译一下！

相关阅读：
【腾讯云的种玩法】利用 节省成本 日新进用户，解密《龙之谷》手游背后的压测故事

原文链接：作者： 

精细化运营能够帮助我们在数据的指导下进行产品路线、战略的调整，让产品改进的过程有章可循。但有时候，我们也会遇到一些看起来有些诡异的数据陷阱。
案例数据
我们先看问题的描述：在产品和产品中，男性的购买成交率都是男性女性，可在合计中，却是女性男性。那么，这就有点懵了。所以，到底应该拓展男性用户，还是女性用户呢？？可能我们的第一反应都是：是不是数据不准确啊？于是我们就有了以下案例

原因定位
我们来追溯一下问题的来源：从数据上我们可以看到，实际上，在产品和产品上，确实都是男性转化率高于女性，但由于产品的转化率明显低于，且男性群体大量被引导去了产品，所以整体数据的转化率反而要低于。这在统计学上称为：辛普森悖论’ 。在分组比较中都占优势的一方，在总评中有時反而是失势的一方。该现象于世纪初就有人讨论，但一直到年，辛普森在他发表的论文中阐述这一现象后，该现象才算正式被描述解释。 后来就以他的名字命名此悖论，即辛普森悖论。
此处数据已做了模糊处理，非真实数据
优化方案
回到这里的题目中，数据向我们展现：对于产品和产品，男性的购买成交率都大于女性；产品的平均成交率要明显低于产品。那么对于投放决策来说，我们还是偏好男性用户。在引流成本相同的条件下，男性的购买转化率较高。而针对产品和产品的分流推荐方式，可能还需要考虑两个产品的客单价与利润率。

从上图中可以看出，产品属于低单价、低利润、成交率高的产品，产品属于高单价、高利润、成交率低的产品。那么如果在电商开拓期，希望引入更多用户，我们可能会侧重于推广产品；如果平台已经有一定规模，希望能够提高人均利润率，降低百元成交量的获客成本，我们可能可以考虑多推广产品。

大概就是像这样的两个产品↑
当然，这些的前提是在，引流成本相同的情况下。而往往实际问题的考虑中，我们还会需要考虑投放成本、投放效果、转化效果等问题，这部分在《数据运营实战一：细分目标人群，结合用户画像的实践》中也探讨过，欢迎移步讨论！
案例总结
在数据运营的实战中，也可能会遇到一些让我们觉得有点别扭的数据。而在这些数据背后，其实蕴藏着很多的细节与能量。因此，建立详细的数据分析运营体系，理解用户群分离与归并的思路，让数据为你所用，这是很重要的。回顾我们上一期讲过的数据运营微笑模型

这一期我们讲的是在定位原因的过程中，对用户群拆分解析之后发现了其中的运营价值。我们可以先通过腾讯移动分析的自定义事件埋点，监测购买事件，同时上报购买商品的参数；然后通过用户分群设置筛选出购买事件中，购买参数等于产品或者产品的人群，来得到我们想要的细分用户群体：
然后通过用户群体的计算与分析，得到该群体的人群特征，展开我们的数据分析工作。、问题的引出
提到移动设备开发，最先让人想起的是苹果和安卓，以及他们那些令人头疼的多屏幕适配。下面是腾讯分析统计的移动设备的各分辨率占有情况。


不光分辨率差别很大，移动设备的尺寸相差也很大，从英寸的手机到英寸的平板。
下图为各种品牌所存在的移动设备的尺寸。

还有，就算两个设备尺寸一样，也会存在不一样的屏幕密度或，每英寸的屏幕包含多少个像素，同样大小的字体或者宽高，放到这两个设备上，屏幕密度大的字体就会显得小。下图是现有市场上的屏幕档次。

所以说，移动端开发面临的最大问题就是就是多屏适配，这是一个设计师、开发和测试都要面临的问题，如何做到在不同分辨率，不同屏幕密度上的手机上，同样大小的元素，看起来是一样大的。说白了就是同一套代码在不同分辨率的手机上跑时，页面元素间的间距，留白，以及图片大小会随着变化，在比例上跟设计稿一致。
、一些概念
在解决问题之前，先了解一些概念。
像素
即我们代码里写的像素，用于页面布局的单位，与设备无关。
物理像素， 
一个物理像素是显示器手机屏幕上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。物理像素与分辨率有关，比如 的分辨率是，它表示这个设配有个物理像素。
设备独立像素， 
设备独立像素也叫密度无关像素，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素比如 像素，然后由相关系统转换为物理像素。设配独立像素与尺寸有关，比如的宽高为×，可以理解为设备有×独立像素或像素。所以说，物理像素和设备独立像素之间存在着一定的对应关系，这就是接下来要说的设备像素比。
设备像素比   
设备像素比简称定义了物理像素和设备独立像素的对应关系，一个设备像素上有多少个物理像素，它的值可以按如下的公式的得到：
设备像素比 = 物理像素  设备独立像素
下图为同样设置宽高为的矩形，在不同的设备上所占的物理像素。其中像素比为的占用个，像素比为的占用个。

视口：
视口指的是移动设备中的设备屏幕窗口。在移动端浏览器当中，存在着两种视口，一种是视觉视口也就是我们说的设备大小，另一种是布局视口我们要看的网页的宽度是多少。

先说一下视口的起源，智能设备刚出现的时候，查看桌面端的页面时会出现一个问题：由于早期的页面很多采用固定宽度的布局，导致放在移动端的小窗口下出现横向的滚动条，不便于用户查看，所以浏览器厂商研究出了布局视口。布局视口的宽度一般在由浏览器厂商设置，常见宽度，这样，小屏的移动设备能够一次性完全显示桌面端页面，避免了浏览器出现横向滚动条。下图是腾讯网在手机端的显示状态，如果不进行缩放操作的话，文字几乎是无法看清的

举一个例子：如果我们的屏幕是像素×像素的大小，假设在浏览器中，像素的屏幕宽度能够展示像素宽度的内容。那么像素的宽度就是可见视口的宽度，而能够显示的像素的宽度就是视窗视口的宽度。说白了，就是把的东西装在了的屏幕里。用户不用缩放，就能看到整屏的的页面。但也产生了一个问题，移动端的浏览器同桌面端相比，就是字体过小，但是用户可以手动缩放。后期也产生了根据调整视口宽度和缩放开发移动端的页面。
、设计图
设计师出图的依据是移动设备的分辨率，与设备的宽高无关，单位是。根据本文的第一张图显示，苹果分辨率最多，而安卓则是最多，虽然有些差别，但是宽高比都是的，缩放后失真不会太多。
倍图
在早期的手机，一个设备像素就是一个物理像素，这时候的分辨率和尺寸有关。比如的手机一定会比的小。这种图已成为历史，不再讨论。
倍图
后来苹果发明了，就有了屏幕像素比这个概念，倍图就是屏幕像素比为的图，这种比例以 起为代表，它的尺寸是，但是它的分辨率是。即：分辨率 = 屏幕宽高  像素比
倍图
到了 又出了三倍图的概念，它的尺寸是是 ，而分辨率达到了。
下面是系列各个宽高及像素比：

安卓的屏幕尺寸更加多样，分辨率有很多种，相应地，设备像素比也不一致，有、、、、等等。也有倍图等概念。
那设计师出多大分辨率的图呢？
第一种：
以 为基准设计稿，向上适配。这种方案在两年前比较流行，小尺寸的页面放在大尺寸的手机上，会自动等比放大，铺满新手机，效果还可行。现在还有很多在做适配的时候设置成都直接设置了 =，简单可行。但因为拉伸，整体看起来有点虚，也不能更好利用大屏空间。等到后来在出现，效果就更差了一些。
第二种：
以 为基准设计稿，向上、向下适配。这个尺寸在上非常流行，   的尺寸大小相同，分辨率相同，都为，向上拉伸，向下压缩，失真的比例不会太大。
第三种：
以  为基准设计稿，向下适配。这两年安卓发展突飞猛进，分辨率越来越高，分辨率已成为普及，而、屏也即将到来，小的设计稿已无法满足超清的要求，很多的设计都已步入倍图的时代，那就是以  的尺寸×=为基准，生成的倍图，×分辨率。
综合来看，在移动开发时，第二种方式当前最合适。既满足了用户的显示需求，又能降低、用户加载图片需要的带宽。不过，你若有更高质量的追求，第三种设计稿也是一个不错的选择。
不管在手机浏览器还是在微信客户端或者腾讯新闻客户端开发，内容大都不能全屏显示的。在底部或者顶部多多少少会有一个状态栏的占位。一些手机浏览器底部会有导航，也有些会在顶部和底部都有占位，比如导航栏、状态栏。顶部的占位会把内容往下挤，底部的占位会把内容遮盖住。如果做只有一屏的，高度要注意一下。
下图为腾讯新闻客户端和微信内置浏览器的占位高度，在上他们的高度是一样的。如果你的页面高度超过，页面就会出现滚动功能。

、适配
、固定
 用于指定用户是否可以缩放页面，表示文档针对移动设备进行了优化。 的值是由指令及其值组成的以逗号分隔的列表。
下面是的一个示例：
 = == = =
 = = =
和的值可以使用具体的数值，或者使用可以指示视区宽度应为设备的屏幕宽度高度。
为，或者表示是否允许用户缩放。
用于设置页面的初始缩放比例，设为则将显示未经缩放的文档。将放大， 将缩小。
和用于设置用户对页面缩放比例的限制。值的范围为至之间。
既然可以自动缩放页面，那么为什么不制作固定尺寸的页面，让浏览器自己去缩放呢？开发和设计都省事了！
固定尺寸的页面的实现：
 = ===
这种模式最为简单，它的意思是不管何种设备，都按照的宽度等比例缩放。所以，按照宽度为的界面设计和开发最省事。=的意思是不允许用户缩放。若是开启用户缩放的话，当你的页面超过时，浏览器会自动进一步缩放，至你的页面宽度。
另外，也有的写法
  = 
  = =
=  = 
  =   = 
}
这种模式适合用来做页面的简单适配，但是这有个缺点，这是缩放。既然是缩放，那么就会失真，大屏设备上的字体会大一些字体变的模糊，的直线看起来不一样粗。还有，设备由竖屏切换到横屏的时候，界面会变大的很多。在一些手机上，如果用了一些非自带的字体，甚至会发虚如果用了部分的属性，发糊的现象可能会更严重，缩放同时会带来浏览器的卡顿。
这种模式，情急之下够用，但不完美。
、设备宽度
在开发移动网页时，你一定会遇到前辈留下的这段代码：
 = == = =
 = = 
 在网页的中增加以上这句话，可以让网页的宽度自动适应手机屏幕的宽度。其中：
= ：表示宽度是设备屏幕的宽度=：表示初始的缩放比例
它的意思是说，页面宽度就是设备宽度，缩放比例，这时，无论你是多么高清的屏一个像素完全等于一个设备的独立像素。其实这两行代码的作用是一样的。他们的的作用都是不对当前的页面进行缩放，也就是页面本该是多大就是多大。因为这里的缩放值是，也就是没缩放，屏幕的宽度自然是实际能展示的宽度了。
但如果 和 =同时出现，并且还出现了冲突呢？比如：
 = == =
=表示把当前的宽度设为，=则表示把当前的宽度设为设备的的宽度，那么浏览器到底该服从哪个命令呢？是书写顺序在后面的那个吗？不是。当遇到这种情况时，浏览器会取它们两个中较大的那个值。
但为什么要写两个？这里有个兼容性的，当横竖屏切换的时候，、的会始终为竖屏的，而的始终依据的是竖屏的。最完美的写法应该是，两者都写上去，这样就 = 解决了 、的毛病，=则解决了的毛病。
如果不设置或，浏览器则会默认为，然后计算 = 页面宽度。
、媒体查询
媒体查询可以让我们根据设备显示器的特性为其设定样式，配合，就可以让宽屏的设备显示大号字体和宽的内容。     是指相对于根元素的字体大小的单位。是新增的一种单位，移动端基本都支持。
{}
     {{}}
     {{}}
     {{}}
     {{}}
     {{}}
     {{}}
   {{}}
把与元素尺寸有关的，如，，，，等都以作为单位，这样页面在不同设备下就能保持一致的网页布局。
假设，我们设置 也就是说相对于，那么也就是  = 。
那么我们以的设计布局为基准，将设置为，即 = 。设置是为了方便计算那么可以将大部分单位除以就可以直接改成单位了。比如，宽的元素就是。
通过设备宽度范围区间这样的媒体查询来动态改变基准值，其实不够精确，比如：宽度为 和 宽度为的手机，因为屏宽在同一范围区间内  ，所以会被同等对待基准值相同，而事实上他们的屏幕宽度并不相等，它们的布局也应该有所不同。可以通过来实现媒体查询的功能。
   {
      = 
         =       
         =   {
              = 
              
             =       
        }
      
      
} 
到现在我们没有做到足够的精确，但是已经够用。
、像素问题
上述的方法还存在一个问题，先看下图

我们设置了=，这样样式和设备像素无关了，在普通屏上占用了行像素，在高清屏上占用了行像素，在倍屏上就占用了行像素等等。
那我们怎么才能实现高清设备上的实实在在的呢？也就是呢？比如设计师要求实现设备上一条最细的边线，可并不是所有手机浏览器都能识别 ，以下，等其他系统里，会被当成为处理的。
有两个方法
第一种：针对边框缩放
{
      
    
     
}
 这个时候，不支持像素的设备会按实现，支持的设备会呈现实际上是。这里通过 缩小倍来达到的效果，但是这样实在是不够通用如：圆角等，与这个元素相关的其他属性也要跟着调整，写起来实在麻烦。
有没有别的方法？有！
第二种：整体缩放
思路是这样的，倍图渲染倍图的界面，倍图渲染高清屏的界面，以此类推，然后再统一缩小倍数到设备界面上，完美！
   
  = 
  = 
  = =

 =  || 
 =     
 =   

 设置，进行缩放，达到高清效果
 =     
 =    =   
  =    =

 设置属性，留作的 之用
 

 动态写入样式

 = {    }
 举例来说：
倍屏宽的设备是，渲染的宽度实际上就是，渲染就是。
倍屏宽的设备是，渲染的宽度实际上就是是，缩放为倍为，渲染就是。
倍屏宽的设备是，渲染的宽度实际上就是是，缩放为倍为，渲染就是。
这样就在，通过屏幕像素比进行缩放，不改变原来大小的前提下，实现了功能。
、一切从简
上述的例子一步一步引出了动态设置的方法，但是每次都要计算很麻烦。
对于一些资讯流的页面，比如腾讯新闻的界面和 界面

对于图片，采取了等比例缩放，对于文字，大小是一样的，超出后自动截断。每个列表的高度是一样的，设备越高，展示的新闻条数越多。
这是一种典型的弹性布局：关键元素高宽和位置都不变，只有容器元素在做伸缩变换。对于这类页面，记住一个开发原则就好：文字流式，控件弹性，图片等比缩放

、文字字体大小不变，多了就折行，自动撑开。
、空间在宽屏的设备上左右浮动，或者。
、图片通过或百分比自动缩放。
对于这种页面，拿到设计图后，直接按开发，无需用增加页面的复杂度。
、小结
上面对移动端高清和多屏适配的一些方案总结，没有固定的套路及方法，请根据自身业务的特点，选择其中的一些方法组合使用，不对的地方，多多指教。
接下来第二部分会分析移动开发的过程中的细节问题和最优的解决方法。
敬请期待……本节为大家讲解腾讯云主机搭建代理服务器的过程。

什么是
它是一个代理服务器，用来实现或代理，系统一直在用 非系统，怎么开放个代理呢？那就是。
安装
直接执行命令即可
  
   
配置
配置文件在 
修改如下地方即可：
  预设是 你可以更改
  将改成你自己的
例如你的 是你改成 那只有你才可以连上这个
若你想任何都可以脸到在前面打注释
配置说明

以根用户启动时，在初始化完成后切换  为 
 默认监听端口为 该端口无需用  权限绑定
默认在所在网卡上监听
 必须 日志文件 默认  ，在  文件不存在时会警告，不会运行失败。
 必须 文件 默认  ，在  文件不存在时会运行失败。
 初始启动的代理服务器子进程 默认是  个
 允许使用  进行  代理的  地址。默认是 ，如果想要公开  代理服务器，则把  一行注释掉

运行
直接启动  的  即可。
  
默认启动
   
重启
   
停止
   
连接测试
在另一台客户机上输入
   
其中和是代理服务器的和代理端口，如果出现百度的源代码，则证明代理配置成功。

相关推荐
腾讯云下定时监测进程终止后自动重启的方法
在   服务器上部署  博客
去获取个月的免费试用机会前言
前面总结的几篇踩坑博文中，我总结了自己在使用过程当中踩过的一些坑和经验。我们知道是多机器集群部署的，分为，负责资源调度，是不同的运算节点，由统一调度。
而是我们提交程序的节点，并且所有的类型的操作都会汇总到节点进行整合。节点之间会将等操作函数传递一个独立副本到每一个节点，这些变量也会复制到每台机器上，而节点之间的运算是相互独立的，变量的更新并不会传递回程序。
那么有个问题，如果我们想在节点之间共享一份变量，比如一份公共的配置项，该怎么办呢？为我们提供了两种特定的共享变量，来完成节点间变量的共享。 本文首先简单的介绍以及 中累加器和广播变量的使用方式，然后重点介绍一下如何更新广播变量。
累加器
顾名思义，累加器是一种只能通过关联操作进行“加”操作的变量，因此它能够高效的应用于并行操作中。它们能够用来实现和。原生支持数值类型的累加器，开发者可以自己添加支持的类型，在之前的版本中，通过继承来实现，而之后的版本需要继承来实现自定义类型的累加器。
如果创建了一个具名的累加器，它可以在的中显示。这对于理解运行阶段 的过程有很重要的作用。如下图：

在之前版本中，累加器的声明使用方式如下：
   =   
  = 

     =  = 

        

 
  = 
累加器的声明在发生了变化，到也有所变化，具体可以参考官方文档，我们这里以为例将代码贴一下：
   =  
  =       

     = 

        

 
  = 
广播变量
累加器比较简单直观，如果我们需要在中进行一些全局统计就可以使用它。但是有时候仅仅一个累加器并不能满足我们的需求，比如数据库中一份公共配置表格，需要同步给各个节点进行查询。先来简单介绍下中的广播变量：
广播变量允许程序员缓存一个只读的变量在每台机器上面，而不是每个任务保存一份拷贝。例如，利用广播变量，我们能够以一种更有效率的方式将一个大数据量输入集合的副本分配给每个节点。也尝试着利用有效的广播算法去分配广播变量，以减少通信的成本。
一个广播变量可以通过调用方法从一个初始变量中创建。广播变量是的一个包装变量，它的值可以通过方法访问，下面的代码说明了这个过程：
   =   
  = 

 
  =   
从上文我们可以看出广播变量的声明很简单，调用就能搞定，并且中一切可序列化的对象都是可以进行广播的，这就给了我们很大的想象空间，可以利用广播变量将一些经常访问的大变量进行广播，而不是每个任务保存一份，这样可以减少资源上的浪费。
更新广播变量
广播变量可以用来更新一些大的配置变量，比如数据库中的一张表格，那么有这样一个问题，如果数据库当中的配置表格进行了更新，我们需要重新广播变量该怎么做呢。上文对广播变量的说明中，我们知道广播变量是只读的，也就是说广播出去的变量没法再修改，那么我们应该怎么解决这个问题呢？答案是利用中的函数

                                          

上文是从官方文档摘抄出来的，我们可以看出，正常来说每个节点的数据是不需要我们操心的，会自动按照规则将老数据删除，如果需要手动删除可以调用函数。
那么更新广播变量的基本思路：将老的广播变量删除，然后重新广播一遍新的广播变量，为此简单包装了一个用于广播和更新广播变量的类，如下：
 {   }
 
 
 

          
     
   
        
       _  {

      = _

       =   = {
     删除是否需要锁定
    
     = 
  }

     = 

       = {
    
  }

       = {
     = 
  }
}
利用该更新广播变量，大致的处理逻辑如下：
 定义
  =  

 = {
  定期更新广播变量
        {
     
  }
     
}
总结
中的共享变量是我们能够在全局做出一些操作，比如总数的统计更新，一些大变量配置项的广播等等。而对于广播变量，我们也可以监控数据库中的变化，做到定时的重新广播新的数据表配置情况，另外我使用上述方式，在每天千万级的数据实时流统计中表现稳定，所以有相似问题的同学也可以进行尝试，有任何问题，欢迎随时骚扰沟通
广告下我们项目：专注于游戏舆情的挖掘分析，欢迎大家来踩踩

参考文献
    共享变量         

相关推荐踩坑记——初试踩坑记——数据库在腾讯云的  服务器上安装和运行 
 添加  
     |   
 添加 ，并安装
        
 
  
 检查是否已安装成功
 
基本使用
安装  镜像
  
开始下载  镜像 大概需要分钟左右
  
   
   
   
   
   
   
   
  
  =========================================             
查看一下当前的镜像列表
 
                                                      
                                                  
                                                 
                                                  
                                                
                                                 
                                                 
                                                
                                                
                                                  
                                                
                                              
                                                
                                               
                                                
                                                
                                                
                                                
执行一个命令
     
 
           
            
           
         
            
          
           
           
            
           
           
           
           
          
           
           
            
           
          
          
登录到  里面去
     
  
           _ _ _ 

  
  _      
       
        
       
       _  _ 
  _    _    
       
        
       
       _  _ 
安装 
 默认的源在腾讯云主机上无法访问 所以要把源改成腾讯云的源 登录到  里面去发现里面连  编辑器都没有 没办法 只能把主机的文件映射到  里面去 然后 
下面的命令把主机的  映射到  的 目录 并且运行 
       进入  后把主机的  文件  过去 在  里面执行下面的命令
  
  
然后再执行  命令安装就没有问题了
    
设置个  密码
 
   
   
   
查看下  的
  
  _      
       
        
       
       _  _ 
  _    _    
       
        
       
       _  _ 
启动 
  
从主机上登录
 
        
    
         
          
 
      _

    

         
          
   

          
 


保存对的修改

查看下  

 
                                                                               
                                                              _

保存 上一步的   是  但是不用全部输入只要保证不重复就可以了

   


确认 镜像列表里面有刚刚保存的镜像

 
                                                      
                                        
                                                  
                                                 
                                                 
                                                
                                                  
                                                 
                                                  
                                                
                                                
                                              
                                                
                                               
                                                
                                                
                                                
                                                
                                                

提交

  
        
  
首次提交会要求登录
    
 

 
 
        
  
    
    
    
    
    
    
  ===========                                           
   




相关推荐深入浅出话容器服务导语
身为码农，缓存大概是我们接触最频繁的概念之一了。当读写性能不达标，我们也许会脱口：做缓存策略吧，性能会大幅提升的；当发现缓存命中率不足时，我们也许会脱口而出：提升命中率吧，性能会大幅提升的；但事实确实如此吗？会不会其他方法会工作的更好？下面是我的一些数据分析，希望能给大家带来一些灵感与思考。
公式
命中率 = 缓存命中次数请求总数时延 = 命中率×缓存时延 命中率×缓存时延 失效时延 = 线程数时延
一个例子
假设我们运行了一个单线程的数据服务，单请求的延迟为 ， 为 ；做了缓存策略之后，命中缓存的情况下，单请求的延迟为 ， 为 。我们用服务的平均  来代表其性能，下表为性能和缓存命中率的关系：



缓存命中率
性能





















































从表格中，可以发现一些有趣的现象：当我们把缓存命中率从 提升到 ，带来的性能提升还不到 。而当命中率从 提升到 ，仅仅一个百分点，性能提升就达到了近一倍！
缓存与性能的关系
上面的分析，说明了缓存命中率和性能并不是一个线性关系。缓存与性能的关系曲线如下图所示。当缓存层级间速度差异越大，此曲线越陡峭。  

指导意义

只有当缓存命中率达到 以上，才会有明显的性能提升。命中率为 ，性能提升约 ～ 倍；命中率为 ，性能提升约 ～ 倍；

缓存命中率与业务场景有关，局部性越强，缓存性能提升越大。对于完全随机的业务，缓存策略提升不大，甚至拖累性能；

对于特定业务，如果缓存命中率达到 甚至 以上，优化缓存命中率可以得到巨大的性能提升；

对于特定业务，如果缓存命中率不到 ，优化未命中缓存时的业务性能更靠谱。比如换 ，优化算法等；

高性能存储系统，比如数据库服务，一定要预留大量可用系统内存以供页缓存使用。一旦内存不够，则性能将会大大折扣。比如系统内存不足，导致页缓存命中率从 跌到 ，性能会下降五倍之多；

 是个好东西。对于纯随机的读写服务， 比缓存要靠谱得多；

对于局部性不太强的业务，二级缓存、三级缓存也是有用的，如果一级缓存命中率不高，多加几层缓存也可使得每一层缓存间的命中率达到 以上。翻译者：乐视  高翻院  石雪峰
校对：叶赫华、黄华、刘慧美

 是如何利用  持续部署实践来改善  发布流程的
、起航
代码部署应该简单且频繁，研发工程师需要参与整个部署流程，对于 而言意味着秉持持续部署的核心实践。对于日常发布而言，会有一组工程师和一名专职的发布经理共同监督所有变更被成功部署到准生产环境和生产活动，在发布流程的每一个检查点，团队成员会对他们的变更负责，保证不会破坏代码质量，确保其可以随时发布。
所有人必须紧密配合保证每次部署都安全完成，而在  这是一个频繁发生的事情，有时甚至每天会有超过次的部署。
这种策略奏效主要归因于每次部署都是由最熟悉变更的成员直接完成，那些直接负责这些模块代码的开发工程师可以很容易发现并解决软件中的问题。因此，开发人员应该被授权根据需要部署代码，且代码的顺利部署保持关注。
而对于一个  的发布而言，会有一些不同的地方，代码部署的方法就不太适用了。其中一个主要的原因就在于  有版本迭代和编译的完整过程，同时  需要通过   或者   进行分发，所以需要花费些额外的时间才能真正到达用户。
一般来说，由于  发布的这种特性，团队会倾向于引入发布分支和发布经理来管理这个流程。而我们的  最早也是沿用类似策略，可是很快我们发现这样的做法不太像 ，所以我们决定是时候进行改变了。
、发布经理

我们两个曾经是  的发布经理， 负责    ，而我负责。我们的职责包括：所有发布阶段流转，维护发布计划，管理所有发布环节中的协同沟通，解决冲突以及跨团队调配资源来应对紧急发布中的问题修复。
 准备发布
我们的工作重在使个人各施其职，按部就班。每个发布时间点也是我们最需要注意的评审点，此时需要组建专门团队负责此阶段功能集成到主产品，轮流进行迭代。阶段发布需要按计划进行，并且保证到达特定发布阶段时会完成某些变更。重要的是，那些变更是意料之中且已经测试过的。
仅仅依靠  和我来追踪所有在这次发布中的变更是一件非常困难的事情，所以我们的任务之一就是协调所有作出变更的工程师保证他们的改动符合预期且验证通过。在实际操作中，这意味在特定检查点比如拉出发布分支的时候需要发送大量的邮件和信息用于沟通。当然在紧急报警发生的时候，我们同样需要及时知会相关人员。

后来  离开了  寻找更好的机会，而我就成了唯一的发布经理，所有发布的决策都需要通过我来完成，也只有我能作出和执行这些决定，我俨然成为了发布系统中的那个容易导致单点失败的瓶颈。
这令我压力山大，手足无措，我担心自己会陷入无尽的上传    和发邮件的工作中，这也并非是我期望的工作内容。我希望这些繁琐的任务都可以自动化，只需要一个按钮就可以完成，想到部署时候的轻松惬意，这让我很是羡慕。
即使回到我们两个发布经理的时候也并不轻松，从工程师的角度来说，这个阶段的  发布一点都不透明。他们很难知道当前的发布阶段，每天都接收大量的邮件，但只有很少部分才是他们真正关心的。我们仅仅是把邮件发给个应用。
开发人员的群组，内容混淆了类的邮件和真正需要紧急处理的，这让我们陷入了“狼来了”的困境。
所有这些问题都会让工程师感觉自己像机舱里托运的货物，而不是驾驶员，这完全不符合我们之前部署的原则，也不符合我们的研发处世哲学。我们并不喜欢这样，他应该变得更好，让工程师从被动变为主动。
、发布

所以我们打造了一个管道来协调发布过程中的状态，计划，沟通以及工具，他有几点好处：
•保持跟踪谁做了哪些修改
•发送必要有效的  消息和邮件给需要的角色
•管理所有发布的状态和计划
为了让这些抽象的概念更加容易理解，我们可以看个例子：
 队长日志
 在    版本上完成了第一次提交
 获取了这个消息，自动发送给  一封  版本欢迎邮件 

译者注：是一个自动化系统

周一
•自动任务将发布流转到测试阶段，并自动编译出测试版本 
• 获取了这个消息，并发送 一封版本编译完成邮件给 
• 安装这个版本并验证她的改动，并回复给  这个问题已经 
周二
•所有人完成自己改动的验证，并 反馈成功状态
•自动任务完成发布分支的创建和预发布版本的准备工作
• 获取了这个消息，并 给验收测试团队发送一封邮件
周三
•验收测试团队报告没有发现严重问题
•自动任务将  版本提交   审核
周五
•自动任务检测到   的审核结果，同通知  本次发布已经获得批准
• 发送邮件给  和所有改动负责人，通知本次发布已经获得批准
周二
•自动任务正式发布 
• 自动邮件给  和所有改动负责人，通知本次发布已经正式到生产环境
周三
• 发送一封  报告给所有本次发布中的负责人
在  诞生之前，所有以上这些工作都需要手动完成，但是你也许会发现，当一切都自动化之后，是不是发布经理这个角色就被脚本所取代了， 变成了我们的发布经理？

 发布司机  
只说对了一部分，实际上有一个功能将每次发布分配给一个发布司机 。

司机的职责在于一系列无法自动化或者 不应该自动化 的工作，包括：•安排变更计划
•跟踪监控所有工程师变更都达到准备发布的状态
•跟踪解决所有发布前的严重问题
其他的事情呢？全部是自动化完成的！分支拉取，候选发布版本编译，提交   — 甚至启动发布到   
当然，我们也受到    这篇文章的启发。有一些工作默认是编排为手动执行的。同时还有一部分工作在  中是明确定义为禁止自动完成的，比如 的正式发布。
这样的工作需要人为干预，除此之外尽量实现自动化。当然我们还有一个安全控制机制，在任何时候发布司机都可以停止所有自动任务，切换到手动驾驶模式。

当发布司机希望手动处理一些工作的时候，他们并不需要手动访问     ，这些工作都被很好的封装简化到一键完成。这么做的好处是，我们完全无需担心发布配置被所有人获取，包括设备号，认证签名等，同时在后台我们保存了一份清晰的日志来记录所有发布司机的行为。
在主线分支进入下一个发布周期的时候，我们会采取半随机的形式来选举新的发布司机，范围是上一个周期中参与到代码提交活动的工程师和发布司机。当选举完成后，我们会自动发送一份通知邮件到这位幸运儿，告知他所要承担职责：

 准备再次发布
其实在发布分支被正式拉出之前，新一任司机基本都无需跳到前台，在发布分支创建前几个小时，就需要他正式登场啦，首先要确认所有本次待发布的改动已经准备就绪，同时评估那些尚未完成的工作事项的详细计划。当一切就绪后，司机仍然要作为主要接口人来跟踪验收测试，如果发现任何问题，那么他就需要推动解决。
假设一切顺利的来到发布当天，司机可以选择手动发布，或者安排自动任务，如果自动任务过程中出现问题，会自动通知出来。在发布之后，司机会关注可视化看板，日志，图表来确认本次发布的健康程度。
修复
并非所有发布都是计划内的，意外总会发生，这才是 意料之中的 假设严重问题不会随版本发布出去过于天真，事实上会有各种各样的问题需要我们 事后应对。当问题出现时，任何工程师都可以快速的基于最近一次正式发布的基线修复问题。

研发工程师会通知发布司机请求集成这个改动。当他们拉出新的发布分支时，所有必要改动会集成进来，只要获得发布司机的同意，其他人也可以这样做。之后的流程跟正式发布一致，编译待发布版本，安排验收测试，推送生产环境，一切尽在发布司机的掌握之中。
、发布状态机
诚然，版本的发布是一个异常复杂的过程。

他起源于一个抽象的发布计划，之后便开始一系列具体的工作，提交代码改动到主分支。代码改动完成后则进入下一个阶段拉出待发布分支。编译待发布版本并跑通验收测试，并投放到生产环境，之后发布分支的生命周期就会结束。
当拉出发布分支后，下一次发布任务即刻在主分支启动，周而复始，每一次发布都有自己的发布状态机，帮助开发和发布工作有节奏的交替进行。
 通知：和

通知机制覆盖整个发布周期，因为整个过程中有太多信息。让合适的人在合适的时间收到合适的通知是非常重要的。所以我们使用发布状态机来通知工程师，以及其他订阅消息的人员，这取决于他们的需求以及他们对本次发布的影响。
我们提供了订阅机制，允许发布过程中的通知订阅，这对于产品经理，支持团队，工程团队都有帮助，我们的通知机制正是基于主动订阅的方法来设计的。
根据订阅，我们会在状态转换的时候发送通知邮件，以保证邮件中覆盖必要信息。

至于如何判断对本次发布的影响大小，我们需要其他途径来获取这些有效数据。
、
我们提到  需要通过其他途径来获取数据，在 ，我们使用作为代码版本控制系统，我们的会基于平台，来构建。为了保证  的数据及时准确，我们添加了后台脚本   ，检测到  分支推送和发布分支推送的时候，会自动通知。
当  获取到这个消息后，他会遍历提交，记录作者，保存本地提交路径，提交信息以及受影响的  和影响版本。 会统计分析这些数据，来评估影响哪些工程师会出现版本影响人员列表，这个列表会作为邮件通知的重要依据，以保证关联人员可以及时获取信息。
此外，在发布过程中，工程师可以登录改变他们的通知状态，他们往往是因为需要获取更多版本信息，或者  错误识别了代码改动信息，并把他们添加到了不需要的版本通知列表中。
、
以上我们已经说明了在内部是如何跟踪状态的机制，但还没有提及自动任务是如何同外部系统协同工作的，以及他如何影响的开发流程。
我们研发了一套管理部署平台  来提供  发布支持。他可以实现同     的发布交互，这是我们用来编译待发布版本，发布，创建分支，提交   等一系列任务的作业平台。
我们采用  基于几个以下几个原因：
• 的工程师非常熟悉这个平台
•通过一键操作封装复杂的发布过程操作
•便捷的日志提取和错误追踪功能
在我们的系统中采用了  任务，他帮助我们在周二晚上拉出发布分支，也帮助我们接口     ，我们使用官方通过  模块实现访问  ，至于   我们使用  来实现非官方的  的调用。
、适航 
构建的目标是让他成为我们的发布经理，从此  不再有专职的发布经理角色，任何人都有可能成为这个角色，包括我也不时的参与到发布工作之中。
人的作用不可能被自动化完全取代，这对于  部署和  发布殊途同归。我们的流程之所以独特，就在于不断穷尽我们所能想到的所有事情，并让他变得自动。与此同时，赋予研发工程师相比从前更多的职责，让研发工程师来完成部署上线，决策是否拉出分支，工程师来亲自上阵，点击按钮发布版本。
而这才正式 之所有存在的核心期许，他让我们的工程师交付最好的  给我们的用户，让工程师走向前台，职责共担，激发更大的热情和责任感。

译者注：有效价值的快速持续交付是  的终极目标，组织和文化的改变往往比工具层面的演进更加重要，打破部门墙和组织边界的关键在于职责共担， 正是通过极尽的自动化，简化原本复杂而专业的事情，让人人成为发布经理，当工程师真正站在产品的角度意识到他的每一次改变都能带来价值的时候，行为的改变潜移默化的带动文化的改变，从而使这样一家公司迸发出更多活力，成为研发效率领域的明星。

       

文章来源：时代社区终于到了这一篇，从数据层到应用层都是完全基于平台优化，完全将微软系应用架构搬到了国内云平台上，也算是国内第一例了。
牛皮吹完，说说正事儿，的监控虽然看起来非常“丰富”：
 
而且似乎没有统一的监控界面：

但实际上能够支持企业级应用前几篇构建的应用架构已经属于典型的传统应用，重数据层、重应用层，比如上的缓冲池、错误连接等，所以能够深入以业务级别来监控还需要专业的监控，而目前来说方面最最专业的肯定不是至少开发成本来说，而是   ，同时也是我本人研究的方向统称方向，由于本篇不是基础篇，搭建过程及基本设置请参考《基础篇》：=红色为已完成搭建，蓝色是本次文章涉及的区域：
 
、    根据基础篇准备好各项环境，第一个需要优化的就是系统相关监控项目，管理包的导入分为两种一个是主包，一个是语言包，语言包通常是后缀带_之类的，如下图需要先导入主包才可以导入语言包：

、    如何判断导入并应用是否成功？这里可以看两个地方：
    日志：

    看面板，将操作系统列调出，可以看到从原来未监控变成“正常”状态：

、    我们确认下相关的规则是否被正常创建：

、    现在就可以看到比平台更多的性能参数了，比如 、  这些重要的内存参数：
  
、    接着我们在创建一个自定义面板，来集中展示这些监控数据，就可以观察每台子机的内存使用情况，先新建一个管理包来集中收集变更的数据：
 
 
、    创建一个文件夹来集中安放这些面板，并选择放在新建的上：
  
 
、    默认会显示很多非必要的面板，这里做多一层优化，将多余的面板隐藏掉，点击查看——显示隐藏视图：
 
、    勾选必要的面板即可：

、    现在看起来就清爽多了：

、    选择新建仪表板：

、    选择网格布局并输入相关名字：

、    现在可以添加小组件：
 
、    这里要特别注意 组 与 计数器是有对应关系的：

比如在“ 服务器实例组”里可能不存在任何内存相关的计数器，这里可以通过打开某个计数器规则来检查对应对象
、    如果觉得计算机目标这块比较别扭，可以尝试更改下监控的对象：

更改成“性能视图”，这样可读性就高多了：
 
、    以下为成品仪表板左上为可用内存 性能视图、右边是视图、左下是内存警告，当服务器发生异常时可以结合警告查看问题原因：

：有个小坑，默认管理员账户若是 管理员，则默认权限的会丢失：

若不进行补全则会出现“          ”错误
： 安装 还有一个坑，默认的本地账户没有授权，需要手动授权，会出现以下提示：

所以需要在上手动执行以下命令：\ \  \ __  \最近由于想在的脚本组件中，调用的的相关接口，就需要弄明白和的实际对应关系，并对调用的部分原理进行了研究。
本文主要探讨和之间的关系，以及打包和 打包的差别在什么地方？找到这种差别之后，可以怎么运用起来？
本文需要用到的工具：

反编译工具——
 自带的反编译功能

一、将的编译成，的程序入口会是什么？

新建一个项目，创建一个，将工程编译打包成。
对编译出来的，利用进行反编译：  
得到的文件如下：

 = = =
 = = = = =
     = = = = =
     =_ = =_ = =_ =
         =|||||||||||| =_ = = =
            
                 =
                 =
                 =_
            
             = =
        
    
     =
     = =
     = =
     = =

由该文件可知，系统仍然存在主，名字为。
言下之意，编译只包含的工程，打包成 ，会以作为主程序入口，那么问题来了，如何加载显示到这个呢？
二、如何加载中的？
 
这个就要从源码入手了，工程中使用需要依赖到的插件位于安装目录，可以用软件查找查找得到，对其进行反编译得到的部分源码：
     {
      
        {
        
        
        
         =  
        
        
    }
}
虽然经过混淆，看起来比较费劲，但从代码可以看出，最终的界面显示需要依赖到的实例。另外由于也做了一套 的，与相对应的类，就是，下面也对它进行分析。
 从再入手分析
是推出的 中，用于实现 的类，通过查询其源码发现： 实际上的布局文件_
 = =
 =
    _=_
    _=_ 

    
        =__
        _=_
        _=_
        = 

布局文件中没有具体的内容，只包含一个布局。
重点看的函数：
      
      {
      {

        __

        

        _
_
         =  
         __  {
            _
                    _
        }

          
        

  }
}
作为加入到集合中进行显示，注意这里查找的是。根据官方对这个的解释：                       
由此可见，的实现原理，是创建一个只包含的空的帧布局，随后通过将中的加载到中进行显示。
看起来跟有异曲同工之妙，两者牵涉的类都是。
究竟是一个什么类呢？
对包进行反编译得到的部分代码：
       {
        = 
       {
        
           {
             = 
        }
    }
       {
            
    }
             
        

            {
           = 
           = 
          {
                {
               
                
            }
        }
    }
}
从代码中可以发现：

实际上是继承于；
并且自带一个的成员变量，在构造函数中，直接传入的相关参数；
在函数中直接返回该；
通过的构造函数，将其传递给，并赋值给其成员变量。

由于类做了混淆，关于渲染的核心功能也封装在代码中，关于转换到到作为，只能做一个简单的推测：通过调用的渲染引擎，在层进行渲染，并同步到在上进行显示。
三、 如何将显示在自定义的当中
从以上研究的内容可知，假如要从要实现将显示在固定的当中，则需要对的部分的和进行处理。最简单的方法是写一个直接继承于或的类，并在类中写所需要的调用的方法。这样就会加载在特定的当中， 通过获取变量就可以获取到该，并调用其中的函数。
四、   插件需要注意的问题

 工程包含多个的依赖，则需要将对应的编译的插件一起拷贝目录当中。
在第一步骤下，可以直接删除打包后的 目录，尤其里面假如带有的插件，否则会编译报错。
多个编译的时候，注意 相关设置，另外就是的信息。否则会出现 失败的错误。
关于的 文件合并：编写一个， 写一个包含主的包，放在目录当中。用编译出来之后，反编译他的文件两个主，默认显示包含的。解决方法：的文件合并，把一个放到目录下，就不会合并了。

五、打包 的结构探究
由于开发时，常常设计到  和 的环境切换，的开发往往会更快一些，更多的是 侧的代码编写和调试。
这种情况时，有没有一种方法，能够将编译好的 和相关文件，放到 中进行打包，从而实现直接在 中进行调试？
方法原理倒是很简单，通过对比打包的，与普通的 的文件差别，找出文件存放的目录，随后对应存放到 工程目录中，最后通过 完成对相关文件的打包。
首先将添加的后缀，方便用 进行对比：

发现只是多了目录，在这个目录之下，可以看到相关库
将该文件，拷贝到 工程的目录之下；
在 调试时，可以将 工程设置为工程，这样就可以编译运行到手机了。
用 对该工程进行编译，发现目录成功被打包进去。
直接  运行，可以看到跟编译打包的，是相同的效果。

相反，假如工程调试好之后，则直接编译成模式修改成模式，进行之后，就会生成库，此时将库拷贝到目录当中，注意要删除库中的，因为这个目录是我们先前从拷贝过去的，假如不删除，在里面会出现重复打包导致的文件冲突的情况。
由于当将打包之后的目录拷贝到 工程之后， 此时是一个工程，需要转换为工程。关于这其中涉及到的  和的转换，通过设置文件来实现：

模式：   
模式：    

不过在设置这两种模式时，需要注意 的设置，假如是模式，则需要直接注释掉。
假如的部分重新调试好之后，重新将模式改成模式，进行，将生成的包，拷贝到  目录中，就可以直接在看运行效果了。不过一定要记得删除 打包的文件里面的目录，以防止在中重复打包。
四、结论：

中的在中，其实对应于的，每个的运行都有其环境，通过变量可以获取得到。
要实现自定义的能够具备直接加载的功能，则需要其继承于或者，再或者，直接自定义实现类。
提升 项目开发效率的方法：● 直接将打包的中的目录拷贝到 工程的目录当中，并且将工程配置成模式，就可以直接在 上面，对整个 的工程进行调试。●  部分调试好之后，需要修改文件，重新将模式修改为模式，编译出包文件，删除原来拷贝过来的部分，放入到的目录下进行使用即可。

最后套句名言：打得好，解得早

相关推荐
【腾讯云的种玩法】安卓加固在腾讯云上的使用附反编译结果
深度了解  ，你准备好了吗？导语： 抽样作为统计学中非常常用的一种方法，在当前数据化运营的大背景下，被有效得应用在样本不均衡，快速的概念验证等方面抽样包含概率抽样和非概率抽本文主要介绍不同的概率抽样方法的核心思想优缺点以及相关的应用场景。

概率抽样也称为随机抽样，指在总体中排除人的主观因素，给予每一个体一定的抽取机会的抽样。 其特点为，抽取样本具有一定的代表性，可以从调查结果推断总体；概率抽样方法主要分为以下几个类别：
简单随机抽样  
简单随机抽样也称为单纯随机抽样、纯随机抽样、抽样 是指从总体个单位中任意抽取个单位作为样本，使每个可能的样本被抽中的概率相等的一种抽样方式
场景一：
数据源：例如我现在有一个包含的号码包数据集，数据量万，需要随机抽样万去做测试
数据源示例：

由于号本身的所有数据都是有差异的，不存在周期性的特性，并且是数值型的数据，所以可以采取取模的方式来进行随机抽样，用实现的简单示例如下：
 
 _
 =
 
场景二：
数据源：例如我现在有一个包含的号码包数据集，数据量万，需要随机抽样万做测试
数据源示例：

核心思想 ：由于不属于数值型数据，我们可以采取为当前的数据源随机生成一个随机序列，再根据序列随机选择指定量级的数据的方式来实现随机抽样
代码实现方式
方法：
     _      
方法：
   
         
  _       
   _            
  _
    
 函数产生一个到的随机数字，上述两种方式都是使用函数和关键字来获取样例数据，只是在实现细节上略有差异
方法：
   _         
使用和关键字来保证数据是随机分散到和的，  语句可以获取同样的效果，但是性能没有那么高 
简单随机抽样的特点是：每个样本单位被抽中的概率相等，样本的每个单位完全独立，彼此间无一定的关联性和排斥性
 系统抽样   
也称等距抽样。将总体中的所有单位按一定顺序排列，在规定的范围内随机地抽取一个单位作为初始单位，然后按事先规定好的规则确定其他样本单位。先从数字到之间随机抽取一个数字作为初始单位，以后依次取、……等单位。这种方法操作简便，可提高估计的精度，系统抽样按照具体的实现方式分为以下两种：
无序系统抽样：对总体采用按无关标志的等距抽样，即总体单位的排列顺序和所要研究的标志是无关的，是一种更好的纯随机抽样方式，如现在要调查玩家的充值水平，按照玩家的账号的数字串大小进行排列玩家的账号本身与充值水平不存在直接的关系
数据源例如现在有个包含，等级，充值金额三个属性的万号码包，需要选出万个测试用户
数据源示例：

代码实现方式：用开窗函数对数据源进行排序，然后用取模这种比较简洁的方式来选取对应的数据，由于要在万数据中选择万数据，则数据选择间隔为，假设从第一个位置开始选取
 
 

  _   
 _
_
 =
有序系统抽样：对总体采用按照有关标志的等距抽样，即总体单位的排列顺序与所要研究的标志有直接的关系，它能使标志值高低不同的单位，均有可能选入样本，从而提高样本的代表性，减小抽样误差，如现在要调查玩家的充值水平，按照玩家的充值金额大小进行排序玩家的充值金额实际就代表了玩家的充值水平
数据源同所示
代码的是实现方式 与无序排序的代码基本一致，只是我们是按照充值金额去排序
 
 

  _   
 _
_
 =
 系统抽样的特点：抽出的单位在总体中分布均匀，且抽出的样本可少于随机抽样，最大的优势在于 经济性
分层抽样   
分层抽样是将抽样单位按某种特征或者某种规划划分为不同的层，然后从不同的层中独立、随机的抽取样本。将个层的样本结合起来，对总体的目标量估计，样本的结构与总体的结构比较相近，从而提高估计的精度，例如现在要调查不同等级的玩家的战力分布情况，数据源包含玩家的等级，战力，则需要按照等级将玩家划分到不同的层级中，再从不同层选取指定数量的用户进行分析
数据源：包含 三个关键信息，总数据量万，需要抽取划分的每个年龄段个用户
数据源示例：

代码的实现方式：
  

   
 
     _ 
 _ 
_
     _ 
_ 
 _=
分层抽样的优缺点：样本的代表性比较好，抽样误差比较小，缺点是抽样手续较简单随机抽样要繁杂
 整群抽样  
整群抽样又称聚类抽样是将总体各单位归并成若干个互不交叉、互不重复的集合，称之为群，然后以群为抽样单位进行单纯随机抽样抽取个体的一种抽样方式。
整群抽样与分层抽样存在直接的差异：分层抽样要求各层之间的差异很大，层内个体或者单元差异小，整群抽样是要求群与群之间的差异小，群体之间的单元差异大分层抽样的样本是从每个层内抽取若干单元或者个体构成的，而整群抽样则要么是整群抽取，要不整群不被抽取
图示说明如下蓝色圆形，紫色菱形，蓝色圆柱形代表不同类别的用户：
整群抽样

分层抽样

多级抽样  
多级抽样又叫多阶段抽样，是梳理统计的一种。在复杂的，大规模的市场调查中，调查单位不是一次性直接抽取的，而是采取两阶段或者多阶段的方法，先抽取大的单位，在大单位中再选取小的单位，然后再逐层选取的方式，这种抽样方式称为多级抽样
在多级抽样的各个阶段，均可以采取简单随机抽样或者分层抽样应用场景举例说明，现在需要完成全国大学生人口抽样，可以分为几个阶段进行，首先以省为抽样框，抽取一部分，然后在抽取的省中，再以市为单位进行抽样，抽出若干，然后逐层递进
多级抽样所面临的都是个体数目十分庞大而且分布区域又十分广泛的总体
特殊采样方法补充：
在某些分类场景下，如对回流用户和流失用户做逻辑回归时，回流用户中的样本数量极少，而流失用户中样本数量极多，就形成了类不平衡的问题
解决类不平衡，可以采用以下两种方案：
过采样对训练集中样本数量较少的类别少数类进行过采样，合成新的样本来环节类不平衡
欠采样对训练集里面样本数量较多的类别多数类进行欠采样，抛弃一些样本来缓解类不平衡的问题
在中介绍的方法都可以用来实现欠采样，而对于过采样，可以采用   的方法来处理，即合成少数类过采样技术。它是基于随机过采样方法的一种改进方法，基本思想是对少数类的样本进行分析并根据少数类样本人工合成新样本添加到数据集中，合成的策略是对每个少数样本，从它的最近邻中随机选择一个样本，然后在、的连线上随机选取一个点作为新合成的少数类样本，具体的算法步骤如下：
对于少数类中每一个样本，以欧氏距离为标准计算它到少数类样本集中所有样本的距离，得到近邻对于每一个少数类样本，从其近邻中随机选择若干个样本，假设选择的近邻为。对于每一个随机选出的近邻，分别与原样本按照如下的公式构建新的样本。














 由于算法本身的局限性，存在边缘化和盲目性等问题很多人纷纷提出了新的改进办法在一定程度上改进了算法的性能但还存在许多需要解决的问题，这里只是抛砖引玉，就不再赘述作者 | 周东谕编辑 | 京露

周东谕，年加入腾讯，现任职于腾讯互娱运营部数据中心，主要从事游戏相关的数据分析和挖掘工作。            

引言
上一篇文章《一条搞定信息增益的计算》介绍了在机器学习特征工程中，如何使用来进行信息增益的计算。卡方检验作为一种数理统计中的假设检验方法，也常用于特征选择中。本文简单介绍了卡方检验的原理，并用 实现卡方检验值的计算。
卡方检验原理
卡方检验最基本的思想就是通过观察实际值与理论值的偏差来确定理论的正确与否。对应到我们实际工作中，我们的理论假设是：假设某特征如性别、年龄分布与值以二分类为例，是否流失、是否付费，通常用表示的分布相互独立，通常我们把这个理论假设叫做“原假设”，用一句通俗的话来解释就是“用户是不是流失跟他她的性别没有关系”。
然后我们手上有一堆样本数据了，我们要通过观察样本数据来判断我们的“原假设”是否成立。如果不成立，我们就要推翻“原假设”，证明实际情况是“用户流失跟他她的性别可能有关系”。卡方检验值就是用来上述假设的值。它的计算公式如下：

为例便于理解，公式还是以“性别对于用户流失是否有影响”为例进行描述。其中表示特征的枚举，是枚举。表示特征和划分下的数据量，用描述就是特征维度和维度进行 后的量。从这里可以看出，卡方检验要求特征值为离散型的。表示期望值，以特征为，为为例，计算其期望值如下：

这样分别求出特征与各种组合下的期望以及该特征的卡方值。还是以上文的一个例子来描述这个计算的过程：
数据如下：

统计数据如下：

根据统计结果，我们可以计算得如下表：

一共项，每一项表示特征与各种组合下卡方值，然后求和得每个特征的卡方值：

通过查卡方值的值表，我们可以看出来，性别的卡方值小于=的较为宽泛假设卡方值，此时我们要支持原假设，认为性别和是否流失相互独立的，不存在关联。而活跃度的卡方值大于=，此时我们要否定原假设，支持活跃度和是否流失可能相互不独立。

从结果来看，活跃度的卡方值更大，所以我们得出的结论是用户活跃度的大小和他她是否流失关系相对于性别特征来说更大。
代码及说明：


__  _


    
    _
    _
    
    推导以后
      _
    
    
         __ 
        
        
             __    ___
              __
          
        
             _    ___
              _
          _=_
     
      
    

         __    ___
          __
      _=_  _=_  =
      
    
         _    ___   _
      _=_
  _
参考文献：
 机器学习特征选择之卡方检验与互信息


相关推荐【文智背后的奥秘】系列篇——自动文本分类【文智背后的奥秘】系列篇——情感分类  介绍
之所以在机器学习方面具有得天独厚的优势，有以下几点原因：
机器学习算法一般都有很多个步骤迭代计算的过程，机器学习的计算需要在多次迭代后获得足够小的误差或者足够收敛才会停止，迭代时如果使用  的  计算框架，每次计算都要读写磁盘以及任务的启动等工作，这回导致非常大的  和  消耗。而  基于内存的计算模型天生就擅长迭代计算，多个步骤计算直接在内存中完成，只有在必要时才会操作磁盘和网络，所以说  正是机器学习的理想的平台。
从通信的角度讲，如果使用  的  计算框架， 和  之间由于是通过  的方式来进行的通信和传递数据，会导致非常慢的执行速度，而  具有出色而高效的  和  通信系统，通信效率极高。
   是  对常用的机器学习算法的实现库，同时包括相关的测试和数据生成器。 的设计初衷就是为了支持一些迭代的  这正好符合很多机器学习算法的特点。 目前支持  种常见的机器学习问题 分类、回归、聚类和协同过滤， 在  整个生态系统中的位置如图下图所示。

笔者希望将上述几类算法进行整理，完成   一个系列的算法介绍，供大家一起分享参考，作者才疏学浅，资料里难免出现错误，如有发现请不吝指正，谢谢！
参考文献：商业转载请联系腾讯获得授权，非商业转载请注明出处。原文链接：
 导读
十一月临近，一年一度的电商大戏“双十一”又将隆重出场，目前各大商家已经开始各类优惠券的发放，各类大促的商品表单也已经提前流出，即将流入各个用户的购物车中。
作为这些活动的载体，产品宣传、商品购买、交易结算、客户反馈以及售后服务都是电商产品包括网站、、小程序等形式非常重要的功能，但当双十一临近，电商产品要面对大量级用户群体涌入，流量猛增的局面，性能表现往往就成为了成功的关键。

双十一的流量挑战
在优化电商产品的性能表现前，首先要了解一下电商产品的访问逻辑，以电商网站为例：
电商网站的核心内容，包括了服务器、应用服务器和数据库服务器，其中前端服务器负责接收并处理来自用户的请求，并生成页面反馈给用户；中间的应用服务器负责执行其中的业务逻辑；后台数据库和文件服务器负责存储用户、产品信息及状态。
为了提升访问的性能，有的网站会在数据库服务器前部署数据缓存设备。外围部署负载均衡服务器，负责在海量用户访问与多台服务器间进行负载分担。
对于电商产品来说，当流量变高，成百上千的服务器和其他设备面对海量用户的访问，会遇到这样的场景：有的用户在不断查询商品信息，有的用户在注册会员，有的用户在修改购物车信息，有的用户在下单付款，有的用户在秒抢商品，等等。
此时若不重视承载能力，会造成严重的后果。比如国庆期间鹿晗公布恋情导致微博宕机，以及过去几年新机发布导致官网崩溃，都是由于对流量突增没有足够的承载能力导致的。

而这些现象，都给用户带来了很大的困扰，而且用户体量越大，影响的波及面就越广，不仅影响用户口碑，也影响产品收入。如果把产品的月收入平摊到每一分钟的话，大家可以通过分钟，分钟，乃至小时，小时计算具体的损失金额，还要加上因此产生的用户流失以及品牌口碑影响。
所以，如何在“双十一”这样火热的节点保证用户顺畅访问网站，成了一个重大的挑战。
电商产品的压测方案
那么，怎么样才能让电商网站在面对活动流量高峰的时候能够提供正常服务呢？容量规划，压力测试以及压测环境的配置是电商网站必须要经历的考验。
尤其是压力测试，是整个电商网站活动前的实战演习，能够提前预知网站性能表现的瓶颈与故障点。
一、预估流量情况
电商网站背后的系统通常分为两部分，一部分是导购，主要的作用是为用户推荐各式各样的商品，提供搜索服务，给用户挑选商品带来便利；另一部分就是交易，简单来说就是电商网站下单、抢购等活动的过程。
两部分的流量形式是不同的。导购部分的流量会呈现为一个慢慢上涨的曲线，对于服务器来说，流量的压力是慢慢增加的；而交易部分的流量，却是陡然上升的，特别是在某个抢购活动中，压力会瞬间增长到一个高峰，没有给人和机器任何的反应和决策时间，这也是电商产品承载能力要求比其他的产品高的重要原因之一。
但是这个高峰会是多少？很多人在事前并不知道，如果要模拟真实的压力场景，不同的压力造成的测试成本都不同，定高了，成本高，定低了，没效果，因此要想让压力测试既能满足足够的流量压力，又把测试的成本压缩到最小，活动筹备之前对于流量的预估非常重要。
阿里巴巴在双十一活动前通常也会进行压力的预估，将其叫做”容量规划“。活动流量会有多少？峰值会到多少？电商网站的开发人员需要心里有数。
二、场景化压测
在实际电商活动开始后，用户会从四面八方涌入产品，如何去模拟用户的真实行为，形成一个最接近真实的压测场景是电商产品压测第二件需要做的事情。
电商产品通常有很多接口，用户在访问过程中可能接触其中的某几个接口，一种压测的方式就是针对这所有的接口进行统一的压测，增加相同的压力，算出一个系统的容量，然后再根据这个系统的容量情况扩展到一个个集群。
这种方法有一个缺陷，就是如果这个系统某个接口出现了问题，整个集群都会崩溃。
而场景化压测可以避免这类问题。在实际的压测场景中，流量很大一部分都会被分流，由于每个用户的购物流程都不一样，因此对于电商网站上的接口受到的压力都会不同，可以实现用最少的服务器支撑最大的流量。
那么，一般电商购物会有哪些场景呢？以下举三个例子。
场景一：登录注册，访问个人中心
用户在进入电商产品后，会有查看自己订单情况的需求，因此，“登录“”注册“以及”个人中心“会成为流量较高的接口。
场景二：商品遍历
“商品遍历“指的是用户在下单购买前，对不同的商品页进行访问的过程，而此时用户已经进入了登录状态，会带着登录态对不同的页面进行访问，此时不同的商品页面接口会承受比较大的压力。
场景三：购买下单
这可能是电商网站并发压力最高的一个接口，购买按钮，购物车页面以及付费接口都会面临很大的瞬时压力。
在确认完“双十一“活动中承受压力可能最高的几个场景之后，产品开发或测试人员就可以根据场景配置相应的测试用例了。
三、线上压测配置
配置测试用例，实现真实压力，通常需要一个能够真实模拟海量用户的测试工具，压测大师为电商行业提供了一个适用的测试环境，提供了”上下文变量“、”全局参数化“等功能，可以满足电商产品大部分的测试需求。
“上下文变量“实现”用户登录”、”购买下单“场景
“上下文变量“实现的是将用户登录时的用户信息传输到下一个页面中，对于电商平台来说，可以真实模拟用户登录后，点击了”购买“，进入了购买页面。以下是操作介绍：
、进入压测大师首页，选择一个已有的项目进入，如没有项目可以新建项目
、创建一个新的测试，如下图：
、在测试设置部分，填写压力预估的最大人数
这里当配置人数大于时，为防范非法攻击等现象，需要对被测域名进行认证，点击域名认证按照提示认证即可。
、在“客户端请求“点击”上下文变量“，开始配置
、 “上下文变量设置“是为了实现之间参数信息的传递，因此需要点击右下角的”一个请求“增加一个，然后保证第一个的”变量名“与第二个的字段保持一致
、“提取方式“通常选择”键值对“较多具体使用可根据实际情况，选择想要传递信息的”名称“，确定”提取规则“。”提取规则“中所填写的就是传递到下一个页面的信息，比如电商平台用户的会员信息。
那么”提取规则“应该填写什么呢？我们需要在页面中去寻找这个”键值“。
首先在浏览器中输入第一个，点击，点击，刷新一下页面之后点击最左侧的”_“，找到对应的““后面_后的值，就是我们将要传输给下一个的信息。
、完成了”上下文变量“的设置之后，在“测试模型“中的场景中选择”上下文“模式，分别输入两个。
、 如果自有服务器，则可以在“服务器监控“的”添加监控“中设置服务器信息；如果没有，则可以点击”立即执行“开始测试
“全局参数化“实现”商品遍历“场景
“全局参数化“实现的是通过自动更改”“字段中的参数，实现遍历电商平台上所有商品页面，对电商平台上所有的商品页面模拟真实的用户压力。

、点击右上角的“全局参数化“的设置按钮，开始设置全局参数化
、点击“添加“，添加参数，将参数名修改为想要测试的字段，比如上面的”“字段。另外参数化形式中有”自增“、”随机值“和”定长“三种配置方式。
“自增“可以设置”最大值“和”最小值“，比如最小值设置，最大值设置，就可以自定义服务器压力，遍历电商平台上参数值为的所有商品；
“随机值“可以实现在自定义范围内随机对某商品页面进行压力测试；
“定长“通过设置一定长度下的数值，在这个范围内的所有商品页面进行随机的压力测试，比如定长设置为，则会在”“”“之间进行随机的压力测试。
“全局参数化“可以设置”自增“、”随机值“和”定长“三种形式

“全局参数化“下的”定长“参数设置
对电商平台来说，要进行压测的部分不止是遍历所有商品页还有模拟真实用户购买那么简单，还会有搜索，聊天，收货，评价等更多的功能，本文通过两个简单的场景示例，可以帮助电商网站把测试成本降到最小，把测试效果放到最大，避免让电商平台的买家因为无法付款而流失。
做好这些，才能做出完整的电商产品。

压测大师 服务了包括王者荣耀、龙之谷手游、火影忍者等多款高星级手游， 、直播等明星产品，更是服务了携程、京东、特仑苏以及各类规模的电商产品，此次推出”电商行业压测解决方案“，希望能够帮助开发者真实模拟电商用户使用场景，帮助开发者发现服务器端的性能瓶颈，进行针对性的性能调优。在保证用户流畅体验的同时，也能降低服务器采购和维护成本，实现用户与电商开发者的技术共赢！
“压测大师”目前已经开放对外，目前更有低至四折的时效资源包优惠，欢迎大家的使用！
体验地址：
如果对使用当中有任何疑问，欢迎联系腾讯企业：作者：阮一峰

眼下最热门的技术，绝对是人工智能。
人工智能的底层模型是神经网络 。许多复杂的应用比如模式识别、自动控制和高级模型比如深度学习都基于它。学习人工智能，一定是从它开始。

什么是神经网络呢？网上似乎缺乏通俗的解释。
前两天，我读到   的开源教材《神经网络与深度学习》    ，意外发现里面的解释非常好懂。下面，我就按照这本书，介绍什么是神经网络。
一、感知器
历史上，科学家一直希望模拟人的大脑，造出可以思考的机器。人为什么能够思考？科学家发现，原因在于人体的神经网络。


外部刺激通过神经末梢，转化为电信号，转导到神经细胞又叫神经元。
无数神经元构成神经中枢。
神经中枢综合各种信号，做出判断。
人体根据神经中枢的指令，对外部刺激做出反应。

既然思考的基础是神经元，如果能够人造神经元 ，就能组成人工神经网络，模拟思考。上个世纪六十年代，提出了最早的人造神经元模型，叫做感知器，直到今天还在用。

上图的圆圈就代表一个感知器。它接受多个输入，，，产生一个输出，好比神经末梢感受各种外部环境的变化，最后产生电信号。
为了简化模型，我们约定每种输入只有两种可能： 或 。如果所有输入都是，表示各种条件都成立，输出就是；如果所有输入都是，表示条件都不成立，输出就是。
二、感知器的例子
下面来看一个例子。城里正在举办一年一度的游戏动漫展览，小明拿不定主意，周末要不要去参观。

他决定考虑三个因素。

天气：周末是否晴天？
同伴：能否找到人一起去？
价格：门票是否可承受？

这就构成一个感知器。上面三个因素就是外部输入，最后的决定就是感知器的输出。如果三个因素都是 使用表示，输出就是去参观；如果都是 使用表示，输出就是不去参观。
三、权重和阈值
看到这里，你肯定会问：如果某些因素成立，另一些因素不成立，输出是什么？比如，周末是好天气，门票也不贵，但是小明找不到同伴，他还要不要去参观呢？现实中，各种因素很少具有同等重要性：某些因素是决定性因素，另一些因素是次要因素。因此，可以给这些因素指定权重，代表它们不同的重要性。

天气：权重为
同伴：权重为
价格：权重为

上面的权重表示，天气是决定性因素，同伴和价格都是次要因素。
如果三个因素都为，它们乘以权重的总和就是      = 。如果天气和价格因素为，同伴因素为，总和就变为      = 。
这时，还需要指定一个阈值。如果总和大于阈值，感知器输出，否则输出。假定阈值为，那么   ，小明决定去参观。阈值的高低代表了意愿的强烈，阈值越低就表示越想去，越高就越不想去。
上面的决策过程，使用数学表达如下。

上面公式中，表示各种外部因素，表示对应的权重。
四、决策模型
单个的感知器构成了一个简单的决策模型，已经可以拿来用了。真实世界中，实际的决策模型则要复杂得多，是由多个感知器组成的多层网络。

上图中，底层感知器接收外部输入，做出判断以后，再发出信号，作为上层感知器的输入，直至得到最后的结果。注意：感知器的输出依然只有一个，但是可以发送给多个目标。
这张图里，信号都是单向的，即下层感知器的输出总是上层感知器的输入。现实中，有可能发生循环传递，即  传给 ， 传给 ， 又传给 ，这称为递归神经网络  ，本文不涉及。

五、矢量化
为了方便后面的讨论，需要对上面的模型进行一些数学处理。

外部因素 、、 写成矢量 ，简写为 
权重 、、 也写成矢量   ，简写为 
定义运算 ⋅ = ∑ ，即  和  的点运算，等于因素与权重的乘积之和
定义  等于负的阈值  = 

感知器模型就变成了下面这样。

六、神经网络的运作过程
一个神经网络的搭建，需要满足三个条件。

输入和输出
权重和阈值
多层感知器的结构

也就是说，需要事先画出上面出现的那张图。

其中，最困难的部分就是确定权重和阈值。目前为止，这两个值都是主观给出的，但现实中很难估计它们的值，必需有一种方法，可以找出答案。这种方法就是试错法。其他参数都不变，或的微小变动，记作Δ或Δ，然后观察输出有什么变化。不断重复这个过程，直至得到对应最精确输出的那组和，就是我们要的值。这个过程称为模型的训练。

因此，神经网络的运作过程如下。

确定输入和输出
找到一种或多种算法，可以从输入得到输出
找到一组已知答案的数据集，用来训练模型，估算和
一旦新的数据产生，输入模型，就可以得到结果，同时对和进行校正

可以看到，整个过程需要海量计算。所以，神经网络直到最近这几年才有实用价值，而且一般的  还不行，要使用专门为机器学习定制的  来计算。

七、神经网络的例子
下面通过车牌自动识别的例子，来解释神经网络。

所谓车牌自动识别，就是高速公路的探头拍下车牌照片，计算机识别出照片里的数字。

这个例子里面，车牌照片就是输入，车牌号码就是输出，照片的清晰度可以设置权重。然后，找到一种或多种图像比对算法，作为感知器。算法的得到结果是一个概率，比如的概率可以确定是数字。这就需要设置一个阈值比如的可信度，低于这个门槛结果就无效。一组已经识别好的车牌照片，作为训练集数据，输入模型。不断调整各种参数，直至找到正确率最高的参数组合。以后拿到新照片，就可以直接给出结果了。

八、输出的连续性
上面的模型有一个问题没有解决，按照假设，输出只有两种结果：和。但是，模型要求或的微小变化，会引发输出的变化。如果只输出和，未免也太不敏感了，无法保证训练的正确性，因此必须将输出改造成一个连续性函数。这就需要进行一点简单的数学改造。首先，将感知器的计算结果  记为。
 =   然后，计算下面的式子，将结果记为σ。
σ =     
这是因为如果趋向正无穷 → ∞表示感知器强烈匹配，那么σ → ；如果趋向负无穷 → ∞表示感知器强烈不匹配，那么σ → 。也就是说，只要使用σ当作输出结果，那么输出就会变成一个连续性函数。
原来的输出曲线是下面这样。

现在变成了这样。

实际上，还可以证明Δσ满足下面的公式。

即Δσ和Δ和Δ之间是线性关系，变化率是偏导数。这就有利于精确推算出和的值了。正文完

原文链接作者：秦策

一、 流简介
   作为现代浏览器的基础，其设计和实现方式影响着整个浏览器的表现。对安全研究者而言，了解 的结构更是有着特殊的意义。在对  结构有了了解之后进行相关漏洞的分析，分析工作将会有一个清晰的脉络和方向，使得分析工作变得更加简单，对漏洞的理解也会更加深刻和具体。
 作为一度占据很大市场份额的主流浏览器其  的组织和结构值得我们去研究一番。 浏览器在刚刚推出时还只是实现简单的文本解析功能，随着页面功能的丰富和各种新特性的加入， 浏览器的功能也变得越来越复杂，但是作为浏览器骨架的  结构却仍然延续了最初的设计，微软尝试通过不断添加新的属性以优化其表现使其适应现代浏览器的功能需要。
出于以上的历史原因， 浏览器的  结构并不是一个真正意义上的树结构，而是被设计成为一个流结构，页面内容解析出的节点在逻辑上以线性形式排列，对于  的访问和修改均以流的方式进行。微软在有关 的设计文档中描述了这一特点 。
以如下  文档举例
   按照树形结构进行构建，上述页面会被解析成如下的一棵树
          
            |
      
      |     |      |
           
            |
          
但是如果将上述页面进行修改变成
      在这个页面中标签和  标签相互嵌套，这样一来页面便无法被简单的表示成为树结构，此时便选择使用流来表示页面，并通过范围操作操作页面内容。
本文将通过对   版本浏览器进行分析和逆向，阐述  中  的结构，以及这种结构如何在浏览器中发挥作用。为了方便描述下文统一将  文档中的标签成为 ，而将由  解析而的到的对象称为。
二、 流的结构
在  的  流中，页面元素  并不直接相关联，而是间接通过一个叫做  的类来完成这一功能。 类结构如下本文中所列出的数据结构和函数均根据   逆向而来，、、 中有所不同， 但是核心思想均是相同的
 
{
 
      
      
            _                                     
            _                 
            _                      
            _               
            _            
            _                   _ = 
            _                   _ = 
            _             
           _                                    
                                                  
           _                                     
           _

        _
        _
          
          
          
}
每个  都与一个  相关联。一个中包含了两个  结构，分别在逻辑上代表着一个  对应的  的头标签和尾标签，这些  按照  在  文档中的排布顺序依次前后相连， 流即是这些  对象链接而成的双向链表。
 对象结构如下，其中 _、_用于构建  流；_ 表示当前 代表的  在页面中左边有多少个字符，可以看做 在  流中的 这里需要经过计算。
 
{

           _ 
           _            左子树中的字符数量
       _      
       _           
       _                当前  在  流中的左边
       _              当前  在  流中的右边
}
以具体的例子来说明  中  流的情况。考虑如下页面

    
       
    

上述页面经过  解析之后构成如下所示的  流，每个  与一个 相关联，的两个  分别按照其  在页面中的排布前后相连， 的  与  的 之间省略的部分为页面解析时自动补全的  
                          
   |         |          |                |              |             |         |
                                 
   |         |          |                               |             |         |
   |         |                       |         | 
   |         |                                                |         |
   |         |                                                        |         | 
   |                  | 
   |                                                                            |
    
三、 流的遍历
为了将页面内容与解析出  流关联起来， 需要使用一个容器类来对  流进行管理，这个容器类称为 。在页面开始解析时， 会默认创建一个  用于管理解析过程中产生的一系列  节点和  操作，此后每一次针对  的操作均需要为其指定一个 ，该次操作的  流即为这个  管理的 。
 浏览器在访问页面  流时也按照流的规范进行，为此  使用一个名叫  的对象来作为  流的迭代器。 顾名思义是用于指示 即 流中位置的指针。并不是 流的一部分，多数情况下它都是作为临时变量来使用。 可以被放置于页面的这些位置： 的开始、 的结束或者  之中。由于 本身不包含内容，因此如果两个  指向了同一个位置便会难以区分。的放置工作通过 函数完成。函数原型如下
 
     
    _


     _ {
         __
         __
         __
         __
    }
一旦 被放置在了文档中， 浏览器便可以通过它来获取其所指向位置中  流的相关信息。这个功能使用  函数实现，函数原型如下
 
     
     
    __ 
     
     
    _ 


第一个参数指定获取指针右边还是左边的信息
第二个参数指定指针是否可移动，若不可移动，则函数仅仅会返回指针周围内容的描述；否则，函数 在返回周围内容描述的同时还会移动过去。
第三个参数为返回值，返回周围的内容类型。











__
左边或者右边没有东西



__
左边或者右边是一个



__
如果是，则左边是一个 ；如果是，的右边是一个  。



__
如果是，则左边是一个 ；如果是，的右边是一个  。



__
的左边或者右边不是一个可以成对的标签





第四个参数返回  左边或者右边的
第五个参数用来限定读取的范围，同时也用来返回获取的 的大小
第六个参数返回 左边或者右边的 
下面以具体的页面举例说明

      对于页面上的五个 分别调用函数，调用的参数及结果如下表







 
 























































































下面通过实际的  操作来说明  是如何通过 来对流结构进行遍历的
，，，
 中可以通过  的这四个函数获取一个  周围  的信息，这里以  作为典型来说明，在   中的函数逻辑如下所示
    
{
    
   
   

   = 
       创建 

   =   __     放置 
       == _ 
    {
       = 
       = _           通过  获取 
    }

   =  
  
   
}
函数首先新建一个  对象，接着将该  放置于目标节点的 __ 位置，而后通过该 来检查周围的内容，这里使用 函数来获取  所指的位置的对应节点信息。逻辑上来说即 __
 、 、 其函数逻辑也大体相同，有所区别的即是在调用  时的传入参数，分别为 __、__、__
这里也非常容易理解，以如下页面流为例子。调用  ，首先使用一个  对象指向在  的 __位置，即下面页面中的位置，再调用  获取  右边的内容，即为下面页面中的标签，其他同理。


 节点属性则是通过  遍历对应  节点而实现，在   中其主要的功能函数为  ，该函数逆向后主要功能代码如下
__ 
{
      = 
         
          
     
      =   __     放置 
      =   __     放置 
     {
        
         = 
         
         =   __     放置 
        
        }  
    
}
通过两个  指针分别指向  的开始位置  和结尾位置 ，并从其开始位置开始依次遍历 ，其间所有的节点均为  的子节点。

接《 浏览器  树结构概览下》请原谅我标题党了，这年代不标题党没法混啊。。。  
其实事情很简单，先介绍一下背景，背景是我们  或者  上跑  任务，一通计算之后，结果总要落地，一般落地到 ，而具体到我们这次的场景中，我们用的是 ， 全称是 ，是一个  版本的 ，可以参考这个简介《开源基于的数据库》 ，协议上兼容 ，我们可以用普通能连  的方式去连 ，并且把  看成一个黑盒的集群版本的  来使用。
然后这次的优化的手段也很简单，就是从原来的  连接拼  改成用 ，类似  命令行下的 \ 命令，所以一句话就能说完，而写这个文章的点主要是分享一下这个过程中的一些思路历程和细节。
先看效果，优化前，我们的耗时如下

优化后

对比图

作为对比，我们原先的数据写入方式是  连上之后拼  语句，应该说这种方式在  场景下是很适用的，但是在  场景下效率问题就开始显现出来了，耗时不仅仅产生在写入端拼   的开销上，更重的是在   端去   的耗时成本，以及附带衍生的事务，回滚日志等开销成本。
那么  作为一个立足于大量数据处理的 ，肯定要对数据的  有一个解决方案的，官方是怎么来解决这个问题的呢，看到这里，_ ，官方主要提供了几种方案：

            
         
        

其中，外部表的方式可以通过以下几种实现达成

：                    
：     
               
：         

 可以把一个外部机器上的数据文件让所有  节点能访问到，因而就可以并行的载入数据， 是一个安全版本的 ，但是这种方式存在一些问题考量：

需要在  节点上额外安装部署程序
不兼容  本身就没有  节点的概念，囧

所以没有选用，而  这种方式，能够让  连上  去读数据，也是并行的，但是出于以下考量也最终没有采用

我们的  的  带了自定义的鉴权
我们在  表中的存储格式并不是平坦的二维表，由于指标的值稀疏，我们使用的是类似  的  的存储格式，而这种形式并不利于直接表对表的拷到  中成为一张平坦的表

而  其实就是一个外部表的载入界面封装

         ’      

所以最终我们的选择就落在了  上，用  的好处主要是
是  的标准工具，无缝兼容  与 ，一次干活到处使用不需要额外的依赖与安装部署，对目标  没有特殊要求虽然，在官方的介绍中说了  是一个非并行的工具，但是，实测下来， 的效率并不低
用  有两种方式，一种是在命令行上用，参考  ，另外一种，是引入  包，在代码中用，参考  ，可以看到他在函数的  上说了

              

这也说明这个工具的作者是很自信的笑
可以看到这个函数有两个重载
   
                    
             
                   
 和
   
                    
             
                   
 那么自然的问题就是，从  中读取和从  中读取有什么区别？
参考这个文章， _ ，其实，二者的主要区别在于：

提供的是字节流的读取，而非文本读取，这是和类的根本区别。即用读取出来的是数组或者 ，使用读取出来的是数组。

也就是说，他们一个是面向字节的，一个是面向字符的，而面向字符的自然就要面临一个问题就是字符的编码方式的选择问题，以及解码和编码的开销成本问题，所以从效率上来说，我们应该是选用面向字节的方式
去看他的源码实现也可以发现
            {
          =  
         
          = 
         {
                  =     {
                          
                }
                 
        }  {            
                
                        
        }
}
 对于  的方式，直接读进来就可以用了
            {
          =  
         
          = 
         {
               =    {
                  =    
                  
            }
             
        }  {            
            
                
        }
    }
而对于  的方式，读进来之后还要  处理一下，进一步验证了我们的想法
接下来，就可以得出一个使用方式的  代码了，我们的根本需求是把计算结果写入，所以应该是  ，但是，由于需要转成一个 ，所以我们需要转而接受一个  的入参
所以到目前为止可以得出代码如下
      = {
       = 
     {      
      
             
       =   
        =  
       _ =    
        = 
        = _ 
        = 
                    
      
      
    }  {
         =        
    }  {
       {
          =  
      }  {
           = 
      }
    }
  }

      = {    
      =  
            
      =  {
        = 
        = 
                 {
            ==  \\  \
      }
    }
      = 
                  
     _
  }
以上这个代码能够正常跑出文章开头的性能测试的结果，但是很显然，埋了一个大坑：会爆内存
且不说为了能够满足  的要求，我们需要把输入数据组织成一个  并拉到  节点这一步骤本身就违背了  节点不干具体活的宗旨，就说我们把   到  之后，还需要转变出一个  这种形式，中途还需要通过  去  一个大 ，这何止是奢侈，简直就是奢侈， 占一份内存， 之后又占一份内存
于是尝试使用  和  来解决，这是一个基于管道的流式读写，我们可以起一个单独的线程，来往这个  写入数据，由于缓冲区大小有限，他就会阻塞在缓冲区满的状态下，然后读取端从  去读，一边读一边写入到网络上去， 顿时轻松很多，但是，动手之前，有一个问题是，怎么来确认我们的这些改动是真的有效呢，由此需要引入  运行时的内存监控工具
我们可以发现，在安装  的时候，附送了这么一个东西

他其实是一个运行时的监控，简单的  内存监控可以不需要说明书就能上手

他可以绘制出  运行时的  和内存曲线图，并带有仪表盘
另外，我们也通过  来获取使用的内存，参考这里，   可以加入打印函数如下
   {
    ==============
      = 
      = 
           
         
         
    ===============
  }
 然后在原有的函数上打点
    = {    
      
      =  
            
      =  {
        = 
        = 
                 {
            ==  \\  \
      }
    }
      = 
      
                  
     _
  }
 并生成  行测试数据
    = {
      =  
      
      = 
      
     
  }
 我们使用一个测试用的表，直接在  中跑一下，可以得到输出如下
=====  =========
 
 
 
===============
=====  =========
 
 
 
===============
=====  =========
 
 
 
===============
    
=====  =========
 
 
 
===============
      
        
可以看到，通过  来生成  的方式，耗用的内存，远比一倍要多
那么接下来就可以尝试改成  和  的方式了
把生成  的类改成如下
    = {
      
      =  
     {
         {
                
          =  {
            = 
            = 
                     {
                ==  \\  \_
          }
        }        
        
         
      }
    }
      =  
    
      
        
  }
  这里其实隐含了一个问题就是是否需要 
可以看到输出如下，耗时有所增加，不过内存控制住了
=====  =========
 
 
 
===============
=====  =========
 
 
 
===============
=====  =========
 
 
 
===============
=====  =========
 
 
    
 
===============
 
        
并且过程中的内存曲线基本平稳

接下来，浮现出来的一个问题就是：是否真的需要把   到  上来？
答案其实是可以不需要，我们有  这个算子，可以写成如下
  = 
 = {
   
  
}
  = 
         
需要注意的是， 并不是 ，而是一个 ，所以我们需要在后面给他跟上一个 ，例如 ，来触发执行
执行起来的效果如下，任一子节点的输出如下

可以看到数据被拆分成了  左右的一个  来分别写入，每个的耗时都控制在  以内
而主节点如下

可以看到主节点再无写入数据的动作，并且总的耗时比文章开头的耗时还要下降了 ，不过基本在一个量级，可以认为是实验误差范围内
通过这种  的方式，需要注意的问题有

 数量的选择，过多容易造成同时连接  的连接数过多，而且每个分区小了，其实吞吐性能不利
如果需要 ，需要意识到  也是有开销成本的
最后别忘了跟一个 

至此，基本就完结了，剩下就是一些工程化方面的工作，例如

在写入数据之前删除分区，以避免脏数据
在写入数据之后校验写入行数是否相符，以免某个  写的过程中出异常了这里其实引申出来一个问题，如果某个  在写到一半的时候挂了，怎么办，是否只能整个  任务重跑来清理现场？
加强日志的可读性

以上动作都是工程化方面的工作，其实还是避免自己给自己挖坑，哈哈 作者：
【小程序码设计篇】菊花绽放 一文中介绍了小程序码的设计过程，本文继续分享我们在小程序码识别上面的一些心得，权当抛砖引玉，欢迎有共同兴趣的同事一起讨论。
识别之前，我们需要对照片做什么处理
打开扫一扫，扫码引擎通常采集到的图片是这样子的。

引擎其实并不关心这朵菊花是什么颜色，因此，我们把图片简化，处理成灰度图。

二值化可以让引擎做的事情更简单，因此再将灰度图处理成位图。

如何在黑白图中快速找到菊花的位置
细心的朋友肯定注意到，每一朵菊花都有两个共同点：

 个圆形的“牛眼”定位点

右下角的“小程序 ”


以上是小程序码的定位信息，准确的定位是识别的第一步。
如何快速找出所有可能的定位点
在设计这个菊花码时，我们是按照          绘制定位点的。

为什么不采用  的比例？因为前者比例比较贴近黄金比例，更符合人类审美需求。下图右为 

基于这个特性，使用水平，垂直， 度角等三个方向的扫描线扫描全图。如果三个方向的黑白像素都接近这个比例，显然它极可能是一个定位点。

怎么定位“小程序 ”
最简单的方法，根据  个定位点的位置，预估小程序  的中心位置平行四边形

在很多扭曲的情况下，上述方法仍有较大偏差。因此我们提出了一种改进方法基于  为圆形的特性，将预估的中心点修正到圆心位置

具体校正方法如下：

拍摄出来的码这么“歪”，能否进行“摆正”
由于上文中，我们已经找到了码在图像中的位置，但由于这个码可能已经被旋转，扭曲，所以，我们需要再做一次矩阵变换透视变换，将其变换到直角坐标系。变换后的码，已经比较易于被机器解读了。

怎么读码
二维码怎么读码
上述流程和传统二维码识别的核心思想并无二致，如果你坚持看到这里，说明你已经知道如何识别二维码了。

经过透视变换，二维码其实已经变成了单位矩阵如上图，你可以理解一个小块为一个像素点，这里为了方便阅读，放大了，那么，我们顺着二维码的编码路径，就能完整地读出编码信息了。
小程序码怎么读码
其实，按照二维码的套路，我们可以把透视变换后的图，进行编码区域划分。值得注意的是，这里一个彩色小块并非一个像素点，而是一片区域。一个编码块是  还是 ，取决于该区域上的黑色像素面积的比例，我们称之为“投票法”。

是否有其他读码方案
但在实际应用中，我们发现该方法对于扭曲的场景，识别效率很低，鲁棒性不佳。经过各种尝试和思考，我们借鉴了一维码的识别思路 ——“采样法”。

举个例子，上图中，我们用红色扫描线采样一维码的信息，对于采样的一行像素，我们根据比例读出具体的编码。

类比该方案，我们利用小程序码为“放射线”编码的特性，采样每一条放射线上的一个像素序列，根据黑白比例读出每一条线的编码信息。
目前扫码引擎的性能如何，能应对什么场景
在测试阶段，我们内部自行拍摄采集了各种场景下的大量测试样本，做了如下评测

包括如下场景这是《使用腾讯云学习深度学习》系列文章的第一篇。本系列文章主要介绍如何使用  腾讯云服务器 进行深度学习运算，前面主要介绍原理部分，后期则以实践为主。
传统机器学习的回顾
近年来，深度学习的概念十分火热，人工智能也由于这一技术的兴起，在近几年吸引了越来越多的关注。我们这里，将结合一些基本的用例，简要的介绍一下这一新的技术。
我们首先需要明确人工智能、机器学习以及深度学习三者之间的关系。如官网所述，人工智能是一个非常大的概念，而机器学习只是人工智能的一种实现方法。深度学习是同样也是一种实现机器学习的方法，是在机器学习的基础上建立起来的。这体现在，首先从字面上看，二者都是在“学习”，因此在评价深度学习训练出的模型好坏时，同样直接来源于机器学习的评价方法。其次，深度学习最常见的形式，深度神经网络，直接脱胎于机器学习中的神经网络模型。

因此，本文主要将从评价方法以及模型实现这两个方面，基于传统机器学习的概念，谈一谈深度学习。
 机器学习的评价方法
我们首先讲一下评价方法问题。为了让本文看起来更加有趣，我们不妨把“机器”理解为“学生”。我们知道，学生有所谓的“好学生”，通常我们搞应试教育，学习成绩好的是“好学生”，不好的就不是“好学生”，但现在流行素质教育，从素质教育的角度看，可能有的学生学习成绩中等，但是团结同学、体育优秀、能歌善舞，这样也算是好学生。
这就涉及到了不同评价标准的问题——应试教育和素质教育。机器学习同样有这两种评价方式，应试教育、唯分数论的监督学习，和素质教育、综合考量并不明确打分的非监督学习。注意这里有一个误区，即可能现在认为素质教育优于应试教育，近期大牛们也一再强调非监督算法的重要意义。但实际上如果拿到一个学习任务，具体使用哪一种方式去分析，还是需要考虑应用场景。通常我们不了解这个学习任务的目的性、需要找线索时，会用非监督找线索，方法包括聚类、降维。而如果明确了学习的目的性，追求高准确率，这时候就需要使用监督学习的方法。
具体举一个鸢尾花分类的例子。我们使用 费雪鸢尾花卉数据集   ，它最初是埃德加·安德森从加拿大加斯帕半岛上的鸢尾属花朵中提取的地理变异数据，包含了个样本，都属于鸢尾属下的三个亚属，分别是山鸢尾、变色鸢尾和维吉尼亚鸢尾。四个特征被用作样本的定量分析，它们分别是花萼和花瓣的长度和宽度：



 
 
 
 


























…
…
…
…
…























…
…
…
…
…
























于是，我们就想，是否可以用鸢尾花数据集里面包含的四个特征，去预测花的种类？如果要这么做，我们首先应该明确不同种类的鸢尾花，这四个特征是否真的有区别非监督学习，如果确实有所区别，我们就可以在此基础上，用这几个特征去追求高的分类准确性监督学习。下面部分我们逐个执行这些步骤。
 使用数据可视化、降维、聚类等非监督方法，探索数据特征
首先展示不同种类鸢尾花四个数据两两组合的情况，如下：
   
   
   

 

 = _
 = 
 = 
_

    
 = _
 =__


这些特征的两两组合，起来确实和花的种类有关。但实际上我们总共有四个维度，这里只能看见两个，我们能否将四个维度换成两个维度、展示在一个平面上呢？这里使用了多种非监督的降维方法，尝试去从非监督的角度，展示不同种类之间的区别：
   
   
   

 

 = _
 = 
 = 
_


   
   
   
   

_ = 
_ = 
 = _
 = 
 = 

 = = 


 = 
 = _ __
 = 
      
 = _
    = =
      
__
__



 = 
 = _ _= _=
 = _
 = 
      
 = _
    = =
      
__
__



 = 
 = _=_
                                _=_
 = _
 = 
      
 = _
    = =
      
__
__


 = 
 = _=_

 = 

 = 
      
 = _
    = =
      
__
__



 = 
 = _=_ = _= =
 = _
 = 
      
 = _
    = =
      
__
__





我们可以看到基于花萼和花瓣的长度和宽度特征，可以通过非监督的数学方法，在降维后，将三种鸢尾花分开。由此，我们明确了学习的目的性根据花萼和花瓣的长度和宽度特征，对三种鸢尾花分类。其中第一类和其他两类可以很好区分，而第二类、第三类之间区分度并不好，这也是一个潜在的问题。
 基于特征的监督模型预测
明确目的之后，我们就可以采用监督学习的方法，使用模型进行分类。监督学习有很多模型，包括深度学习中的神经网络模型。监督学习的基础，是我们已知一部分数据以及其对应的结果，对这些已知结果的数据进行建模，使模型预测的结果和已知的结果越接近越好。这种接近的程度用损失函数来表示，进而通过最小化这个损失函数，得到最优模型。
经典的机器学习方法，可以基于高斯过程：

也可以使用基于核方法的支持向量机：

更可以通过决策树的集成：

同时也可以使用  ，建立一个包含三个隐藏层深度神经网络。以下例子来自  官网
 ____  _
 ____  
 ____  _

 
 

   
   

_ = _
_ = _

 下载数据
   _ _
      
         =   __
           
            

_ = ___
          =_
          _=
          _=

_ = ___
          =_
          _=
          _=


 使用花萼花瓣的长宽作为输入特征
_ = __ =

 建立一个三层的神经网络，每层分别包含 个、 个、 个隐藏单元。
 = _=_
                                               _=  
                                               _=
                                               _=_

 训练数据转化成  格式
 __
     = _
     = _
      

 训练模型
_=__ =

 测试数据转换成  格式
 __
   = _
   = _

    

 评价准确率
_ = _=__
                                     =

\  {}\_

最终这个简单的深度神经网络模型，会实现一个  的分类准确率。
 结果的评价指标以及潜在问题
注意这里最优模型拼准确率时，有一个很大的问题，就是数据分布不平均时，单纯的使用错误率作为标准，会有很大的问题。比如某一种罕见疾病的发病率是万分之一 ，这时候如果一个模型什么都不管，直接认为这个人没有病，也能拿到一个 正确的模型。如何正确衡量这个问题？如果是经典的二分类问题，这种情况下我们需要综合考虑 灵敏度以及 假阳性率，用这两个指标计算 曲线，继而计算  围成的面积—— 值 详见这里。 这种情况下，我们可以认为， 值越高越好。
注意这里 越高越好和最小化损失函数这两个概念，这里意味着，可能某个模型，损失函数已经最小化了，但是 却并不高，造成模型在实际使用时，会引入很多错误——一个较低的  值，可能会在追求高灵敏度时引入了大量的假阳性，正如古话所言，“宁可错杀一万，不可放过一个”，后果就是可能医生通知了十位患者有患癌风险，最终可能只有一位真有问题，其他九人虚惊一场。这种情况，模型并未被很好的训练，可能存在着 欠拟合 的问题。同时，也可能损失函数最小化以后，测试数据  也很高，但是实际运用在真实案例中，却又有大量的错误，这种情况被称作 过拟合。
那么如何避免这两种问题呢？前面提到，监督学习如同“应试教育”，所以机器学习过程为了避免这两种常见问题，也使用了一种类似“题海战术”的策略，即老师手里有一堆题目，不会全都给学生，会分成三个部分，一部分作为 训练集平时作业，一部分作为验证集平时考试，最后还有 测试集中考高考。训练集有数据也有答案，验证集同样有数据有答案，但和平时课堂测试一样，答案是考完试才给看的。而用到测试集时，才会最终评价模型的优劣，如同学生平时作业得分第一，但高考没有考第一，那他也不是状元。
为了避免平时作业写得好、高考失误这种悲剧，合理的运用平时考试抓差补缺就十分必要。机器学习的过程中，这一条同样成立，具体而言，如果一个学生，作业全对，但是平时考试成绩不好，这种情况用机器学习术语就是 过拟合 了，可能的原因是，机器学习过程中使用了过多的参数去迎合数据，片面追求平时学习过程的准确率，造成知其然不知其所以然的结果，在实际运用过程中表现很差。还有种情况可能更加常见，就是一个学生，写作业错一堆，考试也一堆错，这种情况，就是 欠拟合，可能是学习不够、方法不对，需要更多的特征、更优化的模型。
 提高深度学习模型预测的准确性
回到鸢尾花的例子，我们写的最简单的深度学习模型，达到了  的准确性。那么问题来了，如果我们追求的是 ，如何提高模型的表现？
调整模型的参数，无疑是最简单最快速的方法，但调参并不能从根本上解决分类准确性的问题。如果是数据 欠拟合，则通常需要更多的特征、更优化的模型。
我们首先说 更多的特征，比如我们这里只用了四个特征，花瓣、花萼的长度和宽度。而植物分类学家使用的特征，可能就会包括诸如 “根部是否肥大呈纺锤形”、“外花被裂片附属物有无或附属物是须毛状还是鸡冠状”、“基因序列和个限制性位点的比对” 这种更加专业的特征，这些特征可能只有专业人士才能得出结论，甚至需要借助专业的仪器、花费数天时间。
但实际上，植物分类，并不一定要按照植物分类学课本的定义进行，可能普通人看一眼也可以分的差不多。比如我们的三种鸢尾花，我们看起来确实是第一类和第二三类不同，然后二三类之间区别相对更小，但其形状、颜色、纹路等确实有所区别：

因此对于鸢尾花数据集，各种模型可能都并不足以达到 准确分类，其背后深层次的原因是，这个数据集可能并没有很好的表征花瓣的形状、颜色、纹路等特征。原因也很简单，数据收集者很难准确用几个数字描述出花瓣的形状，特别是形状极为相似的情况。同时，描述出深紫色、浅紫色的区别也十分困难。于是有一个想法，就是我们能不能直接给出图片，让计算机帮忙标注这些特征，用更多的特征，增加模型准确性？
想让计算机帮忙挖掘、标注这些更多的特征，这就离不开 更优化的模型 了。事实上，这几年深度学习领域的新进展，就是以这个想法为基础产生的。我们可以使用更复杂的深度学习网络，在图片中挖出数以百万计的特征。在这些数以百万计的特征中，可能就包括了我们想到的形状、纹路、颜色等信息，更多的则是我们也无法理解、描述的东西。如下图，使用  深度学习架构，后面的全连接部分  与本节  部分相同，都是三层隐藏层，但是前面却接了一个卷积部分 用来在图像中提取各种特征。

我们将在接下来的章节中，详细介绍如何通过深度学习技术，在图像中挖出更多的特征，达到一个更高的分类正确性。
最后，目前腾讯云  服务器还在内测阶段，暂时没有申请到内测资格的读者也可以使用普通的云服务器运行本讲的代码。但后续文章的重点是深度学习，计算量大大增加，必须租用 云服务器 才可以执行代码。服务器的租用方式，以及  编程环境的搭建，我们将以腾讯云  为例，在接下来的内容中和大家详细介绍。导语
最近介入测试的相关逻辑，因此对穿透原理做了一定程度的了解当然也没有很深入。本篇文章也是综合和参考了些网络上和文献里的一些资料文中没有对引用处进行标记，请见谅。写本文的目的就是，用自己的语言描述了这个过程，同时也在描述过程中加入了一些自己的理解，形成一篇文章作为要点的记录。对于这一块的知识，自己也有很多盲点，还请各路大神多多指教。
一、背景知识介绍
什么是？
  ，网络地址转换，也叫做网络掩蔽或者掩蔽。是一种网络地址翻译技术，主要是将内部的私有地址 转换成可以在公网使用的公网 。
为什么会有？
时光回到上个世纪年代，当时的人们在设计网络地址的时候，觉得再怎么样也不会有超过位长即的次幂台终端设备连入互联网，再加上增加的长度即使是从字节增到字节对当时设备的计算、存储、传输成本也是相当巨大的。后来逐渐发现地址不够用了，然后就就诞生了！虽然也是解决办法，但始终普及不开来，而且未来到底够不够用仍是未知。
因此，技术能够兴起的原因还是因为在我们国家公网地址太少了，不够用，所以才会采取这种地址转换的策略。可见，的本质就是让一群机器公用同一个，这样就暂时解决了短缺的问题。
有什么优缺点？
优势其实上面已经刚刚讨论过了，根据定义，比较容易看出，可以同时让多个计算机同时联网，并隐藏其内网，因此也增加了内网的网络安全性；此外，对来自外部的数据查看其映射记录，对没有相应记录的数据包进行拒绝，提高了网络安全性。
那么，与此同时也带来一些弊端：首先是，设备会对数据包进行编辑修改，这样就降低了发送数据的效率；此外，各种协议的应用各有不同，有的协议是无法通过的不能通过的协议还是蛮多的，这就需要通过穿透技术来解决。我们后面会重点讨论穿透技术。
简单的背景了解过后，下面介绍下实现的主要方式，以及都有哪些类型。
二、实现方式及主要类型
实现方式
静态：也就是静态地址转换。是指一个公网对应一个私有，是一对一的转换，同时注意，这里只进行了转换，而没有进行端口的转换。举个栗子：

：端口多路复用技术。与静态的差别是，不但要转换地址，还要进行传输层的端口转换。具体的表现形式就是，对外只有一个公网，通过端口来区别不同私有主机的数据。再举个栗子。

通过上面实现方式的介绍，我们其实不难看出，现实环境中的应用显然是更广泛的。因此下面就重点介绍下的主要类型有哪些。
的主要类型
对于我们主要分为两大类：锥型和对称型。其中锥型又分：完全锥型，受限锥型和端口受限锥型。概括的说：对称型是一个请求对应一个端口；锥型非对称是多个请求外部发向内部对应一个端口，只要源端口不变，无论发往的目的是否相同，在上都映射为同一个端口，形象的看起来就像锥子一样。下面分别介绍这四种类型及其差异。
完全锥型  ，后面简称
特点：和端口都不受限。
表现形式：将来自内部同一个地址同一个端口号__  __的主机监听请求，映射到公网某个端口__  __的监听。任意外部地址与端口对其自己公网的这个映射后的端口访问__  __，都将重新定位到内部这个主机__  __。该技术中，基于架构的应用可以在任何一端发起连接。是不是很绕啊。再简单一点的说，就是，只要客户端，由内到外建立一个映射  之后，其他的主机或端口都可以使用这个洞给客户端发送数据。见下图图片来自网络。

受限锥型  
特点：受限，端口不受限。
表现形式：与完全锥形不同的是，在公网映射端口后，并不允许所有进行对于该端口的访问，要想通信必需内部主机对某个外部主机发起过连接，然后这个外部主机就可以与该内部主机通信了，但端口不做限制。举个栗子。当客户端由内到外建立映射 – ，机器可以使用他的其他端口主动连接客户端，但机器则不被允许。因为受限啦，但是端口随便。见下图绿色是允许通信，红色是禁止通信。

端口受限型   
特点：和端口都受限。
表现形式：该技术与受限锥形相比更为严格。除具有受限锥形特性，对于回复主机的端口也有要求。也就是说：只有当内部主机曾经发送过报文给外部主机假设其地址为且端口为之后，外部主机才能以公网中的信息作为目标地址和目标端口，向内部主机发送报文，同时，其请求报文的必须是，端口必须为使用地址为，端口为，或者地址为，端口为都将通信失败。例子见下图。这一要求进一步强化了对外部报文请求来源的限制，从而较 更具安全性。

对称型 
特点：对每个外部主机或端口的会话都会映射为不同的端口洞。
表现形式：只有来自同一内部、且针对同一目标的请求才被转换至同一个公网外部，否则的话，将为之分配一个新的外部公网。并且，只有曾经收到过内部主机请求的外部主机才能向内部主机发送数据包。内部主机用同一与同一端口与外部多通信。客户端想和服务器__建立连接，是通过映射为来进行的。而客户端和服务器__建立连接，是通过映射为来进行的。即同一个客户端和不同的目标通信，经过映射后的公网是不同的。此时，如果想要和客户端通信，也只能通过也就是紫色的洞洞来进行，而不能通过也就是黄色的洞洞。

以上，就是的四种类型。可以看出由类型至类型，的限制是越来越大的。
三、路由类型判断
根据上面的介绍，我们可以了解到，在实际的网络情况中，各个设备所处的网络环境是不同的。那么，如果这些设备想要进行通信，首先判断出设备所处的网络类型就是非常重要的一步。举个例子来说：对于视频会议和软件，对位于不同内部的主机通信需要靠服务器来转发完成，这样就会增加服务器的负担。为了解决这种问题，要尽量使位于不同内部的主机建立直接通信，其中，最重要的一点就是要判断出的类型，然后才能根据的类型，设计出直接通信方案。不然的话，两个都在的终端怎么通信呢？我们不知道对方的内网，即使把消息发到对方的网关，然后呢？网关怎么知道这条消息给谁，而且谁允许网关这么做了？
为了解决这个问题，也就是处于内网的主机之间能够穿越它们之间的建立直接通信，已经提出了许多方法，    ，会话穿越应用程序技术就是其中比较重要的一种解决方法，并得到了广泛的应用。在这个部分，我们将重点介绍下技术的原理。：除此之外，还有技术，应用层网关识别技术，会话边界控制，交互式连接建立，中继穿越技术等等，本文不一一做介绍。
四、协议
是一种网络协议，它允许位于或多重后的客户端找出自己的公网地址，查出自己位于哪种类型的之后以及为某一个本地端口所绑定的端端口。这些信息被用来在两个同时处于路由器之后的主机之间建立通信。该协议由 定义。由三部分组成：客户端、服务器端、路由器。服务端部署在一台有着两个公网的服务器上。大概的结构参考下图。客户端通过向服务器端发送不同的消息类型，根据服务器端不同的响应来做出相应的判断，一旦客户端得知了端的端口，通信就可以开始了。

协议定义了三类测试过程来检测类型。
： 通过端口{}向 {}发送一个 没有设置任何属性。 收到该请求后，通过端口{}把它所看到的 的和端口{}作为 的内容回送给 。： 通过端口{}向 {}发送一个 没有设置任何属性。 收到该请求后，通过端口{}把它所看到的 的和端口{}作为 的内容回送给 。
： 通过端口{}向 {}发送一个 设置了 和 属性。 收到该请求后，通过端口{}把它所看到的 的和端口{}作为 的内容回送给 。
： 通过端口{}向 {}发送一个 设置了 属性。 收到该请求后，通过端口{}把它所看到的 的和端口{}作为 的内容回送给 。
协议的输出是：公网和防火墙是否设置客户端是否在之后，及所处的的类型
因此我们进而整理出，通过协议，我们可以检测的类型一共有以下七种：
：公开的互联网。主机拥有公网，并且没有防火墙，可自由与外部通信：完全锥形。：受限制锥形。：端口受限制形。：对称型防火墙。主机出口处没有设备但有防火墙且防火墙规则如下：从主机端口发出的数据包保持源地址，但只有从之前该主机发出包的目的发出到该主机端口的包才能通过防火墙。：对称型：防火墙限制通信。
输入和输出准备好后，附上一张维基百科的流程图，就可以描述协议的判断过程了。

：检测客户端是否有能力进行通信以及客户端是否位于后  客户端建立 ，然后用这个向服务器的，发送数据包要求服务器返回客户端的和，客户端发送请求后立即开始接受数据包。重复几次。如果每次都超时收不到服务器的响应，则说明客户端无法进行通信，可能是：防火墙阻止通信如果能收到回应，则把服务器返回的客户端的同   比较：如果完全相同则客户端不在后，这样的客户端是：具有公网可以直接监听端口接收数据进行通信或者。否则客户端在后要做进一步的类型检测继续。
：检测客户端防火墙类型  客户端向服务器发送请求，要求服务器从其他和向客户端回复包：收不到服务器从其他地址的回复，认为包前被前置防火墙阻断，网络类型为收到则认为客户端处在一个开放的网络上，网络类型为
：检测客户端是否是    客户端建立 然后用这个向服务器的发送数据包要求服务器用另一对响应客户端的请求往回发一个数据包，客户端发送请求后立即开始接受数据包。 重复这个过程若干次。如果每次都超时，无法接受到服务器的回应，则说明客户端的不是一个  ，具体类型有待下一步检测继续。如果能够接受到服务器从返回的应答包，则说明客户端是一个  ，这样的客户端能够进行通信。
：检测客户端是否是   客户端建立 然后用这个向服务器的发送数据包要求服务器返回客户端的和 客户端发送请求后立即开始接受数据包。 重复这个过程直到收到回应一定能够收到，因为第一步保证了这个客户端可以进行通信。用同样的方法用一个向服务器的发送数据包要求服务器返回客户端的和。比较上面两个过程从服务器返回的客户端如果两个过程返回的有一对不同则说明客户端为 ，这样的客户端无法进行通信检测停止因为对称型，每次连接端口都不一样，所以无法知道对称的客户端，下一次会用什么端口。否则是  ，是否为   有待检测继续。
：检测客户端是  还是     客户端建立 然后用这个向服务器的发送数据包要求服务器用和一个不同于的端口发送一个 数据包响应客户端 客户端发送请求后立即开始接受数据包。重复这个过程若干次。如果每次都超时，无法接受到服务器的回应，则说明客户端是一个   ，如果能够收到服务器的响应则说明客户端是一个  。以上两种都可以进行通信。
通过以上过程，至此，就可以分析和判断出客户端是否处于之后，以及的类型及其公网，以及判断客户端是否具备通信的能力了。当然这是自己个人笔记的第一篇，后面，再作一篇笔记《穿透原理浅析二》分析下不同类型的穿透打洞策略。导语
视频点播为公司大部分流媒体和音视频相关的业务提供上传、存储和下载等需求。所有文件存储在相同的仓库，提供下载服务的节点也是共用的，所以存在各个各样的盗链问题。
、背景介绍
由于所有业务的文件都存储，并且下载时提供下载服务的节点也是相同的，所以为了识别某个下载链接是那个业务的，我们提供给业务的下载链接都会有一个相应的用于识别各个业务没有带上或者带上的在下载服务没配置，直接禁止访问。
为了防止用户或者黑客获取到下载链接后恶意访问文件，每个下载链接的中都会带上一个参数，里面包含了当前这个链接访问文件名值、的生成时间、的有效时长、通过此链接下载文件是否进行限速，当然这一切都是以一个不公开的算法加了密的。服务端收到下载请求后会解密，并且对信息进行校验，限速，通过进行下一步给客户端吐数据，如果校验不通过，直接返回。下载链接如下：  域名
、问题描述
首先所有文件都存储，并且下载时提供下载服务的节点也是相同的，并且除了音乐业务有自己单独的一套校验库外音乐也是个坑，下面描述，其他业务包括腾讯视频都是用同一套校验库，这就为盗链的存在提供了巨大的隐患。
 、通用的算法被破解，或者一些腾讯视频精品库付费会员才能观看的文件对应被获取后非法盗用，这时，恶意用户就可以利用这些漏洞，盗播腾讯视频精品库等内容音乐同理。
、由于所有文件都存储，并且下载时提供下载服务的节点也是相同的，所有恶意用户可以利用任意业务的下载任意业务文件只要能正确生成或获取。
、音乐校验算法没有校验文件名，也就是说获取到音乐的后，可以利用音乐下载任意业务文件。
、音乐的校验算法除了没有校验文件名之外，其实跟通过算法相同，也就是说拿到通用，可以利用音乐的下载任意文件。
、解决措施
、针对被破解方法，这个是一个效率与安全的博弈论。或许最简单的方法是用公私秘钥或者，这时候客户端知道算法也无法伪造，但是公私秘钥加解密和签名耗并且要全网部署相关秘钥，怎么防止全网几千台服务秘钥不泄露等问题。通过腾讯视频播放页面或者正确的秘钥，这个更是无法阻止了，因为客户端可以任意抓包，总能获取到的下载的。实际上也无法完全禁止文件被盗播。
 那么先解决重点问题，点播这边最大的问题就是腾讯视频的精品库被盗播，利用腾讯视频自己的和相关，多次盗播视频这个问题，和全部对腾讯视频的接入腾讯视频那边的异步盗链打击，防止恶意用户利用腾讯视频的盗播精品库。具体参考文章视频防盗链阶段总结。
、针对获取到后，利用非腾讯视频的访问精品库问题，这时候这些都死非腾讯视频业务，不能接入腾讯视频的异步防盗链打击。但是，正是由于他们是非腾讯视频访问腾讯视频业务文件，所有禁止他们访问腾讯视频文件或者让它们只能访问自己的业务文件就解决了问题。
每个业务接入时，我们都会为业务提供一个业务大业务不止一个，可能有多个，在源站是，但是 节点上无法获取文件对应的能从获取到文件相关，也就无法限制访问相关文件。无法识别，有没有办法从文件名识别是否为腾讯视频的文件。其实，最后就是根据文件名的规则识别为腾讯视频文件，最后全网禁止非腾讯视频的访问腾讯视频文件。  并且腾讯视频自己启用新的校验库，独立一套校验库算法。
、点播业务除了腾讯视频，还有两大业务，音乐和空间。前面说了音乐的校验没有校验文件名，拿到一个合法或者自己生成音乐，通过音乐就可以访问任意业务视频文件当然访问腾讯视频文件已经被我们通过识别腾讯视频文件名禁止掉了。这样音乐的就可能被利用来播放空间的视频文件特别是带颜色的小视频。
针对这种情况，首先源站的可以获取到文件对应的，发现通过音乐访问非音乐文件，直接禁止访问。那么的节点呢，实际上空间视频的文件命名上已经呆了，所有节点也能根据文件名知道相关，禁止音乐盗播空间视频。现在我们接入的业务都是要求文件命名问 _，位位，但是腾讯视频和音乐文件属于比较先接入业务，命名没根据这个规则了，所以才有了前面第点，根据腾讯视频其他规则来限制他被其他业务盗播。
、效果与进展
图和图为非腾讯视频添加后缀做限制，不允许访问腾讯视频文件。图波动由于月日禁用一些音乐回源，盗链全部换到这个引起。图是源站限制只能访问其相关的文件之后音乐回源源站盗链流量掉底。

图

图

图
、后续措施
业务的去盗播业务的文件，此时，如果能识别通过文件名获取到任意一个业务的，就能禁止这种现象。如业务文件能获取到对应，现在的只能访问的文件；如果如业务文件能获取到对应禁止文件被业务访问。但是，如果出现无法从文件名中直接获取任意一个业务的，就无法通过禁止这种不同业务之间的盗播。所以，在内存允许的情况下，在缓存节点的文件索引管理中记录每个文件的，就可以做到业务之间不相互盗播文件。 背景
微云日上传视频数达到万个，每日播放视频次数达到次，在线播放视频成为强烈的需求。但是在 、的播放体验并不好，原因有两个：
播放组件支持的视频格式少，仅支持、等编码的视频；
部分视频特别是视频码率过大，导致播放卡顿。
所以我们决定对微云的视频转码，提供流畅的视频在线播放体验。
 转码原理
原视频存放在架平仓库，转码视频时需要先下载视频到本地，再对下载好的视频转码得到新视频，最后再把新视频上传到云端。简单的转码流程如下：

为了能在各个客户端上流畅地播放视频，我们需要把原视频转码成编码、低码率的视频。视频文件主要由视频流和音频流等信息组成，其中视频流和音频流有着不同的编码格式。转码的过程如下图，先解封视频，分别提取视频流和音频流，把视频流转为格式，把音频流转为格式，然后再封装起来得到新视频。

我们这里选择作为视频转码组件。因为是一个成熟的开源、跨平台组件，支持多种格式的音视频转码，并提供了一套录制、转换以及流化音视频的完整解决方案。
 转码架构设计
 哪些视频需要转码？
微云的存量视频达到，如果都转码这些视频，显然不太现实，也没有必要，因为存量视频的点击播放率较低，投入产出比太低。所以我们经过分析，发现用户一般是分享视频的场景下，更多的点击播放视频。好钢用在刀刃上，花钱花在跟节眼上，在机器资源有限的情况下，所以我们决定对分享的视频再进行转码。
 转码后的新视频存在哪里？
原视频转码后会产生新视频，新视频的存放应该满足这几个条件：
用户不感知。由于是后台自动转码，所以用户不应该感知到有新视频的存在，否则会引起用户误会，导致用户投诉或新视频被删。
并发上传视频不冲突。由于多个视频在同时转码，所以上传新视频时相当于并发写操作，这里需要做到并发写无冲突。
下载速度稳定。
经过讨论，我们最后选择了腾讯云存储系统来存放新视频。因为新视频不能存放在原视频的用户的目录下，否则会用户会感知到；也不能存在公共的账号上，因为底层做了对写排队保护，如果并发上传过多，容易导致队列满而失败。而系统满足上面三个条件，支持单目录并发写，不容易冲突。
 下载、转码、上传操作流水线化
前面提到，转码视频时需要先下载视频到本地，再对下载好的视频转码得到新视频，最后再把新视频上传到云端。
举个例子，假如有、两个视频需要转码。在同步转码模式下，下载模块下载完原视频的数据后，转码模块拿到视频的数据开始转码，这时候下载模块就空闲，直到上传模块把视频上传到、结束视频的完整转码过程，下载模块才会开始下一个转码任务：下载视频的数据。在整个转码过程中，每个模块都在等待其他两个模块的操作完成而空闲着，这样的转码效率低下，白白浪费了很多时间。

 显而易见，这三个模块都是后者依赖前者的输出结果，也就是说，一旦前者输出结果后，后续的模块的操作和前者就再无关系。根据这个特点，我们在每个模块之前加入队列，把下载、转码、上传操作异步化，各个模块之间不再同步等待转码结束，而是在完成本模块的任务后，继续从队列里面取下一个任务。这样就实现了转码的流水线化，极大地提高转码效率。简单流程如下：

这里我们使用组件来实现队列功能，是一个强大的分布式任务管理组件。详细介绍可以参见官网，这里先不展开详细介绍了。
 总体架构
经过前面的推论，我们设计出了视频云播转码的总体架构。如下：
由分享场景触发视频转码，云播逻辑把待转码视频放到下载队列中，等待转码。
用户播放已转码视频时，从公网直连边下边播，实现云播功能。

 运营部署
目前云播转码模块已经部署到外网环境，其中使用了台机器来转码视频，目前已住业务分享场景的日常转码、云播需求。
 未来规划
由于资源有限，我们的转码方案只满足了分享场景的转码需求，并没有完成覆盖业务的所有场景。上述转码方案其实也是属于预转码，并不能保证所有转码过的视频都会被播放。后续我们计划实现实时转码功能，通过用户播放操作触发转码，这样能最大化利用机器资源，做到百分百覆盖云播场景。主从同步的整体思路不外乎“数据镜像  流水”，但是仔细考虑，会有一些值得思考的细节问题，看看你是否考虑过？术语：主机=，从机=
问题提出：

“数据镜像”也称之为“快照”，是指保留某个瞬间状态的切片数据。但是毕竟保存数据是个过程可能需要数分钟、数十分钟、甚至数小时不等，如何保证这个过程中产生的修改操作，不会“弄脏”数据镜像呢？

生成“数据镜像”并成功传输给之后，还不能称之为主从数据一致。从镜像数据产生到传输完成过程中累计的修改操作，如何再增量的同步给？

什么是？字面意思很简单—— 。仅仅是记录修改数据的一个过程么？有没有其它格式？分别的特点和优缺点是什么？

的同步可以是向拉取，也可以是向推送，应该选择哪种方式？各有什么优缺点？

产生一条修改数据操作，实时同步给后，是否需要等待确认收到的？的必要性和优缺点分别是什么？



如果上述个问题，你都知道答案，那一定是对主从同步机制非常了解，可以不用再继续看后文啦。如果有些问题你不确定或者没有明确答案的话，接下来，会参考一些成熟系统、和的主从同步机制，看看它们是怎么解决上述几个问题的，最后给出对比和总结。
 ： 如何保证“数据镜像”的数据一致性？
 复用了的时的技术。
收到的同步请求之后，会出一个子进程用于产生镜像数据文件。之后，父子进程的进程空间有些资源共享，大多数资源如堆栈内存会复制一份到子进程。但是内核为了更加高效，此时的复制并不是真正的复制，而是写时复制。

的示意图
示意图中可以看出，后父子进程的虚拟地址不同，但是都指向父进程的物理地址。当父子进程有任意一方，尝试修改内存的时候，都会产生缺页中断，由内核分配内存给子进程独享。正文段除外，因为是只读段，所以可以复用物理内存
所以，子进程可以很好的保持瞬间的内存状态，并把数据保存成镜像文件。父进程此时继续处理业务请求，期间即使再有修改操作，也只是修改主进程对应的内存，子进程感知不到。从而很好的解决的此问题。
 的数据引擎采用的是技术。
的镜像数据通常利用工具生成。
 对于不支持事务的引擎，如。为了保证时的数据一致性，通常都会采用锁表操作，即数据库在过程中变为只读，不允许写操作。这种方式通常只能在业务低峰期，或者备机上使用。
  对于支持事务的引擎，如。加上参数，可以在不停写、且保证数据一致性的基础上，进行数据生成镜像文件。其中采用的就是技术。
全称为  ，即多版本并发控制技术。目前支持的数据库有：、、等。类似于前面介绍的技术，也是在修改数据时，数据并标记对应的版本号，但是操作粒度更加精细。的实现原理简单介绍如下：

实现的原理图
上图中，读操作采用级别，也就是说读取到的一定是事务提交之后的结果，已经开始未提交的事务结果是读取不到的。大括号的范围表示事务的执行时间，其中绿色为修改类的事务，黄色为查询类的事务。每个事务对应一个事务，按照事务开始的时间顺序排列，其事务分别为前缀和是为了直观区分读写。
 写事务，把数值从修改成了。此时是最新值，是旧的副本；
 写事务，把数值从修改成功。此时是最新值，和是旧的副本；
 是先于开始的读事务。所以读取到的是；
 是提交之前发起的读事务。所以也只能读到；
 是提交之前，提交之后发起的读事务。所以读到的是；
 当结束之后，没有事务需要访问了，所以可以从副本中删除；
 当结束之后，没有事务需要访问了，所以可以从副本中删除，只剩下最新值；
上述流程可以看出：类似于，当有读事务访问一个旧值时，修改类事务就会出来一个副本进行修改，保证读写不会冲突，而且不会锁住流程。
的原理如上面介绍，不过具体实现各数据库略有不同：
 中副本的表现形式就是多记录同时存在，但是每个记录会对应不同的事务所有的操作都会变成操作并记录事务的方式，延迟旧数据，根据读事务级别以及读事务判断需要读哪个副本。所以过程中，极端情况下如果全表，会导致表大小增加一倍。独立的进程负责异步回收不再需要使用的副本数据。
 中副本是保存在 中的，所以表数据不会膨胀。每次对记录的修改时，都会把修改前的数据写入 中。所有读事务会对应一份的表，当有修改事务操作数据时，把操作事务的事务记录在中，这样读事务在读取某条记录数据时，可以根据记录最新的事务，在中查找，查找到的话，就意味着数据已经修改过，需要结合 找到自己可以读到的那个值，否则就可以直接读取最新的数值。
 是利用“加锁”的思想。
镜像文件由生成，而且为了保证数据一致性，需要短暂停止同步，然后数据到磁盘后，再恢复同步。但是这种方式会导致有一段时间主备数据不同步，存在一定隐患。同学也有计划把这块做成边同步边落地数据的方式

问题总结：
 技术。优点：实现非常简单，之后完全跟主进程访问内存的方式相同。缺点：粒度相对粗犷，一次缺页中断加载的就是一个内存大小默认；
 技术。优点：控制更加精细，可以到数据记录级别。缺点：实现相对复杂，需要维护各种版本号，已经无效副本的回收。
 “加锁”。优点：实现最简单。缺点：业务需要停写，影响较大。
 ：如何同步积压数据？如何增量同步？
 分两种情况处理：
 积压数据同步。在主进程返回之后，子进程开始生成镜像数据，主线程此时就把之后产生的修改类指令存放在的发送缓冲区中，等待镜像文件发送完之后，一并把缓冲区中积压的指令发送给。
衍生的问题：会不会由于生成镜像文件时间较长，而这段时间的修改操作又很多，导致缓冲区爆掉？采用固定变长内存块队列的方式，保证缓冲区大小比较灵活，有伸缩性。

其中是缓冲区的默认大小，静态分配；如果还不够，每次就动态分配的，挂在一个链表上。
 增量数据同步。这种方式，是在与连接断开，或者长时间没有心跳后也会断连接触发的增量同步逻辑。

增量同步示意图
发送请求给，侧维护一个循环队列内存数据结构，称之为，大小可配置。是为了确保的实例没有变化过没有重启过，是记录了当前已经同步的位置，就根据在自己维护的中查找，找到的话就把中剩余的增量数据一并发送给。
 的增量同步实现。

增量同步示意图
收到的请求之后，就创建一个线程与之对接多个，就有多个线程。与类似，根据传过来的的和，确定当前的同步位置，由负责把剩余的数据发送给。侧有两个线程与同步有关系，一个是，负责接收主机同步过来的数据，并把数据写入的文件中；另一个是，负责从中读取并执行语句。
 的增量同步实现。

增量同步示意图
与的流程基本一致，不过侧没有这个中转文件，而是收到同步的之后，将其转换成正常的请求，直接在备机上重做。
衍生的问题：上的有存在的价值吗？和需要独立开来吗？
分两个线程是有必要的！因为语句的执行时间很难估计，有些操作的执行时间会非常长例如全表，或者没有命中索引的修改操作，如果没有而是直接由缓冲区接收，那么缓冲区很容易积压满，就无法继续同步数据过来，从而导致同步延时增加。所以把接收数据和执行操作两个步骤拆分开来进行解耦，尽可能让同步消息先落地到中是非常有必要的。
这方便的问题不突出，批量更新的操作数量不多，特别是热点数据的修改都直接在内存中完成，所以整个同步数据接收和执行的总时间都是可控的。那么的存在意义就不大了。
问题总结：
 都是基于内存的数据结构实现的增量同步机制。通过变长的发送缓冲区和的循环对列实现同步。
 和都是基于文件的，实现增量同步机制。两者的区别在于：的写操作耗时可控，所以没有的中转文件。
 ：的格式有哪几种格式？
的全称为 ，是一种二进制日志格式，主要用于主从同步或数据恢复。传统意义上的一般都按顺序记录了修改类的操作指令增加、修改、删除，并把这些操作流保存在磁盘上。广义上，分为两种格式：
  。这种是基于操作流的，收到的请求是什么，就保存下来什么。
   。这种是基于操作结果的，把操作之后的数据保存下来。
这两种各有什么特点？
  。
优点：表达更加精简，可以很好的保留数据的修改过程。
缺点：某些情况下，无法精确表达，重做可能会产生不同的执行结果。例如操作，如果没有带 ，返回顺序不同而导致_的值不同；还有其它复杂的机制，如触发器、存储过程、事务交叉执行等等都可能有不同结果
  。
优点：表达更加精确；有些操作的效率会更高例如，重做的时候不需要重复一遍了；具有幂等性，同一条日志多次执行的结果相同。
 缺点：只是存储了修改结果，所以无法表达修改过程，不知道为什么变成了这样的状态；日志容易膨胀假设一个操作是修改整个表的数据，基于的话，就需要把整个表的数据结果都保存下来！！！
对比下来，发现两种格式各有优缺点，所以产生了混合型的 ：在能够精确表达的时候优先使用  ，对于无法精确表达的情况则采用 。

固化数据的日志称之为  。这种格式存储的是操作流，所以是一种 。

支持上述三种。并且建议使用 。

内部称之为。是一种紧凑格式的基于的。


 ：同步什么时候，什么时候？

：与建立连接之后，会主动把已同步的发送给，请求按照这个拉取数据，所以此时属于模式。当主从数据一致之后，收到的修改类操作，都会实时传播给，此时属于模式。

：也是和结合。


前面介绍过，首先告诉，自己当前的 和 。会创建独立线程与进行对接处理，根据传过来的，在本地的中查找，并把剩下的发送给。这个过程也是模式。

实时广播的流程图
侧有新的产生时，主线程会广播通知有新的产生，然后由读取发送给。该过程属于模式。

：与类似。

问题总结：
三个系统都采用和相结合的方式同步数据。
长时间与不同步，什么时候具备重新同步的能力，只有才知道，所以这种情况下由拉取增量数据最合适；
产生新数据需要同步给，此时只有可以第一时间感知到，所以此时采用推送的方式通知更新数据一定是最实时的。试想，如果循环向拉取数据，一方面效率会比较低，另一方面实时性也比较差。
 ：同步是否需要？
：把增量修改操作发给，并没有确认是否收到。由于主备通过直连，所以层可以保证发送到对端的系统缓冲区中，而且也不会出现乱序或丢包的情况。
：默认的同步机制下，也是不需要回复的。但是不确认对于要求强一致性的场合是不够的。例如，把数据写入并通知有修改后，就返回给客户端写入成功，恰恰此时挂掉，没有收到刚才的就升级为，就会出现数据不一致。对此版本之后，引入了半同步机制 ，这种机制下，是要求收到的回包的。具体关于半同步的内容就不展开了，后面的参考资料里面可以进一步研究下。
：最终一致性，直连，也是没有确认的。
问题总结：
 直连的情况下，可以不确认，简单实现最终一致性的主从同步。
 如果不使用直连例如通过中转了同步请求，或者使用协议不能保证时序、可靠性，那么必须要实现自己的。否则连最终一致性都无法保证。
  强一致性的情况下，需要确保回复成功后，再通知客户端成功。
各系统对比总结：

参考资料：
  官网 。上面有很多英文介绍，结合源码分析源码写的很漂亮，而且注释丰富，很容易搞懂整个同步流程。
 的官网文档
 
 的增量同步流程分析
 的半同步复制解析
介绍了 如何实时推送同步
  附件中还有一个介绍技术的，网上搜到的，觉得讲的很清楚，可以参考下。导语 生产环境中使用作远程控制时，发现会有部分机器报    错误，尝试使用命令连接此机器，只是卡半天，最终还是能够正常登陆。

最近一直做运维发布平台，底层命令行、文件通道主要基于模块，使用过程中遇到各种各样的问题，本文主要用于收集问题及解决记录，以备后续使用。

一、    连接错误
这个关键词，在百度、谷歌一搜一大把的提问，也有少部分给出了解决方案，但是最终都无法解决，我经过不断尝试和解读源码，终于搞定了这个问题，在此记录分享下。
、具体报错信息：
    
     
   _    
   _    _
     
、解决办法：
重新下载插件源码，解压后，编辑安装目录下的文件：
 
搜索 _ 关键词，并将其参数改大即可，比如改为：
_ = 
最后，重装即可。
、下面的曲折、啰嗦的解决过程，不喜请跳过：
在谷歌搜到一个老外相关提问，虽然他说的是，其实也是基于：

他最后给出了他的解决方案：


                              

意思是，在使用前，先 ，就能解决问题。我照做之后，发现对手头的现网环境无效，可能错误产生的原因不一样。
但是，我从老外的问题描述过程中，找到了解决方法，他是这样说的：

                       

我看到有个和，就想到现网那些报    错误的机器也是非常卡，而且目测了下发起连接到报错的时间，基本是相同的。
于是系统中搜索，并找到了这个文件：

并搜了下，发现果然有一个参数设置，而且和目测的超时基本一致！

于是，顺手修改成，并重新测试发现没任何效果，依然超时。接着打断点、直接移走这个问题，问题依旧！！看来这个文件不会被引用。。。
回到最初的报错信息，发现里面显示的是：
_
而系统里面搜不到这个问题，最后醍醐灌顶，发觉模块编译后，基本是以文件保存的，看来 必须修改源码才行了。
于是到的源码目录，执行搜索，找到各文件：
    


尝试将文件中的 _ 值改成，重新安装，结果一次性测试成功！
二、远程执行后台脚本“阻塞”问题
我写的远程命令通道上线之后，发现在远程脚本中后台再执行另一个脚本，通道会一直等待后台脚本执行完成才会返回，有时甚至会僵死。
、复现过程如下：
①、编写测试脚本
脚本：

 
  
 
脚本：

  
  
 
脚本：
 
 = 
 = 
____
= = = = =_=__=                          
=_                         
_ = 
    
    _ = 
 _
将和传到远程服务器上，比如放到下。
②、发起远程执行
在本地执行  ，会发现整个脚本不会立即打印 ，而是等之后才打印包括的所有输出信息。
、解决办法
将远程脚本的标准输出重定向到错误输出即可， 修改如下：
 
 = 
 = 
____
= = = = =_=__=                          
=_                   
_ = 
    
    _ = 
 _
现在执行，就能立即得到结果了。其实原因很简单，因为   虽然是后台执行，但是依然会产生标准输出，一旦产生标准输出，就会认为命令还未执行完成，且的大于，因此产生等待问题。
这里只要将脚本执行的标准输出重定向到错误输出，然后就可以使用快速读取远程打屏信息了。
三、     报错解决
这次扩容一个基于的自动化，结果发现在新环境执行远程命令或文件传输时，抛了如下报错：
                 = = =
       
      _    
       __
      _    __
              
                 = = =
   
                = = =
 总以为是组件安装有问题，反反复复检查，最终发现居然是多装了一个插件导致的！
解决办法：
删除已经安装 插件即可，具体原因见后文
  
下面是艰难险阻的解决过程，不喜勿看：
、看到报错，作为懒人第一时间就搜了下 【     】这个关键词，发现没能到解决方案。
、按照经验，我先找到图中 __ 函数如下：
 __
                   
           
                        
                      
              == 
                 = _
            
                 = 
            
                 = 
             
                
              
                       
              == 
                
            _    
          = 
                    
               
        _ = 
             
         = 
         =   
          = 
             = 
             = 
                 
         =  
           
               
         = 
         = 
          =    = 
                    
        _        
、很明显这个异常由  =  语句抛出，我印象中的粗暴定位方法就是不使用，直接将此语句执行看看：
     __
                   
           
                        
                      
              == 
                 = _
            
                 = 
             =    不使用，看看是从哪出来的异常
            
                 = 
             
                
            
 结果报错信息就更加具体了，如下所示：
              = = =
       
      _    
       __
      _    __
        = 
      _    
        = __
      _    __
        = __
      __    
       ___
      __    _
       
      _    
        = 
      _    
        
      _    
        
             = = =
   
            = = =
 这次基本就定位到了和这个真凶了！本以为是我的调用了，结果定位了半天，确定并没有使用。而且印象中这个插件也没用到，可这异常是怎么来的？
直到我再次在谷歌搜索【       】关键词，找到一个博客文章：=，总算知道是什么原因了！
具体原因：主要是因为  里面有个函数，覆盖了  的 里面的同名函数，导致执行__时，实际调用了的函数，因此报错！再次醉了！作者：

协议是前端性能乃至安全中一个非常重要的话题，最近在看《性能权威指南   》，把其中关于部分的内容拿出来分享一下，加了一点自己的想法，当然没有《权威指南》讲得详细，但对于理解我们平常做的事情很有启发。预计会有两三篇文章，重点分别会涉及到 、、 等内容，本篇主要涉及 及其应用。
的历史
 
的第一个版本被官方称为，这是个只有一行的协议，例如：
 

超文本响应……
连接关闭……
 有几个要点：

客户端服务器、请求响应协议
 协议，运行于链接之上
设计用来传输超文本文档
服务器与客户端之间的连接在每次请求之后都会关闭

这个版本的主要用来传输文本，并且没有共用连接。
 
一个典型的 请求过程如下：
   
   
  

   
  
 
       
         

超文本响应……
连接关闭……
相对前一个版本， 主要有以下几点变化：

请求和相应可以由于多行首部字段构成
响应对象前面添加了一个响应状态行
响应对象不局限于超文本
服务器与客户端之间的连接在每次请求之后都会关闭
实现了等传输内容的缓存控制
内容编码、字符集等协商内容的支持

这时候开始有了请求及返回首部的概念，开始传输不限于文本其他二进制内容
 
 是当前大部分应用所使用的协议版本。相对前面的版本， 语义格式基本保持不变，但是它加入了很多重要的性能优化：持久连接、分块编码传输、字节范围请求、增强的缓存机制、传输编码及请求管道。

实际上，持久链接在后来被反向移植到了上

 
  的主要目标是改进传输性能实现低延迟和高吞吐量。 作了很多性能角度的优化，另一方面，的高层协议语义并不会因为这次版本升级而受影响。所有首部、值以及它们的使用场景都不会变。现有的任何网站和应用无需做任何修改都可以在   上跑起来。换句话说 等以后我们的服务器、客户端如浏览器都支持 的时候，我们不用为了利用   的好处而修改标记，作很多额外的编码，却能享受到它带来的更低的延迟和更高的网络连接利用率交付！

 的内容将在下篇或下下篇放出，本文不对其做过多润色

 与前端性能
前面讲到， 这个版本引入了大量增强性能的重要特性，其中包括：

持久化连接以支持连接重用
分块传输编码以支持流式响应
请求管道以支持并行请求处理
字节服务以支持基于范围的资源请求
改进的更好的缓存机制

这里重点讲一下持久化、管道在前端性能优化中的一些应用
持久连接
所谓持久连接，就是重用 连接，多个请求公用一个连接。
  改变了  协议的语义默认使用持久连接。换句话说除非明确告知通过   首部否则服务器默认会保持连接打开。如果你使用的是  从技术上说不需要   首部但很多客户端还是选择加上它，比如我们的浏览器在发起请求的时候，一般会默认帮我们带上   首部。
我们来看一下为什么持久连接对我们来说这么重要。
假设一个网页仅包含一个文档及一个样式文件，服务器响应这两个文件的时间分别为及，服务器和浏览者分别在哈尔滨和深圳，两者之间单向光纤延迟为假设的理想状态，实际会比这个要大。

首先是获取文档的请求过程：


下载完毕后，连接关闭。

其次，发起资源的请求，再次经历一次握手


可以看到，两个请求都分别需要经历一次的三次握手时间，另外，图中没有体现到的是，每一次请求都有可能会经历一次慢启动 过程，这是影响传播性能的一个不可忽视的重要因素。
假如我们底层的连接得到重用，这时候的情况会是这样子：

很明显，在获取的请求中，减少了一次握手往返。

一开始，每个请求要用两个连接，总延迟为。在使用持久连接后，避免了一次握手往返总延迟减少为。这里面两次请求节省了一个， 的时间

上面的例子还只是只有一个和一个的简单假设情况，而现实世界的的请求数量比这个要多得多，在启用持久连接的情况下，次请求节省的总延迟时间就是×。
现实情况中，延迟更高、请求更多，性能提升效果比这里还要高得多。事实上网络延迟越高请求越多节省的时间就越多。实际应用中，这个节省的总时间可按秒来算了。如果每一个都重启一个连接，可想而知要浪费多少时间！
管道
持久  可以让我们重用已有的连接来完成多次应用请求，但多次请求必须严格满足先进先出，   的队列顺序：发送请求等待响应完成再发送客户端队列中的下一个请求。
举一下上一节持久连接的那个例子，首先，服务器处理完第一次请求后，会发生了一次完整的往返：先是响应回传，接着是第二次请求，在第二次请求到达服务器之间的这段时间里，服务器空闲。
如果服务器能在处理完第一次请求后立即开始处理第二次请求呢？甚至，如果服务器可以并行处理两个请求呢
这时候管道就派上用场了，管道是一个很小但对上述工作流非常重要的一次优化。
有了管道，我们的请求在一定程度上不用再一个一个地串行请求，而是可以多个并行了，看起来好像很理想：

如上图，和的请求同时到达服务器，服务器同时处理，然后返回。

这一次，通过使用管道，又减少了两次请求之间的一次往返总延迟减少为  。从一开始没有持久连接、没有管道的，到优化后的，这的性能提升完全拜简单的协议优化所赐。

等一下，刚刚那个例子好像哪里还不够好：既然请求同时到达，同时处理，为什么后面要先返回，然后再返回？两者不能同时返回吗？
理想很丰满，现实却有点骨感，这就是 管道的一个很大的局限性：请求无法很好地利用多路复用，不允许一个连接上的多个响应数据交错返回多路复用。因而一个响应必须完全返回后，下一个响应才会开始传输。
这个管道只是让我们把队列从客户端迁移到了服务器。也就是说，请求可以同时到达服务器，服务器也可以同时处理两个文件，但是，两个文件还是得按顺序返回给用户，如下图：


和请求同时到达，但先处理的是请求
服务器并行处理两个请求，其中处理  用时，处理用时
请求先处理完成，但被缓冲起来以等候响应先发送
发送完响应后，再发送服务器缓冲中的响应

可以看到，即使客户端同时发送了两个请求而且资源先准备就绪，但是服务器也会先发送  响应，然后再交付 。

题外话上面两节举的例子，说到了和请求同时到达，这是书中的例子，实际上，个人觉得这个例子举得不是很恰当。实际的中，及其包含的一般不会同时到达服务器，正常的瀑布图也不是这样的，往往是要先获取内容后浏览器才能发起其中的等资源请求。我想作者只是为了阐述原理吧，个人认为换成同一个文档中和可能更加恰当。

这个问题的原理在于层面的“队首阻塞”，感兴趣可以去复习下计算机网络的课程。其代价往往是：不能充分利用网络连接，造成服务器缓冲开销，有可能导致客户端更大的延迟。更严重的时，假如前面的请求无限期挂起，或者要花很长时间才能处理完所有后续的请求都将被阻塞等待它完成。 
所以，在 中，管道技术的应用非常有限，尽管其优点毋庸置疑。实际上，一些支持管道的浏览器，通常都将其作为一个高级配置选项，但大多数浏览器都会禁用它。换句话说，作为前端工程师，开发的应用是面向普通浏览器应用的话，还是不要过多的指望管道，看来还是期待一下 中对管道的优化吧。

不过，实际上还是有很好地利用管道的一些应用，例如在 上，有苹果的工程师分享了一个针对优化取得巨大成效的案例：通过使用的持久连接和管道，重用中既有的连接，使得低网速用户的性能提升到原来的倍！

实际上假如你想充分利用管道的好处，必须要保证下面这几点条件：

客户端支持管道
服务器支持管道
应用可以处理中断的连接并恢复
应用可以处理中断请求的幂等问题
应用可以保护自身不受出问题的代理的影响

因为的服务器和客户端都受开发者控制的应用，所以他们能满足以上的条件。这也许能给开发应用或者开发浏览器之外的应用的前端工程师们一些启发，如果你开发的网站面向的用户是使用五花八门的浏览器，你可能就没辙了。
使用多个连接
因为 管道存在上面的缺点，所以利用率不高。那么问题来了：假设没有使用管道，我们的所有请求都只能通过持久连接，一个接一个地串行返回，这得有多慢？
实际上，现阶段的浏览器厂商采取了另外的办法来解决 管道的缺陷：允许我们并行打开多个会话。至于是多少个，大家可能已经似曾相识：到个不等。这就是前端工程师非常熟悉的浏览器只允许从同一个服务器并行加载到个资源这一认识的真正来历。
持久连接虽然帮我们解决了连接复用的问题，但是现阶段的管道却无法实现多个请求结果的交错返回，所以浏览器只能开启多个连接，以达到并行地加载资源的目的。
只能说，这是作为绕过应用协议限制的一个权宜之计。可以这样打一个比喻，一个水管无法同时运输多种液体，那就只能给每一种液体开通一条运输管了，至于这个水管什么时候可以智能化到同时运输不同的液体，又能保证各自完整不受干扰到达目的地并在目的地自行分类？还是那一句，期待 吧。

这里的连接数为什么是到个，是多方平衡的结果：这个数字越大，客户端和服务器的资源占用越多在高并发访问的服务器中因为连接造成的系统开销不可忽视，每个主机到个连接只不过是大家都觉得比较安全的一个数字。

域名分区
前面说到，浏览器和服务器之间只能并发到个连接，也就是同时下载到个资源，够吗？
看看我们现在的大部分网站，动不动就几十个、，一次六个，会造成后面大量的资源排队等待；另外，只下载个资源，对带宽的利用率也是很低的。
打个比喻，一个工厂装了根水管，每次却只能用其中根接水，既慢，又浪费水管！
所以，我们前端性能优化中有一个最佳实践：使用域名分区！
对啊，何必把自己只限制在一个主机上呢？我们可以手工将所有资源分散到多个子域名，由于主机名称不一样了，就可以突破浏览器的连接限制，实现更高的并行能力。
通过这种方式“欺骗”浏览器，这样浏览器和服务器之间的并行传输数量就变多了。
域名分区使用得越多，并行能力就越强！
但是，域名分区也是有代价的！
实践中，域名分区经常会被滥用。
例如，假设你的应用面向的是网络的手机用户，你分配了好几个域名，同时加载十几二十多个、，这里的问题在于：

每一个域名都会多出来的查询开销，这是额外的机器资源开销和额外的网络延时代价。网络的查询可不像你公司的电脑一样，相反可能是好几秒的延迟
同时加载多个资源，以网络那种小得可怜的带宽来看，后果往往就是带宽被占满，每一个资源都下载得很慢
手机的耗电加快

所以在一些低带宽高延时的场景，例如手机网络，域名分区做过了的话，不光不会带来前端性能的提升，反而会变成性能杀手。
域名分区是一种合理但又不完美的优化手段，最合适的办法就是，从最小分区数目不分区开始，然后逐个增加分区并度量分区后对应用的影响，从而得到一个最优的域名数。
连接与拼合
我们前端性能优化中有这么一个所谓的最佳实践原则：合并打包、文件，以及做 。
现在我们应该知道为什么要这样做了，实际上就是因为现在 的管道太弱了，这两种技术的效果就好像是隐式地启用了 管道：来自多个响应的数据前后相继地连接在一起，消除了额外的网络延迟。
实际上，就是把管道提高了一层，置入了应用中，也许到了 时代，前端工程师就不用干这样的活了吧？ 的内容下篇讲
当然，连接拼合技术同样有代价的。

例如 ，浏览器必须分析整个图片，即便实际上只显示了其中的一小块，也要始终把整个图片都保存在内存中。浏览器没有办法把不显示的部分从内存中剔除掉。

再者，既然、合并了，带来的一般就是体积的增大，在带宽有限的环境下例如下载时间就变长，一般导致的就是页面渲染时间延后等后果。因为 和 处理器都不允许递增式执行的，对于 和 的解析及执行，则要等到整个文件下载完毕。



打包文件到底多大合适呢？可惜的是，没有理想的大小。然而，谷歌团队的测试表明， 压缩后是每个 文件大小的合适范围：既大到了能够减少小文件带来的网络延迟，还能确保递增及分层式的执行。具体的结果可能会由于应用类型和脚本数量而有所不同。

资源内嵌
 和 代码， 通过适当的 和 块可以直接放在页面中，而图片甚至音频或 文件，都可以通过数据的方式嵌入到页面中。
上面的这种方式我们称为资源内嵌。
嵌入资源是另一种非常流行的优化方法， 把资源嵌入文档可以减少请求的次数。尤其在网络等情况中，内嵌资源可以有效地减少多次请求带来的时延。可以参考这篇文章在中的一些实践。
当然，有缺点：

内嵌方式的资源，不能被浏览器、 或其他缓存代理作为单独的资源缓存。如果在多个页面中都嵌入同样的资源，那么这个资源将会随着每个页面的加载而被加载，从而增大每个页面的总体大小。
如果嵌入资源更新，那么所有以前出现过它的页面都将被宣告无效，而由客户端重新从服务器获取。
图片等非文本性资源通过 编码，会导致开销明显增大：编码后的资源大小比原大小增大！

的砖家给出一些经验：

只考虑嵌入  以下的资源，因为小于这个标准的资源经常会导致比它自身更高的 开销
如果文件很小，而且只有个别页面使用，可以考虑嵌入。理想情况下，最好是只用一次的资源
如果文件很小，但需要在多个页面中重用，应该考虑集中打包
如果小文件经常需要更新，就不要嵌入了
通过减少   的大小将协议开销最小化

小结
本文介绍了 在前端性能优化中的一些应用，有些是为了绕过 局限性的一些不得不做的事情，比如资源合并、压缩、内嵌等，这些都可以说是 来临前的一些解决问题的“黑魔法”。
 及其利用当然远远没有本文说得那么简单，我只是浓缩了一部分内容，有兴趣可以去研究《权威指南》。
下篇，稍微详细点来介绍一下 。

原文链接：


相关推荐
 学习笔记
简明笔记作者介绍：，腾讯开发工程师，在预审和优化领域从事专项测试相关工作，为腾讯游戏近个产品提供专项服务。

 导读
众所周知，苹果应用商店是苹果公司提供给开发者发布和用户下载应用软件的地方，苹果为了给开发者和用户创造一个良性、公平、健康、安全的应用商店环境，制定了一系列的应用商店审核条款，所有应用必须遵循这些条款，才能获得发布上架。不可否认，应用审核在一定程度上保证了应用商店的品质，但对众多开发者来说，应用上架苹果商店，往往是一段忐忑甚至是悲壮的旅程，经常被苹果的各种理由拒之门外，让开发者苦不堪言。本文将介绍腾讯预审团队一系列的预审策略和方法，让大家了解腾讯是怎样保障提审通过率的。
预审开展思路
最近，苹果在官网给出了截至年月份应用被拒绝的十大条款其中以上的应用被拒绝都是因为这个条款，看似简单的条款，仍然出现很多提审被拒，其实，开发者对审核条款理解和把控不够系统，是导致提审被拒的主因。

那么，看似让人眼花缭乱的审核条款，我们有没有什么办法准确和系统的去把握呢？对此，腾讯预审团队从年便开始尝试一系列的探索和积累：

分析《苹果应用商店审核指南》的条款，结合过往提审被拒的案例，进行系统的测试设计，并输出成可落地的测试用例；

在以上步骤的基础上，进行自动化分析，抽离出可自动化的模块开发对应的自动扫描工具；

将剩余的部分用例，组建专项的测试人员来进行验收；

每次版本提审，通过以上测试验收后，才会正式提交给苹果审核。


腾讯预审的探秘
根据以上工作思路，腾讯预审团队对审核对象进行模块的划分，主要包含包、提审资源以及应用内容和功能大模块一共整合了个测试点及测试用例，其中自动化扫描项个：

包的检查
主要是确保中、包文件大小、规格、私有、第三方、位等内容符合苹果要求，此部分的验收，腾讯预审团队已开发出自动化工具，通过自动扫描来完成；
提审资源的检查
主要是确保提交的应用截图、视频、、应用描述等资源是符合苹果要求的，其中资源规格属性的验收，预审团队已开发出自动化工具，通过自动扫描来完成；但资源的内容、文案等部分内容的验收，还需要人工来审查；
应用内容和功能的检查
确保应用的内容满足苹果审核审核指南中安全、性能、设计、法律等章节的条款，通常需要覆盖安装、登录、支付、公告、活动、邮件、文件存储、美国网络连通性、网络连通性等应用场景内容和功能，此部分的验收，全需要人工来审查；
除此之外，预审团队通过实时跟进苹果审核动态，依此来不断的更新和完善验收方案，持续保障产品的提审通过率，得到越来越多产品的认可，截止到今年月，服务产品已累计个，每月完成的转测次数次。在上半年的提审数据统计可见，尽管有、提审图片视频等政策变更的冲击，提审通过率仍旧保持在以上，体现了预审方案的工作成效：

各模块被拒的占比，详情如下图：

在以上被拒的数据统计中，可以发现，更多的是在游戏功能、内容和提审材料的内容，而包和提审资源规格部分被拒的次数占比很少，自动化工具带来的质量和保障也得以体现。
预审测试内容解读
 包检查的介绍
包检查项主要包含以下几方面，如、私有、第三方、位、文件等等，其中几个重要扫描规则我们将逐一进行介绍：

检查
是一种结构化的文本文件，通常所说的 “属性列表”的都使用文件来存储元信息，用来实现决定所显示的，当前支持打开的文档类型，服务声明等等。关于此部分扫描规则，来源于《    》，包含如下方面的内容：

检查
苹果官方对、、等应用程序的有明确的要求：要求包中必须包含，，，，尺寸的格式的详见下表，并且不同尺寸的内容要一致，关于此部分的扫描规则，来源于《   》：

关于 的检查，采用自动化方法实现自动解压包，并逐一核实图标是否存在并满足要求，对于不满足要求的包，给出告警提示：

私有检查
私有和 ，是苹果明令禁止的条款，每次预审都会重点跟进这部分的扫描结果。关于这块自动化的思路，在之前分享的一些文章中也曾提过了，主要是采用一些反编译工具，对的可执行文件进行反编译解析，获取头文件中库、方法和类的集合，再去逐一比对私有库和库，如有命中则给出告警提示：

文件大小检查
此部分扫描内容，主要包含包的大小、可执行文件的正文段大小和包中每个文件的大小三个方面：
 
扫描如有不满足项，则给出告警提示：

提审资源检查的介绍
提审资源包含提审图片、提审视频和应用介绍三部分，苹果对提审资源要求，主要是两方面：规格属性和内容，对于前者，预审是通过自动化来验收，而后者则是通过人工来审查的。

提审资源规格属性的扫描规则，来源于《   》，预审当前主要覆盖以下几方面的内容：

对于不满足要求的资源，则给出告警提示：

提审资源的验收规则，来源于《   》和《   》，预审主要覆盖以下几个方面内容：

每一种分辨率的视频，必须是在对应分辨率的真机上录制生成，不能采用拉伸、剪裁、填充等方式处理生成如在设备上录制的视频，通过拉伸的处理方式，生成分辨率的视频。
经典案例
 案例 
《项目》版本，提审图片不能真实反应  的内容，导致被拒。

应对措施：
图片中尽量避免提供与应用无关的内容，要表现出应用的真实内容，尤其是游戏类应用的截图，需体现游戏场景、画风、特色玩法等。针对此问题，产品修改并通过苹果审核的图片如下：

 案例
《项目》版本，视频中出现手机设备、并且存在游戏中没有的内容，宣传成分太多，因此被拒。

应对措施：
在苹果真机设备上录制应用的真实内容，尽量避免加入广告、特效等宣传成分的内容。
应用内容和功能检查的介绍
苹果针对应用内容和功能的审核，往往会比较严格，如果其中一点不满足条款便会拒绝版本，因此，大家需要熟记每个审核要点，同时也尽量要遍历应用功能。在遍历功能时要注意重要机型和固件的适配，尽量在最新的和如应用不支持，可以忽略，固件也尽量是最新的版本。对于特殊时间段，比如在秋季新系统发布前，要提前摸底版本兼容性，避免新系统发布时出现不可预知的兼容性问题，阻塞版本的提审节奏。

近期苹果要求兼容网络月号以后上架更新的，必须兼容，因此，提审前需确保应用在网络下可正常登录网络可按照苹果官网提供指导进行部署。除此之外，美国网络也不能忽视。因为苹果的审核团队在美国，他们进行审核时，使用的是美国网络，跨洲际的网络连接，难免会出现时延大、抖动、丢包等网络问题，为了提前验证后台服务器基于此场景下的反应，美国来模拟苹果审核团队的访问，可以提前爆露一些问题。
预审对这部分的验收，主要是包含以下两个模块：

文字内容的检查

主要检查应用中的公告、活动、提示，游戏类的邮件、新手指引、剧情对白等，同时还覆盖应用中链接的官网、论坛等网页内容，确保文字内容是满足苹果审核的相关条款。



应用内容的检查：主要覆盖应用中的图片、动画、视频、游戏的角色造型等场景界面，确保以上内容满足苹果审核的相关条款。

预审总结
以上便是预审主要的工作思路，核心思想是围绕《苹果应用商店审核指南》来开展验收工作，同时也在实时跟进苹果审核政策的动态，来确保预审的方向和质量。
自动化扫描工具介绍
为了提高苹果审核通过率，腾讯专门成立了苹果审核测试团队，打造出预审工具这款产品。经过年半的内部运营，腾讯内部应用的审核通过率从平均提升到。
现将腾讯内部产品的过审经验，以线上工具的形式共享给各位。在腾讯质量开放平台上可以在线使用。
点击链接即可立即体验！

预审工具分四步进行预审服务
【一键扫描】只需提供包、审核图片、审核视频、应用描述，即可在小时内拿到一份完整的检测报告，定位问题的同时提供解决方案，助您成功通过审核。
【案例分享】集结审核失败常见原因，丰富案例为您提供参考依据。
【专家服务】腾讯专家团队为您分析各种疑难杂症，提出最优解决方案。
【优化】专业优化内关键字搜索结果，让产品离用户更近一步。
希望手游在预审验收保证下，都可以快快乐乐过审，开开心心赚钱。
商业转载请联系腾讯获得授权，非商业转载请注明出处。接《浅析  穿越  的原理、技术、方法  上 》
 网络拓扑类型一：
如下图所，  位于内网，而 是具有公网的机器。如果是 需要连接 那么 直接连 就可以了。如果 需要连接 ，那么 直接  一般是连接不上的。但是我们可以反过来让 主动去连 不就可以了。下面所说的 或 的类型指的是对于 能看到的的最外层的的类型。

反过来让 主动去连 的技术就是所谓的：反向连接技术具体的穿越过程如下：

  通过向 发送请求，请求连接 。
  按需回复看是否需要启动 的类型侦测。这要看 是否已经缓存了 的相关信息
  通过可以知道 具有公网，于是， 通过发送指令给 让 主动连 并告诉 目标 的和监听端口。
  收到 的和监听端口，然后发送连接请求连上 并附带一下身份信息，于是两者就可以进行通信。
下面为了描述简便，具体的侦测步骤就省略了。
 网络拓扑类型二
如下图， 和 位于同一个后面，这个时候 和  位于同一个局域网。

具体的穿越过程如下：

  通过向 发送请求，请求连接 。
  发现 、位于同一个后面，于是返回 、 的公网、和内网、给 
  收到后，知道 和自己位于同一个里面，于是直接连上 的内网进行通信。
 网络拓扑类型三
如下图， 和 分别位于不同的后面，这个时候 和  位于独立的局域网。

具体的穿越过程如下：

  通过向 发送请求，请求连接 。
  发现 、位于独立的后面，也是通过返回给 、 的公网、和内网、给 。并且通过返回给 、 的公网、和内网、给 。
接下来的步骤和 、 的类型密切相关，下面会分别就相应的组合进行介绍具体的过程步骤。
 是任意类型，  是    和 
  一般是比较少的，因为这样的安全性很差。
  通过发送指令让 直接  的外网，由于 的是 ，于是不管三七二十一就把收到的包转发给 ，于是它们就可以顺利通信了。
 是任意类型，  是    和 
  通过发送指令让  先内网然后往 的外网发送请求由于 是  ，那么依旧是映射为，如果连接建立成功，那么它们就可以进行通信了，反之失败的话， 将失败结果反馈给 ，然后转入

  收到失败反馈，通过发送指令让 往 的外网发送请求，由于在步骤， 已经往 发送过数据包，根据过滤规则 ， 的会允许 的数据包通过并转发给 。于是，它们就建立其连接进行通信。
 的类型：映射规则是  的，过滤规则任意；  是     和   
 该步骤和情况中的步骤完全一样
  收到失败反馈，通过发送指令让  先内网然后往 的外网发送请求由于 是  ，那么依旧是映射为，由于在步骤， 已经往 的发送过数据包，根据过滤规则   ， 的会允许 的的数据包通过并转发给 。于是，它们就建立其连接进行通信。
 的类型：映射规则是非  的，过滤规则任意；  是     和   
在这种情况下，在上面的步骤的时候，由于 是非  ，那么就会映射为是_而不是了。这样根据过滤 规则   ， 的将不会允许 的_的数据包通过。要想数据包能通过 的，需要 曾经给_发送过数据。但是，我们无法通过直接的方法让 提前知道 的外网_，难道就无能为力了吗？不，还是有些方法的，虽然无法直接知道 的外网_，但是我们可以进行预测。具体过程如下：
 该步骤和情况中的步骤完全一样
  收到失败反馈，通过发送指令让  启动端口映射预测过程。端口映射预测可以简单、可以复杂，大体就是让 往的不同端口、不同发送数据包，以便收集到 的端口映射样本，以便能够根据样本的端口映射变化规律预测 的的规则。

  根据的预测情况，通过发送给 接下来 可能的映射端口列表也就是可能的外网、  ，然后让 都往这些外网、  发送数据包。

 然后 通过发送指令让  先内网然后往 的外网发送请求这个时候，假设预测算法有效的话，那么 的内网将会映射为，由于在步骤， 已经往 的发送过数据包，根据过滤规则   ， 的会允许 的的数据包通过并转发给 。于是，它们就建立其连接进行通信。

 如果在步骤的预测失败，那么在步骤将建立连接失败，然后 将失败结果反馈给 。这个时候 可以启动重试步骤或直接判断 和 无法建立直接的通信了，于是进入服务器中转环节。部分在后面会单独介绍。
 网络拓扑类型四
如下图， 和  位于多层后面。

具体过程如下：
  通过向 发送请求，请求连接 。
  发现 、位于同一个后面，于是返回 、 的公网、和内网、给 
  收到后，认为 和自己位于同一个里面，于是往 的内网发送连接请求，当然是连接不上的。
 在连接失败后，接着 尝试向 的外网发送连接请求，这个时候 收到数据包后是否转发该数据包要看 是否支持回环转换 ，如果不支持那么就无法进行直连通信，需要就需要反馈给 开启。

 在步骤失败了， 是无法知道是因为 不支持回环转换造成的失败，还是内层的行为造成的失败。于是 就假设 是支持回环转换的，这个时候网络拓扑情况就变成网络拓扑类型三了，那么接下来的穿越步骤就和网络拓扑类型三的多种情况一样的了，这里就不重复了。
上图，只是给出了 、 位于两层后面的一种情况，对于多层的各种组合本文就不介绍了。对于多层的组合，在穿透失败的时候，是比较难判断出到底是哪层的行为造成的。我们只能用上面说过的所有方法进行逐一重试，如果还是失败，那只能启动进行服务器中转了。
 服务器中转技术
由于进行穿透是否成功与的行为和防火墙策略有很大的关系，因此就算是一个友好也很难保证穿透成功。举个例子： 网络拓扑类型四，假设 、  、 都是  完全锥型，但是如果 不支持回环转换 那么也是无法穿透成功的。那么一个完整的穿透的解决方案必不可少的一个部分就是了，部分主要协议描述。作为协议的一个补充，协议主要由、、来描述，其中主要描述的是协议的，描述的是协议的，而描述的是的。下面主要介绍一下和两个文档中描述的较为重要的交互过程，具体的协议相关属性、报文结构等等，有兴趣的可以细读一下协议文档。
协议简单的来讲，如下图所示：向 发送一个 请求一个分配，如果 接收请求就会给分配一个地址__，每个都有一个有效期，过了有效期就不能使用了。在有效期内可以发送 来刷新延长有效期。 想给 发送数据需要创建权限，这个通过 请求来创建权限，权限创建成功后， 就可以发送数据给 由 中转给 ，同时 发送给 数据也会被 中转给 。如图中所示，由于 没有注册 的权限，那么 发给 的数据会被 丢弃，同时 发给 的数据也会被 丢弃。

 协议的
首先介绍，协议的，主要有两种方式：第一种是   ，第二种是。下面分别介绍这两个方式。
 方式一、   ，具体交互过程如下：

首先发送  给  请求一个分配。其中携带的主要属性：= ：事务用于标识一个交互过程=    ：可有可无的属性=    ：请求分配的有效期，期望有效期=  ：未来数据传输采用的协议 ：请求不要将数据进行分割分包转发给。
 回复一个  响应，表示请求未通过授权，需要进行用户验证。= ：事务要和的一样=    ：可有可无=  ：错误码= ：为了让客户端下次请求的时候要带上这个属性=  ：为了让客户端下次请求的时候要带上这个属性
收到响应后，发现是错误响应，那么需要给 提供用户名和密码进行验证。于是重新发送 请求。= ：另起一个事务，标识另外一个请求过程=    ：同=     ：同=   ：同  ：同=  ：的用户名=  中 响应给的=  中 响应给的=    ：一些加密信息，用于验证的
  验证通过后给响应  =  ：事务要和相同=     ：同=    ：该分配的有效期，实际有效期=  ：给分配的地址=  ：的经后的映射地址=   ：一些加密信息
收到 的响应后，发送 来创建的权限。= ：另起一个事务，标识另外一个请求过程=  ：需要创建权限的的地址，权限只与地址相关，与端口无关==   中 响应给的=  中 响应给的=  ：一些加密的信息 
 接受创建权限请求，发送   响应给=  ：事务要和相同=   ：一些加密信息
创建权限成功后，就可以用 来发送数据给 然后由 将数据给=  ：另起一个事务，标识另外一个请求过程=     ：需要发送数据的监听的注意一定要和注册权限的时候的一样，否则会被拒绝并响应错误  ：请求 不要将数据分片发送=    ：需要发给的数据内容
 收到 请求后，进行一些权限检查后，提取出协议包中的属性中的数据内容，然后将数据内容用协议从的地址源：发送给目的：   =  ： 发给的 数据包
收到数据包后，如果有响应数据，那么就将响应数据用发给 的地址   –= ：响应给 的数据包
 在的地址那收到的数据包，这时 需要检测是否注册了的权限，如果没有就会丢弃该数据包。如果有那么就取出数据包中的部分，然后将封装成协议数据包，给发送 。=  ：协议并不要求这个事务要和中的一样=  ：标识数据来自哪个=    发给的数据内容以上是   方式的核心交互过程，较为完整交互过程可以查看一下协议文档。这里有个问题需要说明一下，就是每个都有一个有效期，需要把握好有效期，及时在有效期内发送 来刷新延长有效期。
 方式二、，具体交互过程如下：

交互过程和   方式是一样的，这里就不在重复了。
权限创建成功后，发送 给 请求进行 。=  ：事务=   ：定义的  =  ： 的和=     ：同方式一=  ：同方式一=  ：同方式一=     ：同方式一
 接受请求后，给发送  响应=  ：事务，和相同=           |   
收到  后就可以通过来发送数据了。=  ：中定义  =   ：需要发给 的数据内容
 收到后首先从协议数据包中提取出，接着查找是否已经绑定，如果没有就返回错误并丢弃数据包；如果查找到有绑定，那么就提前出属性中的数据内容用协议通过的地址源：发送给 目的：。   =  发给 的 数据包
收到数据包后，如果有响应数据，那么就将响应数据用发给 的地址   =   发给的数据内容
 在的地址那收到的数据包，这时 需要检测是否注册了的权限，如果没有就会丢弃该数据包。如果有注册权限，那就检查是有绑定该，如果有那么就通过  方式数据给，否则就通过方式一中的  方式数据给=   ：中定义  =  ： 发给的数据内容
以上是的核心交互过程，较为详细的过程可以查看协议文档。方式二比方式一多了一个 的步骤，这个步骤是为了告诉 接下来以标识的协议数据包是要发给谁的，这样才使得中只要携带一个头部信息就可以，而不用携带方式一中的、等额外的头部信息，减少数据量。
 协议的
协议的是在中描述，其中主要有两种情况下的：       。下面分别介绍两种情况下。
 情况一、  ，网络拓扑如下：

在上面的网络拓扑下，有两种方式的：   主动发起的   主动发起的。下面分别介绍这两种方式的交互过程。这里 表示能够理解协议的主机，而 表示普通的一般主机。
   主动发起的：
在这种方式下， 要能够直接连接上 监听的端口才行。具体交互过程如下：

交互过程和的是基本一样的，这里就不在重复了。所不同的是中是协议，而这里是协议，并且是在一个连接中完成，我们称这个连接为 。
创建权限成功后，通过 发送 给 请求 去连接 =  ：事务=   ： 监听的和端口
 收到 后， 它会通过的地址源：尝试连接到 的，如果连接不成功，那么给响应错误码为的错误。如果连接成功那么转入，我们称这个连接为  
 连接 成功后，给发送  =    ：事务，同=    ： 给响应的标识，用于将两条连接联系起来用的。
在 上收到  ，那么需要建立另外一条连接连上 ，我们称这条连接为 。通过 给 发送 ，请求将 和  进行绑定。=  ：事务=   ：中收到的  收到 后，进行一些操作，把 和  两条连接联系起来。
通过上面个步骤以后，和 就能分别通过 和  两条连接来发送数据了。通过 发送的数据到达 ， 就会将数据原封不动通过  转发给 ，同样对于 也是一样的， 就像进行端口转发一样了。这里有个问题是：  这条连接要比 这条连接早一些建立起来的，这样在 建立起来之前 就开始发送数据的话，那么 这个时候是无法将数据转发给的，所以协议要求，只要  连接建立好了，那么 就必须做好准备接收 的数据，并将接收到的数据住，等 建立好后在转发给。但是，有些开源实现并没有这样做，所以这点要注意一下。
  主动发起的
在这种方式下， 可以位于后面，具体交互如下：

交互过程和方式的是一样的，这里就不在重复了。
 通过向的地址发起连接。  马上这个连接并做好  发送的数据流的准备。然后， 检查 拥有地址的是否已经注册了 的权限，如果没有，那么 会马上刚刚的连接。如果有，那么转向，我们把这个连接称为  
  查找到拥有地址的的 ，通过 给发送 。= ：事务=  ：中那个 的和端口=  ： 给响应的标识，用于将两条连接联系起来用的
收到 ，如果接收这个的话，那么会新起一个连接连上 ，我们称这个连接为 ，通过 给 发送 ，请求绑定  。=   ：事务=   ： 中收到的
 收到 后会通过 给发送   。
通过上面个步骤以后，和 就能分别通过 和  两条连接来发送数据了。这个方式同样存在方式中的数据住问题。在这种情况下，在 看来与之通信的是的地址， 不需要知道真实的的地址。
 情况二、  ，网络拓扑结构如下：

这种情况下，文档中并没有讲到，估计是因为这种情况是情况一的一个特例而已，我这里展开来讲一下是希望能帮助大家更加深刻理解协议本身。 和 步骤的交互情况基本和上面的一样，并且是比较独立的，所以下面直接给出了。  的步骤交互情况如下：

  的步骤交互情况如下：

从上面的交互可以知道   的地址是： ，映射后的地址是：，而 的地址是： ，映射后的地址是：。下面继续给出  和  的其他交互情况，由于它们和 的交互带有一定的时序性，下面会交错给出它们和 的交互步骤。 和 是对称，这里不妨假设 是数据交互的发起者，具体交互过程如下：

  首先通过 发送 给 ，请求连接  的地址。=  ：事务=   ：  的地址
 收到 后， 它会通过 的地址源：尝试连接到，这个连接一般都会成功，因为这个是 给的地址，我们称这个连接为  
 连接成功后，给 发送  =：事务= ： 给响应的标识，用于将两条连接联系起来用的
这个步骤和几乎同时发生的， 发现 的地址有个连接上来，那么 马上这个连接，我们称这个连接是  其实就是  ；经过权限检查后， 通过 的 给 发送 = ：事务=  ： 的地址= ： 给响应的标识，用于将两条连接联系起来用的
  收到  后，另起一个 连接上 ，我们称这个连接为 。 通过 给  发送 = ：事务= ： 中 响应的
这个步骤几乎和同时发生，  收到 ，表示接受，然后它另起一个 连接上 我们称这个连接为 。 通过 给 发送 。= ：事务=    ：中 响应的
和 分别通过 和 给  和  发送   。
通过以上个步骤，  就能借助 和  与  进行数据交互。而  借助 和  与  进行数据交互。
到这里，通信穿越的相关原理、技术、方法基本介绍完毕，关于和协议，有个开源实现，有兴趣的同学可以阅读一下源码：
另外还有一个协议，这个也有一个文档系列：这个文档系列较为复杂一些，有兴趣的可以阅读一下。     – –  – –   – –     
  参考文献
 概述      本文作者： 

 全称是   ，即，矢量图。在  中使用  可以解决位图放大失真的问题。首先，不要把  和 ，， 搞混。他们之间并没有你中有我，我中有你的关系。 是通过  的形式写在  文档中的。
如何书写
开篇说过， 就是一个 。看一下代码吧：
 = = = = =   
      = = = = = =
      = = = = =
      = = =   
           
      = = = = = =
      = = = = = =

 大家看  标签中带有一个  的属性。这其实是  中一个很重要的概念，后面的缩放都会与它有关。
说到这里，我们就需要了解一下关于  的几个基本概念。
基本概念
简单来说有  个基本概念：

 物理窗口
 实物窗口算了，下面解释
 保留横纵比

我们接下来，一个一个的进行讲解吧。

参照上面的 ，这实际上就是你用 。这  个属性，在页面上固定的矩形区域。

定义  元素在  中的具体尺寸比例。假设有如下内容：
 = = =    
  = = = =
          =  


 为  到 
 为  到 

默认情况下  是自动填充满  的。注意，在  中，子标签的所有尺寸都是不能带单位的，因为初始单位就是根据上面两个概念确定。
当为以上情况， 中基本的尺寸则不是 ，而是  = 。所以，如下的图形大小为：
  = = = =
          =  
 也就是在  里面定义的图形，它的实际尺寸为  到 。

该属性就是用来定义上面  和  相互对齐的方式。换句话就是说，它的属性可以改变  的具体位置。基本格式为： 

 定义  和  的对齐方式，分为  轴两个方向。 轴方向有三种方式：左边重合， 轴中点重合，右边重合。同理， 轴也有 顶边重合， 轴中点重合，底边边重合
 主要就是定义该  是内嵌，还是裁剪或是 听天有命。

其中， 需要着重理解一下。首先，它的默认值为 ，即为中点重合。

可以从图中看出， 是通过中心进行延展的。注意，它的原点坐标还是在  的左上角。如果你是动态增加尺寸的话，此时并不是从左到右增加，而是从中心向两端扩张。同理，如果你使用的是  的话，那么如果存在尺寸变化，那么相对点则是从左上角开始的。简单来说， 相对点其实一共有  个。

然后就是  ||  ||  这三个属性具体干的事情。
在这之前，我们需要了解一个公式缩放比计算公式：

_ _ = _ 或者 _ _ = _ 

其中， 为  简写， 为  的简写。_ 代表就是  。_ 代表就是  。_ 代表的是  轴的缩放比例。
假设有下列情况：
  = = =    =  =  
     = = = = =

 那么，_ 和 _ 分别为：

_ =  = 
_ =  = 

现在，针对上面  不同的取值，实际应用到  里面的缩放比例是不同的。

默认值 本意是让  尽可能的显示在  里，即，会在 _ 和 _ 中选择最小的值作为缩放标准。
 本意是让  完全铺满 ，即，会在 _ 和 _ 中选择最大的值作为缩放标准。

所以针对不同的取值，基准比例也不同。
当为  的情况，那么实际缩放比例为 。则里面实际矩形的大小就为  到 。

当为  的情况，那么实际缩放比例为 。则里面实际矩形的大小就为  到 。

如果你的值为  的话，他会直接铺满整个 ，即，实际矩形大小为： 到 。

响应式 
虽然讲起响应式，一些童鞋会想这  又是啥奇技淫巧？
对不起，并不是。。。就是一个  并且不带  而已。
看个实际的例子吧：
  =   
      = =
        =      
            
        =           
                    
             
 

 可以看到，上面的  标签并没有带上啥  属性，只是简单描述了  的范围而已。当然，里面的尺寸标准都是在这  的范围内进行设置的。
另外，在这里声明一下，本文章并不是新手教程，也就是说，不会教你一步一步的画直线啊，圆啊，矩形啊等等这些基本图形。这些直接  一下，一搜一大把。所以，这里假设大家的水平是处于，能对  基本的图形属性熟悉即可，对一些高级属性还不是很清楚和熟练。，继续
在  中，能够直接使用的图形有








上面没有啥说的，后面我详细说一下两个比较重要的概念，分组和 。
分组和 
通常  和 分组通常是一起使用的，如上：
  = =
     =      
         
     =           
                 
          

 分组我们放到后面进行讲解，这里先看一下 。

 在  中的地位应该是比较高的，实际上，利用  这个一个标签可以画出任意的图形。 中  属性是用来定义相关线条数据，通常是以  为起始，代表的就是 的意思。在  中，一共可以定义  种不同的图形。例如 ，。 大家可以注意，每种标识符有两种书写方式，即，大小写。

大写 参照的是绝对坐标，即， 的右上角
小写 参照的相对坐标，即，前一个点的坐标。

而在  中不同表示符中，又可以分为直线和曲线两种不同的标识符。这里，我们分类来讲解一下。
线型

该使用定义起始点的，没啥特殊的作用。 = 
 表示，以  为起始点。

原意是  ，用来画线段的。格式和  差不多：      

用来画水平线，即，。既然方向已经定了，剩下的就是距离，格式很简单：     

用来画竖直线，即，。同上，方向也定了，格式为：     
 看个例子吧：  =          
 该  实际上就是画了一个正方形，宽 = 高 = 。 

该标识符用来表示  的结束，并且将最后一点和  标识开头的一点连接起来。所以，它不存在什么表示点之类的，格式为：  
 而上面也可以进行相关的优化，最终的结果为：
 =          
 使用 
 =         = =
曲线
曲线就是  画图中常见的  贝塞尔，，  很多贝塞尔  等。
我们简单看一下：

这是正统的贝塞尔曲线，需要  个参考点，下图应该说比较确切表示了二次贝塞尔所需要的点。所以， 需要定义三个点。

基本格式为：              
 例如：  =         = =

该标识符实际上使用来表示一个反射贝塞尔，即，在原有贝塞尔上再加一段贝塞尔曲线，所以， 一般和  一起使用。
基本格式为：           
 实际样式图为：

相当于原有的贝塞尔曲线的最后一段进行反向延长并对称。然后加上新定义的一段限制曲线。
具体实例为：  =              = =

该标识符是用来定义二次贝塞尔曲线，该曲线相当于上面传统的贝塞尔来说，更加简单，它只需要定义三个点，即可完整一个贝塞尔曲线，具体作图过程如下：

基本格式为：
           
 即为图上点， ，
起始点为  定义的点，例如： =       = =

该标识符和  差不多，也是一个贝塞尔曲线的延长。相当于原曲线的控制点  相当于    做对称，然后，只需要定义一个终点即可，即， 只需要定义贝塞尔曲线里面的终点即可：      
 如图：

所以，简单来说，， 是两两搭配一起使用的。在使用的时候，千万不要搞混即可。
弧线

该曲线是用来画弧线，而，弧线通常是圆椭圆的一部分。当，椭圆的两个轴径长相等则为圆，所以， 是按照椭圆作为基准格式：
       
        
 说实在的，这个比较复杂。因为，他画椭圆的方式和我们平常不一样，一般情况下，椭圆只要确定一个中心，然后是长短轴，然后是弧度范围即可。
但是，它这里是通过椭圆上的两点来确定的，在加上旋转角度，俩轴径等因素来确定的。另外，需要注意，它的起始点是从上一个命令的结束点位置开始计算的。，我们首先简单了解一下格式里面的参数：

 代表的就是长轴短轴，没得说。
 代表的是弧长的结束点。开始点就是上一个命令的终点。
  轴的旋转角度。顺时针为正
 表示取大弧还是小弧。因为两点之间的弧长有两部分。
 取顺时针的弧，还是逆时针的弧长。参考点是以起始点开始的。

上面几个属性中，比较难理解的就是 和。这么说吧，前面几个属性充其量只能确定椭圆的位置，和经过椭圆的两个点，不过，一般能通过指定两点的椭圆有两个，而通过这两点划分又会出现  段弧长。为了确定  个弧长中，是哪一个，需要两个值来确定。即， 抽 ， 抽 。

简单说一种，例如当， 和  都为 的情况。首先， 为  选择的是小弧长。所以，里面两段比较小的弧长被抽出来。然后， 为  选择的是逆时针。即，以起始点为参考，选择通过逆时针方向到达终点的那段弧。即， 抽 。最终得出我们需要的弧。
说实在的，这个是真  复杂。。。
给一个参考 。
一般情况下，我们并不需要手动来确定 ，有工具为啥不用工具呢！
比如，  等，都可以自动生成 。不过，生成之后，需要对代码做相关的压缩优化，这些都可以直接在编译器里面找到。
你也可以用一下可视化工具  来简单看一下。
分组
 中的分组你可以理解为  中的图层，一块图层里面通常只会放一下高内聚的图形，这样既方便移动又方便做动画。 中的分组标签就是，使用 标签包裹的所有子元素都认同为一组。
例如：
 
     = = = = 
     = = = = 
  
  
     = = = = = 
     = = = = = 
  
 需要注意的是，使用  进行分组，并不会改变原有元素的在屏幕上展示的效果。
不过，标签除了分组，还有另外一个很重要的功能动画
分组动画
在分组重定义动画是直接写在  属性当中的。实际上，每个子标签都可以使用  的相关属性。
  =    
  

 每种变换动画之间是通过 空格或逗号 连接的。它的执行顺序是从右到左。为啥呢？实际上可以理解为，这就是几个嵌套的  叠在一起。
  =    
    
  

      
   =
    =
      =
        =
          =
           
         
       
     
   
 
 具体可以使用的动画形式和  动画一模一样，详情可以参考  动画

原文链接：叶劲峰 现任腾讯  专家、互动娱乐事业群魔方工作室群前台技术总监。他获得香港大学认知科学学士、香港中文大学系统工程及工程管理哲学硕士。他是《游戏引擎架构》译者、《  中文版第五版》审校。他曾参与《天涯明月刀》、《斗战神》、《爱丽丝：疯狂回归》、《美食从天降》、《王子传奇》等游戏项目，以及多个游戏引擎及中间件的研发。他是开源项目  的作者，开发  比较  个开源原生  库的标准符合程度及性能。他在  年学习  语言， 年开始使用  于各种项目。


上图中展示的书籍表示游戏程序员可能应该获得的知识技能。当然，其它的学习方式也很重要，例如练习、课程、产业学术会议出版物等。

原文来自：随着大数据时代的到来，一个大规模生成、分享、处理以及应用数据的时代正在开启。如果能将互联网上异源异构的非结构化或半结构化数据转换为更易处理的结构化数据，可以极大的降低获取数据的门槛，为信息检索和数据挖掘提供基础，更好的挖掘数据中蕴藏的价值。
单纯考虑网页这种半结构化数据的抽取：对于搜索引擎一般需要抽取出页面的标题、实际标题、时间、正文等关键信息；而对于去哪儿、携程这种酒店预定网站则需要进行更精细化的信息抽取，需要抽取出酒店名称、地址、电话、价格、评分、简介等具体属性。
可以看到，大量互联网产品都依赖抽取功能，因此迫切需要一个方便、便捷、高效且准确的网页抽取平台。
一常用抽取方法
目前针对这种半结构化的页面，业界比较流行的抽取方法大致就两类：树分块以及模版抽取。
树分块
该方法的基本思想就是对页面建树后，对树进行遍历，同时根据事先训练好的分类模型判断遍历到的容器节点的语义块类别，本质上就是分类问题。比如对新闻网页，一般定义的语义块类别有标题、实际标题、时间、正文、相关推荐、相关阅读、版权、广告等。如果用分类模型进行语义块判断，需要用事先标注好的样本进行训练。采用的特征集合包括该节点下的文本长度、特定关键词命中情况、标点符号个数、图片个数、标签宽度、各种标签的分布情况等等。
通过模型预测节点的语义块类别会有几个候选，整体上会得到若干语义块组合序列，最后可以再用语言模型的思路得到一个最优序列。
该方法的优点是通用性强，主要工作包括定义新类别页面的语义块类别、样本标注、训练模型、抽取程序，一般用于大规模网页的处理；缺点是一般抽取到的语义块比较粗，精度不高。另外样本标注也需要大量的人力成本和时间成本。
模版类
针对下面这个页面

图 豆瓣电影详情页
我们希望抽取导演、编剧、主演、类型、语言、上映日期等字段的信息， 树分块的方法就不太适用了。因为这块区域整体上属于一个容器节点，子节点的特征方面区分度也不大。
因此有了第二类抽取方法：模版类抽取。该方法的基本思想很简单：事先配置好需要抽取内容的模版，模版可以是正则表达式或， 然后基于进行精确的模版匹配，将匹配结果输出。该方法的优点是可以实现精细化抽取，缺点是模版的配置和维护成本较高。如正则抽取比较依赖页面中的，把作为桩，提取出桩周围的有用信息，因此对配置人员的正则能力要求比较高。
精细化抽取现在业界采用比较多的是，作为文档路径标准语言，通过路径表达式来定位与查找文档中的节点。使用进行精细化抽取的优点有：
很多主流的浏览器都提供获取指定节点路径的功能，或者可以通过嵌入的代码从中获取路径，因此易于实现可视化配置，降低配置门槛。
依赖页面结构。而实际上一个网站或者一个子域下的页面结构确实大体一样，或者基本可以穷举，因此配置一组往往可以覆盖一个子域甚至一个站点下的页面。
作为标准集下的一个重要标准，被广大厂商接受并推广，已经有很多开源且成熟的实现，因此更易得到社区的广泛支持。
本篇重点介绍我们在模版抽取方面做的工作，包括如何使配置简单化、如何对抽取的结果进行去噪、如何维护模版的更新、如何快速接入抽取等等；
在开始介绍抽取平台之前，先看看刚才那个豆瓣页面我们的抽取效果：

图 豆瓣电影详情页抽取结果
二平台的整体框架及介绍
系统分为配置管理、抽取以及去噪处理三个主要模块：
 配置管理：负责配置的管理、更新与分发。
 抽取：根据配置的抽取页面中指定的属性。
去噪处理：对抽取的结果做去噪处理。

图 抽取平台整体框图
配置
为了降低配置门槛，做到人人可配、人人会配，因此在设计和实现模板配置的和交互的过程尽量做到简洁明了、轻量级、引导式交互、及时响应等原则。

图  配置页面
抽取过程
整个抽取过程比较简单，因此直接使用流程图来说明抽取过程。

图  抽取流程
去噪处理
虽然的抽取能精确到元素粒度，但很多时候仍然有大量的噪音存在。为此，我们提供了四个方面的噪音过滤规则：
文本规则：通过配置正则表达式将属性值中的噪音去除。
规则：针对链接元素，通过配置规则，将属性不满足规则的节点过滤掉。
元素属性规则：通过配置标签的属性规则进行噪音过滤。
规则：通过配置起始串与结束串，将中以起始串开始，以结束串终止的子串过滤掉。

图 噪音过滤规则配置页面
元素抽取
在实现的过程中，发现有一类属性的属性值是一个，内元素之间是并列的。比如专辑《吻别》页面中，名称、歌手、发行时间等字段属于普通属性，但专辑下的曲目则属于类型的属性。

图 百度音乐专辑页
元素有以下特点：拥有一个相同的祖先节点，从该祖先节点开始节点名称、层次以及深度都完全相同，并且在某个或某几个层级上是平行关系偏移不一样。上述专辑页中任意两首歌曲的即满足该特点：
《恋爱的人都一样》：
《拥抱阳光》：
根据这一特征，为了更好的表达和抽取这类属性值，我们将上面歌曲属性的虚化为：
其中作为占位符，抽取匹配的时候会具体化为实际的数字。
属性的抽取流程为：

图  属性抽取流程
抽取指标及运营工具
平台经过近一年的持续迭代和运营，各项指标趋于稳定；平台的稳定性和可靠性得到验证；运营工具趋于完备，监控告警也基本做到全方位无死角。下面从三个方面来说明：
运营指标：各项指标都在稳步上升，数据质量也在持续提高。数据在资讯推荐、音乐搜索以及部门内数据挖掘类需求中得到应用，数据质量经受住了业务的考验。
   最近两周系统主要运营指标如下，可以看到各项指标稳中有升，系统的运营状况良好。



日期
站点数
模板数
模板数
网页数
抽取成功数
成功率































表  平台运营指标
运营工具：提供了下载诊断与查询、快照查询、抽取检查、标准集验证、模板评测、抽样验证、抽取诊断等一系列的运营诊断工具。从配置、下载、快照、抽取到最终数据等环节都力争做到可运营。
监控告警：结合一年以来暴露的运营问题，不断丰富对抽取各项指标的监控，提高系统的可用性和可靠性。目前主要告警有整体抽取失败报警以及模板抽取成功率跌幅超过阈值报警。
三暗网数据抽取
通过上面的抽取平台，我们已经具备将互联网上大部分网页转换为结构化数据的能力。但是对于互联网上存在的“暗网”数据，由于其自身的特殊性，需要专门设计和优化我们的下载和抽取系统，下面主要介绍我们在这方面的思考和解决方案。
暗网的形成
时代，随着用户对应用的体验要求越来越高，大量相关技术应运而生，特别是技术的兴起，使得应用的用户体验接近客户端类的体验，因此被业界广泛采用。这类应用的架构大体是这样的：

图  请求流程
这类富应用对于用户来说比较友好，却对信息检索提出了考验。现今的搜索引擎爬虫大部分还是基于页面之间的链接关系，但对于这种无法通过超链接扩散以及抓取的动态网页，则无法被搜索引擎收录， 因此形成所谓的“暗网”。
另外，随着移动互联网的兴起，信息出现了多元化、异构化及碎片化的趋势。大量数据从端向移动端转移，甚至有很多数据就是为移动端而生的。这类数据的典型特点是，通过常规的页面链接无法获取，形成一个一个的信息孤岛。为了解决数据获取问题，业界主要从下面两个方面入手：
开发更强大的爬虫系统，以应对信息的孤岛化。从相关新闻可以看到：百度针对搜索引擎的升级和更新中，很大一部分与解决“暗网”问题有关。
与“暗网”网站合作，数据厂商通过平台方开发的提交结构化的数据，来达到信息的互联互通。像前不久推出的应用内搜索，就是通过这种方式试图打破信息壁垒。
难点及解决方案
通过大量的案例分析，发现存在两个方面的问题：
下载扩散
对于常见的网页，我们可以通过页面之间自然的链接关系被爬虫抓取，但是这类暗网页面往往无法通过正常的链接关系获取，接口之间是独立的。因此要扩散到这类动态接口，必须通过特殊的规则生成它们。这里我们归纳并抽象了一类特殊的模板类型：链接工厂模板，该模板是专门用来生产的。根据中可变的参数，在类型下我们会预定义个属性参数。然后通过定义一个拼接规则，将链接工厂类页面中抽取出来的属性填充到拼接规则中，生成最终的数据接口。
整个生成流程如下：

图  生成与扩散流程
抽取
我们的抽取平台是基于的， 因此对于接口数据格式为的异步请求，我们只要通过上面的方法生成并下载便能进行抽取。但在富应用中已经成为广泛采用的数据格式，为了接入上面的抽取框架， 这里我们采用的是将数据转换成格式的方法，然后使用进行抽取。

图  数据抽取
可以看到，上述对暗网页面的下载与抽取比较好的适配在原有框架里，仅仅增加了一种链接工厂模板用于链接扩散，以及在抽取环节增加了一个数据类型转换的适配器模块。
、暗网抽取案例分析
在资讯推荐项目开发及运营的的过程中，发现今日头条新闻列表页都是采用的方式加载的，通过抓包以及分析源码发现，今日头条推荐频道的数据接口地址为：
=____=__=_=_=

图 今日头条推荐频道异步请求

图 今日头条发起异步请求的代码
该接口是格式的接口，而新闻详情页的为中的一个字段，如图所示：

图 今日头条数据字段详情
我们将转换为文档，转换后的结果为：

图 转换为的今日头条接口数据
标红的部分即为新闻详情页的，可以通过正常的抽取出来，然后将该推给下载系统下载。通过这种特殊的扩散方法，今日头条的新闻才得以被下载系统下载，进而通过进行抽取。
四未来展望
未来希望在以下几个方面进行改进和优化，使得结构化抽取平台越来越完善。

平台配置的简易性：后续会在配置管理上持续优化，提高平台的易用性，进一步降低配置门槛和学习成本。

抽取任务接入更加方便快捷，降低接入所需的沟通成本和开发成本，实现自动化和通用化。

支持更多的数据输出格式：目前是输出基于协议的、格式的文件，未来会支持更多的数据格式。


同时欢迎有需求的团队联系我们，使用腾讯文智自然语言处理。

相关推荐 【 文智背后的奥秘 】系列篇：情感分类 【 文智背后的奥秘 】系列篇：文本聚类系统 【 文智背后的奥秘 】系列篇：关键词智能提取导语： 花叔在个人技术公众号里写了一篇关于小程序打赏的文章，也许内部同学也有做小程序打赏功能的需求，于是特意转过来一下，希望对大家有用。

最近跌了不少，所以想谈谈“钱”的事，于是我们就谈谈小程序的“打赏”吧。强行把逻辑拉到线上
先扯扯微信打赏的一些事
话说，在这之前，里公众号文章是支持打赏功能的。

但后来苹果爸爸强迫微信爸爸下架了这个打赏功能微信下还能用，想必这事让好多自媒体的收入下降了不少，不过微信官方还是提供了一个替代方案：在里，文章底部放个收款二维码。

虽说这确实解决了燃眉之急，但这体验却不大一样了，毕竟转账是转账，打赏是打赏，目的都是送钱，但体验和感觉却不一样。花叔表示打赏是情怀！是情怀！转账是什么鬼！
这是公众号打赏的一个小事情。
有同学看到这里，可能就问了，你干嘛说公众号的事！你不是要说小程序的打赏么！
所以接下来，花叔要提一下同一时期发生的一个事情，正当大家目光被“苹果爸爸怼微信打赏”这事吸引时，市面上出现了一个叫“群应用”的小程序，这个小程序很特别，竟然能实现打赏功能：

这小程序是花叔的一个叫杨芳贤的微信好友做的，不得不佩服芳贤，因为这应该算是首批鲜有支持打赏的小程序中的一个，能想到这个打赏方案，确实也是牛！
当时各种公众号也写了关于这个“小程序打赏”的介绍。
然而好像没有哪篇文章说过这是怎么实现的，花叔今天尝试分析一下，大家先耐心看看，我后面还会引出另一个更神奇的玩法。
“小程序打赏”的实现逻辑
打赏也是交易行为，存在“付款”和“到账”的行为。在小程序里，只通过自身的“小程序支付”的是实现不了整个过程的，它只能实现“付款”操作；而“到账”操作是通过“企业付款”的方式来实现的，在  上均有这两种方式的介绍：

可能这么说大家不大懂，花叔举个栗子：
在上述小程序打赏的技术方案里，用户打赏了用户，技术层面到底发生了什么呢？

概况起来是这样的：
、用户首先在小程序里唤起“微信支付”的技术接口，通过这个接口把钱先付给该小程序企业的对公账户
、然后小程序记录用户的付款数值，同时用户的钱包里就累加一笔到款金额所以小程序必须具备一个钱包功能
、而用户要提现的时候，小程序后台就会调起“企业付款”的接口，以用户指定的金额付款给用户的“微信零钱”
说到这里，大家应该大概知道这原理的大概了，这里面是有一个“中间商”的，而“中间商”还可以抽佣，所以现在部分具备同样打赏逻辑的小程序，会在用户提现的时候抽取左右的手续费，而且在用户提现前，钱都在“中间商”的账号里。
打赏和提现不可能做到同步，所以一定存在一个不动的资金池，所以越多人打赏，闲置的资金就越多，至于企业能拿这个钱做什么？呵呵呵，花叔就不细说了。
说完这个，本文要结束了。
骗你的  　ﾟ∀ﾟ ﾉ
接下来结合小程序别的一些特性，会发生一些神奇的事情：
第一，借助第三方打赏小程序，侧公众号文章将可以变相实现原本的打赏交互。
怎么说？
早在《解读最新小程序跳转方式，请叫我预言花》一文中，花叔提及过公众号文章跳转小程序的新方案

里面提到了“文字链接”和“图片链接”的小程序跳转方式，那么奇特的事情出现了。
假设市面出现那么一个第三方的、专门用来打赏的小程序，当它跟公众号互相绑定后，公众号的文章中将可添加一个图片来模拟“赞赏”按钮，然后点击可跳转到一个能实现打赏的小程序内页，比如：

借助于这种方式，你能让你的公众号文章在里变相实现原本的“打赏”体验。
第二，个人开发者小程序或者没有“打赏”功能开发能力的企业小程序，借助第三方打赏小程序，将可变相具备这个“打赏”能力。这个又怎么说呢？
同样在花叔早前撰写的《火速体验了一下小程序互跳功能》一文里提到，只要两个小程序绑定了同一个公众号，那么这两个小程序将可实现小程序内页里的互相跳转。
在这之前，有个问题一直困扰着个人开发者，那就是个人开发的小程序没法调起微信支付接口没权限，花叔还专门请教了微信官方的同学，对方明确表示暂没有让个人小程序具备这个权限的打算，也就是说个人小程序没法做打赏功能。
但结合“互跳”以及上述的打赏小程序，困扰已久的个人开发者小程序没法被打赏的问题，就可以解决了。

具体思路也简单，有点类似第一点说的套路，这里就不演示了。
遗憾的事，这种方式依然需要您的小程序跟打赏用的第三方小程序绑定同样的公众号。。。
如果对方不愿意绑定，那个人开发者小程序是不是就没法直接在小程序内页进行打赏了呢？
也不是的，要知道小程序内长按识别菊花码是可以跳转到任意其他小程序的，而这种做法并不会被限制。也就是说，理论上在一个小程序里，通过菊花码识别的方式能跳转到任意一个别的小程序，从而可实现打赏，以“小程序”为例：

当然这种方式肯定没有直接“点击某个按钮或者某个图片”跳转到打赏小程序的方式快捷和方便，但起码也能解决打赏问题了。要知道，以往要实现用户对的打赏，花叔只能提供一个小程序内没法识别的二维码图片，然后提示用户进行保存，然后再想办法去识别，这种反人类的交互，基本没啥用户会去做。
好了，这回真的是说完了。打造黑苹果四安装系统
前情回顾
打造黑苹果一组装硬件的选择与组装打造黑苹果二制作黑系统安装盘打造黑苹果三设置
前言
经过前面的步骤，我们可以正式开始我们的系统安装工作了。这里，我再提醒一下，如果你的硬件不支持黑系统，又或者你的  设置不正确的话，那么在这里是没办法进行下去的。会不断的重启呀之类的。
另外，再强调一点，内存条必须插在靠近一侧的插槽上，否则是会不断重启的。
如果你确定你的硬件没有问题，内存条也插在正确的位置，但是还是不行，那么基本是  设置有问题，就不断的调整，知道为止。
我没在这一步遇到太多的坑，除了内存条插的不对，但是也是经过反复尝试了几次的。
另外，你需要对你主板集成的网卡以及声卡的芯片有所了解，可以去中关村或者太平洋的网站上查，把芯片记下来，然后安装驱动的时候需要。
开始安装   系统
首先，第一步，插入你制作好的安装盘，开机时选择盘启动。再次强调一遍，是  开头的盘，而不是只是一个盘名字的盘。
选择盘进入安装过程中之后，会出现一个四叶草的界面，如下图，我们选择如下图的图标       ，用方向键，左右键控制。选好了之后，我们回车，进入安装过程。忘记拍照了，这张图片是在网上找的。

进入安装后，会出现黑色背景，白色的苹果，持续大概几分钟，会出现下图的界面，选择语言。

我们选择以简体中文作为主要语言 ，然后点击下面的圆形向右的箭头，进入到下面的图片，我们点击继续。


然后就出现了一个软件许可协议之类的东西，我们点击继续，会弹出一个对话框，我已经阅读并同意软件许可协议的条款，我们点击同意，然后进进入下图的界面。

如果你准备安装的固态硬盘没有格式化，那么，这里应该只有一个，如果安装过黑，则会出现两个，就像我的这张图一样，我们点击顶部的实用工具，然后再下拉菜单里面选择磁盘工具，打开如下图的磁盘工具面板：

在磁盘工具面板的左侧，我们选中我们准备安装黑系统的固态硬盘，然后点击标题栏下面的抹掉按钮，将会弹出如下图的抹掉面板。

如上图所示，我们在抹掉面板中进行如下设置：

名称，后面输入  
格式，我们选择    
方案，我们选择   

选择好后，我们点击下面的 抹掉 按钮。然后会有一个进度条，完成后，会出现绿色的对勾图标。我们点击完成。这里的界面和前面制作盘是基本上一样的，就不放图片了。这里，需要注意的是，有可能执行一次会失败，如果失败了，就再来一次，一般就成功了。
完成之后，回到先前的选择安装盘的界面，我们点击  ，也就是我们刚刚格式化的硬盘，然后继续，进入安装进度条界面。

等待十几分钟，安装完成之后，会重启。
重启进入黑设置过程
重启电脑的时候，我们依然要选择用盘启动。在下面的四叶草的页面，我们选择  的图标，就是中间的这个，进入系统。

这个时候因为驱动的关系，可能在显示器上只能显示中间一部分，周边有一圈黑边，没有关系，我们搞好之后就好了。等黑底白果的图标过后，就出现了下图，选择你的地理位置，我们选择中国，点击继续

然后就到了输入法的设置页面了。你可以勾选简体拼音或者五笔型，根据你的需要，选择好之后，点击继续

然后就到了设置网络连接的页面。在这里，我们选择 我的电脑不连接到互联网选择好之后，点击继续，然后会弹出一个对话框，我们确定一下。

然后就到了传输信息到这台的设置页面，我们选择 现在不传输任何信息 ，点击继续

然后是定位服务的设置，我们去掉 在这台上启用定位服务 前面的勾选，点击继续，会弹出确认对话框，我们点击不使用

然后是条款与条件界面，愿意读一下吗？我是直接点击 同意

弹出对话框，确认一下，我们继续点击 同意

然后就是创建电脑账户了。我们根据下面的标签，设置你的账户名以及密码。强烈建议设置为英文或者拼音的，设置好之后，我们点击 继续

然后，就出现了选择你的时区 我们在地图上点击中国的大概区域，一直点击到 北京市  中国 ，也可以在下拉框里面选择。

然后是一个诊断与用量的界面。这里，我们取消掉两个勾选。咱自己黑的就不给苹果公司添麻烦了_|||选好了之后，我们点击 继续

然后就是 启用 ，我们选择启用，然后点击 继续

然后就设置好了，就会弹出一个正在设置的界面，出现了经典的旋转菊花

设置完成之后，就进入桌面了，我忘记了这里会不会重启了，因为这些操作很流畅，所以一路继续到这里了。
如果在这里设置好了要重启，重启的时候，我们依然选择盘启动，然后选择的这个图标，进入。
进入系统之后，会检测你的键盘，你点击一下继续，然后按一下键和？键，会自动判断出你的键盘的类型。确定保存即可。

到这里，我们的黑系统就已经安装在我们的硬盘上了。下一章节我们讲如何设置系统引导以及安装驱动。
这一章节的内容在网站上寥寥带过，其实本来也不难。但是对于初次黑苹果的人来说，可能稍微有点懵逼，所以我就全程拍照下来作为记录，以便于你的操作。
然后，我们重启电脑，依然选择从盘进入，和上面的一样，选择的这个图标，进入系统。
本文由原创，允许转载，但转载必须附注首发链接。谢谢。
首发链接：关键字：无服务器，云函数
分享人：陈杰
腾讯云架构平台部技术专家，年云计算经验，现供职于腾讯架构平台部，负责弹性计算及云函数技术研发，致力于提供领先的基础设施平台以提升资源利用率及优化提升程序员开发运维效率。
继虚拟机，容器技术，无服务器化成为新的行业热点，无服务器云函数可以让用户无需关心服务器的部署运营，只需开发最核心的业务逻辑，即可实现上线运营，具备分布容灾能力，可依据负载自动扩缩容，按照实际调用次数与时长计费。本次主要分享腾讯云无服务器云函数在技术实现上的挑战及架构实现原理。
主要从以下四个方面来分享一下无服务器云函数：云函数的价值及使用场景云函数架构原理云函数关键技术点云函数行业进展趋势
无服务器云函数  是腾讯云提供的无服务器执行环境，帮助用户在没有购买和管理服务器时仍能运行代码。用户只需要使用云平台支持的语言编写核心代码及设置代码运行的条件，代码即可在腾讯云基础设施上弹性、安全地运行，并可完全管理底层计算资源，包括服务器、内存、网络、代码部署、弹性伸缩、负载均衡等服务。
使用无服务器云函数将可免除所有运维性操作，企业和开发者可以更加专注于核心业务的开发，实现快速上线和迭代，把握业务发展的节奏。
一、云函数的价值及使用场景
随着云计算服务市场的成熟，用户对云计算接受程度逐渐提高，借助各类基础云组件，将业务上线时间从月级缩短到天级，但对比传统模式，用户仍需基于云组件重构非功能性需求。
云函数尝试将业务算法和流程提炼出来交由用户实现，打通各种云服务，并实现通用的负载均衡、自动伸缩、故障容灾、安全监管等通用功能，真正使得用户像搭积木一样打造个性化服务，将业务上线时间从天级缩短到分钟级。

相比云主机，云函数更适合于支持微服务架构业务场景。以图片多规格压缩服务为例，该服务在用户上传图片至时，自动将原始图片压缩成适配手机、平板、电脑等多种大小的规格。如利用云函数实现该服务，用户只需创建函数，定义函数触发条件为“图片上传”，在线编辑或使用完成代码编写后上传，服务即构建完成。用户上传图片时，自动调用定义的函数完成图片的多规格压缩，云函数平台根据上传并发量自动扩缩容函数实例，并最终按照实际调用消耗计费。

从该示例可以看出，云函数为用户带来的主要价值为：

加快用户服务上线时间，用户只需实现业务算法及流程，上线时间缩短为分钟级

减少用户的运营负担，用户无须承担服务扩容，故障恢复运维工作

消除用户的资源成本，用户无需承担资源闲置费用，只为实际调用消耗付费


二、云函数架构原理
云函数平台整体架构原理如图所示。

云函数为用户提供两种使用方式，并通过事件注册与回调机制与其它云组件打通，提供标准的接口；调用分发根据函数所属的区域，用户，名字，版本号，鉴权等信息申请函数实例，并将调用均匀的分发到可用函数实例；函数管理负责创建修改删除函数，并提供函数代码管理，版本管理等功能；函数调度根据函数资源需求选择合适的位置创建销毁函数实例；函数实例部署用户定义的函数，负责函数的执行及监管。
从云函数的定位及架构原理看，衡量云函数平台的关键技术指标可概括为：

不仅支持业务快速上线，且能实现持续发展

不仅支持业务按需取用，且能释放闲置资源

不仅支持业务永不中断，且能扩展运行范围

不仅支持业务自由运行，且能避免干扰入侵


下文将展开详述。
三、支持业务快速上线，且能实现持续发展
支持业务分钟级上线，需要尽可能的减少用户研发工作量，云函数用户仅需提供简单的函数配置及代码即可完成上线。以图片压缩为例，用户自行编辑代码如下，即可实现一个图片压缩服务：

其中第行引入依赖库，第行解析输入参数，第行调用库完成图片压缩，行判断结果及返回。用户可在线完成代码的编辑并提交，也可像开发本地程序一样使用喜欢的编辑，调试通过后打成包通过提交，提交成功服务即上线。
支持业务可持续发展，需提供用户函数平滑升级及版本变更能力，当用户更新函数代码或配置后，新调用请求被分发至新函数实例，原调用请求执行完成后，旧函数实例自动消亡，服务在客户不感知情况下平滑更新。即将支持用户函数多版本管理，将函数别名映射至用户指定版本，在客户不感知情况下实现多版本间平滑切换。

函数运行过程中间，用户打印日志，标准输出错误输出日志分类上传至腾讯云日志服务平台，用户可实时监控函数运行情况。
四、支持业务按需取用，且能释放闲置资源
要支持云函数真正按需取用，需实现用户第一次调用时延迟分配资源，函数调用过程如下图所示：

云函数平台在调用分发时，会判断是否有函数实例存在，如若不存在，则实时启动实例，实例启动完成后，才开始执行函数调用。为了达到第一次调用足够快的目标，在调用过程中需分阶段逐层优化：

分发调用阶段：需减少调用分发层级，比如对于用户主动发起的同步调用，正常路径可免去存入持久化队列过程

镜像及代码下载阶段：需尽量预部署以减少下载时间，比如对新提交函数，并行启动预加载，使得第一次调用发起时无须再去实时下载

容器启动过程：需简化容器启动脚本，使得启动过程尽量轻量，对于对延时敏感的业务，提供实例预留机制，用户可选择预留少量实例以减少第一次调用的额外延时

执行函数调用：需尽量减少函数参数，返回数据及日志传递导致的内存拷贝次数

返回调用：需尽量减少返回层级


通过逐层优化，第一次调用平台耗时可控制在左右，后续调用平台耗时控制在左右。随着客户请求量的增加或减少，函数实例随着自动扩缩容，一般算法如下：
 当前请求数当前实例数  扩容阈值：扩容实例
 当前请求数当前实例数  缩容阈值：缩容实例
当缩容至最后一个函数实例时，为避免函数实例短时间内重复启动停止导致客户调用延时增加，需保留一段时间延迟释放。
五、支持业务永不中断，且能扩展运行范围
要支持云函数永不中断，需实现个容灾目标：

硬件故障时服务不中断

平台升级时服务不中断


为实现这三个容灾目标，整体架构需实现化，且在各层均需对应的支持：

接入层：基于腾讯云实现横向扩展，负载均衡，层路由能力

逻辑层：实现模块无状态化，模块内部无状态数据，可随意启停替换

数据层：采用一致性存储仓库存储关键数据

节点层：实现快速节点故障检测及替换恢复


比如平台内部模块实例硬件故障时，如下图所示，由于模块无状态，故障时可由接入层模块自动剔除，剔除后新请求分发至剩余模块实例，已接收的异步事件可由其它重试完成，同步调用会直接返回给用户错误请求，由用户重试，在故障实例恢复后，自动添加至中，继续分担负载。

当平台需要升级接口时，采用只增不改策略，提供新版本接口，保持用户原有服务兼容性，用户采用新接口时，通过层路由，路由至新版本模块实例，旧版本实例随着负载的降低逐步缩容，新版本实例随着负载升高逐步扩容，以此实现了用户透明的版本平滑升级。

要实现云函数需与各类云组件打通，需要云组件提供事件注册及回调机制，云组件提供可注册事件及对应的回调接口，云函数确保云组件通信的用户权限打通传递。当前云函数实现了与腾讯云存储组件的打通，马上将实现与腾讯云、云监控等其它云产品的打通，并将运行范围扩展至节点及设备网关，实现边缘计算。
六、支持业务自由运行，且能避免干扰入侵
云函数需支持用户本地测试通过的代码无缝在云函数平台，需具备足够的兼容性，及用户函数运行时环境，需要具备和用户开发测试环境类似的软件包，安全等配置同时避免函数间干扰，防止恶意入侵。
为了避免用户函数间干扰，云函数使用了容器来封装函数实例，通过的名字隔离、空间隔离、权限限制等机制实现用户间隔离，辅以实时冲突监控调度等措施及时处理干扰。
为了避免用户执行代码影响整个云函数平台，如下图所示，实现了云函数管理平台与用户函数的隔离，用户函数无法感知管理平台的网络地址，运行日志等信息，从而无从影响云函数平台的运行。

为了避免用户恶意代码对网络的探测和入侵，如下图所示，用户函数实例被限制到了受限的公共网络，需通过网关实现与外网服务、其它函数实例、云组件的互访，同时，为了支持用户函数实例与个人虚拟机的集成，云函数平台通过弹性网卡打通了与其私有的网络通信。

七、云函数行业进展趋势
近年、微服务等理念逐步深入人心，云函数开始被用户了解接受。为了满足用户对于更快速上线、更低成本、更优架构的求索，腾讯云推出了云函数产品。用户不妨从解决实际问题开始试用云函数，比如实现一个简单的服务拨测工具，实现一个定时任务，实现存储于的图片、视频、文件的计算等。。随着云函数可联动云组件的拓展，支持语言的丰富，调试工具，流程引擎等逐步完善，云函数会逐步成为整个云平台的粘合剂，将各种云组件融合一起，让云成为你的公共后台，到时可支持更为复杂的状态服务场景，成为用户通用体贴厚实的后盾。
欢迎试用腾讯云无服务器云函数产品，云函数解决安全接入、故障容灾、自动伸缩、成本优化、版本管理等后台通用问题，用户可更省心专注的投入到业务创新。希望通过云函数能更深入的开放腾讯多年在海量服务耕耘修炼的能力，共享给广大用户使用，与大家一起成长。


：请问代码怎么部署到中：直接将代码下载至母机，再将代码目录挂载至
：云函数是通用的 还是只能在云平台运行：云提供了云函数服务，自己也可搭建，目前上有不少开源云函数平台，比如，等，建议直接使用云的服务，因为可以和多个云产品打通，单靠云函数自身难以构建完整服务。
：事件传递使用的是队列吗：异步事件用了消息队列持久化存储，同步事件未使用
：请问云函数对开发语言有限制否？如果有，目前对语言的支持如何？：目前支持    ，如果有通用的用户需求，可以支持其它语言，比如等
：有系统函数调用吗？自定义函数的颗粒度有何建议？：绝大部分的系统调用都可调用，除了一些危险操作，比如关机，重启，网络服务监听等，函数颗粒度可参考微服务的设计原则，将功能尽量拆细
：可落地吗？：已有不少用户案例，后续会做些分享，不妨亲自试试，当前是免费的，会一直提供免费包，有需求直接给我们提
：云函数支持语言吗？：之前没用户反馈需要这种语言的支持，不过我个人挺看好，会持续保持关注
：请问将请求调度函数实例，这个调度算法的实现？：其实这里就是通用的负载均衡和扩缩容算法，这里比较复杂的是提前预测需要扩容，后续会详细分享。
：能介绍下 将请求调度到函数实例的实现吗？：这里有个模块对每个函数维持有一个请求队列，目前没设置优先级，按照先来先到的顺序依次调度，调度时会从函数所有可用的函数实例中，选择一个下发。函数实例里有个循环接受请求，收到时传递参数调用用户函数。
：代码可以下云落地吗？：代码里一般会涉及其它云产品的调用，所以一般对云平台有一些依赖，可以关注下开源的框架，在公有云云函数上封装了一层，用来解除依赖，实现在各个云平台的平滑迁移。
：云函数的代码有哪些限制？比如什么样的函数不可以调用，什么样的库不能？：可以基本认为无限制，但会禁止恶意行为，比如关机，重启，端口扫描等；也会禁止端口监听，因为常驻进程不符合云函数按需启用的原则。如果预装库不符合要求，可以自行将依赖库打包至里上传。
：下层的容器编排是基于什么做的？么？：基于腾讯云的容器平台，其底层是
作者：，腾讯后台开发高级工程师

年
年月日，腾讯横空出世。光阴荏苒，那个在你屏幕右下角频频闪动的企鹅已经度过了个年头。随着一同成长的你，还记得它最初的摸样吗？
年：腾讯的前身诞生，该版本具备中文网络寻呼机、公共聊天室以及传输文件功能。

年，正式更名为，发布视频聊天功能、群和秀等功能。

年版本，发布聊天场景、捕捉屏幕、给好友播放录影及炫铃等功能。　　
年，新增个人网络硬盘、远程协助和小秘书功能。
几经更迭，版本也产生许多变化，很多操作方式都变了，也让更有现代感了。如今的越来越精美，越来越简洁，如你所见。


据不完全统计，腾讯月活用户达到亿左右，而这个数字还在不断增加
如此庞大的用户群的任何行为，都会产生巨大的影响。
年春节，推出红包加入红包大战，经调查手机的红包全网渗透率达到。
在此期间，后台想必又一次承受了海量的压力，年后第一波推送，来看看腾讯内部对后台的接口处理的相关技术干货，或许可以给到你答案。
一、背景
后台提供了一套内部访问的统一服务接口，对腾讯各业务部门提供统一的资料关系链访问服务，后面我们把这套接口简称为。
现在说说分的背景：年的某一天，某个业务的小朋友在申请正式环境的接入权限后，使用正式环境来验证刚写完的测试程序，循环向接口机发送请求包，但因为这个包格式非法，触发了解包的一个，导致收到这些请求包的服务器群体 ，无一幸免。。。。整个系统的服务顿时进入瘫痪状态。
因此有了故障隔离的需求，年初，我们着手的故障隔离增强改造。实现方法就是分服务把不同业务部门的请求定向到不同的服务进程组上，如果某个业务的请求有问题，最多只影响一个部门，不会影响整个服务系统。
二、总体方案
为了更清楚描述分的方案，我们通过两个图进行分前后的对比。
分之前：

 分之后：

从图中可以看出，实现方式其实非常简单，就是多启动一个进程根据到的映射关系分发请求包到对应的进程上。
三、分尝试
很多事情往往看起来非常简单，实现起来却十分复杂，分就是一个典型的例子。怎么说呢？先看看我们刚开始实现的分方案。
实现方案一：通过转包给分进程，分进程直接回包给前端。

这个方案刚发布几台后就发现问题：
，有前端业务投诉回包端口不对导致访问失败。后来了解这些业务会对回包端口进行校验，如果端口不一致就会把包丢弃。
，比原来上涨了同样的请求量，原来是，使用这个方案后变成
回包端口改变的问题因为影响业务业务就是我们的上帝，得罪不起，必须马上解决，于是有了方案二。
实现方案二：通过转包给分进程，分进程回包给，由回包。

改动很快完成，一切顺利，马上铺开批量部署。。。。
晚上点准时迎来第一次高峰，出现大量的丢包和告警，运维紧急迁移流量。
第二天全部回滚为未分的版本。
重新做性能验证的时候，发现比原来涨了，按这个比例，原来多台机器，现在需要增加多台机器才能撑起同样请求的容量。这是写本文时候的机器数，目前机器数已经翻倍了
后来分析原因的时候，发现网卡收发包量都涨了一倍，而基本上都消耗在内核队列的处理上，其中竞争资源的_占用了超过的  这也正是我们决定一定要做无锁队列的原因。
四、最终实现方案
做互联网服务，最大的一个特点就是，任何一项需求，做与不做，都必须在投入、产出、时间、质量之间做一个取舍。
前面的尝试选择了最简单的实现方式，目的就是为了能够尽快上线，减少群体掉的风险，但却引入了容量不足的风险。
既然这个方案行不通，那就得退而求其次退说的是延期，次说的是牺牲一些人力和运维投入，方案是很多的，但是需要以人力作为代价。
举个简单的实现方法：安装一个内核模块，挂个钩子，直接在网络层进行分，再把回包改一下发送端口。
这在内核实现是非常非常简单的事情，但却带来很大的风险：
，不是所有同事都懂内核代码
，运营环境的机器不支持动态加载内核模块，只能重新编译内核
，从运维的角度：动内核 == 杀鸡取卵  内核有问题，都不知道找谁了
好吧，我无法说服开发运营团队，就只能放弃这种想法了即便很不情愿。
跑题了，言归正传，这是我们重新设计的方案：

方案描述：
，使用一写多读的共享内存队列来分发数据包，每个创建一个_，同个下面的多个服务进程通过扫描_进行抢包。
，在分发的时候同时把收包端口、客户端地址、收包时间戳用于防滚雪球控制，后面介绍一起放到_中。
，服务处理进程回包的时候直接使用 回包，把回包的端口写成收包的端口。
看到这里，各位同学可能会觉得这个实现非常简单。。。不可否认，确实也是挺简单的不过，在实施的时候，有一些细节是我们不得不考虑的，包括：
１这个共享内存队列是一写多读的目前是一个进程对应一组化共享内存队列，的个数可以配置为多个，但目前只配一个，占单不到的开销，所以共享内存队列的实现必须有效解决读写、读读冲突的问题，同时必须保证高性能。
２服务需要侦听后端的回包，同时还要扫描_中是否有数据，这两个操作无法在一个或者_中完成，因此无法及时响应前端请求，怎么办？
原来的防滚雪球控制机制是直接取网卡收包的时间戳和用户层收包时系统时间的差值，如果大于一定阀值比如，就丢弃。现在不再直接收包了，这个策略也要跟着变化。
基于通知机制的无锁共享内存队列
 对于第一个问题，解决方法就是无锁共享内存队列，使用来解决访问冲突。

这里顺便介绍一下  ，就是一个汇编指令，用于原子性执行  ：如果内存地址指向的值等于，就把写入，否则返回失败。
那么，读的时候，只要保证修改的操作是一个原子操作，谁成功修改了，谁就获得对修改前指向元素的访问权，从而避开多个进程同时访问的情况。
 对于第二个问题，我们的做法就是使用注册和通知机制：

工作方式如下：
负责初始化信号共享内存
进程启动的时候调用注册接口注册自己的进程，并返回进程在进程列表中的下标
在进入睡眠之前调用打开通知接口把对应的置位，然后进入睡眠函数
写完数据发现共享内存队列中的块数达到一定个数比如，可以配置的时候，扫描进程，根据对应为的位取出一定个数比如，可以配置为进程的个数的进程
遍历这些进程，执行发送信号，同时把对应的位置防止进程死了，不断被通知
进程收到信号或者超时后从睡眠函数中醒来，把对应的置，关闭通知
除了通知，其实还有很多通知机制，包括、，还有较新的内核引入的、等等，我们之所以选择比较传统的通知，主要因为简单、高效，兼容各种内核版本，另外一个原因，是因为的对象是进程，我们可以选择性发送，避免惊群效应的发生。
防滚雪球控制机制
前面已经说过，原来的防滚雪球控制机制是基于网卡收包时间戳的。但现在拿不到网卡收包的时间戳了，只能另寻新路，新的做法是：
收包的时候把收包时间戳保存起来，跟请求包一起放到队列里面，收包的时候，把这个时间戳跟当前时间进行对比。
这样能更有效的做到防滚雪球控制，因为我们把这个包在前面的环节里面经历的时间都考虑进来了，用图形描述可能更清楚一点。

五、性能验证
使用_和 后，接口机处理性能基本跟原来未分的性能持平，新加的进程占用的一直维持在单 以内，但摊分到多个上就变成非常少了对于核的服务器，只是增加了的平均开销，完全可以忽略不计。
最后，分的这个版本已经正式上线运行一段时间了，目前状态稳定。

对许多企业而言，虽不一定经历月活亿用户，但为了能够面对蜂拥而来的用户游刃有余，时刻了解并保持自己的最优状态迎接用户，一定要在上线之前对自己的网站承载能力进行一个测试。如果自己没有服务器，没有人力，没有钱，都没有关系
腾讯提供了一个可以自主进行服务器性能测试的环境，用户只需要填写域名和简单的几个参数就可以获知自己的服务器性能情况，目前在腾讯平台可以免费使用。
腾讯服务器性能测试运用了沉淀十多年的内部实践经验总结，通过基于真实业务场景和用户行为进行压力测试，帮助游戏开发者发现服务器端的性能瓶颈，进行针对性的性能调优，降低服务器采购和维护成本，提高用户留存和转化率。
功能目前免费对外开放中，点击  即可体验！
如果对使用当中有任何疑问，欢迎联系腾讯企业：接海量之道系列文章
《 海量之道系列文章之弱联网优化 一》《 海量之道系列文章之弱联网优化 二》《 海量之道系列文章之弱联网优化 三》《 海量之道系列文章之弱联网优化 四》《 海量之道系列文章之弱联网优化 五》《 海量之道系列文章之弱联网优化 六》
 多异步
经过前面不懈的努力，初步打造了一个比较好的技术根基，好马配好鞍，好车配风帆，怎么就把领先优势拱手送与特斯拉了。
用户欲壑难平，资源供不应求，靠“术”并无法优雅的解决。跳出来从产品角度去观察，还有些什么能够触动我们思考的深度呢。根据不同的需求和使用场景，用有损服务的价值观去权衡取舍，用完美的精神追求不完美，此乃道的层面。
所谓大道至简，完美之道，不在无可添加，而在无可删减。通过多异步和各类缓存机制，提供区分网络、区分业务场景下的差异化服务，是我们孜孜以求的大“道”。
下面通过一些实践案例的总结，来探索简洁优雅的弱联网体验改善之道开始肆无忌惮的吹嘘了。
①　【网络交互可否延后】
微博客户端某个版本启动时，从闪屏加载到界面需要秒。这样的体验是无法接受的，与用户秒以内的等待容忍度是背道而驰的。从技术角度去分析，很容易发现问题，诸如我们在启动时有个并发的网络请求因为是短链接，意味着个并发的网络链接、闪屏加载、主创建、本地配置加载、本地持久化数据加载至等等程序行为，优化的目标很自然就集中在网络请求和本地配置、持久化数据加载上。
梳理并发网络请求，可以从以下三个方面考察：
        哪些请求是要求实时拉取的，比如  提及  私信的数字、身份校验；
        哪些请求是可以异步拉取的，比如、用户、云端配置、双向收听列表、闪屏配置、分组列表、相册列表等；
        哪些请求是可以精简或合并的，比如  提及  私信的数字与身份校验合并；
此时，取舍就非常简单和清晰了，启动时个网络请求足够应对。所做的仅仅是把一些请求延后发起，这是一种异步机制。
在移动里面还有大量类似的场景，比如用户更新了的某个设置项或者自己的某个字段，是停在界面上转菊花等网络交互返回后再提示结果，亦或是把界面交互马上还给用户，延后异步向服务器提交用户请求，这里面的价值取向不同，“快”感也便不同。
②　【网络内容可否预先加载】
微博客户端在刷新时，用户向上快速滑屏，到达一个逻辑分页比如条微博消息时，有两个取舍，一是提前预加载下个分页内容并自动拼接，给用户无缝滑动的体验；二是等到用户滑动到达分页临界点时现场转菊花，卡不卡看当时的网络状况。实践中选择了方案一。用户在滑动浏览第一个逻辑分页时，就利用这个时间窗主动预先拉取下一个逻辑分页的内容，使得用户能享受一个顺畅的“刷”的体验。
所做的仅仅是把一个请求提前发起了，这也是一种异步机制。思考的要点是：
        预先加载的内容是用户预期的吗，预先加载和自动下载之间，失之毫厘谬以千里；
        预先加载的内容对用户移动设备的资源比如流量、电量等和后端服务器的资源比如带宽、存储、等消耗要做好估算和判断，体贴和恶意之间，也就一步之遥；
        预先加载区分轻重数据，轻数据可以不区分网络状况，重数据考虑仅限优质网络下执行，最好这些策略云端可以控制；
        预先通过网络拉取加载或存储的过程中，不要打搅用户的正常使用；
在移动中，预加载有大量的实践，比较典型的就是升级提醒，大家都采用了先下载好升级包，再提示用户有新版本的策略，让你顺畅到底。
③　【用户体验可否降级】
微博客户端在香港公共下刷新总是失败，通过后台用户接入请求和响应日志分析，判断是香港到香港公共的汇接口带宽窄、时延大，此时该如何应对。
从前面探讨的网络知识，可以知道，在一个窄带宽高时延网络中，吞吐量必然很小，也就是说单位大小的数据传输所需的时间会很长。如果按照通常一次下发一个逻辑分页数据的策略，那么从服务器到客户端传输，整个数据需要拆分成多个数据报文，在缓慢的传输过程中，可能一个数据报文还未传输完成，客户端的链路就已经超时了。
如果在弱网络需要在应用层有测速机制，类似的机制，测速时机可以是拉取微博消息数字时下，把逻辑分页的微博消息数由调整为会如何，如果方案成立，用户刷微博的体验是不是会下降，因为滑动一屏就要做一次网络交互，即便是配合预加载，也可能因为网络太慢，操控太快而又见菊花。外团在香港实测了这个版本，感叹，终于可以刷了。
在饥渴难耐和美酒佳肴之间，似乎还有很多不同层级的体验。聊胜于无，这个词很精准的表述了服务分层，降级取舍的重要性。思考的要点是：
        产品的核心体验是什么，即用户最在乎的是什么，在做宏观分层设计时要充分保障核心体验；
        每个产品交互界面中，什么数据是无法容忍短时间不一致的，即什么是用户不能容忍的错误，在做微观分层设计时要充分考虑正确性；
        在宏观和微观分层的基础上，开始设想在什么条件下，可以有什么样的降级取舍，来保障可用，保障爽快的体验；
        分层不宜太多太细，大部分产品和场景，层足矣；
在移动弱网络条件下，处处可见降级取舍的案例。比如网络条件不佳时，降低拉取缩略图的规格，甚至干脆不自动拉取缩略图等等，分层由心，降级有意。
④　【端和云孰轻孰重】
移动时代，绝对的轻端重云或者轻云重端都是不可取的，只有端云有机的配合，才能在一个受限的网络通道上做出更好的用户体验。正所谓东家之子，胖瘦有致。
比如移动网游，如取向选择轻端重云，那么玩家的战斗计算就会大量的通过网络递交给服务器处理并返回，卡顿家常便饭，操控感尽失。
比如微博客户端，如果取向选择重端轻云，微博所有的消息都拉取元数据比如微博正文包括文字、各类、话题、标签、、消息的父子关系、消息中用户、关系链等等，由客户端实时计算拼装，不但客户端用户需要消耗大量流量计算量，而且给后端服务器带来巨大的带宽成本和计算压力，如果过程中网络状况不佳，还会非常卡顿。
通过实践总结，端和云孰轻孰重，取舍的关键是在数据计算规模可控和数据安全有保障的前提下：
        减少网络往复，要快；
        减少网络流量，要轻；
端云有机结合，可以很好的演绎机制与策略分离的设计思想，从而使系统具备足够的柔韧性。
不得不再次特别提到的一点是，缓存技术是异步化的基础，它渗透在性能和体验提升的方方面面，从持久化的、文件，到短周期的内存数据结构，从业务逻辑数据，到协议栈，它无所不在。缓存涉及到数据结构组织和算法效能耗时、命中率、内存使用率等、持久化和启动加载、更新、淘汰、清理方案等，有机会我们可以展开做专题的介绍。牢记一个字，缓存是让用户爽到极致的利器，但千万别留下垃圾。
提倡多异步，实际上是要求团队认真审视产品的核心能力是什么，深入思考和发现什么是用户最关心的核心体验，把有限的资源聚焦在它们身上。通过考察用户使用产品时的心理模型，体验和还原用户使用场景，用追求完美的精神探索不完美之道。
互联网服务核心价值观之一“不要我等”，在移动互联网时代仍应奉为圭臬，如何面对新的挑战，需要更多的学习、思考、实践和总结，这篇文章即是对过去实践的总结，亦作为面对未来挑战的思考基点。
老子曰过：上士闻道，勤而行之；中士闻道，若存若亡；下士闻道，大笑之。不笑不足以为道。求求你了，笑一个。
知易行难，故知行合一似为扯蛋，那么我们就且扯且珍惜吧。在以上两篇文章中我们已经在腾讯云服务器上搭建好了爬虫环境了，下一步就是在云服务器上爬上我们的爬虫，抓取我们想要的数据：【腾讯云的种玩法】云服务器搭建环境【腾讯云的种玩法】云服务器搭建爬虫环境
今天我们要抓去的目标网站是，国内最大的年轻人潮流文化娱乐社区：哔哩哔哩   ゜ ゜つロ 干杯   站自建站以来已经收纳了大约六百多万的视频，那么今天我们就写一个爬虫去征服这六百多万条视频信息。

我们想抓取的就是上面的播放次数、评论数量、硬币数量以及收藏数量，接着我们开始。
、先分析首先第一步这些数据在哪里？我们第一个想到的就是在网页源码里面，于是我们查看源码，搜索相关信息。
遗憾的是我们会发现，信息并不在源码中；紧接着我们打开开发者工具查看请求信息。
_=_==_=
我们可以对以上的进行修剪，删除一些不是必须要的参数。我们先观察这个，是这个视频的唯一标识不能删除，我们可以先把其余的参数都删掉试试看，如果不成功我们在一一加参数测试。
_=

显然，删除了非必要参数之后对内容毫无影响，所以我们只需要知道每个视频的就可以抓取所有的视频信息了。那么站的视频是怎么编号的呢？我们可以多观察以下会发现这个是一个自动增长的主键，从开始递增。于是我们代码思路有就了。
、写代码使用库来请求获取数据，并使用的内置库来提取数据。
现在已经可以抓取单个视频信息了，让你的小爬虫遍历整个站的视频。
现在你只需要把你的爬虫一直开在服务器上就了。

相关推荐
【腾讯云的种玩法】云服务器搭建环境
【腾讯云的种玩法】云服务器搭建爬虫环境
知乎简史：为了理解知乎，用云上爬虫分析了创始人的个回答和位种子用户作者 |郭小发编辑 | 顾乡
   
开篇
这篇文章描述了使用语言利用决策树以及随机森林对的一个分类问题解题的全部过程。本文需要读者对机器学习中的决策树、随机森林的原理有所了解，并且知道基本的语言语法。
背景
关于
是一个进行数据挖掘和预测竞赛的在线平台，任何人都可以参加竞赛。企业或者组织者将实际问题的背景、数据、目标发布到，广大参与者可以分析、提交答案，最终根据准确率排名。的竞赛题目有些有奖金，而有些则是数据分析挖掘的练习场。我们这次练手的就是这样一个级别的题目   。
关于    
题目网址： 大致背景如下：闲来无事的研究员把研究院里面的只怪物的特征都测量了一遍，根据特征已经对只怪物进行了分类，分为、和三类。而剩下的怪物的分类工作就交给我们了。
这是一个分类问题，后面我们用决策树来完成这个任务。
关于决策树
不知道决策树是啥的请自行
观察数据
初步观察数据
从网站上下载训练数据和测试数据，放在目录下第一步当然是看看这些数据都长什么样子，有哪些特征可以处理。首先将数据读取进来，合并成一个通过增加一个变量_来区分训练数据集和测试数据集。合并成同一个的好处就是后续所有的特征变量的转化操作都可以在训练数据集和测试数据集上同时生效。
 加载包


读取训练数据集和测试数据集 
  
_   
  
_  

 合并两个训练集
  _ 

 转化_为
_  _
先来看一下数据集中的变量：
结果如下：
        
                  
  _          
  _        
  _          
  _         
                  
                   
  _        
数据集中除了变量和_外还有其他个变量。
数据集中各字段含义：

 怪物的标号
_ 骨头的平均长度标准化到
_ 腐肉的百分比
_ 毛发的平均长度标准化到
_ 灵魂的百分比
 体表颜色，分为’’’’’’’’’’’’六种
 怪物的类型，分为’’、’’和’’三种查看所有变量的描述性统计信息：

结果：
          _       _      _
                          
                
                
                        
                
                        
  _                            _  
                 
               
            
              
         
       
其中四个变量_、_、_、_的原始数据都已经被标准化。而变量、、_都是因子变量。从_变量的分布中可以看到训练集有个记录，测试集有条记录。变量就是这次分类算法的响应变量。
整体数据很工整，也不存在缺失值，预示着我们很快就可以直接撸模型了。
数据初步分析
我们先看看各变量在各个怪物分类上的分布情况，来人工筛查一些各个变量和分类结果的相关度。
 加载画图包


 取出训练集数据
  _ ==  

 对_、_、_、_四个变量做分析
   
  
_  _ _ _ _
  _ {
   _ =   = _   =   
        _ 
         =  
        _    
        
     
}
 其中是一个自定义函数，用来将多张图画在一起。具体代码见附件。
 =   = 

通过图像可以看到怪物中的两类和在四个变量上区分度比较高，而则处于中间位置，同其他两类的特征都有交集。
查看图形，可以初步有如下的推断：

最终的预测准确率会低一些。
_和_两个特征上和区分度相对比较高，后续模型中的重要性应该会高一些。

而其他例如腐烂度等一类的指标看不出什么名堂。我们继续看下颜色是否和怪物的类型有关系
 查看颜色和类型的关系
 = =  _  =_=
这个结果充分说明，各种怪物对颜色也没有特别的偏好，基本所有颜色中三种怪物比例都差不多。
接下来再看看各变量之间的散点图，直观的感受一下各变量之间的相关性。
 各个指标的散点图
____ =  =   =       
三种怪物的变量相互交织在一起，人类已经没有什么好办法了，剩下的就交给计算机吧。
模型训练
基础模型
特征都已经处理好了其实我们什么都没有做，汗，现在开始扔进模型里面看看吧。我们用语言的包里面的决策树来对样本分类。
首先设置决策树的控制参数
 加载包 



 设置决策树的控制参数
   节点中样本数如果小于则分裂停止，否则节点继续分裂子节点 
   树中叶节点包含的最小样本数 
   决策树最大深度 
   交叉验证的次数 
     任何提升效果小于此值的分裂尝试都会被剪枝掉 
  =====
我们简单粗暴的将所有特征都加到模型中
 设定随机种子，保证后续的计算一致性


 模型公式
    _  _  _  _  

 训练模型
 ：根据因变量的数据类型选择相应的变量分割方法 连续性=“”离散型=“”计数型=“”生存分析型=“”
 ： 生成的提前剪枝的设置变量
  = = = =
模型结果中有很多信息，其中比较重要的是一个变量重要度，给出了各个模型特征在模型训练中的重要程度。
 查看变量重要度
=
 = = =
通过条形图可以看到_和_的重要度要高一些，而这个变量毫无贡献度，这点也和上面的箱线图表现一致。
我们把最终的决策树图画出来看一下。
加载画图包


 画图
 = = = =
我们看一下模型在训练集上的准确度
  预测的类型 取值，则结果为分类 
  =

 查看结果
 
 结果
                  
                   
                   
                   

 准确率
   
 
训练集上的准确度为，看起来还不错，我们趁热打铁，在测试集上训练一下结果，提交答案。
 测试集上计算结果
  _ ==  
  =

 生成结果
   =   = 
  = _  = 
我们把结果文件_提交到上，很快在 上面获得了我们第一次提交的结果，准确率 。这个准确率有点低，说明我们还有很长的路要走。
特征再加工
题目给的变量较少，我们在之前的重要度图上也看到了_和_的重要度比较高。我们组合_和_来得到一个新的特征。我们依次将四个变量一一相乘获得新的个变量，然后再重新用决策树训练一下。
 两两组合生成新的变量    
_ = _  _
_ = _  _
_ = _  _
_ = _  _
_ = _  _
_ = _  _

 增加新的次方来生成新的变量
 = _  
 = _  
 = _  
 = _  
重新观察一下新的变量的分布，可以看到最右下角的_变量几乎将和给完全分开，同时和的区分度也增加了。

重新训练模型，并在测试集上计算，提交验证。


 重新获取训练集和测试集
  _ ==  
  _ ==  

 将新的特征量加入模型
    ______ ____


 训练新的模型
  = = = =
我们看一下新的模型的变量的重要度。

可以看到我们新加入的变量_的重要度最高，说明对模型的贡献度最高。
 重新训练以及预测
   =

 生成结果
   =   = 
  = _  = 
这次提交上去之后，准确率提高到
随机森林
俗话说，三个臭皮匠顶个诸葛亮。机器学习里面也有类似的技术，就是模型组合。对于决策树来说，随机森林则是一个简单易行的模型组合方法。使用的方式建立一个森林，森林里面有很多的决策树组成，随机森林的每一课决策树之间是没有关联的。在得到森林之后，当有一个新的输入样本进入，就让森林中的每一颗决策树分别进行判断，看看这个样本属于那个类，然后看看哪一类被选择多，就预测为那一类。
加载随机森林包



设定种子


 设定控制参数
  =   折交叉验证 
   折交叉验证中的， = 则是折交叉验证
   交叉验证的次数
   打印训练日志
   =   =   =   = 

 训练模型
    =    =    =    = 
预测结果
 重新训练以及预测
  

 生成结果
   =   = 
  = _  = 
此次提交结果是 
参考书籍

   
    
   


相关推荐
小菜鸟对周志华大神的理解【文智背后的奥秘】系列篇——自动文本分类机器学习在 视频编码中的实践裴泽良，年加入架构平台部，一直从事运营系统相关的建设工作，历经了腾讯海量存储及服务的运营体系从入门到初级再到较为完善的各个阶段，目前专注于提升腾讯云上业务的运营质量，以及建设新一代高效与安全的自动化运维体系。

运营体系
在介绍我们的运营体系前，有必要先简单介绍下我们的业务及其特点，方便大家更好的了解我们的运营体系为何是这样。

图架平所服务业务的特点
 架构平台部后面简称架平承载的业务涵盖了腾讯主要的海量存储、场景，譬如微信聊天图片视频、朋友圈图片小视频、空间相册图片视频、腾讯视频点播直播、腾讯云、微云等的文件、图片、视频、语音等场景，在全球拥有数十万台服务器、数百个机房、几十的下载带宽、级存储量，为全球用户提供上传、下载等服务。
 类存储系统提供了类似于文件系统的文件存储服务，譬如微云里面的文件、朋友圈图片均存储在此，类存储系统提供了存储服务，譬如空间的、说说，以及的索引数据等均存储在此。类存储系统相关的内容会在本系列其他文章中有详细介绍，这里不再描述。

图架平运营体系
架平的运营体系主要包括基础配置、成本预算核算、报表流程测试、质量监控、现网操作这五大块，这五大部分组合成一个完整的运营体，为部门业务安全可靠高效的运营保驾护航。
：基础性的配置管理，包括了设备、机房、业务等基础信息，主要提供设备资源提前报备、到货验收初始化、高危端口管理、设备转移退役等功能；
成本预算核算：部门承载了公司海量的存储、服务，每年的运营成本占了公司总运营成本的相当一部分，必然要有全面、严谨的成本管控核算；
报表流程测试：业务多报表多，需要有个报表系统来统一管理，现网变更的管理、突发事件产生后的跟进需要流程系统，以及对现网质量关键的保障自动化测试；
质量监控：我们的眼睛，时刻盯着数十万台服务器、成百上千个业务，一旦出现异常，最快秒级主动通知到负责人，降低对业务的影响时长；
现网操作：几十台机器的时候，不需要建设复杂专用的现网操作管理系统，几百台甚至上千台的时候还可以依靠这类脚本来搞定，但如果服务器达到数十万台、分布在各种不同运营商、甚至海外机房、等场景时，就必须要有一套专用系统来支撑对现网安全、高效的操作。
我们今天主要讲的就是海量设备、海量业务服务场景下的现网操作。
在安全与效率中追求极致的自动化运维
一、自动化运维的背景
这里说的自动化运维主要是探讨与现网操作相关的内容，譬如业务扩容、变更、异常的分析与处理等，这里面都会涉及到对生产机的操作，譬如要登录到生产机、要修改文件内容、要执行相关命令等。
 当整个服务只有几十台机器、很少数业务的时候，可以不需要，也不需要专用的扩容变更等系统，直接采用记录机器模块关系一台台登录到生产机的方式就能够满足日常的管理变更等需求，其实很早期的后台也就是这么玩转的。
 当机器规模上升到几百台、业务开始多元化的时候，很显然就需要建设规范化的，以及要借助专用的管理工具，譬如、等，否则效率极低同时又极易出错引发人为事故。
 但当机器规模上升到数万台、数十万台，且分布在全球各个区域、不同运营商，业务数量增长到以百计、千计时，这些开源的自动化运维工具也不可能无法满足我们的需求，我们就需要根据业务特点建设专用的运营管理系统。
二、 我们业务对自动化运维的诉求
海量业务服务下的运维理想中的效果就是各种各样的操作都能在安全的前提下同时拥有最高的效率。这里面的核心目标就是安全与效率，但这两者常常难以兼得，要操作效率那就不能任何操作行为都受到限制，否则就谈不上效率，要安全那就要求任何操作行为都提前审批、预定义好，但在复杂多变的业务场景下这就谈不上效率了。
当然了理想状态可能难以达到，但是我们可以靠近理想状态，通过建设自动化的运维体系从体系层面来保障安全，同时做到尽量减少人工参与，提升操作效率。
三、自动化运维的体系建设

图生产机权限管理体系
 架平数十万台服务器的安全管理，需要有专用的安全管控系统，目前我们采用了安全平台部的铁将军架平自身研发的权限层级授权体系来综合管控服务器的权限。
铁将军主要提供了登录鉴权、解析器劫持等功能。架平的权限授权体系主要包括了对虚拟业务平台、业务平台内的权限组、部门内部人员与权限组的对应关系、虚拟业务平台与业务模块以及机器之间的关联关系的管理，同时可对具体的权限组授权可执行命令白名单，然后把这些基础信息推送到铁将军。
 在用户实际登录到某台机器的时候，铁将军便按照这个规则来判断该用户是否有登录这台机器的权限，以及当用户成功登录进去之后输入命令开始执行时，铁将军也会判断用户所提交的命令是否包含在白名单内，不在白名单内的命令是无法被执行的。
通过这种权限管控体系，可以把不同业务的负责人相互隔离开，不同业务的负责人是无法相互登录到对方所负责的服务器，降低登录的随意性，以及虽然负责人能够登录到所负责的服务器，但也没有传统意义上的权限，而是只能执行白名单内的命令，进一步降低随意操作的风险。这种方式拥有了一定的灵活性，同时也保证了一定的安全性。

图自助化运营体系
上面主要描述了登录生产机的管控，但很多时候登录生产机本身就是一个低效率的行为，但用户仍然有对生产机操作的诉求，譬如异常的分析与处理，能不能不登录生产机就可以对生产机进行既安全又高效的操作呢？针对此需求，我们构建了全新的自助化运营体系。
如上图，该体系主要包括固化后常见生产机的操作场景定义为工具、快速搭建业务专用的操作场景定义为流程、操作的安全分级等部分组成。每个对生产机操作的功能都可以同时批量应用到指定的多台机器上，相较于直接一台台登录生产机，操作效率提升明显。
 安全分级主要描述了每个操作的安全风险，高风险的操作每次执行时都需要相关人审批，低风险的操作每天会有操作机器数量的限制，操作数量内无需审批即可执行，超出数量后则需要审批才能执行，保证了安全的同时，也拥有了一定的灵活性。
常见生产机的操作场景是指我们把用户经常操作的场景固化到系统里面，譬如增加项、减少项，这样用户就不需要一台台登录生产机，通过自助运营系统就可以安全高效的完成操作，在系统内部该能力也称之为“工具”。
快速搭建业务专用的操作场景是指我们可以把已经固化到自助运营系统里面的工具自由组合成一个“流程”，由多个工具来共同完成一个复杂的操作场景，譬如业务模块的一键上架、异常的自动分析处理等，我们在下面会详细介绍。
图业务模块的一键上架
所服务的业务形态多，各种业务必然会有少许差别，对应在运营的某些环节，也可能会有细微的差别，譬如业务模块的扩容。某些业务模块的扩容不仅仅只是部署程序模块，同时还要申请腾讯内部使用的类似的外网收敛负载均衡系统、腾讯内部使用的名字服务负载均衡系统、报备高危端口等，通过为该场景建设专用的流程，就可以实现该业务专用的安全高效的一键扩容的效果。

图异常的发现分析处理全流程
海量业务的运营过程中，硬件的故障、网络的异常、软件的等等各种各样的问题都很常见，所有异常如果都告警出来并由人来处理，那效率就会非常低。针对这种情况，我们建设了异常的发现监控分析分析系统处理自动处理系统全流程的体系。目前对于单机不可服务、硬盘故障或者某些常见的业务异常，已做到告警产生后，会自动触发分析流程，由具体的分析结果决策是自动调用处理流程，还是通知负责人来人工处理，在某些场景下已做到了完全不需要人工干预，提升异常分析处理的自动化运维效率。
 架平的海量存储对应了几十万级别的硬盘，行业内硬盘故障率约月千成之三，由此可知坏盘对于我们来说是再常见不过的情况，坏盘的处理流程涉及“发现停现网服务迁移数据通知现场换盘确认换好盘初始化加入服务”这些环节，如果每一块坏盘都需要人工介入处理，则效率极其低下。针对该场景，建设了坏盘自动化处理系统，除了实际换盘还需要人工处理之外，其他各环节已是全自动运转，大大提升了这种常见运维的处理效率。
关于体系建设这块儿已基本介绍完了，我们总结下介绍了架平的自助运营体系，生产机权限管理体系，以及几种常见运维场景下的安全化高效化的实践。通过自助运营体系把常见的现网操作集成进来，大大减少人工直接接触生产机、使用“黑字符”的频率，通过生产机权限管理体系，把不得不登录生产机的场景安全化管理起来。
四、移动化
移动化时代的今天，对现网的操作也同样有移动化的强烈需求。
当我们小伙伴在外面一起聚餐时出了一个故障需要处理，在以往我们要以最快的速度回到电脑前，当我们夜里睡觉的时候出了一个故障需要处理，在以往我们要以最快的速度打开电脑登录，当
而现在我们将自助运营的能力通过企业号的方式下放到移动端，让用户通过手机就可以与生产机交互，完成常见的现网操作，让我们即使不在电脑前出现故障时也可以很从容。

文章来源公众号：腾讯架构师作者：

 入门教程
 是个什么鬼？
 下文简称是提供的一种数据序列化协议，下面是我从网上找到的官方对的定义：

  是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化，很适合做数据存储或  数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 、、 三种语言的 。

道理我们都懂，然后并没有什么卵用，看完上面这段定义，对于是什么我还是一脸懵逼

开发者为何要跟 打交道
作为开发者，对我们最友好的数据序列化协议当然是大名鼎鼎的啦！我们本能的会想是什么鬼？还我！
这就要说到的历史了。
由出品，年的时候把这个项目开源了，官方支持，，，和五种语言，但是由于其设计得很简单，所以衍生出很多第三方的支持，基本上常用的，， ，，等多种语言都已有第三方的库。
由于协议相较于之前流行的更加的简洁高效后面会提到这是为什么，因此许多后台接口都是基于定制的数据序列化协议。而作为开发者，跟或编写的后台服务接口打交道那是家常便饭的事儿，因此我们很有必要掌握协议。
为什么说使用使用类似的二进制协议通信更好呢？

二进制协议对于电脑来说更容易解析，在解析速度上是这样的文本协议不可比拟的。
有和两种选择，在一些场景下，传输的效率会更高。
在后台开发中，后台与后台的通信一般就是基于二进制协议的。甚至某些 和服务器的通信也选择了二进制协议例如腾讯视频。但由于前端的存在，后台同学往往需要特地开发维护一套接口专供我们使用，如果也能使用二进制协议，可以节省许多后台开发的成本。

在大公司，最重要的就是优化效率、节省成本，因此二进制协议明显优于这样的文本协议。
下面举两个简单的例子，应该有助于我们理解。
在中实践 协议
选择支持的第三方模块



  




根据数和文档完善程度两方面综合考虑，我们决定选择。
一个栗子
我打算使用  和开发一个十分简单的例子程序。
该程序由两部分组成。第一部分被称为 ，第二部分叫做 。
 负责将一些结构化的数据写入一个磁盘文件， 则负责从该磁盘文件中读取结构化数据并打印到屏幕上。
准备用于演示的结构化数据是 ，它包含两个基本数据：

，为一个整数类型的数据
，这是一个字符串

书写文件
首先我们需要编写一个  文件，定义我们程序中需要处理的结构化数据，在  的术语中，结构化数据被称为 。 文件非常类似  或者  语言的数据定义。代码清单  显示了例子应用中的  文件内容。
清单   文件
  
  
{ 
          =     
         =     
          =     
}
一个比较好的习惯是认真对待  文件的文件名。比如将命名规则定于如下：

在上例中， 名字叫做 ，定义了一个消息 ，该消息有三个成员，类型为  的 ，另一个为类型为  的成员 。 是一个可选的成员，即消息中可以不包含该成员。、、这几个数字是这三个字段的唯一标识符，这些标识符是用来在消息的二进制格式中识别各个字段的，一旦开始使用就不能够再改变。
编译  文件
我们可以使用提供的命令行工具来编译  文件
用法 
     

我们来看看
               查看帮助
             查看版本号
               

                                
                               
指定来源文件格式，可以是或文件

               

                                   
                              
                                 
                                
                               
指定生成文件格式，可以是符合或者规范的文件，或者是单纯的文件。

                  
                        
                  压缩生成文件
                 
              
                        
                  
                    
                         
               
                      
           
                          
                         
重点关注 就好，由于我们是在环境中使用，因此选择生成符合规范的文件，命令如下：
       

得到编译后的符合规范的文件：
 = {}{
     
     
        {
             
             
                {
                     
                     
                     
                     
                }
                {
                     
                     
                     
                     
                }
                {
                     
                     
                     
                     
                }
            
        }
    
}

编写 
  = 
  = 

 除了这种传入一个对象的方式， 你也可以使用 函数用来修改和读取结构化数据中的数据成员
  =  {
     
     
}

  = 

   {
     {
        
    }
}

编写
  = 
  = 

  =    {
     {
          来看看里的对象长什么样子。
          = 
        
    }
}

运行结果
由于我们没有在中给可选字段字段赋值，因此读出来的字段值为。
这个例子本身并无意义，但只要您稍加修改就可以将它变成更加有用的程序。比如将磁盘替换为网络 ，那么就可以实现基于网络的数据交换任务。而存储和交换正是  最有效的应用领域。
再举一个栗子
俗话说得好：“世界上没有什么技术问题是不能用一个的栗子解释清楚的，如果不行，那就用两个！”
在这个栗子中，我们来实现基于网络的数据交换任务。
编写
文件：
 

  {

      {
           = 
    }

      {
           = 
           = 
    }
}
编写
一般情况下，使用  的人们都会先写好  文件，再用  编译器生成目标语言所需要的源代码文件。将这些生成的代码和应用程序一起编译。
可是在某些情况下，人们无法预先知道  文件，他们需要动态处理一些未知的  文件。比如一个通用的消息转发中间件，它不可能预知需要处理怎样的消息。这需要动态编译  文件，并使用其中的 。
我们这里决定利用文件可以动态编译的特性，在代码中直接读取文件，动态生成我们需要的模块。

  = 
  = 
  = 
  = 

  = 
     = 
     = 
     = 

  =  {
       
}


  = 

  = {
     
     
}   {
     {
        
    }

    
}

  = 

       {
     {
         
    }

            
}

    {
                   
    

    

     = 
}

 {
     


}

 {
    

     
    
}

书写

  = 
  = 
  = 
  = 
  = 

  = 
     = 
     = 
     = 

   {
      = 
              
}

    {
             
       
      =  {
         
         \  
    }

      = 
      = 
           {
         {
             
        }

                
    }

}

 

运行结果

其他高级特性
嵌套
  { 
     =  
     =                
     =  

    { 
     =  
     =  
     =  
  } 

    { 
       =  
       =   =  
  } 
     =  
 }
在   中，定义了嵌套消息 ，并用来定义  消息中的  域。这使得人们可以定义更加复杂的数据结构。
 
在一个  文件中，还可以用  关键字引入在其他  文件中定义的消息，这可以称做  ，或者  。
比如下例：
  

  { 
   _  =  
     =  
 }
其中 _定义在包内。
  的用处主要在于提供了方便的代码管理机制，类似  语言中的头文件。您可以将一些公用的  定义在一个  中，然后在别的  文件中引入该 ，进而使用其中的消息定义。
   可以很好地支持嵌套  和引入 ，从而让定义复杂的数据结构的工作变得非常轻松愉快。
总结一下
优点
简单说来  的主要优点就是：简洁，快。
为什么这么说呢？
简洁
因为  信息的表示非常紧凑，这意味着消息的体积减少，自然需要更少的资源。比如网络上传输的字节数更少，需要的  更少等，从而提高性能。
对于代码清单  中的消息，用  序列化后的字节序列为：
         
而如果用 ，则类似这样：
                
                 
       
一共  个字节，这些奇怪的数字需要稍微解释一下，其含义用  表示如下：
  
     
     
 
我相信与一样同为文本序列化协议的也不会好到哪里去。
快
首先我们来了解一下  的封解包过程。 需要从文件中读取出字符串，再转换为  文档对象结构模型。之后，再从  文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将  文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗  的复杂计算。
反观 ，它只需要简单地将一个二进制序列，按照指定的格式读取到编程语言对应的结构类型中就可以了。而消息的  过程也可以通过几个位移操作组成的表达式计算即可完成。速度非常快。
缺点
作为二进制的序列化协议，人眼不可读！
参考文档
   的使用和原理
 语法指南

原文链接：


相关推荐腾讯云从零部署站点中错误捕获的一些最佳实践