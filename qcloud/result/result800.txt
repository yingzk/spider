小程序框架文档
成品展示

一个是使用  命令生成的标准
一个是基于开发的手机充值的完整
一个是基于开发的开源的仿微信的聊天界面源代码下载
以上三个均在安卓机和机上运行过通。
快速入门
代码规范：
  变量与方法使用尽量使用驼峰式命名，避免使用开头。以开头的方法或者属性为框架内建方法或者属性，可以被使用，使用前请参考文档。
 入口，页面，组件的命名后缀为。外链的文件可以是其它后缀。请参考文件说明
 使用语法开发。
框架在下开发，因此也需要使用开发小程序，中有大量的语法糖可以让我们的代码更加简洁高效。
 使用
框架默认对小程序提供的全都进行了  处理，甚至可以直接使用等新特性进行开发。
项目创建与使用
安装
以下安装都通过安装
注：在腾讯开发网，因为需要使用代理才可以，没使用代理的同学建议使用腾讯内部工具代替安装，的安装与使用请参考  的文章。
 安装  命令行工具
   
 在开发目录生成开发
  
 开发实时编译
  
项目目录结构

_

 
     _
     _
 
     
     


开发使用说明
 使用微信开发者工具新建项目，本地开发选择目录。
 微信开发者工具 — 项目 — 关闭转。
 本地项目根目录运行  ，开启实时编译。
主要解决问题：
 开发模式转换
在原有的小程序的开发模式下进行再次封装，更贴近于现有框架开发模式。框架在开发过程中参考了一些现在框架的一些特性，并且融入其中，以下是使用前后的代码对比图。
官方代码：

获取应用实例
  = 
{
   {
    
   {}
  }
  事件处理函数
    {
   
  }
     {
  
  }
}
基于的实现：
   

      {

   = {
    
   {}
  }
   = {
    {
   
  }
  }
   {
  
  }
}
 支持组件化开发
参见章节：组件
示例代码：
 

  
   = =
   = =
   = =
   = =
  


   
   
   
   

      {

   = {
   
  }
   = {
   
   
   
   
  }
}

 支持加载外部包。
在编译过程当中，会递归遍历代码中的然后将对应依赖文件从_当中拷贝出来，并且修改为相对路径，从而实现对外部包的支持。如下图：

 单文件模式，使得目录结构更加清晰。
官方目录结构要求必须有三个文件，，，页面有个文件 ，，，。而且文件必须同名。
所以使用开发前后开发目录对比如下：
官方：

    
        
        
        
        
        
    
        
        
        
        
    
    
    
使用框架后目录结构：

    
    
        
        
    
默认使用编译，支持的一些新特性。
用户可以通过修改配置文件，配置自己熟悉的环境进行开发。默认开启使用了一些新的特性如，等等。
示例代码：
   

      {

   {
          = {
           = {
              { }
          } 
      }
  }
    {
        =  
      
  }
}
 针对原生进行优化
对现在进行处理，同时修复一些现有的缺陷，比如：并发问题等。
原有代码：
 =   {
    = 
  {
         {
          {
                 {
                  { }
              }
      }
  }
  }

}
基于实现代码：
  {
   
   =  
}
在同时并发个请求测试时：
不使用


使用后：

进阶说明
 配置文件说明
执行  后，会生成类似配置文件。
  = _ === 

 = {
   
   {
     
      
      
    
     
      
      
      
    
  }
}


  {
   压缩
   = { }

   压缩
   = { }

   压缩
   = {
       {
           \
           {
               {
                 
              }
          }
      }
       {
           \
           {
          }
      }
  }
}
：缺省值为’’，默认情况下不会对此文件类型高亮，此时可以修改所有文件为后缀因为与高亮规则一样，然后将此选项修改为，就能解决部分代码高亮问题。
：编译配置，参见这里
：编译配置，参见这里
：编译配置，参见这里
： 为版本之后功能，目前支持压缩与图片压缩，持续开发……
文件说明
文件的编译过程过下：

一个文件分为三个部分：
样式对应原有
模板对应原有
代码对应原有
其中入口文件不需要，所以编译时会被忽略。这三个标签都支持和属性，决定了其代码编译过程，决定是否外联代码，存在属性且有效时，忽略内联代码，示例如下：
 = =
 = =

    

标签对应  值如下表所示：
|标签|默认值|支持值|
|—|—|—|
|||，，待完成|
|||，，待完成|
|||，待完成|
说明
程序入口
 =
  


   
     {
   = {
      
      
  
  {
       
       
       
       
  }
  }
   {
      
  }
}

入口继承自，包含一个属性和其全局属性、方法、事件。其中属性对应原有的，编译时会根据生成文件，如果需要修改中的内容，请使用系统提供。
页面
 =
  

 =
  
  
   = =


   
   
      {

   = {}
   = { }

   = {}
   = {}

   = {}
   {}
    
}

页面入口继承自，主要属性说明如下：

组件
 =
  

 =
   


   
      {

   = {}

   = {}
   = {}

   = {}
    
}

页面入口继承自，属性与页面属性一样，除了不需要以及页面特有的一些小程序事件等等。
组件
在小程序中，可以利用 模块化 和模板 ，对业务模块进行划分，实现如下效果：

但实际上不同的模块代码与事件交互都是在同一个页面空间处理的，比如说  和  中同时存在一个  响应事件时，就需要在  和  中分别定义为 _，_。业务模块复杂之后就不利于开发和维护。
在中，利用组件化的特性可以解决此类问题，如下图：

 和 中间的数据与事件相互隔离，可以分别拥有自己的事件。
组件引用
当页面或者组件需要引入子组件时，需要在页面或者中的给组件分配唯一，并且在中添加标签，如
页面引入，，三个组件，同时组件和又有自己的子组件，，，，。
组件通信与交互
基类提供三个方法，，，因此任一页面或任一组件都可以调用上述三种方法实现通信与交互，如：
    
组件的事件监听需要写在属性下，如：
   
      {

   = {}

   = {}
   = {}

   = {
         {
          `{}  {}  {}`
      }
  }
    
}
  事件是由父组件发起，所有子组件都会收到此广播事件，除非事件被手动取消。事件广播的顺序为广度优先搜索顺序，如果_发起一个事件，那么接收到事件的先后顺序为：       。如下图：

 
与正好相反，事件发起组件的父组件会依次接收到事件，如上图，如果发起一个事件，那么接收到事件的先后顺序为： _。如下图：

 
是一个组件对另一个组件的直接调用，通过传入的组件路径找到相应组件，然后再调用其方法。
如果想在_中调用组件的某个方法：
  
如果想在组件中调用组件的某个方法：
  
混合
混合可以将组之间的可复用部分抽离，从而在组件中使用混合时，可以将混合的数据，事件以及方法注入到组件之中。混合分分为两种：

默认式混合

兼容式混合


默认式混合
对于组件数据，组件，事件以及其它自定义方法采用默认式混合，即如果组件未声明该数据，组件，事件，自定义方法等，那么将混合对象中的选项将注入组件这中。对于组件已声明的选项将不受影响。
 
   

      {
     = {
            
            
    }
     {
          {
             
        }
    }
}

 
   
   

      {
     = {
            
    }
     =  
     {
             
             
    }
}
兼容式混合
对于组件响应事件，以及小程序页面事件将采用兼容式混合，即先响应组件本身响应事件，然后再响应混合对象中响应事件。
 
   

      {
     = {
          {
             
        }
    }
     {
         
    }
}

 
   
   

      {

     = 
     = {
          {
             
        }
    }
     {
         
    }
}


  
  
   
  
  
数据绑定
小程序数据绑定方式
小程序通过提供的方法去绑定数据，如：
{   }
因为小程序架构本身原因，页面渲染层和逻辑层分开的，操作实际就是逻辑层与页面渲染层之间的通信，那么如果在同一次运行周期内多次执行操作时，那么通信的次数是一次还是多次呢？经过跟小程序团队确认后得知多次会执行多次通信。
数据绑定方式
使用脏数据检查对进行封装，在函数运行周期结束时执行脏数据检查，一来可以不用关心页面多次是否会有性能上的问题，二来可以更加简洁去修改数据实现绑定，不用重复去写方法。代码如下：
 =   
但需注意，在函数运行周期之外的函数里去修改数据需要手动调用方法。如：
 = {
   =   
  
} 
脏数据检查流程
在执行脏数据检查是，会通过标识当前检查状态，并且会保证在并发的流程当中，只会有一个脏数据检查流程在运行，以下是执行脏数据检查的流程图：

其它优化细节
  接收参数修改
点这里查看官方文档
 官方
{
     
       {
        
    }
}

  使用方式
  接口从只接收变为可接收
 = 
 优化事件参数传递
点这里查看官方文档
 官方
 = = =   
{
    {
      
  }
}

  建议传参方式
 = = =   

 {
         {
              
    }
}
 改变数据绑定方式
保留方法，但不建议使用执行绑定，修复传入的，并且修改入参支持：

 




点这里查看官方文档
 官方
 {{  }} 

   {
    {  }
}


 
 {{  }} 

  {
     =  
}
 组件代替模板和模块
点这里查看官方文档
 官方
  
 =
  {{}}


  
 =
 = ={{ }}

  
  = 




 
  
 {{}}

  

     =


       
       
          {
         = {  }
    }












 

新增对第三方的支持

新增编译器

重新整理代码结构，使用维护不同的包

重新处理，同样交由第三方包处理

添加了编译时检测依赖的或者是否缺失的逻辑，如果缺失会自行安装

添加了工具版本检测的功能


 

新增了 命令升级版本

新增对第三方组件的支持

新增第三方组件

模板中添加组件测试


 

修复了使用外链报错的

修复了编译会调用到的

优化了事件传参数，支持直接传参

加入了以及

修复其它细节问题


 

的属性同时支持和

添加支持


 

修复了组件大写导致无法识别的问题

添加了对小程序页面所有响应事件的支持

修改支持

添加，在编译时对生成的所有文件进行压缩

添加不推荐使用，处理大图片时还有问题

添加  参数，编译时会重新编译所有依赖文件

  时，由在当前目录下生成项目改为创建目录，然后再生成项目

更新生成支持最新功能


 

添加了小程序其它页面事件的支持

修改默认配置文件为，方便以后功能扩展。兼容老配置文件


 

修复编译异常导致结束的

修复子组件修改时不会触发父组件更新的

修复的

修复页面事件中传参的


 

添加了对的编译支持

中加入对的配置支持

中添加选项

更新生成模板


最后，感谢  以及组内小伙伴们在开发过程中提供的帮助。作者简介：李科慧，腾讯高级工程师，天天  图  开发。热爱生活，除了码代码以外，还喜欢旅游、阅读、游泳、绘画、手工、拼图，。

导语
个人兴趣爱好特别广泛，喜欢捣鼓各种小东西自娱自乐。虽然都没能深入研究，但是自己的“孩子”还是很想拿出来遛遛得人一句夸奖的。所以刚学  的时候很是有想过要搭个个人博客来玩玩，一来激励自己练习 ，二来也是展示一下自己的“劳动成果”。可惜第一次尝试    的搭配没能一次成功，忙起来了也就把这事儿放一边了。最近因为微信普通公众号不支持页面内插入多个链接想做个集合贴链接到自己的不同作品，就又想着还是自己搭个网站吧。改变策略使用    倒是很快成功了，记录一下过程，如果能对其他想要搭建个人博客网站的小伙伴有帮助那就更好了。
 准备
 的官方文档挑重要的部分扫了一下，主要还是参考网上的一些帖子依样画的葫芦，遇到问题再去  和度娘上找答案。问题也都不难解决，主要还是配置的问题，分享出来只是希望后来者可以少走点弯路。
首先说一下， 是一款基于  的静态博客框架，支持 ，符合大家需求的话就请听我慢慢道来。
我使用的是办公用的  来搭建的，本地的操作基本是用  来完成的。其它操作系统应该类似，不过因为没验证尝试过也就不在这里谈到了。
我一共搭了两个博客，使用了不同的主题，一个比较简洁的，适合程序员发布技术贴；另一个是漂亮的   风瀑布流，可以用来发布一些生活化的动态。因为  有较为严重的整理癖，所以挑选的两个模板都有分类和  功能；同时也很想与同好们多多交流，并听听大家的反馈，所以找的都是有评论功能的主题不过后一个的  第三方评论插件国内被墙啦。如果想要更简洁的、功能更强大的或者其他风格的模板，大家可以自行去  的主题列表里挑选。
 注册  账号
这一步对于工程师来说相信没啥难度，估计大家也都有账号了，需要注意的是：

要创建一个仓库和你的博客相关联。使用  的话，对这个  的名字是有要求的，必须是：__ 格式。也就是说，一个  账号只能对应一个博客其实  配置文件里有一项是填写  的，如果网站有子目录的话，可以填写子目录，所以猜测还是有希望在一个仓库里建立不同子目录来部署几个博客的，但是尝试了两次都没有成功后，我决定先采用不同的  账号来配合不同的博客了。

最好生成并配置  。也可以不配制，但不配置的话每次对自己的博客有改动要提交时，必须手动输入账号密码，配置了则不需要。我之前申请第一个账号时就已经配置好了，今天因为要使用一台电脑向两个  账号发布内容，管理多个  秘钥比起新建一个需要更多费一点周折，就一并放在后文讲解了。


 安装 ， 和 

安装命令行的 ，太久以前做的，具体已经忘了，应该就是去官网下载最新版并安装吧。它是用来把本地的  内容提交到  上，以及快速下载各主题的。

去  官网下载最新版并安装；用于下载  等工具和插件。

下载安装 ：


    
 搭建博客
 本地初始化博客
建立一个博客文件夹，文件夹的名称可以随意。建议不要选择需要管理员权限才能创建的目录。进入目录并初始化：
  __
  
使用  根据博客既定的  配置安装所有的依赖包：
  
初始化博客以后，我们可以看到博客文件夹里多出了很多文件和目录。
 根据需要配置博客
我们通过修改 _ 文件来配置我们的博客。下面是我修改的几项参数信息注意每一项的“”后面都要保留一个空格：
 填写网站相关信息
   
    
   
  
 
 
 配置个人域名
 
                
 
 
我的理解是，没有花钱购买了域名的话，可以不用填这两项。不过如果使用了评论系统，这两项必须正确填写。也许可以研究一下使用  的话是否就能用  的一个  搭建多个博客。我有尝试过配置  为 “”，但是把网站  以后，键入地址打开，会报找不到各资源，等的错，因为会去  下去寻找资源，而使用   我们的网站 的时候还是部署到仓库的根目录下的。不知道如果把网站部署到  仓库的  目录下是否就可以了，目前还没有找到使用  部署网站到  子目录的方法。
 关联  的部署信息 

 
 可以在   首页的 `  ` 按钮下找到下面的链接
 ____
 
 部署博客
我们先进行本地发布，确认一下前面的操作是否都成功了：
  
此时终端会输出：
   
          
打开浏览器，输入 ，应该就可以看到我们搭建好的博客和发布的文章了。
下载  部署器，并将博客部署到网上：
注意，不执行下面第一行的话，可能会报 “    ” 或者 “    ” 的错
    
  
这时在  的仓库里已经可以看见我们的网站目录和文件了。此时在浏览器地址栏键入我们的网址，即：__ 就可以打开我们博客的主页了。
注意第一次打开估计需要做一些初始化的工作，会比较慢。
 维护博客的一些常用操作
 发布一篇博文
 在终端输入下列命令新建一篇文章：
   _
就可以在本地博客文件夹的 _ 目录下看到我们新建的  文件。
 用  编辑器打开文件进行编辑，输入文章内容，保存后准备发布；
使用  生成静态网页，并发布到网上：每次我们更新了博客后，都需要让  重新生成一下静态网页，可以在  目录的相应日期下看到生成的文件。 可以缩写为 ，其它缩写见  官方文档。
  
  
 删除一篇博文
 去本地博客文件夹的 _ 目录下删除需要删除的  文件。
 去本地博客文件夹的  目录下删除该博文对应的文件夹会按发布时间归到不同目录下。
 在终端重新生成静态网页并发布：
  
  

当我们更新博客时发生了任何问题，可以在终端输入下述命令清理并重新生成静态网页：

  
  
 博文首页展示长度控制
 博文在首页展示时，“ ” 或 “阅读更多” 按钮出现的位置是由作者在写文章的时候设定的。只需在文章正文里合适的位置加上     此标记之前的正文内容就会成为该文章的简述，显示在首页里。
  中的  配置
 是文件最上方分隔出来的一块  或  格式的区域。采用  格式书写时， 以三个短横杠“”同正文进行分隔，使用  格式时则是三个分号“”。
 用于指定文章的一些属性，有：布局，标题，文件建立日期，文件更新日期，文章评论功能开关，标签不适用于分页，分类不适用于分页， 覆盖文章网址等。
下面介绍一下其中比较常用的几个：
   
在   的时候会自动生成，当然也可以之后再编辑。
   

只有  类型的文件是支持  和  的。它们可以类似  数组的形式来表示，也可以分多行以短横杠开头来表示：


 
    
 
  
 
 

如上填写完这两个属性，在   的时候就会自动生成相应的标签和分类。如果所使用的  主题的侧边栏有这两个模块，或者主题有相应的页面，就可以看到相应的生成结果被展示出来下图是  主题自动生成的侧边栏  和  效果。


 和  的最大区别是：当有多个并存时， 是顺序作用到  上、且有层级关系；而  的各个元素是同一层级的，所以顺序并不重要。从上图貌似没有看出分类的层级效果，但是观察一下打开的  就能发现不同了，同样是打开 “”， 的  如下：




 的则是：




如果您的分类有中文的话，譬如： 美容 护肤 面膜，那么您会发现， 里面也有中文：


美容护肤面膜

复制黏贴出来的话，会更不友好：



想要让  中尽量少出现中文，可以在博客的根目录配置文件 _ 中利用 _ 属性作映射。
_
 美容 
 护肤  
 面膜 
如上配置后，得到的  就会变为：



 也有相应的 _。
 
 默认不开启文章目录，若想要某篇文章根据标题权重自动生成目录显示在最右边，可以在  中开启

 
 


从上图中可以看到，生成目录时会自动添加序号。所以如果使用自动生成的话，就无需再在文章中的标题添加序号了。
 可选选择自己喜欢的主题
会写博客的小伙伴们估计还是比较重视细节和美观的，对博客的样式自然也有追求，简单说一下怎么替换主题，不同的主题替换起来略有不同，大家可以参考作者的指导。
 有两份主要的配置文件文件名都是 _，一份位于站点根目录下的站点配置文件，另一份位于主题目录  下的主题配置文件。
要安装一个新的  主题一般分为两步： 将主题文件放置于站点的  目录下； 修改配置文件。下面举一下我的两个例子：
  主题在  上的移植版
先上刚撘完时的效果图：

主要是看着作者的引导修改的，具体步骤如下：
 从  上将主题下载下来，放到  目录下：
    
 安装主题和渲染器：
    
    
 编辑博客目录下的 _ 文件，将  的值改为 。
 接着就是执行 ，， 三部曲了。
 还有很多可配置项，这里列举几项我尝试了的，其他的请参考作者的原文
 按照默认配置，会有：“首页”、“归档”、“关于”、“订阅”四个 ，其中“首页”和“归档”是自动生成的，“关于”和“订阅”要生成一下，不然会找不到网页。

生成“关于”页面：

最简单的方法是：
    
可以看见  目录下生成了  目录，此目录下的  文件就是“关于”页面了，大家可以根据自己的需要进行编辑。
想要添加其它页面，重复上述步骤即可。另一种生成页面的方法是：在  目录下建立同所要生成的页面名字一样的文件夹，在其中创建  文件，并在  的  中设置  为  。若需要单栏页面，就将  设置为  。

生成“订阅”页面：

首先要说明一下，由于生成  也就是订阅的插件同   的兼容性的问题，我这边无法正常生成“订阅”页面，会报如下错误：
    `    `     
所以作为已经使用了   的用户，我就只能把  从主页中移除啦去主题的配置文件 _ 中，将  下的  配置注释掉：

    
     
     
    
     
     
    
     
     
     
      
      
其它功能模块也可用此种方式删除。
但是如果您装的是更早版本的 ，是可以根据以下步骤自动生成  的：安装两个插件：
    
    
在项目的 _ 配置文件中添加这两个插件：
 如果是   及以上版本，无法使用  功能，必须将这两句注释掉，不然  的时候会报错

 
 
另外需要注意，项目的配置文件中的  必须正确填写自己网站地址，不然  订阅不会成功。
 评论功能
对于我来说，评论功能还是很有用的，促进同好之间互相交流共同进步，这也是我写博客的最终目的吧  主题是支持两大最常用的第三方评论的， 和 多说。一般  国内加载会比较慢，但是会更稳定一点。因为我使用的网络环境连不上 ，所以也没什么好纠结的了，直接使用多说了。

首先去多说网站注册一下，一个账号对应于一个博客。

在主题的配置文件 _ 中填上您刚刚注册得到的多说 


 _

之后就可以在文章和页面的  中设置   或   来开启或关闭评论功能啦默认开启。


  主题自动截取文章第一段作为摘要显示在首页，而不会显示全文。我们也能自定义摘要：

使用文章的  中的  项来填写想要显示的摘要；

或者直接在正文内容中插入 ，其前面的内容就会被认为是摘要。


 支持数学公式：
此主题已经集成了  用于渲染  数学公式，按如下步骤可以打开：

要启用公式高亮，先在博客目录的 _ 中添加：

 

并在相应文章的  中添加  项来开启：


 
 

对于行内公式，使用  或 \\\\ 来标记；对于块级公式，默认定界符是  和 \\\\。

如果文章内容中出现美元符号“”，而非行内公式的定界符，那么请在博客目录的 _ 中添加：

 
相应地，在需要使用数学公式的文章的  中也要使用  。
  瀑布流效果的  主题
可以先看一下作者博客的效果，而我刚撘完时的效果如下：

也是照着作者的引导来修改的，具体过程如下：
 从  上下载主题到  目录下：
    
 下载依赖：
        
 编辑博客目录下的 _ 文件，将  的值改为 。
    将  和  图片放到  目录下，并在 _ 文件中如下指定：
 
 _
 _
 _

   _
   _
 _
         
    
 
 
对于这个主题，此步骤不可省略，不然打开网站时会抛错。

 即  ，是地址栏网页标签最左侧的图标。有在线工具可以上传自己的图片去生成指定规格的  文件。

    在 _ 目录下建立并配置下述几个文件：



 在  目录下按引导配置 _ 文件。
 仍然是执行 ，， 三部曲了。
 其他可配置项：
 按照默认配置会有：“首页”、“归档”、“关于”三个 ，其中“首页”和“归档”是自动生成的，“关于”自行生成一下，具体事宜参见前文  主题的操作。
 评论功能
此   主题是支持  评论系统的，因为国内被墙，所以我也就没有配置了。
 此主题首页默认会显示文章全文，这会大大降低网站的加载速度，所以大家要记得配置每篇博文的摘要

直接在正文内容中插入 ，其前面的内容就会被认为是摘要。

  主题不支持在  中的  项来标记摘要哦


 支持数学公式：
此主题本身不支持数学公式，单纯靠自己人肉修改主题来支持数学公式还是比较麻烦的，幸而网上已有牛人开发了基于  来渲染  数学公式的插件了，我们只要按文档安装配置就可以啦：

安装插件：

    

初始化虽然官网中有写此步骤，但实际操作时发现  没有这个命令，且此步骤不必须。

在博客文件夹中执行：
   

在主题目录的 _ 中添加：虽然官网中有写此步骤，但实际操作时发现无步骤亦可。```
```

然后就可以在你的文章中应用数学公式啦比起   主题自带的 ，此插件的优点是： 无需在文章的  中添加  项来开启； 即使是首页摘要里的公式，也能正确显示；

不过使用过程中可能会因为  与  的特殊字符冲突而产生一些小问题。


 会先用  渲染  文件，然后再交给  渲染数学公式。譬如  中的换行符“\\”会先被  转义成一个“\”，导致  渲染时不认为它是换行了。针对个别字符二次转义的问题，我采取修改  文件的方式来解决：
 用编辑器打开博客目录下的 _ 文件；
 将下述代码：
  \\\\`{}\\ \_
替换成
 \\`\\ \_
即取消了对“\\”，“\{”，“\}”等  特殊字符的转义。再配合  码的  来使用，！
 注意这些修改要  再  才会生效哦
 一台电脑上配置多个 
因为博主之前已经在电脑上配置过  了，所以使用  向  部署时是不会要求输入账户密码的，这样就导致向第二个账号提交的时候自动使用了第一个账号的  从而失败。这里就说一下如何在一台电脑上，配置多个  账号的 ，从而向多个  博客发布博文。第一次新建  的情况也可以参照此方式来配置。
 生成新的 
 下  是放在  目录下的。如果之前已经配置过 ，那么该目录下应该已存在一个  秘钥了，假设文件名为：_。在终端输入如下命令，用新账号生成新的秘钥，并根据提示输入用于保存的名字，如：“__”。
  
     
         __
    
       
 __
操作完成后，就可以看见目录下已经多了两个文件，__ 和 __。
 将新的  秘钥添加到  代理中，以使你的电脑可以识别它：
  __
如果发生错误：“        ”，尝试下述命令：
  
  __
 配置管理你的多个  秘钥
 编辑  目录下的  文件，没有的话则新建一个。
  
  
 将下面的内容粘贴到  文件中：
   
 
 
 
 _

                 
                          
     
 
 
 __
 关联  账号
要将新生成的 __ 的内容添加到你的第二个  账号中，从而可以使用它向  提交内容。
 将  秘钥复制到剪贴板：
   __
如果  命令不起作用，可以直接去隐藏的  目录下用文字编辑器打开并复制其内容，小心不要加入多余的换行符或空格。
 进入  网页的个人设置里，从侧边栏中进入    ，再点击    或   。
 在  输入框中输入合适的名字来描述你的新秘钥，如：   __。
 将复制到剪贴板的秘钥粘贴至  输入框中。
 点击    并确认。
 修改  配置
打开你的第二个  博客的 _ 文件，并编辑如下：
 

 
 注意此处写法同之前的   的写法不同
 ______
 
如果你还有其他  账号，则可以重复上述步骤来继续添加。
总结
我搭建过程中遇到的各种情况基本都在前文讲述了，剩下的大家就自由发挥吧
参考资料
 代码咖啡  分钟教你使用  搭建  博客，          ，  潘柏信   ，搭建属于自己的博客， 小道博客  博客更换主题， 屠夫 大道至简——  简洁主题推荐，                  ， 

相关推荐
利用搭建数据科学博客【腾讯云的种玩法】如何腾讯云存储上搭建一个博客作者：李光 ，现任职于腾讯社交网络运营部织云产品团队，负责织云监控告警平台规划与运维新产品开发工作，具有多年业务运维、运营规划经验。
 相关推荐：  腾讯业务监控的修炼之路「二」

欢迎大家在文末扫描作者二维码，反馈日常使用监控告警产品的痛点与具体的场景。这系列文章我会尝试用开放式类众包的方式去写，后续会统一评估这些反馈的场景，如果是典型共性场景，或是很小众但却能代表一个特定类型的业务，将会采纳您提供的场景，在后续的文章中会标明提供者的名字，并且附上我的建议场景解决方案，供大家交流与讨论。
概述
本文作为监控告警产品专题系列第一篇文章，涉及的主要内容为监控产品设计的相关基础知识，算是整个系列文章的一个索引。主要内容有：
• 关于监控告警的一些概念• 立体化监控体系的阐述
老鸟们可以关注后续的文章文末有三期内容预告，关键词：  组件监控
业务运维  产品经理
以前做  业务运维的时候，有一类平台是自己天天会用，那这类平台是什么呢？就是监控告警平台，每天在上面查大量的业务视图、查异常、确认告警、处理告警等等。
对于运维同学来说，如果从使用频率这个维度看，监控告警类平台的使用频率要大于自动化类平台，毕竟自动化类平台多数都是由例行变更触发，而监控告警平台是我们  小时都要使用的。当时自己名下有较多的业务和几千台机器，那时有过一天收  多条告警的记录，相当崩溃。其实告警如果一天超过几十条就基本是无效的，既关注不过来，也处理不过来。
在业务运维这个角色中，我更多的是从使用者这个视角去看监控。
去年下半年我从业务运维转型为产品经理，现在负责腾讯织云企业级运维管理平台监控告警产品线的规划与落地，在产品经理这个阶段我更多的是从建设者这个视角去看监控的。
使用者和建设者这两个视角去看待同一个事物监控告警这个产品，最大的差异点是什么呢？
• 使用者是点，建设者是面，使用者只关注能服务到自己的功能点，而建设者尽量要更全面的抽象多数使用者所具化的场景，在抽象的基础上在去构建功能，力争满足大部分的使用者场景，解决实际的问题。


“出了任何故障，其他环节都是可能有问题，唯独监控是一定有问题！”
                                             —— 乔治·背黑锅

基于这两种不同的视角与在实际建设途中遇到的各种实际问题，我萌发了写一个监控专题系列的想法，哈哈，脸皮蛮厚的。自己以前都是写单篇的文章，这次也算是一个挑战了。希望通过这个专题能与大家交流下关于一款企业级监控产品是怎么样规划、设计与落地的。
可能是当产品经理习惯了用户场景与角色的分析，如果把这个主题的文章当做一个产品来看，那么其中的角色与场景是什么呢？
• 梳理一下自己在建设织云监控告警产品线的一些经验和思考。• 对于刚入行对监控告警这个产品还不太熟悉的新业务运维同学。• 想自己建设监控告警的运维同学或者运营建设同学。• 正在建设监控告警平台的运维同学或者产品经理。• 对监控告警产品天天使用的业务运维同学。
因为我现在是织云监控告警产品线的产品经理，而且这部分的产品也在分版本的持续建设中。所以后续主要的产品规划、设计、实现的讲述都是基于织云这个载体上实现。
万丈高楼平地起
本章主要介绍一些关于监控的通用方法论，我们先理清一些基本概念。
• 监控的定义？• 监控的方式？• 监控的类型？• 监控的目标？• 监控的本质？• 监控的目的？• 监控的产品属性？
监控的定义
通过技术手段发现服务异常，持续优化业务可用性与用户体验。这句话的关键词是 发现、持续优化、可用性，体验。
监控的方式
主动：程序内部埋点，服务主动上报自身的运行情况，一般都是具化为业务的各个属性或者指标，这种方式准、快、灵活性好，指标丰富。但是在非标准框架下会有一定的代码改造成本。被动：无需埋点，从外部探测或获取服务的运行情况，例如探测、日志采集分析等等。旁路：与程序逻辑无关，对服务质量与口碑的监控，例如舆情分析。
那么这三类有优劣之分吗？其实没有，这里的方式都是针对于不同场景的，例如对域名的监控，就可以通过该域名的外部拨测来达到监控的目标，域名的访问耗时也可以通过不同的拨测点来监控。在腾讯内部，和两个海量业务对这三类监控都应用到了。
监控的类型
从大的对象范畴与层级关系来说，监控一般分为五种类型：基础监控：这里的基础监控囊括范围比较广，主要指层服务器、系统、网络等服务端监控：一般指后台服务，例如的后台消息服务。客户端监控：一般指，手的客户端与微信的客户端。监控：一般指网站，例如对网站域名的拨测。用户端监控：一般指用户舆情监控，例如某个的口碑好坏。
监控的目标
一个好的监控体系应该要达到以下三点目标：全：监控对象的广度，监控点的覆盖率，例如上文提到的五种对象类型是否都能覆盖到快：监控的性能，数据流的处理能力准：智能分析与收敛、监控对象收拢
监控的本质
在  中，运维、开发、测试这三个角色应该视角统一，这里为什么说要视角统一，就是大家在监控这个层面关注的点应该是一致的，而不是你关注你的点，我关注我的点。
例如所有的业务监控都可以抽象出三个核心指标：请求量、成功率、耗时。这三个关键指标来判断我们服务的可靠性，通过可靠性可以推算出可用性，并且可以间接反映用户使用我们产品的的体验。例如，如果服务的可靠性不好，那么用户的产品体验肯定不会好。
监控的目的
通过对上文的一些概念介绍，其实我们已经可以推导出应用监控告警的目的，就是持续优化业务服务质量，并建设质量体系。同样织云监控也是为了打造质量体系的闭环路径。
监控告警的产品属性
监控告警是一款数据类属性的产品，既然是数据类产品，那么在产品设计的时候一定要注意这样的路径闭环 数据生产数据增值数据消费，围绕着这样的路径我们就可以勾勒出很多的用户故事，用户故事就是针对具体的角色，会有什么具体的活动，以及这个活动所产生的价值。这里举个简单的例子来说明数据生产与数据消费。随着后面详细的讲述产品建设过程中会更加详细的阐述这个闭环的路径。
数据生产：例如一台服务器上报的各种基本的  指标数据，如  使用率，内存使用量等。这就产生了若干待消费的原始数据，那么我们能用这些数据干什么呢？
数据消费：对这些上报的原始数据整理可以用作视图展示，例如图形化展示该服务在最近一个小时的  使用率。 又或者对这些原始数据设定阈值，当超过某个阈值的时候，就产生告警通知。这些都是最直接的消费的场景。
我们再延伸一步对于这些消费场景产生的告警数据，是否可以再进一步消费呢？答案是可以的，例如对若干承载  计算型业务的服务器所产生的  使用率告警生产时间进行分析统计消费，是不是可以基本推导出该业务的服务高峰期是大概在那个时间范围呢？
这里想说明的是多数原子数据并无单一的消费或者生产的属性，而是要取决于在具体的场景与所处的数据链条中的角色。
并且监控告警的数据加上特定的流程也可以驱动监控告警自动化的大的业务逻辑交互闭环，这个场景容我先卖个关子，后面的叙述会再次提及到这部分。
监控体系
体系，泛指一定范围内或同类的事物按照一定的秩序和内部联系组合而成的整体，是不同系统组成的系统。其实这个描述是有些抽象的，咱们用大白话套用监控体系来解读下。
对于一个有一定体量的公司，需要一些不同的监控系统，通过系统与系统间的内部交互来组成一个大的整体，从而完成对不同场景下的监控需求即监控体系。用我们内部来举例，我们内部在现网上跑的监控系统也有快套了，同样在构建体系时关键的部分也是要用动态的视角去看待这些系统所产生的数据，而不是每个系统都是一个孤立的数据孤岛。下图是织云整体的监控体系。

在织云监控告警产品建设过程中，我们融入了很多关于海量运维的监控思考与经验沉淀。

这里的监控体系是和公司体量大小有直接关系的，但是一般来说在这个体系中，应该有三类监控系统是必备的。

总结
通过上文的简单介绍，相信大家对监控告警会有个初步的宏观认识，随着后续文章的铺开，大家会逐步了解到一个企业级的监控产品是怎样从  到  演化而来的。同时下篇文章就会进入到实战阶段。 建设监控告警是一条持续且漫长的路也是蛮复杂的，坑也很多，但还是有一些基本的方法论和规律可以遵循。
监控告警产品专题内容预告【腾讯织云】： 将连载推送，欢迎关注：
• 层监控服务器性能、网络设备、网络流量分析等如何设计与实现？• 一个企业级监控告警产品需要设计怎样的 ？在云化时代  所扮演的角色越来越核心，我以前也设计过织云的 • 平台级的监控产品如何更好地支撑五花八门且业务形态差别很大的组件监控？
欢迎大家扫码反馈添加时请注明“姓名公司名称工作岗位”需求
 从  后开始支持异构存储，异构存储是为了解决爆炸式的存储容量增长以及计算能力增长所带来的数据存储需求，一份数据热数据在经历计算产生出新的数据，那么原始数据有可能变为冷数据，随着数据不断增长差异化存储变的非常迫切，需要经常被计算或者读取的热数据为了保证性能需要存储在高速存储设备上，当一些数据变为冷数据后不经常会用到的数据会变为归档数据，可以使用大容量性能要差一些的存储设备来存储来减少存储成本， 可以按照一定的规则来存储这些数据，具体架构如下：

存储类型存储策略
存储类型

_
内存镜像文件系统


 盘


普通磁盘


归档


存储策略



策略 
策略名称
块分布







_
_   





_
 





_
   
 
 



 
 
  





   
 
 




 
  
  



存储策略名称分别从 _ 到 ，分别代表了设备的访问速度从快到慢，访问速度最快的为内存文件系统，其次是 ，再是普通盘，最后是归档性存储，我们可以利用上面的策略来控制数据的分布以达到降低成本的目的。
  
对于第一个创建的  块的  情况时的可选存储类型
 
对于的  块的其余副本的  情况时的可选存储类型，这里出现了  的情况什么叫做  的情况呢，当前存储类型不可用的时候退一级所选择使用的存储类型
测试环境验证
环境信息准备

数据拷贝数 

 节点信息






存储介质
初始空间
 设置介质类型























普通盘





普通盘





初始集群只有 、、 三个存储节点，默认的存储类型没有设置即为  类型实际盘是  和  节点为新扩节点实际磁盘为机械盘在  里设置的存储类型为 

初始文件信息

     | { }|      

在  默认策略下有一个  目录下面有  的文件

初始块分布

         

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  
可以确认  个块均匀的分布在  到  三个存储节点上

设置不同的目录不同的策略

 目录是默认策略不用修改
设置  目录策略为 
      
     
设置  目录策略为 
         
     
此时在集群还未加入存储类型为  类型的几点的时候如果向 目录写入数据会抛出异常

数据降冷  到 
查看  目录的存储策略
     

    

{ =  =  = }
移动数据到  目录
       

  

   \               
执行 
      

     = {=}

        

        

        

        

        

      __  =      

      __  =      

      __  =      

      __  =      

      __  =      

      __  =      

      __  =      

      __  =      

      __  =      

      __  =      

          =            

        
检查数据块分布
      

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =   

\ __ = =  

\ __ = =   

\ __ = =   

\ __ = =  

\ __ = =  
可以看出数据分布已经是一半的块在 ，一半的块在普通盘
数据降冷  到 
查看  目录存储策略
     

    

{ = = =}
移动数据到  目录
      

  

  

             

  

   \               
执行 
    
检查数据块分布
      

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  
可以看出数据已经完全分布在冷设备上
数据生热  到 
移动数据到  目录
    
执行 
 
检查数据块分布
        

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  

\ __ = =  
可以看出数据块分布已经是一半在 ，一半在普通盘。接《 知多少 上》
 单继承
接着我们来看一下类型间单继承的情况看看内存布局会有什么变化
 
{
     _
      {}
}

    
{
     _
      {}
}
一般而言如果基类或者继承类存在虚函数表指针的话会置于类型的内存布局首部继承类会复用基类的虚函数表指针然后放置基类的数据成员最后放置继承类的数据成员放置方法仍然遵循之前所讲的对齐和填充规则所以我们仍然可以套用公式来计算的大小
首先对齐各个成员
’  = 
’  = ’        =        = 
’  = ’   _  _  _ =        =  _来自于基类
’  = ’   _  _  _ =        = 
然后做一次整体填充
 =  _ _ =    = 
 = ’      =      = 
的内存布局如下

图： 内存布局 
 多继承
还支持多继承特性一个类型可以继承于多个基类假设基类分别为  … 其中每个基类都可能有成员数据及虚函数表继承类也必须能够无缝的向下转形为任一基类其内存布局的一般规则如下
 首先放置的虚函数指针会复用该虚函数表指针
 接着放置的数据成员并逐个执行内存对齐
 接着放置的虚函数指针如果有的话
 接着放置的数据成员并逐个执行内存对齐
 对接下来的基类重复和两个步骤直到 
 接着放置自身的数据成员并逐个执行内存对齐
 最后对整体做一次数据填充
其中如果没有虚函数表但是后面的有虚函数表我们就把提前放置其实就是把之前的基类列表  …    … 映射重排成了   …   … 如果基类都没有虚函数表但是自身有虚函数表的话的首部则会放置自身的虚函数表指针否则会复用第一个有虚函数表的基类的虚函数表指针
看一个例子可能更清晰些
 
{
     _
     _
      {}
}

 
{
     _
}

      
{
     _
      {}
}
我们按照之前的公式来计算一下的大小
首先对齐各个成员
’  = 
’  = ’        =        =  的虚函数表指针会复用该指针
’  = ’   _  _  _ =        = 
’  = ’   _  _  _ =        = 
’  = ’   _  _  _ =        = 
’  = ’   _  _  _ =        = 
然后做一次整体填充
 =  _ _ _ _ =      = 
 = ’      =      = 
的内存布局如下

图：内存布局 
 虚拟继承
虚拟继承偏于复杂一般也不推荐使用讨论虚拟继承相关的内存布局实际来看意义不大仅供有兴趣的朋友参考 
一般的教科书中都会提一下虚拟继承并说明一下虚拟继承的目的是为了解决菱形继承导致的重复基类问题如果我们想要计算虚拟继承类型的内存大小就必须首先了解一下编译器对于虚拟类型的内存布局方法这里首先要说明的一点是就和而言两者对于虚拟继承类型的内存布局方法是有很大不同的我们先说下的布局方法
一个类型如果定义了虚拟函数便会为该类型创建虚函数表同样的如果定义了虚拟继承便会为该类型创建虚基类表并在类型实例中添加虚基类表指针一般而言会被放置在之后如果类型没有则会被放置于实例首部另外的虚拟基类的成员也会被放置在继承类的尾部而不是像普通继承那样从继承类的头部开始细节可以参考上面小节
考虑下面的类型定义
 
{
     _
}

     
{
     _
      {}
}

     
{
     _
      {}
}

      
{
     _
      {}
}
我们还是使用之前的公式来计算一下的大小
首先对齐各个成员
’  = 
’  = ’        =        =  的虚函数表指针会复用该指针
’  = ’        =        =  的虚基类指针用以索引
’  = ’   _  _  _ =        = 
’  = ’        =        =  的虚函数表指针
’  = ’        =        =  的虚基类指针用以索引
’  = ’   _  _  _ =        = 
’  = ’   _  _  _ =        = 
’  = ’   _  _  _ =        =  被放置在了尾部
然后做一次整体填充
 =   _   _ _ _ =         = 
 = ’      =      = 
的内存布局如下

图： 内存布局 
而采用了不同的方法来实现虚拟继承机制之前提到会为虚拟继承类型生成虚基类表并在实例中插入虚基类表指针同样也会为虚拟继承类型生成虚基类表但是并不会在实例中插入虚基类表指针相反”合并”了虚函数表指针和虚基类表指针
或者说只使用了来实现虚函数的重载和虚基类的索引方法是通过正向索引来定位虚函数  通过负向索引来定位虚基类  所以在内存布局上会比生成的内存布局小一些这里我们同样来计算一下为上面的类型生成的内存布局大小
首先对齐各个成员
’  = 
’  = ’        =        =  的虚函数表指针会复用该指针
’  = ’   _  _  _ =        =  不包含
’  = ’        =        =  的虚函数表指针
’  = ’   _  _  _ =        =  不包含
’  = ’   _  _  _ =        = 
’  = ’   _  _  _ =        =  被放置在了尾部
然后做一次整体填充
 =  _  _ _ _ =       = 
 = ’      =      = 
的内存布局如下

图 内存布局 
 杂项
有个关于的有趣的点可以再提一下那就是空类型的内存大小
 
{
}
空类型的大小一般为之所以不为是为了支持空类型实例的取址所以我们可以把空类型看做是一种大小为对齐值也为的类型这样就可以使用之前的公式来计算一些包含空类型的复合结构的内存大小
 
{
     _
     _
     _
     _
}
我们来计算一下的内存大小
首先对齐各个成员
’  = 
’  = ’   _  _  _ =        = 
’  = ’   _  _  _ =        = 
’  = ’   _  _  _ =        = 
’  = ’   _  _  _ =        = 
然后做一次整体填充
 = _ _ _ _ =     = 
 = ’      =      = 
有个注意点就是如果类型是继承于空类型而不是包含空类型时编译器往往会把空类型的占位空间那一个字节给优化掉考虑以下定义
    
{
     _
}
按照之前公式的计算你会得出的内存大小为但是由于有之前所说的编译器优化即空基类优化所以实际上的大小一般为当然如果你把此时的空类型看做一种大小为对齐值为的结构的话仍然可以使用之前的公式计算得出正确答案
首先对齐各个成员
’  = 
’  = ’        =        =  注意此处类型的特殊处理
’  = ’   _  _  _ =        = 
然后做一次整体填充
 =  _ =   = 
 = ’      =      = 作者：张佳

  什么是分析
分析：本文指的是微观的分析。从单个有价值的入手，追踪和分析产生的本质原因，在此基础上对产品各个角色、以及项目流程做改善和优化。
可见，分析分为两部分。一是“分析”本身，二是以分析结果为前提，所做的一系列优化改善。
 为什么要做分析
原因一：借助，提升测试人员对产品质量的整体把控从项目初期的产品需求，到开发阶段的自测、迭代提测、集成上线提测，直至发布后用户反馈，可以说几乎贯穿了产品发展的各个阶段。对于测试人员来说，用好手中的，提升对产品的理解，能够更高效、更有效的测试，从而把控质量风险，提升产品质量。
原因二：追本溯源，重新审视项目过程，推动优化有人说，产品一切的根源都是代码。如果把产品的诞生当作一场马拉松，那就是那些年我们踩过的坑。从哪儿跌倒就从哪儿爬起来，通过分析找到产生的根因，思考如何从各个方面去优化改进，避免以后踩到类似的“坑”，下一场比赛才能跑的更快更远。
 怎么做分析

先上模型，以下我们逐步讲解怎么对应模型去做分析。
第一步：怎么选
的来源很多，有产品体验、开发自测、测试发现、众测反馈、灰度反馈、发布后反馈，等等。我们做分析首先面临的就是“如何挑选合适的”。这里给出几点建议：

选择对用户影响大的：比如闪退、或者导致某功能无法使用的
选择典型有代表性的：同类型的一系列问题，比如：适配导致和手机必现无法启动
选择有发现难度的：积累问题库，对测试用例做补充
选择有推广价值的：可借鉴到其他平台或其他产品，比如：白屏系列专题

总之，只要是符合目标通过分析，更高效、有效的保证产品质量的，都可以选来做分析。
第二步、收集哪些信息
假设你已经选定了待分析的，我们接下来要做的是，对收集尽量多的有效信息。比较常见的“信息”包括以下：

被测产品信息：比如名称、版本号
测试机型和环境：比如小米手机系统、网络、测试环境
严重级别：比如分为严重、一般、建议
模块：比如书签模块、字体模块
测试步骤：描述测试操作的步骤
预期结果实际结果：对比正常情况下的预知结果，给出的表现
附加信息：比如截图、视频录像、信息等需要指出的是，结合的实际表现，我们在提交时应该尽量多的提供有效信息，对问题本身做“隔离”。这样做的好处是，能够帮助开发过滤掉干扰因素，减少排查时间，更高效的定位到。来看个例子，通过隔离法做“初筛”，测试可以快速对做一轮初步定位。


第三步、如何做分析
我们前面说过，分析就是要追踪产生的本质原因。实际测试中，基于分析小组的经验总结，我们将分析的过程分为三大类型。结合自己的特点，在分析时可以选择合适的方法去套用。
、直接分析法
适用场景：可以直观的看到，或者通过隔离筛查，已经初步定位到模块。
举个例子：“华为版本内核下，图片显示异常”。
特定系统的问题，看起来原因比较明确，就是系统下的显示问题。我们通过查看官方版本更新文档、了解代码变更，通常可以很快找到原因。
以这个来说，存在同样问题并已经做了修复，我们在官网上查找相关资料，就可以了解到根因了。
、分析法
适用场景：比较没有头绪，本身以外的信息较少。
是一种分析方法，通过不断的追问“为什么”，来识别和说明因果关系，解释事件发生的本质原因。这里我们用在分析中，借鉴思想，深入追踪产生的根本原因，从源头上寻找原因。
 分析的特点是：从表象入手，一步步追问，由上一个问题的回答引发下一个问题，直至得到产生的本质原因。
举个例子：
来源： 实验室版本
标题：使用第三方字体，页面显示异常
测试步骤：

对手机更换热门的“花漾水果”字体；

进入浏览器，访问百度，网易等页面；


现象：页面文字不显示
分析步骤：
先找到问题的最外层表现，即明确的表现是什么；
对最外层表现提问，找出的直接原因；
用方法，针对直接原因，连续追问多次，直至找到的本质原因；
可见，通过连续不断地追问，我们总可以深挖到产生的最根本原因。当然，对新手来说，你可能没办法一次问到的本质，不过没关系，多问几次，培养对问题的敏感度，你总能从某条“线”上挖到你想到的结果。
、探案分析法
适用场景：基于现有的知识储备，有一定的追查思路，能划分可能的几大类原因。
探案分析法，从案情的发生过程，基于经验分析确定可能的嫌疑人，再用高科技工具逐个排查疑犯，最终由证据指认真正的“凶手”。
举个例子：
“小米进入看准网任意二级链接进度条加载完成后白屏”。首先，从的描述信息提炼有价值的点。
【初步评估】 
、正常可以排除网络异常导致
、小米手机独有问题
、网址导航配置的链接，较容易被发现
【怀疑对象】
、渲染模块，渲染异常，没有正确上屏
、网络模块，网络交互异常，没有拉取到资源
【提炼疑点】
疑点：只有小米手机有这个问题？跟机型和版本有关吗？线上是否有类似用户反馈？
疑点：看准网是做什么的？有什么特殊性？为什么一级链接正常，二级链接就白屏了？
【收集证据排除干扰】 针对疑点用其他机型做对比验证，验证结果：其他机型未复现。
 查找线上数据，确认线上是否有类似用户反馈。查找结果：有条反馈
获取到如下关键信息：
反馈版本是，反馈时间，早于上述发现时间。
用户机型是：，换手机也是如此。推翻上述单个机型问题的判断。
 看准网是中国最大的企业点评、雇主品牌展示和员工分享平台。其他招聘类站点未出现类似问题，初步看不出这个站点有什么特殊性。
 通过调试发现，访问看准网二级链接，网络请求直接返回，并没有拉取到网页资源，请求被服务器拒绝了。
【分析推理】
服务器为什么在有些场景下会拒绝网络请求呢？怀疑是代理直连的策略导致，部分机型走直连，部分机型走代理。另外即使是配置成代理，但是由于各种不可控因素会导致走直连。
从看当时出现白屏时，确实是走的代理。
当时未能进一步验证：没有出现问题的手机访问该站点走的直连。
猜测原因：代理情况下会出现，同一个高频访问，看准网屏蔽了我们的代理。
解决方案：在强制直连白名单里增加看准网，之后可以正常拉取到资源。如下是从后台拉取的强制代理白名单，确实有增加看准网。
【结案陈词】
白屏问题是由网络模块异常导致，代理策略的局限性会导致：代理方式访问有做无效访问屏蔽的站点可能会存在这类问题如：购票、投票等。
第四步、总结经验和改进优化

、左移
大家都知道，发现的越早，修复的成本越低。通过分析，做好预防，尽量早的发现问题，从而降低修复成本和产品风险。
、测试优化
通过分析的案例积累，提升测试对产品整体架构的理解，高效、有效的设计测试方案，更好的把控产品质量风险。
、项目各角色改进

产品侧：需求更合理、预知实现风险，前期从设计层面规避
开发侧：通过编码规范、加强自测和 ，提高代码质量 
测试侧：补充优化测试方案，了解产品架构逻辑，经验和技术提升，更精准的关注重点、提升产品风险评估能力

举个例子：
分析案例：“一个较大文件的白屏问题”
通过分析后得到的根因：在实现文件加载渐隐渐显效果时代码有逻辑缺陷，会导致文章内容在加载完成前被隐藏，页面白屏，文件打开失败。
 测试优化改进方案：

 补充了需要验证的支持的文件格式
 从之前的随意选取几个格式进行文件逻辑验证改为有针对性的选取文件格式以保证
 特定打开逻辑的验证集成时要求每种逻辑至少用一种文件格式验证保证了文件格式和打开逻辑验证的覆盖度


 补充文件测试中对于文件大小的关注。
收获：文件格式兼容的测试更有针对性，后面在测试第三方调起打开需求和手拉新需求的时候，都是直接按照表格上的格式让开发自测，同时我们自己也是这样验证的，既覆盖了的文件打开逻辑，也基本涵盖了用户常用的文件格式
实际效果：
从版本至版本，共发现个与特定文件格式相关的；比如：

【文件】压缩包格式文件打开均失败
【文件】第三方使用浏览器打开显示乱码

上线后：线上没有出现关于文件格式相关的用户反馈。
我们的思考
分析是一种手段，但不是目的。从得到的根因，反思和回溯产生的各个阶段，思考如何避免类似问题，不再踩坑，在下次测试中得到提升，才是我们想要的结果。同样的，分析的成果是一个持续改进优化闭环的过程，它是测试人员潜移默化中测试能力的提升，也是项目流程中各个角色共同保障产品质量意识的推动。因此，请做好分析，为产品质量保驾护航 
本章完

原文链接：


相关推荐偶尔需点击两次分析那些年我们踩过的坑 背景
互联网视频行业两大竞争方向，丰富的内容与前沿技术，对于不同视频内容越多，观看人数相应会越多。但对于同一内容，用户有多个选择时，理当选择体验最好的观看，排除习惯因素。所以不断对技术优化和创新是维持用户粘性和持续增加用户数量的重要环节，也是公司节省成本和开支有效方法。围绕用户体验和成本优化，腾讯视频推出了云剪辑系统。
 云剪辑
视频点播业务常规上线转码流程简述：
、采集卫星信号流
、离线非编软件剪辑广告、加字幕
、转码各种清晰度视频
、上线各种清晰度视频
以上整个流程在后期处理花费大量时间，造成节目延迟上线，给用户带来不好体验。
 云剪辑思想
云剪辑是一种用于在线编辑直播流一种实现方法，卫星信号接入直播编码器输出两路在线直播流，一路低码，一路高码，两路具有相同时间。低码用于在线剪辑，高码用于分布式后台转码。在线剪辑比常规剪辑流程更快，因为剪辑操作在线上完成，而不是把直播节目采集完成线下编辑，当节目直播结束，整个节目也被剪辑完，最后在线剪辑将输出一个用于记录打点信息广告的入点和出点的节目文件，分布式后台转码通过这个文件记录的打点信息切出广告。
 云剪辑架构

 云剪辑优化思想和方法
在线剪辑虽然线下编辑快，但线上剪辑技术上更加复杂，因为操作本地文件比操作网络流文件更容易，如响应延迟会很大、网络流没有完整索引文件，切割视频将不精确。所以在这里给出解决思路和想法，欢迎各位大牛指正。
 模糊  思想
用户在时间轴拖动游标时，实际不需要精确操作，开始只要知道广告出现的大概位置，基于这样的原理，可以对云剪辑操作做优化，每次传输和解码的数据只需要关键帧数据即可，大大提高了云剪辑响应的速度。
 = 
是当前用户时间轴的位置，用于把当前用户位置最近关键帧解码出来。
 帧精确切割
在线剪辑预览是基于技术实现，每一个分片都是一个文件，中存放时码的字段只有位，每秒是单位，该字段每小时复位一次还有时码跳变情况。
为什么要保证时码严格连续唯一单调递增呢？
假如播放某个网络流，每一帧都有一个如果中间时码复位和跳变，播放就会异常或乱序。最常见直播过程出现半个小时断流，那么用户预览会半个小时黑屏，最好能够自动跳过黑屏部分，继续播放黑屏后面有效画面。操作也是同样的原理，如果用户显示时间轴上某个位置的帧，只有在连续唯一单调递增的时码里查找，才能够找到正确的帧。
帧精确的关键所在是为每一帧设置一个严格连续单调递增的唯一时码。那如何才能实现单调递增的唯一时码呢？
 文件中存储每一个  分片都有一个近似时长字段
“”。那么可以给出每帧的  计算公式
分片  计算公式：
 = 
为第片的近似时长分片的实际时长分片第一帧的分片第帧的，片内每帧通过视频帧率和帧号计算得到。
每帧的计算公式：
=  
经过计算后，=  并严格唯一单调递增即。
从时间线精确切除某广告位置方法如下：
、用户先通过模糊定位广告所在分片
、通过左移右移一帧寻找广告开始结束位置。
、左移一帧查找当前
、右移一帧查找当前
、直到查找到广告开始结束位置
、获取广告开始结束位置，分片名分片内广告真正开始结束时间。
 所见即所得
在直播体育赛事节目时，视频背景会出现广告画面，在没有授权的情况，需要擦除广告。对于这些功能，通过线下非编处理，费时费力。所以云剪辑集成了擦除广告、加标、去黑边等功能，显著提高节目的编辑效率。
使用插件技术，响应鼠标拖动消息，每次数据移动消息，显示最新操作效果，通过双缓冲方式渲染，避免闪烁，即拖即现。
 云剪辑未来方向
随着短视频流行，视频行业互联网公司都推出了视频剪辑软件，比如搜狐云剪辑，快剪辑，爱奇艺在线非编等，腾讯视频云剪辑主要用于剪辑直播节目，点播节目还无法剪辑。对比各家剪辑软件，功能都相对简单，与广电非编软件有一定差距，如国内的索贝和大洋非编软件。
未来可把云剪辑打造成一款通用剪辑软件，即可用于内部编辑，也可用于外部用户。剪辑软件可发挥的空间还很大，可有各种各样的玩法，比如字幕和酷炫的特效，在线素材库，提供配音、配图等，类似广电行业图文包装系统。需求背景：
后台业务逻辑类服务，其实现通常都会依赖其他外部服务，比如存储，或者其他的逻辑。
有一类比较典型的问题：假设主调方是同步处理模型，有一个关键路径是访问服务。当被调服务延迟很高时，主调方的进程会挂起等待，导致后来的请求也无法及时处理，从而影响整个服务的处理能力。甚至出现服务不可用。当然，比较理想的是出现过载或者故障时，的服务能力能够降到和同等的服务能力，而非不可用。
因此，部门会定期进行容灾演习，也期望能够验证到各个服务的最差服务能力。即验证被调出现较高延迟或者过载的时候，主调的服务能力是否符合预期。要想做这种演习，其核心技术点是模拟被调服务出现延迟。以前类似场景是直接使用系列工具，但是由于操作麻烦，以及需要内核支持，实际使用范围非常有限。
目标：
实现一个通用的毫秒级的延迟代理服务，该代理服务用于模拟各种有延迟的被调服务。
、支持各种应用层协议的接入，无需修改后台代码。
、高性能。因为该服务就是用于压测其他服务的，不能自己先垮掉
为什么不使用？
是腾讯内部广泛使用的后台服务器框架，封装了网络数据收发、监控等。
使用开发一个服务器程序，不需要使用者关注网络相关的编程，只需按照其接口规范开发插件动态库需实现____等接口，然后挂到框架上即可运行。
框架通过回调插件内的__接口来检查数据包是否接收完整；当数据包接收完整后，框架会回调__对数据包进行处理。
是基于数据包的处理模型，处理请求时第一步就是断包，即调用__来检查当前收包是否完整。
断包的规则是与应用层协议相关的，比如协议的断包规则和单行文本协议的断包规则显然不一样。但是本程序的目的，是实现一个通用的延迟代理服务，即支持不同的应用层协议。如果使用基于请求包的服务模型，则每次接入新的应用层协议时都需要修改代码。不符合需求。
可能有同学会想到一个变通的方法让__直接返回当前长度。事实上，当请求包转给真正的被调后，还是无法解决收包时机的问题，以及同一连接上的多个请求被转发后，收包时序的问题。
这里采用的解决方案，是实现一个基于连接的代理服务，而非基于请求包的。
代理服务使用端口来区分不同的转发规则。对于每一个接受的连接，代理服务创建一个指向目标服务的连接，将前者透传到后者。回包时也是一样，按照连接对应关系反向透传即可。
这样代理服务可以做到并不关注上的数据协议，完全透传即可。
不使用其实还有一个原因，的的模型，其实并不是适合特别高性能的服务。在足够轻量的时候，单线程的可能成为系统的瓶颈，无法发挥出多的优势。
高性能
提到高性能，作为有情怀的程序员，通常会想到

尽量无锁

尽量无拷贝

尽量无多余的系统调用

内存分配要足够快


。。。
本服务在实现过程中会尽力以这些作为目标，比如使用了一些如下的小技巧：
使用_选项以上支持来将负载均衡到各，也避免使用消息队列带来拷贝和锁开销
使用指针操作，内存管理会麻烦一些，但避免拷贝。
使用等函数，一步设置异步 创建的函数也可以同时设置异步，减少系统调用。
使用关闭句柄，不需要从中删除句柄了时会自动从中清理掉。避免多余的系统调用。
获取系统时间足够快，位机器上已经不是问题。
在运行时，没有一个多余的调用
连接管理
对于每个连接，程序会维护一些属性，比如活跃时间等，是一个较大的结构体。因此，需要维护一个映射关系，能够根据句柄查找连接属性。可以使用或者来实现。
但是最简单的还是，直接使用数组。这里的是在启动时分配的数组。
  
{   
                  
    _         
    _         
                  
                 _    

                 
    _        _     网络字节序。该字段可能用作其他意义
    _        _    网络字节序
    _        _   网络字节序。该字段可能用作其他意义
    _        _  网络字节序

    _         
    _        
    _     
     {
     {
                
                 
    }
               
}

}  
   
上的句柄是整数值，所以这里可以使用这个技巧，直接以的值作为数组的索引
优点：简单，快，无生命周期问题
缺点：存在一定空间浪费
这里提到快，其实是有疑议的。
虽然使用数组来管理连接的数据结构是的，足够快。但事实上内核管理句柄是使用红黑树的，其时间复杂度为。综合来说，时间复杂度依然是。但是依然足够快了。
连接超时机制
作为一个×运行的服务，需要考虑其健壮性。考虑如下几个场景
某客户端连接该服务后，客户端机器掉电，或者网线断开，或者中间路由器故障。此时服务器并不知晓，会继续保持连接。
客户端编程使用了长连接，然后一直没有断开，也没有继续请求。此时服务器也会保持连接。
如果没有清理机制，
场景会导致服务端的句柄数随时间增长，最终耗尽资源后宕机，不可能×小时持续运行。
场景类似，如果这样的客户端太多，会占用服务端的资源，却没有真正用于提供服务
所以每一个成熟的服务器都会自带清理基因：对于长时间不活跃的连接，服务器会主动断开，以节约服务器资源。
这个问题其实是比较有趣的，可以抽象为如下的问题模型：
有个连接，
如果一个连接连续秒没有收到数据，则该连接已到期。
如果某连接有数据到来，则从最后一次收数据开始，重新计时秒
连接有可能在中途被关闭
随时可能有新的连接加入
简单来说，就是在一堆到期时间变化的句柄中找出已到期的句柄。
显然最直接的办法是遍历，时间复杂度。
然而，一个可管理的句柄数可达数十万，甚至百万级，这种方法显然效率太低
方案：级的超时机制假设是常量
维护一个链表，按照到期时间对数据排序，最先到期的项都在链表头部。
如果要寻找所有已到期的句柄，只需从头部开始遍历，注意只要遇到一个未到期的句柄，就可以退出遍历了。因为由于有序性，后面的节点更不可能到期。
由于在当前时刻刚好到期的句柄数，相对于所有句柄数而言是一个非常小的值，所以节约了大量的遍历时间。
不过问题来了，当一个句柄收到数据时，到期时间变化了，该如何处理？
假设句柄的最后收包时间为， 则到期时间应为，由于是常量，所以的顺序其实就是的顺序。
所以只需删除掉链表中原有节点，然后添加到链表尾端即可，时间复杂度
细心的同学会发现，其实还是有一个问题，如何根据找到链表中原有的项？
通常的解决方法是使用侵入式的链表侵入式链表可以参考内核中链表的实现方式可以避免这种查找以及节点拷贝等问题。很多算法也使用这种实现方式。的也使用了这种实现方式。
方案：级别的超时机制
从方案可以看到，虽然实现了的查找，但是该方案有一个限制：即必须是常量。
如果不是常量，则最后收包的连接一定在最后超时这一结论不成立了，则意味着不能简单的将连接放到链表尾部。即方案无法正常处理这种情况。
 为变量时，比较典型的实现方式是使用红黑树。而中使用红黑树，最简单的办法就是直接使用
由于本服务器实现上允许使用方配置各种不同的超时时间，所以使用了红黑树的方案。
以句柄的到期时间微秒级时间戳作为，清理函数及参数作为
__ 
   ___  {  }
  
_ __       {
    _ 
     = 
     = 
     =  
     _
}
红黑树的第一个元素是整棵树中最小的，如果第一个元素都没有超时，则可以断定整棵树肯定不存在已超时的元素了。所以只需要循环检查第一个元素是否超时，如果已超时，则回调对应的清理函数由红黑树的元素的指定的，然后删除第一个元素；否则退出循环。
         _ =  
         { 
             {
                  = 
                 
                 
            }  {
                _  =  
                _||_ _ =  
                   
            }
        }
使用红黑树来管理超时也是比较一个常用的实现方式。在内核的句柄管理，以及中都有使用。
延迟机制与定时器
、数据结构
如果只是为了管理连接超时，只需把型的句柄值作为的也可以实现，然后在适当的时机去检查中的句柄的超时情况即可。
但事实上，在一个异步处理的服务器程序中，有很多类似的场景，比如本服务器中涉及的句柄到期清理，句柄到期清理，请求包延迟，以及超时等，其处理逻辑均不同。但是其本质是相同的，都是在指定时间后执行一个逻辑。这种指定时间后执行一个逻辑可以抽象为统一的定时器，以便代码中所有地方都可以很容易的复用到这种定时机制。
实现定时器时，实际上是将设计为_数据结构，这只是一个简单的结构体，包含了回调函数，回调参数，标识个字段。并提供注册定时器事件、移除定时器事件的接口。
这样，句柄到期清理，句柄到期清理，请求包延迟，超时这几类场景，其触发及回调的机制是相同的，只是的值不同
将收到的数据延迟后再转发也只是其中一个具体场景，程序收到数据后注册一个定时器事件，被唤醒后执行回调函数转发数据即可。
将位函数指针放到中会浪费一定空间。如果红黑树有个元素，则需要约的空间用于存储函数指针。
若严格考虑内存使用效率，其实有一个简单的优化方案：用一个数组来存储回调函数列表，然后将数组的索引放到中代替函数指针。
通常来说，回调函数的可选值是很少的，比如我们可以使用个字节或者个字节的整数索引即可标识一个回调函数。
此外字段其实目前只需要位即可标识。
不过对于本服务来说，这个的内存浪费并不是大问题，所以暂未针对的大小做优化
、定时器唤醒
使用红黑树实现定时器，很容易找到当前已经到期的节点。但是还有个问题未解决：程序应该在什么时机做超时检查？即定时器唤醒时机的问题。
服务器总框架是运行在一个事件循环中，当有网络事件发生比如句柄可读可写时就会返回。如果没有事件发生，则处于阻塞状态。那程序如何知道有定时器事件到期？
很容易想到，本身是可以指定毫秒级的超时时间的。在最后一个参数指定的超时时间到期时，即使没有网络事件发生，也会返回。所以我们若指定的超时时间，比如，则可以肯定每内至少会返回次，我们就有可靠的时机去检查红黑树上的超时情况。
这样做，虽然是可行的，但有个问题：超时时间设置为多少是合适的？
问题 如果该值很小，那么在没有网络事件发生的时候，也会频繁返回。而且大部分情况下的检查，都会发现并没有超时事件到期。即浪费做无用功。
问题 如果该值很大，则会导致定时器的精度很低。比如若设置超时时间为，则对于一个后即将到期的事件来说，最多可能需要等待之后才被发现。
理想的情况当然是按需返回：即最好能在下次红黑树内的超时到期的时候返回，然后程序会检查红黑树，正好发现此事件到期。这种策略下，每一次唤醒都是有效的对比问题，而且到期时间是准确的对比问题
事实上，很容易就做到这一点，因为下一次的到期时间就是红黑树的第一个元素的值！
所以的最后一个参数取红黑树的首节点值与当前时间的差即可。
     {
         _ =  
         { 
                 {
                  = 
                   
                 
            }  {
                _  =   
                _||_ _ =  
                
            }
        }

         = _   _
        。。。
    }
内存分配策略
这里面临的内存分配，其实也是一个有意思的问题。
由于该的实现目标是可以透传任意的数据，对接入的服务没有要求，这意味着我们事先并不知道连接上数据量有多少，可能是几十个字节，也可能是几兆的文件。
那么接收数据时应该使用多大的缓冲区？
如果缓冲区太小，在数据量非常大时，则可能需要循环很多次调用系统调用，影响性能。
如果缓冲区太大，在数据量非常小时，则会浪费内存，对于几十万连接的服务来说，这个内存浪费会比较可观。
我使用了一个折中的办法，指数增长的缓冲区大小，以期望在 系统调用的次数 和 浪费的内存 间取一个平衡。
目前默认配置的缓冲区大小为，系统首先使用这么大的缓冲区去
如果缓冲区收满，则继续收包，但再次分配的缓冲区大小翻倍，使用
如果缓冲区又收满，则继续收包，但再次分配的缓冲区大小再翻倍，
。。。
     {
        =_ 
         {            
           ==   
           == 
            ___ _  
        }  == {
            ___ _  
        }  {
             = 
        }

        _ = = =  __ __         
           ==_ {            
           =__ {
                 ___ _    
            }
            _  = _   
              = ___  
             { ___ _      }
             = 
        }
    }
    。。。
  }
这种策略下，分配的缓冲区理论上最多浪费一倍最后一次分配后只使用了很少比如才个字节，系统调用次数为也不会特别夸张。
这是一个可以接受的平衡点。
此外，对于连接数据结构的自身由于使用了预分配，并且是的效率，不涉及内存分配问题了。
对于其他的通用的内存分配，比如内的内存分配，目前暂未做特别处理。
由于目前都运行在位的上，其的性能已经很高，所以暂未使用类的第三方库。在上一篇中，我们完成了数据区域的优化，得到很多童鞋的反馈，说想了解下如何优化应用层面，其实也无所谓优化，之前我们在实现应用高可用时采用的是 或  加上反向代理，而现在使用，我们在实现公有云的应用只是简单的配置云负载均衡与前端的负载即可：
 
而这里的前端也只是为了方便大家识别，实际上使用了一些特殊配置来节省两台红色为已完成搭建，蓝色是本次文章涉及的区域：
 
、    这里所使用的已非基础篇所用的，不过架构基本也是的，采用的是的 具体如何部署这里略，首先准备对应的服务器端口修改为内部端口这里的主机名绑定请随意：
 
、    设置安全组开放这里有个细节，安全漏洞一键实现高危对外端口封堵：
 
、    创建一个外网型：

、    建立监听器：
 
、    这里设置好轮询：

、    这里的监测还属于比较初级，仅检测可用性，后面我们引入作为应用监控可以看到更多数据：

、    访问地址查看应用是否正常：

、    接着在域名商上添加对应与域名的解析，即完成应用的准备与优化：

、    现在就可以使用访问到对应网站：

后记：采用 产品实际上对应用级别的负载非常有好处，按照传统微软系的高可用应用需要部署多个节点并安装，根据设备类型、应用情况还要选择使用哪种播发模式，单播、组播模式选择上都存在需要设备协调问题，此外负载依赖于节点本身，也存在一定风险，采用后，实际上可以实现下图架构：
 
图来自官网
后续自动化故障处理模块会解说如何根据业务负载来自动弹性扩展子机并加入对应的基于节点中，下一篇开始进阶篇的重头戏。背景：
 年  月  日， 蠕虫通过  漏洞在全球范围大爆发，感染了大量的计算机，该蠕虫感染计算机后会向计算机中植入敲诈者病毒，导致电脑大量文件被加密，本文对其进行详细分析。 
木马概况：
 木马利用前阵子泄漏的方程式工具包中的“永恒之蓝”漏洞工具，进行网络端口扫描攻击，目标机器被成功攻陷后会从攻击机下载  木马进行感染，并作为攻击机再次扫描互联网和局域网其他机器，行成蠕虫感染大范围超快速扩散。
木马母体为 ，运行后会扫描随机  的互联网机器，尝试感染，也会扫描局域网相同网段的机器进行感染传播，此外会释放敲诈者程序 ，对磁盘文件进行加密勒索。
木马加密使用  加密文件，并使用非对称加密算法   加密随机密钥，每个文件使用一个随机密钥，理论上不可破解。 

详细分析：
 行为：
、开关：
木马在网络上设置了一个开关，当本地计算机能够成功访问  时，退出进程，不再进行传播感染。目前该域名已被安全公司接管。
 
、蠕虫行为：
通过创建服务启动，每次开机都会自启动
 
从木马自身读取 _ 漏洞利用代码， 分为  和  两个版本。
 
创建两个线程，分别扫描内网和外网的 ，开始进程蠕虫传播感染。 

对公网随机  地址  端口进行扫描感染

对于局域网，则直接扫描当前计算机所在的网段进行感染 
 
感染过程，尝试连接  端口
 
如果连接成功，则对该地址尝试进行漏洞攻击感染

、释放敲诈者

 行为：敲诈者
解压释放大量敲诈者模块及配置文件，解压密码为 

首先关闭指定进程，避免某些重要文件因被占用而无法感染

遍历磁盘文件，避开含有以下字符的目录
\
\
\
\ 
\  
\\\
\ \
         
 
同时，也避免感染木马释放出来的说明文档


木马加密流程图
遍历磁盘文件，加密以下  种扩展名文件。
                                                                                                                                                                                  
程序中内置两个   公钥，用于加密，其中一个含有配对的私钥，用于演示能够解密的文件，另一个则是真正的加密用的密钥，程序中没有相配对的私钥

木马随机生成一个  字节的密钥，并拷贝一份用  加密， 公钥内置于程序中

构造文件头，文件头中包含有标志、密钥大小、 加密过的密钥、文件大小等信息

使用  模式  加密文件内容，并将文件内容写入到构造好的文件头后，保存成扩展名为 的文件，并用随机数填充原始文件后再删除，防止数据恢复



完成所有文件加密后释放说明文档，弹出勒索界面，需支付价值数百美元不等的比特比到指定的比特比钱包地址，三个比特币钱包地址硬编码于程序中




解密程序：
木马解密程序中内置了其中一个公钥的配对私钥，可以用于解密使用该公钥加密的几个文件，用于向用户“证明”程序能够解密文件，诱导用户支付比特币。

 
此后，程序判断本地是否存在“”文件，该文件为真实解密所需私钥文件。若存在，则通过解密测试文件来检测密钥文件是否正确。

若正确，则解密，若错误或不存在，木马将程判断解压后的  目录下是否存在 ，若不存在，则生成该文件，并且调用  拉起该进程：

该程序主要为  匿名代理工具，该工具启动后会监听本地  端口，木马通过本地代理通信实现与服务器连接。

在点击“ ”按钮后，由服务端判断是否下发解密所需私钥。若私钥下发，则会在本地生成解密所需要的  文件。

而后，程序便可利用该  文件进行解密。不过，到目前为止，未曾有解密成功的案例。
 文件列表及作用：
 中招敲诈者后桌面壁纸
 配置文件，包含洋葱域名、比特币地址、 下载地址等
 提示文件，包含中招提示信息
  文件，包含  客户端
 测试文件
 解密程序
 可免支付解密的文件列表
安全建议：
由于之前爆发过多起利用  端口共享漏洞攻击案例，运营商对个人用户关闭了  端口。因校园网是独立的，故无此设置，加上不及时更新补丁，所以在本次事件中导致大量校园网用户中招。管家提供以下安全建议
，关闭 、 等端口，方法详见：
、下载并更新补丁，及时修复漏洞目前微软已经紧急发布 、、  等系统补丁，已经支持所有主流系统，请立即更新；
、安装腾讯电脑管家，管家会自动开启主动防御进行拦截查杀；
，支付比特币并不能解密文件，不要支付比特币，保留被加密的文件，等待解密作者：王少飞

先看下官网的一个。定时更新当前元素， 
拿这个例子分析下的实现原理：
首先是的方法，

将新的状态放到队列中  ， 
 
新的状态是立即更新还是后面更新这个例子是在中更新的情况，

这里采用事务处理为了可以执行用户绑定的生命周期的方法，要更新的状态最终放到中 ，
 
最终中的数据经过后渲染到页面。


原文链接：作者：宋秋萌

先描述一下我们产品的效果，你可以借助任何一个远程终端来讲解你的  一个手机、麦克风等，我们的系统会根据你讲解的内容帮助你自动播放  ，解决播放  的麻烦。
一服务端代码实现
先放上我们的系统架构图

我们的服务器分成了两层来实现这项功能。
第一层是数据处理层
具体模块：
持久化模块数据库
我们选择的是用  数据库进行持久化操作。这个模块的主要功能是对每个  的信息进行记录，比如用户预先输入的每一页  的翻页提示语。每一个  都被是一个  ，同意放置在   里面命名比较随意。。其中，  的前面几条分别记录了用户的 ， 的信息等，后面则是记录每一页用户的翻页提示。即用户在当前页面说道这句话的时候，系统会下达翻页指令。
语义识别模块
这个模块是用来将用户发来的  类型进行识别，转化成  客户端可以理解的  指令。
由于在网上关于语义匹配的多是整个文章的语义匹配，或文章与一句话的匹配程度，而我们这个工程需要的是两个较短的句子的匹配，且比赛时间有限，所以我们只能自己在已有的较复杂的算法模型上自行改进，创造出了了一个简化版矩阵相乘的算法。具体实现思路如下：
首先，拿到用户演讲内容的字符串和用户设置的翻页关键句字符串，例如，用户演讲内容为：“接下来我们介绍屈原的文学成就”；用户设置的关键句为：“屈原的文学成就”。
然后分词模块开始工作，讲两句分别分词放在不同的中：{接下来我们介绍屈原的文学成就}{屈原的文学成就}
而且我们会调用开源  得到每个词的词性，匹配时根据词性设置权重。
对于  中每个词，分别去匹配  中的词，若是名词且匹配住，则  中那个词的的位置设置为，动词匹配成功会将权重设置为。若匹配不成功则为名词为动词为。其他词性的词也这样处理但权重不同，具体权重按具体情况分析，这样就可以得到一个矩阵。{}这样就可以算出来一个相似度约为，设置一个阈值，具体情况根据实际而定，若相似度大于阈值，则匹配成功，返回翻页指令。
对于轻微口音导致语音识别不准确，我们会和转成拼音的相似度进行综合。
 指令调度模块
这个模块用来综合调度语意模块识别出来的  指令。这个模块实现的核心是一个  集合，它以用户的  为 ，指令集合为  ，来储存用户已经发送而未被  客户端执行的  指令，并且通过一个接口提供指令的  操作。
考虑到网络的原因，用户发出的指令可能无法及时被客户端获取，所以我们在这里使用了一个  来储存用户的指令。当网络拥堵或者用户发送的指令过多的时候指令会被临时储存，并等待客户端周期性的访问取出。
第二层是服务接口层
 客户端
考虑到  平台的广泛性，我们的  客户端也选择采用   来实现。所以，服务端使用  平台的  框架来为客户端提供服务接口。具体结构包括获取  指令、注册服务、绑定  翻页提示语等，具体的实现细节则会交由第一层模块。
语音录入端智能手机
当时因为设备的限制，我们决定采用智能手机作为语音的录入设备。
考虑到  系统不支持  语言，我们没有使用  框架来提供服务，而是提供了更为适用的  接口。
这个接口会不断接收客户端识别并发来的  类型的用户语音，并交由语义识别模块来进行语意识别，并将结果交给  指令调度模块。
这样，一个调度  自动播放的服务端就可以搭建完毕了。
二服务器部署
这里我们采用了腾讯云服务器作为服务器的运行平台腾讯云推出的元学生服务器，简单易用。
首先在镜像市场上购买带有  开发环境的  系统牛人可以自己配置，再将写好的系统打包成  文件记得添加程序入口。
将程序上传后通过  客户端启动程序就  了最好能设置能一个服务，并设置成自启动，方法请百度。
三客户端实现简介
 客户端我们主要使用的  相关类来控制  的播放，并通过  脚本来实现视屏播放等功能。
语音识别端则是通过讯飞语音系统来识别用户说出的话，并上传到服务端进行处理。
这样，一个远程自动播放  的系统就搭建完毕了，大家在演讲分享的时候就再也不同站在电脑前来播放  啦。

相关推荐腾讯云服务器如何使用系统云服务器如何使用系统云服务器由主办的上海运维容器技术盛会于年月日在上海成功举办，近名中高端开发者技术人员参与。此次大会，腾讯云分享了多集群高可用运维实践，并向广大开发者限时免费提供上半年已上线的体验环境。


此次大会，腾讯云主要在现场向众多技术极客们，展示了容器服务和无服务器云函数产品、最新架构原理、实操演示环境以及相关实战案例。
容器服务支持用户直接调用，并基于打造了、等产品插件，并以腾讯云私有网络为基础，实现高可靠，高性能的网络方案。目前，腾讯云是国内最大的基于提供容器服务的公有云服务商，也是拥有国内最大规模集群的云计算企业。华尔街见闻、小红书、三一重工、、上海掌金等各类大型企业业务模块已经在腾讯云容器平台上稳定运行，容器平台建设成功落地。
以下附上本次全球运维大会腾讯云多集群高可用运维实践分享。导语
   系列 介绍图像真实风格迁移这一问题。详细讲解论文   算法原理与实现和该模型优于之前相关模型的关键之处。同时以高分辨率人脸图像作为测试图像，对比分析实验结果。
一、图像真实风格迁移问题介绍
近年来，由深度学习所引领的人工智能技术浪潮，开始越来越广泛地应用到社会各个领域。这其中，人工智能与艺术的交叉碰撞，不仅在相关的技术领域和艺术领域引起了高度关注。以相关技术为基础而开发的各种图像处理软件和滤镜应用更是一推出就立刻吸引了海量用户，风头一时无两。在这各种神奇的背后，最核心的就是基于深度学习的图像风格迁移 。
图像风格迁移算法可以解决如下问题：指定一幅输入图像作为基础图像，也被称做内容图像；同时指定另一幅或多幅图像作为希望得到的图像风格，算法在保证内容图像的结构的同时，将图像风格进行转换，使得最终输出的合成图像呈现出输入图像内容和风格的完美结合。其中，图像的风格可以是某一艺术家的作品、也可以是由个人拍摄的图像所呈现出来的风格。以下是一个图像风格迁移的示例 。









图 ：内容图像
图 ：风格图像




图 ：风格迁移结果需要指出的是，图像风格迁移这一问题并没有严格的数学定义。具体说来，这是由于图像的风格这一词汇本身就没有严格的定义，它包含了丰富的含义，可以是指图像的颜色、纹理和画家的笔触，甚至是图像本身所表现出的某些难以言表的成分。但另一方面，人类尤其是经过训练的专业人员却可以充分地感受和描述图像风格。因此图像风格迁移这一问题也和人类认知相关，并可以在一定程度上推动人工智能和神经认知相关领域的研究发展。
另外，图像风格迁移问题的研究，早在  年初就有很多学者开始进行研究，只是当时集中关注的是纹理合成与迁移问题，利用的数学手段主要是各种图像变换的统计方法，如小波变换 等，效果有限。直到近年来，受到深度神经网络在大规模图像分类上的优异性能的启发，借助其强大的多层次图像特征提取和表示能力，这一问题才得到了更好地解决，性能提升明显。
本文所要介绍和讲解的     论文，则是在图像风格迁移的基础上，进一步的要求两幅输入图像均为高清的、具有图像真实细节的图像，尤其是风格图像，并不是一些具有明显艺术家风格的风格图像。以下是一组论文的结果示例：









图 ：内容图像
图 ：风格图像




图 ：照片真实化风格迁移结果通过结果可以看出，合成图像将内容图像这一白天建筑风景照片很好的转换为了夜景风格，同时很好保留了内容图像的真实细节，算法效果让人赞叹。
以下就对这一文章的算法原理进行分析，并通过高分辨率人脸图像作为测试图像，对比分析实验结果。
二、算法原理分析
、已有算法的介绍
本论文是在论文 的基础上进行了有效改进。为此，首先介绍 的算法原理，这也是目前这类问题的算法基础。
我们的目的是输出图像可以分别结合输入图像的内容和风格，也就是我们希望结果图像可以在内容上与内容图像相似，在风格上与风格图像相似。为此，很自然的就有两个问题需要解决：如何分别表示和提取图像的内容和风格；如何刻画内容和风格上的相似性。前文已经提过，图像的内容和风格由于含义广泛并且没有严格统一的数学定义，并且有很大程度的主观性，因此很难表示。在 中，作者借助于深度卷积神经网络其强大的特征及语义表征能力，并利用基本的统计学知识，创新性地在一定程度上解决了这个问题，并最终取得了让人惊艳的效果。
众所周知，以 为代表的深度卷积神经网络模型可以很好地层次化提取图像特征从而对图像进行有效的表征，在大规模图像分类、图像分割和图像目标检测等多个任务上取得了优异性能。受到这一技术的启发，作者以  模型为例，通过实验对比验证，作者得到以下两个结论：
网络 _ 层的输出，即该层经过非线性响应而得到的 _，可以作为图像内容比较好的表示；
在风格表示上，由每一层输出的 _ 所得到的  矩阵可以作为图像风格的良好表示。具体计算方法为：将某一层输出的  个 _ 分别拉成向量， 矩阵的元素为 _ 向量之间的内积即 ，具体计算公式如下：

其中  表示第  层， 为  矩阵， 和  为第  个和第  个   向量。
在解决了图像内容和风格的表示之后，接下来就是如何衡量内容和风格之间的相似性，并将这一问题转化为优化问题求解。假定我们希望得到的最终合成图像为 ，输入的内容图像为 ，风格图像为 假设只有一副风格图像。为了使  与  的内容相似，我们有以下损失函数：
 
为了使  与  的风格相似，我们有以下损失函数：

其中， 代表  矩阵， 代表  ， 表示第  个卷积层， 代表  层中有  个  ， 表示   的尺寸。
最终我们会得到以下总的损失函数：
 
其中， 为总的卷积层个数，和为内容损失函数和风格损失函数中每一层的权重。为了求解这个优化问题，我们利用梯度下降法来进行数值迭代求解。具体过程可以参见论文 。
值得指出的是：在本问题中，我们需要求解目标是图像 ，而不是神经网络的参数。因此求解过程并没有神经网络的训练过程即，该问题并不是机器学习通常的训练测试流程，而只是一个普通的迭代求解过程。迭代结束，就得到目标图像。这也导致了该算法的运行速度比较慢。，只是在计算损失函数对  的梯度时，仍然需要借助于深度学习框架的高性能。这一点希望读者注意。
以上就是本文的算法基础。由于本文要解决的是图像真实化风格的迁移，即需要在风格迁移的同时，最大程度保留输入图像的真实细节。在这一基础上，本文提出了两个创新点来提升最终的结果。以下两小节将分别讲解。其中第一点最为重要，也是性能得以提升的关键。
、基于颜色空间局部仿射变换的  正则约束
为了实现在风格迁移过程中，不丢失图像的真实细节，作者提出了如下的策略：对于过程中的畸变进行惩罚。具体来说，因为输入的内容图像已经具有了我们希望的真实细节，而为了保持这些细节，作者提出了一种在颜色空间中的局部仿射变换，即假设最终的输出图像是由输入图像经过局部仿射变换得到。通过建立这一关系，就达到了通过输入图像来约束结果图像的目的。
具体的数学形式如下：作者借助于文献    问题的经典方法，是理解这一正则项的关键，感兴趣的读者可以参考其中的分析和推导。核心思想可以概括为概括为：输出图像的每一个颜色通道中的每个像素值，都可以由输入图像的局部区域像素的线性组合得到，同时该问题有闭合解的形式。 中的方法，提出了以下的正则项：

其中， 为输入图像  的  ，为输出图像  的  通道的向量化表示。这一约束可以让输出图像在边缘结构上与输入图像上尽量相似，从而使得输出最大程度上保留图像的真实细节。
、基于语义分割的增广风格损失函数
为了进一步的提升性能，使得模型能够适应输入图像的不同内容和风格，作者又提出了对输入图像进行语义分割 ，将分割模版同时作为算法的输入具体做法是将分割  作为输入图像的增广  一同输入到神经网络中，从而保证优化过程中只处理我们感兴趣的内容。
具体的增广损失函数定义如下：

其中，表示在  层中， 通过的分割 。
最后，将以上的各个函数组合在一起，就得到了最终的优化目标函数：

其中，为  正则项的权重。其余参数含义见之前部分的描述。同样的，优化方法为梯度下降。
三、实验结果和分析
、原文实验复现
在复现原文的过程中，本文作者并没有使用论文作者提供的  源代码，而是直接使用了根据源代码封装的第三方  ，从而避免了繁琐的实验环境配置。以下是原文中测试图像的复现结果。










图 ：内容图像
图 ：风格图像
图：照片真实化风格迁移结果



从结果图中可以看出，算法非常好地将内容图像香水瓶 的风格迁移到了目标风格火焰颜色，同时充分而准确地保留了内容图像的边缘结构和光泽等信息。仔细观察，连比较细微的结构都很好地得到了风格迁移和真实细节保留。实验环境为：       ， 内存。测试图像尺寸为 ，在迭代  次的条件下，处理一张图的时间约为  分钟。注：由于和原文的实验环境不完全一致，具体的实验结果可能会有偏差。
虽然  分钟的处理速度并不能满实时处理的应用场景，但可以设想，如果是手动进行处理，即使是专业人员，也需要花费很多时间，更为重要的是，无法很好地提取内容、风格元素和进行风格迁移。
、高分辨人脸图像的真实化风格迁移实验
为了进一步验证算法结果，我们采用使用专业成像设备，在内容和风格图像均为高分辨率人脸图像图像时，进行图像真实化风格迁移这里的风格主要指受光照影响的面部颜色。
第一组实验
以下是输入图像：










图 ：内容图像
图 ：风格图像
图 ：结果图像



两幅图像虽然总体上很相似，但光照条件的不同导致了两幅图像在人脸颜色存在一定程度的差异。因此我们希望通过以上算法实现图像的颜色迁移，并保留内容图像的高分辨细节。图  为真实化风格迁移结果图像。可以看出结果很不理想，具体存在以下几个问题： 脸部颜色并不完全是我们希望的颜色风格，同时面部颜色分布不均匀， 高分辨率细节丢失，具体表现在脸部纹理和头发等高频信息。
那么出现以上的结果原因可能为： 我们的输入图像没有原文中提到的语义分割 ， 风格图像除了人脸，还有其他的内容元素，并且语义风格并不明显。为此，我们进行了第二组实验，并分析了算法参数对于结果的影响。
第二组实验











图 ：内容图像
图 ：内容图像 
图 ：内容图像
图 ：内容图像 



实验结果：
 参数λ对于结果的影响：









图 ：λ= 的结果图像
图 ：λ= 的结果图像












图 ：λ= 的结果图像
图 ：λ= 的结果图像



从一系列结果图像可以看出，λ作为  正则项的权重，对于结果有很大影响。具体表现在，当λ比较小时，结果图像在颜色上和输入的风格图像很相似，但是皱纹、头发边缘等细节损失非常严重，仅保留了比较明显的结构信息，比如大尺寸和边缘强度比较大的结构信息，出现了明显的模糊现象。随着λ的增加，结果图像的细节保留越来越多，同时，颜色却原来越倾向于内容图像的原本颜色，而偏离了风格图像的颜色。这组对比结果说明，文本新提出的  正则项确实能够帮助风格迁移过程中真实细节的保留，从而提升迁移效果。另一方面，我们也可以认为，图像内容和风格并没有完全清晰的界限。可以视具体的输入图像与应用场景来精细处理。关于这方面，感兴趣的读者可以参考文献 。
综合两组实验结果，我们可以观察到，图像真实化风格迁移算法在我们的高分辨人脸测试图像上效果并不理想，可能的原因有以下几点：
人脸图像的统计特性和纹理结构与自然图像图像尤其是风景图像有很大的不同，用于自然图像的深度神经网络未必能够提取出合适的人脸特征。对应的，我们可以改用专门进行人脸识别的深度神经网络模型 进行图像的内容与风格特征提取。内容和风格图像的图像分辨率有差异，进行  的过程中，可能造成细节丢失和引入畸变和错误信息。输入图像本身分辨率已经非常高，在处理过程中任何细节的丢失都会影响主观的结果评价。
四、总结与展望
、注意相关问题的理论方法，尤其是  兴起前的经典论文中的方法。这些方法都是经过时间检验、可以比较好地解决某类问题的方法，仔细思考这些方法内在的本质，同时比较分析相关问题的之间的异同，将会非常有助于我们对问题本质的理解，从而触类旁通，举一反三，发现和提出新的模型与算法。
、对于图像风格迁移以及真实化风格迁移，还有许多问题需要解决，比如算法加速达到实时来满足应用需求，多个风格和任意风格的自由变换等。由于并不是本文关注重点，就不在这里展开介绍了。感兴趣的读者可以查阅相关文献。 
由于时间精力有限，并且研究这一问题时间不长，如若文章出现错误，希望各位读者批评指正，同时非常欢迎就以上各个相关问题与作者进行讨论。
参考文献
               
            
                     – 
                        
                       – 
              
                  是  编写的一个框架，在本地安装完  环境后并在本地撰写博客文章，然后执行  提供的简单的命令生成静态页面，再通过命令或者手动将静态网站发布在远程主机上。
同时 可以离线撰写博客文章，并且可以使用任意文本编辑器工具例如 来编辑，默认使用  语法。
前提条件
如果想跟着本教程顺利完成博客的搭建，需要具备以下条件

一台腾讯云服务器并且安装好

云服务器上安装以及


环境配置
、安装
   
、安装以及
     
克隆
   
 
安装依赖
   
 
安装默认主题
 
在本地生成预览
 
然后在浏览器内输入  ，即可看到我们搭建完成的博客。

配置
至此，你的  就已经安装好了，接下来我们对  进行一些简单的配置。
我们需要修改的只有 _ 一个文件，这个文件包含 、   和    三个部分。在这里，我们只需要修改  中的 、 和  。
    博客名字
      博客副标题
    作者名字
编写发布博文
用  写博文主要是通过执行  提供的  命令来完成的，下面简单介绍一下，更多的详细信息可以查看  官方文档中的   
 _  在 _ 目录下创建一篇新博文
   生成博文到  目录下
   查看  和  目录的变化，且有变化时重新生成博文
    在  预览博文
 博文采用  语法进行书写， 的语法全由一些符号所组成，这些符号经过精挑细选，它的作用一目了然，因此你可能只需要  分钟就能快速上手。
若不想使用编辑器，在本地编写完成之后使用上传到，然后在执行 即可生成预览博文。

相关阅读在   服务器上部署  博客如何快速部署国人开源的  博客系统 利用搭建数据科学博客一、同步和异步
同步和异步通常用来形容一次方法调用，同步方法，调用者必须等到方法调用返回后，才能继续后续的行为，异步方法调用会立即返回，调用者就可以继续后续的操作

二、并发和并行
并发和并行都可以表示两个或多个任务一起执行，但偏重点点不同，并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”。
三、阻塞和非阻塞
一个线程占用了临界资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起，这种情况就是阻塞，非阻塞的意思与之相反。
四、线程的状态

线程的状态
、线程的启动是调用方法，而不是方法。
、线程的终止、不用是因为方法太过暴力，强行把执行到一半的线程终止，可能会引起数据不一致的问题，一般我们定义一个线程终止的方法，告知线程何时停止即可。
、线程中断：线程中断并不会使线程立即退出，而是给线程发一个通知，告知目标线程，有人希望你退出，至于目标线程接到通知后如何处理，则完全由目标线程自行决定。与线程中断的有三个方法
  中断线程
判断是否中断
： 判断是否中断，并清除当前中断状态
注：方法会抛出一个中断异常，这不是运行时异常，也就是说程序必须捕获并处理它。当线程在休眠时，如果被中断，这个异常会产生。
、等待和通知 注：这两个方法是在类中的，意味着任何对象都可以调用这两个方法。
方法，线程会停止继续执行，转为等待状态，直到其他线程调用方法为止。调用方法，就会进入对象的等待队列，当调用时，会从这个等待队列中，随机选择一个线程，并将其唤醒，这个选择是不公平的，完全是随机的。会唤醒等待队列里的所有线程，而不是随机选择一个线程。
、挂起和继续执行线程
与是一组相反的操作，调用方法后的线程，必须等到方法调用后，才能继续执行。
注：此方法已经被废弃，并不推荐使用，因为在导致线程暂停的同时，并不会去释放任何资源。此 时，若其他任何线程想要访问被它暂用的锁时，都会被牵连，导致无法正常继续运行。同时，若方法在前就执行了，那么被方法挂起的线程，很难有机会被继续执行，更为严重的是，它所占用的锁不会被释放，可能导致整个系统工作不正常。同时，对于被挂起的线程，从线程状态上看，还是，会严重影响我们的判断

原文链接：腾讯云技术社区「腾云阁」上线以来得到了广大程序员们的支持，为了吸引更多的开发者入驻，现再次举办【腾讯云的种玩法】征文活动。只要是与「腾讯云」相关的干货原创内容，都可以参加这次活动。
现在就动手写一篇干货满满的技术文章吧。分享你的干货，传递你的经验，没准儿，就拿大奖了呢。


【参与方式】
注册登录腾讯云账号

输入腾云阁作者入驻申请链接： 或点击腾云阁首页 右侧「申请入驻社区」按钮，等待审核通过审核时间个工作日之内。

作者填写「真实姓名」，选择擅长领域，填写「个人简介」、渠道，例如：腾讯云官网、腾讯内部、微信公众号、、博客园、简书等。

前两步操作非常简单，可以先完成哟。成功入驻腾云阁且通过腾讯云实名认证的作者可领取腾讯云元代金券。仅有个代金券名额，先到先得哟。
撰写并发表文章，在文章标题前加【腾讯云的种玩法】

【活动规则】
征文规则：

文章内容为腾讯云相关。
文章内容需为作者原创。一经发现侵权行为，取消活动参与资格。活动杜绝严重灌水行为，一经发现将取消获奖资格。
腾云阁对整个活动保留最终解释权。

评审规则：
最终得分：文章投票数专家评分
主要按照以下维度评分，届时将有腾讯技术专家黄希彤参与评审。

产品创新性
实用性
可借鉴性
代码规范度
与云计算能力的结合

文章评论数也会是热度考核的指标之一哟。
「腾讯云的种玩法」往期优秀文章：
《在腾讯云上创建您的 》系列
《激发云力量打造我的云端工具集》
《 部署  实践》等系列文章 
：撰写文章发布成功之后可以在评论区写下你的文章标题和链接哟。

所有【腾讯云的种玩法】征文文章如下， 月  日前提交的文章都可以参与本次征文活动哟
欢迎点击标题阅读征文，在你喜欢的文章页留下评论，每条评论算一个投票哟。
【腾讯云的种玩法】从到搭建自己的互联网领地
【腾讯云的种玩法】  整合微视频上传管理能力，轻松打造视频后台
【腾讯云的种玩法】几种在腾讯云建立的方法一
【腾讯云的种玩法】几种在腾讯云建立的方法二
【腾讯云的种玩法】  单机环境搭建与初步学习
【腾讯云的种玩法】  升级与实战练习与笔记
【腾讯云的种玩法】  整合万向优图图片管理能力，打造高效图片处理服务
【腾讯云的种玩法】   负载均衡配置详解
【腾讯云的种玩法】实现全站访问
【腾讯云的种玩法】系统文件权限的系统阐述与演示
【腾讯云的种玩法】自建 迁移云 过程小记
【腾讯云的种玩法】如何使用腾讯云构建自己的云桌面办公平台
【腾讯云的种玩法】在的  下搭建一个适用于个人的  环境
【腾讯云的种玩法】 服务器网络测试哪家强？ 帮你忙
【腾讯云的种玩法】一个小白的自学建站史菜鸟建站入门
【腾讯云的种玩法】零基础微信机器人实践云技术对个人开发者的影响
【腾讯云的种玩法】如何腾讯云存储上搭建一个博客
【腾讯云的种玩法】云服务器搭建环境
【腾讯云的种玩法】云服务器搭建爬虫环境
【腾讯云的种玩法】元体验腾讯云小程序后端解决方案
【腾讯云的种玩法】搭建属于自己的服务器
【腾讯云的种玩法】发送邮件设置
【腾讯云的种玩法】 整合  对象存储服务，享受无限容量存储服务
【腾讯云的种玩法】构建企业级应用环境之数据层面优化一
【腾讯云的种玩法】安卓加固在腾讯云上的使用附反编译结果
【腾讯云的种玩法】关于服务器反向代理 的一点思考脚本
【腾讯云的种玩法】邮件服务器的搭建
【腾讯云的种玩法】利用腾讯云搭建实用小工具
【腾讯云的种玩法】服务器配置系列一服务器的配置
【腾讯云的种玩法】在腾讯云服务器搭建平台，简体中文汉化版，更新缓存
【腾讯云的种玩法】轻松搭建内网穿透服务
【腾讯云的种玩法】运维的网络管理利器：弹性网卡体验
【腾讯云的种玩法】如何使用腾讯云服务器作为微信公众号的开发空间
【腾讯云的种玩法】快速通过搭建个人博客
【腾讯云的种玩法】开源服务器的配置和安装图文详解
【腾讯云的种玩法】构建企业级应用环境之数据层面优化二
【腾讯云的种玩法】从购买服务器到建站，从打造自己的网络领地
【腾讯云的种玩法】如何利用腾讯云搭建个人网盘
【腾讯云的种玩法】编译下客户端和相关配置
【腾讯云的种玩法】、、服务器虚拟主机配置
【腾讯云的种玩法】伪分布式搭建
【腾讯云的种玩法】发布更新文章、提交审核评论自动清理腾讯云缓存
【腾讯云的种玩法】网站使用之后禁止用户真实访问的方法
【腾讯云的种玩法】 为  设置特定启动提示信息
【腾讯云的种玩法】自定义  
【腾讯云的种玩法】在下搭建个人博客系统
【腾讯云的种玩法】利用 节省成本
【腾讯云的种玩法】项目部署指南
【腾讯云的种玩法】跨园区容灾，升级不停服——高可用负载均衡集群实践
【腾讯云的种玩法】在  上使用腾讯云  镜像加速构建
【腾讯云的种玩法】在腾讯云上部署你的集群
【腾讯云的种玩法】个人网站如何开启？
【腾讯云的种玩法】架构实现动态网站论坛系统
【腾讯云的种玩法】云中漫步，做个公众号方便生活、取悦自己
【腾讯云的种玩法】十分钟架构课之一 ：从上云开始
【腾讯云的种玩法】使用腾讯云自建一个专属于自己的网络笔记本
【腾讯云的种玩法】新手教程：腾讯云安装
【腾讯云的种玩法】 之静态博客搭建自动部署
【腾讯云的种玩法】从一个云服务器到一款十年后的游戏之第一年
【腾讯云的种玩法】十分钟架构课之二：更好的网络
【腾讯云的种玩法】腾讯云备份手机照片、办公室文档、手机电脑快速传图
【腾讯云的种玩法】 搭建  服务器实测版
【腾讯云的种玩法】十分钟轻松搞定云架构之三：更大的存储
【腾讯云的种玩法】一分钟加固你的腾讯云主机
【腾讯云的种玩法】试用腾讯云     镜像的几点经验分享
【腾讯云的种玩法】专为新手小白写的服务器环境配置网站教程
【腾讯云的种玩法】十分钟轻松搞定云架构之四：替你分心的负载均衡
【腾讯云的种玩法】在腾讯云创建您的 ——机准备篇
【腾讯云的种玩法】十分钟轻松搞定云架构：数据库的主备 双活 读写分离
【 腾讯云的种玩法】十分钟轻松搞定云架构：单点和多点
【腾讯云的种玩法】十分钟轻松搞定云架构：的命中率是什么
【腾讯云的种玩法】腾讯云公网负载均衡技术实现详解
【腾讯云的种玩法】腾讯云数据库优化最佳实战：以为例
【腾讯云的种玩法】分钟搭建  网站
【腾讯云的种玩法】十分钟搞定云架构 · 什么是、什么是
【腾讯云的种玩法】十分钟轻松搞定云架构 · 负载均衡的最佳实践
【腾讯云的种玩法】网站服务器学习与入门
【腾讯云的种玩法】十分钟轻松搞定云架构 · 负载均衡的几种类型
【腾讯云的种玩法】十分钟轻松搞定云架构：的两种上传模式
【腾讯云的种玩法】 十分钟轻松搞定云架构 · 负载均衡的几种均衡模式
【腾讯云的种玩法】小心！ 升级到 的几个坑
【腾讯云的种玩法】构建企业级应用环境之应用层面优化
【腾讯云的种玩法】利用  快速搭建  仓库  与代码审阅  平台
点击查看全部腾讯云的种玩法征文
欢迎给你喜欢的征文通过评论的方式投票。

腾云阁【腾讯云的种玩法】征文活动获奖名单公布
继续关注我们，以后会不定期有各种各样的活动哟。随着容器技术在企业的大量应用与普及，越来越多的技术实践和应用场景成为用户更为关注的地方。随着企业和开发者的需求，在开发应用层面研究和发展势头也越加迅猛，如何让用户更加专注于上层业务，减少底层运维成本？如何让企业的资源投入到更加可控和精细化的应用、服务和业务、运营管理上？

月日，腾讯云特为技术开发者们进行了一场关于容器架构、网络的最新实践和案例，以及容器向架构演进的技术实践分享。现奉上技术专家们的精彩供大家学习。编译 | ·、爱心心、_校对 | _

下个月机器学习领域的顶会就要在大洋彼岸开幕啦，那么这次的又有什么值得关注的亮点呢？在新作中提出了优化的新概念 ，通过最小化使用不同的 的同一个的预测差异，提升对于不同 的不变性，来对进行优化。模型在对比实验中取得了非常惊艳的效果，同时在图像标注和半监督任务上也表现不俗，下面就跟随小编对这篇文章进行一发膜拜吧。

摘要
作为神经网络中的一类十分重要的架构，主要用于语言建模和序列预测。然而，的优化却相当棘手，比前馈神经网络要难的多，学界也提出了很多技术来解决这个问题。我们在我们中提出了一项叫做 的技术，主要通过利用来实现这个目标。具体来说，我们首先用不同的 对两个一模一样的进行训练，同时最小化它们预测的差异。通过这种方式，我们的正则项会促进的表示对 的不变性。我们证明了我们的正则项的上限是线性期望目标，而且线性期望目标已经被证明了可以解决在训练和推理阶段的差异导致的较大差异。我们在两个基准数据集  和上进行了序列建模任务以评价我们的模型，并且获得了十分惊艳的结果。我们也证明了这种方法可以为图像标注 和半监督任务带来显著的性能提升。
 前言
像网络   和门控循环单元    这样的循环神经网络都是处理诸如语言生成、翻译、语音合成以及机器理解等序列建模任务的流行架构。然而由于输入序列的长度可变性，每个时刻相同转换算子的重复应用以及由词汇量决定的大规模密集嵌入矩阵等问题的存在，与前馈网络相比，这些网络架构更加难以优化。也正是由于同前馈神经网络相比，在优化问题上遇到的这些挑战，使得批归一化以及它的变体层归一化，循环批归一化，循环归一化传播，尽管确实带来了很大的性能提升，但其应用依然没有像它们在前馈神经网络中对应的部件一样成功等 。同样的，的朴素应用等，也已经证明在中是无效的等，。因此，的正则化技术到目前为止依然是一个活跃的研究领域。
为了解决这些挑战，等人提出将仅用于多层中的非环式连接。 ，会在训练期间在整个序列中使用相同的。等，在权重矩阵上应用了操作。  等以类似的方式随机选择使用前一个时刻隐藏状态，而不是使用当前时刻隐藏状态。类似地，作为批归一化的替代，层归一化将每个样本内的隐藏单元归一化为具有零均值和单位标准偏差的分布。循环批标准化适用于批标准化，但对于每个时刻使用非共享的统计等，。
等人和等从另一方面证明激活正则化和时域激活正则化也是正则化的有效方法。
在我们中，我们提出了一个基于的简单正则化，我们称之为 。这个方法将最小化两个网络预测损失的等权重加权和这两个网络由两个不同在同一个上得到，并将两个网络的预测结果的差作为正则项相加。我们分析证明了，该方法的正则化目标等于最小化来自不同的 的预测结果的方差。该方法将会提升预测结果对于不同的不变性。同时，文章也讨论了我们的正则项和线性期望等、以及激活正则化等，的相关性，并且通过实验证明了我们的方法与这些相关方法相比带来的性能提升，第五部分的 将进一步解释这些方法。
  
在神经网络中是一种强大的正则化方式。它通常在密集连接的层上更有效，因为与参数共享的卷积层相比，它们更容易受到过拟合的影响。出于这个原因，是系列一个重要的正则化方式。然而，的使用在训练和推理阶段之间是存在的，因为推理阶段假设是用线性激活的方式来校正因子，因此每个激活的期望值都会不同。小编注：为了更好的理解这部分内容，大家可以参考      ，这篇文章从理论上分析了的模式和一般的求期望模式的。然后提出了将这个作为一种正则化方式，也就是说的优化目标就是要尽可能小。另外，带有的预测模型通常会随着不同 而变化。然而，在这种情况下理想的结果就是最后的预测结果不随着 的变化而变化。
因此，提出 的想法就是在训练一个神经网络模型时，保证在不同 下预测结果的变化尽可能的小。比如，假定我们有一个模型θ，输入是，θ 是该模型的参数，然后让表示预测模型，即给定一个在时间点的输入样例， 是
当前输入是 ，其中  是关于输入的一个函数，隐藏层的状态是跟之前时刻有关。同样的，是跟整个输入目标样本对在第时刻的损失值相关的。
在 中，我们采用两个相同的来同时前馈输入样本。这两个共享相同的模型参数θ，但是在每个时刻有不同的   和。这样在每个时间点，会产生两个损失值
因此， 整体的损失函数就可以由下面公式表示，

其中κ是正则化系数，是的维数，是 正则化项，具体表示如下，
我们采用蒙特卡洛采样来估计，其中，和计算值使用的是同一表达式。因此，额外的计算可以忽略不计。
我们注意到，如下面所示，我们正则化项的目标等价于最小化在不同 下，预测函数的方差附录中有证明
备注  假定 和均是独立同分布的， 和是上述的预测函数。
因此，
 相关工作
 线性期望相关工作
  分析研究显示下述两者之间的预期误差在样本上是有上限的，即在所有的 下的模型的期望值与使用平均的期望值之间的误差。基于这一结论，他们提出了明确地最小化差异我们在我们的该符号表达中采用了他们的正则式，
其中，是 。但是，基于可行性考虑，他们提出在实践中使用下列正则式进行替代，

特别地，这个式子是通过在网络中的两次前馈输入分别使用和不使用 ，以及最小化主要网络损失该损失是在有的情况下的和前面指定的正则项但是在无的网络中没有反向传播梯度来实现的。  的目标是最小化网络损失以及期望差异，这个期望差异是指来自独立的 的预测值和来自期望的 的预测值之间的差异。同时，我们的正则项目标的上限是线性期望，如下式所示附录中证明：

结果表明，最小化目标可以间接地最小化我们的正则项。最终如前文所述，他们仅在无的网络中应用了目标损失 。实际上，在我们的研究中参见第节，我们发现通过网络无反向传播目标损失 会让优化模型更难。但是，在该设置中，同时反向传播目标损失 能够获得包括性能增益和收敛增益的网络收益。我们认为由于在所用实例中，网络权重更有可能通过反向传播更新来达到目标，所以我们的正则项收敛速度会更快。尤其对于权重   更是如此，因为在这种情况下，权重将不会在训练的迭代中获得更新。
  – 相关工作
为了实现在半监督分类任务中提高性能的目标，  提出了 –。他们提出的模型和我们提出的模型相似，除了他们仅在其中一个网络中应用了目标损失 ，并且使用的是依赖时间的权重函数而我们使用常量，可以等价于是我们模型的深度前馈版本。他们实例的直觉是利用未标记的数据来最小化两种预测上的差异，即两种使用不同 的同一网络的预测值。而且，他们也在监督任务中测试了他们的模型，但是无法解释使用这一正则项带来的提升。
通过对我们的实例进行分析，我们证明了，最小化该正则项在 –中也使用了同最小化模型预测结果备注中的方差是等价的。此外，我们也证明了正则项同线性期望命题之间的关系。在第节，我们研究了基于没有在 –中使用的两种网络损失的目标的影响。我们发现在两个网络中应用目标损失 将使得网络获得关键性的更快的收敛。最后，我们注意到时域嵌入  ，提出的另一模型，声称对于半监督学习来说，是比 –更好的版本在自然语言处理应用中相当的棘手，因为保存所有时刻的平均预测值会十分消耗内存因为预测值的数目往往非常大数以万计。还有一点，我们证明了在监督学习的实例中，使用时间依赖的权重函数来代替一个常量值是没有必要的。因为标记的数据是已知的，我们没有观察到提到的问题，即当在早期训练的中太大时，网络会陷入退化。我们注意到寻找一个优化的常量值比调整时间依赖的函数更加容易，这也在我们的实例中进行了实现。
和 –的方法相似，我们的方法也和其他半监督任务相关，主要有  和  。由于半监督学习并不是本文要关注的部分，因此我们参考了的更多细节。

 实验
 语言模型
在语言建模的情形下，我们在两个基准数据集 数据集等，和数据集等，上测试了我们的模型。预处理操作参考了等用于语料库，并且用到了 等，用于数据集。
对于这两个数据集，我们都采用了等人描述的 层架构。 。 用于的模型中的参数数量是万，而的参数数量则是万，这是因为词汇量更大，我们要使用更大的嵌入矩阵。 除了这些差异之外，架构是相同的。

 词级任务

我们使用混淆度指标来评估我们的模型，并将我们获得的结果与现有的最好结果进行比较。表显示了我们的结果，在现有上，我们的方法达到了最先进的性能。

词级任务

在语言建模任务的情况下，我们的表现优于目前的最新技术水平。 表列出了最终结果。关于实验的更多细节可以在节中找到。
 图像标注
我们也把 应用到了图像标注任务上。我们使用著名的  模型作为等，。这里要强调的是，在图像标注任务中，图像编码器和句子解码器架构通常是一起学习的。但既然我们想把重点放在在中使用 的好处上，我们就使用了冻结的预训练 等，模型作为我们的图像编码器。这也就意味着我们的结果不能与其他最先进的方法直接比较，但是我们提供了原始方法的结果，以便读者可以看到我们的良好的表现。表提供了最终的结果。
我们认为，在这个任务中，κ值较小时，效果最好，因为图像标注编码器在开始时就被给予了所有信息，因此连续预测的方差会小于在无条件的自然语言处理任务中的方差。 可能在这里是有利的，主要是因为它对不同的平均梯度进行了平均，从而更新权重频率更快。
   模型简化测试
在本节中，我们的目标是研究与我们方法密切相关的现有方法。      ，Π   和    我们所有的 小编注： 是为了研究模型中所提出的一些结构是否有效而设计的实验都是采用一个单层，使用相同的超参数和模型结构。
 线性期望 
第二部分已经讨论了我们法方法和方法的联系。这里我们进行实验来研究使用正则化和我们的正则化性能上的差异。除了，我们还研究了一个的改进版。就是跟的用法相似，将应用在两个相同的上在原作者的实验中只是在一个上用了。因此我们得到了一个没有任何正则化方式的基准模型。图画出了这几种方法训练过程的曲线。与其他方法相比，我们的正则化方法在收敛性上表现的更好。而在泛化性能上，我们发现和相似，而基准模型和表现得更差。有趣的是，如果一起看训练和验证曲线，似乎还有待进一步的优化。
 Π
因为Π和我们的算法相似即使它是为前馈网络中的半监督学习而设计的，所以我们为了明确我们算法的优势，分别从定性和定量的角度研究了它们在性能上的差异。首先，基于  任务，我们运行了单层和层来在语言建模上对两种算法进测试比较。图和显示了测试结果。我们发现我们的模型比Π收敛速度明显加快，我们相信这是因为我们采用两个网络Π相反反向传播目标损失，导致了更多的采用基于目标梯度的参数更新。

尽管我们设计的算法是专门来解决中的问题，但为了有一个公平的对比，我们在半监督任务上也与Π做了对比。因此，我们使用了包含类由大小图像组成的数据集。参照半监督学习文献中通常的数据拆分方法，我们使用了张标记的图片和张无标记图片作为训练集，张标记的图片做验证集合张标记的图片做测试集。我们使用了原版的层残差网络结构，网格搜索参数
，
率在{，，，}，然后保持剩下的超参数不变。我们另外测验了使用无标记数据的重要性。表给出了结果。我们发现我们算法的表现和Π几乎一样。当无标记数据没有使用时， 仅仅比普通的表现得要稍微好些。
激活正则化和时域激活正则化分析
  的作者们研究了激活正则化的重要性，和在中的时域激活正则化，如下所示，

表：基于模型在改变的半监督任务数据集的准确率。我们发现我们提出的算法和模型有同等的表现。当未标记数据没有被使用，传统会破坏性能，但是 提供了略好的结果。这意味着当缺乏数据和不得不使用额外的正则方法时，我们的方法是有利的。

图：研究：使用词级模型的单层参数的训练左和验证右混淆度。显示了基准模型、时域激活正则化、预测模型、激活正则化和 我们的算法的学习动态曲线。我们发现与对照的正则项相比，收敛速度更快，泛华性能更好。
其中，是在时刻时的输出激活因此同时取决于当前输入和模型参数。注意和正则化应用在的输出上，而我们的正则化应用在的输出上。但是，因为我们的正则项能够分解如下：

并且，封装了一个项和点积项，我们通过实验确定了在我们的方法中的提升并不是单独由正则项决定的。目标也有一个相似的争论。我们在上运行网格搜索，包括在  中提到的超参数。我们在提出的正则项中使用。而且，我们也在一个正则式为正则项上进行了比较，以进一步排除仅来自于正则项的任何提升。基于这一网格搜索，我们选择了在验证集上对所有正则化来说最好的模型，另外还报告了一个未使用已提及的种正则化的基准模型。学习动态如图所示。与其他方法相比，我们的正则项在收敛和概括期间都表现更好。当描述的任意正则项被应用时，平均隐藏态激活减少如图所示。
    语言模型比较
正如小节所述，由于等人的影响，我们要确保 能够超越现有的方法不仅仅是因为广泛的超参数网格搜索。因此，在我们的实验中，我们保留了原始文件中提到的绝大多数超参数，即嵌入和隐藏状态大小，梯度裁剪值，权重衰减以及用于所有层的值词向量上的，层间的输出，最终的输出和嵌入。

当然，也进行了一些必要的变化：

和的系数必须改变，因为 也影响的激活如小节所述  我们没有进行网格搜索来获得最好的值，而是简单地去除了和正则项。
由于我们需要两倍的内存，所以的被减小了一半，从而让模型产生大致相同的内存量需求，并且可以安装在同一个上

最后一项变动的地方是改变的非单调间隔超参数。我们在∈{}上进行了一个网格搜索，并且在取最大值和的时候获得了非常相似的结果。因此，我们的模型使用普通优化器的训练时间要长于原始模型。
为了确保我们的模型效果，我们在数据集上通过使用不同种子的原始超参数不进行微调运行了个学习程序来计算置信区间。平均最佳验证混淆度为±，最小值为。测试混淆度分别为±和。我们的得分分验证混淆度和分测试混淆度比最初的得分好。
由于计算资源有限，我们在数据集对 运行了一次单独的训练程序。在这个实验中，我们使用数据集的最佳超参数κ= ，非单调间隔 = ， 减半。
我们证实使用会对有好处等，。然而，这是一个非常耗时的做法，因为在这个附加的学习过程中可能会使用不同的超参数，所以通过广泛的网格搜索而获得更好的结果的可能性更高。因此，在我们的实验中，我们使用与官方存储库中实施的相同的程序甚至没有使用 。表中列出了的重要性。
我们认为，运行网格联合搜索所有超参数可能会获得更好的结果改变率可能是尤其有利，因为我们的方法就明确地使用了。然而，我们这里的目的是排除仅仅因为使用更好的超参数而表现更好的可能性。
 结论
在论文中，我们提出了一个叫做 的简单正则化方法，通过作为正则项来减少模型在不同的 上预测结果的方差。通过实验证明了我们的模型具有更快的收敛速度，同时在基准语言建模任务上取得了最先进的成果。 我们也分析研究了我们的正则项和线性期望  等，之间的关系。我们进行了一系列的 研究，从不同的角度评估了模型，并从定性和定量的角度将其与相关方法进行了仔细比较。

论文链接   
本文来源于  科技大本营微信公众号著名统计学家、中国人民大学统计学院教授吴喜之教授
采访 | 胡永波，鸽子
导读
机器学习是一门在统计学和计算机科学交叉点上茁壮成长起来的学科。关于数据的学问，全在统计学里。
在经典统计学中，对于数据性质的研究、误差的分析、数据质量的判断、数据模型的建立，有着非常丰富的思想、理论和经验成果。对于机器学习来说，统计学既是理论基础，又是思想宝库。
但是现实世界中，机器学习的实践者大多出身计算机科学，除了本科学的那一点工科概率论与数理统计，对于统计学，基本上是“随用随学，够用为止”，因此统计学当中大量的思想资源实际上是被闲置的。
事实上，无论是做人工智能，还是做商业数据分析，如果能够对统计学有系统的理解，那么，他对于机器学习的研究和应用便会如虎添翼，登堂入室。
不过大多数统计学出身的学者推崇数学模型驱动的路子，在他们看来，直接从一堆实际数据出发做预测分析的“野路子”，是登不了学术的大雅之堂的。因此相当多的统计学者并没有积极投身机器学习的研究、教学和应用中，与机器学习界的交流也远远不够。
吴喜之教授则走的是一条实用应用之路。
吴喜之教授是我国著名的统计学家，退休前在中国人民大学统计学院任统计学教授。吴教授上世纪六十年代就读于北京大学数学力学系，八十年代出国深造，在美国北卡罗来纳大学获得统计学博士学位，是改革开放之后第一批留美并获得统计学博士学位的中国学者。多年来吴教授在国内外数十所高校讲授统计学课程，在国内统计学界享有盛誉。
早在十多年前，吴教授就第一个在国内大学统计学课堂引入  语言，培养了国内第一批  语言专家。如今他已古稀之年，仍然孜孜不倦的学习新方法、新工具，并且亲自编程实践，探索不辍。
在统计学家当中，他积极拥抱机器学习方法，并且撰写多部专著，致力于融合统计学和机器学习方法。另一方面，他对于机器学习，特别是数据性质和质量分析、回归与分类，复杂数据统计方法以及时间序列分析，有着统计学家特有的深刻思想和丰富实践，对于机器学习的实践者，是难得的明师。
因此我们抓住吴教授在京的宝贵时间，对他进行了一次专访，请他结合亲身实践经验，谈谈机器学习与统计学相互结合促进的问题。在访谈中吴教授介绍了大量的案例，清晰简明地阐述了他对于机器学习和统计学一些重大问题的看法，是我们学习数据科学、机器学习和人工智能一份难得的参考。
以下是访谈的部分内容。
做数据就要各领域交叉
科技大本营：现在大家都关心人工智能，但我们科技大本营内部在讨论的时候就发现，人工智能的关注点更多的是放在算法、模型方面，至于上游的数据搜集和处理过程，大家关心得并不多。您怎么看待这一现象呢？

吴教授：的确是这样的，做任何数据分析，首先要有数据。但是怎么得到这些数据，就是一个费力不讨好的工作了。但这里的事情必须得干。比如，人们能通过编程拿到一些网络数据，但是，拿到数据以后，你怎么看待这个数据？怎么处理？用什么模型？这绝不是一个标准的教科书问题，而是一个集知识、经验、逻辑及创新能力为一体的过程。就拿我的书来说，我在书中写模型，用的虽然都是国外现成的真实数据，但却是挑选过的，如果对我们手中的应用数据，直接用书中的模型就未必合适，至少也需要做各种各样的处理。
比如过去，我参与过税务总局的一个项目，希望把数据中会逃税的那些人给找出来，但数据并未指明哪些人逃税。按照机器学习的术语，这属于＂无监督学习＂，对这个具体数据，没有教科书或文献给出任何的方法。具体的数据没有哪两个是一样的，这就要有独特的处理方法，你必须考虑基于什么样的偷税漏税机理和背景来建立模型，你总不能说大家都在偷税漏税，而的目的是要把最有可能偷税漏税的人找出来，所以你就要了解企业避税方面的思维方式和可能采用的方法。
这就是说，你既要有相关应用领域的知识，又得知道怎么来处理数据，还要会编程什么的……所有的东西你都会了，才能做好。这就是数据科学比较复杂、比较费劲的地方，需要有较强的跨学科能力。
科技大本营：那一般企业在数据处理上的问题多出在哪里呢？解决这里的问题需要什么样的能力？
吴教授：处理数据还在其次，他们很多没有处理数据最起码的条件，只能做一些很简单的事情。记得在年代，我去过一些比较落后的工厂：像是当时的天津汽车厂，生产雁牌轻型货车，从零件到成品没有完整的记录，基本上没有多少有关质量的数据；还有一个生产镍氢电池的工厂，他们希望改进质量，但缺乏关键的数据……这一类的问题有好多，你就很难做。因为到具体单位解决问题时，你希望他有什么数据，他可能就是没有，要想做好事情得从头开始干预。这说明企业生产线上的问题没有那么简单，不是你想拿什么就能拿到什么。但在生产实践上，恰恰需要这方面的数据来做质量控制，企业自己意识不强，你就很难越俎代庖。
科技大本营：当下机器学习非常火热，在它落地到这些具体的应用场景时，应该怎么面对这里的数据呢？
吴教授：现在专业编程的人比较多，但真正明白这个数据，理解我们需要从数据得到什么知识的不多。所以，一开始很难泛泛回答。
就说前面税务总局的项目，我刚过去时并不清楚，就让他们先给我讲那个问题，我思考之后，就有了一个大体的概念。这些东西很难说是某一个领域的知识，它是一些领域的知识加上经验、加上数据知识……相互关联起来，然后才有进一步怎么去做的打算。
这不是简单靠几本书、几个模型就能解决的。而且，书上的模型一般比较固定，例子也相对简单，毕竟书上只能介绍那点东西。比如说回归，一般回归书上大部分篇幅写的都是一百年前的线性最小二乘回归，但在最近十几年中就发展了大量基于算法的新回归方法。仅我写的书中介绍的机器学习回归就有很多种，比如基于决策树的有随机森林、、，还有支持向量机及较早就发展的神经网络，它们都能够做回归，往往都比线性最小二乘回归强大……但你必须要挑一个最好的，所以就需要你把这些数据拿过来做交叉验证，要让数据自己来说话，来确定哪个模型好，哪个模型坏。而经典统计上确定模型的优劣方法严重依赖于对数据的无法证明的众多数学假定。
在机器学习方面，很重要的一点就是交叉验证，就是用一部分数据来建立一个模型，然后用另外一块数据来验证这个模型好不好。但是在经典统计里就没有这种东西。
以经典最小二乘回归为例，做了很多无法验证的数学假定，比如模型及误差的线性形式假定，样本点的独立同分布假定，分布的正态性或大样本假定，对损失函数的二次形式的假定等等，然后根据各种检验统计量得到ｐ值，再按照ｐ值大小得到结论往往不加区别地认为ｐ值小于就显著。
这些基于百年前的知识结构产生的内容就要安排学生们花一个学期来学，即使这样古老的课程还有许多原则性错误出现于教科书中，而数据科学所需要的最有用的内容却往往被忽略。所以我常讲经典统计的数学式教学方法和模型驱动的思维方式误人子弟，这自然会得罪不少人。
一般来说统计专业出身的人对模型比较重视，但对数据感觉不够，甚至不敢触动陌生结构的数据如果不是害怕的话，搞机器学习必须既了解模型又乐于和数据打交道。所以学统计的如果不跟搞计算机的合作就什么也干不成，这一点应该让大家都知道。
科技大本营：那反过来像程序员这种学计算机的人，他们应该怎么跟统计学结合呢？
吴教授：统计学对课程基础的要求比较高，没有办法速成。我们知道，单纯的编程比较容易学，他们最好是在应用中学习统计的批判性思维，需要什么学什么，这样能够保持兴趣和学习动力，学的也较快。
但统计专业中，相当部分统计教授都不会编程，更不熟悉实际的数据分析，这还包括某些博导，他们见到稍微复杂的数据就蒙了。他们可以假定出一个模型，然后就说他们的模型怎么怎么好，但这是在很强的假定之下，比如数据一定要满足什么数学条件……一定要在这个条件下他们的模型才很好，他们最苦恼的就是寻找符合他们条件的数据为了发表文章，但实际上只有老天爷才知道是否存在这样满足他们条件的数据。
统计学的两种文化

北大时期的吴喜之教授
科技大本营：您是怎么开始做机器学习的？
吴教授：因为教学生，我要了解最新的方法，只要能用的、好用的，我就要教给学生去用。要想当好老师就需要不断学习新的知识。机器学习这块跟计算机编程直接相连，我学了以后，用机器学习的方法来解决问题，我觉得比经典统计要好用得多，真的不是一个数量级。
科技大本营：不是一个数量级，这该怎么讲呢？
吴教授：这是一种比方，而不是严格的术语。不过简单来形容的话，对于很多复杂的数据，用机器学习的预测误差如果只是、左右的话，那用经典统计就可能有百分之十几以上，差别就很大。当然，对于比较简单的数据，经典统计也可能表现不错，这不能一概而论。尽管从数学上，那些经典的东西看起来很漂亮，很吸引人特别是对数学背景的，但面对复杂的现实世界，必须要改变思想，不管方法漂亮与否，关键是能够解决问题。许多机器学习方法也很美，但不是数学公式漂亮，而是其思维及逻辑的美。现在都有飞机了，你还靠拉着板车在那走，那就是你的问题了。
科技大本营：那您是什么时候开始用机器学习的？
吴教授：这个是在非典的时候，年吧，是用语言。在中国，我大概是头一个在正式课堂上教语言的。
在那以前，我已经在教了，跟很像，都是编程语言。但当时多数老师教统计是不用编程语言的，他们会用盗版的及等点鼠标式傻瓜软件，不仅侵犯版权，还会让学生产生依赖性。所以国内的学生不懂计算机编程，跟这一点关系很大。老师自己都不会编程，只能教学生用盗版软件。只学点鼠标肯定是学不会编程、也看不懂代码的。
我开始教语言的那一级的学生，有些在数据领域中比较出名，比如李舰和刘思喆，比我要强多了。
后来我读了一篇很有名的文章，《统计建模：两种文化》     ，作者是 ，加州大学伯克利一个很有名的教授决策树、及随机森林的发明者，他去世后我才读到他的这篇文章。他在文章中狠批了把数据限制在假定模型中的经典统计学界，然后大力推广他在商业咨询中用机器学习做算法模型的有效经验，这一点我感同身受。
机器学习圈子意识到数据的生成过程是复杂和未知的，这一点符合实际，学完之后就能用出来，所以我就自己去推广。但是在国内推广很难，只能自己去教、去写书，把机器学习的东西写进书里，让更多的人掌握。
用机器学习来改造统计学
科技大本营：那我可不可以这样理解，你现在更多的希望，其实是想把机器学习的一些思想注入到统计学这个学科里边，对吧？
吴教授：我是希望改变统计学，用机器学习这个思想来改造统计学。机器学习的思维方式就是科学的思维方式。整个统计学界的问题太多，所以就需要改造。把它从数学假定主导的思维方式改造过来，从模型驱动改变成数据驱动或问题驱动，机器学习是实现这种改造的一个最佳方式。
其实我一直都对处理实际的数据感兴趣，尽量从数据出发来做统计，问题驱动的思维一直都有。九几年还在南开的时候，我就不断倡导这个事情。现在统计学做的很多东西都跟实际数据没什么关系，这种做法不过是把人禁锢在自己的模型里做梦。脱离实际的统计不但是无用的，而且是有害的。
的这篇文章使我的思维更加清晰，目的更加明确，的文章对我近年来走过的路程有着无可比拟的指导意义。
科技大本营：我们应该怎么基于问题驱动的思维来学习呢，吴老师您在这方面都是怎么做的？
吴教授：搞数据科学应该是问题驱动，学习知识也应该是问题驱动。我不喜欢完整地看大部头的统计书，因为整本整本地看下来，目的不明，被作者牵着走，效果肯定不好……一定要有感兴趣的问题来引导，才好钻研进去。学东西一定要问题驱动。好多新方法，我都是从语言里面学来的：首先看那些软件包能解决什么问题；如果对这些问题感兴趣我就看它的方法；如果想知道方法里面是什么原理、用的什么数学、为什么这样做，就去进一步看参考文献……这一套下来我自然就学会了；相对于打基础式的学习方法来说，这是相反的学习方法，是拉动式学习方法。
如果被老师限制住，你就算再聪明也能学傻了。所以一定不能死学，一定要有个目标，要有一个感兴趣的目的。比如，你的目标是把这个数据分析好，你必须考虑用什么方法来解决，怎么来编程……这里面的兴趣自然而然就来了。如果你只是为了编程而编程，把语法一、二、三、四背下来，你就没有一个载体把它们串起来。这是我最讨厌的学习方式，学生为了打基础，盲目地先看这本书，再看那本书，一堆书看完之后就完全迷失了，如果记忆力好会记一些东西，但绝对不会有助于增加动手能力。
反过来，为了解一个问题，你需要什么东西就去看什么，主动权在你手中掌握，这种拉动式的方式就让你有动机去学，而且学到的东西都是有用的。这是我的经验，你要是让我从头到尾去看一本书，我肯定是看不下去的。
科技大本营：那您在教学生的时候是怎样的，是如何让学生也能把你这套东西用起来的？
吴教授：对一般学生来说，我可能是有点像赶鸭子上架，如同魔鬼训练。在每个学校，我都给每个学生一个或者两个国外的数据网址，没有两个学生数据相同，然后给他们讲解一些包括机器学习在内的数据分析方法及编程初步，并且给他们一些我自己编的程序模板，目的是让他们得到任何从数据可以得到的结论。期末每个学生要上交数据、代码及或文件，并且上台在一定时间内向大家讲解数据的意义、所用的模型、计算过程及结论。这之后，学生就再也不害怕数据了。前年在云南的大理大学我就是这样做的，学生的基础虽然不如一些重点大学好，但都做出来了，而且许多人把我给的作业作为毕业论文。
前些天我看到他们本科毕业论文中有三个人还得了优秀论文奖。之前我在云南师大教课也一样，他们学起来也挺苦的，不过后来其中有几个人参加前年的全国大学生统计建模大赛，还拿到了一等奖。
当然，他们中的一些人在做完作业，甚至得奖以后，也可能还是不那么明白里面的道理，也可能只是会用现成的工具，但已经有了飞跃的进步，最重要的是他们有了信心。因为一开始他们真是什么程序都不会，掌握的统计方法也很有限，要现教语言及各种统计方法才能把课上下去。他们老师原来教的最多是。我曾经看到一本教学生怎么用来解决问题的很不错的书。我看了这书以后，花了半天功夫写了大约一页程序，把那一本书的问题全给解决了，这说明程序语言的简洁及强大的能力。
总之，一个结果就是给学生一种新的眼界及新的体验，让他们有信心来把事情做下去。
实际上，零基础的人也可以学机器学习，比如云南的一个烟草公司，我给他们一线的员工讲过几天统计，里面有人还是外语专业出身的，连统计的基本概念都不清楚，我就这样给他们讲，讲完给他们不同的网站数据去做，结果包括外语专业在内的绝大部分学员都做完了所分配的数据分析。
刚开始学习的时候，你不可能什么都学、什么都知道。你要从基础的模型开始，去理解它背后是怎么想的，为什么要这么编程序、这么去处理，这样做的好处是什么、能避免什么样的问题，背后这些东西弄清楚了，你就能弄清楚自己的问题是怎么出的。这样你就能学会怎么去用这些模型，甚至发展自己的一些新东西出来。
其实弄懂机器学习背后的机理并不难，也不需要事先读很多专业书。即使是那几个天才的发明，他背后的思维方式及编程原则并不复杂，如果把这些弄清楚，你对统计学的理解就能进一大步。

吴喜之教授亲自编写程序解决问题
科技大本营：这么说来，我们学机器学习、学数据科学，其实首先就是要有一种由问题来驱动的数据思维，用上这种思维就是对统计学的改造，我们能这样理解吗？
吴教授：一百年来，由于没有计算机，数据量有限，于是由数学家发展的经典统计引入了大量的数学假定来弥补数据信息的不足，这就给统计打上了很深的数学烙印，并且导致了很多统计学家模型驱动的错误思维方式。在计算技术飞速发展以及数据膨胀的新时代，如果还把自己束缚在这种模型驱动的思维方式中，就会被时代所抛弃。机器学习是典型的数据驱动的思维方式，它从数据出发，通过各种计算方法来理解数据，并建立适当的算法模型来拟合数据并得到结论。不仅在应用中，而且要在统计教学中大量引入机器学习方法是非常必要的，目的是还统计以数据驱动或问题驱动的本来面目。导语
当下直播平台发展十分迅猛，依靠游戏内直播平台的发展带动游戏活跃提升收入，那么对于我们开发来说如何玩转视频呢？下面就来介绍一个音频、视频处理利器——。
 简介
 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用  或  许可证。它提供了录制、转换以及流化音视频的完整解决方案。
 使用

格式转换：将文件  转换成 

     
   表示输入文件

视频和音频分离

     
  表示忽略视频
     
  表示忽略音频

压缩  文件：通过改变比特率，可以调整  文件的大小

      
   设置比特率，单位：

从视频中截取图片：从视频第  秒处截图，图片尺寸大小：，截图文件名：   

            
   强制选择格式
   搜索到指定时间，支持格式：，时间单位：秒
   设置记录时间
   设置帧的大小

获取视频时长

     |   |       |  

视频切片  

            
   跟标准的严格性

转换  文件并生成 

将  文件转换成  文件  
       _ 
 将  切片，并且生成  文件
          _  _  
 文件：传输流文件，视频编码主要格式 ，音频为 。
 文件：用文本方式对媒体文件进行描述，由一系列标签组成。
总结
以上是对  功能的一些简单的介绍，它的功能远远不止这些，还十分强大，有兴趣的小伙伴可以后续一起研究探讨，充分利用好这一个强大的利器。
附录
 官网：发表者简介： 于旸， 专家工程师，玄武实验室，玄武实验室总监 

内存的读、写、执行属性是系统安全最重要的机制之一。通常，如果要改写内存中的数据，必须先确保这块内存具有可写属性，如果要执行一块内存中的代码，必须先确保这块内存具有可执行属性，否则就会引发异常。然而，系统的异常处理流程中存在一些小小的特例，借助这些特例，就可以知其不可写而写，知其不可执行而执行。
一、直接改写只读内存
我在的演讲《    》中介绍了一种有趣的浏览器漏洞利用技术：通过修改对象中的某些标志，从而关闭安全模式，让可以加载类似这样的危险对象，从而执行任意代码而完全无需考虑。
不过，修改标志并非是让可以加载危险对象的唯一方法。
浏览器的某些界面实际上是用实现的，这些通常存储在的资源中，例如：打印预览是，整理收藏夹是，页面属性则是 。
浏览器会为这些创建独立的渲染实例，以及独立的引擎实例。而为这些创建的引擎实例中，本身就是关闭的。
所以，只需将代码插入到的资源中，然后触发的相应功能，被插入的代码就会被当作自身的功能代码在关闭的实例下执行。
不过，的资源节是只读的，如果试图用某个能对任意地址进行写入的漏洞直接改写的资源，会触发写访问违例：
= = = = = =
= = = =                
=  =  =  =  =  =             =
_
                        =
 
  
  
  
  
  
  
 __ 
           
                     
 __ 
          
 __ 
        
                    
 __ 
       __ 
                   __ 
  
在上面的异常处理链中，中的异常处理函数最终会调用。如果_标志是，就会终止当前进程：
 __   {
      
     _
      
     _
     

   =   
    _ 
  {
     =    
    _ = 
    _   
     = 
       
       = 
     = 
     = 
     
  }
   
}
但是，如果_标志为，异常处理链就会执行到，并最终执行：
 __   {
     

     
     =  
  
     = 
   
}
如果也为，函数就会将试图写入的那个内存分页的属性设为可写，然后正常返回。
也就是说，如果先将_和这两个标志改写为，之后就可以直接修改的资源，而不必担心其只读属性的问题，操作系统会处理好一切。
另外还有个小问题。如果像上面所说的那样触发了一次中的修改内存属性的操作，内存属性的也会变成一个内存分页的大小，通常是。而在以中的资源创建渲染实例前，函数会检查资源所在内存的属性，如果该属性小于资源的大小，就会返回失败。然而，只需将要改写的资源从头到尾全部改写一遍，就会相应变大，从而绕过这个检查。
这样，利用写访问异常对文件资源节开的绿灯，就可以写出非常奇妙的漏洞利用代码。
二、直接执行不可执行内存
我在的演讲《漏洞挖掘中的时间维度》中介绍了一种较为少见的模块地址释放后重用漏洞。比如一个程序中线程调用了模块的函数，模块又调用了模块的函数。模块的函数由于某种原因，耗时比较长才能返回。在它返回前，如能让线程将模块释放，那么模块的函数返回时，返回地址将是无效的。当时发现在浏览器中可以利用模块触发这种漏洞，一款国产下载工具也有类似问题。

另外还有不少其它类型的漏洞，最终表现也和上述问题一样，可以执行某个固定的指针，但无法控制该指针的值。在无环境下，这些漏洞并不难利用，只要喷射代码到会被执行的地址即可。而在环境下，这些漏洞通常都被认为是不可能利用的。
但如果在预期会被执行到的地址喷射下面这样的数据：
  _ {
                        
      
                        
             
                    
} 
即使在环境下，尽管堆喷射的内存区域确定无疑不可执行，但你会惊奇地发现系统似乎还是执行了这些指令，跳到所设定的地址去了。只要把设为合适的值，就可以跳往任何地址，继而执行链。
这是因为系统为了兼容某些老版本程序，实现了一套叫  的机制。系统内核在处理执行访问异常时，会检查异常地址处的代码是否符合 特征。对符合 特征的代码，内核会用函数去模拟执行它们。
  机制会检查要跳往的地址是否位于文件中，在支持的系统上还会确认要跳往的地址能否通过检查。同时，在之后的默认   下，  机制仅对没有设置 ___的程序生效。如果程序编译时指定了参数，就不再兼容  了。不过还是有很多程序支持  ，例如很多第三方应用程序，以及 位的 。所以，类似 泄露邮件中的，如能用某种堆喷成功抢占内存，就可借此技巧实现漏洞利用。
这样，利用系统异常处理流程中的  能直接执行不可执行内存的特性，就可以让一些通常认为无法利用的漏洞起死回生。
本文大部分内容完成于年月，涉及的模块地址、符号信息等基于        。
参考：
    ______
    _____
  “”         
 《漏洞挖掘中的时间维度》， 前段时间把博客迁到了腾讯云，感觉非常棒，再也不怕网站打开速度慢，再也不怕被人，再也不怕服务商跑路了……有朋友问我是怎么在腾讯云上做博客的，专门为他写一个指引，希望对大家也有帮助。当然博客好建，难于坚持更新啊！！！
注册腾讯云
注册腾讯云最好只要有个号即可，访问 腾讯云免费体验馆 ，点击 云服务器  入门型  免费体验
 
有可能会提示你先注册为腾讯云用户

注册一下，新用户会送你一堆礼包，呵呵

搞一个服务器
收好礼包，回到腾讯云免费体验馆 ，点 免费体验 回进入机型选择
地域选择离你最近的城市
系统选择  位
这里要通过 新手问答 或 个人认证 才可以免费体验

恭喜您，可以免费体验了，点 立即体验

进入到服务器列表，这时服务器还正在初始化，要等一下

刷新一下页面，了！！！

服务器配置
服务器有了，然后就要登录服务器进行配置，这里是重点。
服务器密码在哪
首先要去 站内信 看一下你拉服务器密码，请查收…… 这行字里有密码

打开，看到我红框里的重要内容了嘛，猜猜我的密码是啥 

登录服务器
有了密码，还要用    这个软件才可以访问服务器，下载  安装
下载地址：
安装好，打开，按下图把 、端口、用户名、密码 填写好，登录

登录成功，终端会显示成这样

用以下命令升级服务里的软件到最新版
  
安装
 是一个一键安装程序，可以方便的安装 、、 这些程序，有这些才能让正常运行
在终端逐步录入执行以下命令
          
     包含源码，国内外均可下载
  
     如果需要修改目录安装、数据存储、日志，请修改文件
      如果网路出现中断，可以执行命令`  `重新连接安装窗口
     注：请勿 或者 这样执行
然后按下图选择好相关软件


注意：请记录好你的数据库密码，后面会用到！！！
注意：请记录好你的数据库密码，后面会用到！！！
注意：请记录好你的数据库密码，后面会用到！！！

安装成功后，用浏览器打开你的公网，可以看到成功页面

绑定域名到目录
如何你有域名，可以用  命令绑定域名到目录

安装
就是博客程序了，他是世界上最流行的博客程序，安装方便，使用简单。
下载
进入你域名目录
 
或者默认目录
 
下载
 _
解压
  _
建立数据库
用浏览器打开你的公网，点击 ，用之前记录的账号密码登录数据库

点击  新建数据库

数据库名  
字符集选 __


安装
用浏览器打开你的公网，在地址后添加  访问，比如

访问后会显示以下界面，点击 现在就开始！

会提示无法创建  文件，这时 全选  复制

在终端进入目录，这里以默认目录为例
 
然后用创建 
 
在  中，按字母  进入编辑模式，复制进之前粘贴板中的内容

然后按 ，然后输入  保存退出
然后再回到浏览器中，进入下一步，设置 用户名 和 密码，请保存好啊！！！

然后会安装成功，提示登录

登录成功啦！！！这就是的后台

这就是安装好的了

最快安装
除了像上面那样一步一步安装，还可以在 新建服务器 时，在 服务市场 直接选择 博客平台，这样就不用像前面那边复杂的操作了。
在这里选 从服务市场选择

在 建站模板 中选择 博客平台


好了，接下来就是怎么坚持把博客一直写下去的事情了哦

相关推荐
利用搭建数据科学博客
使用  和  快速搭建个人博客
在云端快速构建一个个人站点概述
腾讯云容器服务在平台的基础上做了大量和腾讯云紧密结合的工作，比如集群创建时直接创建集群、集群内的容器使用网络的，容器数据卷使用、直接使用腾讯云的等，通过这些工作大大降低了客户搭建和使用集群的门槛，同时因为和的紧密结合，某些性能如网络会比自己搭建等开源软件要好很多。
目前，腾讯云容器服务已经有很多客户在使用，客户在使用腾讯云容器服务的过程中，常见的一个问题是客户应用除了依赖的服务发现外，还有部分应用需要使用客户自己的服务器。针对这种情况，本文先介绍的原理，然后再具体说明添加外部服务器的步骤。后续我们将把这个功能做到产品中来，支持客户通过控制台来添加外部服务器。
介绍
为什么需要服务
给每个服务都分配了，通过可以访问和该服务关联的，应用无需关心的实例个数，会自动做负载均衡。如果一个服务要访问另外一个服务，如何知道另外一个服务对应的呢？
目前有两种方式：

通过环境变量，每个启动的时候，会把所有的服务以环境变量的形式注入到对应的容器，在容器中可以通过环境变量获取到对应服务的，这种做法带来的缺点就是容器只能获取到比它早启动的服务。

通过内置的服务，服务之间通过服务名称访问，这个服务在里面的名字为，位于的命名空间。启动的时候通过 参数指定的，这样后续创建的都会在对应容器的文件中生成一条指向 的记录，从而保证所有创建的容器，服务器都使用。


服务组成
服务对应的包含个容器：

：监控服务资源并更新记录
：提供缓存，缓存中的数据通过查询获取
：定期检查和的健康状态，并提供服务是否健康的的

这三个容器的之间的关系如下：

添加外部服务器的操作原理
添加外部服务器的原理是利用的启动参数，在的启动参数中，有个叫的参数，通过参数可以指定上游的服务器，在的 文件中，容器将容器作为其上游服务器，这个关系也是通过参数指定的，下面的文件中，容器绑定的端口为，容器通过=指向。同样的方法也可以用于添加外部服务器，只需修改服务中的启动参数即可。

  
    =
    =
    =
    =
    
    
   
     
      
      
     
      
      
     
      
      
 
   =
   
  默认的域名解析服务器使用上面的容器，因为在一个里所以直接用的地址，容器的端口为
   =
  域名以结尾的使用作为域名解析服务器
   =
   =
   
添加外部的操作原理
的启动参数除了参数外，还有一个的参数，通过该参数可以添加和的映射关系，类似于 的参数，的效果是在容器的插入和的记录，在中没有这样的参数，如果碰到客户要在中加入和主机名的映射关系，用的参数可以实现该功能。
在腾讯云容器服务上添加自定义服务器操作步骤
、先登录到一台容器主机，将的文件保存下来
         
、修改文件，找到的镜像位置，在其启动参数中做修改原来的参数如下：
 
      =
      
      =
      =
如果这个时候要添加个外部的服务器，对应的文件修改如下，修改内容就是加了两个的启动参数
 
      =
      
      =
      =
      =
      =
如果这时需要添加主机名和的对应关系，可以通过添加参数实现：
 
      =
      
      =
      =
      =
      =
、使用修改后的文件执行 使配置生效
   
、验证添加的自定义服务器是否在容器里生效，验证方法有很多种，可以通过在服务里使用或命令来看；也可以直接通过某个依赖于该自定义的应用服务来验证。近日，在数据中心联盟组织的第五批大数据产品评测中， 腾讯云大数据平台取得了两项第一名，特别在性能上有非常亮眼的表现，其他各项成绩也名列前茅。本月日，中国通信标准化协会常务副秘书长、数据中心联盟理事长代晓慧在“大数据发展促进委员会年年会暨成果发布会”上，为包括腾讯云在内的通过测试的企业颁发了证书。

在本次数促会年会上，数据会办公室主任姜春宇对第五批大数据产品评测结果进行了通报，详细的解读了评测的方法和结果。大数据产品能力评测由数据中心联盟组织，并委托中国信息通信研究院实施测试，是国内起步最早、覆盖最广、技术水平最高、影响最大的大数据评测体系，圈定了国内大数据产品厂商第一梯队，为政府和行业用户选购大数据产品提供权威参考，可以方便政府和企业选购大数据产品。
大会中，腾讯云大数据资深架构师于涛进行了主题演讲，对腾讯云大数据与的硬件与技术实力、产品布局、未来发展等做了全面的介绍，同数据中心联盟的各成员进行了深入的交流。

腾讯云的大数据产品能力源自、空间、微信等海量业务的积淀。
截至年底，腾讯、空间、微信等全面产品线及亿万级数据资产背后，有着万亿条数据接入、亿次数据分发、的存储、的离线计算、万亿的实时计算、万次任务调度等亿万级的数据处理经验和能力，这些都是腾讯云大数据产品的坚固基石。
而从年第一个内部大数据集群上线以来，腾讯云大数据产品经过了多次迭代，进行多项腾讯社区组件的优化和自研组件的配置。用户可以按需部署大数据处理服务，实现数据处理需求，例如报表展示、报表分析、数据呈现、数据挖掘、数据分析等全面的大数据应用。
纵横数智，助画方略。腾讯云数智方略包含大数据平台、智能推荐、数字营销、数据可视化等产品，为企业及开发者提供完整的大数据解决方案，开源易用、多环境部署、安全合规、丰富的运维实践经验助力大数据解决方案在各行各业的开发与应用。
更多详情移步官网：二维码现在是大街小巷的标配设计，只要用手机扫一下就能快速的进入相应的页面，可以跳转到相应页面，或是查看名片、付款、收红包等等。本文依据二维码的生成原理，用艺术图标替代枯燥的黑白二维码，赋予二维码艺术性和鲜活的个性。
一 二维码原理
二维码   是用某种特定的几何图形按一定规律在平面二维方向上分布的黑白相间的图形记录数据符号信息的。二维码的优点：二维码存储的数据量更大；可以包含数字、字符，及中文文本等混合内容；有一定的容错性在部分损坏以后可以正常读取；空间利用率高。
如下图所示：

  二维码  
是被广泛使用的一种二维码，解码速度快。它可以存储多种类型。如下图是一个的基本结构

其中：位置探测图形、位置探测图形分隔符、定位图形：用于对二维码的定位，对每个码来说，位置都是固定存在的，只是大小规格会有所差异；校正图形：规格确定，校正图形的数量和位置也就确定了；格式信息：表示改二维码的纠错级别，分为、、、；版本信息：即二维码的规格，码符号共有种规格的矩阵一般为黑白色，从版本，到版本，每一版本符号比前一版本 每边增加个模块。数据和纠错码字：实际保存的二维码信息，和纠错码字用于修正二维码损坏带来的错误。
 艺术二维码 
依据二维码的结构特性，加入丰富生动的图案，提升其美观性。其原理就是针对黑白二维码中的黑色码元，用色彩绚丽的图案进行替换。

二 艺术二维码生成方法
 生成二维码的原始数据矩阵。
有很多开源的库工具可以直接用来生成二维码的，比如应用较广泛的提供的库。

代码如下：
     {
          = 
          {
            配置参数
               =   
            _ 
            容错级别
            _ 
            设置空白边距的宽度
                
             图像数据转换，使用了矩阵转换
             {
                 =   _   
            }    {
                
            }
        }
         = {
             = 
             
        }  {
                  
        }
    }
格式化，找出其中所有码元点，和符合特定矩形形状的码元集合。
按照二维码的原则，在中，先找出左、右、下等个回字形定位符；然后遍历在，找出所有的码元点，再从码元点中找出特定矩形框也即实际需求对二维码中要替换成特定图标的矩形框，比如等。

     格式化，找出其中所有的码元点   
        {
          = 
          = 
          = 
          ==   _ {
             = 
             = 
              _ _
              _   _
               _ _ 
            遍历，得出所有的码元
               =      {
                  =  列
                 _ =  
                先列遍历，再行遍历
                   =      {
                    查看此是否为有信息的码元点
                      =  
                      =   
                      {
                          = 
                          
                                  
                                   {不属于定位符的点
                            以列优先的顺序存放，故需要把下标的行列反过来，便于后续的按列顺序查找
                              =   
                            存储该码元在可用码元矩阵中的列行坐标
                             
                            
                        }  {
                            _
                        }
                    } 
                }
                 
                _  
                 _
            }            
        }
         
    }
 =   _   这句是用链接来生成的，其中要传入需要生成矩阵的宽和高，经过对比，发现这里可以取巧，设置宽和高为，这样生成的矩阵最小保证码元点信息无遗漏，每个码元点的宽度为个单位，后续可以省去再去查找定位符以及计算码元点宽度的步骤。
     查找出所有符合规则的形状  
       {
        遍历形状集查找出所有的矩形框，将其中的码元点标记为已发现，并添加到中
           =      {
              = 
             =  =  = {
                
            }
        }
        将已标记的码元点从中移除
          = 
           =   =   {
            每次只删一条，保证下标始终处于范围内
              = 
              = 
             = {
                    
                
            }
        }
    }
绘制图形。
依据前面两步对的操作，将找出的定位符用符合定位符特征的图片绘制到画布上，再将各个特定矩形框也以相应的宽高尺寸绘制到画布，然后将单个的码元点以简单的图标绘制上去，最后还可以利用二维码的容错机制，在画布的中央小块位置画上个性化的头像。
     绘制艺术二维码的图像  
            {
        商  
          = 
        余数  
          = 
          = 
          {调整初始图片的宽度，凑整，为了每个码元点占用整数个像素点
            
             = 
        }
          = 
          {
            
             生成二维码图片的格式，使用_
             =   _
              =  
              =  
            先画原图
               
            再画
              
        }
          {再将图像压缩至目标宽高
             =    
        }
         
    }
     在画布上绘出所有的矩形框和码元点  
              {
         按照二维码的算法，在上逐个绘制二维码的码元点
          = 
          =  ___
          =  _ _ 
        先画个定位符
           
           
           
          再画所有找到的特殊矩形框
            = 
            =
             =      {
                = 为此集合中相同的
                = 
                = 
                =  
              =    
                = =    
                 =
              对同一种矩形框，查出所有实例并绘制
                 =      {
                    = 
                   = {
                         
                }
            }
        }
          再画剩下的单个的码元
          = 
          =  ___
          =    
           =      {
               =
              = 
             = {
                   
            }
        }
    }
至此，二维码图片就已经生成了。
三 总结
利用二维码的结构特性，将其中连成片的特殊形状用个性化的图片代替，可以使二维码更加美观和生动。
在手中，用此方法，实际可用生成面对面红包、付款码等二维码图形。
附：试用手扫一扫，有惊喜哦！程序员的时间很宝贵，这门语言虽然足够简单、优雅，但并不是说你使用编程，效率就一定会高。要想节省时间、提高效率，还是需要注意很多地方的。
今天就与大家分享资深程序员总结的点建议，帮助大家大幅节省开发时间。
 不使用分号
使用分号在  中是可选的：与其他面向对象语言不同，你不需要在每一条语句后面使用分号。
这看起来很简单，似乎也节省不了多少时间；但一旦你的代码量扩展到数千号，这些分号就变得分心且没有必要键入。
 使用称手的代码编辑器
选择一个称手的代码编辑器可以节省大量的时间。面对这么多代码编辑器，很多新手都会感觉很迷茫。
习惯一个编辑器再使用其他编辑器会觉得很混乱，所以选一个称手的是一个好的起点。不管你选择哪一个，要实时支持 和 。
参考链接：

与真乃天作之合
：最好的编辑器

 遵循  代码规范

遵循  代码规范可以提升代码的可读性，从而节省评审代码的时间。
参考链接：

开发团队的内部编码风格指南。
开发指南：最佳实践

 使用  函数
 的  是随手可用的内置函数可以节约很多时间，比如查找其他函数的解释。你可以在解释器终端直接运行该函数。 文档有更多该函数的用法。
 善用第三方库

 有大量的第三方库可以让你不必每次都重复造轮子。比如，你可以从 包索引选择大量可用的包，这是一个软件仓库。
 是一个很好例子，它使图像处理任务如模糊，增强对比度，缩放只需要一些函数调用就可以完成。
参考链接：

年十大流行的库
年十大流行的库

 使用

 是一命令行工具，可以帮助你从工程模板创建  工程，这可以节省大量的时间。
 严格的注释

养成写注释的好习惯，可以节省你和其他人的时间，尤其是作调试跟踪。
注释在团队合作是非常关键，尤其是一个做了大量变更。
 经常测试
尝试测试你程序中的每一个组件。听起来好像有点费时，但长时间运行可以节省大量时间，帮助你发现隐藏的 ，让你对代码更放心，还强制你理解自己的每一片代码在真实情况下是如何地运行。
 是一个  ，一个常用的代码测试工具，很多高手都会使用它。
 专注和专业

建议要有一个专注领域和专长。你可以使用  做很多事情，从编写网页到处理计算和算法。 
已经有大量的库可以帮助完成这些任务，如 ，计算机视觉处理；，是一个生物计算库； ，是一个数学符号计算库。
深入类似这些的领域，并掌握一个特定的框架，帮助你在更深的层次学习 ，掌握一个特定的代码风格，处理特定类型的问题。
 每天编码
当你养成了每天写  代码，使用  解决问题的习惯，你就会开始用  思考，可以这么说，这将最终会帮助你更快的解决问题。
原文链接：译文链接：产生跨域问题的原因
跨域问题是浏览器同源策略限制，当前域名的只能读取同域下的窗口属性。
跨域问题产生的场景
当要在在页面中使用获取其他网站的数据时，就会产生跨域问题，比如在网站中使用请求其他网站的天气、快递或者其他数据接口时以及 中请求数据，浏览器就会提示以下错误。这种场景下就要解决的跨域问题。
   你请求的域名           当前页的域名     哪些情况会产生跨域问题一个网站的网址组成包括协议名，子域名，主域名，端口号。比如  ，其中是协议名，是子域名，是主域名，端口号是，当在在页面中从一个请求数据时，如果这个的协议名、子域名、主域名、端口号任意一个有一个不同，就会产生跨域问题。即使是在  页面请求  也会有跨域问题
解决跨域问题
有很多种方法，大体上分前台解决方案和后台解决方案。前台可以设置的为注意， = 现在介绍后台的解决方案，特别简单。其他的，也有自己的解决方案，网上一搜一箩筐，不过，由于没有时间去尝试，需要你自己甄别了。下面仅仅介绍的解决方案。
 安装
  

如果报上面的问题，说明站点不可用
再上述命令后，加上     即可。
这是我选取的一个可用的站点。
设置
增加
_ = 
设置中间键
_ = 
增加前三个。注意，一定要在之前。
不用重启，就实时生效了。支持热加载。大约在六月底，在微信全量上线了一个补丁版本，随即华为反馈在 上微信无法启动。冷汗冒一地， 又搞了什么东东？为什么与 保持一致的补丁方式也跪了？  ，   。趁着台风妮妲肆虐广东，终于有时间总结一把。在此非常感谢华为工程师谢小灵与胡海亮的帮助，事实上微信与各大厂商都保持着非常紧密的联系。
无法启动的原因
我们遵循从问题出发的思路，针对华为提供的日志，我们看到微信在 上启动时会报。可以从看到，的确跟补丁是有关系的。
 
   
 
   
 
   
  
但是在我们手上 却无法复现，同时跟华为的进一步沟通中，他们也明确只有一少部分的用户会出现问题。这就很难办了，但是根据之前在地址错乱的经验似乎这里我还欠大家一篇分析文章，跟这里似乎有点相似。
但是已经做了全量替换，所以我怀疑由于 的某种机制这里只有部分用了补丁中的类，但是部分类导致使用了原来的中的。接下来就跟着我一起去研究 在编译运行究竟做了什么改变吧
 的混合编译运行模式
网上关于 混合编译的文章并不多，上有一篇翻译文章： 混合使用编译，解释和三种运行时。混合编译运行主要指编译，解释执行与编译，它主要解决的问题有以下几个：
、应用安装时间过长；在之前，应用在安装时需要对所有做机器码编译，类似微信这种比较大型的可能会耗时数分钟。但是往往我们只会使用一个应用的功能，剩下的我们付出了时间成本，却没带来太大的收益。
、降低占空间；同样全量编译机器码，的编译结果往往可以达到之多。只编译用户用到或常用的功能，这对于存储空间不足的设备尤其重要。
、提升系统与应用性能；减少了全量编译，降低了系统的耗电。在的基础上，每个应用增加了这块后面会详细解析 通过预加载与缓存提升应用性能。
、快速的系统升级；以往厂商时，需要对安装的所有应用做全量的编译，这耗时非常久。事实上，同样只有的应用是我们经常使用的，给不常用的应用，不常用的功能付出的这些成本是不值得的。
 为了解决这些问题，通过管理解释，与三种模式，以达到一种运行效率、内存与耗电的折中。简单来说，在应用运行时分析运行过的代码以及“热代码”，并将配置存储下来。在设备空闲与充电时，仅仅编译这份配置中的“热代码”。我们先来看看 上有哪些编译方法：
 的编译模式
在_，我们可以看到一共有种编译模式：
  {   
                        
                 
                      
                 
                          
                  
                      
                      
                  
                      
                
                    
}
以上种编译模式按照排列次序逐渐增强，那系统默认采用了哪些编译模式呢？我们可以在在手机上执行 |  查看
 
 
 
 
 
 
 
 
 
其中有几个我们是特别关心的，
、应用安装与应用首次启动使用的是，即只，代码解释执行即不编译任何的机器码，它的性能与时完全一致，先让用户愉快的玩耍起来。
、系统升级与后台编译使用的是，即只根据“热代码”的配置来编译。这也是中混合编译的核心模式。
、对于动态加载的代码，即，它采用的是模式，即最大限度的编译机器码，它的表现与之前的编译一致。
总的来说，程序使用动态加载的代码是无法享受混合编译带来的好处，我们应当尽量采用方式来符合的规范。这不仅在还是混合编译上，都会带来很大的提升。
 的文件
在讲是怎样编译之前，这里先简单描述一下文件。相关的核心代码都在中。简单来说，_会开启线程去专门收集已经的类与函数，达到一定条件即会持久化存储在文件夹中。具体的条件可以在__中查看，在收集过程会出现类似以下的日志：
    
         = _=
          
的存储格式在__中定义，我们也可以通过命令查看文件中的数据，命令如下：
 = 
具体输出如下：
===  ===


 
 
其中代表的位置，这里代表的是中的第一个。其他会使用类似方式命名。后面的与代表的是它们在格式中的，只有这些类与方法是我们需要在模式中需要编译。
 的编译
在这里我们比较关心系统究竟是什么时候会去对应用做类似增量的编译，还有具体的编译流程是怎么样的？
编译的时机
首先我们来看系统在什么时候会对各个应用做这种渐进式编译呢？手机在充电＋空闲＋四个小时间隔等多个条件下，通过中的下触发编译优化。
 __ 
           
           
           
           
编译的流程
对于模式，编译命令的核心参数如下：
 = = = =
 = 
入口文件位于中，在这里并不想贴具体的调用函数，简单的描述一下流程：若参数中有输入文件，会读取中的数据。与以往不同的是，这里不仅会根据文件来生成文件，同时还会生成称为_的文件。与类似，文件主要为了加快应用的对“热代码”的加载与缓存。
我们可以通过命令来看到文件的内容，具体命令如下：
 = =  =  =
我们可以到文件中的所有信息，这里我只将它的头部信息输出如下：
  
  
  
   = =
   = =
   = =
   = =
   = =
   = =
   = =
   = =
   = =
文件主要记录已经编译好的类的具体信息以及函数在文件的位置，一个的输出格式如下：
   
    __     
    __  
      
        
      
        
      
      
        
      
        
      
      
      
      
        
      
        
      
      
      
      
      
      
      
         
        
      
        
的输出格式如下：
    
  
  = = =
    
  
  = = =  
    
  
  = = =
那么我们就剩下最后一个问题， 文件是什么时候被加载，并且为什么它会影响热补丁的机制？
 文件的加载
在启动时我们需要加载应用的文件以及可能存在的 文件，它的大致流程如下：
、通过加载时，若 存在，则通过调用函数加载；
、在加载 文件时，通过函数，将文件中的_中的所有插入到，同时将更新到_
、在类加载时，使用时  会先从 中去查找，找不到时才会走到 中。
非常简单的说， 的作用是记录已经编译好的“热代码”，并且在启动时一次性把它们加载到缓存。预先加载代替用时查找以提升应用的性能，到这里我们终于明白为什么会影响热补丁的机制。
无论是使用插入还是 的方式，若补丁修改的已经存在与 ，它们都是无法通过热补丁更新的。它们在启动时已经加入到的中，系统在查找类时会直接使用中的。
 为什么没有影响
对于 来说，它的目标是快速。从上面的编译条件看来，它是不太可能可以触发编译的。事实上，它在上面传入了—参数， 不过并没有单独处理这个参数。感兴趣的同学，可以再详细研究这一块。
最后我们再来总结一下 混合编译运行的整个流程，它就像一个小型生态系统那样和谐。

 上热补丁的出路
假设文件在补丁前已经存在，这里存在三种情况：
、补丁修改的类都不 中；这种情况是最理想的，此时补丁机制依然有效；
、补丁修改的类部分在 中；这种情况我们只能更新一部分的类，此时是最危险的。一部分类是新的，一部分类是旧的，可能会出现地址错乱而出现；
、补丁修改的类全部在 中；这种情况只是造成补丁不生效，并不会因此造成。如何解决这个问题呢？下面根据当时我的一些思路分别说明：
插桩？
当时第一反应想到是通过插桩是否能阻止类被编译到 中，从而规避了这个问题。事实上，在生成时，使用的是函数，插桩并没有任何作用。
我这边也专门单独看了插桩后编译的机器码，仅仅是通过模式跳回虚拟机查找而已。
 
     
                               | 
                  
     
方案
假设我们实现一个最小化的这部分代码我们补丁时是不会去改变。然后其他代码都通过动态方式加载，这套方案的确是可行的，但是并不会被采用，因为它会带来以下几个代价：
、对 之前，由于不使用方式，带来首次加载过慢甚至黑屏的问题；、对于 ，不仅存在第一点问题，同时将混合编译的好处完全废掉了因为动态加载的代码是相当于完全编译的；
在微信中，补丁方案的原则应该是不能影响运行时的性能，所以这套方案也是不可取的。
运行时替换方案
事实上， 中的是插入到中的中。假设我们完全废弃掉，而采用一个新建来加载后续的所有类，即可达到将无用化的效果。
需要注意的问题是我们的类是一定会通过加载的，所以我们需要将类与我们的逻辑解耦，这里方式有两种：
、采用类似 的实现；在代理中，反射替换真正的。这种方式的优点在于接入容易，但是这种方式无法保证兼容性，特别在反射失败的情况，是无法回退的。
、采用代理实现的方法；即的所有实现都会被代理到其他类，类不会再被使用到。这种方式没有兼容性的问题，但是会带来一定的接入成本。
我想说明的是许多号称毫无兼容性问题的反射框架，在微信 数亿用户面前往往都是经不起考验的。这也是为什么我们尽管采用增加接入成本方式也不愿意再多的使用反射的原因。总的来说，这种方式不会影响没有补丁时的性能，但在加载补丁后，由于废弃了 带来一定的性能损耗。具体数据如下：

事实上，在 上我们不会出现完整编译一个应用的与的情况。的作用是加快类与方法的第一次查找速度，所以在启动时这个数据是影响最大的。在这种情况，废弃大约带来左右的性能损耗。在其他情况下，这个数字应该是远远小于这个数字。
的后续计划
在 上，全量合成方案带来了一个较为严重的问题。即将 的混合编译退化了，因为动态编译的代码采用的是方式完整编译，它会占用比较多空间。所以未来我们计划根据平台区分合成的方式，在平台我们合成一个完整的，但在平台只合成需要的类，它的规则如下：
、修改跟新增的；、若有，或数量变化，它们所有的子类；、若有，或数量变化，它们以及它们所有子类的调用类。如果采用方式，即需要多个一起处理。
规则看起来很复杂，同一个文件，根据不同平台合成不同文件看起来也很复杂。更困难的是，格式是存在大量的互相引用，除了区域，还有使用绝对地址引用的区域，大量的变长结构，字节对齐……
所以最终期望的结构图应该如下，在上面仅仅合成即可：

结语
尽管当前还没有开启内测，我们会尽力在开源前做的更好。让无论在还是上，都有着最好的表现，同时也恳请大家继续耐心等候我们。引言
作为腾讯规模最大的  数据库服务， 在腾讯云上也是最受欢迎的关系型数据库产品。 不仅具备备份回档、监控、快速扩容等数据库运维的全套解决方案，而且拥有深度定制的内核版本  ，简称。内核版本拥有更高的性能、更强的稳定性，同时提供   企业级版本才拥有的特性，对内支持集团内部业务的发展，对外提供强有力的竟争力，助力腾讯云的快速奔跑。在腾讯云的发展过程中，为其保驾护航，积极的推动了腾讯云的快速发展。

  自从年月份正式立项，在近两年的时间里对  的读写性能、强同步、大并发量访问和稳定性等方面做了大量工作，读写性能在并发上升到一定程度时具有倍以上的性能提升，同时在  的版本发展过程中修复了多个影响线上稳定性的 如  死锁，实例异常关闭、字符集引起的主备异常等，在保证了内核稳定的同时，对腾讯云的稳定性提供了有力的保障。  不仅提升了实例性能与稳定性，而且在发展的过程中积极和社区进行交流，在  等社区发表了多篇具有影响力的文章，并作为演讲嘉宾，多次参与 、、、开源中国和  全球架构师峰会等社区会议，大大提升了腾讯云在业界的影响力，赢得了客户的信任与口碑。
什么是 ，为什么要做  
 是   的简称，是  基础架构部   团队在近十年发展过程中衍生出来的一个对  内核源码深度定制、对官方  版本进行二次开发的项目。其主要目的是在保证线上稳定性的同时，满足业务对数据库的各种需求。 的服务对象是公司内部用户和腾讯云上小至数大至数百的外部客户。 是支撑这些业务平稳运行的关键基石，在服务用户的同时，以打造腾讯自己的分支为己任。
 作为最受欢迎的开源数据库，也是云上使用最多的数据库，不同的业务场景对数据库有不同的功能需求与性能需求，这样就决定了数据库本身的多样化需求，同时  在不同使用场景下所衍生出来的各种问题，也影响着线上的稳定性， 主要包括以下工作：
数据库性能调优；对内核进行深度改造，满足应用需要的性能要求，在活动促销时需要保证数据库的平稳；提供业务需要的各种功能需求；实现资源管理需要内核支持的功能；  在运维过程中需要的诊断相关的功能； 在运行过程中存在的问题定位并修复影响系统运行的  ；保证数据库系统的安全，保证云上用户数据的安全；作为云上客户的服务者，我们必须有及时响应用户并解决各种问题的能力，也应该满足用户的各种合理要求，对内支持业务的快速发展，满足业务要求；对外为腾讯云提供强有力的竟争力，这就是  存在与发展的目的。
 做了哪些事情
版本选择
 版本，其基准开发版本为 ， 选择  做为基准版本主要有以下原因：
 是当时大版本  中的最新版本，自     以来，版本已经相当稳定； 版本刚刚 ， 但从官方  上来看有相当多的  ，因此未被采用，在现在看来选择  也是正确的，因为从  版本的   来看，除了   是新加入的功能，其它内容基本是  相关；虽然  存在着各种问题，但其新添加的功能  卓越的性能都会是未来  年的主流选择，我们也计划在今年对  进行支持，并且会对  新添加的功能  性能改进进行详细的源码级别的介绍。 版本是接受程度最高的  版本，也是用户使用最多的数据库版本；综合以上原因，我们选择了  做为  开发的基准版本。
性能改进
  优化
  又称读视图，用于存储事务创建时的活跃事务集合。当事务创建时，线程会对 _ 上全局锁，然后遍历当前活跃事务列表，将当前活跃事务的存储在数组中的同时，记录最大事务 __ 　最小事务 __  最小序列化事务 __。 当事务执行时，凡是大于__ 的数据对于事务是不可见的，凡是事务小于 __ 的数据都是可见的，事务  是 _ 数组中的某一个时也是不可见的；  在执行  操作时，凡是小于 __ 的数据，都是可以被  的，  是   实现的基础；
由于_ 的创建和销毁都需要获取 _ 当并发量很大的时候，事务链表会比较长，又由于遍历本身也是一个费时的工作，所以此处便成为了性能瓶颈，详情可以参考 ，为了解决这个问题  做了以下事情：

在 _下维护一个全局的事务的有序集合，事务的 创建  销毁 的同时将事务的  从这个集合中移除；在 _下维护一个有序的已分配序列号的事务列表，已记录拥有最小序列号的事务，供  时使用；减少不必要的内存分配，为每一个 _ 缓存一个 _，_ 数组的大小根据创建时的活跃全局事务  集合做必要的调整；参照  的实现，在  中将 __ 移除，减少只读视图的长度；

经过上述修改，读写性能都有很大的提升，详情可以参考文章 畅游数据库性能优化过程简析。
   
 有两种很重要的 ，分别为    ，前者是保证事务原子性操作所产生的日志，后者是主备数据同步所产生的同步日志。 其中  在 _ 时进行   而   则是在事务提交的时候分别调用 _ 使   落地，导致 _ 竟争较为严重；从   的逻辑来看，只要   早于  落地，就不会有数据问题，因此在 _ 的第一阶段时， 会收集各种引擎的最大的   ，然后将小于该  的   落盘，从而提升写性能。更详细的分析与测试，可以参考 。
  双缓冲区
   是一个顺序写的单缓冲区，_ 锁资源竟争激烈，在事务落盘的过程中对  相关的读、写都被阻塞，为了解决 _ 的锁竟争问题，引入双缓冲区机制  _ 锁，在    的过程中释放 _，继续持有 __，从而阻塞写，不阻塞  相关的读操作， 完成后释放 _；从而提升并发性，提升性能。
   锁拆分
 一次定位  的过程是从根结点到叶子结点的路径，时间复杂度为：    ，上述的两个优化过程无法省略定位  的中间结点，因此需要引入一种可以从   定位到叶子结点的方法，从而省略根结点到叶子结点的路径上所消耗的时间，而这种方法即是 自适应索引   。查询语句使用  的时候有以下优点：

可以直接通过从查询条件直接定位到叶子结点，减少一次定位所需要的时间；在   不足的情况下，可以只针对热点数据页建立缓存，从而避免数据页频繁的 ；

 的 __     是  中两个比较大的锁，详情可以参考      –     ， 通过对  锁拆分     以及引入不同的索引锁协议  解决了这两个问题。但是  并不总能提升性能，在多表  模糊查询  查询条件经常变化的情况下，此时系统监控  使用的资源大于上述的好处时，不仅不能发挥  的优点，还会为系统带来额外的  消耗，此时需要将  关闭来避免不必要的系统资源浪费，关于  的适应场景可以参考：____。
 则是和  的解决思路类似，只是使用的分区算法不同，关于自适应索引的详细说明可以参考：  实现解析。
当然，以上这些只是我们所做优化的一部分，还有其它一些优化如  优化、强同步优化、针对业务所做的特殊优化等，这些优化都在线上发挥了不可小觑的作用，以后再以文章的方式一一给大家进行介绍。
功能添加
 支持多种工作模式
 根据配置的不同，支持不同的工作模式，分别为只读、读写、不可服务，在不同的模式下实例表现形式不同：
只读模式：实例只接受读请求，不接受非管理用户的写请求操作；读写模式：实例可以接受读写请求，但系统管理的相关权限被禁用；不可服务模式：此模式下， 正常运行但不接受除管理账号以外的其它操作； 在实现跨园区容灾的时候会根据结点的角色设置不同的工作模式，从而避免双写的问题；
  …  功能
 在执行过程中需要获取对应的表锁，然后进行操作，如果此时有事务获取表锁，则会造成此语句的阻塞，而后绪操作此表的请求也会被此  阻塞，因此我们引入了  中的   超时失败的功能，即   …  |    的功能以降低  对线上的影响， 中    |   则可以通过设置参数 ___ 来实现；
 锁系统的扩展
 锁系统有两个特征：
 中的锁与连接强依赖，在连接断开之后便会释放其占有的锁资源，包括  层   层的所有锁资源；
用户线程获取锁之后，如果没有显示释放锁资源，连接没有断开亦或事物没有提交，则会一直占有锁资源；
 对 的锁系统进行了扩展，实现了一种跨事务的、与连接无关的租约读写锁，用于应用层实现分布式事务，提供接口 _ _ 用于上锁与解锁请求，从而满足业务需求，详细接口介绍如下：
 _    _ _ _ _
  多用户对同一个锁对象加锁，会在加锁超时前等待。直到获取到锁或者超时返回。
  锁类型目前支持两种，共享锁和排它锁。共享锁是读锁，允许多个客户端对锁加共享锁。排它锁是写锁，同一时刻只允许一个请求占有排它锁，其他请求需要等待锁释放。排它锁比共享锁有更高优先级，防止过多的共享锁等待情况下，排它锁长时间无法获取。
  同一个锁持有者对同一锁发起多次加锁，会认为重复加锁，相同锁发起者同一时刻只能对同一锁成功发起一次。
  获取的锁，不会因为连接断开而释放。锁持有时间是有指定的，超过持有时间以后锁会自动释放。 _ 
  主动锁释放。会对指定锁的持有者释放锁，只有在锁持有情况下才会成功。
基于  的强同步
原生  存在着以下问题：
 在时间超过 ____ 会退化为异步采用  进行监听，当句柄值大于  时则会出现异常，详情可参考 在   后等待  容易出现幻读的问题；…为了解决上面的问题并对强同步进行优化及显示状态信息， 做了以下事情：
优化半同步，增加线程，收发并行化；修正时超过导致异常的，改为；优化线程判断自身是否为半同步的方法：在线程自身变量上记录；在半同步基础上实现强同步，一直住直到收到；修改同步方式时，唤醒正在等待的用户线程，继续等待或者退出；增加一些状态，用于展示当前等待的情况正在等待的位点，已等待时间；这些只是我们暂时做的，在以后的版本中，我们将会引入  、更完善的审记、防火墙等内部用户  外部云用户都需要的功能，随着时间的积累与版本的推移，的功能将会越来越丰富。
稳定性改进与测试
稳定性是数据库服务首先要解决的问题，原生  在稳定性方面存在着以下问题：
在压力持续增大的过程时，会存在着内存分配的问题，原生  在内存分配的过程中会调用 _____，在并发量加大且线程数量变化较大时，内存分配会造成系统性能的抖动，详情可以参考：        ，       
随着并发的加大，由于原生  没有流量控制或者  层线程调度的功能，导致线程之间资源争夺比较剧烈，直接导致  性能的不稳定，性能曲线先升后降；   刷脏算法在   类型时，很容易成为瓶颈；主备同步时备库性能过低导致的延迟问题等； 各个版本在实现的过程中存在的  如   死锁 典型的字符集问题、   等… 在服务业务的过程中不断的自我完善和发展，解决在发展过程中遇到的各种问题，如：
解决在线上遇到的各种 内核引入  解决内存分配的效率问题；对复制线程进行改进，减缓主备延迟；引入   在  层进行线程高度，从而避免过多资源浪费在资源争夺等内测中…；实现  需要的功能，结合  实现强一致功能等；…为了保证版本稳定性， 对每一个  都有对应的  文件和覆盖率测试，对于比较重要的改动，不仅要有理有据，还会邀请  官方人员进行必要的  ； 每个小版本发布之前，都会进行回归测试、覆盖率测试、稳定性测试、性能测试以及压力测试，然后才会进行灰度发布；当然，对于每一次的版本发布，都有详细的   以供参考。
金融业务支持
数据的可靠性是金融业务必然的需求，由于  自身存在的问题，很难保证数据的强一致性，这些问题包括：
 是典型的两段提交，在  的过程中依赖  是否存在 决定事务的  或 ，对于已经写  的事务，一定会提交事务，这样在主备切换后容易出现双写的问题；当 _____=_ 时，主备切换时存在着幻读问题，当 _____=_，如果用户线程在等待备库  的过程中被  那么其它用户线程可以看到被  线程的提交，此时主备切换，仍然存在着幻读问题；当 _____=_ 时，用户线程在  切换时容易出现死锁问题  详情如下：
                           _                                                 _     
                        
为了解决上述问题并实现主备数据的强一致， 结合  管控平台针对金融业务的需求，实现了以下特性：
为了规避幻读，强同步插件在线程等待  的过程中，禁止用户  线程，同时本地  会通过实例状态变量 _______ 监控是否出现长时间  问题，触发告警和  操作，减少  住对实例的影响；本地  在主库  后，会向  获取故障切换时的  位点信息，并以这个位点启动实例， 将截断多余的 ，并回滚相应事务，与新主库建立主从，确保可以快速补充节点；跨园区高可用的支持。 是常见的  架构：由本地  负责监听  实例，如果实例出现故障，则上报总控节点 ， 选择拥有最多数据的 ，将其提升为 ，并更新接入层的  为新 。在跨园区环境中，如果主库所在园区故障，  时可能无法更新该园区的接入层，而该园区的  依然能够操作原主库，导致出现双写的问题，为了规避网络分区情下的双写问题，实现了租约功能，租约过期的实例将拒绝服务。本地  只有成功向  续租后，才会更新实例的租约，确保实例的租约小于，从而解决双写问题；对主库 _ 进行拆分，解决死锁的同时提升主库写性能；除了数据强一制的支持， 还实现了一套与连接无关的分布式锁来支持业务部门实现分布式事务，后绪随着对业务的深入，更多更好的金融特性将会在  中一 一实现，比如热点更新等；
版本表现
 的首要发展目标是解决线上存在的问题并支持业务的稳健发展，同时在解决问题的过程中推动  自身的发展。
 最近的 个版本，分别为 _、_ 以及 _ 版本，每个版本包含若干 ，每个  的紧迫程度决定其优先级，每一次版本发布都会对新版本的实例做严密的监控，以保证新版本的稳定性。下面我们从版本在线上的表现以及与官方数据的性能对比来对  做简单的介绍。
线上业务表现

_ 引入业界先进思想并  ，成功解决了业务在高并发下的性能下降问题，并支持业务在大压力下的稳定运行，详情可参考之前的文章：畅游数据库性能优化过程简析；_ 版本对   做了必要的优化并对写   的代码 ___ 进行了重构，使写性能得到了一定的提交，在与竟品的性能测试  压力测试 长时间的进行压力测试且数据不能出现抖动 的对比过程中脱颖而出，对  站在腾讯云上的最终落户起到了一定的积极作用；同时通过租约控制  的在线离线模式，规避双写，满足跨园区需求；_ 版本除了必要的优化外， 了影响较为广泛的字符集问题、   问题，使得线上的稳定性得到提升；…

 与官方性能测试对比
_ 版本目前处于开发状态，所以我们选取了 _ 版本与  的基准版本  、  的最新版本  以及   的最新版本  做了性能对比，测试机器为  测试详情如下：
测试说明
测试概况：测试结果为  端统计出来的数据，其中   _ 为单语句事务，  中包含 个语句，配置文件为：，测试数据为 个表，每张表 条数据；
 与各版本  性能对比

 与各版本 _ 性能对比

 与各版本  性能对比

从测试的过程与测试结果来看， 不仅拥有更好的性能，还拥有更好的稳定性，在新的  不断实现的基础上，我们对  的表现拥有更多的期待。
关于  
  自  以来已经有年有余，社区  用户的呼声也越来越高， 会在今年上半年增加对  的支持，同时会对  的特性进行详细的分析以飨大家，另外在阅读代码  文档的过程中，笔者做了一些整理，希望对大家理解  有帮助；

 中对   的锁拆分，详情可参考：支持强同步的  ，原理可参考：       新的数据格式的支持  更为方便的优化器控制选项  代价计算，详情可参考： ；对独立表空间加密的支持，暂时不支持    的加密，详情可参考：  ；虚拟列  函数索引的支持         功能 调整执行计划出错的利器，但现在有性能问题，详情见 更为详细的系统运行信息监控  …

其实，我们在   中做了很多  的事情，如   优化、  创建优化等，在新的   中，我们会有更多可以做的事情，比如执行计划缓存、比如写优化、再比如基于于   服务等等，我们相信   会是一个不俗的版本。
 未来的发展发向
 的发展只是刚刚起步，相比   等这样的公司我们做的还远远不够，还有很多需要改进的空间，但路总是一步步走出来的，我们的差距也在讯速的缩小，在未来的发展过程中  仍然会以用户为导向从以下方面不断的进行改进：
功能开发，以业务需求为出发点，实现业务所需要的各种功能，如审记、防火墙等；性能优化，在保证稳定性的前提下不断提升单机性能，并根据业务特性有针对性的进行优化，如热点更新、多语句提交等；提高内核的抗风险能力，提升对烂、索引异常、流量异常等异常的防范能力，在不修改应用的前提下，保证系统的稳定运行；兼容并包，不断加强与开源社区的联系，并引入  需要的功能或性能 ，并将有价值的  提交至官方；以线上稳定为基础，不断提升内核能力的同时，实现运维需要的各种功能，方便运维兄弟；所以，大家在使用数据库的过程中如果有好的想法或者需求也可以和我们联系，我们会尽最大的努力来满足大家的需求，支持业务的发展。
最后打个广告，数据库是一个很有吸引力的领域，数据库内核研发和算法、操作系统、文件系统、体系结构等有着很多的联系，如果你对数据库有着浓厚的兴趣、对数据库的原理比较清楚、又有着比较好的  或  的基础，最重要的，你有挑战各种困难的勇气，那么你就是我们要找的人，没有专业限制、没有条条框框，我们将会一起努力，见证  在云上的魅力在公司，像小书匠这样的  编辑器无法进行图床的绑定，因此很多小伙伴都利用了  编辑器将图片转为  格式进行存储，这样就导致了  文件过大。因此，我想到了之前写的一个小软件，可以用腾讯云的  来进行图片的存储，这样就可以随心地将图片存储在腾讯云上了，文章也就很方便的发表了。
附一个  地址：
设计说明
 腾讯云万象优图每个账户提供  的图片存储支持黄图检测； 可以在截图之后，直接点击上传，自动将截图的程序上传到万象优图，不再有复杂的上传操作；也可以主动上传图片。

设计实现
如上图所说，本来想对截图直接生成  编码的字符串，然后使用该字符串利用二进制上传到腾讯云万象优图。但是，现在已有的   不支持二进制文件的上传，因此，这里就对不起观众了。现在采用的方案是：将截图程序生成的截图不需要保存由程序在保存在程序的根目录下的  文件夹下，然后再利用本地文件路径进行上传。
程序下载
我已经将打包好的程序，放在了开源中国的仓库上，下载地址为   点我下载
程序安装
安装过程比较简单，直接一步一步的上图片。
第一步是选择安装路径，不要安装到  盘 的其他目录，因为程序可能获取不到创建文件夹和文件的选项。程序默认的是  路径，这个路径的开放程度比较高。

第二步是提示你要创建桌面快捷方式，最好是选择创建一下快捷方式，不然，不方便你使用啦！

第三步是确认你的创建快捷方式的选项。

第四步选择 ，很快就创建完成了  。

程序使用
程序刚打开的界面如下：

设置自己的万象优图的 __，_ 的信息，这里我默认的配置是我自己的。

关于如何配置自己的万象优图信息，参考下一节内容
使用场景
拖拽的方式，上传图片
这种方式，就是把图片往程序的界面上，拖动

拖拽后，程序会自动加载该图片

点击程序界面下面的 上传拖拽图像，就可以完成上传，并且自动在系统粘贴板上设置  格式的  标签

下面，我将使用  ，粘贴程序生成的  标签

截图的方式，上传图片
首先，使用  截图功能 或者其他截图软件，进行截图，示例就是截的编辑本文档的界面的图片，截图之后，不需要你手动保存的。下面是我截的图片

完成截图之后，回到程序界面，点击程序下面的 上传截图 按钮，

就可以完成上传，并且自动在系统粘贴板上设置  格式的  标签，下面，我将使用  ，粘贴程序生成的  标签

程序的使用就介绍到这里
获取自己的万象优图的信息
首先登陆自己的万象优图
选择立即使用，进行订购页面

选择图片空间

添加图片空间

等待系统进行处理

创建成功之后，查看自己的 _ 和 _如下图箭头和文字注释 

已经有了 _ 和 _，我们还需要 _ 和 _，下图就是获取这两项的示例

有了这四个东西，就可以在程序的 设置 菜单中，将图片的仓库配置成你自己的了的，就可以尽情享受你的  存储空间了。作者：陈俊浩

名词解释
：一种单位，表示每秒报文数。核：本文中说到的核，是指。：实现的核间通讯用的高速环形缓冲区。特性：根据、或者元组信息计算，将报文分发给值对应编号的核的一种网卡特性。结构：用来管理报文的结构体。_结构：内核协议栈用来管理报文的结构体。协议：一种动态路由协议，当前主要用于的容灾功能上。：非统一内存访问的简称，是一种消除访问内存时对前端总线的竞争的架构。物理核：物理上的 。逻辑核：超线程模拟的 。：本文特指 ，而非网络。：柏克莱报文过滤器，一种通过指定的规则快速匹配过滤报文的接口。：自带的一种性能分析工具。
背景
是一套实现多网接入的负载均衡系统，为腾讯业务提供着外网接入服务。随着影响力的提升，越来越多的业务接入，对于的整体负载能力要求也越来越高，性能问题也逐渐成为的痛点。其中，最突出的问题，就是单台机器转发性能只有万，跑不满流量，造成机器资源浪费。另外，一些高、流量大、又无法扩容的集群，要经常在较大压力下运行，也给业务带来不稳定因素。所以，提升单机的转发性能，充分利用、内存与网卡，成为性能优化的关键。
瓶颈
请输入标题     做性能优化，首先要分析瓶颈：
规则表、连接表等都是多核间的共享资源，读写都加锁，容易造成较大。
页面小，当前只有，而的连接池需要占用左右的内存，就容易造成大量的 。
解决方案
做完瓶颈分析，就来思考解决方案：
要消除共享资源加锁，首先想到的方案是无锁化，每个处理报文的核都能自己维护一份资源，尽量减少。
要消除，则可以采用，使用甚至的页面。综上两点，我们选择了基于的开源解决方案来改造，原因如下：实现了多线程多进程报文处理框架，为资源化提供便利。实现了基于的内存池管理，为连接池、规则表等访问优化提供了便利。实现了高效的接口，为报文零拷贝操作提供了便利。实现了网卡队列映射到用户态，可以改造成为应用程序，在用户态处理报文，少走了内核网络协议栈的部分逻辑，降低与内核的耦合。当然，业界也有其他的解决方案，比如，为啥就选择呢？原因主要有点：
仍然采用中断，当高时，中断容易打断本来正在处理报文的工作，影响吞吐；而默认采用轮询，自己判断网卡队列是否有报文了，不打断工作。
仍避免不了使用系统调用，而系统调用时需要切换上下文，势必造成 ，无法发挥极致性能。而都在用户态实现，消除了系统调用的开销。
设计
做设计过程中，我们遇到了各种各样的问题：
使用哪种报文处理模型？
答：使用改造网络转发程序，需要确定每个核负责的工作以及核与核之间的交互，设计好报文处理模型。的程序中，提供了以及两种模型。是指从开始处理报文起，到报文发出去，都是由某个核负责。这种模型让编码变得简单，每个核跑同样的逻辑，可以灵活地做平行扩展。是指将报文处理逻辑拆分成多个段，每个逻辑段跑在独立的核上，当报文跑完一个逻辑段，就通过核间的，将报文丢给另一个核，跑另一个逻辑段。这种模型有利于充分利用 的局部性原理，避免频繁刷新。对于而言，模型无法满足功能需求，因为采用模式，需要解析报文，将外层头部剥离，取出内层地址计算并进行分发，以保证出入方向的报文都可以跑到同一个业务逻辑处理核上。而完全的模型实现起来比较复杂，代码改动量大利用改造之前，更接近模型，容易出，影响稳定性。最终，采用了两者结合的一种模型：

报文分发核，从网卡接收队列收取报文，根据源目标地址计算若是收到报文，则剥离掉外层头部，利用内层地址计算，然后通过，将其分发给对应的业务逻辑处理核。业务逻辑处理核，对报文进行查找规则、连接、封装解封装报文等处理，然后将报文塞入网卡发送队列，发送出去。我们做了以下模拟测试：

根据测试结果，得出以下结论：跨的组合性能最低。纯物理核的组合比物理核跟逻辑核混搭的组合性能高。封装转发的逻辑比较重，可以通过增加核来提高性能。所以，尽量使用同个的物理核，就可以有更高性能。但是，理想总是美好的，现实却是如此残忍。经统计，总共需要使用内存主要是业务逻辑处理用到。主流的机器只有内存，个，假设取其中挂载留左右内存给系统使用，如果采用大小的，则每个最多可以使用内存做了限制，必须均分，那么业务逻辑处理核需要跨。如果采用大小的，可以调整每个使用内存的比例，但是需要配置好策略，增加了与操作系统的耦合，并且概率会相对大一些。权衡利弊，最终选择了大小的，用一些跨导致的性能消耗，换来与操作系统的解耦以及概率的降低。
选择多线程还是多进程？
答：多线程与多进程区别主要是地址空间独立与否。另外，多进程挂了一个进程，还有其他进程可以继续服务；多线程一旦挂了，就全部线程都会退出。是通过协议来实现集群容灾的，一台机器挂了，上联交换机一旦探测到这台机器没有响应，则会将报文发往集群中的其他机器，不会再发往这台挂掉的机器了。如果采用多进程，某个进程挂了，其他进程仍然继续工作，此时上联交换机的探测报文很可能依然可以探测成功活着的进程处理了探测报文，交换机依然会把业务报文发往这台机器。此时，需要将死掉的进程排除在外，不将业务报文给它处理，否则业务报文会丢失。这样，就要再做一层进程间的容灾，增加了系统复杂性，且带来的收益不大。因此，采用了多线程。
采用是轮询报文的方式，会长期，如何确定机器负载以及是否已经到达性能极限了呢？
答：在业务报文处理的路径上，报文分发核跟业务逻辑处理核是主要的参与者。若报文分发核负载高，则网卡接收队列的占用率会随之升高。而业务逻辑处理核负载高，则它与报文分发核之间的占用率也会随之升高。所以，对于机器负载的确定，采用监控网卡接收队列以及两种核之间的的占用率，替代监控占用率。
脱离了内核，需要自己实现学习、动态路由、登录等基础功能吗？
答：没有完全脱离内核，仅仅是让业务报文在用户态程序中处理，非业务报文都采用提供的功能，丢给内核处理。所以，学习、动态路由、登录的非业务报文都会被扔给内核处理。
是什么？
答：是实现的与内核协议栈做报文交互的接口，其中包括一个模块与相应的通讯接口。模块主要做以下两件事：启动一个内核线程，内核线程负责接收从用户态发来的报文，并将其从结构转换成_结构，再调用_来让该报文跑内核协议栈。在内核注册一个虚拟网络接口，若应用程序通过发报文，在内核准备通过虚拟网络接口发出去时，会调用注册的发送函数，报文将被转换成结构，并被丢到与用户态程序通讯的中。工作原理如下图：
 
创建的是虚拟网络接口，那真实的网络接口怎么处理，如、？
答：把、都干掉了，而创建的虚拟网络接口名称就改为、。这样可以保持对一些依赖于网络接口名称的脚本或者程序的兼容性。
会不会影响业务流量统计功能？
答：会！由于业务报文是不走接口的，所以统计的流量已经不准确了。好在提供了获取网卡流量的接口，所以依然可以获取到网卡流量。
怎么实现类似功能？
答：是将过滤条件转换成的规则，下发给内核，内核利用这些规则过滤报文，再将匹配条件的报文上传到用户态。但是，比较复杂，移植到的难度较大，所以采用另一种方案：实现一个工具，该工具将过滤条件传到报文处理模块。然后，该工具再执行，将指定的过滤条件，转换成规则，下发到内核。在报文处理模块这边，从网卡收取到报文后，以及将报文转发出去之前，利用工具传过来的简单过滤条件只匹配、端口、传输层协议，进行匹配。对于符合简单过滤条件的报文，则一份，将结果通过接口，发往内核。这里的，只是申请一个新的结构体，引用原始报文，并不会做内容拷贝。而在封装报文的时候，则会做类似于内核策略的操作。内核协议栈收到报文，根据之前下发的规则，过滤报文，将报文送往用户态，最终由打印出来。
怎么打日志？
答：打日志需要写文件，如果直接在业务逻辑处理核打印日志，那么会影响报文处理。于是，采用了以下方案，解决业务逻辑核打印日志的问题：维护专用的日志内存池，内存池中每个节点，都是一块日志缓冲区。调用日志接口时，会从内存池申请一个节点，日志信息直接写到该节点上，并将该节点塞入中这里的是专门用于传送日志的，与传输报文用的是互相独立的。控制面线程从中读取日志信息，并写入文件。
调优
完成了基于的前期改造，经过测试，的极限性能只有万 ，仅仅比原来版本提高一倍。于是，我们在当前基础上，对进行了调优。
多核扩展
测试发现，当跑到万 时，有大量丢包，丢包原因在于网卡接收队列满了，说明是报文分发核性能不足。当前，采用的是个报文分发核与个业务逻辑处理核的组合，每个网口仅对应着个报文分发核。由此看来，个网口只由个报文分发核来收取分发报文，显然是不够的。根据之前选核测试得出的结论：增加核数，可以提高业务处理性能，我们尝试调整了报文分发核的核数，并做了以下极限性能测试：
根据测试结果，可以得出，个报文分发核与个业务逻辑核的组合是性能最好的，但是，由于机器只有个核，除去、同步、控制面线程独占的核外，只剩个核。如果采用性能最好的方案，则系统只剩下个核用了，整个系统会长期处于高负荷状态。所以，经过评估，我们采用了个报文分发核与个业务逻辑核的组合。既保留给系统足够的资源，又可以提升性能到万 。
新机型
尽管经过多核扩展后，仍然只可以跑到万 。后来，新机型出来了，是  核，内存，网卡。于是，又做了以下极限性能测试：

单核优化
从之前的测试结果来看，有个问题：当业务逻辑核数增加到个之后，成功收取报文数下降了，说明是报文分发核的性能不足了。当业务逻辑核数增加到个之后，成功转发报文数下降了，说明业务逻辑核的性能不足了。那有没有办法继续提高性能呢？根据结果，分析代码，发现有个问题：报文分发核会将一些的自定义数据存在结构的第条 ，该条 并没有提前预取，在写数据时，就引起了。接近极限性能的时候，占用率很高，怀疑是否的内存池太小了当时只有。之前做多核扩展的时候，为了图方便，没有将报文分发核与业务逻辑核之间的两两独立开，而是每个网口对应的报文分发核共享与业务逻辑核数相当的，这样报文分发核对的访问就需要做互斥同步了，也会产生。针对上述的问题，分别做了以下优化：裁减的自定义数据，把没必要的字段去掉，并将其位置改到第条 中。

将内存池大小扩大为。每个报文分发核跟每个业务逻辑核都有一一对应的，保证对的操作只有单写单读。加上上述优化后，极限性能测试结果如下：

从测试结果来看，个报文分发核与个业务逻辑核的组合的性能最高。另外，综合该组合的测试结果看，单核优化前后对比，报文分发核的极限处理性能可以提高万，业务逻辑核的极限处理性能可以提高万。
踩过的坑
开发过程中，我们也遇到一些坑：
诡异的丢包
上线后，我们遇到了一个问题，就是网卡的统计计数中，一项会增加，这意味着报文分发核的性能不足。但是，当时负载不高，出入报文量远远没到达性能极限。刚开始，怀疑是报文分发核之间共享，产生竞争导致的。于是，将每个网口对应的报文分发核数临时改成个，消除报文分发核之间的资源竞争。测试结果发现，现象有所缓解，丢包率峰值从降到。继续排查，通过查看各个线程的运行情况，发现报文分发核的任务被动调度次数较多，并且不定时会有突发。然后，观察任务调度次数突发与报文丢弃的关系，发现一旦出现突发，丢弃的报文数就升上去了。所以，可以确定，报文丢弃给任务被动调度有关系，怀疑是任务被调度出去了，然后报文处理不过来，就给丢了。于是，我们通过尝试设置实时进程的方式来解决这个问题。设置实时进程，提高线程的优先级，避免的线程任务被调度出去。设置实时进程后，报文丢弃的问题确实得到了解决。但是，跑了一段时间后，却发现了一个新的问题：系统上出现了大量状态的进程。查看进入状态的调用栈发现，卡在了_上如下图所示。出现状态进程的原因是被设置为_的实时进程，且其线程是不会主动退出的或者产生主动调度的，而实时进程的优先级本来就大于的优先级，导致内核进程一直得不到调度，进而其他进程的相关操作得不到处理，进入了状态。

由此看来，设置实时进程的方式还是太暴力了，不能采用。网上搜索资料，发现内核参数中断亲和性设置可以实现独占，任务不会被调度出去。马上测试一下，发现报文丢弃现象有所好转，但未完全根治。在另一个机型的机器上测试，却没有发现报文丢弃现象。难道报文丢弃跟机器硬件有关系？查看，发现有这种日志：

观察发现，打印日志的时候，就会出现报文丢弃现象。再次网上搜索资料，发现有人遇过类似的问题，并给出了解决方案：

这个是 不能很好地兼容服务器电源管理特性测试用的机器，恰好就是 ，可以通过设置内核参数=来解决。采用该方案再次测试，已经没有出现报文丢弃现象了。终于完整地解决这个报文丢弃问题了。
下的 
由于使用了接口，若程序直接退出，怕会引用的一些资源没有释放而导致问题。所以在停止之前，加入了___来停止网卡。但是，也由此发现了一个的代码：若网卡采用向量收报文模式，并且开启了____，调用___，则一定概率上会出现 。分析代码，发现原因如下：向量收报文模式下，结构转交给报文分发核处理后，其指针仍然留在网卡接收队列中，并没有清掉。报文转发出去后，结构会被网卡驱动给释放掉。调用了___时，会遍历网卡接收队列，将其中所有结构给释放掉，结果将之前已经转发出去的报文对应的结构再次释放一遍，造成二次释放。开启____时，释放结构的代码中会判断，是否已经释放过了，如果已经释放过，则产生，从而产生 。最终，这个问题报给了的工程师。而我们采用了去掉停止网卡的代码，并关闭____选项的方法来规避解决问题。
落地
优化后的，已经上线了一年多了。从线上机器运行情况来看，优化效果还是相当明显的。以前需要台机器来抗住压力的集群，现在用台就可以了，节省了机器资源，也解决了高负载集群的问题。

文章来自：腾讯架构师作者介绍：翟伟， 个性化业务前端团队 ，曾参与过超级  的和  会员的前端开发工作，目前负责手机  个性装扮的开发工作，拥有近  年的项目架构和实践经验，专注于手机  的  模式下  优化和持续集成方向。

前言
任何技术优化都依托于业务的发展，随着  会员增值业务的重心转移到手  移动端，对  页面不仅要求加载更快，还需承载丰富多彩的运营活动，同时由于每个页面都意味着  收入，任何可能导致页面功能不可用的发布行为都是不可接受的。
本文为  杭州站的分享实录，介绍  会员的前端开发团队在手  的  模式下对  页面的性能优化、组件化和持续集成方面的实践。
正文
首先简单介绍一下自己，作为一名  后老腊肉，呆过若干创业团队； 年加入腾讯超级  团队，负责前端开发工作； 年公司内部组织架构调整加入  会员团队。
随着移动化浪潮的来临， 增值业务的重心从  端  转移到移动端手机 ；作为前端开发，我们的工作内容也转移到基于手机  的  模式下  开发工作。

什么是  会员？ 会员是宇宙第一大包月业务，大部分的会员用户都很年轻。大家可以猜一下哪个年龄段的  会员用户最多？小学、初中、高中、大学还是白领？所以如果你还不是  会员，说明你已经老了。
个性张扬是年轻的代名词， 会员用户在好友列表中的名字是红色，而且排名靠前，这些都达成了用户的炫耀心理，就连发红包时都拥有右图中的专属的皮肤。
同时  会员还有左图中的  等级加速更快等特权，买电影票、定外卖还能打折。
其实手机  在承担即时通讯等社交功能的同时，还承载着  会员数十亿的营收重任，其中大部分的营收都来自于内嵌在手  中的  页面，因此保证  页面的高质量，是我们的工作重点。

保证  页面的高质量，我们有以下三个挑战：

第一、如何让  打开更快？雅虎的一项研究表明，页面打开每慢  毫秒，将带来 的用户流失；让页面更快呈现给用户是前端工程师们的不懈追求，在  模式下借助于终端的能力我们有了更大的想象空间！

第二、如何让  开发更快？好的产品是运营出来的，沃尔玛每周都有打折，电商有  和双  双 ，同样  会员也需要有持续的  运营活动以保持用户的活跃和留存，而  组件化是我们提高开发效率的手段。

第三、如何保证  页面持续高质量。手机  一两个月发布一个版本，但是  页面每天都有发布，随着  逻辑越来越复杂，比如不同身份用户非会员、会员在不同时间点到期前和到期后进入页面时看到的内容都不一样；如何不依赖成本很高的人工测试来保证  页面的功能持续可用？


首先介绍下我们基于  的  方案是如何实现页面在  秒左右打开的。

、要打开页面，在  端需要先打开一个浏览器 或者火狐，在  或者  应用中必须先有一个 图中橙色部分；出于性能考虑手  并未在后台常驻一个  进程，所以要打开页面需要先初始化 。
、在之前版本的手  中我们时常可以看到类似左边的白屏，虽然加上了卖萌的文案别闹，加载是件正经事让用户感觉萌萌哒，但这掩盖不了曾经  初始化慢的事实。虽然经过几个版本迭代优化，客户端耗时已经大大降低，但是还需要近  毫秒。好像距离一秒的目标很近了。。
、但是  初始化完成后，再调用  接口获取目标  的  内容并进行渲染图中蓝色部分；由于我们的  层基于  语言来实现，一个  请求需要新建一个子进程去查询若干个后台服务，这里的耗时至少需要  毫秒。算一下终端加后台的耗时加起来已经超过一秒了。。虽然没有人能跑的比博尔特更快，但是我们还是有方法来让我们的页面打开更快。

第  个优化是把串行改为并行！我们把终端  初始化工作并行为两个线程图中两个橙色块： 主线程处理主要的初始化工作，而登录态获取、业务插件初始化等工作放在  子线程，这样终端的耗时就从之前的两部分的耗时之和变成了两部分耗时的最大值。同样在后台我们也新建了一个  来代理后台所有服务的查询工作右侧绿色块，由  来并行发起对其他后台服务的查询， 的耗时取决于最慢的那个后台服务接口的耗时。
第  个优化是网络耗时的优化。电影英雄中有段对白：剑术的最高境界是心中无剑，手中亦无剑。减少网络耗时最有效的优化方法莫过于不进行网络请求，也就是 。
、虽然浏览器本身有缓存功能，可以通过设置静态文件的缓存时间来减少请求数，但是我们经过数据验证，发现移动端浏览器缓存有时候并不可靠，缓存还未过期也有可能被清掉重新请求。
、 标准中也有一个  特性，我们通过扩展  的缓存插件实现在  中缓存  文件，加快了  依赖的  的加载速度。但是  本身仍然需要走网络请求。
、其实手  也实现了一套离线包机制，用来缓存  和图片、、 等文件，但是只能缓存静态不变的内容，比如刚开始介绍  会员时的会员个性化红包页面就利用了离线包的能力。然而我们的页面有很多用户数据比如会员身份、会员成长值、 等级成长速度等需要实时查询，再加上终端复杂的离线包校验机制耗时很多，我们新建了   机制，在终端缓存了整个 。
、有了缓存之后， 主线程先发起  的  操作展示本地  缓存给用户，同时发起  的  请求去获取最新的数据内容，如果有变更则通过第  步的  回调进行页面刷新，同时终端会异步进行第  步的更新本地的  。
、如果页面没有变化，网络耗时仅为加载本地  文件的  时间，这个时间几乎为 ；如果页面有变化，由于这里提前并行发起了  请求，网络耗时也比上一页中串行的  直连要少很多。
、这里还有一个问题，就是如果缓存的  内容和最新的内容不一致，我们需要刷新整个页面吗？答案是否定。大家注意下这里第  步返回内容可能是 ，也有可能是 ，下一页会介绍为什么。
 
、我们将  拆分为两部分：模板和数据块。一个数据块对应一段  片段上图中蓝色字部分，用注释语句包裹起来；而数据块以外的部分为模板，一般情况模板的内容比较固定， 结构、内联的样式等很少变动。
、比如图中有三个数据块：， 和 ，分别对应这个页面从上到下三个红框框住的部分。
、刚才有讲到并行  请求回来的内容可能是 ，也可能是 ；我们的策略是如果是首次访问本地没有缓存或者缓存被清理则返回完整的 ；如果模板未变化只是数据块有变化，比如总成长值加了  点，从  加到 ，或者生活福利模块更换了  个广告位，只需要返回  即可，由  触发页面回调来替换  节点实现页面的局部刷新。
、以上两个优化点需要终端和页面按照统一规则紧密配合，我们通过扩展  协议来实现。

、我们扩展了  个  协议头， 个请求头和  个返回头。
、 表明终端是否支持增量更新的能力，一般传 ，对于老版本的手 ，无法携带该头部，后台将会始终返回完整的 ； 代表终端本地缓存的  的  摘要值；
、 代表服务端模板是否有变更，模板和数据块均无变更返回 ，模板无变更仅部分数据块有变更时为 ，首次和模板变更时都是 ； 是后台告诉终端如何进行页面刷新和本地  缓存更新，如果为  代表刷新页面并更新缓存，如果为 ，代表仅更新缓存不刷新页面。

下面我们从整个流程上来看一下。
第一种场景是用户首次或者缓存失效时加载页面，用户点击终端入口后，在初始化  的同时并行发起  链接，在  初始化好之后会在内核和  流之间建立桥接。内核在读取完毕之后终端根据模板数据拆分规则对  进行内容分割，并记录模板和数据的  信息，异步  为模板和数据用于下次与服务器通信实时更新。
 
、第二种场景是用户二次进入页面，这种情况的占比七成以上。 优先加载  缓存，并且根据  返回码的同步状态，进行不同的处理。
、如果  为 ，且返回的是 ，说明只有数据变更，终端会对数据进行  处理，和页面通过  通信进行局部刷新。
、如果发生模板变更，处理逻辑会有点复杂，终端根据在不同机型和网络环境下做智能切换处理，速度较快时会拉取完  流交给内核渲染，速度不快时仍然会建立桥接流，并且也会对  进行拆分；
、如果  为  说明完全命中缓存，则不作任何处理；

、左边的效果是最初页面局部刷新时的表现，我们可以看到加载本地缓存的  后很快看到了整个页面，然后成长值发生了变动，然后又更新了两个广告运营位。但是这里的体验还是有点问题的，加载图片需要时间，导致页面的闪动很明显。
、我们又改进了下，先将图片下载完，再去局部更新这两个广告运营位，最终实现了右边比较平滑的效果。
另外一个图片的优化是图片自适应。
网页中的流量大头是图片，图片加载消耗了很多时间。我们实现了对于同一张图片，终端看一根据用户不同的手机分辨率返回不同规格的图片，而这一切不需要做任何代码修改，完全透明接入。
比如如果你是  ， 返回  像素的高清大图，如果你还在用  ， 返回  像素的一般清晰度的小图，这样在保证体验的同时减少了加载的图片大小，页面更快展现给用户。 

这个项目内部代号 ，意思是希望页面加载速度可以像音速一样快。最终我们也实现了占比 右侧  个场景，局部刷新和完全  时总耗时  秒左右，而且首次访问时的总耗时也低于之前最左边的  直连。

我们除了让  页面加载更快，还需要让  页面开发更快以满足活动运营的需求。

首先我们看一下什么是运营活动？
、左边第一个活动新游戏即将发布，在预约页面提前预约的用户在游戏发布后下载完成后可以免费领取福利；
、左边第三个活动， 会员可以免费领取一张美团的优惠券；
、最右边的活动， 会员玩天天酷跑游戏可以免费抽奖获取游戏道具；

、运营活动有四个要求：一般  天需要完成开发测试和上线、不同活动可能有相同的功能逻辑，一般会投入大量推广资源所以对页面的质量要求比较高，大量资源推广时并发访问用户多对性能要求比较高。
、我们的思路是必须尽可能减少开发环节和开发人力，最小化功能逻辑实现颗粒化可复用，对前端代码和后端服务要求稳定可靠，必须持续的前端性能优化。
、我们的解决方案是构建一个组件化的活动开发平台，内部代号 。

、第一：减少一切可以减少的环节。一般  页面的开发流程是交互设计重构开发，我们和交互、设计人员制定好运营活动的交互设计规范，比如统一弹窗样式，从而减少了交互环节；利用  的新特性  自动对设计稿进行切图，又省掉了重构环节。
、第二：组件化开发。开发人员只需要开发组件，组件可以在不同活动中复用。运营人员只需要拖拽组件、配置资源，最后由执行引擎生成包含活动逻辑的  页面，自动发布外网即可。

一个组件由  片段， 样式和  逻辑构成；开发人员完成组件开发之后，运营人员像拼积木一样，拖动几个组件组合在一起，就可以生成运营活动页面。
同时  平台实现了一整套发布回滚流程支持，自动对接页面性能测试工具，可以对运营页面的性能进行自动化测试，最后也会给大家分享下如何进行性能自动化测试的。

该平台上线后，月均上线活动达到  个以上，但全职开发人员投入仅  人。

保证  页面功能正常，并且让  页面打开更快，不是一锤子买卖，需要可持续。 页面的质量不能仅仅靠测试人员的手工测试来保证，我们需要一套自动化解决方案。
 
、说到质量标准， 是我们耳熟能详的国际质量标准，但是  页面的质量标准是什么？
、 时代，我们知道   就能比较全面的透视整个页面请求过程的耗时，在  模式下，我们对  页面高质量的定义是页面功能的高可用和页面加载速度更快。 

、功能高可用需要  不会 ，页面能够正常打开并且业务逻辑符合预期；页面加载速度更细化，终端耗时、网络耗时、页面耗时，同时需要关注总耗时大于  秒以上的慢用户占比。

、页面功能可用性的自动化测试，我们构建于腾讯内部自研的自动化测试工具 。该工具不仅可以识别  和  终端的控件，也可以识别  的  控件，通过对点击事件进行模拟，将实际的返回值同期望值比较以确认用例是否通过。
、测试人员使用  语言编写自动化测试脚本上传到 ，由分布式任务管理系统分配可供测试的手机模拟器或真实的手机，测试人员可以手工或者设置定时任务自动执行测试计划。
、同时我们将  发布系统和任务管理系统进行打通，每次发布前自动进行功能自动化测试，只有在预发布环境的通过率达标才能继续发布，这样就保证了频繁变更时  页面的功能依然正常。

、页面性能自动化测试我们参考了很多现有的工具，比如 ，雅虎前端优化军规以及谷歌的 ，但是发现这些对  模式支持的都不是很好，尤其是我们基于手  环境下有更多的个性化的东西。
、我们选择了自研  页面性能自动化测试工具，简称为 ，  。参考了  军规，结合终端环境特性和  业务特性，对  页面加载的全流程进行发布前测试和发布后回归。


简单回顾下，我们通过  页面和终端的深度融合实现了  页面的快速加载，同时通过组件化实现了  页面的快速开发，使用自动化工具实现了  页面变更时的持续的高可用和高性能，最终实现了高质量的  的架构实践。
 

文章来源公众号：小时光茶社 ，由腾讯  会员技术团队创建，用于技术分享和交流。新玩法：基于对象

“基于对象”是面向对象编程新趋势，是走向动态化的一次变革。业界在多个领域已经感受到它的优点，并且开始广泛接受这个概念。
“基于对象”的特点
什么是“基于”对象呢？就是关注“对象之间”的关系，而不是关注对象和类的关系。“面向对象编程”的概念已经诞生了很多年，在业界可谓深入人心。像著名的编程语言都是按照这个概念去设计的。但是面向对象编程概念，在实践中，也受到了大量的挑战，很多人认为面向对象编程有很多缺点，其中就不乏重量级的人物如的作者。
在所有的挑战和质疑之中，大部分都是指向面向对象编程的复杂性的。面向对象编程的三个特点封装、继承、多态，都要比单纯的结构化编程，让使用者学习更多的关键字，理解更多的隐喻，遵守更多“不成文”的规范，这确实是提高了编程的复杂度。由于面向对象编程的设计目标，就是要应对复杂的“业务需求”，所以大部分的概念和设置，都无可避免的带上了试图解决灵活度的问题，而在灵活性和本身复杂度之间，要取得平衡确实不容易。
 
面向对象编程的复杂性
但是，在现代的编程语言发展至今，有一个明显的趋势，就是动态化和脚本化。我们可以发现最新兴起的语言，绝大多数都脚本语言，比如，而语言的新规范，也更多的倾向动态类型推断和表达式动态函数。所以面向对象编程概念的发展，也进入了一个更动态化，更脚本化的新时代——基于对象。
现在应用最广的基于对象的语言，应该是和。其中语言的发展尤其快，已经从浏览器脚本，发展成一门通用的脚本语言，通过框架在服务器端也占据了一席之地，并且随之在手机端的流行，更是成为了前端编程的必备武器。
要了解什么是基于对象，我们可以和传统的面向对象编程三特征：封装、继承、多态，来做对比，获得最直观的印象。
封装
在面向对象编程经典概念中，封装的含义是，把函数和属性，都封装在一个叫“类”的盒子里面，然后我们通过实例化“类”得到“对象”，通过“对象”来实现我们的业务逻辑。
在我们的观念中，函数和变量，是构成代码的两个基本概念，而“类”则是一个用来封装这两个基本概念的“新概念”。反而“对象”很好理解，就是一个自定义数据类型的变量而已。“类”是比较静态的概念，是运行时的“对象”的模板。
一般来说，“类”的定义是编译时就固定了的，所以“对象”在运行期的行为和属性，其结构也是固定在“类”这个框框里面的。“类”就好像图纸，而“对象”就好像照图纸建造的房子，为了获得复杂的房子，我们的图纸必定会变得很复杂，因为图纸必须包含全部的建筑信息，而不能在房子建成后再修改其结构。
 
类是图纸，对象是房子。
然而，在基于对象的概念里，有两个本质上的区别：
第一个区别是：只有“对象”而没有“类”的概念，所以也没有各种“类型”的变量。所有的对象，都统一是“”类型。所以如果你要新建一个“对象”，是无需指定类型的，只要好像新建一个变量一样就好了，也就是没有所谓“实例化”的过程。
当然这样新建的对象是一个空白的对象，没有任何功能。由于“基于对象”里的“对象”，基本上都是可以“动态”变化内容的就是可以运行时添加成员，所以我们创建出空白对象之后，就会“动态的”运行时用代码给它添加各种成员属性，从而让它变得有用起来。
第二个区别是：函数方法也是变量。关键字就是函数变量的类型。这意味着，函数和变量的概念统一起来了。函数也可以像变量一样，被赋值、被用作参数、被作为对象的成员所携带。由于函数也是变量，所以“对象”就没有必要把自己的成员分为“方法”和“属性”两种，统统都可以看成是“成员属性”即可。想要类似以前的“类”上携带“方法”的效果，只需要简单的为“对象”添加一个函数类型的成员变量即可。使用基于对象的模型编程，我们会用动态的组装对象初始化或赋值，为对象安插上数据变量和函数变量作为成员，代替“方法”和“属性”的作用。这个过程取代了先定义“类”，然后“实例化”对象的做法。当然这种简化也会带来其它问题，我们后面会说。
 
初始化变量时构建对象。
这两个区别，全面的简化了传统面向对象编程中概念的数量。因为我们不再需要构建复杂的自定义“类型”系统，没有了“类”关键字，也没有和类相关的“方法”和普通函数差异的概念。这无疑大大减轻了学习的负担，同时也大大增加了运行时的灵活性。
 灵活性：在使用时组装。
继承
传统面向对象编程中，“继承”这个特性是一个大杀器。威力巨大，副作用也巨大，据说现在都流行不要用这个特性了——说继承会破坏“封装”，让父类的信息被泄露到子类去。而且有的语言程序员请冷静支持多重继承，这更是让程序变得超级复杂。不过，从本源来说，继承是为了把一种对象的模板父类，复制到另外一种对象的模板子类里的技术。
由于两种模板的定义可能是随心所欲的，所以要真正的能让它们结合的既好用，又不会出错，其实是挺困难的。所以我们为继承的特性创造出一大堆的关键字，比如   …然并卵的是，这些关键字往往除了让语言级别考试作为题目以外，实际运用中往往没有特别大的作用。程序员们一般都希望能以最简单这样不容易出错的某个惯例来编写代码，有些精心设置的特性几乎从来不会使用比如操作符重载，程序员请继续冷静。
基于对象的语言，在继承上的实现，就和以前的概念有很大不同。基于对象的继承，是根据一种叫原型链的方法来实现的。意思就是，父类和子类的关系，并非是“类”定义的关系，而是对象之间的关系。因为根本没有“类”这个东西，所以父类的特性，是由一个父类地位的对象所携带，然后作为一个特殊成员“原型”也就是一个叫的属性，被子类对象所引用的。当然父类对象还可以自己再链接着另外一个父类对象，这样就形成了一条对象的链。
 原型链
在运行的时候，如果调用一个对象任何方法或者成员，是找不到的时候，就会顺着这条原型链挨个查找，看看链上的对象有没有对应的方法和成员属性，如果找到了就访问它。这样就实现了子类对象拥有父类对象的能力。虽然这样做多少有点简单粗暴，但是足够清晰。
原型链这种继承方式，在使用上和传统的继承差别似乎不大，但是它使用的是一种“默认委托”来实现。从本质上来说，子对象和其原型对象实际上通过组合，而不是严格意义的“继承”来结合的，这正是很多面向对象编程规范苦口婆心教育大家的“尽量用组合，少用继承”。
需要注意的是，原型链下的继承方法，如果里面有用到关键字，指的是那个方法所对应的对象，也就是有可能是原型链上的原型对象，而不是最终的子对象。也就是说，在“父类”方法中的，不是多态的，不能代表最终的“子类”对象。
 两个对象组合实现继承
用原型链来实现继承，从性能上来说是比不上传统的继承的，因为有可能要遍历原型链上的所有对象。从理解上来说，其实也显得没必要的复杂。因为，如果对象都是动态的，如果我需要某个对象的能力，可以直接把那个对象的成员方法拆下来，装在自己身上。甚至可以动态的拆装多个所需对象的结构，组合成一个独特的新对象。——这些工作完全不需要修改类定义文件，不需要编译，而仅仅是写几行脚本即可。
多态
基于对象的编程方案，其实最有价值的，最能提升开发效率的，就在于对“多态”的增强。
 多态常用于接口
我们如果编程，由于函数不可以脱离类存在，如果使用某些框架来开发，你会发现你要实现大量的接口。每个接口或多或少的几个方法，可能会让你自己的类变得面目全非。这些需要实现的接口，本身的命名和语义，都是按照框架本身的含义来设计的，而你自己的类，一般和框架的整个语境不同，强迫你的类加入一些奇怪的函数，确实是严重的“污染”了整个代码的可读性。
如果你想每个接口都单独实现一个类，那么你马上就会陷入“类爆炸”——你的项目中有大量的类型，而绝大多数其实都是为了接口而制造的。对于代码维护者来说，看着这么大堆的代码就头晕。所以有人说编程就是在表演一套复杂的仪式，来完成一个很简单的操作。其中就有接口实现类的“功劳”。
对于基于对象的语言来说，接口其实什么都不是，因为函数本身是一种类型，所以函数这种类型，本身就是一个“超级接口”。所有的回调、事件都可以绑定到任何函数上。函数作为一个变量，也可以作为其他函数的参数传来传去。这样你就再也不需要定义任何形式的函数接口了，你只需要用的写法，把一个变量当作函数调用即可。因为没有需要绑定的接口，所以也避免了因为大量的回调接口造成的“类爆炸”。而且这种做法写起来也很简单，如果你想让你的代码使用一个函数参数，直接声明一个就好，不需要去表演一整套的“定义接口——完成实现——多态调用”的过程，这极大的提升了开发的效率。
我们在、以及很多异步框架中，能明显的体验到基于对象对‘多态’优化带来的好处。这一类框架，由于是针对异步操作程序的，所以回调函数是最常见的东西。整个业务流程，都是由大量的回调函数“串接”起来的。如果没有函数变量类型，将要有无数个接口类型需要声明。
虽然基于对象有节省大量“声明、定义”的优点，但这个反过来说也可能是个缺点。以为所有的函数变量都只有一个类型，因此你无法在编译器作任何函数形式的检查，也无法预防运行期发生不合适的函数变量被调用的问题。另外一个缺点，就是表现力可读性上面的，类型系统的好处是：类型本身就是一个自定义的语义，可以赋予良好的可读意义，但是一个简单的类型，就没有任何可读语义。这对于比较复杂的系统，其实是挺大的问题，因为各种函数对象传来传去，如果没有类型信息用来协助理解，代码阅读起来会非常困难。
优秀的组合：组件化
面向对象和基于对象，都有各自的优点和缺点，但是有没有可以兼顾两方面的方案呢？很多项目都在这个方面做了一些尝试，一般来说这类尝试都走向一种叫组件化的方向。
所谓组件化，通常是指，把我们业务中常见的逻辑单元，都先抽象成一种叫“组件”的对象，不同的逻辑特性构成不同类型的“组件”。而这些组件对象，都是可以在运行时，遵循基于对象的原则，可以灵活的组合成真正需要的逻辑对象。
 组件既是对象，也构成对象
由于“组件”本身是一个接口类，所以各种各样的“组件”还是有各自的面向对象的“类型信息”的，这就能利用上面向对象的静态检查、可读性等优点。
而由于“组件”是可以灵活的组合的，所以避免了复杂的继承结构，而能提供千变万化的对象。这些对象变化恰恰是能很好的应对业务逻辑上的复杂变化的。为了让组合后的对象能简便的调用“组件”提供的能力，往往需要使用一些“反射”类的特性，用来让业务逻辑对象能直接“拥有”那些反射的方法和属性。这种做法虽然性能可能稍微低一点，但是却能得到非常大的灵活性。
现在非常流行的游戏引擎的语言方案里面，就是一个组件化的编程的优秀实践。在里面，所有在游戏中存在的东西，不管是可见还是不可见，都叫做，而所有这些通通都可以被放在一个容器场景中。游戏就是由一个个的场景组成的，非常容易理解。在游戏中可以表示任何东西，这个就是“基于对象”中的对象。比如我们常见的有“摄像机”没有它游戏就不会显示哦，而且一个场景里面可以有多个摄像机，这样可以做类似监控录像的功能，“地面”，“玩家”、“建筑物”、“子弹”等等，都是。在的编程环境中，也对应的存在一个这样的类型。然而，这个类型本身却没有多少功能方法和属性，基本上都是一些创建、删除、查找子对象、查找组件的方法。而真正为这个提供能力的，是它所包含的各种各样的组件。
 每个都带有多个
一般一个在游戏里面的角色，都会包含如下一些组件：一个代表此对象在场景中位置和方向的类型组件位置、方向、比例三个属性都由\\三个数表示；一个表示自己外观的组件；一个用于记录如何渲染自己的组件；如果需要碰撞检测功能，还会带有和组件；更重要的是，如果你想为这个角色带上一些自定义的功能，可以带上一个或者多个组件。如果你有多个游戏对象，都具有同样的行为，比如一大群各种各样的怪物，你完全可以只编写一个对象，然后加到所有这个怪物身上，他们就会具有一样的行为了。
而一个摄像机对象除了会带有组件你可以通过它来控制摄像机的位置和方向，还会有组件控制景深、背景颜色等等，另外还会有 组件用于显示面板工具栏，甚至还有 组件用于播放声音当然你可以同时附加一个 组件，这样组合起来就可以播放背景音乐了。可以说几乎所有的游戏的功能，都是通过各种各样不同类型的组件对象，通过组合的形式放在类型的对象里实现的。
  
所有这些组件，都会成为的一个属性存在，比如 就能获得组件，从而读取或修改对象的位置。而且这个组合的过程，你可以通过的图形编辑器来实现，不需要编写一个真正的类定义的文件。这里就用到了一些动态反射的机制：访问一个属性的请求，自动转换成访问一个组件对象。
和都是可编程的类型，但是那些一个个由不同组件组合成的，如果想变成一个可复制的模板，则需要建立一个叫预制件的对象。这里的负责了“类型继承”的能力。由于不为每个建立独立的类型，所以我们无法通过一个类型去实例化多个具备同样功能的对象；但是使用“基于对象”的概念，我们可以从一个对象模版去克隆复制出多个同样功能的对象：   ——我们只要传入一个对象，就能得到其复制品对象。而对象是无需存在于游戏中的场景里的，从某种意义上说，可以看成是“类”的替代品。
 
在游戏开发中，我们每天都要设计、修改大量不同特征的游戏对象，如果为了每个对象都去编写其类定义代码文件，将会是很枯燥和繁琐的事情，甚至于最后为了起类的名字都会想破头。但是如果我们用了基于对象的方法，我们可以专心于处理一个个游戏中独特的对象。对于那些大量重复的对象，同样可以使用复制的方法来控制。这对于快速开发游戏，应对大量不同的需求变更游戏策划是最爱变更需求的人了，是非常有好处的。
虽然每个都可以带有不同的脚本组件，但只要每个脚本有方法，就能在每次渲染时调用这个方法。值得注意的是这个方法并不是定义在组件类型里的，而完全只是一个单独的公开方法。引擎会使用反射的方法来找到这个方法来调用。使用反射而不是多态的方式来设计这个接口的原因，实际上也是基于对象的思想：方法应该是动态的，是一个属性。当然啦，本身除了，也支持脚本，在里面，根本就没有“虚方法”继承得来的方法这个概念。
在里面的编程方案里面，既存在传统的面向对象概念，如的类型系统，也使用了基于对象的架构：模型。因为有的类型概念，所以各种组件实际上是有自己的类型的，这些类定义可以帮助使用者快速浏览和掌握引擎提供的各种方法和属性，并且提供足够的编译期检查。开发者自己的代码，也可以采用类型系统来编写严格定义的类，用来构建严谨和良好可读的复用代码。而那些变化非常频繁的代码和模型，则可以使用基于对象的的组件模型，灵活的组合出各种业务对象，降低开发成本。所以这种设计既能兼顾传统面向对象的优点，又能用上基于对象的好处，是一个非常值得学习的思路。
总结
“基于对象”是“面向对象”一次动态化变迁，它依赖于现代语言的动态特性，让方法和属性统一起来；用组合取代继承；以函数对象查找取代多态的方法调用。这些变化让面向对象复杂的仪式化定义代码变得灵活轻巧，更加适合那些需求多变的业务领域。而组件化编程思想则把“面向对象”的严谨和代码可读性结合到“基于对象”上，从而兼顾两者的优点，从而渐渐成为现代编程理念的一个潮流。

相关推荐架构实现利器：反射浅析“远程对象调用”互联网企业的敏捷开发之道接《 加速，协议先行  上》，下面我们看一下协议的优化。

协议最大的性能问题也是它的握手。所以优化的目标也非常明确，就是减少完全握手，提升简化握手的比例。协议层面提供了两种机制， 和 ，我相信接触过的同学都非常清楚，网上的资料也非常多，关于原理和过程我就不多做介绍了。
这里我主要是分享两点：
通过提升简化握手比例， 的握手时间提升了，从节省到了。
虽然 是一种更加优秀的机制，因为它不需要服务端做缓存，但是目前还不支持 ，要想实现简化握手，必须要支持 ，并且最好是实现分布式 来提升简化握手比例。
然后我们再来看一下完全握手，因为有很多场景下必须要进行完全握手，比如用户第一次打开浏览器或者，用户关闭页面再打开，用户手机或者系统重启等，都需要进行完全握手，因为前面提到的 还是 都是基于内存的，客户端重启之后再发起握手默认就无法携带上这些信息，必须进行完全握手。

针对完全握手该如何优化？
优化思路类似，即在完全握手的第二个阶段，即密钥交换阶段，提前发送应用层数据，节省这一个对性能的影响。
上图左边是普通握手，可以看出必须要进行四次握手，两个之后才能发送绿色的加密数据。上图右边就是 ，抢跑的意思。在第二阶段，消息发出的时候，将 的应用层数据加密发出来了。相当于节省了一个。如何支持 ？
很简单。因为现在最新的客户端都已经支持了这个特性，所以对于服务端来廛，我们只需要将支持完美前向密码算法的密码套件配置在前面就行了，比如，算法配置在最前面。协商好密码套件后，客户端就能提前发送数据，实现 。 对完全握手的优化效果也很明显，大概提升了。

接下来我们再看一下的问题。是在线证书状态检查协议，这个检查和证书本身的签名校验不是一回事。因为有一些情况，单纯检验签名是发现不了的。比如我们申请了一张有效期一年的证书，但不幸的是，申请下来的第一个月，私钥被内部人员泄露了，或者本身的数据库被黑客攻击了，我们需要主动撤销这张证书的信任关系。那就只能主动告诉这张证书不安全，然后客户端自己再去那边查询一下。因为这个时候证书本身的签名是没有问题的，如果不去额外查一下，在证书本身过期之前，永远也发现不了证书被撤销的事实。
的过程发生在客户端接收到 和消息后，这个时候它会根据证书里的域名，发起请求，如上图左边所示。 的意思，简单来说就是服务端代理实现的内容的签发。服务端会提前向ＣＡ站点请求好ＯＣＳＰ内容，并保存在本地，在握手的时候，将ＯＣＳＰ内容和证书一起发送给客户端，这样客户端就不需要自己主动去请求ＣＡ查询ＯＣＳＰ内容了。这样看来 至少节省了三个，效果应该非常不错。但事实上， 的效果并不会特别突出，因为客户端有缓存。一般来讲会有天，也就是说客户端天中才会查询一次。对于一个用户经常访问的页面来讲，这个概率可能只有千分之一甚至万分之一。所以对用户的访问体验来讲，提升的效果也比较有限。

然后我们再看一下  。为什么需要做这个动态调整呢？是因为协议本身的队头阻塞。
是协议处理的最小单位，最大不能超过，一些服务器比如默认的大小就是。由于一个必须经过数据一致性校验才能进行加解密，所以一个的，就算丢了一个字节，也会导致已经接收到的数据无法处理，因为它不完整。比如上图右边所示，假设一个需要个 传输完成，如果最后一个丢了，那么上层应用程序必须在那里等，无法继续处理。
上述就是协议层面的队头阻塞，那如何解决呢？也有两个方案：
高版本支持一个配置指令__，可以将它设置成，这样就算有，影响的也只是数据，而不是之前的。

更好的一个方案是动态调整大小，思路类似 的 。在连接刚刚建立的时候，由于不知道网络速率，可以将设置得小一点，比如，当发送速度逐渐提上来之后，再将这个 设置成。这个方案也已经有开源的，是 提供的，大家有兴趣可以关注一下。

刚才提到的一些优化特性都是针对及其之前的协议版本。接下去我们看一下协议。这是一个具有革命性的创造性的极具里程碑意义的协议。

它现在迟迟没有发布的一个讨论焦点就是它到底该叫还是。在性能方面最大的提升就是能够实现的完全握手，能够实现的简化握手。上图左边就是的完全握手，右边就是的简化握手，也就是说应用层数据可以握手消息一起发出来，而且都是经过加密的。
关于协议的原理和的详细过程我就不做详细描述了，因为还没有正式发布，那这里为什么又给大家介绍呢？因为如果大家想尝鲜的话，现在就可以体验了。
以及 目前已经支持的最新草稿。也有一些客户端支持了，比如。大家如果有自己的客户端，现在就可以参考这些实现进行集成。刚才我们介绍的是协议，接下去我们再往上看，协议。

之前提到过需要跳转强制用户使用。那能不能减少这个跳转呢？就是这个作用。这是一个的，客户端接收到这个头部后，就会在接下去指定的时间内，默认只发起请求。不管用户输入  还是  ，浏览器都会在本地进行跳转，直接发起请求。
就算返回的里包含有资源，浏览器也会将它们全部替换成资源。
不过还是有一个安全风险，因为通常来讲它都是通过协议返回的，所以很容易被中间者劫持，直接被干掉，这样客户端就可能永远也接收不到的头部，也就不会发起请求了。
为了解决这个问题，提供了一个 的机制，大家可以给上图所示的网站申请，将自己的网站域名加入到 里，这样不需要返回，也会默认使用来访问你的网站。

然后我们再来看一下和，这里为什么要提一下呢，主要是两个原因：
的大部分特性，除了头部压缩算法，都是沿用自，可以说是的鼻祖。现在越来越多的人只知道，不知道，我这里介绍一下主要是为了向它致敬。
现在还有很多的客户端只支持，比如以前，以及现在都支持，为了兼容一些老的客户端，提升它们的性能，我们腾讯云的服务端也是同时支持和。
上图列的几个特性是大家都比较清楚的特性，其中多路复用是最强大的特性，它能将多个请求在一个连接上并发地发出来，同时请求和请求之间在协议层面可以没 任何依赖，当然也可以有依赖。也就是说谁先处理完成谁就可以先返回，不会影响其他请求的处理。
的就不行，比如上图右边，如果在同一个连接上发起四个请求，那四个响应必须按照顺序返回，其中一个处理慢了或者丢失了，都会导致四个请求全都无法处理，也就是 的队头阻塞。

前面几个特性大家比较清楚，这里我再重点介绍一下两个大家可能不太清楚的特性，一个是头部压缩，从字面很好理解，就是压缩了头部大小，提升了传输效率。但压缩比真的如官方页面宣传的有吗？
我们通过实验发现，在一个连接上发起第一次请求时，压缩只有，发起第二次请求时，压缩比能达到，一直到第三次请求以及之后的请求时，压缩比才能达到将近。为什么会这样呢？因为头部压缩是基于的，是基于的压缩算法，它们都是利用状态空间的重复信息进行压缩，也就是说信息越冗余越重复，压缩比才会越高。
这带给我们的启发就是，在用户发起真正的请求前，我们利用提前发送两个空请求，积累重复的头部数据，当用户发起真正的请求时，已经是这个连接上的第三个请求了，这样用户请求的头部压缩比一下就能达到，有利于提升用户访问速度。
然后再来看一下 。由于不支持，这个功能目前在国内用得还比较少，但确实很有用。比如客户端请求一个，正常来讲它需要解析完后再请求和，这里至少会有个。但是如果支持 ，我们在服务端配置一个头部，这样服务器在接收到请求后就知道将另外两个资源和 一起返回给客户端，不需要客户端发起额外的请求。
这就是 未发先至的作用，和有点类似，但是相比有两个好处：
有利于缓存。因为在里，不仅增加了的体积，而且一般来讲是不会缓存的。
减少开发成本， 雪碧图也好还是图片内联，服务端都有一定的开发成本，有些开发甚至是反模式的，需要精确地位置调整和屏幕适配。

分享一下的实践建议。
使用一个连接，或者使用尽量少的连接。为什么呢？有三个好处：
 连接少意味着更少的连接建立成本，之前也提到了，的连接成本很高。
 能够实现更高的压缩比，因为数据都在一个连接上，提供的冗余信息更丰富，有利于压缩。
 能够更好地利用的特性。因为的很多特性，包括滑动窗口，拥塞控制都是基于一个连接的，如果连接数量多，特别是网络拥塞的时候，很容易放大拥塞系数，加剧拥塞。
使用更少的域名。一方面能够减少域名解析的时间，另外一方面也能建立更少的连接，作用和第一点类似。
如果一定要使用多个域名，那么尽量保证多个域名解析到相同，并且使用了相同的证书。这样也能方便浏览器复用相同的连接，比如就会作这样的智能判断。
灵活运用 代替。
只支持及之后的版本。而且只有的部分 才能使用。所以如果大家想使用，一定要注意配置好协议，参考的规范，配置好密码套件。
不是万能的，如果你的页面很简单，比如只有几个元素，如果还是有性能问题，那也不能寄希望于。最强大的特性是多路复用，还是适合于解决多元素多请求的场景。

最后我们再来看一下预建连接。所谓的预建连接就是在用户发起正直的请求前将连接提前建立好。这样当用户发起请求时，由连接建立所导致的开销成本，用户都是感觉不到的。
所以预建连接可以说是一种最简单，最有效的方案。因为之前提到的一系列方案，就算是握手，也会有一些数据校验和计算的工作。预建连接的效果也非常明显，对性能的提升至少是以上。
那如何预建连接呢？主要有两个方法：
通过标签和头部告诉浏览器提前建立另外一个资源的连接。不过还有很多浏览器或者一些历史版本不支持这个特性。

通过页面的给另外一个资源发送请求，提前建立连接。

预建连接也可以根据具体的用户场景和用户行为来建立。比如：
首页提前预建子页面的连接。当用户打开百度首页的时候，它通常会发起搜索，那我们可以提前给搜索结果页面建立连接。
根据用户行为预测。比如用户进入ＱＱ空间首页时，我们可以根据用户的浏览习惯，他是经常访问相册，还是经常访问ＱＱ商城来预建不同的连接。
预建好的连接也有可能会超时断开，比如ＨＴＴＰＳ的超时时间是１分钟，ＨＴＴＰ２有可能是３分钟，那过了几分钟后连接就断开了，用户再次发起请求时又需要建立新连接，如何避免这种情况？
可以使用长连接保持。即我们使用周期性比如每分钟发起一次长连接保持的请求，就提供一个空页面，访问这个页面我们返回个字节，作用就是为了维持住这个连接，不让它中断。

总的来说，的访问速度是可以超越的，这里面最核心的一点是，可以使用，可以多路复用，而不行。
上图的数据是两年前 空间优化的效果，数据虽然有点老，不过思路和优化方法是一致的，没有过时。

前面提到了很多的特性，性能也很强大，那是未来吗？或者更准确地说，是下一个十年，最有性能优势，最具有统治力的协议吗？
可以说是。因为它的许多特性，包括多路复用，头部压缩， ，优先级等，设计得十分先进，性能也十分优良，解决了许多性能问题。也可以说不是，为什么？因为当前的协议是构建在和之上的，由此导致了一系列问题：
连接耗时。比如需要三次握手才能建立连接，就算是有了，也需要操作系统才能支持，有许多系统目前也不支持。而且本身，在第一次获取时，也需要一次额外的才能实现接下去的快速握手。
连接耗时，当前的至少需要个才能建立连接。
安全问题，目前并没有针对头部进行一致性校验，从而存在头部被篡改的风险，比如修改滑动窗口数，修改序列号等。
加剧队头阻塞。为了实现可靠性和数据的有序性，发生丢包后需要重传，就算丢包序列号之后的包提前到达了，也需要等待丢失的包重传才能通知应用层来读取数据。这就是的队头阻塞问题，而的多路复用，加剧了的队头阻塞，因为一条连接上同时发送的数据变多了。队头阻塞的影响也就更严重了。
重传的模糊性问题。由于重传的序列号和原始的序列号相同。在判断该及后续是否需要重传的时候，很容易迷糊。
拥塞控制，需要操作系统的支持，升级成本高。
以上种种，影响了的性能，所以从这个角度来看，也可以说并不是未来最有性能优势的协议，那什么才是呢？我觉得最有竞争力的一个协议就是。

让我们拥抱。什么是协议？简单来说就是使用实现的。它具体以下特性：
继承了的大部分特性，包括多路复用，头部压缩， ，优先级等。
当前支持握手，等发布后，也会使用的握手协议。
使用传输，没有连接建立的耗时。
针对 进行加密，减少了队头阻塞的程度。
针对头部进行一致性校验，就算是修改了头部也能及时发现。
由于篇幅关系，关于的原理和详细功能就不再做介绍了。感兴趣的同学可以关注我们后续的报道，如果有机会，下一次架构师峰会，也可以专门给大家重点分享。

上述提到的许多协议优化特性，我们都已经集成到了腾讯云负载均衡。大家如果感兴趣的话，可以使用腾讯云的产品和来体验一下。

注：本篇内容来自“腾讯技术工程官方号”，公众号：一、理解  ，  ， ，  的联系和区别

 是应用层与  协议族通信的中间软件抽象层，它是一组接口
一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定
 起源于 ，而  基本哲学之一就是“一切皆文件”，都可以用“打开  – 读写  – 关闭 ”模式来操作。 即是一种特殊的文件，一些  函数就是对其进行的操作读写 、打开、关闭
 中的 ，读起来太抽象，打个具体的比方吧，我们的消息队列文件就是  类型的文件，就是  文件： 框架下消息队列文件存在 目录下

： 里面配的两个  在  文件中配置的，成对出现可以在这里查到。→加个 →再换成十进制。。。扯远了。

网络中的 ：
在本地可以通过进程  来唯一标识一个进程，但是在网络中这是行不通的。其实  协议族已经帮我们解决了这个问题，网络层的“ 地址”可以唯一标识网络中的主机，而传输层的“协议端口”可以唯一标识主机中的应用程序进程。这样利用三元组 地址，协议，端口就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。

先看网络协议图：

就是说  是应用层协议的一种，建立在  协议之上，它的诞生是为了创建一种「双向通信」的协议，来作为  协议的一个替代者。
情不自禁要问，为什么要用  来替代 ？ 也有 ，如图随便抓个  的包都能看到 。

 默认使用持久连接 ，在一个  连接上也可以传输多个  消息对，但是  的基本模型还是一个  对应一个 。这在双向通信客户端要向服务器传送数据，同时服务器也需要实时的向客户端传送信息，一个聊天系统就是典型的双向通信时一般会使用这样几种解决方案：

轮询，轮询就会造成对网络和通信双方的资源的浪费，且非实时。

长轮询，客户端发送一个超时时间很长的 ，服务器  住这个连接，在有新数据到达时返回 ，相比，占用的网络带宽少了，其他类似。

长连接，其实有些人对长连接的概念是模糊不清的，我这里讲的其实是  的长连接。如果你使用  来建立  的长连接，那么，这个长连接跟我们这里要讨论的  是一样的，实际上  长连接就是  的基础，但是如果是  的长连接，本质上还是  消息对，仍然会造成资源的浪费、实时性不强等问题。



相同点
•都是基于  的应用层协议
•都使用  模型进行连接的建立
•在连接的建立过程中对错误的处理方式相同，在这个阶段  可能返回和  相同的返回码
•都可以在网络中传输数据
不同点
• 使用  来建立连接，但是定义了一系列新的  域，这些域在  中并不会使用
• 的连接不能通过中间人来转发，它必须是一个直接连接
• 连接建立之后，通信双方都可以在任何时刻向另一方发送数据
• 连接建立之后，数据的传输使用帧来传递，不再需要  消息
• 的数据帧有序
二、 握手
出于兼容性的考虑， 的握手使用  来实现，客户端的握手消息就是一个「普通的，带有  头的，  消息」。所以这一个小节到内容大部分都来自于 ，这里只是它的一种应用形式，下面是  文档中给出的一个客户端握手消息示例：

                  
        
                 
                 
     ==            
                 
                  
                 
可以看到，前两行跟  的  的起始行一模一样，而真正在  的握手过程中起到作用的是下面几个  域。

： 是  中用于定义转换协议的  域。它表示，如果服务器支持的话，客户端希望使用现有的「网络层」已经建立好的这个「连接此处是  连接」，切换到另外一个「应用层」此处是 协议。

： 中规定  只能应用在「直接连接」中，所以带有  头的  消息必须含有  头，因为  头的意义就是，任何接收到此消息的人往往是代理服务器都要在转发此消息之前处理掉  中指定的域不转发  域。


如果客户端和服务器之间是通过代理连接的，那么在发送这个握手消息之前首先要发送  消息来建立直接连接。

＊：第  行标识了客户端支持的子协议的列表关于子协议会在下面介绍，第  行标识了客户端支持的  协议的版本列表，第  行用来发送给服务器使用服务器会使用此字段组装成另一个  值放在握手返回信息里发送客户端。

：作安全使用，防止跨站攻击，浏览器一般会使用这个来标识原始域。


如果服务器接受了这个请求，可能会发送如下这样的返回信息，这是一个标准的  的  消息。 表示服务器收到了客户端切换协议的请求，并且同意切换到此协议。 规定只有  及  以上版本的时候才能同意切换。
        
      
      
     =  
      
  协议默认使用  端口， 协议默认使用  端口。和  一样啊
收发数据帧：
客户端和服务端都能在任意时候发送数据，不管是从客户端到服务端还是相反 每个数据帧的格式都是：

对报文的详细解析过程可以参考文章如下：
查看资料：



__   是之项目组 ， ，陈松等以及陈莉君教授西邮 实验室正在致力于打造的一个开源项目，项目组欢迎开源爱好者加入和参与。这是文档《 是什么为什么怎么办 》的第二部分。第一部分的链接为：宋宝华：  易用剖析器 是什么为什么以及怎么办
的下一步工作
 架构改造
 前后台分离
目前的体系架构是由浏览器触发与通信然后开始采集数据的，下一步我们要改造为，通过的后台设置监控目标，我们通过后台设置一个或者数个被监控的电路板服务器地址，即开始采集，而后浏览器只负责观看监控数据，如下图。

 服务器端，读取采集到的数据并分析与保存到数据库。而浏览器端，基于已经存在的数据，进行各种分析。
 数据保存和恢复支持
在架构中的另外一个考虑是，增加数据库的支持，将采集到的数据，进行保存和恢复。以方便进行时空比对。
我们可以把某一时段的数据采样出来，通过浏览器打开了分析。这样，可以回顾场景或者对比各次场景。
 自定义被监控的数据
目前，一旦开启，进入浏览器就可以获得所有的数据。未来，我们应该提供勾选关注事件的能力，以便于只监控它感兴趣的数据。比如，用户选择了只关注内存，那么别的界面就不要显示了。
 功能增强
 高平均负载预警
以不同的颜色，标识系统里面平均负载的高低。比如某段长期时间段里面  明显过高，我们标识一段红线区域。类似不同颜色的台风或暴雨预警。
点击预警的时间点时，可同步刷新当时的利用率，，等曲线。
 负载不均衡预警
一旦检测到多核下，负载不均衡，以算法分析后，进行提示。负载的不均衡主要体现为个方面：

进程中断软中断
中断软中断

在出现中断与软中断负载不均衡的时候，提示进行中断的设置，以及提示采用  调控。
 内存大户提示与内存泄漏预警
分析高峰期的内存场景，比如在某个场景下，哪些进程在耗内存。对于内存大户，可以给出某个进程的内存使用历史曲线。
我们如果监控到某个进程的内存持续震荡向上，应提示内存泄漏预警。

可点选某一进程，显示它的，类似：
       _
        _
        _
       _
        _
        _
       
        
        
此处我们能否画一个柱状体：

同时，我们要增加剖析和的能力，并提醒用户和的泄漏。我们也可以显示的内容：

 基于和用户自定义分群的分析
可视图显示的不同的，显示每个的占用，内存占用。也可以对某个的资源进行调配。

此外，也支持用户通过浏览器拖曳手段，依据应用场景建立自己的分群，把关注的进程，拖到自定义的分群中。最后显示这些自定义分群的、内存和占用情况。
 排队预警和调度策略控制
能够给出排队情况的不同颜色的预警，提示硬盘的访问的剧烈程度与排队等候情况。
增加各个磁盘调度策略的显示和设置。读取此类节点 通过选择框设置  

在的情况下，点击一个进程，可选择设置它的和调度策略。
 集成
的功能有很多，目前我们需要集成一些紧迫的功能。
可以平滑的绘制系统的分布图
类似执行     

在进程列表上面，加一个窗口，这样可以自己手动启动一个进程；后面有一个单选框，决定是否进行 和 的跟踪。


此部分类似 里面进一步一个函数的功能：
 杂项：查缺补漏和交互控制
可以给出系统里面谁在耗电，历史上、外设处在各种状态的时间比例。

每秒中断、每秒软中断、每秒上下文切换、、等残缺数据的采集和显示。频繁的场景提示匿名页交换过于频繁的不同颜色的预警。
运行起来后，有很多的是通过来控制，很多的含义，用户根本不懂。我们可以在浏览器上，直接展开目标的，然后把一些关键的设置的含义，告诉用户。让用户知道自己的目标是什么情况。比如：

_ =  暗示你的总是假装系统有足够多的内存 点击阅读文档…
…
在进程的利用率图上，我们可以点击右键，展开它的线程，甚或进一步控制线程的调度策略、优先级或者值。
凡此种种，可以想到很多，不再一一列举。在的开发过程中，小点逐步完善。
 和测试
在提交后，催生自动编译和测试。测试环节要求可以覆盖到位、位、 位和 位的目标机。覆盖到的内核版本包括

 
 
 

编写测试案例，以覆盖到的每个，并自动覆盖到的 ，保证高强度下，和的稳定。
 文档
每个模块在设计和开发过程中，书写详细的文档；文档在、内核之旅、投放；书写文档，投放到上传教学使用视频到、英文版；更新和完善网站
人员与分工
 总体参与人员
研发与测试由陈莉君教授组和 组共同负责，张国强负责总后勤与联络。
  架构改为前后台以及监控数据可配置
  数据存储与读取、比对
 基于和用户自定义分群的分析
 持续集成一旦有人提交代码，即激活自动编译和测试。
 自动测试与案例增加必要的测试，保证在各平台，各内核版本的持续稳定。
 残缺功能添加和预警分析功能中断、软中断、上下文切换、、、、、等残缺的数据采集，负载预警，负载不均衡，内存泄漏预警，过载预警等。
 集成目前端依赖于工具的安装，我们希望能将的核心功能从工具移植出来，直接集成到，这样避免对平台的依赖。

来自微信公众号  前言：
在《的一次 失败的分析》中分析了失败的原因以及解决方法。修改了之后，一直没有看到现象发生，但是不能证明问题被解决了，因为当时的环境只有文件，没有找到固定的复现规律。继续观察中。坏消息是问题又复现了。好消息是问题能复现了。
分析：
、 
作者写了脚本，批量启动大量的进程。在启动很大量的之后，会有部分进程。结合之前的分析过程，作者判断，很可能是系统调用发生了失败。是时候使用了。使用需要有 ，如果是发行版，可以参考发行版提供的 ，参考官方的教程，可以搭建起来的使用环境。如果是个人维护的，那么就需要保存对应的。作者写了下面的脚本来监控进程调用_的返回值。
  {
        \
}

 _ {
      ==  {
        _  \ 
    }
}

 _ {
      ==  {
        __   \  
           
            __   \  
    }
}
启动：    复现到问题的时候，抓到了返回值是，也就是。那就说明，确确实实因为的返回值是，的 失败。
、 
继续分析，的核心实现部分在 中，发现在下面的逻辑中都可能返回：
上面的行号，就是出错的地方，那么继续写脚本来监控上面的各个地方：
  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}

  {
    _  \ 
}
在使用执行脚本的时候，如果报错，需要耐心一点，比对行号已经对应的位置上是不是有语句，不然会报错说指定的行数不能。执行后发现，是行开始出错的。也就是说明，跳转到___的地方出错了。
、  

可见，是检查出错了。
、 
在中，继续分析：

一次检查的各个资源组。需要确定具体是哪个资源，也就是出错的时候，的数值。继续写脚本：
  {
      =  {
          \ 
                  = \  
    }
}
复现后发现，出错的时候，的值是。结合_发现，就是在检查的时候发生的错误。
、
 来查看使用的。发现是继续查看：结果是。进程中包含多个线程，在比较多的时候，就容易发生超过限制的问题了。这个问题的 就是限制的问题了。
、 
检查的代码发现，中不支持的配置。的是，在中，还不支持 。所以不支持也不是特别惊奇的事情了。那么就要自己想办法修改一下这个配置了。这个问题到此分析结束。作者：翟翌华

导语
近期研究了一下的强大的性能测试工具，收获颇丰，现简单介绍一下的测试框架。中的很多方法都正在逐步的引入到自研的桌面浏览器性能自动化测试系统中。
一、概述
是一套的性能测试框架，它使用远程调试协议，可实现网页操作的自动化测试，以及获取测试过程中的性能打点数据，生成性能数据报表。支持多个平台，     ，即一个用例可以同时在所有支持的平台上运行。
尽管是一个性能测试框架，但是已经集成了大量测试用例，例如 的性能，流畅度，内存，耗电，冷启热启性能，，绘图性能，性能，线程性能等等。
下载地址：
下面以端浏览器为例，将使用的与之间的基本的通信协议进行讲解。
二、运行环境
  上需要环境，需要安装和两个库。
由于命令中不能有空行，这里将解压到同一目录：执行下的_脚本： _ = =\\即可看到帮助：结果如下：每个就是一个测试用例集，比如执行冷启动用例集的命令如下：
 _ = =\\  = _
三、远程调试协议
      是用，，编写的开发者工具，而    远程调试协议就是它用来与浏览器页面交互和调试的协议通道，然后采用再来与每个页面通信。
协议启动
运行时增加=参数，即在端口打开远程调试通信协议。
可在的快捷方式上增加参数：
也可以命令行方式开启：
\  \\\\ =
然后本机访问，就可以看到打开的页面信息：
操作标签
可以获取标签页的详细信息，以格式返回：
新建标签页命令如下：


激活和删除标签页：


操作页面
每个标签页都有一个，与之连接后可以对页面进行多种操作。
如下脚本为一个示例，浏览器打开后运行脚本，与页面建立连接后：
通过{   { }}请求，访问。
通过_，执行命令监控网页加载完成事件，网页加载完成后获取网页加载速度，类似在 上的执行命令：
通过{   {  ‘       }}将页面向下滚动。
由于需要的库函数，下面的文件放在\\\\目录即可。


所有与页面相关的定义见__文件，这里推荐一个代码在线查看的链接：。
__文件的链接是：
__=__=
使用远程调试协议和可以很轻松的实现的自动化测试。
这里说明一下，对于使用内核的浏览器：浏览器，猎豹和极速浏览器来说，上述的脚本同样适用。
四、性能数据采集方法
 除了上节介绍的_方法执行命令获取性能数据外，提供了功能，能够启动输出预先打点的性能统计点数据。
下面以冷启动脚本为例，
 _ = =\\  = _
启动
冷启动测试脚本启动时增加了=\参数，其中内容为：
{_{_ _  _ }}
_表示哪几类的性能打点需要记录，每个测试用例都是不一样的，冷启动只对的性能数据比较关心。
当然，如果不是启动性能数据采集，可以在脚本执行过程中启动，启动的命令为：{   { ‘’   }}，内容可参考上述。
停止，收集数据
脚本发送{ }后即开始从获取性能数据，在接受到的｛ ‘’｝消息后即表示性能数据传输完毕，详情可以查看文件\\\_\\\\\\_\_中的函数。
收集到的性能数据格式为这里只列了一部分：
{     { }            } {     { }            }
计算性能参数
最终结果为：
每个时间都是从性能打点中计算得到的，比如__就是两个时间点的差想减所得。
中性能数据打点方法
下面显示了代码中对性能输出起始时间的地方，在窗口显示完毕的函数中输出进程启动时间和当前窗口显示的时间，这两个时间差就是从进程启动到窗口显示共消耗的时间。大家也可以使用现有接口，自己定义需要统计性能的点输出。
五、总结
 的性能测试工具功能如此强大，我们正在逐步的将中可用的功能移植到我们浏览器的性能自动化测试框架中，目前已经把远程调试协议移植进来，用来自动化操作和获取命令的返回值。其他的性能测试用例，如，绘图性能用例正在移植中。
大家在做性能测试时，都是通过何种渠道和方式获取到细化后的性能指标的？

相关推荐常用机器性能评估工具分析垃圾信息 图片压缩算法预研报告前言
在使用、的过程中经常会碰到数据倾斜的问题，数据倾斜基本都发生在、等需要数据的操作中，这些过程需要按照值进行数据汇集处理，如果值过于集中，在汇集过程中大部分数据汇集到一台机，这就导致数据倾斜。数据倾斜不仅无法充分利用分布式带来的好处，而且可能导致内存消耗过大超过负载直接导致任务延迟或者失败。本文就是将所有在工作中遇到的数据倾斜的问题及其解决方案进行汇总记录。
一、 少量值重复数量特别多需要
需求：统计_ 中出现的次数，要求这些必须出现在_中
需求很简单，但是很多业务都用到，统计代码如下：
   
      
         
     
     _
      = 

        
     
          
     _
      = 
      

  = 
_数据量只有条而且关于去重，_数据量有一亿条，这个任务在没有优化之前跑了接近一个小时，这是无法接受的，而且查看日志发现有一个运行时长非常久，其他都能够在中之内完成，由此可推断出必然发生了数据倾斜。
 问题的根源及解决方法
不考虑数据本身，从代码层面来分析，有两个地方会发生数据倾斜，但是根本原因只有一个那就是_中某个值大量重复，于是在统计一下_出现次数最多的的，发现确实有一个大量重复，此时有两种解决方案：
如果头部不是业务需要的，直接过滤
如果头部都很多，而且都是业务需要的，考虑加入随机数
如下代码所示：
   
      
         
     
     _
      = 


     
          
     
         
               加入随机，强制将原来一组的拆成多组，增加并发度
              
         _
          = 
           
     
      

  = 
注意：
无论是否使用，小表都需要放入前面，原因是阶段会将第一个表的全部放入内存，当第二个表到来的时候就开始输出；在读表之后第一件事就是尽可能的过滤不必要的数据，理清业务含义先过滤脏数据和业务不相关的数据。
二、少量值重复数量特别多需要
需求：统计_是由、、三个字段组成，但和不是主键，_是和组合作为主键的，需求是找出_满足存在_的组合主键的记录，并求字段的和以及每个单独键出现的次数。
这种需要实际工作中也是经常遇到，由于不支持的条件嵌套子查询，那么解决这个需求最正常的方法是用操作如下：
    _
       _
      
 
       
          
          
     
          
            
         _
    
     
         
                            
              
         _
           
    
      =    = 

 分析问题并解决
这个需求可能导致倾斜的地方有三处：

对_的 
操作
两个 

如果前面两个倾斜会发生，原因也是和案例一是相同的，就是_的和的组合有数量明显大的组合。此时解决方法同相似。但是这里要提出第三种解决方法：
如果头部都很多，而且都是业务需要的，但是的一方是小表可以使用
如下代码所示：
    _
       _
      
 
     
          
          
          
     
          
            
         _
    
     
        注意：不去重直接
         
                            
            
         _
    
      =    = 

注意：

使用第二个表就先不进行 ，因为 会导致倾斜；
注意在新的版本上加入： =  = 这两个参数设置，使得能够生效。

这样肯定可以完全避免数据倾斜，如果之后数据量变得很少，上面两个操作就会很快
如果数据量还是很大两个在一起有一个某些值特别多出现倾斜，此时业务不需要非常精准的去重，可以考虑使用基数估计
 在中有_这个函数，直接取代  _ = __ 即可作者介绍：易固武，腾讯高级工程师，参与腾讯账号安全建设，腾讯数据仓库优化改造，腾讯云数据库等项目，对大规模分布式存储和计算系统有浓厚的兴趣和经历

数据库是目前开源应用最大的关系型数据库，有海量的应用将数据存储在数据库中。存储数据的安全性和可靠性是生产数据库的关注重点。本文分析了目前采用较多的保障可用性方案。
 
 是官方提供的主从同步方案，用于将一个实例的数据，同步到另一个实例中。为保证数据安全做了重要的保证，也是现在运用最广的容灾方案。用两个或以上的实例搭建了主从复制集群，提供单点写入，多点读取的服务，实现了读的 。

图  主从复制集群
如图一所示，一个主实例，三个从实例，通过，生成的，然后发给，将写入，然后将其提交到自身数据库中，实现主从数据同步。对于数据库之上的业务层来说，基于的主从复制集群，单点写入，在同步到后，读逻辑可以从任何一个读取数据，以读写分离的方式，大大降低的运行负载，同时提升了的资源利用。
对于高可用来说， 有个重要的缺陷：数据复制的时延。在通常情况下， 数据复制是异步的，即是写后，发送给并不等待返回确认收到，本地事务就提交了。一旦出现网络延迟或中断，数据延迟发送到侧，主从数据就会出现不一致。在这个阶段中，一旦宕机，未发送到的数据就丢失了，无法做到数据的高可用。
为了解决这个问题，提供了解决方案：半同步和同步复制。在数据异步复制的基础之上，做了一点修改。半同步复制是等待写入的后，再提交本地，保证一定收到了需要同步的数据。同步复制不不仅是要求收到数据，还要求将数据到数据库中，从而保证每次的数据写入，主从数据都是一致的。
基于半同步和同步复制， 的高可用得到了质的提升，特别是同步复制。基于同步复制的 集群，每个实例读取的数据都是一致的，不会存在幻读。同时，宕机后，应用程序切换到任何一个都可以保证读写数据的一致性。但是，同步复制带来了重大的性能下降，这里需要做一个折衷。另外， 的主从切换需要人工介入判断，同时需要的提交完毕，故障恢复时间会比较长。
 
 是社区提供的管理多个服务的扩展。高可用是它设计的主要特性之一。
将两个及以上的实例划分为一个 。其中的一个是主，其余的都是从。 保证访问指定 的数据总是可用的。其基础的数据复制是基于 ，然后，提供了更多的特性：
失效检测和恢复：监控 中的主实例，一旦发现主实例失效，会从 中剩余的从实例中选择一个，并将其提升为主实例。
读写均衡：可以自动的处理一个 的读写操作，将写操作发送给主实例，而读请求在多个从实例之间做负载均衡。

图 

是目前广泛使用的主从复制的高可用方案。设计目标是自动实现主实例宕机后，从机切换为主，并尽量降低切换时延通常在内切换完成。同时，由保证在切换过程中的数据一致性。对的主从复制集群非常友好，没有对集群做任何侵入性的修改。
的一个重点特性是：在主实例宕机后，可以自动的判断主从复制集群中哪个从实例的是最新的，并将最新从实例的差异“应用”到其余的从实例中，从而保证每个实例的数据一致。通常情况下，需要左右检测主实例异常，并将主实例关闭从而避免脑裂。然后再用左右将差异的 同步，并启用新的。整个的时间大约在。
 
 是一个高度可扩展的，兼容事务的实时数据库，基于分布式架构不存在单点故障， 支持自动水平扩容，并能做自动的读写负载均衡。
 使用了一个叫的内存存储引擎来整合多个实例，提供一个统一的服务集群。如图三所示。

图  组成
 由 ，，和  组成。 是应用程序的接口，像普通的服务一样，接受用户的输入，执行并返回结果。 是数据存储节点，  用来管理集群中的每个。
 采用了新的数据分片和容错的方式来实现数据安全和高可用。其由，， ， 构成。
：一张表的一个数据分片，包含一张表的一部分数据。
：一个的拷贝。一个可以有一个或多个，一个的所有数据都是一致的。
 ：的存储载体，每个存储一个或多个。
 ：一个 的集合。

图  数据高可用
一个 有个，被分为了两个。和归属于，和归属于。有一张表被分为个，并分别有两个。和的两个，分别存储在和上，和的两个分别存在和上。这样，对于一张表的一个来说，在整个集群有两份数据，并分布在两个独立的上，实现了数据容灾。同时，每次对一个的写操作，都会在两个上呈现，如果 异常，那么 可以立即提供服务，实现数据的高可用。
小结
本文分析了目前使用较多的几种数据复制和高可用方案，从使用来看， 是使用最为广泛的数据复制方案，因为是原生支持，针对其在不同场景下的一些缺陷，衍生出了半同步复制，强同步复制等数据高可用的方案。
在此基础之上，为了运维方便， 和应运而生，从不同的方向解决了主从切换时数据一致性问题和流程自动化的问题。此外，随着分布式系统架构和方案的逐步成熟。 设计了全新的分布式架构，采用多副本，等特性，支持水平扩展，做到了个的数据库服务质量保证。
参考文献
         
更多数据库文章，请关注腾讯云数据库公众号 

相关推荐   数据加密功能解析 实现简介 管理数据库实例导读：年月日，由腾讯安全科恩实验室主办的“腾讯安全国际技术峰会 ”落下帷幕，本次峰会聚焦安全行业前沿技术，覆盖时下最热的安全议题。在为期两天的议程中，来自腾讯、微软、谷歌等国际工业界和学术界顶级的研究员共带来个安全议题，现场干货满满，堪称一场技术研究人员的盛会。
本篇文章正是选择了的这个热点，全文刊登了腾讯安全平台部总经理关于“技术在信息安全领域的应用”的现场演讲发言。

本篇文章共字 读完大约需分钟
首先跟大家做一下自我介绍，我在安全行业已经工作十几年了，可以说在安全攻防这个领域，我是一个老兵，但是在安全相关的内容上，我觉得我还是一个新人。其实大家担忧会抢去我们工作，这件事情发生或没有发生，或者在某些领域正在发生。
危机
助力安全再上新台阶
作为安全行业来说，我们确实也感受到给我们带来一些实实在在的好处，比如说我们传统的安全领域最常用的，如用密码来鉴别用户身份这个领域。随着技术的到来，其实我们在慢慢让生物识别变成可能，比如人脸的识别，我们这里就使用了很多中图像识别的技术，让这些功能成为可能。
同时，当我们把机器学习的方法用于恶意代码的识别，其实也极大地提升了对恶意代码的对抗和识别能力，我觉得这都是一些积极的变化。但在安全这个领域，我们确实也在学术界发现了很多问题。人工智能应用最广泛的应该是三个领域，第一个是图像识别领域，第二个是语音识别领域，保证自然语音识别，第三个是包括机器学习的通用技术的使用。
的应用也增加了新风险
在图像识别领域，生成对抗网络这块，已经有很多学术界的专家或者学术界的人，他们已经做出一些样例。比如说下面这幅图，这是交通标志的一个图，实际上通过加一些特定的噪点，可以让对方对交通标志的识别出现错乱，进行错误的识别。

而下面这幅图就是在人脸识别领域，这是一个大学的研究团队，他们制造了一个比较特殊的研究，当你带这个特殊眼镜的时候，会引导机器做出错误判断，把自然人识别成自然人，这都是学术界已经开始发现并且指出的一些问题，并且在特定的实验环境上得到了验证。

实战
业务安全 人机对抗
实际上这些学术上的尝试，我觉得都是很积极的，而且他们确实也告诉我们，在我们大量地使用这种机器学习、算法和识别算法的时候，其实我们还是有很多隐患和安全问题是有待解决的，这些隐患是真实存在的。
 所以我觉得这些东西，我们大概是在差不多一年多、两年前也关注到了这些变化，实际上当我们看到各个知识社区，包括安全社区，大家谈到越来越多的人工智能问题，机器学习问题的时候，我们也意识到几个问题：
第一，在实践中更多地去尝试和探讨技术作为实际工作中的一个技术的使用可能。
第二，随着越来越多的业务使用，这种技术、机器学习技术，包括我们也在尝试着使用这种机器学习技术，是否黑客也在尝试使用这种技术。
第三，当我们和业务去使用这种技术用于业务和安全建设的时候，当我们不恰当地使用，或者使用的算法存在某种缺陷，会导致黑客或黑产利用缺陷达成一种攻击，或者取得更高的获利或效果？这是我们的思考，所以在这一年多、两年的时间进行了一些实践，下面我跟大家分享的就是我们一些实践的经验。
 首先我讲的是在业务安全领域的人机识别场景的黑产对抗和应用的情况。腾讯作为中国最大的社交网络，一天大概会受到针对帐号的亿次攻击尝试。尝试成功一个账号，会给他元人民币，换算下来，一天万元人民币大概数字。正是这样一笔获利丰厚的生意，很多技术非常优秀的人投身黑产。而正是因为社交网络背后的价值非常巨大，包括用户的数据、隐私，包括背后所衍生的，比如说电子商务、虚拟财产安全等等，而且这些东西会变成十倍、百倍的利益。正因为有如此大的利益驱动，让从事黑产的人非常有动力投入和进行技术的探索。

时代攻防战场对抗升级
大家经常会听到黑产，黑产到底是什么样？我很难用具体的词汇描述，但跟传统意义的黑客、极客不一样，这种黑产更多是以金钱为目的，而并不是以技术精神达到极致为目的。
上面所说的黑产有几大特点。第一，具备工具化，是以规模化、批量化生产为依托，实际上更像一个小型的工厂或工业体系。而且大家可以看到，这里面有很多配套的硬件设施和设备去支持它。
大家可以看到，右侧插着很多卡的图，这个在国内我们叫做猫池，实际上是一个一个猫，上面插了大量电话卡，可以实现电话卡的拨号，实际上很多体系是基于电话卡来进行自然人识别，但实际上在黑产下完全无效，因为他们有专业的设备和大量的电话卡去使用，完全可以突破这种体系。

黑产工具化
再往下大家可以看到，就是像墙一样放满各种各样手机的设备，实际上在对抗很多自动机的场景下，很多人会觉得，如果我有一些模拟软件的识别，我加上一些协议识别是可以对抗的。现在已经进行到可以构建这样一个墙，装满真实的手机，在上面进行自动化模拟，这里的对抗实际上非常剧烈，而且大家也可以通过这个，这实际是我们抓到的一个黑产团伙，大家可以通过这个团伙看到，对方的武器装备也是非常先进的，对方不仅仅是像我们想象那样，仅仅有大刀、长矛，实际上人家也是有坦克、飞机、大炮的。

黑产智能化
这是我们最终起获的，前面是硬件装备，这是软环境，或者说可以是研发环境的简单陈述。他本身的架构设计还是非常有条理性的，并且有蛮豪华的硬件设施，而且他搭建了一个用人工智能去识别验证码的平台，可以批量化地去攻破这种账号登录体系。当他批量化地登录账号体系时，每攻破一个就可以达到人民币，拿到这笔钱，如果用机器跑一天可以跑多少？一天可以跑上千万次，这是一个非常丰厚的收入回报。

同时，他搭建的这套人工智能体系是基于神经网络的，我们当时查获以后去测试了一下，对市面上几乎所有的验证码识别率很高，也就是对市面上的所有的识别完全失效，这个团伙实现了工业化的进步，用人工智能达到了他这个行业的垄断和霸主地位。我们当时去预估了一下，这个打码平台占到黑产在这个行业攻破自动机的市场份额，可以说是完全垄断了这个行业。
像这种人工智能打码，他跟以前的有什么区别？也有很多是可以做到比较高的识别率，我这里给大家一个很有意思的例子来让大家感受一下，不仅仅是简单的图像识别问题，确实包含一些深层次的智能对抗问题。因为验证码往往是分层的，在这种情况下已经是被识别成比较可能是坏人的情况下，所以这个验证码是比较难于识辨的，或者人类看起来有点费劲，人类肉眼已经比较难识别出这一串字母了。这已经是我们识别高概率，但实际上他的机器还是可以识别到。那怎么办？我们当时使用了一些小技巧，大家可以看到上面的小字是中文，请你按顺序输入第位、第位和第位，目的是为了避免他用人工智能图像识别的技术，把这些字母输入识别出来以后，按顺序直接输出，于是我们调整了一些语义，让他按次序进入，这样我们就可以大家对抗图像识别的能力来进行对抗。

我们用了这个小技巧以后，作为对方使用了神经网络的对抗体系跟我们对抗的时候，他们用了大概是一天半的时间攻破。一天的时间我们观测了一下，从我们自己构建一个蓝军平台看，一天可以做到百分之四五十，就很快了。黑产我们观测了一下，大概在一天半左右，对于这种比较简单语义的，他打开是一天半的时间就可以做到、，所以神经网络对于比较简单的逻辑，比较相对固定的答案，或者逻辑不是很复杂的这种情况下，他的变种能力、对抗能力是非常强的，不仅仅是一个图像领域的对抗问题，他就是智力领域的对抗问题。
这也给我们一个深深的启示，实际上我们传统用于黑客攻防对抗的，不管是攻方还是防御方，你的策略对抗这个领域其实慢慢在分级，也许一些弱的逻辑，一些简单的策略，慢慢机器会越来越有优势，而人类的优势已经不在，人类也许需要 ，才能我们能固守的领域，从现有来看，这就是一个现实的例证。
黑产收益暴增
前面大家看到的机架上的，那套我认为非常奢华的服务器，就是我们起获的。这个所谓的“企业”其实只有个人，他们一天就可以挣到万。这个人里，其实有相当一部分人的收入非常低，因为他们是客服。这人的核心团队里，只有两到三名是最核心的研发和搭建体系的人，这些人是真正的大头。一旦这种技术被扩散和广泛使用，在人机对抗领域，我们面临的挑战是非常大的。

大概是一两年前，我们发现并开始应对、处置了这种问题，在今年各种场合下的安全会议上，包括工业的会议上，大家对人工智能的话题谈的越来越多。黑产学习研究并且付诸于实施和使用的时间已经是在将近三年前了。对手的能力和速度，对技术的执着和进取心，我觉得对我是一个很大的鞭策。
让黑产陷入混沌
我们受这件事的启发，开始反思，在传统领域跟他进行对抗的同时，尝试引入了一些的技术。
下面的这个例子，我们依然是打出验证码，我们根据各种各样的策略信息判断出他使用的是一套平台，但也会犯错，所以我们也在研究在图形、图片领域的缺陷和问题。比如像之前的大会他们提到的，可以进行错误的引导和训练。我们尝试把这种技术用在验证码领域，我们发现在这种技术使用的时候，其实我们可以引导机器去做出错误的识别和判断。比如说验证码，实际上我们引导机器做出了错误的识别，把识别成。这种技术提升了用户的体验，但没有增加用户识别的的难度。

我们有什么办法让不再进行那么高效的识别？我们想到把这套技术加进了中间，并且把我们在尝试识别的验证码里加入了一些代码进行混淆识别，我们发现如果进行适当的算法调整，可以引导的错误识别率提升，所以我认为这里面有一个非常大的研究潜力。因为当技术和机器学习技术进入了攻击这个领域，这个趋势是不可阻挡的，如果你想做好防御和对抗工作，那在这个领域，你保持学习进取和创新探索，就非常必要。
而实际工业上的实践结果证明，经过不长一段时间的探索，这里提升和完善的空间还是很大的。请大家注意，刚才我们看到的验证码实际上尺寸是非常小的，如果我们相对来说有一个比较大的人机对抗的界面和场景，这里的改善空间、完善空间和优化空间会更大。因为比较小的验证码做图像对抗的战场也过小，所以你优化和对抗的空间也会很小。

更多相关内容详见：用怼黑产是一种怎样的体验？下作为一名学生，免不了同学之间传送资料和数据的问题。
由于整个学校相当于一个大型局域网，相互之间传送数据非常快，比如要共享个电影，传点资料什么的。
所以我们可以选择搭建一个服务器来共享文件。
那么问题来了，有的同学会问，我们既然在一个局域网内，直接用传也很快啊，干嘛要搭建服务器？
那么告诉大家，如果两人不能同时在线呢？离线文件？传离线文件不就不走局域网了吗？
还有如果你想一个人给多个人同时发呢？一个一个发？网盘链接？算了吧，等到花儿都谢了都下不完…
所以，明智的选择，服务器。
在学校拥有了一台服务器之后，我可以把自己的资料或者电影放到我的服务器上，分享给同学一个链接，分分钟下载完，当然我们需要在一个局域网才能有那样的速度，这样的话，不用我去开个传，也不用动什么网盘分享，简单粗暴。
接下来我就说一下怎样配置自己的服务器。
我的系统为，所以我选择了利用来配置自己的服务器。
配置这个，为了确保安全，你可以选择使用用户名和密码来登录，也可以直接匿名登录…随你怎么来。
为了方便，我直接设置了匿名登录，这样让别人分享给我东西时，也不需要告诉别人用户名密码，直接拖进去上传就行了，方便快捷，不过安全性嘛，你懂得 这里我只配置了匿名的方式，具体的用户名密码登录的方式，网上的教程也是一大堆。
废话说了一大通了，开始干！配置很简单
首先下载安装
   
然后修改文件
修改如下几行：
为注释的意思，最前面不加就是取消掉它的注释，使之生效
_=    设置匿名可登录
_=        本地用户允许登录
_=        用户是否有写的权限
__=   允许匿名用户上传
___=   允许匿名用户创建目录文件
其他的就不用管了，保存文件。
重启服务器
   
设置完了这些之后，其他人就能来访问你的服务器了。
现在你可以登录你的服务器来尝试一下了。
现在应该能登录进去，但是里面什么也没有。
因为匿名用户默认访问的是你的 文件夹
现在我们需要两个功能，一个用来上传的，一个用来下载的
上传的文件夹，其他人可以上传到这个文件夹，但是不能有删除权限，试想如果有匿名登录进来的给你删除掉了别人好心给你分享的文件还行吗？
下载的文件夹，其他人只能读取这个文件夹，但是不能修改这个文件夹，也就是你要分享给其他人的文件可以放到这里面。
我们在 文件夹新建两个文件夹，一个是，一个是
执行下面的两条指令
    
    
这样就把的权限设置为可读可写，把权限设置为可读不可写。
配置完上面的内容，就大功告成啦，登录服务器后，你就可以看到一个文件夹，一个文件夹。
是不是很简单。
现在下面的事情你就可以实现了：

学校里某个同学有一个非常好看的电影，而你现在又不方便去接受，发网盘又太慢，你就把你的地址扔给他，对他说，你上传到
你的地址 文件夹下吧，我回去的时候取下来看。

你剪辑了一个很不错的视频短片，想分享给学校里的小伙伴，你就可以把它扔到你的服务器 目录下，然后对小伙伴们说，我的视频已经共享了，你们到 你的地址 里面去下载吧。

嗯，只要你配置好了，就能享受局域网高速传输，分分钟搞定


如果配置有问题，欢迎留言与我联系

相关推荐
腾讯云下搭建服务器腾讯云主机环境安装爬虫框架过程腾讯云上配置开发环境详解导语：本次很荣幸能邀请到邵宗文为我们带来《大型网站架构设计及优化》主题分享。邵宗文有多年运营开发、海量运维和架构规划经验，精通海量服务的架构设计和自动化运维建设，目前专注于大数据，高并发的实践探索。
他曾任新浪数据库平台主管，后来负责、新闻客户端、快报，视频，财经，体育等业务的后台数据运维规划工作。
演讲嘉宾：腾讯网络媒体事业群 运维工程师 邵宗文演讲主题：大型网站架构及优化作者：

上周处理了一下群活动的 ，第一步是摆脱 ，捕获异常栈，找到自己是错在哪里 分享一下这个步骤
异步的切入点：
、
 、、
 、、 
 、的事件绑定  、 另外要能、
何时引入切入文件：
最简单的方法是在  引入后立刻做  ， 的切入， 在  加载之后做 ， 的切入。或者在引入之后做所有的切入。但这样无法对进去的代码做切入，比如预加载的代码。既然是移动端，使用____去监听的出现也许是最好的选择
下面是主要的代码：
    _   {                         
          {                                              
             =                  
        }                                                                           
    }                                                                             

    _                               

     打包后 有时候会被封在函数里，可以手动暴露到上             
    _                        

    _    {                                  
            {                                                            
            _                         
            _                    
        }                                                                           
                                                                            
    }                                                                             

     手动接口                                                                     
     = 

需要注意：
、对做切入，一定也要对做切入，使能工作
、切入函数和被切入函数尽量保持一对一，要不然容易出现未知的问题
、、在打包之后不一定会暴露到对象上来，可以手动暴露一下
完整代码：
 {
     _ = {
          {
               === 
        }
          注入
            {
            \ {
                 _ = 
                 =  {
                      =   || 
                     _ 
                }
            }
        }
         监听修改属性
            {
             ____ {
                
            }
            \ {
                  = 
                 如果属性已经存在
                   ==  {
                     =  
                }
                ____ _ {
                     _ ==  {
                         =  _
                    }
                }
                ____  {
                     
                }
            }
        }
    }


      =  {
        
          
         设置一个标志位 跳过这个异常，随后设为
        _ = 
         
    }


    
      包装函数
     
      {
         防止多次包装
         _ || __ {
             
        }
         保持一对一，要不然容易引起未知的问题
         例如 两次 再会有一个无法
         __ {
             __
        }
          =  {
             {
                  
            }   {
                
            }
        }
        __ = 
        __ = 
        ____ = 
         
    }

    
      包装参数中的函数
     
      {
          {
             _    
        }
    }

    
      反包装参数中的函数
     
      {
          {
             _  __  __  
        }
    }

      {
         _ {
             __ || ___ {
                 _
            }
             ___ {
                 ___
            }
              =  {
                  =  
                 _ 
            }
            ___ = 
            __ = _
            ____ = _
             
        }
    }

    _   {
          {
             = 
        }
    }

    _   

     打包后 有时候会被封在函数里，可以手动暴露到上
    _   

    _    {
            {
            _   
            _   
        }
         
    }

     手动接口
     = 
}


原文链接：最近毕设需要学习操作，预先学习了一波。也撰写个文章供各位讨论分享。
安装与配置
大数据这个领域是热火朝天，而 则是一个炙手可热大数据神器。趁着现在还比较有空，赶紧学习方面的东西。
这一小节主要是记录下在 下搭建单机环境的过程。这个过程主要有四个部分：

安装
安装
安装
安装

安装

下载 ，然后解压
    =_
    \\=_ 
       

这里需要解释下为什么这么做：因为我直接从官网上下载的，而官网下载之前需要确认协议，如果直接复制官网下载地址则会出现下载的是个网页的情况。所以只能通过一个带有序号的下载地址下载后再修改文件名了。如果有更好的方法的朋友，请联系我告知。谢谢！ 


配置环境变量
  的环境变量又好几个地方可以配置，我这里配置的是文件。
   _=_
   _={_}
   ={_}{_}
   ={_}{_}

之后重启服务器，或者输入 命令，使环境变量生效，检验有没配置成功
    
    _
       _
          
    
   _


安装
安装过程和的类似，比较简单

官网下载压缩包，然后解压
    
    
       

配置环境变量 
   _=
   ={_}

重启服务器，或者输入 命令，使环境变量生效，测试一下
    
          


安装

官网下载压缩文件。这里我选择的是版本的     解压
    
    
       

配置环境变量 
   _=
   ={_}
  重启服务器，或者输入 命令，使环境变量生效。
  到这里，应该就可以启动，跟着官网上的教程来学了。


安装
安装我参考的是这篇文章手动安装

官网下载解压
    
    
       
    
     

配置环境变量 
   _=
   ={_}

建立启动的脚本
    
    
    

   脚本内容如下，注意的路径
  _=    =
   _   

修改文件权限
     

测试
    
      
          
   
  第一次执行的时候会下载很多东西，然后因为国内你猜到的原因，这一步会比较慢，也很有可能会失败。可以通过如下步骤设置国内的源 ：
   
  在里面输入如下内容：
  
    
    
     __


 不过这个并没有成功，目前来看还是因为你懂得的原因，正在寻找解决方案。 

到此为止，的单机环境就搭建完毕，下一步就是认真地学习了。
初识
这一小节主要介绍下相关语法与操作指南。
 终端
我觉得  非常亲民的一点是它提供了一个交互式的命令行终端，这样用户就可以快速地测试一些命令和语句，而无需每次都保存代码脚本然后调用执行，这对于  和  用户来说是非常顺心的一件事。如果已经将  的  目录加入到了系统路径，那么在系统命令行里输入  就可以进入  的交互式终端了。

如果出现了像图中  这样的提示符，就说明  安装成功。这里的  指的是  编程语言。前面说了， 主要使用  来进行开发，这意味着要最大程度地发挥  的性能，还需要再多学一门编程语言 还支持  和  的接口，但  的语法没有  简洁， 的性能没有  的高。虽然这需要花费一些额外的时间，但好在  的语法非常直观，基本上通过例子就可以模仿写出自己的程序来。
如果对  语言感兴趣，可以参考这份教程来了解其基本的语法。但在这里我们将直接进入正题，用  来跑一个回归的例子。
 例子：回归模型
 的数据分析功能包含在一个称为  的组件当中，顾名思义，这是  的机器学习库，而回归是它支持的模型之一。为了演示例子，我们首先用  生成一组模拟的数据是不是感觉怪怪的，主要是我还没用熟 ：

 = 
 = 
 =    
 = 
 =       
 =  
   =    =   = 
我们将数据保存为  文件，它共有一百万行，每一行有个数，用空格分隔，其中第一个数代表因变量，其余的为自变量。
下面就是一段用  实现的  算回归的程序，其中包括了读取数据，拟合回归，计算回归系数，进行模型预测以及计算  的过程。将这段程序复制到  的终端里，就可以迅速查看输出结果，体验  的基本功能了。
 
 
 
 

  = 

  = {  =
      =    字符串按空格切分
      =     第一个数转成型，是因变量
      = _  其余的转成自变量向量
        把因变量和自变量打包
}



  =  




  = 
  = 
  = 

            




  = _

  =  _
 =     
下面我们来解释一下程序中每一部分的含义。开头到行的是一系列的  语句，目的是使用一些已经封装好的类，与  中的  和  的  语句类似。另外，相信不少读者立刻就能看出这是  风格的导入语句。事实上， 正是基于  而开发的，因此其语法也大多脱胎于 。
第行是读取数据，并将结果赋值给一个变量 。特别需要指出的是，这条语句实际上并没有开始读取文件，而只是建立了数据与程序之间的一种连接。这一点是与  中  最大的不同。
第到第行其实包含了两条操作，第一是调用了  对象的  方法，之后连着的是 方法。 相当于  中的 ，意思是对读进来文件的每一行进行一次变换，然后将结果返回，组成一个新的向量。之所以需要这么做，是因为  读取文本文件时把每一行当作了一个字符串，因此我们需要从这个字符串中解析出我们需要的数据来。语句中被大括号包括的部分其实就是定义了这样一个变换函数，其输入是参数 ，代表传入函数的那个字符串，而输出是一个  对象，它是  中定义的一个数据结构，用来代表一个因变量自变量的配对观测。 方法返回的结果，就是一个长度为一百万，每个元素为  类型的向量。
接下来的  方法是  非常独到的一个操作，它是为了告诉 ，只要内存足够限额可以通过  中的配置文件设置，就将数据放到内存里，以加快后续程序的运算速度。如果内存放不下，就依然保存到硬盘中。这样的好处在于，一方面避免了  把所有对象都往内存放的操作，另一方面避免了  这种重度依赖硬盘，以至于效率低下的情形。
而有趣的是，执行完这一句后，数据其实还没有进行真正的读取。这是因为  采用了一种“延迟运行”的机制，意思是数据只有在真正用到的地方才开始运算，其理念就是，“只要老师不检查作业，我就暂时不写”。基于这个原因，数据只有到了下面  这句需要计算样本量时才真正开始进行读取和变换。
接下来的第到行就是真正拟合回归模型的时候了。 里拟合回归采用的是随机梯度下降法，选用这种算法的原因，一是因为它是一种迭代算法，可以通过设置迭代次数来随时终止计算当然同时会损失一部分精度，这对于大规模的数据是非常关键的，因为通常在这些场合下我们不要求结果非常精确，但却希望计算能在规定的时间里完成。而另一个原因就在于这种算法可以比较容易地进行并行，扩展性较好。
第行中，我们先建立模型对象，然后在、行设置最大迭代次数以及告诉模型应该包括截距项。和行插入了两句获取时间的函数，是为了评估模型训练行花费的时间。
在第行中，我们用拟合出的模型对训练集本身进行了预测。_ 的目的是取出训练集中的自变量部分，而  方法返回的结果就是因变量的预测值向量。
最后的第行，我们利用  为我们封装好的  函数计算了预测值与真实值之间的相关系数_ 与 _ 相对，是取出训练集中的因变量，将它平方一下，就是模型的  值了。

学习资源
下面几个链接我觉得对于  入门是非常有帮助的：

伯克利的  迷你课程
 官方快速入门教程
 官方文档

参考资料与文献

曾梦想仗剑走天涯   单机环境搭建 
 加速下载依赖库的速度 
   
怡然轩 极简  入门笔记——安装和第一个回归程序 


相关推荐
如何正确配置   服务器？
【腾讯云的种玩法】在下搭建个人博客系统
免费体验云服务器，提供最佳上云实践机会作者：马卓
导语 本文介绍了一下自动化分析的方法

由于项目原因，需要批量分析文件，正常的手动分析流程是：

使用载入文件；
等待文件分析完成；
提取其中的信息；
进行决策，如何处理；
关闭，继续下一个；

这种流程对于几个文件可能还不算什么，但是当面对成百上千个文件时，效率就很低下了。因此我开始琢磨如何批量自动化的完成这个操作，这里我想到了。
是使用编写的调用 的工具。按照官方文档的说法，有两种模式：
一种是作为的插件。相信经常使用的同学应该会很熟悉。
而另一种模式则是作为独立的模块存在的。这为我们摆脱实现自动化提供了可能。
当作为独立模块时，安装也很简单只需要运行以下命令即可：    模块会自带这个模块，因此不再需要单独安装。
下面来说一下如何利用这个模块实现自动化。这里涉及到两个和。顾名思义，就是用来载入文件的，是用来关闭文件的。这里需要强调一下的用法，在以后，并没有为这个文件创建相应的对象，而仅仅只是返回了一个，而的各个命令中并没有区分多个文件的参数，因此我们在载入多个文件后再获得其他文件的信息，因此这里我们需要在获得文件信息后，调用方法关闭文件，一来防止内存泄漏，二来防止多次载入信息以后造成数据的混淆。
下面是实现的代码，比较简单，大家可以自己添加代码，打印自己关心的信息，也可以通过方法执行自己的命令。
___=
 
 
 

 
        
          
 
    =
      
     
     
    =
    _= 
       
        _=
        _=
     _
    
 
     =
        
    
        =
        =
         =\\
            =\\
           
               
                   
                      
                    =
                    
                     
 ____==____
   
 下面是效果图：
参考链接：
 文档==
 ==数据可视化的内涵并非只是专业人员才能看得的懂的图表，当你想要通过数据来宣传证明自己时，你遇到的问题是大多数人并不能看懂你的图表。那么让数据可视化的过程更加的生动有趣、通俗易懂就显的尤为重要了。
如何才能让数据可视化在面向普罗大众更容易接受和理解，甚至产生的感觉呢？下面我试着通过一些具体的数据可视化案例来说明。

  
“  ”是之前系列文章中出现过的美国因枪支而死亡的人的网站。在这个案例中，每一条线的灰色代表是一个人原来可以活到多少岁，但因为枪支却提前死亡了，死之前用桔色表现。一开始只是一两条线来让用户说明线条的含义，然后突然加快速度若干线线条一起出现，每条线条的颜色汇集在一起，从而直观的表现出因为枪支死亡的是中青年。
可以想象如果只是用简单一些折线图来表现，对观看者的触动就没到现在这些大，从而达不到提醒人们对枪支管理进行反思的意义。

网络的演变
“网络的演变”是谷歌推出为了说明网络技术与浏览器相互作用，让我们的网络越来越强大的网站。第一条彩带都代表一门网络技术，可以看不同时间浏览器对技术产生不同的影响，特别是手机端和加入后，让网络技术变得越来越强大和复杂。
在这个网站中，横向时间轴的滚动，技术彩带上下飞动，几大浏览器的版本线通贯全场，这都是一般图表所不能表现出来的。如果不用这种方式，可能我们并不能知道浏览器的发展对网络技术的重要性。

  
“  ”是对维基百科最近更新数据的视觉和声音展示网站。用声音表示增加或删除词，不同的音调代表不同的编辑量。绿色圆圈表示未注册的贡献者在编辑，紫色圆圈表示自动机器人在编辑。所有的用户都会产生一些小噪音，而每个编辑者会有一个特别的声音。
用声音来对数据进行展示就是本站的亮点，通过在这里聆听这些声音，那么再在维基百科贡献时就不会再感觉到孤独。更可以吸引新的贡献者参与到编辑工作中来。

    
“    ”反应欧美从到年最流行首歌变化情况的网站。在传统的折线图上加入歌手榜单的动态变化，随着榜单变化，第一名的歌曲也会变化。用户听着音乐声，回忆着一首首老歌，再听一听新歌，对音乐和时间变化的关系更加理解深刻。
榜单变化本是一个简单的事，但加入了音乐做为背景，并随时间产生相应变化。则就是非常有意思的事了，更加令人印象深刻。

       
“       ”是牛津移民观察站为了展示年英国移民数据情况的网站，这里的数据从相关新闻中提取。做本站的意义在于他们想表达支持关于移民的平衡讨论的立场。
可以看出里对数据的表现非常直观，而不是让人看到听到的冷冰冰的数字，在一开始的动画就可以看到约有七百万移民从不同国家来到英国。随后用动态的小点来展示英国各个地区移民数据的情况。

  
“  ”是阐述难民问题的网站，展示难民的时间和地点，以及他们背后政治、经济和社会的复杂故事。通过将历史背景融入到到移民的数据变化中，表达每次危机对人类生活的影响。
通过一开始的数据变化，我们可以发现难民数据竟然是上升的，仅年到年数据下降了，这说明这个世界并不太平。通过点击我们可以发现为了避难，有的人甚至跨过了半个地球。

      
“      ”描绘了第一次世界大战期间英国因战争死亡人员的数据。试图通过可视化的方式来表现战争的残酷。
长长的横向滚动，在浏览时，我们可以看到随着战争的进行，死亡的人数在不断增加，让我们不要忘记历史。


“”是一个跨越亿年历史的交互式时间表，从大爆炸到年。该网站每天从维基百科和自动更新中抽取历史事件，并记录新的事件。用户可以选择观看在特定时间段内发生的各种事件。
不同于一般时间轴表现方式，这个页面用非常多的小方点来表示事件，通过在纵向维度上的堆砌，表现某一时间段的事件。而在页面缩放时，小方点们动态的变化也显的非常有趣。


“”基于年以来所有商业航运而绘制的地图，目的是为用户展示现代商业航运的巨大规模，以及巨型船只在世界各地的路线，还有不同类型的货船的地域分布和他们生产的二氧化碳。
这个网站把所有船舶都展示了出来，而且还可以随着时间而移动，动态的展示一两个船舶的移动不能，难就难在所有船舶的移动都展示了。而且还有带背景音乐的内容介绍，以及地图的说明性游览。


“”分析和可视化了维基百科中争议性条目的讨论情况。这里展示出最长的个讨论。
这里创意的用树的形式来展示这些讨论。当用户对条目建议保留、合并或重定向时，会添加用向左倾斜的绿色线条。而用户建议删除条目时，会添加向右倾斜的红色线条。而随着讨论的进行，线条的长度以及角度会慢慢衰减。

     “     ”使用来自多个星系的数据来构建宇宙网络的多个模型，为星系融合提供了复杂的蓝图。
用交互式可视化可以帮助我们更好的想象宇宙网络，更方便展示模型之间的差异，让我们深入了解宇宙的基本结构。
通过上面这些案例分析，我们可以看出，这些案例首先都会有一个主题，围绕着这个主题对会对数据进行一些提纯，而不是把所有相关数据都罗列让用户自己去找答案。最后就是怎么让数据展示的更加生活和更有交互性了。导语：为了让开发者更高效地开发和发布小程序，微信开发者工具全新改版上线，并新增测试系统、腾讯云工具、运维性能监控、小程序分阶段发布、脚本语言等

—微信开发者工具
为提升小程序开发体验，帮助开发者更高效地开发小程序代码，微信开发者工具全新改版，现面向所有开发者开放。
详情查看《微信开发者工具》

—小程序测试系统
微信开发者工具新增小程序测试系统，可便于开发者检测小程序程序缺陷，评估小程序产品质量。在小程序发布之前，开发者可将小程序代码提交到测试系统，在不同型号的手机真机上运行，执行完毕后自动生成测试报告。
详情查看《测试系统使用说明》

—腾讯云工具
小程序管理后台新增腾讯云工具，可帮助小程序开发者实现腾讯云帐号的开通、代码部署、代码的上传部署全流程。在“公众平台开发者工具”可快速授权开通并自动配置腾讯云环境。可在微信开发者工具上直接编写、调试、发布腾讯云代码。可快速查看服务器状态，便捷升级。
详情查看《腾讯云工具使用简介》

—运维中心新增“性能监控”
为便于开发者及时了解已发布的小程序所出现的异常，公众平台小程序运维中心增加“性能监控”模块，主要功能如下：开发者登录小程序管理后台，在运维中心可查看接口调用情况监控曲线图。开发者可选择需要监控的接口，开启在微信告警群中推送告警通知，便于及时接收告警信息。

—小程序分阶段发布
为便于开发者灵活管理小程序版本，开发者可自定义小程序的发布比例，并在天内逐步提升发布比例。如发现新版本出现问题影响线上服务，可撤销发布。
详情查看《小程序分阶段发布功能介绍》

—脚本语言 是小程序的一套脚本语言，结合 ，可以构建出页面的结构。在微信开发者工具中，在工具栏  项目中开启设置即可使用。
详情查看《脚本语言介绍》背景知识
在建模过程中，当我们需要创建很多细小的物体时，并不会一个个地创建这些物体，而是通过创建粒子，粒子可以模拟很多效果，例如烟花、火焰、雨滴、雪花、云朵等等。提供了各种的粒子系统创建方式。从官网例子的来看，可以总结分为两类，分别是和。
粒子系统的创建
首先看看官网对的解释：

             

也就是说，必须要通过渲染方式来创建重点强调这个是因为官网的中粒子的创建一般通过两种方式和
 =   
粒子系统的创建过程一般可以总结为三步：
创建一个几何对象也可以是外部导入的模型，然后基于几何体自身的顶点集合创建粒子即 将网格转化为粒子，每个顶点将代表粒子系统中的每个粒子。
  =      
创建粒子材质，对应，来实现每个粒子的图案。实现的方式可以是加载图片纹理地址或者纹理，又或者不采用纹理直接创建正方体粒子地址。
  =   {  }  
通过以上两步的创建一个类的物体，这个物体则代表了整个粒子系统。
  =     
下图展示了将一个球形网格模型转化成一个球形粒子系统：

另外，也可以创建一个自定义的几何体为其添加顶点集合。
粒子系统的创建
                 
官网如是说，是一直面向的平面，并且我们可以用其创建基于屏幕坐标移动、定位和缩放的对象，而不影响三维场景中的其他物体做到互不影响必须单独创建一个用于对象的和。另外对象还有一个特点是不能生成阴影。
创建过程：
创建粒子材质如果渲染器是则可以直接引用画布，另外也可以加载图片纹理和纹理。
  =   {  } 
创建粒子
  =    
另外还可以为粒子设置如果将每个粒子设置为一个几何体的每个顶点，则效果和粒子系统相似。
 = 
 = 
 = 
为了方便控制，还可以将粒子加进同一个组内，变成一个粒子系统。
    =       { 表示粒子数目
    
      
}
粒子材质
先说说每个粒子材质图形的创建，一般是通过描绘或通过加载图片的方式来格式化粒子：
直接引用画布，当通过渲染时：
 =  
你可以直接在每个粒子的材质对象里直接引用画布。例如：
画点
  =   
  =     {
    
           
    
}
为每个点附上材质
  =   {
         
     
} 
上文提到，对象只能通过进行渲染，所以和这种方式是无缘了。渲染时的粒子如果需要用实现，则必须加多一步将转化为纹理，在通过属性加载进来。
加载图片纹理：
  =  
  =   
  =   {            } 
从上面的代码可以看到，粒子材质的属性还有很多，详情点击： 和
礼花效果实现
应用上面的知识点，小编做了一个礼花的小，礼花的展示效果大致分为三步：

绽放前，飞线动画向上运动。

绽放出球形礼花。

往下往外坠落礼花消失。


实现过程如下：

创建粒子，在这个例子中小编应用了结合，用画出每个粒子圆点，然后为它们设置初始位置都在同一点。

  =   
画点
  =     {

    
           
    

}
 =  
  

    =       {
    为每个点附上材质
      =   {
             
         
    } 

     =    
     = 
     = 
     = 
     =  =     
    
    
}

飞线动画实现

在每一帧的中，判断每个粒子的坐标小于一定值时，以不同的速度按照正弦曲线的轨迹向上运动，形成飞线动画的效果。
 {     正弦函数
     
}
 =   
  = 
 =       
  =     
    {     控制飞线动画时间
      = 
     {
            {
             =     
             =     
        }            
    }
}
   

绽放效果是结合实现的，在粒子初始化的时候，为了实现绽放时的球形效果，定义了一个球体几何体，得到球体的总顶点数作为粒子的总数，用设置了每个粒子在绽放到最大时的位置，即了相应的球体的顶点位置再增减一些随机数，并设置随机的绽放时间，来达到错落有致的效果。

创建一个球型用作最后的形状
  =      
  = 

    =       {

    
     =    
    

      = 
    为每个点加动画
    
        
        
        {} 
    

      
}
礼花消失，同样是使用

          
           
          {} 
 
展示：地址

整个花的形状：地址

花的形状是用极坐标函数写的：传送门
项目代码地址：

学习心得

在的粒子系统中，每个粒子其实是一张图片或者一个而不是的物体。

当粒子量级非常大时，可以用来代替的顶点，因为它可以将数据存储在缓冲区中，减少数据传递到的成本，同时因为在缓冲区，所以更适合静态的物体。

版本更新了很多次，粒子系统的创建也改了很多次名字，从到到，在学习实例时应注意。本文例子应用的是目前最新的。


参考文章：





《开发指南》


谢谢阅读，如有问题请各位大大指正！接《分布式锁服务关键技术和常见解决方案  上》
、基于分布式一致性算法实现的锁服务
​分析完上述的锁服务方案，可以看到，各种方案核心还是在一致性和可用性之间做取舍。对于锁服务本身的定位和用途而言，其是一个相对中心化，对数据一致性有严格要求的场景。所以在分布式环境下，把数据严格一致性作为第一要求的情况下，算法是绕不开的一个算法“               ”。于是就有了和这类，基于分布式一致性算法核心是和相关变种实现的锁服务。​是由开发实现，在其内部使用的一个分布式锁服务，其核心设计通过论文的形式开源出来。而作为的开源实现版本，由开源社区开发，目前也广泛应用在各种场景下。由于和之间的关系，两者在绝大部分的设计上都十分相似，因此此部分以为例，来分析此类锁服务的相关特点，关于和设计上的差异，在本节最后简要分析。​
 设计细节
​核心架构​​图的系统结构​如上图，一个典型的集群，或者叫 ，通常由台服务器奇数台组成。这些服务器之间采用协议，通过投票方式决定一个服务器作为。一旦一个服务器成为，会保证一段时间其他服务器不会成为，这段时间被称为租期。在运行过程中，服务器会不断续租，如果服务器发生故障，余下的服务器会选举新的产生新的服务器。​客户端通过发现集群的地址，然后客户端会向集群询问服务器，在询问过程，那些非服务器会将服务器标识反馈给客户端，可以非常快的定位到。​在实际运行中，所有的读写请求都发给。针对写请求， 会采用一致性协议将其广播到所有副本服务器，并且在过半机器接受请求后，再响应客户端。对于读请求，服务器直接处理返回。​的一致性协议是算法的工程实现，对于协议本身，由于不是此文的重点，所以此处不展开详细介绍。总体上，可以理解为的一致性协议，可以保证通过写成功之后的数据，最终会扩散到集群内的所有机器上，同时对于多次的写操作，可以严格保证时序无论是挂掉重新选举产生新，还是其中非机器的故障或者是被替换，另外从读取的数据也是最新的数据。而满足这一切要求的前提，只需要集群中的大部分机器可以正常提供服务即可。​每台服务器的基本架构大致分三层：​​图结点的基本架构​、最底层是容错日志系统，通过协议保证集群上的日志完全一致。​、日志之上是类型的容错数据库，通过下层的日志来保证一致性和容错性。​、最上层是对外提供的分布式锁服务和小文件存储服务。数据组织形式​作为分布式锁服务，提供的数据操作接口是类似于文件系统接口风格的接口，这样设计的初衷据说是文件系统操作风格的接口在内部更加符合使用者的习惯。中所有的数据都是以文件结点的形式提供给调用者访问，中典型的结点如下：。​结点分为永久结点和临时结点，临时结点在没有客户端打开或者其子目录下已经为空的情况下自动删除。每个结点都可以设置访问控制权限，同时结点的原数据中有四个递增的位数，用于区分结点在各个方面的修改时序：、实体编号：区分同名结点的先后；、文件内容编号：文件内容修改时自增；、锁编号：锁结点被获取时自增；、编号：变化时自增。​基于文件结点的组织形式，提供的数据操作如下​、：打开文件结点；​、：关闭文件结点；​、：获取文件内容；​、：写文件，可以同时提供文件内容编号，验证文件目前的序号和提供的一致，方能修改；​、：删除文件需要文件无子节点；​、   ：获取和释放锁；​、 ：加锁成功后，获取锁序号；​、 ：检验锁序号是否有效。​
事件机制
​为了避免大量客户端轮询服务器带来的压力，提供了事件通知机制。客户端可以向注册事件通知，当触发了这些事件后服务端就会向客户端发送事件通知。支持的事件类型包括不限于：​、文件内容变化：通常用于监控文件是否被其他客户端修改；、子节点新增、删除、变化：用于监控文件结点的变化；、故障：警告客户端可能已经无法再收到其他事件了，需要重新检查数据；、文件句柄已经失效：通知客户端目前使用的文件句柄已经失效，通常是网络问题。​
 加锁流程
​结合上述的设计细节，中客户端完成加锁的操作序列如下：​、  所有客户端打开锁文件，尝试获取锁。​、  只有一个客户端成功，其他失败。​、  成功的客户端获得了锁，可以写自己的相关信息到文件，其他客户端可以读取到锁持有者的信息可以通过订阅事件，也可以通过加锁失败后去读取结果。​、  获取锁失败的客户端，可以随后轮询再试，也可以通过订阅事件，等待锁释放后的主动通知。​、  加锁成功的客户端从获取一个序列号，然后在与后端资源服务器的通信的时候带上此序列号，后端资源服务器处理请求前，调用去检查锁是否依然有效。有效则认为此客户端依旧是锁的持有者，可以为其提供服务。​的加锁流程看起来十分简单，我们来详细分析下，如何解决之前几种方案碰到的问题：​结点故障，数据的一致性保证​、  故障后，集群内部会通过一致性协议重新发起选主流程，在新产生之前，集群无法对外提供服务，一致性协议保证集群内可以选出唯一的。​、  新当选的结点，由于之前已经在集群中，所以其上已经有绝大部分的数据。而对于暂未同步的数据即新原来作为普通结点，未参与投票的那部分数据，新通过一致性协议从集群内其他结点学习得到。学习完毕后，新开始对外提供服务。整个过程，耗时在之间。​、  对于一台普通结点故障，如果在短时间内恢复，那么其使用本地的一致性日志恢复数据，再用一致性协议和学习未同步的数据，学习完毕后，参与投票。​、  对于一台普通结点故障，如果在长时间都无法恢复，那么使用新的空闲结点替换，替换时使用集群其他结点的一致性日志文件恢复绝大部分数据，剩余的再用一致性协议和学习，学习完毕后，参与投票。​因此，通过一致性协议，解决了单点数据没有多份的问题，同时解决了无法识别缺失数据和学习缺失数据的问题。在可用性方面，只要集群大部分机器正常工作，就能保持正常对外提供服务。在数据一致性和可用性方面，这类方案明显优于前两种方案这本身就是协议的长处。​预防死锁​、  和之间通过保活包维护会话。保活包由定时发起给，收到包之后，可以立即回复有事件需要下发时，也可以等待一段时间，等到快超时前回复，收到回复后，再立刻发起另外一个新的保活包。保活包承担了延长租约和通知事件的功能。​、  当锁持有方发生故障，无法维护。会在租约到期后，自动删除该持有的锁，以避免锁长时间无法释放而导致死锁。​、  另外一个客户端发现锁已经被释放，发起获取锁操作，成功获取到锁。​、  对于同一把锁，每一次获取锁操作，都会使得锁的序列号自增。锁序号是一个位自增的整形。​、  对于锁持有方，每次去访问后续的资源服务器时，都会带上自己的锁序号；而资源服务器在处理请求之前，会去请求验证当前锁序号是否是最新。​、  所以考虑这样一种情况，如果在获取锁成功之后，恢复了，认为自己仍旧持有锁，而发起修改资源的请求，会因为锁序号已经过期而失败，从而保障了锁的安全性。​总结起来，引入了资源方和锁服务的验证，来避免了锁服务本身孤立地做预防死锁机制而导致的破坏锁安全性的风险。同时依靠来维持锁的持有状态，在正常情况下，客户端可以持有锁任意长的时间，这可以确保它做完所有需要的资源访问操作之后再释放锁。这避免了基于的锁对于有效时间  到底设置多长的两难问题。​不过引入的代价是资源方需要作对应修改，对于资源方不方便作修改的场景，提供了一种替代的机制，来尽量避免由于预防死锁而导致的锁安全性被破坏。允许客户端为持有的锁指定一个的时间值默认是分钟。当发现客户端被动失去联系的时候，并不会立即释放锁，而是会在指定的时间内阻止其它客户端获得这个锁。这是为了在把锁分配给新的客户端之前，让之前持有锁的客户端有充分的时间把请求队列排空  ，尽量防止出现延迟到达的未处理请求。​可见，为了应对锁失效问题，提供的两种处理方式：检查和，它们对于安全性的保证是从强到弱的。但是确实提供了单调递增的锁序号，以及资源服务器和的沟通渠道，这就允许资源服务器在需要的时候，利用它提供更强的安全性保障。​
和的设计差异
​、  对于服务读负载的取舍​设计为所有的读写都经过处理，这必然导致的负载过高，因此在端实现了缓存机制。端在本地有文件内容的，端对的维护只是负责让失效，而不持续更新，失效后的，在下一次访问之后重新创建。每次修改后，通过的保活包所以保活包除了有延长租约和通知事件的功能外，还有一个功能是失效，通知每个拥有此的维护了每个可能拥有的信息，让他们的失效，收到保活包之后，删除本地。如果未收到本次保活包，那么只有两种可能，后续的保活包学习到失效的内容，或者超时，清空所有重新建立。所以对机制而言，不能够保证数据的随时最新，但是可以保证最终的数据一致性，同时可以大量避免每次向读带来的网络流量开销和的高负载。​设计采取了另外一个思路，其中可以连接集群中任意一个节点，而不是必须要连接。的所有写请求必须转给处理，而读请求，可以由普通结点直接处理返回，从而分担了的负载。同样的，读数据不能保证时刻的一致性，但是可以保证最终一致性。​、  预防死锁方面​提供了检查和两种方式来避免锁失效带来的问题，引入了资源方和锁服务方的交互来保证锁数据安全性。不过目前还没有类似于的机制，而只有类似于的等待机制来尽量避免锁失效带来的安全性问题。所以在锁失效方面的安全性来说，提供了更好的保证。​、  锁使用便利性方面的差异​和都提供了事件机制，这个机制可以这样来使用，比如当客户端试图创建的时候，发现它已经存在了，这时候创建失败，但客户端不一定就此对外宣告获取锁失败。客户端可以进入一种等待状态，等待当节点被释放的时候，锁服务通过事件机制通知它，这样它就可以继续完成创建操作获取锁。这可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。​但是考虑这样一个问题，当有大量的客户端都阻塞在结点上时，一旦之前的持有者释放锁，那么阻塞的潜在调用方都会被激活，但是大量客户端被激活，重新发起加锁操作时，又只有一个客户端能成功，造成所谓的“惊群”效应。​考虑到这一点，上实现了一个“有序临时结点”的功能，来避免惊群。对于一个临时锁结点，支持每次创建都可以成功，但是每次创建的结点通过一个自增的序号来区别。创建成功最小结点的客户端表明获得了锁，而其他调用方创建的结点序号表明其处于锁等待队列中的位置。所以，对于获取锁失败的客户端，其只需要监听序号比其小的最大结点的释放情况，就可以判断何时自己有机会竞争锁。而不是每次一旦有锁释放，都去尝试重新加锁，从而避免“惊群”效应产生。​
、 结语
​本文通过分析三类分布式锁服务，基本涵盖了所有分布式锁服务中涉及到的关键技术，以及对应具体的工程实现方案。​基于分布式存储实现的锁服务，由于其内存数据存储的特性，所以具有结构简单，高性能和低延迟的优点。但是受限于通用存储的定位，其在锁数据一致性上缺乏严格保证，同时​其在解锁验证、故障切换、死锁处理等方面，存在各种问题。所以其适用于在对性能要求较高，但是可以容忍极端情况下丢失锁数据安全性的场景下。​基于分布式一致性算法实现的锁服务，其使用协议保证了锁数据的严格一致性，同时又具备高可用性。在要求锁数据严格一致的场景下，此类锁服务几乎是唯一的选择。但是由于其结构和分布式一致性协议的复杂性，其在性能和加锁延迟上，比基于分布式存储实现的锁服务要逊色。​所以实际应用场景下，需要根据具体需求出发，权衡各种考虑因素，选择合适的锁服务实现模型。无论选择哪一种模型，需要我们清楚地知道它在安全性上有哪些不足，以及它会带来什么后果。更特别的，如果是对锁数据安全性要求十分严格的应用场景，那么需要更加慎之又慎。在本文的讨论中，我们看到，在分布式锁的正确性上走得最远的，是基于实现，同时引入分布式资源进行验证的方案。​参考​《   》《       》《    》《     》《   》《基于的分布式锁真的安全吗？上》《基于的分布式锁真的安全吗？下》本文作者：  

导语
在网页上绘制图形已经不再是什么新鲜的事情，时不时都能遇到一个炫酷的模型让人感叹未来的无限可能，在某些使用场景下，用呈现内容会更能抓住用户的注意力，新技术如、全景的不断成熟也在加速构建世界的脚步。
技术上我们已经有足够多的手段去实现一个三维世界，比如可以实现变换、动画，  画布可以模拟物体甚至实现的效果。而本文要讨论的相对来说会更加底层，它建立在   嵌入式，一个适用于移动设备的图形标准 之上，对曾经从事过 图形开发的人员来说非常容易入门。
本质来讲仍然是画布的功能，浏览器提供一系列的编程接口来在和的环境中绘制图形。它利用图形硬件  加速绘制，而且直接在浏览器 浏览器的支持情况 中运行不需要额外的插件支持。的绘制代码相对于 来说会显得非常复杂，比如绘制一个矩形， 只需要不超过行代码即可，而利用的话，也许会写出将近行。不过目前有很多有优秀的库来帮助开发者减少重复工作，高效的构建应用比如。本文不会涉及第三方库的使用，利用原生 从绘制基本图形三角形出发，探讨在二维画布上的绘制。
需要提前知道的
学习曲线相对来说比较陡峭，学习人员至少要熟悉和，除此之外还需要了解一点点其他的内容，的将在下文代码中使用到时介绍。

图形基础坐标，视点、目标点、上方向，投影等
线性代数矩阵基础矢量点积、叉积，齐次坐标，矩阵运算，矩阵变换等
  基础语法下文介绍

绘制顶点
这一节，我们仅仅在页面绘制顶点，利用缓冲数组绘制多个点，探讨绘制的过程。 

首先准备文件：
 


   = = =
      浏览器不支持画布
  
  


依然是在 画布范畴，所以在中使用标签，来提供画布上下文。案例中利用了一些工具库来帮助我们把重点放在应用上。接下来在文件中创建上下文。
  {
   获取上下文
    = 

   获取上下文
    = 

   初始化着色器
   _ _

   初始化缓冲
    = 

   清除背景色和颜色缓存
     
  __

   绘制
    
在函数中获取传递给用来获取上下文，看看的主要实现：
  {
    = 
   {
     如果没有上下文，尝试实验版的
     =  || 
  }  {
    
  }

   
}
回到函数中，接下来初始化一个叫着色器的东西。光线照射在材质上产生的效果也就是着色，在中着色分为两种：

顶点着色器：对顶点进行着色
片段着色器：绘制缓存中的片段进行着色
来看看着色器代码的简单实现：

 顶点着色器
 _ =
 `  _
    _
    _
    {
    _ = _
    _ = 
    _ = _
  }`

 片段着色器
 _ =
 `  
    _
    {
    _ = _
  }`
着色器的代码是一种类风格的 着色语言 ，顶点着色器和片段着色器用字符串表示，着色器代码分别用_，_两个变量存储。着色器中可以定义变量，变量一般有三类：

变量：与顶点有关的变量如位置，颜色
变量：与顶点无关的共享变量，在所有顶点、片段中都相同
变量：用来从顶点向片段发送的变量
内置变量：如_、_用来指定顶点、片段的变量顶点着色器中定义了顶点位置，顶点尺寸，还向片段着色器传入颜色属性，片段着色器中  定义了浮点类型数据的精度。

着色器代码需要传入中来初始化着色器，最终得到一个包含顶点着色器和片段着色器的程序对象，这个程序对象附加到上下文中供后面的代码与着色器代码建立关联。
初始化着色器需要步：

创建着色器对象 
把着色器代码载入到着色器对象中 
编译着色器 
创建程序对象 
编译过的着色器附加到程序对象中 
链接程序对象 
调用程序对象 

来看看的具体实现去掉了异常处理：
    {
   分别加载顶点着色器和片段着色器
    =  _ 
    =  _ 

   创建程序对象
    = 

   编译过的着色器附加到程序对象中
   
   

   链接程序对象
  

   调用程序对象
  
   = 

   
}

    {
   创建着色器对象
    = 

   把着色器代码载入到着色器对象
   

   编译着色器
  

    检查编译状态
    =  _
    {
      = 
          
    
     
  }

   
}
接下来建立缓冲保存需要的数据。是一种即时模式，每一帧都需要完全重新绘制，没有提供能保存绘制物体状态的，所以需要代码自己提供对绘制物体状态的保存。在绘制顶点时，把顶点数据以数组的形式存储，这个数组就是所说的缓冲，待绘制的数据都应该在缓冲中定义。同时，为了加快数组的访问速度和减少内存消耗，浏览器专门为引入了缓冲数组 这个新的数据类型。最后将缓冲数组写入到的缓冲对象中。建立缓冲对象：

创建对象 
绑定到缓冲对象上 
向缓冲对象写入数据 

在初始化缓冲数据中，需要完成：

从程序对象中获取相应属性 
向顶点写入缓冲数据 
使用缓冲数据建立程序代码到着色器代码的联系 

  {
   定义顶点数据     
    =  
              
            
             
  

    = 

   创建对象
    = 

   创建对象
    = __

   绑定到缓冲对象上
  _ 

   向缓冲对象写入数据
  _  _

   从程序对象中获取相应属性
   _ =  _
   _ =  _

   向顶点写入缓冲数据
  _       

   使用缓冲数据建立程序代码到着色器代码的联系
  _

  _         
  _

   
}
使用__来获取缓冲数组每个元素的字节长度来帮助从数组中获取需要的数据。数组中存储有顶点位置和颜色信息，将它们都写入_中，方法用来从程序对象中获取属性索引，_和_都是索引值。方法从缓冲中取出数据并写入向程序对象的属性中，参数分别表示指定属性的索引值，指定每一个属性值的长度，数据类型，是否归一化，指定属性字节长度步幅，偏移值，_         表示向颜色属性写入数据，数据长度是个，从第二个开始。补充说明位置信息为   的个分量的向量表示，这样的坐标叫做齐次坐标，将分别除就是空间坐标  ，当为时，，，也就和在空间坐标中的值一样，在写入数据时不指定和的值会默认赋上和，同理，颜色信息使用表示，代码中值没有指定时会默认为不透明。现在最后的工作就是绘制顶点，如果没有指定视口下文介绍的话，视口会被初始化位一个原点在的矩形，矩形高宽为画布的高宽。
 清除背景色和颜色缓存
   
__

 绘制
  
每一次绘制都会清除画布，方法指定清除颜色，方法传入__表示把颜色缓存清除为指定的颜色。调用绘制点类型就可以绘制出三个顶点。
流程
前面的代码虽然还没有涉及三维空间的知识，但是已经大致说明了绘制程序的几个步骤。

获取上下文
初始化着色器
初始化缓冲数据
清除缓存
绘制 在这几步的基础上进行扩充就能实现动画，交互，世界等高级功能。 

在上面的代码中，通过调用多个把模型的绘制信息都传递给后，此时已经拥有了两个可编程着色器，模型如何绘制的信息位置，尺寸等。调用后就绘制出三个不同颜色的定点，这里来介绍一下绘制的流程。
第一个阶段是顶点着色器对顶点进行绘制，在这个阶段定义顶点位置，尺寸信息，可以通过变换矩阵实现绘制对象在场景中的位置转变。
第二个阶段是图元装配，把已经着色的顶点装配成三角形，线段等几何图元。对于每一个图元，还要判断是否位于屏幕上的可见区域可设置中，如果不在可见区域中，则需要删掉，剩下的部分进入下一个阶段。
然后是光栅化阶段，这个阶段就是把图元转换魏一个个片段，然后把片段传递给片段着色器。片段可以先理解为一个像素，但是在逐片段绘制阶段会因为深度、融合等过程而丢弃一些片段，所以中的片段和像素还是有区别的。
第四个阶段是片段着色器阶段，通过输入或是自定义片段信息颜色，坐标系等绘制出每一个片段，在上面的代码中，颜色通过变量传入，再进行线性插值得到当前片段的颜色。片段着色器需要指定浮点类型数据的精度，  。
写入绘制缓存前的最后一个阶段是逐片段操作，这一步包含几个可设置启动禁用的子操作。比如深度测试缓存可以对片对值进行比较，决定是否丢弃片段，融合操作可以将传入片段的颜色如已经在颜色缓存中的片段进行组合，一般用在透明对象中。
图形绘制
在前面的代码中，已经绘制出了三角形的三个顶点，并且这三个顶点的值都为，那么怎么绘制一个二维平面的三角形呢？只需要简单修改之前的代码。
 绘制
  
将绘制这一步的的第一个参数由修改为即可。在中有两个方法绘制缓冲数据： 
要使用方法，需要将对象由方法创建绑定到_上，然后把数据写入到对象中，在激活连接 后就可以按顶点的顺序依次绘制。
  该方法有三个参数，表示要渲染的图元类型，它包括点 绘制顶点线 顶点，按 的顺序绘制线_ 顶点，按   的顺序绘制线，最终是一个_ 顶点，按  的顺序绘制线三角 将顶点绘制成三角形_ 绘制成三角带，比如   绘制成  和  的多边形_ 绘制成三角扇形，比如   绘制成  和 扇形表示开始缓冲数组中哪一个点作为起始的顶点，表示总共需要绘制的顶点数。该方法在有多个共享顶点的情况下可以增加顶点的重用程度，按照顶点索引的顺序来绘制相应的图元。利用包含顶点数据的_，还要使用一个顶点数据索引的缓冲__。顶点的绘制顺序有这个索引来决定。   参数与前面方法的一样，定义了要绘制的图元类型。定义__上的索引数量。是索引的类型，一般指定为_或_。是索引的偏移量。回到代码中，要绘制一个三角形就可以采用三角形图元来绘制，也可以试试其他图元，看看能绘制出什么样的图形。现在来试一下矩形怎么绘制，在之前代码的基础上，需要增加一个顶点，利用基本三角就可以绘制出。如图所示，使用图元类型为_，，，和，，两个三角形就可以组成矩形，修改顶点数组：
  =  
            
          
           
           


  = 
前面介绍的绘制方法又是什么使用的呢？现在尝试使用和顶点索引绘制一个多个六变形组成的图形。这个像蜂窝的图案由个正六边形组成。首先依次计算出个六边形的中点图案放入中心点数组中，然后遍历这个中心点数组，结合六边形的宽高，得出每一个顶点的坐标：

       
         
         
       
         
         采用图元绘制图案，对于每一个六边形，顶点索引是           ，然后将索引写入绑定在__上的中，使用方法绘制出来。

 六边形宽高
  = 
  =     
 顶点数组
  = 
 索引数组
  = 
 中心点坐标
  = 
         
   
         
         
   
         


  = {
  
                  
                   
                    
                  
                    
                    

    _  = {
                 
    }
}


  =  

  =  

  = 
  = 

_ 
_  _

 写入__
__ 
__  _


 绘制
  _ 
利用_或_还能有更高效的绘制方案。
着色器语言  
着色器代码用 编写，从来源看，是着色器语言的一个功能简化版，本来的目标是嵌入式设备，因此简化的 相对来说占用更低的硬件消耗和更少的性能开销。语法上，语法与语言非常类似，基础的变量，赋值，类型转换，代码执行次序都与语言相同，并且在矢量和矩阵运算上提供很多的简便方法，非常适合图像处理，这里介绍一些在编写着色器代码时可能遇到的特性。
变量
 中有全局变量和局部变量的概念，在之前的代码中，声明在函数外的__在函数之外，他们都是全局变量，声明在函数内部的变量就是局部变量。之前我们用，来修饰变量，它们都叫变量的限定字，除了上面提到的，存储限定字还有和。

和中的概念一样， 中的限定字表示修饰的变量的值不能被改变，并且声明同时就要初始化。比如   =    。再改变的值就会报错。

只会出现在顶点着色器中，只能被声明为全局变量，用来表示与逐顶点相关的值，比如顶点的坐标。

可以出现在顶点着色器和片段着色器中，只能被声明为全局变量，它表示顶点或偏远共用的数据，比如顶点的坐标都共用一个变换矩阵，那个变换矩阵就可以声明为：  。

与一样，也只能被声明为全局变量，它是将顶点着色器中的数据传递给片段着色器，只需要在两种着色器中都声明同名，同类型的变量。顶点着色器的变量经过光栅化的过程，对其进行内插得到的结果再传递给片段着色器。
新引入了精度限定字，给每种数据都设置精度，帮助着色器提高运行效率，减少内存开支。支持三种精度高精度，顶点着色器的最低精度，中精度，片段着色器的最低精度和低精度。比如  指定变量具有高精度。在片段着色器代码中，用  来为浮点型数据都制定中精度。如果没有单独指定精度，都会采用数据类型的默认精度，但是片段着色器的类型没有默认精度，所以需要手动指定。
取样器
 支持一种叫取样器的类型，通过该类型的变量可以访问纹理。取样器有两种类型：和。取样器是共用的数据，所以被限定为变量。后续文章介绍纹理时会演示它的使用。

 同样支持的程序流程控制和语言很相似，同样可以通过语句来控制循环。在使用循环时，除了语言中就有的和控制语句外，还有一个。在片段着色器中被使用，当它被调用时，表示放弃当面片段，直接处理下一个片断。比如要绘制圆形的点：
  {
     计算片段到点中心的距离
      = _  
       {
         绘制红色片段
        _ =    
    }  {
         放弃绘制
        
    }
}
函数
函数的定义也接近语言，除了自定义函数外，提供很多内置函数来帮助处理图片，比如计算内积，变量归一化，获取纹素等。
矢量和矩阵矢量和矩阵常用来处理计算机图形，在中，用，，来变数具有相应后缀数子的浮点元素的矢量，表示矢量元素类型为整形数，同理，表示元素类型为布尔值。，，分别表示，，的浮点数元素矩阵。在矢量和矩阵赋值的时候要注意元素类型和数量的一致。比如  =    。也可以使用矢量的组合来赋值给一个新的矢量或矩阵，比如：  =     =     =  也就是，，，。也可以构成矩阵，比如：  =  
矢量的访问可以用运算符。用来访问顶点左边分量，  =     表示 ，表示。同时多个分量共同放在点运算符后可以取出多个分量，也就是混合： 表示 ，，。除此之外，颜色分量可以用，，，来访问元素，纹理坐标可以用，来访问。对于一个的矢量来说，，，都可以访问第一个元素。
和的数据类似，矢量和矩阵也可以用运算符访问。矢量中，运算符中的数值表示索引值，矩阵中，第一个表示列数，第二个表示行数。
支持矢量、矩阵的运算，矢量和矩阵的可以直接用操作符指定运算，运算遵循线性代数中的矩阵运算基本规则。
总结
在开始绘制三维图形之前需要熟悉的图形的绘制，关于纹理贴图，光照等内容等下一篇再介绍吧。

原文出处：社区 未经同意，禁止转载程序为什么容易出现
这个是因为 系统对  的   作了硬性限制，当  进程申请的  空间超过阈值时，就会抛出异常这个阈值可以是 、 、 等，视机型而定，可以通过   或者   查看此值。
也就是说，程序发生  并不表示  不足，而是因为程序申请的   对象超过了   。也就是说，在  充足的情况下，也可能发生  。
这样的设计似乎有些不合理，但是  为什么这样做呢？这样设计的目的是为了让  系统能同时让比较多的进程常驻内存，这样程序启动时就不用每次都重新加载到内存，能够给用户更快的响应。迫使每个应用程序使用较小的内存，移动设备非常有限的就能使比较多的常驻其中。
进程内存空间和  之间的关系
进程的内存空间只是虚拟内存或者叫作逻辑内存，而程序的运行需要的是实实在在的内存，即物理内存。在必要时，操作系统会将程序运行中申请的内存虚拟内存映射到，让进程能够使用物理内存。
中的进程

进程：采用实现，不包含实例的进程，目录下面的程序文件运行后都是以进程形式存在的。
进程：实例化了  虚拟机实例的  进程，进程的入口  函数为  函数。 虚拟机实例的宿主进程是调用创建的  进程，所以每一个  上的  进程实际上就是一个  进程，只是进程中多了一个  虚拟机实例。因此， 进程的内存分配比  进程复杂。 系统中的应用程序基本都是  进程，如桌面、电话、联系人、状态栏等等。
解释一些字段的意思：

    虚拟耗用内存包含共享库占用的内存

    实际使用物理内存包含共享库占用的内存

    实际使用的物理内存比例分配共享库占用的内存

    进程独自占用的物理内存不包含共享库占用的内存


一般来说内存占用大小有如下规律： =  =  = 
中进程的堆内存

进程空间中的空间是我们需要重点关注的，空间完全由程序员控制，我们使用的、  和  所申请的空间都是空间，  申请的内存空间在   中，而  申请的内存空间则在  中。
如何应对不足
 程序发生  并不是表示  不足，如果  真的不足，会发生什么呢？这时  的   会起作用，当  所剩不多时，  会杀死一些优先级比较低的进程来释放物理内存，让高优先级程序得到更多的内存。
应用程序如何绕过 的限制
创建子进程
创建一个新的进程，那么我们就可以把一些对象分配到新进程的上了，从而达到一个应用程序使用更多的内存的目的，当然，创建子进程会增加系统开销，而且并不是所有应用程序都适合这样做，视需求而定。
使用在 上申请空间
 的增长并不受  的限制，只要有剩余空间，程序员可以一直在 上申请空间，当然如果 快耗尽， 会杀进程释放。大家使用一些软件时，有时候会闪退，就可能是软件在层申请了比较多的内存导致的。

相关推荐深入浅出腾讯云：缓存篇缓存系统在游戏业务中的特异性今天碰到一次因死锁导致更新操作的事务执行时间过长，特将排查过程记录如下：
首先该事务的条件已经命中了主键索引，而且表也不大，故可以排除扫表过慢原因。通过  发现也只有该事务在操作这个表，初看起来似乎也不像是死锁的原因：

但通过咨询后发现，判断事务是否死锁不能简单通过 来判断，而是要通过查询锁的相关表来确定，和锁有关的主要有三个表，
_          当前运行的所有事务
_        当前出现的锁
__   锁等待的对应关系
上面表的各个字段的含义如下：
_
——————————————–—————
|        |                 |  |  |  |  |
——————————————–—————
| _     |          |    |     |         |       |锁
| __ |          |    |     |         |       |拥有锁的事务
| _   |          |    |     |         |       |锁模式
| _   |          |    |     |         |       |锁类型
| _  |        |    |     |         |       |被锁的表
| _  |        |   |     |     |       |被锁的索引
| _  |   |   |     |     |       |被锁的表空间号
| _   |   |   |     |     |       |被锁的页号
| _    |   |   |     |     |       |被锁的记录号
| _   |        |   |     |     |       |被锁的数据
__

|  |  |  |  |  |  |

| __ |  |  | | | |请求锁的事务
| __ |  |  | | | |请求锁的锁
| __ |  |  | | | |当前拥有锁的事务
| __ |  |  | | | |当前拥有锁的锁

_ 
———————————————————–—————————
|  |  |  |  |  |
———————————————————–—————————
| _ |  |  | | |事务
| _ |  |  | | |事务状态：
| _ |  |  | | |事务开始时间；
| ___ |  |  | | |__
| __ |  |  | | |事务开始等待的时间
| _ |   |  | | |
| ___ |   |  | | |事务线程
| _ |  |  | | |具体语句
| __ |  |  | | |事务当前操作状态
| ___ |   |  | | |事务中有多少个表被使用
| __ |   |  | | |事务拥有多少个锁
| __ |   |  | | |
| ___ |   |  | | |事务锁住的内存大小
| __ |   |  | | |事务锁住的行数
| __ |   |  | | |事务更改的行数
| __ |   |  | | |事务并发票数
| __ |  |  | | |事务隔离级别
| __ |  |  | | |是否唯一性检查
| ___ |  |  | | |是否外键检查
| ____ |  |  | | |最后的外键错误
| ___ |  |  | | |
| ___ |   |  | | |
可以通过   _    _   __=_  ___=线程 来获取该的锁状态，线程可以通过上面的 来获得，执行结果如下：

此时发现，该连接确实处于 锁等待状态通过   __  __=即上面查询得到的__可以得到当前拥有锁的事务 。

再通过   _  __=获取语句与线程

从上面的结果中看出，该事务处于状态，但却为，该线程即对于上面 的机器的端口的连接，该连接处于状态。为什么为却依然占有锁？在查询相关资料和咨询后，知道了这个实际和 引擎的写机制有关，执行写事务操作时，实际是先取得索引中该行的行锁即使该表上没有任何索引，那么会在后台创建一个隐藏的聚集主键索引，再在缓存里写入，最后事务后正式写入中并释放锁。之所以为，是因为该连接已经把 操作执行写入缓存中了，但是由于代码没有最后，导致一直占用着行锁，后续新的连接想写这一行数据却因为一直取不到行锁而处于长时间的等待状态。
那为什么需要两次写？下面是我查询相关资料得出来的结论
因为中的日志是逻辑的，所谓逻辑就是比如当插入一条记录时，它可能会导致在某一个页面这条记录最终被插入的位置的多个偏移位置写入某个长度的值，比如页头的记录数，槽数，页尾槽数据，页中的记录值等等，这些本是一些物理操作，而为了节约日志量及其它一些原因，设计为逻辑处理的方式，那就是它会在一个页面的基础上，把一条记录插入，那么在日志记录中记录的内容为表空间号、页面号、记录的各个列的值等等，在内部转换为上面的物理操作。
但这里的一个问题是，如果那个页面本身是错误的，这种错误有可能是因为写断裂个页面为，分多次写入，后面的有可能没有写成功，导致这个页面不完整引起的，那么这个逻辑操作就没办法完成了，因为它的前提是这个页面还是正确的，完整的，因为如果这个页面不正确的话，这个页面里的数据是无效的，有可能产生各种不可预料的问题。
那么正是因为这个问题，所以必须要首先保证这个页面是正确的，方法就是两次写，它的思想最终是一种备份思想，也就是一种镜像。
两次写的过程：
可以将两次写看作是在表空间内部分配的一个短期的日志文件，这一日志文件包含个数据页。在写出缓冲区中的数据页时采用的是一次写多个页的方式，这样多个页就可以先顺序写入到两次写缓冲区并调用保证这些数据被写出到磁盘，然后数据页才被定出到它们实际的存储位置并再次调用。故障恢复时检查缓冲区与数据页原存储位置的内容，若数据页在两次写缓冲区中处于不一致状态将被简单的丢弃，若在原存储位置中不一致则从两次写缓冲区中还原。声明

作者：本文的 “我们” 所指的是谷歌，本文为翻译文章。

前言
抽象的视觉传达是人们彼此之间交流的一种方式，占着交流方式的主要一部分。从小的时候开始，孩纸们就可以通过简单的描绘来形容一个具体的物体或者描述他们的心情，但是他们所画的东西不像照片所拍摄的一样与现实事物一样，但是它可以告诉我们一些关于人们如何代表和重建周围世界图像的方式。

 图 ：  矢量绘图 
正文
在谷歌最近的论文“     ”中，提出了一种能够产生普通物体草图的生成式复现神经网络，其目的是训练机器人以和人类相似的方式绘制和概括一些抽象概念，在手绘草图训练模型，每一个笔：移动方向、什么时候抬起笔、什么时候停止绘画，在这个过程中，他们创建了一个可能有着诸多应用的程序模型，从辅助创作家创作到帮助学生绘制。
虽然现在已经有大量使用神经网络的图像生成建模工作，但大部分工作着重于对网格像素的光栅图像进行建模，虽然这些模型均能生成一些逼真的图像，由于网格像素的高维度，它们的关键是生成具有相干结构的图像，比如它们可能会生成拥有只或者更多眼睛的猫、拥有多个头部的狗。

用 数据集训练，使用以前的模型产生的身体部位数量错误的动物的例子，        
在本文中，我们研究了一个基于人体绘制的低维向量的表示，我们的模型，是基于序列到序列自动编码器框架。 它包含变分推理，并将超网络用作复发神经网络单元。自动编码器的目标是训练网络将输入序列编码为浮点数的向量，称为潜向向量，并且从该潜矢量使用解码器来重构输出序列，该解码器尽可能复制输入序列 。

图 ： 原理图 
在我们的模型中，我们刻意的在向量中添加噪声，在我们的论文中，我们表明，通过将噪声引入到编码器和解码器之间的通信通道中，该模型不能够准确地再现输入草图，而是必须学会将草图的本质捕获为嘈杂的潜在向量。我们的解码器采用这个潜在的向量，并产生用于构建新草图的一系列运动动作。 在下图中，我们将几个实际的猫的草图提供给编码器，以使用解码器产生重建的草图。

图 ： 猫草图的重建 
强调：
重建的猫草图不是输入的草图的副本，而是与输入具有相似特征的猫的新草图，为了证明该模型不是简单的复制，并且实际学到了一些关于人们绘制猫的方式，我们可以尝试将非标准的草图提供给编码器：

当我们提供一只拥有只眼睛的猫作为输入草图时，该模型产生了一只两只眼睛的猫，这表明我们的模型已经知道了猫通常只有两只眼睛，为了表明我们的模型不是简单的从大量记忆猫草图中选择最接近正常猫，所以我们尝试输入不同的东西，如牙刷草图，我们看到了该编码器产生了一个像猫的形状，长满胡须，模仿牙刷的特征和方向。这表明网络已经学会将草图编码嵌入到潜在向量的一组抽象猫概念，并且还能基于这个潜在向量构建全新的草图。
如果不相信我们可以重复一次对猪草图训练的模型，并且得出类似的结论，当出现一只有只脚的猪时，该模型生成一只只有四条腿的猪，如果在这个输入草图中再加入卡车，我们会得到一直看起来像卡车的猪。

图 ： 猪草图的重建 
为了研究这些潜在载体如何编码概念动物特征，在下图中，我们首先获得两个非常不同的猪编码的两个潜在载体，在这种情况下，猪头绿色盒子和一头满完整和猪橙色 框。 我们想知道我们的模型如何学习代表猪，一种方法是在两个不同的潜在向量之间进行插值，并从每个内插潜在向量中可视化每个生成的草图。 在下图中，我们可以看出猪头的草图如何缓慢地变成全猪的草图，并在此过程中展示了模型如何组织猪草图的概念。 我们看到，潜伏矢量控制鼻子相对于头部的相对位置和大小，以及草图中身体和腿部的存在。

图 ：潜在空间插值生成的一个模型训练猪草图 
我们还想知道我们的模型是否可以学习多种动物的特征表现，如果可以，会是什么样子？ 在下图中，我们通过在猫头和一只完整的猪之间插入潜在载体产生草图。 我们看到这个表现如何从猫头，一只尾巴猫到一只胖胖的身体的猫，慢慢地变成一只全猪。 像一个学习绘画动物的孩子一样，我们的模型通过将头，脚和尾巴附着在身上来学习建造动物。 我们看到，该模型还能够绘制与猪头不同的猫头。

图 ：猫和猪一起作为输入草图训练图
这些插值示例表明潜在的矢量确实对草图的概念特征进行了编码。 但是，我们可以使用这些功能来增加没有这些功能的其他草图  例如，向猫添加一个身体？

图 ：使用潜在的向量算法探索抽象概念之间的学习关系
事实上，我们发现草图绘制类比是可能的，我们的模型训练猫和猪草图。 例如，我们可以从完整猪的潜在载体中减去编码猪头的潜在载体，以获得代表身体概念的载体。 将这种差异添加到猫头的潜在载体中会产生一只完整的猫即猫头身体=完整的猫。 这些绘图类比使我们能够探索模型如何组织其潜在空间，以便在生成的草图的多边形中表示不同的概念。
创意应用
除了这项工作的研究部分，我们对草图的潜在创意应用也感到非常兴奋。 例如，即使在最简单的用例中，模式设计人员也可以应用为纺织品或壁纸打印生成大量相似但独特的设计。

图 ：由单一输入草图绿色和黄色框生成的类似但独特的猫
如前所述，如果给出卡车的输入草图，则可以制作一个训练成猪仔的模型来绘制猪式卡车。 我们可以将此结果扩展到应用程序，这些应用程序可能有助于创意设计师提出可以与目标受众更多共鸣的抽象设计。
例如，在下图中，我们将四把椅子的草图放入我们的绘图模型中，生产四只椅子般的猫。 我们可以进一步，并结合前面介绍的插值方法来探索座椅猫的潜在空间，并产生一个大的网格生成的设计来选择。

探索不同对象之间的潜在空间可能使创意设计师能够找到有趣的交叉点和不同图形之间的关系

探索生成的日常物品草图的潜在空间
从左到右的潜在空间插值，然后从上到下
我们也可以使用的解码器模块作为独立模型，并对其进行训练，以预测不完整草图的不同结果。 这种技术可以让应用程序通过提供完成不完整草图的替代方法来协助艺术家的创作过程。 在下图中，我们绘制不同的不完整草图红色，并使模型得到不同的可能方式来完成绘图。

该模型可以从不完整的草图垂直线左侧的红色部分草图开始，并自动生成不同的图像
我们可以进一步把这个概念，并有不同的模型完成相同的不完整素描。 在下图中，我们看到如何使同一个圆圈和方形图成为各种蚂蚁，火烈鸟，直升机，猫头鹰，沙发甚至油漆刷的一部分。 通过使用训练有素的多种模式来绘制各种对象，设计人员可以探索创造性的方式来向观众传达有意义的视觉信息。

使用训练了不同对象的模型 预测圆和矩形中间的结尾
这些模型将使许多令人兴奋的新的创意应用程序在各种不同的方向。 他们也可以作为一个工具来帮助我们提高对自己创意思维过程的理解。 通过阅读我们的论文“     ”，了解更多关于的信息。
致谢
感谢 ， ， ， ， ， ， ， 对这个项目的帮助。 这项工作是  计划的一部分。

相关推荐
深度学习平台谷歌开源图片压缩算法实测体验报告为什么要做电量测试
随着移动互联网的快速发展，手机的实用性、娱乐性越来越强。日常使用中发现，安装了应用后，即使不怎么使用，电量也会消耗很快。但如果恢复出场设置充满电后，手机可以待机很长时间。真相只有一个：手机耗电的最终元凶是软件。
在各大应用市场中搜索“电量管理”相关应用，每个应用都有几万到几十万次的下载量。这说明，越来越多的用户开始关注应用电量问题。所以，在研发阶段，有效的检测和定位电量问题，是十分重要的工作。
如何能够有效的检测和定位应用的电量问题呢？可以从两个方面入手：一方面，从手机系统入手，了解对应用电量消耗的统计原理，进而从代码层规避不必要的电量消耗。另一方面，从应用本身入手，在保证用户体验的前提下，尽可能减少不必要的操作。
下面分享下，在对应用电量优化过程中所做的专项测试工作。
业界通用的电量测试方法

小结：可以看出，目前业界现有的电量测试方法很多。除了借助于其他设备监测整机电量消耗的硬件测试方案外，系统也提供了各种获取应用电量消耗的方法。
方法各有优势。但，都是定位于获取整体电量消耗整机、应用。对于开发和测试人员最关注的问题：有效定位导致应用电量消耗的具体原因，仍然无法解决。
我们需要的电量测试
在产品研发阶段，能够快速获取应用电量消耗，准确定位问题原因的测试方法，是开发和测试人员最需要的方法。所以，从年初开始，我们确定了电量测试工作的开展方向：
、理清原理：系统电量统计原理；
、调整策略：关注整机的硬件测试方案替换为关注的软件测试方案；
、准确定位：获取更详细的数据；
、提升效率：自动化电量测试方案建设。
理清原理
在对业界现有测试工具的了解中，我们发现提供了对应用电量统计的系统工具“耗电排行”。通过解包源码并反编译，找到了系统对应用电量消耗统计的接口：之后类名中的方法。该方法中统计了系统对应用各部分的电量消耗：

在解读源码的过程中，发现了一个有意思的文件_。该文件中列出了手机厂商针对机型硬件定义的单位时间元器件电量消耗值。由于文件内容的差异，从而导致了，同样的应用、同样的操作场景、同样的外界环境，在不同手机上电量消耗不同。

不同手机_文件
小结：通过解读源码，掌握到系统对应用电量消耗的统计方法。如果可以在测试过程中获取到组成应用整体消耗的各部分的消耗值，就可以大体定位到问题方向。
调整策略
硬件测试采集的是整机的电流值，由于外接干扰因素的影响其他应用、手机环境、网络环境、人为因素等，经常导致的测试结果是：数据波动大、无法定位原因。并且，随着手机硬件、外观的调整，越来越多的机器无法自主拆卸电池，而厂商对内置版本的电量要求却越来越严格。目前现有的硬件测试方案，无法继续满足在研发阶段对应用电量的有效保障。
既然系统已经提供了对单个应用的电量统计应用，我们就可以利用源码并结合实际的需求，对已有的系统工具进行二次开发，通过软件的方式完成对单个应用耗电量的测试。
准确定位
理清了系统对应用的电量统计原理后，我们发现“耗电排行工具”并没有详细输出组成应用总体电量消耗的每一部分的消耗值。所以，在解决“准确定位”的问题上，首先能够做的工作就是进一步细化数据。
“工欲善其事必先利其器”。
我们开发了以下两个工具，支持获取更详细的数据。
【工具一：】
该工具是对系统“耗电排行工具”的二次开发。使用系统计算公式和进行计算。相比较原工具，完善以下几个特性：
、数据展示：除了展示组成应用总体电量消耗的每一部分的消耗值，同时显示使用时长、次数及数据传输量信息； 
、传感器细分；
、展示_；
、提供定时测试功能。

【工具二：】
通过日常监控和用户反馈发现，导致应用电量消耗升高的最常见问题是问题：

华为手机用户反馈电量问题

日常监控电量异常升高问题
依据操作系统的概念—进程是由一个或多个线程组成，可以将“准确定位”问题进一步细化到获取线程的时间片消耗。
为了能够在电量测试的同时进行时间片数据的采集，并尽可能减少其他消耗的引入，我们开发了一个手机端的数据采集工具：。原理如下：

工具具备以下几个特性：
、广播作为工具驱动方式，方便应用于自动化脚本控制；
、数据源取自系统：权威、详细；
、多样的采集模式：频繁模式、触发模式。
优势： 
、安装使用无权限要求；
、可与电量测试同时进行；
、数据取自系统保证准确性；
、触发模式保证了最小性能消耗。
小结：目前，工具已经应用于多个移动端应用的电量测试中。除了可以高效定位电量问题外，还可以在功能开发前预估电量消耗，从产品层协助策略制定。通过自研工具的开发，有效的将原有的硬件测试方案替换成关注应用电量消耗的软件测试方案。自研工具获取的数据，全部来自于系统提供的接口，保证了数据的准确有效性。
 提升效率
通过测试工具的开发，在一次电量测试过程中，已经能收集到帮助定位问题的足够详细的测试数据。所以，我们下一步需要思考的就是，如何能够更加高效更加精准的获取测试数据？原有的电量测试流程：

存在的问题：
、人工操作：设备连接、环境清理、应用安装、工具设置、初始数据采集；
、人工操作：设备断开、场景操作执行、计时；
、人工操作：设备连接、数据采集保存。
人工干预每个环节导致：数据准确性低、执行效率低。
各环节的优化方案：
数据采集：脚本驱动测试工具 替代 手动执行命令行；
操作执行：自动化脚本 替代 手工操作；
流程控制：控制 替代 人工控制。

优化后的电量测试流程：

解决需人工连接设备的问题：将传统的线中间增加硬件控制模块后，可由端的脚本控制硬件的断开连接。
解决连接断开后场景操作的执行问题：传统的解决方案：将自动化脚本放到手机端执行。
存在的问题：手机必须要有权限。
解决的方案：无线控制，下发指令。
小结：通过全流程的自动化处理，减少人工干预，除了提高数据的准确性外，有效的提升了测试效率。以小时待机电量测试为例，原测试流程和自动化测试流程相比较：
我们的收益
总结下我们在电量测试方面所做的工作：
、通过对系统电量统计原理的分析，清晰的掌握到组成整体电量消耗的每一部分的消耗值，从而可以直接定位导致电量问题的大体方向。
、通过测试工具的开发，获取到更加详细的功耗数据，从而可以直接定位到具体代码逻辑。
、通过电量测试的自动化建设，有效提升测试效率，除了缩短测试时长、减少人力投入外，还提高了测试数据的准确性。
电量测试方案应用于移动终端产品，除了能快速检测定位电量问题外，还可以协助开发及产品评估新增功能带来的额外消耗。
通过一年多的工作，我们总结出一套理论与实践相结合的电量优化检测方法：
理论：在了解系统对应用电量统计原理的过程中，发现对 消耗的计算在方法中是没有进行条件判断的。也就是说，如果在亮屏时，代码逻辑中仍然注册了 测试的 是没有任何意义的，在对应用进行电量统计时，就会计算上这部分的消耗：


在写代码时，可以注意下，在进行 注册时，首先要判断手机的状态。
实践：在对多个应用进行电量测试的过程中，发现不同产品根据产品特性不同，除了共性导致电量异常的问题外，还会存在产品特性相关的操作场景。
我们抛开产品，抽离出共性问题，整理成下面这个表格：

在用例设计部分，我们将待机列为需要关注的场景，是因为用户对待机时应用的电量消耗更为敏感。而在这个场景下，经常会出现由于代码逻辑问题、产品策略问题导致应用电量消耗异常。在操作过程中的电量消耗，是用户预知的消耗。但如果使用不当，也会造成异常消耗。
想知道更多测试相关干货 请关注我们的微信公众号：腾讯移动品质中心。接《  图形学基础 上》
    色彩和纹理
​​一个纹理实际上就是一个位图。从这个意义上来讲，当纹理一词被用于计算机图形学时，它就有了一个明确的定义。从语义学角度来讲，纹理一词既是指一个物体上颜色的模式，又是指物体表面是粗糙的还是光滑的。​
  纹理坐标
​​纹理实际上是一个二维数组，它的元素是一些颜色值。单个的颜色值被称为纹理元素 或纹理像素。每一个纹理像素在纹理中都有一个唯一的地址。这个地址可以被认为是一个列和行的值，它们分别由和来表示。​纹理坐标位于纹理空间中。也就是说，它们和纹理中的位置相对应。当我们将一个纹理应用于一个图元时，它的纹理像素地址必须要映射到对象坐标系中。然后再被平移到屏幕坐标系或像素位置上。​
  纹理过滤
​渲染一个图元时，会将三维图元映射到二维屏幕上。如果图元有纹理，就必须用纹理来产生图元的二维渲染图象上每个像素的颜色。对于图元在二维屏幕上图象的每个像素来说，都必须从纹理中获得一个颜色值。我们把这一过程称为纹理过滤 ​进行纹理过滤时，正在使用的纹理通常也正在被进行放大或缩小。换句话说，这个纹理将被映射到一个比它大或小的图元的图象上。纹理的放大会导致许多像素被映射到同一个纹理像素上。那么结果看起来就会使矮矮胖胖的。纹理的缩小会导致一个像素被映射到许多纹理像素上。其结果将会变得模糊或发生变化。要解决这些问题，我们可以将一些纹理像素颜色融合到一个像素颜色上。​每种类型的纹理过滤都有各自的优缺点。例如，线性过滤会产生锯齿状的边缘和矮胖的效果。但是，它对系统的消耗却是最小的。另一方面，过滤的效果通常是最好的，特别是和各项异性过滤混合使用时。但是它却需要很大的内存消耗。​    双线性过滤​​线性过滤方法是双线性过滤 。和最近点采样一样，双线性过滤首先要计算一个纹理像素的地址，这个地址通常不是整数地址。然后，找到一个地址最接近的整数地址纹理像素。另外，渲染模块还要计算与最近采样的点相邻的四个纹理像素的加权平均 。​    各项异性过滤​​各向异性是对一个三维物体纹理像素的可见的变形，这个物体的表面朝向屏幕平面，并与之有一定的角度。各向异性图元的像素在映射到纹理像素时，它的形状会发生变形。​各向异性纹理过滤可以和线性过滤或过滤联合使用。​   ​​一个就是一系列的纹理，每一幅纹理都与前一幅是相同的图样，但是分辨率都要比前一幅有所降低。中的每一幅或者每一级图象的高和宽都比前一级小二分之一。并不一定必须是正方形。​高分辨率的图象用于接近观察者的物体。当物体逐渐远离观察者时，使用低分辨率的图象。可以提高场景渲染的质量，但是它的内存消耗却很大。​
  纹理环绕
​​一般来说，分配的、纹理坐标值都在到范围内包括它们。但是，如果我们分配了超出这个范围的纹理坐标，可能会得到一些特别的纹理效果。​通过设置纹理寻址模式，我们就可以在纹理坐标超出范围时进行控制。​   重复​图象在表面上重复出现。忽略纹理坐标的整数部分，并将纹理图的拷贝粘贴在物体表面上这样才能做到无缝连接。​   截取​将大于的数值设置为，将小于的数值设置为，即将超出范围的数值截取到范围内，​这样会导致纹理边缘的重复。​   镜像重复​图象在物体表面上不断重复，但是每次重复的时候对图象进行镜像或者反转。这样在纹理边缘处比较连贯。​   边界截取​在范围外的参数值用单独定义的边界颜色或纹理边缘进行绘制。适合于绘制物体表面的贴花纸。​   边缘截取​总是忽略边界。处于纹理边缘或者靠近纹理边缘的纹理单元都用作纹理计算，但是不包括边界上的纹理单元。​
  立方体纹理
​​立方体纹理是一种特殊的纹理技术，它用幅二维纹理图像构成一个以原点为中心的纹理立方体。对于每个片段，纹理坐标  被当作方向向量看待，每个纹素都表示从原点所看到的纹理立方体上的图像。​基本上说它包含个纹理，这每个纹理是一个立方体的一个面，也就是说它是一个有贴图的立方体。你可能会奇怪这样的立方体有什么用？为什么费事地把个独立纹理结合为一个单独的纹理，只使用个各自独立的不行吗？这是因为有自己特有的属性，可以使用方向向量对它们索引和采样。想象一下，我们有一个××的单位立方体，有个以原点为起点的方向向量在它的中心。​
  点精灵
​​   什么是点精灵​的图形由顶点构成，以后利用顶点进行纹理的映射。点精灵就是，一个顶点被当作一个精灵来处理。特别之处就是，一个顶点也可进行纹理贴出。例如，原来是个顶点构成的一个矩形，现在一个顶点就可以完成了。瞬间我们就可以想想，粒子效果，那些云雾水流火花什么的用了点精灵，就可以瞬间减少个顶点的计算，使用_就可以了，完全也不需要什么顶点索引了。这是非常诱人的效率。​   点精灵的局限​一个顶点缩放都必须是矩形。并且大小的最大最小值是有范围的。既然是一个纹理映射到一个顶点上，那么纹理映射就和原来完全不同，有些复杂。可能会抵消掉一些性能的优势。​
  纹理压缩
​​贴图是在  场景中，增加真实性的一个重要的工具。就像一般的影像一样，贴图的大小愈大，它的图像就愈精细。事实上，贴图往往需要比一般的影像更大。因为，在  场景中，观察者可能会很靠近贴图，使得贴图需要放大很多倍，而造成模糊的现象。所以，一般来说，如果可能的话，贴图愈大就愈好。​不过，贴图是非常占用内存空间的。​常用的图像文件格式有，，，，等；​不过象这种常见图像压缩格式对于多数应用的内存占用和显示总线带宽占用并没有直接的好处，因为还得解压缩成原始像素再传给显卡，而且还有加载时的解碼计算负担。这是因为显卡的纹理解碼硬件不理解格式。所以，在没有显卡硬件支持的情况下，用压缩格式保存纹理没什么意义，特别是对于手持移动设备来说，解碼象这种复杂格式是很浪费电的。​考虑到现代游戏对纹理图片的严重依赖，及相应的对视频总线的巨大压力，硬件实时解压缩获得了广泛的支持，不过这个还没有一种格式获得多个厂家的支持。纹理数据的格式则没有标准，要参考厂商的或文档获得值。这也就意味着，使用了压缩纹理之后就不能跨平台了。​纹理格式是能被所识别的像素格式，能被快速寻址并采样。​在，和于发表的一篇影响深远的论文基于已压缩纹理的渲染中，他们列举四项纹理压缩的特点，使其不同于其他图像压缩技术。​解压速度：由于最好能直接从已压缩的纹理直接渲染，为了尽可能地不影响性能，解压缩要尽可能快。​随机访问：由于几乎不可能预测纹素被访问的顺序，任何纹理压缩算法必须允许对其中纹素的随机访问。所以几乎所有的纹理压缩算法都以块为单位压缩和存储纹素，当某一纹素被访问时，只有同一块中若干纹素被读取和解压缩。这项需求也排除了很多压缩率较高的图像压缩方式，例如和行程长度编码。​压缩率和图像质量：由于人眼的不精确性，相比于其他应用领域，图像渲染更适宜使用有损数据压缩。​编码速度：纹理压缩对压缩速度要求不高，因为绝大多数情况下，纹理只需要进行一次压缩。​由于其数据访问模式是事先知道的，纹理压缩常作为整个绘图管线的一部分，在绘制时对动态地已压缩数据进行解压缩。而反过来绘制管线也可以通过纹理压缩技术来降低对于带宽和存储的需求。在纹理贴图中，已压缩纹理和没有经过压缩的纹理使用起来基本没有区别，都可以被用来存储颜色数据或其他数据，例如凹凸贴图或法线贴图，也都可以和或各向异性过滤等共同使用。​
   主要厂商及支持的纹理压缩算法
​​
    粒子系统
​​
  效果预览
​​粒子系统表示三维计算机图形学中模拟一些特定的模糊现象的技术，而这些现象用其它传统的渲染技术难以实现的真实感的效果。经常使用粒子系统模拟的现象有火、爆炸、烟、水流、火花、落叶、云、雾、雪、尘、流星尾迹或者象发光轨迹这样的抽象视觉效果等等。​
  主要参数
​​什么是粒子系统？粒子系统是由总体具有相同的表现规律，个体却随机表现出不同的特征的大量显示元素构成的集合。​这个定义有几个要素：​、 群体性：粒子系统是由“大量显示元素”构成的。因此，用粒子系统来描述一群蜜蜂是正确的，但描述一只蜜蜂没有意义。​、 统一性：粒子系统的每个元素具有相同的表现规律。比如组成火堆的每一个火苗，都是红色，发亮，向上跳动，并且会在上升途中逐渐变小以至消失。​、 随机性：粒子系统的每个元素又随机表现出不同特征。比如蜂群中的每一只蜜蜂，它的飞行路线可能会弯弯曲曲，就象布郎运动一般无规则可寻，但整个蜂群，却是看起来直线向一个方向运动这就是上一点所说的统一性。​
    数学基础
​​这一部分是很简单的，对于不同数学知识背景的读者来说都容易阅读。对于想了解更多更全的这方面信息的读者，请查看有关线性代数和高等数学的书籍。​
  向量
​​几何学中，我们用有向线段表示向量。向量的两个属性是他的长度和他的顶点所指的方向。因此，可以用向量来模拟既有大小又有方向的物理模型。例如，以后我们要实现的粒子系统。我们用向量来模拟粒子的速度和加速度。在计算机图形学中我们用向量不仅仅模拟方向。例如我们常常想知道光线的照射方向，以及在世界中的摄象机。向量为在维空间中表示方向的提供了方便。​
  变换
​​空间中最常用的变换主要是，平移，旋转，缩放​    变换的顺序​​变换作用的顺序会影响变换最终的结果。​​通过使用矩阵相乘把个变换矩阵合成一个矩阵。注意我们必须按实际应用的顺序来进行矩阵相乘。​    模型视图的二元性​​视图和模型变换对场景外部的最终效果来看是一样的，将两者区分开纯粹是为了程序员方便。将对象向后移动和将参考坐标系向前移动在视觉上没有区别。​   透视投影​​透视投影属于中心投影。透视投影图简称为透视图或透视，它是从某个投射中心将物体投射到单一投影面上所得到的图形。透视图与人们观看物体时所产生的视觉效果非常接近，所以它能更加生动形象地表现建筑外貌及内部装饰。在已有实景实物的情况下，通过拍照或摄像即能得到透视图；对于尚在设计、规划中的建筑物则作图手工或计算机的方法才能画出透视图。透视图以渲染、配景，使之成为形象逼真的效果图。​透视投影符合人们心理习惯，即离视点近的物体大，离视点远的物体小，远到极点即为消失，成为灭点。它的视景体类似于一个顶部和底部都被切除掉的棱椎，也就是棱台。这个投影通常用于动画、视觉仿真以及其它许多具有真实性反映的方面。​   正交投影​​投影线垂直于投影面的投影属于正交投影 ，属于平行投影的一种。​
  粒子的轨迹
​一、搭建  开发管理平台
 上传  证书
第一步：下载证书并解压

第二步：将证书和私钥上传到开发管理平台服务器
  
  _
第三步：将证书和私钥复制到   文件夹登录云主机   ，运行以下命令
   
  __ 
  _ 
 创建  容器
登录云主机   ，使用   命令， 创建一个名为 的容器。
    = = \
       \
  _= \
  _={{数据库内网地址}} \
  _={{数据库用户名有建库权限}} \
  _={{数据库密码}} \
  __= \
  __= \
  ___= \
  __= \
  __= \
  _= \
  _= \
  __= \
   \
   \
   \
   \
 
 解析域名
将域名  解析到 第一步 登录腾讯云域名解析控制台

第二步 进入主域名管理面板

第三步：添加 记录  建议以关联主机方式解析 

 安装配置
使用浏览器访问  ，根据提示完成  配置。第一步 创建管理员账号

创建成功返回控制面板
第二步 配置网页登录鉴权方式进入  应用

选择用户名密码认证

配置登录选项配置成功
第三步 添加公钥 用于代码仓库进入设置面板

上传公钥

上传成功
第四步 更新代码仓库所有者
 进入容器
     

 更改代码仓库所有者
   
第五步 配置   自动部署 进入容器，使用  命令配置  
      
  
      
访问  检查配置

自动部署脚本 
 
   {
  = __
  = \
      {

   _  {
  = 
 }  {
  = _
 __ | __ | __ 
 }
 }

    \
 }

        {

 __ 
 =
 =
 =
 =
  _
 }



  =     {{}}   
  = _
   _  \{\{\}\}    {

  = 
  = 
  = 
  = 

      
 }



  = _ _ _
 __  _
  

相关推荐如何用快速在腾讯云上开发小程序之系列：搭建    服务器如何用快速在腾讯云上开发小程序之系列 ：实现腾讯云 调用前言
强迫症不能忍受这种极其绕的概念而不给个说法。同步异步，阻塞非阻塞，阻塞非阻塞同步异步复用 ，这些概念困扰我许久，下面给出这一阶段我个人的理解。
同步异步与阻塞非阻塞的理解
线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。用线程执行程序流的过程去理解同步异步，阻塞非阻塞。同步异步关注的是流执行过程需不需要等待外部调用的结果，而阻塞非阻塞关注的是外部调用对流本身产生的影响。
同步与异步
线程的执行过程中，产生一个外部调用，如果需要等待该调用返回才能继续线程流则叫做同步，不需要等待结果返回线程流可以继续往下执行的情况叫做异步。区分：线程流向下执行需不需要等待系统调用的结果。
阻塞与非阻塞
线程执行过程中，产生一个外部调用后，会不会把该线程流“堵”住，会“堵”对应的是阻塞，反之为非阻塞。
的五种模型
上一节中对同步异步，阻塞非阻塞的描述只能说能够恰好区分它们，如果不是在计算机领域而是生活中，道理也类似。然而计算机中的某些专业术语又需要放在专门的情景中去看，例如下面将要提到的 模型，建议理解模型本身，而不是抠同步异步与阻塞非阻塞的字眼，因为会发现就算是非阻塞模型也有阻塞的部分，同步与异步的区别是操作的时候会不会让阻塞。下面对模型描述的最终来源为： 的“          ”，节“  ”                           
同步模型
用操作中有阻塞来判断，种模型中种属于同步，分别是阻塞模型，非阻塞模型，复用模型，信号驱动模型。
 
阻塞是的默认设置，其模型如下图所示，程序调用产生一个系统调用，收到该调用请求后有两个步骤，第一是等待数据准备好，第二是将数据从内核空间拷贝到用户空间然后返回，用户空间收到系统调用返回后才会继续程序流的执行。

 
使用非阻塞模型需要对进行另行设置，非阻塞模型如下所示。内核收到系统调用后，若数据未准备好立即返回，用户进程收到会继续产生系统调用，直到数据准备好了并被拷贝到用户空间。

 
对应的是复用模型，优势是能够监听多个，模型图如下所示。用户进程调用产生系统调用，会监听所有负责的，一旦有一个数据准备好了，即返回，用户再去产生系统调用将数据从内核空间读到用户空间。

 
用户程序注册一个信号，然后继续做后续的事情，当内核数据准备好了会发送一个信号，程序调用进行系统调用将数据从内核空间拷贝到用户空间。

异步模型
用操作中无阻塞来判断，种模型中只有异步。
 
异步模型如下，_产生系统调用，在数据准备好后将数据从内核空间拷贝到用户空间后返回一个信号告知数据成功，整个过程程序调用_后就继续执行其他部分直到收到信号，调用处理。

模型的对比
有两个过程，等待数据准备好和拷贝数据到用户空间，用户程序的阻塞一般有两种情况，的阻塞和 的阻塞，中模型的对比如下。


能够同时监听多个文件描述符，当有的读写操作完成时会返回这些，可以对应于复用模型中的系统调用查询是否准备好数据的那一部分。

   _  _ _   

  {
        
      _ _ _
} __
在用户层使用某个结构标识被监听的以及监听的状态，每一个用表示，为表示这个文件是被监听的，表示不监听。  指向的数组表示对应的读，写，异常文件的描述符。_ __指向的数组表示对应的读，写，异常文件的描述符的检测结果。

这个结构被拷贝到内核层，
对所有的注册回调函数__
调用的方法遍历整个_所有的，检查是不是自己需要监听的，如果监听的发生了感兴趣的事文件读写操作完成或者异常，参考用户态预先的设置，则方法返回一个描述读写操作是否就绪的掩码，根据掩码给_赋值。___会把当前进程挂到对应文件的中的的等待队列。
如果一轮遍历无果则挂起，直到超时或者有设备驱动发生自身资源可读写后将其从等待队列唤醒，则执行新一轮的遍历。
把_从内核空间拷贝到用户空间并将进程从各个等待队列中删除。


    _   

  {
     
     
     
}
的实现机制与类似，不一样的是的使用中用户态直接提供了需要监听的的信息，结构记录被监听的和它的状态。
 _ {
 _ 
     
      
}
另外使用_结构来记录监听的，每一个_节点都包含一个数组，参数被拷贝到内核后，_被遍历，换言之数组被遍历，与一样，所有的都被遍历。

 _ 
 _       _ 
 _   _     
将过程细化为一组系统调用，包括个_，多个_，个_。内核针对操作添加了一个文件系统””，每一个或者多个要监视的都有一个对应的文件系统的节点，主要信息保存在结构体中，而被监视的文件的重要信息则保存在结构体中。在执行_和_时把用户态的信息保存到内核态了，之后即使反复地调用_，也不会像那样重复地拷贝参数，扫描，反复地把当前进程放入放出等待队列。
_
_的功能是创建一个文件系统的节点，主要信息保存在结构体中，记录了文件系统的节点的重要信息，其中成员保存该文件节点监视的所有描述符，组织的方式是一棵红黑树，被监视的文件的重要信息则保存在结构体中。
_
_实现一系列操作，它调用_从中的红黑树获得结构体，根据参数的不同而选择不同的操作。当为__，一般情况下无法在的红黑树中找到，所以调用_创建一个结构体并插入到对应的红黑树中，
__ ___
…
 = _ 
…
然后_调用__注册一个回调函数___，该函数会在调用_时被执行。___函数分配一个等待队列结点_，一方面把它挂到文件操作的等待队列中，另一方面把它挂到的队列中。此外它还注册了一个等待队列的回调函数__，__在完成操作完成，唤醒当前等待进程之前被调用，会把放到的完成队列，然后唤醒等待进程。
_
_的工作是等待文件操作完成并返回。它的主体是_，该函数检查中有没有已经完成的事件，有的话就把结果返回。没有的话调用_进入休眠，直到进程被再度唤醒或者超时。
对比
的弱点在于需要轮询遍历，当监听多时开销大；而依赖于回调函数，当活跃过多时开销就大。




监听的个数
消息传递的方式
是否遍历所有
适用场景





最大为_，修改需要重新编译内核
内核与用户空间的拷贝
是
连结数少且活跃



无限制，基于链表存储
内核与用户空间的拷贝
是
连接数少且活跃



很大
共享内存
否
活跃少



总结与展望
其实我并不是很相信自己写的某些部分，例如的细节，毕竟是整合的别人的资料，但是目前为止确实能解释我的某些疑惑，以后有空有机会再去深挖求证。
参考资料
作者：赵裕， 腾讯移动客户端开发商业转载请联系腾讯获得授权，非商业转载请注明出处。原文链接：
 导读
本文探讨了热修复技术的发展脉络，现状及其未来。

热修复技术概述
热修复技术在近年来飞速发展，尤其是在方案推出之后，各种热修复技术竞相涌现。国内大部分成熟的主流都拥有自己的热修复技术，像手淘、支付宝、、饿了么、美团等等。
目前能搜集到的资料，大多简单罗列每个方案的特点并进行横向比较，而其中技术发展的脉络往往被掩盖了。热修复技术从何而来，又将往何处去？在这些资料中都找不到答案。
我认为，走马观花地看一遍各家的热修复方案并不能找到答案，所以写下本文，希望从一个不同的角度来了解热修复技术，权当抛砖引玉，如有不足，欢迎指正。
代码热修复
代码热修复是最常见，也是热修复中最重要的部分，因为程序错误往往都是代码逻辑的错误。最初的热修复方案也仅支持代码热修复。代码热修复分两个流派，即腾讯系的类加载方案和阿里系的底层替换方案，前者需要重启应用但却能修复大部分错误，后者及时生效却只能作方法内的修改。下面详细介绍。
一、类加载方案
、的超级热修复方案是业界最早的热修复方案之一，原理简单而巧妙，影响深刻而久远，在此简单介绍。类加载的源码如下
可以看出当有多个文件时，他们会组成一个有序数组，按顺序加载，而对于一个已经加载的是不会再次加载的，由此得出热修复方案：把需要修复的类打包成一个文件下发，并在启动时通过反射，将这个文件放在的最前面，这样修复了的就会比有的优先加载了。如下图所示：
但在实现过程中，会遇到  异常，方案为了解决这个问题采用了插桩的策略来规避这个异常。实际上，系统的检查和优化都是有其意义的，因此这种方法在和上都会遇到问题。
● 在虚拟机，在安装的时候会被执行操作，同一个文件内的会被打上_标志，而补丁包中的类并没有打上此标志，因此抛出异常。解决方法就是在第一次打包时让所有类都引用另一个文件中的类，这样所有的类始终不会打上_标志，因此补丁包可以顺利加载，但是虚拟机在检测到一个类未打上_之后会再次在类加载的时候进行相关的操作，如果一次性加载很多类，速度将明显变慢。
● 在虚拟机，文件最终会编译成本地机器码，在时 已经将各个类的地址写死，若补丁包中的类出现字段或者方法的修改，会出现内存地址错乱，解决办法是将这个类的父类和调用这个类的类都加入补丁包。但这样会导致补丁包急剧增大。实际上要理解清楚这个问题需要熟悉和的完整流程，并非三言两语能解释清楚
这两个问题都可以解决，但都要付出一些代价：类加载速度或者补丁包大小。
、如果没有上面两个缺陷，或许就不会有了。对于微信这样一个对性能有极高要求的产品来说，的缺点会被无限放大。在参考 的冷插拔与的后，采用了全量替换的策略。全量替换可以避免插桩和地址写死问题，但是补丁包会很大，因此可以在新旧两个的差异放在补丁包中，下发到移动端后再在本地合成完整的文件。
实际上，保留了最核心的东西：反射修改。无论是插入还是替换，本质都是利用了类加载的特点。由于需要下发的全量补丁包体积过大，采用了后台求，下发文件，移动端合成全量包的策略。
如果仅此而已，只要有算法，就可以开发了。实际上，确实如此。而第二个创新之处就是采用了自研的算法，大大优化了下发差异包的大小。
二、底层替换方案
阿里的热修复方案是底层替换方案的代表，与和的思想完全不同，通过修改一个方法的入口地址来达到修复。以虚拟机为例，的核心代码如下：
其实就是修改了方法包括入口地址在内的每一项数据的地址，使之指向一个新的方法。在后台，使用提供的工具，可以得到补丁文件，这个文件记录了哪些方法需要修改，以及修改后的方法。效果：注意我一直在点击，下发补丁后发生了变化……
资源修复
除了代码热修复，资源热修复也很常见。各大主流方案在资源修复的实现上大多参考了的实现方式，因此本章节先讨论了，再分析了基于所实现的热修复。
一、
在中引入。
包括代码修复和在资源修复，资源修复的核心代码
其实做了两件事：

通过反射替换掉原有的
找到引用了原对象的字段并替换为新的引用。

关键是要熟悉相关源码，才能确定哪些字段是需要更新引用的。通过以上两步即可实现资源替换。
二、资源热修复实现
将的方法引入我们的代码就可以实现资源热修复，效果如下
库热修复
库的修复本质是对方法的修复和替换，和类加载方案类似，可以把补丁库的路径插入到数组的最前面，使得优先加载补丁库而不是原来的库来达到修复目的。在此不做赘述。
热修复的稳定性
一、兼容的困境
最初就需要在平台进行插桩，同样也是分平台合成在平台合成全量，在平台合成需要的小，而阿里的作为底层热修复方案，不仅要面对两种虚拟机平台，甚至要为不同版本编写一套替换逻辑，如下：
二、不安全的代码
加载了补丁包的程序本质还是未编译的程序，只是两个已编译程序的结合体，由于的编译过程对于我们是透明，所以我们一不小心就会引入错误，而且这种错误十分隐蔽。在使用类加载方案时由于还是在层，可能不那么容易犯错，但使用等底层热修复方案时却总是防不胜防。
比如，在编译匿名内部类时会编译成顶级类，命名方式为，其中为匿名内部类出现的顺序，所以在第个匿名内部类前面添加匿名内部类就会导致变成，即一个方法的地址发生改变。再比如，的泛型编译可能会在编译期引入新的方法，也会导致的异常。因为编译过程是透明的，所以热修复后的程序不能代替修复问题后重新编译出来的程序，即热修复后程序的安全性是得不到保证的。
热修复技术展望
时期插桩影响了类加载的速度，的算法粒度过细、实现复杂，导致性能消耗严重，使用场景有限、兼容性差，此外美团的、饿了么的等也都各有限制。热修复技术虽然百花齐放，但却并没有哪种方案能够解决所有问题，统一当前的局面。而最近阿里又推出了，针对各种类型的修复又做了深度的优化，虽然没有开源代码，但是发布了《深入探索热修复技术原理》，引起社区的关注，其统一各种热修复方案的意图也十分明显。
从到，从到都可以看出来，热修复技术还在不断上升发展，每一次新方案的推出都是对原有方案的超越。但目前来看，阿里并未打算开源，而仍然在路上，热修复技术在性能、兼容、开发透明方面仍然有很多不足，所以不能仅仅满足于了解已有方案，还要深入源码去理解原理，更要对业界最新进展保持关注。


参考：
、安卓热补丁动态修复技术介绍、微信的一切都在这里，包括源码一、          、  、微信热补丁实践演进之路、          ……

腾讯兼容性测试团队积累了年的手游测试经验，旨在通过制定针对性的测试方案，精准选取目标机型，执行专业、完整的测试用例，来提前发现游戏版本的兼容性问题，针对性地做出修正和优化，来保障手游产品的质量。目前该团队已经支持所有腾讯在研和运营的手游项目。
新机即将同步上线，欢迎进入： 使用专家兼容测试服务。 兼容性测试团队期待与您交流！ ， ！
如果对使用当中有任何疑问，欢迎联系腾讯企业：作者：胡彬  腾讯云高级工程师

 是“     ”的缩写，主要用于存储一个大字段的值。要理解  ，我们要先理解页  的概念。在  中，页是数据在文件存储中的基本单位，其大小是固定的且只能在编译期指定，之后无法修改，默认的大小为  。同时， 不允许一行数据跨页存储，那么对于超长的行数据， 就会启动  ，具体就是采用压缩和切片的方式。如果启用了切片，实际数据存储在另一张系统表的多个行中，这张表就叫  表，这种存储方式叫行外存储。
在深入细节之前，我们要先了解，在  中每个表字段有四种  的策略：

 ：避免压缩和行外存储。只有那些不需要  策略就能存放的数据类型允许选择例如  类型，而对于  这类要求存储长度超过页大小的类型，是不允许采用此策略的

 ：允许压缩和行外存储。一般会先压缩，如果还是太大，就会行外存储

 ：允许行外存储，但不许压缩。类似字符串这种会对数据的一部分进行操作的字段，采用此策略可能获得更高的性能，因为不需要读取出整行数据再解压。

 ：允许压缩，但不许行外存储。不过实际上，为了保证过大数据的存储，行外存储在其它方式例如压缩都无法满足需求的情况下，作为最后手段还是会被启动。因此理解为：尽量不使用行外存储更贴切。现在我们通过实际操作来研究  的细节：


首先创建一张  表：
=        
 
= \ 
                           
   |     |  |   |   |  

       |  |           |     |              | 
    |     |           |  |              | 
  |     |           |  |              |
 可以看到， 默认  策略为  ，而  为  。 资料告诉我们，如果表中有字段需要  ，那么系统会自动创建一张  表负责行外存储，那么这张表在哪里？
=    _  =
  |  |  

     |        |         
 
通过上诉语句，我们查到  表的  为，其对应  表的  为关于  和 _ 的概念，请参考官方文档，那么其对应  表名则为： ___注意这里是  表的  ，我们看下其定义：
= \ ___
  ___
      |     |  

 _   |      | 
 _  |  | 
 _ |    | 
  表有个字段：

_ ：用来表示特定  值的  ，可以理解为具有同样 _ 值的所有行组成原表这里的  的  字段的一行数据

_ ：用来表示该行数据在整个数据中的位置

_ ：实际存储的数据。


现在我们来实际验证下
=      
  
=    
  |  |     

   |  | 
 

=    ___
 _ | _ | _ 

 
 可以看到因为  只有个字符，所以没有压缩，也没有行外存储。然后我们使用如下  语句增加  的长度，每次增长倍，同时观察  的长度，看看会发生什么情况？
=    =||  =
 
=    
  |  |  

   |  |     
 
=    ___
 _ | _ | _ 

 
反复执行如上过程，直到 __ 表中有数据：
=    
  |  |  

   |  | 
 

=  ___  ___
 _ | _ |  

     |          |   
     |          |   
 
 可以看到，直到  的长度为时已远远超过页大小 ，对应  表中才有了行数据，且长度都是略小于，这是因为  策略下，先启用了压缩，然后才使用行外存储。
下面我们将  的  策略改为  ，以禁止压缩。
=        
 
= \ 
                           
   |     |  |   |   |  

       |  |           |     |              | 
    |     |           |  |              | 
  |     |           |  |              |
然后我们再插入一条数据：
=      
  
=    
  |  |  

   |  | 
   |  |     
 
 然后重复以上步骤，直到表中产生新的行：
=    =||  =
 
=    
  |  |  

   |  |   
   |  | 
 

=  ___  ___
 _ | _ |  

     |          |   
     |          |   
     |          |   
     |          |    
 
这次我们看到当  长度达到按照官方文档，应该是超过左右，  表中产生了新的条 _ 为的行，且行数据的 _ 的长度之和正好等于。通过以上操作得出以下结论：

如果策略允许压缩，则优先选择压缩。

不管是否压缩，一旦数据超过左右，就会启用行外存储。

修改策略，不会影响现有数据的存储方式。



相关推荐在云端快速构建一个  站点微信支付商户系统架构背后的故事时光似箭，岁月如梭，恍然间，已入职一周年了。这一年应该学习了不少东西，但决定要好好总结一下自己的时候，却不知从而谈起。
这一年来，编写过 ，开发后台 ，写过批处理程序，编写过  脚本，线上版本迁移，  开发，参与过手  红包项目，这一年，很忙，但也很充实。甚至自嘲长期处于一种“忙成狗，累成牛”的状态。
一年了，似乎也没学到多少东西，还有很多知识等着自己去汲取，去挖掘，继续努力，不断前行。工作中遇到的一切，几乎都是从  开始，故难免会走很多弯路，也曾踩过无数的坑。接下来，我与大家谈谈平日里在项目中遇到的问题以及待优化之处。其中，有些很诡异的问题未定位，欢迎各位解答。若有异议，欢迎拍砖哈！！！
接下来，比较常见的问题，放在  部分，接下来  开发中遇到的问题，随后分别介绍 、批处理、、 和  中遇到的问题。
 
  解析
问题描述：相信很多童鞋都遇到过类似的问题，即当  文件中存在多个同样节点时，则它们之间不能有任何注释，否则读取  失败。例如：在较为常见的代码中，取下一个节点使用 【_】方法。如下若是，读取  文件失败，导致 ，且对应的  会被  进程无限次拉起。

 _ 

{

     

}

 _    

{

         

}

 = 

 

{

           = _ 若注释则会报错

          = _

}



          =_ =

          该处存在问题，会发生  

          =_ =


问题原因：循环读取相邻节点时，则会读取下一行注释，而  会 。
解决方法：使用  方法获取相邻节点，编译所有涉及读取  文件的项目并做出修改。
 高危函数
问题描述：相信很多人拉取代码分支时，都收到过自动化编译的高危函数告警。其中存在 、、、 、野指针等
问题原因：历史遗留
解决方法：
、改用  安全函数，其能够保证标缓冲区末尾为’\’，故使用   若使用   ，则会减少一个空间区域。
、改用 其不会在缓冲区最后添加结束符。为防止越界操作，故常使用时有两种用法：
   = {} 全部初始化
    仅考虑前 故最后一个字节为 \
 
   

    

   = ‘\’
 签名
问题描述：针对  请求串， 一般都将其读取至  中，方便后续处理。若进行  签名时，一般使用类似    得到  升序的字符序列，继续计算  值，签名也比对成功。当一段时间后，签名验证却未能通过。
问题原因：设  为==，若采用通用的  方法，其实得到字符串为 ==。或许还存在标准  编解码的问题，在此不再赘述。也许你会问，什么情况下会遇到=等特殊字符。
、 嵌套，如  ===
、字符串进行  编码。 要求把  个  位字节×=转化为  个  位的字节×=，之后在  位的前面补两个 ，形成  位一个字节的形式。 如果剩下的字符不足  个字节，则用  填充，输出字符使用=，因此编码后输出的文本末尾可能会出现  或  个=。
解决方法：、尽可能打印关键  日志 、重新封装   函数，对源串不编码、不转义。 、牢记签名一般将  按  升序  即可实现，末尾追加“=”。然后进行 。
 服务迁移问题
问题描述：因机器更换等原因，需要对线上运行的服务进行迁移。当提供了迁移说明文档，运维按照说明文档执行时，却出现了很多未预料到的情况。
问题原因：
、数据库无访问策略
、多台机器上的服务配置不完全一致
、灰度方案考虑不全面
、 版本不一致  很奇葩
、业务异常考虑不全面
解决方法：
、与运维多次确认网络访问策略并进行实地验证
、反复对比配置，确认符合预期
、在开发环境进行充分的验证
、加入告警，跟踪实时日志，以便异常出现时能够及时发现
  配置
问题描述：、在  服务端所在机器， 未查询到  进程。
、密码文件未起作用
问题原因：、 同步文件有两种方式 、密码文件属性必须为 
解决方法：
、拷贝命令
  = =_ {} 
其中， 为 中的模块名，路径为 =
密码文件属性必须为：
           _
、通过  登陆的方式
      {} 
然后输入登陆密码就传送 。
若想通过脚本传文件或者不想每次都手工输入登陆密码，则可使用  方法，如下：
   \   \ {}  {}
其中  实现不在此赘述，见附件。
 时间转换
问题描述：设计到月表时，一般情况下，都会根据当前时间戳获取上一个月的月份，简单实现如下：
 = 

_ _

__=


若当前时间为  ，则转换后获取的时间为  ，即当时  月，并不是预期中的  月份。
问题原因： 月有  天，而  月份有  天
解决方法：将当前时间  置为  日，然后进行相减运算。
 跨月查询
问题描述：查询当前月表后，获取当前时间，设为  ，故需要查询  月份的数据库表，若无对应的数据记录，且  查询时间超过  此情况很常见此时，时间已经大于  。因此查询前一个月库表时，实际上会继续查询  月份的数据。因此， 月份的数据永远也不会被覆盖到。若该业务逻辑依靠月表保证重入逻辑，则可能存在严重问题。
 查当月

  = 

  = 

  == 

{

          往前查一个月

          = 

          = 



           == 

         {

                   往后查一个月

                   = 

                   = 

         }

}
问题原因：历史问题
解决方法：以一个固定时间为基准，左右偏移各一个月。
 诡异问题
问题描述：、脚本提示错误，但是仔细检查后未发现异常 、 标签读取失败 、输出日志顺序混乱
问题原因：、全角符号问题，不易发现 、 标签不对应 、涉及标准输入输出时，将  重定向到标准输出，如 “  ”
解决方法：细心、细心、再细心
 
 新建 
问题描述：、新建  时，发现  无法被加载 、打印 ，但是文件大小为 
问题原因：
、新建  时，注意事项
  在  中新增配置项
   
  修改日志级别，  
  _必须生成 _
  需要手动  
解决方法：
、见注意事项
、确定是否有写权限 是否运行打印逻辑？最后一种情况下可以考虑了，那就是磁盘空间满了。这么小的概率却被我撞了  次，包括  插入数据报错，其他都是  中无内容。
 
问题描述：参与过的一些项目中， 查询经常会 ，常见的有以下三种：
、

_    _ 

 =   
、
_      _ 

 =   
、
_     _ 

_      _ 

 =     
问题原因：
、有些数据库创建时， 字段  ， 字段  导致取出的字段值  为 ，故会 
、 下标写串了，随着字段的增多，且不断修改，很容易出现该问题，由于  可能为 ，而  会 
、字段名写串了，当数据字段长度不一致时，会发生阶段，导致数据错误。
解决方法：
、建议数据库表创建时，  “”   ，或者使用  ，尽可能不使用  
、 中拼写  语句时，建议都使用           “” 判空
、建议使用类对象，而不是  的  存储。如下所示：
_ =     

__ =     
这样解决了上述的  问题。
  解析库
问题描述：在做  版本的迁移过程中，发现各个模块使用的  库不统一。有使用 ，也有使用 ，为方便起见，故将两个库全部参与链接。当时解析  时无故 。
问题原因：至今未查明原因，可能不兼容
解决方法：后续都统一使用 ，对应的头文件为 
  调试
问题描述：对于  基础不扎实的我来讲，且刚入职不久，遇到  重启问题，而且没有   文件。
问题原因：、或许担心  文件太大，为防止  进程重复被拉起，为避免硬盘空间被大量占用，大多数情况下，  开关处于关闭状态。若不分析代码的话，不容易发现问题。
、日志句柄未分配空间
__

{

    

    {

                   读取配置项

         =  



         初始化日志指针

         =  

        

         }

          

    {

                    

        

    }

}
解决方法：
、查看  占用的资源  
、打开   开关   
很多情况下，  开关未打开的
   打开 
、进程启动前，尽量使用 __ 打印， 用日志句柄打印时，至少应该判空
 封装问题
问题描述：曾经遇到很郁闷的问题，在大量的代码中，很难发现问题，如下：
 
 = “”

结果发现 “”为空，然后打印 ，“=” 发现依旧为空。
问题原因：其实  类是这样重载 操作符的
     

{

          _ = _  __  “”

}
因此， = “”仅仅修改的临时 
解决方法：将返回类型用  修饰。
 加密无密 接口
问题描述：有时候，调用其他  接口，莫名其妙的报错，尽然说缺少参数。
问题原因： 请求串未加密，调用加密接口。加密  请求串后调用了无密接口。
解决方法：、先确认参数名是否拼错？ 、确认有密接口还是无密接口 、看被调用服务日志
 缩容扩容
问题描述：春节前，为备战微信红包，核心系统进行了扩容，而目前面临缩容问题。而我们的对账平台可以支持逻辑  或者实  扫描数据库，从而继续业务对账。但是有时候在逻辑  时，不确定应该选用哪个。如下图所示：

同样是读取 _____ 表，但究竟选用 ，还是选择  呢？
问题原因： 的数据库管理系统供多个业务使用，故场景不同，库表也不一致。
解决方法：请教 
：仅仅保留近  个月的数据
主要是订单数据，即 _。而其中的 __ 可能之前的账务组需要，不必考虑
订单拆分，数据来源于 _。可能会做迁移，对业务透明。
 
  输出
问题描述： 的逻辑时，调用一个脚本程序将文件  到目标机器，成功后通知页面执行成功。而根据新增需求实现，部分情况下，调用新脚本程序  到目标机器，其他继续走老逻辑。最后发现，走新逻辑， 正常返回，但是页面无法正常显示。而老的逻辑则可以。由于  重定向了标准输入输出，故主要定位方向是查找新逻辑输出的多余数据。
问题原因： 调用新的  脚本将文件  到目标机器，但未重定向返回结果日志，从而导致返回给页面时多出很多  的结果数据，不符合  请求响应报文格式，故报错。
解决方法：对比新旧脚本，新增     
 批处理
  配置
问题描述：常住内存的批处理程序，中间中断一段时间未发现。
问题原因：因异常逻辑触发隐藏 ，导致 ，随后没有机制可以保证再次启动。
解决方法：、即使常驻内存的批处理程序也需要定期检测是否运行中，若为运行，则启动
、批处理程序增加文件锁机制， 配置定期启动批处理程序
：脚本中需要写为绝对路径。若需要相对路径，则需设置环境变量。
 
 导出  记录
问题描述： 多列时，若将结果集重定向到一个文件中，结果集并不是多行。
_= _ _  _  

 _  _   {_}  _

        
问题原因：被单引号括住的内容，将被视为单一字串。在引号内的代表变数的符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。
=    
被双引号括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。
=    
解决方法：为防止 \\ 等特殊字符会被转义，需要加双引号，即  _  _
         

                

                
 变量作用域
问题描述：第一次写  脚本时，使用了很多  方法，也定义了很多变量。当其中一些变量被无故的覆盖了。
问题原因： 中变量默认为全局变量，且全局作用。
解决方法：若需要局部变量，则需要使用关键字  声明。
  计算
问题描述：若计算一个字符串则使用命令   |  |  { }得到  值为 。但是在代码中得到的  值是 。莫非代码有 ？
问题原因：使用  时，不加 选项，字符串默认会包含\。
解决方法：增加 选项，如    |  |  { }
 
、 函数返回值必须是字符串。
、字符串赋值时，=号左右不能加空格
 __   号左右必须加空格，否则当做字符串处理。 内所有符号【赋值=除外】都需要有空格。如   等
、= 带双引号
= 不带   
 中，如果用单引号，即变量不带有“”，即只是字符串的内容。
、在  脚本中，若有 、 语句，在  关键字后需要加换行符。如果需要换行，不能在行末尾加空格，否则空格将会被转义。
、 
如果  最近未修改过。那么发送到本地时，修改时间不变。故不能仅仅按照修改时间排序。
、赋值操作符
 =
在  中， 会将整个  展开后，再决定变量的值。即变量的值将会是整个  中最后被指定的值，如下所示：
 = 

 =  

 = 
在上例中， 的值将会是   ，而不是  
 =
变量的值决定于它处于  中的位置，而不是整个  展开后的最终值。
 = 

 =  

 = 
在上例中， 的值将会是   ，而不是  
 
 库表创建
问题描述：如  所述，数据库创建时字段默认  的话，则使用   得到的 为 。
问题原因： ，任何类型都会插入空指针
 则  类型会插入空字符串，而  类型会插入 
解决方法：为安全起见，建议   “”  ，或者使用  
 
问题描述：如下所示，当记录不存在时， 返回的不是 ，而是 ，与自己预期的不一致。
  _  ____



| _ |



|      |

|      |

|      |



  __  ____



| _ | _ |



|               |          |





  _  ____  _ = 



|  | _ |



|         |             |


问题原因： 永远会返回整型， 在无符合条件记录的情况下会返回 ，而不是 
解决方法：使用  _ 
 
问题描述：看一下下面的  语句，

 ____  == _=  _=
这个是简单的更新语句，至此，你看出什么问题了么？我找了  个人看，但都没有看出有什么问题。其实，更新成功了，但是结果却是未预料到的。
  ____  == _=  _=

      

        
执行成功后， 设置为 ，，没问题。但是，你会发现， 被设置成，而 _ 根本没有得到更新。
问题原因：多个设置域应该用逗号分开，至于为何不报错，且  设置为原因未知。莫非是  的 ？
解决方法：
 ____  == _=  _=
 
 暂时未整理，待续腾讯云电商行业资深架构师唐良以电商行业的发展为例，讲述了云端架构升级为企业开发与业务创新带来的全新价值。唐良表示，腾讯云帮助电商企业从自建的数据中心一步步成功迁移到云端，从最开始的弹性上云、到数据库上云，到数据同步，再到混合云。继而当电商客户越做越大后，该企业也将自己的大数据平台建立在腾讯云的黑石服务器上，实现了高性能计算，从海量数据分析中获取洞察。同时腾讯云的服务器为该企业提供了机器学习的能力。此外，腾讯云的云监控服务保证了系统的可用性与稳定性。数据表明，该企业的最后支付体系，由于放在腾讯云上，通过微信支付的速度比非腾讯云客户快了，这对电商企业来说是一个巨大的优势。
 腾讯云电商行业资深架构师针唐良
唐良还分享到，腾讯云的数据中心已遍布亚洲、欧洲、美洲等全球地区，数据中心之间也由腾讯云自有的专线打通连接，能够灵活快速地满足客户的架构部署与升级。针对电商行业“羊毛党”的问题，企业基于腾讯云，利用人工智能技术，通过用户手机设备或社交账号信息信用记录的分析，能大大降低“褥羊毛”对企业带来的损失。基于腾讯云的天御，同城收到的恶意消息减少了，东鹏特饮也借由天御一年节省了三千万费用。同时，唐良还介绍了电商企业接入腾讯云后的进阶服务——电商业务的创新玩法。蘑菇街基于腾讯云在里开创了“红人买手直播间”。用户可通过网络红人视频直播推荐的服饰与搭配，直接进行互动选购，这相较于传统的电商购买模式，人与人的距离被拉近，用户购买体验也大大增加。截至到今年月，直播间综合收入是去年十一的倍，红人主播单场交易额，也达到了万。简介
什么是
官网介绍是：不需要浏览器的完整协议栈     ，也就是常说的无头浏览器——或者好听点叫做：无界面的解析器。
的特点
由于“无头”——免去了渲染可视化的网页界面，她的速度要比一般的浏览器快不少，又因为她是完整的协议栈，所以不仅仅提供了 ，还完整的支持各类标准：操作、选择器、、和，以及文件系统和操作系统。此外她还提供很多事件监控处理接口 ，这一点也是区别于等自动化测试工具的关键所在，具体的将在后续安全检测中详细说明。
笔者将的特征汇总如下表：
提供的汇总
  

 

 
 
 
 
  
 
  

  

  


  

   
    

  

  

小结
鉴于以上特点，我们就会发现特别适合用来写！爬！虫！
支持便可以动态加载资源，或完成一些模拟人类的动作；支持操作便可以结构化页面；的支持便可以快捷方便的完成页面文档的渲染，供我们保存图片或到处；支持、和更是对与数据或多媒体页面处理的加分项；同时文件系统的提供，也让我们很方便的将处理结果格式化存储起来。
常见的用法
 交互模式 
下载后，直接运行就进入了交互模式，这时我们可以把她当做一个解释器使用，运算、方法、使用对象查看“浏览器”信息等等，大家如果安装了可以随意输入一些命令感受一下。感受结束后输入`退出。

图：　模式下的　
如果是初学的同学，这个模式可能会比的栏更大一些，方便用来练习命令。此外，这个这个模式并不常用，我们更多的是将看做一个二进制工具来使用。
 作为一个二进制工具
这也是最常用的一个模式： 来运行一个脚本。脚本中可以使用提供的各类的语法不支持页内锚点，详见文章前部分的“提供的汇总”
打开页面
创建一个的实例，然后使用方法打开腾讯网首页，如果返回值是成功，则日志打印出网页标题，之后退出。

       
        
  
   
   

  = 
   
         
     {
         ===   {
             
         
         }  {
        
}
   
}
获取
当然，我们也可以用来获取页面的所有内容，使用来获取。
如下，我们获取访问王者荣耀网站时的，并使用键值对的方式打印在里：

       
   
   
   

  = 

     {
        ===  {
            = 
              {
              =  
          }
      }
   
   }
对应的输出为：

图：_
执行
作为无头“浏览器“，当然对的支持也是极好的。如下，我们定义了一个简单的函数，来获取页面标题后返回。只需要简单的调用来执行这段代码即可。

       
   
   
   

  = 
     = 
  
     = 
     {
        ===   {
         =   {
          
  }
  
  }
}
  
使用第三方库如
如果觉得自己用代码来重复造轮子太麻烦，我们也可以在中使用第三方的库。为我们提供了中使用第三方库的方法：

方法一：
方法二：

二者常常混用，主要的区别在于是阻塞加载，而是动态加载。可以理解为代码执行到这里时，程序阻塞，加载这个文件到内存后，程序继续运行，在操作页面时不会对这个文件发起请求。而则是在加载页面用到此文件时动态加载文件。
实例代码如下：

       
     
   
   

  = 
   
  {
  
    
    ===  {
        =  {
            ===     
        }
    
  }{
     
  }

}
输出如下：
我们先了版本号为的本地文件，之后便可以使用的方法来查看版本。当然，这只是验证加载成功，在我们完全可以使用其他提供快捷方法来实现我们的需求。
保存指定页面区间截图
在我们处理页面时，常常会有保存页面截图的需求，比如：保存页面的样子、关键信息的留证等等。这时我们就可以使用的提供的方法，她支持将完整的页面自动滚屏截图、指定区间的页面保存下来  等格式均支持。
如下，我们想获取天气网站”我的天气“详情，而不去关注网页其他各种新闻和广告，我们只需指定区间，然后保存截图即可

 _
    
   
   

  =  
   {
      ==  {
         =    
    }  {
         = {
             
             
             
             
        }
        
         
    }
    
}
保存的图片如下所示：

图：__ 
三行代码怒怼”反爬虫”
正常用户访问
当我们正常使用浏览器访问时，一切正常，如下图：

图：__ 
根据这套反爬虫作者的解释，客户端经过计算出来一个票据，包含在将在服务端再次验证，验证通过则返回数据，验证不通过则不返回数据。如下图所示：

图：_
下面我们通过脚本来自动拉去这个页面数据试试
普通静态爬虫

 

首先我们先用最简答的来这个页面看看能都拿到这个页面的数据：

图： __ 
如上图所示，被反爬虫系统拦截了。
我们再用试试，使用最通用的“  ”的请求：

图： __
可以看到依旧会被反爬虫机制拦截。
反爬虫原理分析
通过人工浏览器访问、抓包分析，我们可以看到：
  人工访问这个网页一共发起了条请求  第条请求时直接请求目标，由于没有合法票据，返回。同时在页面中包含了个文件

图： _ 
 接下来的个请求分别为对页面中的脚本进行加载
 加载运行完毕后，获得了合法票据并添加进中再次发起请求，产生了第条请求。如下图：

图：_ 
第条请求带有合法票据，因此没有被掉，而是增加一个客户标示后跳转到了数据页面。如下图：中添加了签名。

图：  
 此时，中已经包含有了合法的签名以及客户，请求到了数据。得到了正常的页面：

图： _ 
基于的动态爬虫
至此，我们就可以根据前面的分析使用来逐步模拟人工请求，从而绕过反爬虫系统。先看代码：

 _
    
   
   

  = 
  = 
 = 
 = {}
 = 
 = {
     
               
}
 = {
     
     
}


     {
        
          ==  {
           
        }  {
             {
                  = 
                    =     {
                      {
                        _ = 
                         _{
                            _
                            _
                        }
                    }
                }
            }
        }


     {
        __
        
    }
    


}
在上述代码中：

我们先修改，设置请用，
同时自定义，伪造浏览器，
设置分辨率，进一步伪造人工浏览，
打开页面时引入文件，
使用的选择器选出页面中的所有元素，
如果元素中存在脚本，则运行这些脚本，
设置页面超时时间，并打印出页面内容。

运行结果如下：可见，我们的请求已经绕过了反爬虫机制。

图： __ 
行代码爬取：基于的类人动态爬虫
卧槽，我就是个开发，你跟我说抓包分析啥的我不会啊！！宝宝只想爬点数据而已啊…
那就用三行代码来实现吧：

第一行创建一个实例
第二行发起请求
第三行执行并退出



     
   
   


  = 
  {
  
}
 {
    
}
结果如下：

图：__ 
这三行代码不仅成功绕过了反爬虫的限制，而且自带的方法也将也数据结构化显示存储，对于复杂爬虫的开发可以极大的简化开发复杂度。
这三行代码中用到的就是—。
官方自称是一个开源的导航脚本和测试工具，但实际用起来爽的不行不行的。具体包括：

      
 
       
    
  
    
    
         

此外，最为强大的地方在于我在这里给大家简单介绍之后，我就不用再说什么了，拥有极其丰富的文档及实例代码。这一点对比核心文档还是，需要我们来撰写各类文档的来说友好太多了。
最后，鉴于拥有的丰富的文档，我也就不再班门弄斧了，本文就此打住。下次和大家分享讨论基于的检测工具。近日，腾讯云发布了分布式数据库解决方案，其最明显的特性之一就是提供了高于开源分布式事务的性能。大型业务系统有着用户多、并发高的特点，在这方面，集中式数据库单机数据库的性能很难支持，因此主流的互联网公司往往采用分布式架构数据库，物理上利用更多的低端设备，逻辑上对大表水平拆分支撑业务的需要。
虽然分布式数据库能解决性能难题，但事务一致性的问题，却很难在分布式数据库上得到解决。
分布式事务老大难题
数据一致难以实现
众所周知，一个事务所做的更新，分布式数据库系统内部多个独立的数据节点完成每个节点的本地事务是这个全局事务的一个事务分支，在这样一个全局事务提交期间，有可能某些事务分支无法成功提交。
针对这一问题，虽然业内早已存在理论解决方案——二阶段提交协议简称，并延伸出分布式事务简称的解决方案。但业内却少有工程化实现且大规模应用的案例。而腾讯云分布式数据库，却已在内部业务中应用多年。

图：二阶段提交算法
目前已应用在腾讯内部以上的交易、计费业务，并且三一重工树根互联、汇通天下、阅文集团起点创世中文网等、微众银行、和泰人寿、威富通等都在该产品。
腾讯云首发分布式数据库
支持 
腾讯云分布式数据库，是基于腾讯金融级数据库公司内部代号云化改造而来的兼容协议的分布式数据库。现如今，腾讯云已经正式在 分支协议上支持分布式事务，并已在腾讯云公有云、金融云发布供开发者使用。开发者可以通过申请实例，并在初始化后，连接实例运行如下进行初始化：

  
      注意：初始化前，请开启强同步复制能力，另外该会创建__，用户在后续使用中万勿对其进行任何操作。

为更好的支持分布式事务，还新增了命令：

 ，获取当前分布式事务的事务的全局唯一性标识，如果该事务不是分布式事务则返回空；  的格式：‘网关’‘网关随机值’‘序列号’‘时间戳’‘分区号’，例如 
 _“”，获取“”的状态，可能的结果有：    “”，标识该事务已经或者最终会被提交    “”，标识该事务最终会被回滚     空，由于事务的状态会在一个小时之后清楚，因此有以下两种可能：             一个小时之后查询，标识事务状态已经清除             一个小时以内查询，标识事务最终会被回滚
 运维命令：     ：向后端发送 命令，并进行汇总     ：显示当前分布式事务的等待关系可以使用命令将输出转化为等待关系图     ：当前网关上正在运行的分布式事务

以为例，可以对转账业务进行如下编码：   
 = = 
= = = =
 = 

     

        为一个账户的余额减
         =  __   =      =  
         = 
          ==  余额不足，回滚事务
            
            

        为一个账户的余额加
        =  __   =      =
        

      为了安全起见，建议在这里执行‘ ’获取当前事务的值，便于后续跟踪事务的执行情况

        提交事务
        
       
        发生故障，回滚事务
        
分布式事务的好处在于会大大降低应用开发难度，因为在某些不支持的数据库中，需要业务系统通过特殊并且巧妙的设计，而非利用数据库来解决事务中数据不一致等问题。这种对应用开发者的技术水平要求很高，越是复杂的业务系统，越会增加开发成本和技术门槛，这是业内大多数开发者面对分布式数据库时，只能望而却步的主要原因。
腾讯云 关键实现方案
、架构介绍腾讯云整个集群架构简图如下图，采用主从节点配置也叫作主备一套主从节点叫做，在每一个外配置网关，形成一个物理分片。

后端是或其分支版本数据库，目前腾讯云公有云发布支持的版本是基于 分支。
、网关与网关是用于接收请求并与后端建立连接的网络模块。网关可以用两种模式工作，一种称为，此模式下网关不处理不解析语句，透明转发请求和应答。另一种模式称为分布式，即支持自动水平分表模式下，会解析并转发到不同的数据分片。
在实现之前，网关不允许在一个事务中向多个发送语句。因为未实现二阶段提交时，事务采用一阶段提交，如果分布式中某一个提交失败了或回滚了，那么这个分布式事务就处于不一致的状态。
网关的工作方式
二阶段提交中需要的事务管理器。为了解决容灾、简化架构，腾讯云将实现在中，而的网关是一个无状态的模块，通过这一架构， 可以支持：
、分布式事务对业务透明，兼容单机事务语法 ；
、每个网关都可以独立接受和处理事务请求，且无需与其他网关进行协调节点故障不丢失事务；
、允许显式事务中多条语句分别发给多个分片；
、网关无需持久状态，无需容灾，可以随时经由调度集群退出或加入集群，且性能可以扩展；
、支持下单条语句写访问多个分片等。
网关还允许以流式处理方式运行 、 ，流式处理让这类操作变得非常方式非常高效；网关还支持两个使用分表键做等值连接，以及使用的子查询。
未来，腾讯云还计划支持分布式、、二级分区等高级功能，兼容更多高级语法。
、强同步与由于腾讯云默认采用强同步复制，即主从节点数据完全一致，因此事务也遵循强同步的逻辑，即需等待从机确认数据同步后，才给业务以应答。基于强同步，在以下两种异常情况下， 可轻松应对。
、主节点故障时，已确认事务数据不会丢失：主节点故障那么拥有最新数据和的从机就被选为主节点，这其中的数据也包括所有已经向用户确认完成提交的事务的数据。
、原主节点恢复后重新加入集群未确认事务自动闪回：原主节点恢复重新接入集群，它将作为从机运行，此时他可能存留多余的已提交事务此时事务并未得到强同步同步确认，即原备机并没有相关数据，那么这些事务会被闪回。虽然这些事务可能已经在原主节点的内部完成提交，但由于强同步机制，他并不会向客户端返回语句，这意味着仍被视为一个未完成的事务。因此，这些事务的闪回了也并没有破坏数据库的属性。这里值得说的是，闪回是基于生成做逆操作，它与数据库回滚并不同，闪回可以做操作。
腾讯云的强同步为腾讯金融级数据库自研的一项能力，性能比官方半同步大幅提高，几乎等于异步复制性能，腾讯云在腾讯内部应用多年，未发生过一起因为主从切换、故障带来的数据误差。而且，从性能上，也撑住了腾讯公司各类大型运营活动如红包、各类游戏大型推广等海量并发，其主要原因是强同步采用异步提交等待方式，且不占用数据库工作线程。
、并发控制与隔离级别为了达到数据一致性和性能的平衡，分布式事务的关键是数据库隔离控制。的隔离级别最高可以达到完全串行化，该级别将不存在幻读的问题，级别可以通过设置  _=来对所有物理分片和其上承载的数据库进行设置。当然，也可以通过调整隔离级别以调整数据库实例性能，理论上， 性能最高，但可能存在脏读、幻读的情况。
定义的标准定义的四种隔离级别
、分布式事务处理算法前面讲到，腾讯云的网关在模式下已经能够解析语句，腾讯云在网关上实现以使得最具效率。为此，我们在网关中实现中的协调器，并在网关中维护每个的状态，记录好每个写入的，然后在提交阶段做两阶段提交即可，大致流程如下：
、网关在执行一个事务的语句时，会记录这个语句修改了哪个；
、时会发送一个 在这个上面启动事务分支；注：事务开始时，并不确认事务将以哪种提交方式执行，因此总是以 来开启一个事务；
、检测是否影响个数≤，若是，则直接做一阶段提交   。
、影响个数≥，则改为做两阶段提交：
网关首先发送 ‘’ 给参与的大于等于个；接受到 应答表示成功确认；收到成功确认后，写入对应的 ，再发送 ‘’参与；如果有返回了错误，或者写入 失败，那么网关发送  ‘’给相关，这样这个全局事务就实现了回滚。
腾讯云的 是在中存储，这个步骤是批量完成的——网关后台线程会汇集正在提交的分布式事务然后在独立的连接和事务中完成对每个的写入，并且每个事务的 只写入一个中，因而这个开销并没有显著增加事务的提交耗时或者降低。而且，依赖腾讯云已有的强同步和容灾特性，只要成功写入了 ，就意味着数据已经写入从机。
虽然绝大多数的事务可以正常执行。但极少数的异常情况还是会影响整个集群稳定性，因此，腾讯云设计了监控模块，在故障后继续协助完成本地上面事务的提交，即会解析 ，并根据异常处理本地仍然处于的事务数据；如果 上面没有事务的提交决定的话，也会回滚超时未被提交的本地事务。
虽然在 、等版本早已实现，但这两个版本相对于仍然有性能不足，因此腾讯云目前只在公有云上基于支持版本。如今，腾讯云在 、、等分支中做了大量优化和相关修复部分已经提交到社区修复或开源，未来腾讯云还将继续致力于新特性的开发和相关的修复，为众多有需要的企业，提供更好的分布式数据库支持。前言
最近在做项目的时候用到了弹性搜索引擎，在检索遇到了一个诡异的问题，当存储长整型数据超过某个值具体就是百万就会出现数据精度丢失的情况，比如下面一个数据
数据
{
     
     {
         
         
    }
    
}
然后出来，发现被转成科学计数，存在精度丢失问题，在系统表示用户的身份，出现了偏差导致非常严重的后果，而浮点型数据却没有影响。
{
     
     {
         
         
    }
    
}
一、问题定位
 项目中首次采用，之前对这个搜索引擎了解不多，因此最开始怀疑数据是在搜索引擎那里转坏了，先查资料，后求达人，都没有找到答案，由于提供接口，走协议，通过抓包最后发现时候数据并没有被修改，那肯定是逻辑代码问题喽。
 服务框架采用，存储在的数据格式为，编解码使用的是框架的库，这个库在后台多个项目中使用过，之前一直都没有遇到过问题，最开始也没有怀疑到它，走了一段弯路。经过定位发现是将对象转发的时候出现了数据的改变，如下面的红框代码，出问题就是这一行代码。这里为了方便其它服务访问，封装了一个通用的增删改查的接口进行调用
  = _
  
 
{
     _ 
     _ 
     _ 
     = __
}
 走进框架代码，发现_将所有数据对象按照去处理，这样其实也是合理的，但是在转换成的时候却用了 ，用流算子做转换的时候会区分数据类型，当数据是整形的时候问题不大，如果是浮点型数据会出现数据被截断，流算子默认按型数据去处理，这是数据被篡改的原因。

  问题是数据并不是浮点型，而是整形，而正常用结构体的时候整形转换成字符串并没有问题，这又是什么原因呢？分析发布正常使用对象的时候都会指定数据类型格式，而_做解析的时候并没有这样子去做如下源码，也就是说如果使用库去解析，然后再回写成，出现大整数或数据则会出现精度丢失。
 _   
{
     =
     =

      此处省略解析代码

      =  
    =
     
}
二、解决办法
 _优化
找到了问题原因，解决起来自然就很容易，_在进行数据解析的时候指定对数据类型进行指定，避免整形数据转成当成型，这样改完之后整形数据再也不会有问题。
      =  
    =
    =
     
 精度问题
改完之后整形数据自然就没啥问题，但是我们知道在计算机系统中，的浮点数据分别占用位，是按照指数尾数方式存储，精确范围分别为小数点后位和位，采用流算子对数据进行转换还是存在精度丢失的问题，虽说浮点型数据在逻辑服务开发工作中比较少用到，但是从框架的角度希望能有一个比较完美的解决方案。
之前老师讲实现的时候，他重点介绍了浮点型数据格式化处理问题，处理地非常完美，但代码实现略显复杂，在这里使用标准库提供函数处理，基本能满足我们的精度要求，代码实现也会显优雅很多。
结语
框架提供了一些公共函数实现到的转换，大量都采用流算子实现，大家在日常的业务代码开发中，用它处理浮点型的数据要十分注意数据精度丢失问题。 协议由于是明文传送，所以存在三大风险：
、被窃听的风险：第三方可以截获并查看你的内容
、被篡改的危险：第三方可以截获并修改你的内容
、被冒充的风险：第三方可以伪装成通信方与你通信
 因为存在以上三大安全风险，所以才有了  的出现。
 涉及到了很多概念，比如 ，数字证书、数字签名、加密、认证、公钥和私钥等，比较容易混淆。我们先从一次简单的安全通信故事讲起吧，其中穿插复习一些密码学的概念。
一、关于  与他好朋友通信的故事
这个故事的原文是：

阮一峰老师也翻译过：
____ 
不过阮老师里面没有很好的区分加密和认证的概念，以及最后  的说明不够严谨，评论区的针对这些问题的讨论比较激烈，挺有意思的
这里重新叙述一下这个故事：
故事的主人公是 ，他有三个好朋友 、 和 。 经常跟他们写信，因为他的信是明文传输的，在传递过程可能被人截获偷窥，也可能被人截获然后又篡改了，更有可能别人伪装成  本人跟他的好朋友通信，总之是不安全的。他很苦恼，经过一番苦苦探索，诶，他发现计算机安全学里有一种叫非对称加密算法的东东，好像可以帮助他解决这个问题
说明：非对称加密算法是内容加密的一类算法，它有两个秘钥：公钥与私钥。公钥是公开的钥匙，所有人都可以知道，私钥是保密的，只有持有者知道。通过公钥加密的内容，只能通过私钥解开。非对称加密算法的安全性很高，但是因为计算量庞大，比较消耗性能。
好了，来看看  是怎么应用非对称加密算法与他的好朋友通信的：
、首先  弄到了两把钥匙：公钥和私钥；

、 自己保留下了私钥，把公钥复制成三份送给了他的三个好朋友 、 和 ；

、此时， 总算可以安心地和他的好朋友愉快地通信了。比如  要和他讨论关于去哪吃午饭的事情， 就可以先把自己的内容明文首先用  送给他的公钥做一次加密，然后把加密的内容传送给 。 收到信后，再用自己的私钥解开信的内容；

说明：这其实是计算机安全学里加密的概念，加密的目的是为了不让别人看到传送的内容，加密的手段是通过一定的加密算法及约定的密钥进行的比如上述用了非对称加密算法以及  的公钥，而解密则需要相关的解密算法及约定的秘钥如上述用了非对称加密算法和  自己的私钥，可以看出加密是可逆的可解密的。
、 看完信后，决定给  回一封信。为了防止信的内容被篡改或者别人伪装成他的身份跟  通信，他决定先对信的内容用  算法做一次处理，得到一个字符串哈希值， 又用自己的私钥对哈希值做了一次加密得到一个签名，然后把签名和信明文的一起发送给 ；



说明 ： 的内容实质是明文传输的，所以这个过程是可以被人截获和窥探的，但是  不担心被人窥探，他担心的是内容被人篡改或者有人冒充自己跟  通信。这里其实涉及到了计算机安全学中的认证概念， 要向  证明通信的对方是  本人，另外也需要确保自己的内容是完整的。
、 接收到了  的信，首先用  给的公钥对签名作了解密处理，得到了哈希值 ，然后  用了同样的  算法对信的内容作了一次哈希处理，得到另外一个哈希值 ，对比  和 ，如果这两个值是相同的，那么可以确认信就是  本人写的，并且内容没有被篡改过；

 说明： 跟  其实构成了一次完整的通过数字签名进行认证的过程。数字签名的过程简述为：发送方通过不可逆算法对内容  进行处理哈希，得到的结果值 ，然后用私钥加密  得到结果值 。对方接收  和 ，用公钥解密  得到 ，然后用  进行同等的不可逆处理得到 ，对  和  进行对比即可认证发送方。
、此时，另外一种比较复杂出现了， 是通过网络把公钥寄送给他的三个好朋友的，有一个不怀好意的家伙  截获了  给  的公钥。 开始伪装成  跟  通信， 感觉通信的对象不像是 ，但是他又无法确认；

、 最终发现了自己的公钥被  截获了，他感觉自己的公钥通过网络传输给自己的小伙伴似乎也是不安全的，不怀好意的家伙可以截获这个明文传输的公钥。为此他想到了去第三方权威机构证书中心 ，简称 做认证。证书中心用自己的私钥对  的公钥和其它信息做了一次加密。这样  通过网络将数字证书传递给他的小伙伴后，小伙伴们先用  给的公钥解密证书，这样就可以安全获取  的公钥了。

二、 通信过程
通过  与他的小伙伴的通信，我们已经可以大致了解一个安全通信的过程，也可以了解基本的加密、解密、认证等概念。 就是基于这样一个逻辑设计的。
首先看看组成  的协议： 协议和  协议。 协议就不用讲了，而  就是负责加密解密等安全处理的模块，所以  的核心在  上面。整个通信如下：
、浏览器发起往服务器的  端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。
、服务器收到请求，选择浏览器支持的加密算法和哈希算法。
、服务器下将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。
、浏览器进入数字证书认证环节，这一部分是浏览器内置的  完成的：

 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。

 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性验证过程类似上面  和  的通信。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。

 浏览器生成一个随机数 ，并使用网站公钥对  进行加密。


、浏览器将加密的  传送给服务器。
、服务器用自己的私钥解密得到 。
、服务器以  为密钥使用了对称加密算法加密网页内容并传输给浏览器。
、浏览器以  为密钥使用之前约定好的解密算法获取网页内容。

备注 ：前  步其实就是  的握手过程，这个过程主要是认证服务端证书内置的公钥的合法性。因为非对称加密计算量较大，整个通信过程只会用到一次非对称加密算法主要是用来保护传输客户端生成的用于对称加密的随机数私钥。后续内容的加解密都是通过一开始约定好的对称加密算法进行的。
备注 ： 是  安全性的核心模块， 的前身是 ， 就是 ， 是 ， 则是 。  是建立在  协议之上，因而也是应用层级别的协议。其包括    和    两个模块，后者负责握手过程中的身份认证，前者则保证数据传输过程中的完整性和私密性。大家好，我们是吃茶少年团队，这是我们团队第一次参加比赛。由于没什么经验，走了很多很多的弯路，我们在比赛中跟随大佬亦步亦趋地摸索前进。目前成绩在名，写下这篇比赛心得，希望能共同交流、进步。
数据方面
关于训练集、测试集的选取上：由于比赛数据是时序的数据，所以我们首先想到的思路是尝试用日的数据预测日，使用这样的训练集、测试集设置线下的对数损失很小，但是线上和线下的增减时而同步时而不同步。然后，经过我们多番尝试最终选择了随机生成为训练集、为测试集，调整随机数种子使得线上和线下尽可能同步。
关于本次比赛的数据，我们可以把比赛给定的天中每个小时的转换率画出来，如下图所示。我们可以明显看到最后几天转换率偏低，这是由于用户转换时间存在延迟造成的，对最后几天数据有影响，也就是说最后几天的数据存在噪音，转换率偏低。如果想要把最后加入训练集，那么需要最后对预测结果进行一个修正过程，可以通过反函数对预测概率进行修正。同样，在这个图中可以看到号的上午和号的中午存在两个转换率特别异常高的时段，我们可以分析为什么这两个时间段转换率特别高，这对我们数据清洗有一定帮助。

特征工程
关于特征工程方面，我们首先尝试了一些基本的组合特征，把各类特征组合起来使用点击数、转换数、转换率来表达。通过这些基础的组合统计特征，使得分数上涨了个千分点。我们把过程中尝试的特征过程展示如下表所示：可以看到每次成绩的大进步都是依赖于新的强特征的增加。



特征组合
线上成绩




类特征进行编码，使用进行分类



把所有原始特征进行，使用进行分类



原始特征组合统计特征



原始特征组合统计特征时间序列特征



原始特征组合统计特征时间序列特征




之后的找新特征过程，我们主要按照三个方面来找：
  从业务的角度，即我们去猜测用户点击广告后是否发生转换可能与哪些因素有关。这部分通过猜测结合分析数据来实现，生成特征后使用来确定这个新特征是否会对的分布造成影响。比如在下面这张图中，我们通过命令，这个变量不同的取值对的分布有较大影响，可见这个变量对是否转换影响还是很大的。

  从模型提供的信息，我们使用了这一模型来训练，通过给出的特征重要性，主要观察特征重要性在前面的特征，考虑这些特征是否可以有更好的表达。在下图给出的特征重要性中，我们可以看到类的特征都占据着十分重要的特征，对于这些重要性很高的特征，我们尝试把这些特征进行两两组合，而对特征重要性很低的特征比如平台等我们可以考虑把他们去除。把这些无用的特征去除，可以加快训练模型的速度，也可以避免对模型产生干扰。

  多与人交流。我们产生的很多新特征都来自于群里小伙伴的讨论中，从大家的讨论中得到一些灵感，积极借鉴大佬们的思路，借此生成新的特征。比赛中经常会出现较为隐蔽、但对分类效果提升很大的特征，这些特征往往来自于各个小伙伴的灵光一现，多关注群里的进展，往往可以获取这些特征，从而使成绩飞跃。
心得

多看比赛经验，我们参考了上的一些比赛心得，特别从获胜者的代码中学到了很多技巧。比如从台大获胜的代码中，用效率更高的词典来代替的命令，这些代码技巧可以使得数据处理时间上大为减少。

多观察数据。原始特征的表达决定了成绩的上限，强特征往往来自于数据之间的隐含关系，找到强特征相当于把这件分类的事情以一个更好的表达方式告诉给算法。类似的比赛中往往有很多经典的特征，可以模仿前面比赛的思路。

多和其他参赛者交流。群里有很多大佬，提供着不一样的思路，借鉴大佬们的思路，相当于做一个，参考大佬们的经验增加思路，会取得更好的成绩。


第一次参加比赛，收获很多，最后感谢腾讯提供的比赛、感谢队友、感谢群里的大佬。蔡述雄，现腾讯用户体验设计部空间高级工程师。智图图片优化系统首席工程师，曾参与《众妙之门》书籍的翻译工作。目前专注前端图片优化与新技术的探研。

在第一篇《包学会之浅入浅出：开学篇》和上一篇《包学会之浅入浅出：升学篇》的学习中，我们首先了解了环境的搭建以及两个重要思想——路由和组件的学习，通过组件库中的按钮组件和导航组件，相信大家也开始了解相应的知识点，接下来我们会详细分析下如何完成由多个组件组成一个复用组件的开发流程。
下面先看看我们的需求
列表组件
本节我们主要要完成这样一个列表功能，每一行的列表是一个组件，列表内可能出现按钮组件或者箭头组件，点击按钮组件可以自定义事件，同时可以根据不同的参数来决定当前列表是带按钮的列表带箭头的列表。
 
首先看看



   =
     ={{}}
     = = =
  



     
   {
    {
       {
         下载
      }
       {
         默认的文案
      }
    }
     {
       
    }，
    {
      {
          按钮点击事件
      }
    }
  }

上面的知识点基本上就是我们之前学过的，只不过记住本身是一个组件，而在这个组件里面，我们又引入了按钮组件，也就是组件内引用组件，实际上就是组件的嵌套，注意到这里：=的使用，这里冒号表示绑定的是一个变量，然后这个属性通过暴露出去本身在按钮中就暴露了给列表组件使用，借用下面一张图理解下：

至于点击事件，也是我们之前学习过的事件的绑定。现在引入一个新问题，是否有一个参数，可以决定列表组件的右侧是放置按钮组件呢？还是箭头组件。
动态组件
中提供了一些特定关键字：和特定的结构来生成动态组件，让我们修改下里面的内容先：

     
     
   {
    {
       {
         下载
      }
       {
         默认的文案
      }
      {
         
      }
    }
     {
       
       
    }
     {
         {

      }
    }
  }

首先我们先多一个箭头组件，在中添加一个自定义标签‘’，注意到我们多了一个的自定义属性，默认值是，现在再看看标签里面写什么：

   =
     ={{}}
     = = = =  
  

我们把标签去掉了，取而代之的是一个标签，这是自带的一个标签，可以把它当作一个容器，这个容器可以用来装按钮，也可以用来装箭头。决定这个容器装的是哪个组件的关键代码在于：=，当的值为的时候，这个容器就是按钮组件，当它是的时候，就是箭头组件。而我们刚才给这个变量定义的默认值是。
关键字保持这个组件在内存中是常驻的，由于动态组件可能需要动态切换，这样保持组件活跃可以减少组件变化时候的内存消耗。
可以看到我们的上还保留着按钮的点击事件和信息，这些没有关系，只要箭头组件中不出现同样的变量就不会发生冲突。
 =自定义文案，默认右边是按钮 =弹层
 =
 = =最右边是箭头 =
使用列表组件的时候，只需要给暴露出来的指定一个值，就可以决定右侧是按钮还是箭头了。注意最后一个上有一个的属性，这个属性代表组件集合，当页面中有很多组件的时候，可以通过几种方法来获取对应的某个组件的信息：
通过数组获取
通过对象集合获取
其实关于动态组件，不一定要用：来实现，在中有一个指令叫做    ，统称判断指令，配合展示指令，可以根据指定的值来决定对应的组件是否应该展示，另外这种做法我不展示了，就当做一个作业吧，有兴趣的还是建议实战一下，毕竟我们也只是教大家入门学习，后面还是希望大家能够自己去扩展学习。
生命周期
这里简单讲一下什么是组件的生命周期，上面我们通过来获取组件对象的信息，那么在什么时候或者说哪个时机点去做这件事呢，组件从引用到调用到销毁比较少操作有以下几个关键回调函数：

    {
     {
       
    }
    {}组件实例化之前
    {}组件实例化了
    {}组件写入结构之前
    {组件写入结构了
      
      
    }
    {}组件更新前
    {}组件更新比如修改了文案
    {}组件销毁之前
    {}组件已经销毁
  }

所以要想使用的内容，就需要在组件写入之后才能开始调用哦！
我还需要学什么
目前为止，我们三篇文章已经学了大部分的关于组件和路由的知识，当然这并不是的全部，只是相对于其他的知识点，这些可以算是一个垫脚石，看懂了这些，对后面其他的应用，帮助很大。下面我列举一些其他的，后续大家可以去官网查看资料的一些关键点，其实都不难，只要有一些小小的项目实践，你会发现也不过如此。
过渡
过渡其实就是动画，这些，只是写变成好像在写一样，有点类似于的一些思想。
指令
目前为止我们学习了一些常用指令，像，，，还有几个常用的像刚才提到的判断指令和指令，还有指令主要用于等表单组件。当知道指令作用的时候，学习起来其实并不难。

渲染这个方法是我觉得应该用心去学习的，它可以方便我们写出更好的面向对象的组件，而学习它的成本在于这个接口更接近于原生代码的使用。如果有需要，后续也可以写一篇关于的文章。
总结
三篇系列文暂时在这里告一段落，有些童靴可能到这里还是觉得没有学会，对不起，可能是我的标题太夸张了，也可能因为我的例子还不够清晰，文笔也还不好理解。不过没关系，回顾我们的学习历程，你可以按照这个知识点的学习过程，去找更多的文章，毕竟“熟读唐诗三百首，不会作诗也会吟”嘛。当然，学习过程中我们自己更多的练习和尝试才能锻炼巩固知识。至于浅入之后是浅出还是深出，还是要靠大家自己去定义了！
文末附上所有相关代码和官方文档地址


相关推荐
第一篇：《包学会之浅入浅出：开学篇》
第二篇：《包学会之浅入浅出：升学篇》为了保证的性能，我们都建议单表不要太大，也经常有人问我这样的问题，整体来说呢，建议是：单表小于，记录数小于千万，十库百表。如果但行记录数非常小，那么记录数可以再偏大些，反之，可能记录数到百万级别就开始变慢了。
那么，业务量在增长，数据到瓶颈了怎么办呢，除了使用分布式数据库，我们也可以自行分库分表，或者利用的分区功能实现。
本文主要介绍几种分区的选型建议和语法，其实影响分区性能最重要的一点还有索引的设计，非常关键，如果索引没设计好，可能分区表的性能并不理想，后续单独整理分享。
分区的优势：
、冷热分离：表非常大且只在表的最后部分有热点数据，冷数据根据分区规则自动归档。
、定期淘汰历史数据：按时间写入，历史数据可淘汰，可快速删除，空间可快速回收。
、优化查询：在字句中包含分区列时，分区可以大大提高查询效率，减少缓存开销、减少开销。
、统计性能提升：在涉及和这类聚合函数的查询时，可以在每个分区上面并行处理，最终只需要汇总所有分区得到的结果。
的分区规则：
范围 ：   
列表 ：   
：  
 ：  
子分区：  
一、 
   
        _
       
     
       
      
      `_` 

   _  
         
         

这种是最常见的，也是我们平台提供自动按天见分区的格式。一般也比较适合按天分区，或者固定范围的分区，比如时间范围，只能按照数字大小年龄／编号进行区间划分。
优势：
、按分区快速淘汰历史数据
、按分区字段的范围查询
这里不得不吐槽一下，有的人，每天把数据往一个统计表里面存，不做分区，也不做历史数据淘汰，等到了，甚至以后，数据出不来，火急火燎的跑过来问题要怎么删除历史数据，而且表连一个主键、索引都没有，我只能说删表吧哥非常无赖
二、 
   
        _
       
     
       
      
      `_` 

   _  
        
        

表面上看，咦？好像使用分区的都可以使用分区实现呢，其实大部分场景两种分区方式都是可以实现的，线上实际只能使用分区的场景也比较少。
连续数据更趋向于使用分区， 分区一般比较适合离散数据的分区，同时可以将多个离散的属性归类存储，比如我需要把、、三个时间的数据放一个分区，、、放个分区，这种就适合使用分区，针对自己业务特性进行离散的分区，可以非常灵活的将数据打散到不同的分区。可以看出这种分区策略就不适合条件的范围查询，适合固定值的条件查询。
优势：
、灵活的离散数据分区，可自定义分区规则。
、 离散分区不适合条件   ，适合固定分区的等值查询或条件查询

三、 
   
        _
       
     
       
      
      `_` 

  _ 
 
分区很好理解，就是对指定列做，均匀的存到指定的分区，比如按用户名分区，那么按用户名进行查找的速度就会快很多，这种针对分区列数据不固定，想把数据根据分区列离散的存储到固定分区数的表中，不需要做数据淘汰的场景比较适合。
优势：
、维护简单，分区数固定，根据自动分区。
、适合固定条件的等值查询 
、对于分区列数据不固定，分区列值不固定不适合，可根据值均匀打散数据到不同分区。
四、 
   
    _
       
     
       
      
      `_` 

   
 
同样，使用分区跟分区有着神奇的相似，不同的是，如果表有主键或者唯一键的时候无需指定的列名，分区自动根据键值进行分区。
优势：
对于有主键的表，可无需关心分区列，自行根据主键／唯一键分区。如果主键设置不合理，查询条件都不带主键，查询性能会很差。

五、删除分区
移除分区：      
删除分区：     
移除分区仅仅修改表分区定义，数据不会被删除；删除分区会删除分区定义同时删除分区上的数据。
更多分区管理：增删修改

分区表操作优化器如何选择：

分区类型定义说明：
的生态日趋成熟，开源社区也不断孵化出优秀的周边项目，覆盖网络、监控、维护、部署、开发等方面。帮助开发、运维人员快速构建、运营服务环境，其中也不乏有大公司的影子，如、、，甚至微软也宣称后续将提供在平台的支持。
的发展前景一片大好。但在企业当中，如何选择适合自己的构建方案？可选的方案有与都已整合各类组件，另外一种方案为，采用松散式的组织结构，但各个组件之间的通讯是非常严密的，且可扩展性更强，定制也更加灵活。数据中心业务平台首选此架构，已进入试运营阶段。下面详细介绍如何使用构建一个高可用及自动发现的基础架构。
一、 架构优势
约定由构建的基础服务平台简称“” 架构，整合了多种开源组件，看似松散的结构，事实上已经是一个有机的整体，它们互相联系、互相作用，是生态圈中最理想的组合之一，具有以下优势：

自动、实时发现及无感知服务刷新；

支持任意多台主宿机；

支持多种接入且打散至不分主宿机；

采用存储信息，集群支持可靠性高；

采用配置引擎，支持各类接入层，如；

支持负载均衡、故障迁移；

具备资源弹性，伸缩自如通过生成、销毁容器实现；


二、架构说明
在架构中，首先管理员操作 ，除了提交容器启动与停止指令外，还通过方式向存储组件注册容器信息，包括容器名称、主宿机、映射端口等。配置组件会定时查询组件获取最新的容器信息，根据定义好的配置模板生成配置文件，并且自动 服务。用户在访问业务服务时，完全没有感知后端的上线、下线、切换及迁移，达到了自动发现、具备高可用等特点。详细架构图见图。

图  平台架构图
为了方便大家理解各组件间的关系，通过图进行架构流程梳理，首先管理员通过或操作容器，下一步将容器信息注册到组件，组件会定时查询，获取已经注册到中容器信息，最后通过的模板引擎生成配置，整个流程结束。

图  架构流程图
了解架构流程后，我们逐一对流程中各组件进行详细介绍。
、  介绍
是一个高可用的  存储系统，主要用于分享配置和服务发现。

简单：支持  方式的用户  

安全：可选  客户端证书认证

快速：单实例可达每秒  次写操作

可靠：使用  实现分布式


、  介绍
是一个轻量级的配置管理工具。通过查询，结合配置模板引擎，保持本地配置最新，同时具备定期探测机制，配置变更自动。
、  介绍
是提供高可用性、负载均衡以及基于和应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。来源百科
三、架构部署
平台环境基于构建，其中的版本为  ，版本为 ，版本为  。下面对平台的运行环境、安装部署、组件说明等进行详细说明，环境设备角色表如下：



角色
主机名

环境说明




接入层





存储层





主宿机





主宿机
…
…




 、组件安装
 安装
终端登录服务器，执行以下命令：
     
   
   
 、安装
终端登录服务器，执行以下命令：


  –  


  
   
   
  
 


 安装
终端登录服务器，执行以下命令：
    
      
   
  
 
   
  
  
、 组件配置
 配置
由于是一个轻量级的存储平台，启动时指定相关参数即可，无需配置。
            
由于具备多机支持，参数“”指定与其它节点通讯的地址；参数“”指定服务监听地址；参数“”为指定数据存储目录。
由于是通过方式进行交互，常见操作如下：

设置 操作


      =  
{{  }}

获取 信息


   
{{  }}

删除信息

             {{}{  }}
更多操作见
  配置
由于的配置文件是由组件生成，要求务必要与安装在同一台主机上，的配置有两种，一种为资源配置文件，默认路径为“”目录，另一种为配置模板文件，默认路径为“”。具体配置如下：
创建配置文件目录
   {}
 配置资源文件
详细见以下配置文件，其中“”为指定模板文件名称默认到路径中查找；“”指定生成的配置文件路径；“”指定关联中的列表；“_”指定服务重载的命令，本例中配置成的命令。
【 】

 = 
 = 
 = 
  

_ =  
配置模板文件
模板引擎采用了语言的文本模板，更多见，具备简单的逻辑语法，包括循环体、处理函数等，本示例的模板文件如下，通过循环输出及信息。
【】

          
         
         
         
        


          
         
         
         
         
         
          
          
          

  
         
         
         
         
        {{  }}
         {{ }} {{}}       
        {{}}

         
          
          
           
模板引擎说明
本小节详细说明模板引擎基础语法与示例，下面为示例用到的信息。
   _  =
   _  =
   _  =
   _  =
、 
作为函数的别名，获取路径最后一段。
{{   _}}
 {{ }} {{}} 
{{}}
_ 
、 
返回一对匹配的，找不到则返回错误。
{{  _}}
 {{}}

 {{}}
{{}}
_ 
、 
返回所有匹配的，找不到则返回错误。
 {{  }}
{{}} {{}}

 {{}}
    _ 
    _ 
    _ 
_ 
、 
返回一个匹配的字符串型，找不到则返回错误。
{{ _}}

、 
返回所有匹配的字符串型，找不到则返回错误。
    {{  }}

        {{}}

    {{}}
        
        
        
        
、 
对输入的字符串做处理，即将字符串按指定分隔符拆分成数组。
    {{  =   _  }}

       {{  }}

       {{  }}
           
           
、 
返回所有的字符串型子，找不到则返回错误。
{{  }}
    {{}}
{{}}
    _
    _
    _
    _
、 
返回所有的字符串型子目录，找不到则返回一个空列表。
{{  }}
    {{}}
{{}}
 
启动及服务
下面为启动服务命令行，参数“”为指定探测的频率，单位为秒，参数“”为指定监听服务主地址，以便获取容器信息。
           
  
 、容器配置
前面架构说明内容，有讲到容器的操作会即时注册到组件中，是通过命令进行方式提交的，下面详细介绍通过及两种方式的实现方法，支持容器启动、停止的联动。
 、实现方法
实现的原理是通过获取“  ”命令输出的 ，通过“   ”得到详细的容器信息，分析出容器服务映射的外部端口及容器名称，将以“容器名称”作为，“主宿机 映射端口”作为注册到中。其中信息前缀与“”中的参数是保持一致的。【】


     
             
                   
         


   _  
  _=


   _  
  _=


     
  =


   _  
  _=` |    |   |     |  { }`


 _ {
            _ 

        _=`                   `
        =`  _| \\  | \\  |  |   | `
        =`  _ |   |     |  \|  `

           _
          __  =_

                
}

 _ {
          
        _=`  |   |  { }`
           _
          _
         __
          __  
         
}


   =   
  _ 

  _ 

使用方法
、启动一个容器
  镜像
、停止一个容器
   _容器名
、 实现方法
通过语言调用的实现容器的远程操作创建、运行、停止，并结合模块对进行操作、，达到与方式一样的效果，很明显，方式更加容易扩展，可以无缝与现有运营平台对接。
为兼顾到远程支持，需对启动文件“”处进行修改，详细见如下：
  
        
启动容器的程序如下：
【_】

 
 
 

_=
_=
_=
_=
=

=
=

={}
={}

     = _=_==
 
        
    


    =_=_===  =
==
    =
 
        
    


    = ={{  }{  }{ 
 }{  }} _={} _=__= = =
= _= _= _=_= _= _=
 
        
    


    =_
    =
    =__
     _  
         _==
            =
 
         
    

 =  =
    
         = =_ =
         _
            
     
            

      
停止容器的程序如下：
【_】

 
 
 

_=
_=
=_ 指定需要停止容器的名称


     = _=_==
    _
 
     
    


     = =_ =
    
        
 
 
注意：
由于容器是无状态的，尽量让其以松散的形式存在，映射端口选项要求使用“”参数，即使用随机端口的模式，减少人手干预。
四、业务上线
架构已部署完毕，接下来就是让其为我们服务，案例中使用的镜像“”为已经构建好的平台。类似的镜像也可以在中下载到，开始跑起运行创建两个容器：
   
    
  
{{_}}
       _

   
    
  
{{_}}
       _
访问监控地址：，刚创建的容器已经添加到中，见图。

图 监控后台截图    
观察的配置文件更新部分：
  
… …
  
         
         
         
         
         _        
         _        
… …
访问测试文件

图  测试文件截图   
从图可以看出，获取的服务器端为容器本身的地址，在环境变量处输出容器名为“”的信息。
参考文章：        导语
这是一本关于如何写好代码的书，是一本关于“如何编写别人能看懂的代码”的书。从价值观、原则、模式三个层面解读如何优化代码结构，减少代码维护成本。
关于这本书：

作者简介 ，软件开发方法学的泰山北斗，是最早研究软件开发的模式和重构的人之一，是敏捷开发的开创者之一，更是极限编程和测试驱动开发的创始人。

这本书的目标这本书的目标是帮助你通过代码表达自己的意图。

章节概览



图：章节概述 
模式
模式就是我们在编写代码时固定的规则。

图：模式
举个栗子 编程中，我们想写一个函数，需要给它命名。那么映入我们脑海的是：

图：给函数命名的模式

模式让你感觉到束手束脚，但可以帮你节省时间和经历，提高效率。
模式的种类繁多，众多模式构成了一种编程风格

一种编程理论
价值观

图： 编程理论价值观
原则

图：编程理论原则
小结
上面提到了个关键词，分别是：模式、原则、价值观。
模式是编码是的一些约束，众多的模式共同构筑了一种编程风格。
价值观是编程过程中统一支配性主题，影响了我们在编程中所作的每个决策。
原则是模式和价值观之间搭建的桥梁，在遇到没有现有模式可以解决的问题的时候，原则往往可以让我们“无中生有”的创造一些东西，而这些东西往往都是很不错的。

图： 模式原则价值观
摘录书中的一句总结：模式描述了要做什么，价值观提供了动机，原则把动机转化成了实际行动。
动机
由上面的讨论可以知道，价值观为模式的形成提供了动机。那么主要的动机之一是软件设计应该致力于减少整体成本。

经过统计，人们发现，维护成本远远高于初始成本。也就是说维护的代价很大。因为理解现有代码需要耗费很多时间，而且容易出错，改动之后还需要重新测试和部署。

通过合理的模式的使用，可以降低经济成本。
类
关于类，书中讲解了很多细小的点。有的比较有意思，值得一说。
通读本章后，进行了梳理整合，做如下总结。

类的命名类的名字应该是简明扼要，简短而有表现力。一个好的命名可以大大增加理解代码的容易度。

针对接口编程，不针对现实编程对操作进行抽象，由子类实现各自的具体逻辑。接口对扩展开放，对修改关闭。比如想给一个增加一个函数，不能直接添加， 要重新写个继承它。如果直接在原增加函数，就要导致所有实现了本接口的地方都要修改，这个代价是非常大的。

当我们从其他地方复制了一大段代码如果有两个地方的代码非常相似甚至相同，那就要考虑是否可以抽取到公共父类或者工具类中。直接拷贝一份的弊端很明显，维护起来很困难，比如其中一个地方需要修改，那么另外一个地方是不是也要修改呢。而且增加了代码的阅读难度，这明显和模式的原则不符。

内部类和匿名内部类内部类当被实例化之后，会获得创建它的外部类对象的引用，所以可以直接访问后者的数据而不用建立额外的连接。但是这中对象持有操作有内存泄漏的风险。比如在手中中就有特殊的操作来避免内存泄漏。

逻辑委派和可插拔的选择器把相同的逻辑统一处理，然后把不同的逻辑发放给不同的模块去处理。在手中，不同的回报消息在统一处理之后发放给不同的回调逻辑，也是一种实际应用。



图：逻辑委派 
可插拔的选择器和逻辑委派很相似，比如有一个打印类的函数列表的工具方法，传给它不同的类名，就打印不同的类的函数信息。

类库实现模式、实现模式

把一些公共的方法放到一个公共的类中，声明为，当成工具来调用。可以简化代码，看起来更清晰。
状态
  直接访问与间接访问
在类中有很多变量，每一个变量都会存在很多状态，比如有和两种状态，一般类的范围内进行直接访问，对外部的访问一般强制间接访问，也就是通过的函数访问。比如下面这种方式一般是类内访问。
  = 
而下面这种方式一般用在类外访问。
    {
      
 }
其实就是合理使用中的、、修饰。
  变量的分块
在一个类中有很多变量，比如成员变量、静态变量、公共变量，除了变量名命名要规范外，还要分区分块。比如类型的应该放到最上面，并且与其他类型的变量隔开。
 参数
一个变量想传递到其他地方有很多方法。比如可以设置成，让别人直接访问。但是这种方式耦合程度太高，比如改一个变量名，所有引用的地方都要修改。可以使用参数，直接把一个状态传递到另外一个地方，而不涉及二者之间的耦合。
 变量的初始化：及早初始化和延迟初始化
初始化就是给变量一个默认的状态。对于对性能影响较低的初始化可以及早初始化，可以保证变量在后续的使用过程中是已经初始化了的。并且变量的初始化要尽量放到一起，这样逻辑更清晰，也更美观。比如中的在初始化时就要尽量放到一起。延迟初始化是考虑到了性能问题，如果初始化成本很高，就可以考虑通过延迟初始化来实现快速启动。
行为
 主体流
虽然是面向对象编程，但是在一个函数中，也是由上到下依次执行。主体流中包含了一些异常判断和卫述句 。
 卫述句
卫述句是异常检查的一种方式。在程序的主体流中，需要判断某些不适用主体流的情况。
   {
       {
         
     }
     
 }
我们习惯了这种约束，当看到的时候，很容易就想到需要语句。卫述句则不需要子句，它是表达的另一种情形，只是一次主体流中的异常判断。
 异常传播
当程序发生异常，不能直接将日志信息输出，这样被有心之人抓取到了会产生安全隐患。同样也不能置之不理，这样后面排查问题就很困难。正确的做法是调用异常处理工具，比如写入日志文件等等。
方法
把大块的逻辑分成许多块，每一块都是一个方法，每个方法起一个顾名思义的名称。这样的代码理解起来更容易，更易于维护和重用。
 安全复制
如果在一个类中有一个，存放着若干个类的对象实例，比如
   =  
如果外界想访问这个列表呢，通常的做法是这样的
    {
      
 }
这样的话会有安全隐患，我们必须要考虑，外界的逻辑是否会对我们的数据产生影响
   数据被莫名修改，会发生一些问题。
考虑更高的安全性，我们可以这么做
    {
       =  
     
      
 }
当然，安全复制不可滥用，如果数据很大，这种复制会占用耗费的内存和性能，所以更好的做法是综合考虑安全性和性能的平衡。
 方法注释
对于沟通良好的代码来说，很多注释完全是多余的。在强调命名的沟通性和表达性的时候，注释显得处在一个很别扭的层次上。注释不是越多越好，在必要的时候添加适当的注释是合理的。当然，在后期的代码修改的时候，记得及时更新代码注释，否则注释不正确反倒对阅读人造成了误解。
容器
 使用容器应该关心的一个问题
在将容器暴露给外界使用的时候，需要考虑外界是否可以对容器进行修改。比如无法保证容器中的数据不被修改，外界可以直接调用它的方法进行修改，而不通知容器所有者，这样会出现问题。解决办法之一就是返回一个安全拷贝。
 不可变的容器
当只想把容器暴露给外界而不希望被修改时，除了安全拷贝外，还可以创建不可修改的容器，当容器的元素被外界修改时，程序会 。

图：不可变的容器 
 容器的继承和委派
有时候我们可能需要继承一个容器类。比如新建一个书籍列表的类，我们的目的是给他提供类似集合一样的增删改查操作。一个很直接的想法是让它继承。
    {
    
}
这种操作实现了的、、迭代以及其他容器操作，但是这种方式会带来一些问题。比如一般我们不需要的操作，但是如何避免用户调用呢，总不能把所有不需要的方法都加以实现并抛出来取消继承。
这里可以使用委派来实现这种操作。
  {
      =  
}
使用这种方式可以只暴露一些需要的方法。我在头像墙中就是这样做的。
  {
      
}
改进框架
 更新框架时的向前兼容性
在更新框架的时候，一个非常重要的点就是向后兼容。更新框架的功能不能影响到现有代码的逻辑。在设计框架的时候，保持代码尽可能简单的同时，也要尽可能提高代码的适用范围，考虑后续框架的更新是否容易。
 兼容性更新—增量式更新
包为框架代码的增量式更新提供了一条途径，可以在新的包下创建相同类名的新类。比如把更新后的放到这个类中，这样的话客户代码只需要更新语句就可以实现更新。修改更加简单，影响更小。
 抽象—接口和抽象类
多使用接口和抽象类可以提高框架的灵活度。只将必要的逻辑暴露给外部使用，内部逻辑是的。当修改框架代码时，只要接口和抽象类的抽象方法不变，其他的逻辑可以灵活修改，外部调用者不会受到任何影响。
附录 
这部分主要是介绍了一个度量操作性能的框架。介绍了设计框架时要注意的一些事情。
设计操作度量框架要注意以下几个要点：
将操作执行多次，取平均值，克服精度问题。在测量时要考虑的自动优化机制会不会影响操作执行的时间。
总结
这本书主要是着力于编程时的思维层面上的考虑。开发者大脑中要时刻铭记沟通、简单、灵活的价值观，遵循实现模式，并学会在遇到前所未有的问题时，能在价值观的指导下，利用现有原则找到更为恰当的解决方案。
：的渲染貌似有些问题，某些效果没有我本地编辑器渲染的好。附件里提供文档，有需要的可以直接下载了看。作者简介：

 李智桦老师，北京站金牌讲师，台湾著名精益布道师，敏捷专家，著有《精益开发与看板方法 》。

原文链接：

文章来源：时代社区前言
 国际化简称 ，因为在和之间还有个字符，本地化，简称。一般用语言_地区的形式表示一种语言，如_表示简体中文。 对和提供了非常好的支持。没有专门的来提供国际化，而是通过对不同的命名来达到国际化的目的，同时这种命名方法还可用于对硬件的区分，如不同的屏幕分辨率用不同的图片。我们引用这些时，在代码中是通过__的方式来使用，如，在中直接引用，如 引用了名字为的字符串。表示默认的资源文件夹，即当找不到匹配的资源时，会使用文件夹下的资源。文件夹的命名必须都是小写字符，否则在一些大小写敏感的文件系统中可能会出错。
本文主要介绍 国际化过程中遇到的问题和解决方案。
整理
国际化是要在保持原功能不变的情况下，主要对字符串进行替换。一般在涉及字符串的位置都要在里面设置对应的，方便后续的修改和复用，其他语言只需要新建_表示国家代号资源文件夹，系统会自动进行替换。但是经常一个项目由多位同事参与，每个人的编程习惯会有异同，在或者文件中会有遗漏的硬编码，因此第一步是整理项目中的硬编码，统一归并到中。
 是官方推荐的 ，拥有很多强大的功能。利用集成的工具，可以将项目中大部分的搜索出来。首先建立一份模板文件，进入  ，新建一份

然后自定义名称，主要用于检测，以后可以根据需要自由切换。

在下面的勾选框中选择        和  两项，颜色是黄色，表示在代码中会以黄色来提醒。

然后由进行代码分析，选择   ，选择自己的项目，选择之前保存的模板

检测之后， 可以扫描出中出现的代码

 可以扫描出的问题，而这种问题主要分两种
第一种是直接插入字符串，第二种是拼接字符串。

细心的同学会发现最上面的我的测试并没有被标记出来，这也是的一个问题所在。
这个情况可以通过正则表达式来搜索，搜索，需要注意对括号进行转义。

这下可以找到所有的。下面是几点注意事项

间接使用。我们有时候不会直接使用，而是在基类里对进行封装，比如显示页面的顶部名字方法，不会对这种间接使用的情况进行提示，可以借助来帮助排查问题。在方法参数中添加 来限制传入的参数必须是本地资源中的字符串的资源，同时需要将旧方法删除，不要让两者并存。其他类型的资源如图片、尺寸、颜色等，也分别可以添加  ，  ，  来限制。


        {
        
        _
        首页旧方法
        _新方法
        报错的方法
    }

       
    {
        
    }

        
    {
        
    }

占位符。有些业务需求是要将动态信息和静态信息拼接起来，开发的时候有时嫌麻烦，就直接通过号连接字符串了，这是不好的编程习惯，违反国际化规范。

  = 张三
  = 
名字是年龄是的用户不规范用法
名字是年龄是的用户规范用法
需要注意的是这个格式不能直接粘贴在中，需要修改格式将替换为，并添加上参数位置，如拼接的第一个参数是，表示第一个位置的变量， 表示为字符串类型。
   =名字是年龄是的用户

转义字符。字符串中有时候会出现特殊字符，这类特殊字符在中需要转义，下面是一些常用的特殊字符转义之后的样




符号

转义表示




“
 或 


‘
 或 



 或 



 或 



 或 


换行
\



  
现在已经整理好了文件，下一步就是让专业的翻译人员翻译对应的语言。其实直接提供文件就可以了，但是这样不容易进行去重、统计、整理，一般整理出文档比较合适。比较直接的方法可以直接将内容复制到文档中

然后利用替换功能，可以将 =、、这三段文字依次替换为空顺序不能变，得到如下状态

然后利用的分列功能，以为分隔符

可以将内容分为两列

对于重复项的问题，我们采取的方案是以待翻译的文字作为关键字，保持唯一性。先对字段进行排序

然后找出重复的字符串，还是利用的功能在处插入公式=重复

得到的界面如下

将标记重复的字段在或代码中找到引用的地方，替换成重复字段第一次出现的这也是刚才要排序的原因，可以在中直接找到第一次出现的，最后在中删除。
再利用的去重功能，选择 数据  删除重复项，以待翻译字段所在列为查重列，可以得到最终的结果

可以将得到文档提交给专业的翻译团队了。
  
得到翻译好的的文档之后

依旧可以借助的拼接功能，在输入拼接语句= =，可以生成符合中格式要求的内容

下拉统一格式，所有的都可以自动拼接

最后在项目中的目录下创建各自的资源文件夹，右击文件夹      

选择

例如选择的英语，会得到如下的文件夹

然后将前面整理好的各国语言的放到对应的目录下即可。
语言切换
国际化在应用内部需要设置语言切换的功能，修改语言的功能如图所示
  = 
  = 
  = 
 应用用户选择语言
 = 
 
但是修改之后应用并不会自动刷新界面。有如下几种方式解决问题
 重写方法，在里面设置=，发生变化时会调用该方法，和文字有关的控件需要在这里重新刷新。界面元素太多的情况下，这种方式会很繁琐。

     {
     需要刷新的控件
     
 }
采用方法，注册一个语言被修改的监听，回退到其他界面的时候需要刷新界面，方法可以刷新，比正常启动多调用了和，而且是以后的，界面也会有明显的闪屏现象。
一般修改语言界面都在比较深的操作中，上述两种方式是修改语言之后直接刷新当前界面，另一种方式是重新从主界面进入，对应的实现方式就是清空之前的堆栈信息，直接跳到主界面，微信中修改语言之后的界面效果也是如此。
  =   
___|___


为了保证用户设置成功后重新启动应用时，保存的语言依然生效，要对用户的选择语言进行持久化保存，一般是通过来保存，重新启动应用时在的方法中就要读取保存的语言信息，修改。
      {
  
       {
        
        
    }
 }
还有一种情况，应用在后台运行，用户切换了系统的语言，会影响。模拟一个场景，系统语言是中文，应用语言初始化是系统语言中文，修改应用语言为日文，发现主界面变成日文，回到桌面，再进入系统设置，修改系统语言为英文，这时再返回应用，应用显示英文，这个和应用功能违背，应该以应用语言为主。为了解决这种情况，一般在基类里面添加逻辑判断，目前应用语言是否和系统语言相同，如果不同就以应用语言为主，相同就跳过。
     {

       {
        
        
            
    }
}
界面适配
导入英文之后，界面肯定会有很多错乱的地方，原因各种各样。下面仅根据项目中出现的情况，总结出大部分都会出现的一些问题。
位置问题。最早的产品原型中可能不会考虑到国际化的需求，很多控件的布局写成固定值，英文不适用于之前的设计，所以出现错位、遮挡、显示不全等现象。在不影响视觉的情况下，可以对位置参数进行微调，如果区别十分明显，可以将固定值改为代码中动态获取，或者将固定值存在_的中。英文过长。中英文之间的翻译存在长度的不确定性，有时会出现换行的现象。从翻译的角度来看，可以让翻译团队根据所属界面的特殊性来重新翻译，尽量控制在一定字符以内。也可以尝试使用英文缩写这个适用性比较低，只适用于比较流行的词语，否则容易产生歧义，或者将高宽的固定值改成_，或者调整字体大小，同样需要在_的中记录。按钮文字全部变成大写。纯文本信息的按钮在中文情况下是正常显示，但是纯英文之后内容自动变成了大写。以主题为例。跟踪源码可发现，该主题中有：
 =
         =____
         =
         =

关键的原因在于：
 =
解决方法可以在项目的自定义主题中修改如下
 = =
             
         =
         =
         =

         =

或者为具体的控件设置如下属性

    =_
    _=_
    _=_
    =
    
国际化适配界面的工作“因而异”，更多的内容需要一个个界面进行调整，没有完整的通用方法。遇到特殊情况，需要和产品交流，可能需要修改普通版的原有功能，也有可能屏蔽国际版中的一些功能，要有所取舍。总之整个过程需要多方的参与和沟通，才能有效迅速的达到国际化效果。
总结
 国际化的工作并没有太多的技术难度，更多的是一些繁琐的文本处理。如何利用自动化的工具来解放人工操作，如何从看似杂乱无章的内容中寻找出规律，如何改善自己的编程规范，才是真正能从这个过程中学习到的东西。当然我只是列举了部分情况，不同的项目都会对应着不同的特例，很难面面俱到，仍然需要不断的摸索。直播嘉宾：黄希彤，腾讯首位前端专家工程师直播时间：月日晚直播形式：分享答疑报名链接：腾讯课堂、企鹅
本期腾讯云技术公开课邀请到了腾讯首位前端技术专家黄希彤，与大家分享自己的技术成长经历，回答网友在技术学习、发展时碰到的问题。黄希彤还是腾讯在  的代表，目前任腾讯云技术总监，擅长海量  系统的前端优化。

提问腾讯技术专家，还能领价值元的礼品
如今，技术革新的脚步越来越快。前端各种框架、库、自动化工具层出不穷，后端则开始服务化、云化，大量云计算知识亟待补充。
作为一个技术人，面对如此迅速的变化该如何应对？一个技术学了很久，不知道后面该怎么深入？怎样才能完成从小白到技术专家的蜕变？如果您对自身的技术成长有类似的疑问，请在本文下方评论区向嘉宾提问。
我们将选择网友最关注的如点赞最多的问题，在直播时优先进行解答。对于这些问题的提问者，我们还将送出价值元的礼品，包括移动电源和腾讯云产品代金券。提问时应围绕本次直播的主题进行。
礼品奖励规则：

提问点赞数前的用户可任选移动电源或元腾讯云产品代金券。
提问点赞数第的用户不含前三获赠元产品代金券。
重复提问不算，每人只能提问一次，一次可提多个问题。
点赞前需登录腾讯云账号。
截止日期：年月日。

加群咨询交流：
微信群：添加为微信好友，告知“希望加入公开课群交流，并注明姓名公司职业”，即可进入公开课专属微信群。
群：扫描下方二维码加入即可。

点击查看本期嘉宾技术文章。作者介绍：唐聪，后台开发，目前主要负责部门内公共组件建设、超级会员等产品基础系统开发等。

一、背景和概况
在年末，为了解决各类业务大量的排行榜的需求，我们基于实现了一个通用的排行榜服务，良好解决了各类业务的痛点但是随着业务发展到年中，其中一个业务就申请了数百万排行榜，并随着增长趋势，破千万指日可待，同时各业务也希望能直接使用丰富数据结构来解决更多问题如存储关关系链、地理位置等。
当时面临的问题与挑战如下

排行榜服务无法支撑千万级排行榜数排行榜到实例映射关系存储在容量瓶颈

单机容量无法满足关系链等业务需求

排行榜和关系链大部分大于，同时存在超大需支持超大迁移

的存储组件，支持协议，但又存在单 大小的限制

高可用，需要支持主备自动切换

数据运维组未提供集群版接入服务在零运维的支持下如何高效治理众多业务集群？


面对以上挑战，经过多维度的方案选型对比，最终选择了基于版本结合内部需求和运营环境进行了定制化改造，截止到目前，初步实现了一个支持单机分布式存储、平滑扩缩容、超大迁移、高可用、业务自动化接入调度部署、多维度监控、配置管理、容量管理、运营统计的服务平台，在、不能满足业务需求的场景下，接入了增值产品部等五大部门近业务集群图一，实例 容量。
下文将从方案选型、整体架构、自动化接入、数据迁移、高可用、运营实践等方面详细介绍我们在生产环境中的实践情况。

图一 部分接入业务列表
二、方案选型
因其丰富的数据结构、易用性越来越受到广大开发者欢迎，根据的最新统计，已经是稳居数据库产品的见图一。云计算服务产商、、阿里云、腾讯云都提供了产品，各云计算产商主流方案都是基于开源内核做定制化优化，解决不足之处，在提升稳定性、性能的同时最大程度兼容开源。单机主备版各厂商差异不大，都是基于原生内核但是集群版，使用的原生的自带的 模式加强版，阿里云基于、原生内核实现，路由等元存储数据保存在架构类似 腾讯云集群版是基于内部。了解完云计算产商解决方案，再看业界开源、公司内部，上文提到我们面临问题之一就是单机容量瓶颈，因此需要一款集群版产品，目前业界开源的主流的集群解决方案有 公司内部的有 、的从以下几个维度进行对比，详细结果如表一所示年月时数据

图二 数据库流行度排名





 

 





存储引擎
基于原生扩展增加迁移相关指令
原生
原生
多阶哈希



数据分布算法
哈希槽  
哈希槽  

一致性
哈希槽


平滑扩缩容
支持
支持
不支持
支持
支持


大小限制
无
无
无

无


实现
  
  
  
  
内存磁盘


开发语言

采用无中心节点设计无


基于


单线程多线程多进程
多线程
无
单线程
多进程
单线程多线程


超大迁移
不支持
不支持
不支持




机型
内存型
内存型
内存型
内存型或 型
 型



任意
需要支持语义
任意
提供
任意



支持
不支持
支持
支持
支持


运维成本
低
高
高
无
无


定制开发成本
低
高
高
无
无



表一 集群产品对比
云计算产商和业界开源、公司内部的解决方案从整体架构分类，分别是基于中心节点和无中心节点，在这点上我们更偏爱基于中心节点架构设计，运维成本更低、更加可控，从存储引擎分类，分别是基于原生内核和第三方存储引擎如的多阶、的在这点上我们更偏爱基于原生内核，因为我们要解决业务场景就是和无法满足的地方，我们业务大部分使用的数据结构是且一般超过，几十万级元素的 是常态，的 大小限制无法满足我们的需求，同时我们需要的的时间复杂度是基于的存储引擎时间复杂度是因此这也是无法接受的。随着业务发展，容量势必会发生变化，因此扩缩容是常态，而并不支持平滑扩缩容，因此也无法满足要求。最后，我们需要结合内部运营环境和需求做定制化改造，在零运维的支持下，通过技术手段，最大程度自动化治理、运营众多多业务集群，而代码结构清晰，开发语言又是现在比较流行的无论是运行性能、还是开发效率都较高效，因此我们最终选择了
三、整体架构
基于定制开发而成的服务平台整体架构如图二所示，其包含以下组件

实现了协议，除少数命令不支持外，对外表现和原生一样。解析请求时，计算对应的哈希槽，将请求分发到对应的，业务通过进行寻址。

 在内存中实现了等数据结构，对外提供数据读写服务、持久化等，默认一主一备部署。

提供管理集群的和访问元数据存储的通用操作，屏蔽后端元数据存储差异。

第三方元数据存储，保存集群的、、各哈希槽对应的 地址等信息。

：基于 实现主备高可用，部署在多个，采用机制、状态机进行主备自动切换。

调度服务，负责对业务接入申请单进行自动调度部署、集群自动化扩容、各集群运营数据统计等。

运维管理系统 可视化管理集群，提供业务接入、集群管理、容量管理、配置管理等功能。

：存储业务申请单、各节点容量等信息。

负责定时监控和采集、、运行统计信息，上报到米格监控系统和。

：冷备集群，冷备文件每天会定时上传到，提供给业务下载和在主备皆故障的情况下做数据恢复使用。



图三  整体架构
四、自动化接入
当面对成百上千乃至上万个实例时，人工根据业务申请单去过滤无效节点、筛选符合业务要求的节点、再从候选节点中找出最优节点等执行一些列繁琐枯燥流程，这不仅会导致工作乏味、效率低，而且更会大大提升系统的不稳定性，引发运营事故。当繁琐、复杂的流程变成自动化后，工作就会变得充满乐趣，图三是业务接入调度流程，用户在运维管理系统提单接入后，调度器会定时从中读取待调度的业务申请单，首先是筛选过滤流程，此流程包含一系列模块，在设计上是可以动态扩展，目前实现的筛选模块如下：
 健康探测模块，过滤宕机、裁测下线的节点
标签模块，根据业务申请单匹配部署环境测试、现网、部署城市、业务模块、存储类型单机版、分布式存储版
 检查当前节点上是否有空余的实例筛选实例时
 检查当前节点、是否超过安全阀值
检查当前节点角色是否满足要求如实例所属节点机器必须是 角色分为三类   
以上筛选模块，适用、、节点的筛选，在完成以上筛选模块后，返回的是符合要求的候选节点，对候选节点我们又需要对其评分，从中评出最优节点，目前实现的评分模块有最小内存调度、最大内存调度、最小调度、随机调度等。

图四  业务接入调度流程
通过运行以上一系列筛选和评分模块后，就可以准确、快速的获取到新集群的、、的部署节点地址，但是离自动化交付给业务使用还差一个重要环节部署。目前主要是通过以下三个方面来解决自动化部署，其一，本身是基于配置文件部署的，每新增一个业务集群必须在配置文件指定集群名字，新建一个包，维护成本非常高，我们通过监听指定网卡核心配置项迁移到，实现配置管理化，同时部署包标准统一化。其二，在各节点上都会部署会定时采集上报各节点信息入库到容量表，无需人工干预，容量管理自动化，未使用的实例形成一个小型资源池。其三，部署是个多阶段的流程，需要分解成各状态，并保证每个状态都是可重入、幂等性的，当所有状态完成后，则调度结束，某状态失败时，下次调度检查到申请单非完成状态，会自动重试失败的流程，直至完成，拆分后的部署状态流程图如图四所示。
通过以上两个核心流程，自动化调度分配实例自动化部署，我们可以将部署时间从最开始的优化到秒级，在大大提升工作效率的同时，提升了系统稳定性、避免了人为操作错误引起的运营事故。

图五  自动化部署流程
五、数据迁移
扩缩容是存储系统的常归化操作，理想中的数据迁移应该是尽量不影响线上业务正常读写访问、支持任意大小的、优异的迁移性能、保证迁移前后的数据一致性，但是在年末的时候数据迁移功能差强人意。首先是迁移速度慢，其次是只支持同步迁移，较大的迁移会阻塞主线程，影响线上业务正常读写，最后是不支持超大迁移。虽然各种最佳实践不断强调需要避免大的确大可能会是系统潜在的一个风险点如大删除、迁移、热点访问等，但是在不少业务场景下，业务层是无法高效、简单的完成分的，本身也在不断的优化，降低大风险，比如版本提供了异步删除功能倘若存储层能快速完成大迁移，这不仅会大大简化业务端的复杂度，更会提升稳定性、可用性，但是内存型存储系统在大迁移的上复杂度比非内存型存储系统多一个数量级，这也是为什么到现在还未实现大迁移和异步迁移的功能。
大若能拆分成小分批次异步迁移、并在迁移过程中该可读、不可写，只要迁移速度够快，这对业务而言是可以接受的，在年末的时候我跟核心作者交流了大迁移的想法，令人惊喜膜拜的是，他在农历春节期间就快马加鞭实现了异步迁移原型，在这过程中我们协助其测试、反馈和瓶颈、不断改进、优化迁移性能，最终异步迁移不仅支持任意大小迁移，而且迁移性能相比同步迁移要快倍，我们也是第一个在线上大规模应用实践异步迁移的，更令人可喜的是此异步迁移方案击败了作者之前计划的多线程方案，将正式合入 版本。
在介绍异步迁移方案实现前，先介绍下是如何保证过程中数据一致性和为什么同步迁移慢。如何保证迁移过程中各读取到的数据一致性？主要迁移流程如图五所示其采用了多阶段状态机实现，类似分布式事务中的多阶段提交协议，其核心流程如下。

在运维管理系统上，提交迁移指令，更新上哈希槽状态为待迁移，即返回时序图步骤。

异步定时检查上是否有待迁移状态的哈希槽，若有则首先进入准备中状态，将此状态同时分发到所有，若有异常应答失败，则无法进入迁移，状态回退时序图步骤。

若所有应答成功，则进入准备就绪状态，将此状态同时分发到所有收到此状态后访问此哈希槽中的的业务请求将被阻塞等待，若有应答失败，则会立刻回退到上个状态时序图步骤。

若所有应答成功，则进入迁移状态，将此状态同时分发到所有收到此状态后不再阻塞对迁移哈希槽中的访问，若业务请求属于待迁移哈希，首先会从迁移源中读取数据，写到目的端中去，然后再获取修改数据返回，这是其中一种迁移方式，被动迁移，也会发起主动迁移，直至数据迁移结束时序图步骤。


通过多阶段的状态提交和细粒度、级别的锁，优雅的解决了迁移过程中的数据一致性。

图六  迁移状态流程图

图七  同步迁移流程
再看为什么同步迁移慢图七是迁移一个万元素的耗时分析，当发起迁移指令后，源端将整个序列化成花费了通过网络传输给目的端花费目的端收到数据后，将其反序列化成内存中的数据结构，花费了最后源端删除迁移完成的又花费了而整个迁移过程中，源端是完全阻塞的，不能提供任何读写访问。因此，异步迁移方案若要提升迁移性能，必须在以上四个流程上面做优化。
异步迁移的流程如图八所示，面对同步迁移的四个核心点，异步迁移的解决方案如下：

拆分过程，解决同步序列化开销。对于大不再使用对数据进行而是通过指令拆解，  中的数据结构都可以等价的拆分成若干个添加指令，比如含有万元素的可以拆分成万个指令，每个指令添加个数据

拆分过程解决同步开销。异步实现，发送数据不再阻塞。

拆分过程，解决反序列号开销。因源端发送过来的数据不再是二进制数据，目的端无需再使用，只需将收到的添加指令数据直接更新到对应的内存数据结构即可，同时使用了一些比如内存预分配，避免频繁申请内存，转换成 提高迁移性能等。

异步删除，解决同步删除耗时问题。通过额外的工作线程异步删除不再阻塞主线程。



图八  异步迁移流程
万的同步迁移需要而异步迁移只需要在不阻塞在线业务的前提下，性能提升倍多，以我们生产环境某全球排行榜为例，之前单机主备版加载到内存都需要分钟，而用异步跨机器迁移只需要左右 更详细的迁移介绍可参看附录的新版本特性介绍。
六、高可用
各组件中跟用户请求相关性很强的组件分别是、、元数据存储相关性较弱的是。
多机多部署，调度服务会根据 ，自动打散相同尽量保证同一集群部署在不同，通过和进行容灾。
基于 进行主备自动化切换。
高可用分布式协调服务，一半以上节点存活即可提供服务，同时只有在启动时和运行过程中发生数据迁移才会依赖绝大部分正常请求不受 集群状态影响。
 负责协调集群状态变更及一致性，目前在设计上是个单点，但是只有在就集群运行过程中发生数据迁移才会依赖它，因此是弱相关性 后续还可以优化成多节点部署，通过的分布式锁来保证只有一个节点能提供服务，当提供服务的节点故障时，通过一系列流程如需通知，变更等实现自动化故障切换。
重点介绍的主备自动切换流程，常见的存储系统自动切换方案一般有如下三种

基于来做主备自动切换如公司内部的在主备节点上部署在集群上注册临时节点，当主机宕机时，在检测到临时节点消失超过阀值后发起容灾流程。

基于相互独立的探测实现如的的。 将主备自动切换流程拆分成故障决策模块探测存活、故障同步模块、故障监控模块 、故障切换表同步模块将待切换的实例放入队列、故障核心模块 切换路由。

基于的分布式探测如的在新浪微博等公司已经进行了较大规模应用，也是基于此实现主备自动切换，我们在此基础上增加了告警和当网络出现分区时，增加了一个降级操作，避免脑裂，其详细流程图八所示。



图九  主备自动切换流程
图九流程简要分析如下：

图中三个部署在不同的可用区，实际现网我们是部署了五个，覆盖各大运营商等，各会定时向发送等请求探测存活并通过协议相互交流信息，同时各实时监听的状态消息。图八流程

当出现异常，在一定时间可配置如，避免网络抖动，误切内都持续无法访问时，就会认为此节点为主观故障_，会彼此通过协议相互交换信息，当一半以上可配置的认为此都故障后，此节点会被判断为客观故障_各会选举出一个来执行主备切换，首先从各备机中选择一个最佳节点，算法是首选过滤掉与断线时间超过阀值的其次优先选择_较小的，若一样，则选择 最大的，若也一致，则按字典顺序排序选择最小的选择出最佳候选后，会将其提升为同时向订阅者发出 事件通过发出告警通知开发运维，然后更改其他备机主从关系，从新主机同步数据图八流程。

各个收到的 后，会遍历所有查询故障组最新当一半以上的返回了故障组新的，则会切换路由，路由到组的请求，将发到新的主备自动切换完成。图八流程

但是在极端情况下若网络出现分区，业务服务、个别跟 在同一个可用区，则会出现脑裂，为了避免此种情况，部署在机器上的会定时持续检测与连接是否通畅，若连接不上则会向发送降级指令，不可读写图八流程。


七、运营实践

多维度监控
机器上的定时采集、的、、_等几个指标，上报到米格监控系统，针对核心监控指标配置阀值和波动告警。监控系统在线上数次捕捉到集群异常如连接数超过阀值、某实例无备机等，及时发出有效告警，提前发现问题、解决问题。同时，也不连的情况下也可以便捷地通过手机快速查看监控曲线、定位问题等，大大提高工作效率。



图十  曲线

图十一  差异曲线
  低负载优化

集群缩容和相同业务复用同集群

存储机多实例部署，现在默认个实例

通过顺序触发个实例 和 避免多个实例同时从而提高存储机内存使用率至最高

机器多实例部署进行中


 多租户

小业务通过在前缀增加业务标识，复用相同集群

大业务使用独立集群，独立机器


数据安全及备份

访问所有实例都需要鉴权

层可统计汇总所有写请求指令

默认开启日志

定时上报 、文件到集群


八、总结
基于为核心的服务平台高效解决了大量业务的痛点不限制大小，原生的内核，高性能，提高了开发效率，助力产品更快发展，但是因人力有限半个开发投入，在业务项目人力紧张的时候，零投入还有若干待完善的地方，如不支持冷热分离等。 在千呼万唤中，目前公司内的存储组自研的基于共享内存实现各类数据结构的单机主从版也终于上线，集群版也在紧锣密鼓的开发中，较好的解决了内存使用率、跨部署、数据备份及同步机制的一些不足之处，后续业务也将有更多的选择！最后感谢的无私贡献
九、参考资料

 

 

 

新版本特性介绍



文章来源于小时光茶社微信公众号基础：
在企点项目中，用的框架有和。通过分析两种框架发现其实不论哪种框架其核心的思想都是模式。这里不展开。
基于框架的特点，我们可以知道与代码的映射关系。
比如：公海客户筛选请求
： 
 代码文件：…
 函数：

测试需求：
在客户库公海已归属客户删除中增加性别年龄地区学历筛选项

代码分析：

公海、已归属、客户删除筛选函数的实现是一致的，且调用相同基础的方法。接下来看代码后续的调用关系链来了解代码是如何实现页面类型区分
  à   __  à  __

  __ {

  = 

   {

  = 

 }

…

}
到这里就比较明确了，是通过请求参数中的来区分页面类型。表示公海，表示已归属，标识客户删除。
结论：
通过以上分析可以发现，只需要覆盖其中一个页面筛选的全部用例，和其他两个页面的基础用例就可以达到完全测试的效果。这样用例大约可以缩减，大大提升测试效率。
思考：
通过以上也可以发现其实分析代码并不困难，主要是要培养分析代码的意识，不仅能提升自己对设计的理解，还能帮助测试事半功倍哦。九宫格
数独源于世纪的瑞士，又称九宫格，有九行、久列和九宫。玩家需要在九宫格中，根据已知的数字，利用逻辑和推理能力，填出所有的空格中应有的数字。填的时候要求每行、每列和每宫都要不重复地包含数字。每行、每列和每宫中都必须出现且只能出现一次，故称之为数独。
数独游戏考察的是解题者的观察能力和逻辑推理能力，虽然规则很简单，但是数字的排列方式却是包含千变万化，是一种锻炼思维的绝佳方式。有时候数独不光有数字的变化，还有颜色的变化，更难但趣味也更多。

在刚刚接触机器视觉的时候，我就想着用机器视觉来解数独。当时也做了一些尝试。但是当时只是做到了提取每一个九宫格和数字，由于当时初学能力有限，就搁置了。最近重新拾起，不是用，而是用，终于完整地把可以完整地用九宫格了。
今天这篇文章只能说是预告，因为最近空闲时间有限，而这个项目又不是简简单单就能说完的，所以我且利用空闲时间慢慢写，君且慢慢看。
流程
大致的流程是这样的

九宫格数字提取

数字识别

数据收集和处理

数字识别

数独生成和求解


效果预览
数字提取
数字提取，就是在一张数独图片中提取出已知的数字

数字识别
数字识别需要训练数字识别模型，就需要收集数据，进行数据处理之后训练模型。最终可以正确地识别九宫格中的数字。由于训练样本有限，所以现有模型也许只能完美的识别上图所示的九宫格。

求解数独并展示结果


相关推荐
我们教电脑识别视频字幕用进行手写数字识别作者介绍：，腾讯服务器性能测试团队产品经理。

直播的火爆带来了海量的用户，也带来了海量的服务器并发。本文分析了目前直播行业存在的难点，从腾讯目前的新直播产品——直播出发， 了解直播应用背后的那些事。
直播，突然成为了中国互联网的一个最流行的词汇。在《年中国网络直播行业深度调研及投资前景预测报告》中的数据表示，年，全国在线直播平台数量接近家，其中网络直播的市场规模约为亿，网络直播平台用户数量已经达到亿，大型直播平台每日高峰时段同时在线人数接近万，同时直播的房间数量超过个，更可怕的是，这一数据还在以极快的速度向上攀升。
直播平台用户数量亿是什么概念？版的《微信数据化报告》中提到，目前微信用户达到了亿人，也就是说，在你身边同龄的个朋友之中，很有可能有一个人是网络直播的用户。
直播火没火，看用户就知道，但是直播有没有前景，就要看科技巨头们对它的态度了。
国外的推出的 给其用户带来的全新的体验，不仅增加了用户粘性，还给带来了新的收入来源。而 与电视点播相结合的经营模式也给用户带来了新的视频体验。
国内方面，斗鱼、虎牙、熊猫、龙珠、奇秀、花椒等专业的直播平台如雨后春笋般出现。阿里、百度、腾讯等巨头也不甘人后，纷纷推出了自己的直播平台。而直播所涉及的行业领域也从电竞、社交、电商等各个行业间开始广泛出现。
直播下的服务器压力
如此大的用户体量下，直播类的应用对于服务器的要求要高过一般的应用，我们来看看直播类的应用对服务器有哪些更多的挑战？
更大的数据量
视频数据和文本数据完全是两个量级的概念，假设一个直播房间有人，视频的数据，那么就需要==，基本已经达到了三个手游的大小了，而这只是一个房间产生的流量。今年月刘涛入驻直播领域，创造了同时在线人数万，总收看人数万的数据，如果按照这个数量，服务器就会产生的带宽，而当前某著名网络直播日活跃用户超过了，服务器将承受的带宽压力。

更高的并发量
不同于普通应用和游戏，直播类应用的使用时间段非常的集中，一般来说，社交类的直播时间集中在晚饭后时间至睡前点点，游戏类活跃时间集中在下班后点间，秀场类集中在点和午休及下班时间，因此在这短短几小时之间，会涌入大量的用户，一次大的直播通常就会造成百万级的用户登录，需要有详尽的限流、分流和负载均衡策略，保证服务器不会被冲垮。数据来源：大数据解析网络直播市场到底有多火
更真实的用户登录场景
直播应用与普通应用相比，交互的功能异常多，除了直播视频流的服务器压力之外，还要包括用户消息推送、聊天、礼物、支付以及统计系统带来的数据交互压力，服务器进行需要识别不同的业务字段，才能精确判定用户的行为是否成功完成，从交互频率的角度上来说，直播类的应用，与其说更像应用，不如说更像游戏。
更低的延迟
直播需要一个很强的即时性，如果主播的行为和用户的评论无法同步的时候，会给用户非常不好的体验，如果一个用户发现其他用户在欢呼鼓掌，但是屏幕中的主播什么动静都没有的时候，这个直播应用基本可以不要再用了，因此直播类应用不仅需要面对更大的数据量和更高的并发，还要保证更低的延迟。通常可以要保证服务器的处理数据速度要快，要有足够强大的带宽；另外则是通过算法保证数据分享的合理性，保证服务器的数据和的数据可以达到平衡。
直播前的服务器准备
直播应用下的服务器成本，与将要承受的流量情况息息相关，不同的直播应用，交互的频度、深度不同，就会产生不同的带宽压力。我们一起来算一笔帐，为直播应用准备服务器，大概需要多少钱？
首先，我们要买一个服务器。买多大的服务器呢？服务器的带宽要满足直播应用的带宽需求，在这里，科普一下带宽是怎么看的：带宽通常使用的单位是  ， 通常等于，在换算成我们熟悉的文件大小的时候，要除以，也就是在的带宽下，每秒钟可以下载的文件，那么一般来说，直播应用需要多少带宽呢？见下图：直播应用一般使用的分辨率是，以及三种，为了看得清晰一些，一般人们都会选择，那么在的清晰度下，直播应用需要的带宽，也就是每秒传递的数据大小为=。简单来说，如果在中打开直播，使用了的分辨率，一个用户每秒钟需要传输的数据当然实际情况中直播应用还有消息推送，送礼，支付等行为，直播画面分辨率、压缩比等区别，实际会消耗更多的数据。
那么，直播类应用现在需要承载多少用户呢？以目前最红火的几大直播平台为例，斗鱼  的在线人数可以超过 万，战旗  在在线人数约 万左右，龙珠在线人数约  万左右，虎牙在线人数约万，直播平台的带宽成本通常是带宽峰值月结的形式，如果当月最高同时在线人数是，也就是每秒要传输的数据量高达，那么理论上消耗的带宽就是左右，一个月的开销就在人民币左右。
对于直播应用来说，服务器最难处理的环节就是视频流量和用户交互等高频率高带宽的场景，用户的行为是难以预测的，经常会出现突发性的暴涨，一般在进行活动的时候，流量可能是平时的几十倍。年月日，酱的一次直播带来了超过用户的访问，这对于大多数的直播应用来说，服务器的成本都是难以承担的。这也是为什么越来越多的直播应用开始寻求云服务器的支持，目前的云服务商有腾讯云，阿里云，百度云，金山云等，彼此之间在硬件上的类型差别越来越小。
因此直播应用在上线前需要对多样化的用户操作进行针对性的测试，注册，聊天，礼物，支付等行为都需要进行不同接口的测试，直播就是其中之一。
直播服务器的测试
测试需求的产生
腾讯直播是腾讯目前发展非常迅速的直播应用，获得了通过直接登录直播界面的入口，可见其受重视程度，而直播在一场线上活动中，需要对活动的所有接口进行压力测试，提前暴露问题并解决，确保活动的顺利实施。为此，直播与腾讯服务器性能测试进行了合作，对应用的业务后台进行了系统性的测试，对活动进行了一整套场景测试。对于视频流量、用户交互等高频率高带宽的场景，也同样可以使用服务器性能测试的的高级模式进行，本文不做展开，尽请期待后续干货。
测试前的思路梳理
一般来说，对于活动中的功能节点，测试过程中通常关注两点：

单接口压测，提前暴露核心模块的问题
多接口架构问题，场景压测尽量模拟真实用户行为，使得压测结果更有说服力对于这次活动，直播的思路也同样是通过简单的单接口和复杂的多接口场景压测，通过压测工具给后台和客户端增加压力源，帮助发现问题。

测试的执行

单接口压测——步步为营，逐渐迭代
单接口压测的原理很简单，就是不断的对某个功能接口不断加压，直到发现出现问题的那个极限就可以，在腾讯服务器性能测试上，操作如下：
点击压测产品首页中的快捷入口：直压。模式选择简单模式，名称和描述可以自己填写。图中示例起始人数人，每隔秒增加人，加到人为上限
新建一个客户端请求，接口压测包括读写接口，读接口基本是请求，写接口基本是请求。请求使用请求参数，请求使用方式传递参数，在这里直播方法选择，填写想要测试的。
编辑一下测试模型，增加一个场景名，单接口测试只测试一个功能接口，因此模式选择“单场景”，压力百分比设置为。通过这样的压测方式，不断增加服务器压力，直到找到瓶颈位置，腾讯为直播实现了的并发量，满足了直播的并发需求。

多接口压测——真实模拟，定位问题
多接口压测的主要逻辑，就是通过构建不同的功能接口，模拟用户的真实行为，从而帮助开发者定位接口问题。
直播的测试方式是通过请求调用一个功能接口，通过这个功能接口随机产生不同行为逻辑的机器人，模拟真实的用户，然后通过请求执行具体的业务行为，从而发现功能之间会产生的逻辑问题。
直播测试团队读接口基本是请求，写接口基本是请求。请求使用请求参数，请求使用方式传递参数。
在腾讯 服务器性能测试上，我们可以进行如下操作：
首先，通过请求，读取一个用户的“登陆态”，通过这个功能接口随机产生不同行为逻辑的机器人，模拟真实的用户；然后通过请求依次执行具体的业务行为，从而发现功能之间产生的逻辑问题。在测试场景中输入场景名，直播测试的是“登录进入房间点赞”这样三个操作，然后“模式”选择“上下文”，点击“压测场景”，选择调用不同的功能接口。目前腾讯服务器性能测试支持同时接入个场景，更多的场景可以更真实的模拟用户的行为。


总结
通过直播与腾讯在服务器性能测试方面的合作可以看出，目前的直播应用非常注重两块的内容：一个是单接口的承载能力，一个是多接口的架构情况，对于开发人员来说，前者的问题是好解决的，通过平行扩容的方式就可以做到优化，但是后者的问题则需要在多个功能接口之间不断定位问题，不断尝试新的压力测试，才能找到那个存在的隐患。基于直播的需求，腾讯也提升了可同时调用的场景接口，从原来的个增加到了个，之后也会不断的增加；并且也不断的增加可以实现的并发数，为用户提供更大的并发压力和更真实的行为场景，节省了更多的测试成本。做好这些，才能做出更好的直播应用。
腾讯运用了沉淀十多年的内部实践经验总结，通过基于真实业务场景和用户行为进行压力测试，帮助游戏开发者发现服务器端的性能瓶颈，进行针对性的性能调优，降低服务器采购和维护成本，提高用户留存和转化率。
目前腾讯服务器性能测试已经正式对外开放：
体验地址：如何使用简单模式：如何分析报告：常用测试指标：
商业转载请联系腾讯获得授权，非商业转载请注明出处。作者：


 用于网络流量的统计监控、修改请求和响应
  用于代理的管理

抓包的时候偶尔会遇到返回的串在窗口不能显示成对象的形式，如下：

理想的：

这种情况是响应头不正确造成的，可以使 修改响应头。
相应的可以用修改请求头两个接口可以修改几乎所有的头，包括相关的，因此可以实现一个的管理。
自定义请求响应头的插件：
_
某个 独立的插件可以让浏览器登录多个账号：
_
可以实现  的功能
 不能做到修改响应数据、映射等。虽然从安全的角度思考这是异想天开，但有自由访问文件系统的接口需要用户次确认这种权限，如果能做到真想把的功能集成到里去。

原文链接：


相关推荐【腾讯】是如何做浏览器的性能测试的？开发性能优化核心定义介绍篇利用  进行  语言扩展。包括两个基本的步骤：

编写  代码；

 调用  代码，实现相应的  或 。


在之前的文章中，我们已经了解了如何自定义 。至于  的  代码库的结构，我们留待之后讨论； 这里，重点关注，如何在   代码库高层接口的基础上，编写  代码，以及如何调用自己编写的  代码。
官方示例了如何定义一个加法运算见 。这里我们定义函数见 。
  代码
  的基本数据结构是 、等。我们以简单的  函数为例，示例编写  。
==
 需要定义前向和后向两个方向的操作，因此， 代码要实现相应的功能。
 头文件声明
 _ 
 _   
 _ _    _
 函数实现
 包括了   代码数据结构和函数的声明，这是唯一需要添加的  依赖。
 _ 

 

 _   
{
  _ 
  _   
   
}

 _ _    _
{
  __ _
  __

    = __
    = __
    = _ 

  _  
  __  _
   
}
 编译代码
 依赖
由于  的代码是纯  的，因此没有过多的依赖，只需要安装：

  安装方法见官网

    


编译文件非常简单，主要是添加头文件和实现文件，以及相关的宏定义 同时文件还指定了编译后的调用位置此外为__：
 
 
 
   _


 = _
 = _
 = 
_ = 

 _
      
     = __
     = __
     = _ 
    _ = 

 = _
    __
    =
    =
    _=
    _=____
    _=_


 ____ == ____
    
 
  调用
 编写配置文件
 的调用非常简单—— 的  对象，对应  代码的  对象，以此作参数进行调用即可。配置文件如下：
 
   
 _  _

 
      
        __

         = 
          _
            __ 
        
                
         

      _
         = _

        _ = _
          __
            ___  _
        
                
         _
 测试
此处省略  的定义。下面测试下新定义的基于  的  函数。
 
   
   

   

_

 
     ____
         ____
         = 

      
         

 = 
 =   
 =  _=
 = 

=



输出结果如下：
 
         
         
         
         
         
   

 
         
         
         
         
         
   


         
         
         
         
         云计算当前给我们的业务运营提供了极大方便，越来越多的机构或公司利用公有云部署自己的业务应用，国内的阿里云、腾迅云、青云和  等厂商也取得了很大的发展。
随着业务的发展，我们购买的云端服务器不断增加也是水到渠成的事情，比如集群、同城双活、异地多活等等高可用的应用，在这些应用中，我们运维人员将会逐渐面对下面的一些场景：

单台云主机需要多个  地址供不同的场景使用，例如一个主  用于公有云平台管理使用，两个辅助  用于我们业务应用与运维管理。
同城双活和异地多活互联时的多路由。单数据中心的时候，我们的  内云主机的绑定的路由表可能只需两条路由即可，一条是本地  内网通信，一条是出公网的  网关或者公网网关之类的。而当我们有同城双活或者异地多活时，云主机的路由表就要开始逐渐增加到其他数据中心的路由了，通常是对等连接各个公有云厂商的叫法可能会不太一样。
流量隔离，业务流量上来了，单网卡上同时还跑着的运维监控数据流量、双活甚至多活的数据同步流量，可能会对业务流量造成影响，此时我们就会需要进行隔离，以保证业务流量的稳定供给。
容灾迁移，集群环境里不可避免出现某台云主机有问题，需要将其上面的流量转到其他机器上，这时我们通常需要增加后端机器，然后加到负载均衡器，然后再将有问题的云主机从负载均衡中摘掉。

我们在公有云服务商那边的云服务器通常给我们配置的是一块网卡，自动分配的内网  地址也是随机的，面对上面这些使用场景，是不是有一些不好操作呢？
我们假定一个金融项目中对云端服务器环境有这样的需求：

所有应用需要在两个数据中心同时部署，当一个数据中心遇到问题时能快速将业务访问切换到另外一个，在两个数据中心建立了对等连接进行互联互通。
为满足金融行业的安全规定，所有内部研发与运维人员访问服务器经由  连接后才能访问到，希望内部访问与最终客户的业务访问安全隔离，设置不同的安全策略。
希望与合作伙伴的一些对接连接，与最终客户的业务访问进行隔离，因为两者在安全策略上也有区别。

根据这些需求，我们通常会结合云服务器的安全组和  等防火墙来设置安全策略，根据来源地址配置不同的规则，实现需求里的安全隔离。
最近腾迅云平台又新增了一个大功能：弹性网卡，据说是国内公有云首创。向来对新功能抱有好奇心的我，就抽空进行了一番测试，发现它给我们的云服务器在网络通信方面打开了一个扩展的入口，通过灵活结合安全组、子网路由、 和云主机内部静态路由等功能，可以很方便就实现了诸如内外网隔离、内网  动态迁移、细化安全策略控制等各种应用场景，真是一个贴心的功能，相信不久其他公有云服务商就会跟进，给我们运维圈的朋友们带来福利！
什么是弹性网卡？
弹性网卡是云服务器网络接口的一种创新扩展，它即插即用，支持在多个云服务器间迁移，支持单机多网卡，支持单网卡多 ，还支持给每个内网  绑定公网弹性 。
一句话总结：弹性、好用、易扩展！
这么神乎？那与普通的网卡有哪些区别呢？简单说有以下几点区别：

与主网卡独立，它看起来完全是一块新网卡，不像  文档里配置内网地址时使用  这样的虚拟网卡。
无需重启机器，绑定后立即生效。虽然使用感觉是一个新硬件配置，但你无需重启机器即可立即配置  和路由，然后投产使用。
支持单独关联安全组，实现比云服务器安全组颗粒度更细的安全控制。
支持在私有网络内任意迁移至其他云服务器，轻松实现容灾的迁移。

下图更为形像地展示了弹性网卡的功能：

现在腾迅云私有网络云主机上的网卡已经全部支持弹性网卡，所以现在登录控制台打开每台  的详细信息，就能看到弹性网卡的界面了。

弹性网卡的基本操作
可能因为弹性网卡目前仅用于私有网络，所以腾迅云将它的操作入口放在”私有网络“控制台界面区域，如下图所示：

新建弹性网卡
创建一块新的弹性网卡，有两个入口：

在上面截图所示的【弹性网卡】列表界面，点击【新建】按钮，然后在弹窗中选择弹性网卡的所在私有网络、子网、内网数支持指定内网，点击【确认】即可。
进入  云主机的详细信息界面，并点击【弹性网卡】，在已有弹性网卡列表界面点击【绑定网卡】，然后使用【新建弹性网卡并绑定】选项来创建。

两个入口创建新弹性网卡的界面是一样的，如下图所示：

绑定新弹性网卡
绑定新弹性网卡操作只需简单的  步：
第一步：登录控制台后进入云主机列表界面，打开想要绑定新弹性网卡的云主机详细信息界面。
第二步：在“弹性网卡”选项卡，点击“绑定网卡”链接，弹出下图所示界面：

第三步：在上图界面中，你可以绑定已有弹性网卡，也可以新建一块弹性网卡并绑定到这台云主机上。
绑定完成后，云平台会立即给云主机添加一块新的网卡，会使用    这样的规则进行命名如下图所示。
但此时，云主机只是新增了网卡，分配的  地址并未实际绑定到云主机，还需要我们手动或调用  去完成绑定。

绑定新  地址到云主机
下面以   为例进行说明，使用  等发行版的童鞋可根据步骤说明使用对应的命令进行操作。
我们操作的云主机，经过前面的步骤绑定了一块新网卡，它的内网  地址自动分配的是 。

、启动新绑定的弹性网卡
    
、绑定新弹性网卡的内网  地址
     
 

从   显示的结果来看，新的  地址已配置到这台云主机了。
、启用  转发功能
 _ =   
 
、添加转发路由
     
上面的操作是临时使用命令行将  配置到新绑定的弹性网卡，它是即时生效的，当然重启后它也会失效的。如需长久使用，建议通过创建网卡配置文件，这个操作在此略过。
给弹性网卡关联安全组
弹性网卡支持分别绑定不同的安全组，以实现灵活的网络连接权限控制。缺省新创建的弹性网卡是没有关联安全组，此时它是无法进行网络通信的，默认是禁止了所有入站和出站通信请求。

进入云主机的弹性网卡列表界面。
点击需要操作的弹性网卡实例 ，此时界面会切到“私有网络”  “弹性网卡” 那里。
点击“关联安全组”。



点击“配置安全组”。
在弹出的“配置安全组”界面，选择你需要关联进来的某个已有安全组，点击“确定”按钮完成关联。


解绑弹性网卡
当某块弹性网卡需要更换绑定的云主机，我们需要先从当前云主机解绑，然后再绑定到新的云主机，操作也很简单：

进入云主机列表界面，点击需要解绑云主机实例 ，进入详细信息界面。
点击“弹性网卡”，显示已绑定的弹性网卡列表。
在需要解绑的“弹性网卡”栏，点击右边的“解绑”链接。



在弹出的界面，点击“确定”按钮，一会就会提示“解绑成功”。

此时该台云主机跟这块弹性网卡的关联关系进行了解除，在云主机上再执行   将看不到先前绑定的弹性网卡，如下图所示：

解绑弹性网卡后注意事项
解绑弹性网卡需要注意几点：

如果你在云主机里配置  地址是使用网卡配置文件的话，该配置文件仍然保存在服务器上并未删除，需要我们自己去删除，同时，相关的路由表信息也需要我们自己更新。
解绑出来的弹性网卡并未从云平台上删除，可以重新绑定或者绑定到另外一台云主机上。
解绑只是将弹性网卡跟云主机的关联关系进行解除，这块网卡上面的  地址和关联的安全组未变动。

删除弹性网卡
当某块弹性网卡不需要使用了，我们就可以将其删除。此时，它所配置的  地址会被释放，它所关联的安全组则仍然不会删除。
、打开私有网络控制台。、点击左边的“弹性网卡”，进入列表界面。

、找到需要删除的弹性网卡行，点击“删除”链接，如上图所示。
其他操作
除了常用操作外，弹性网卡还支持以下操作：

更换子网
分配更多内网 
绑定弹性公网 
修改内网 

这几个操作，在私有网络下的弹性网卡详细信息界面，或者云主机详细信息下的弹性网卡界面均有对应的功能链接，操作均很简单可视化。
弹性网卡的适用场景
腾迅云的弹性网卡在我们实际运维中，可以满足多个使用场景，下面简单说明，或许某个场景正是你所需要的。
场景一：单主机多内网 
借助弹性网卡，现在我们可以轻松的实现单主机多个内网  地址，同时腾迅云的控制台在分配  或者我们手动分配时，均会检测这个  地址是否已经被使用，以保证不会同一个  地址被分配到多个网卡或者云主机。我们现在通常只能在云服务商的控制台修改内网  地址，而要给某云主机增加  时，只能我们自己维护这些  地址。
场景二：细化的安全策略
现在通过弹性网卡关联安全组的功能，我们可以轻松细化安全控制策略，可以给每个网卡设置不同的安全组，实现不同的安全策略。在没有弹性网卡前，我们的安全组是对整台云主机进行出入安全控制的， 则是对整个子网进入出入安全控制的，现在可以对某个网卡进行出入安全控制了。当然，你也可以继续沿用对整台云主机进行出入安全控制，非常灵活、弹性。
场景三：单主机多公网弹性 
弹性网卡的每个内网  均可以绑定弹性公网 ，轻松实现多公网 ，可以应用到虚拟主机业务、 网关多域名、每个  独享  、运维和业务运营连接分开等多租户的场景。
场景四：高可用容灾
我们可以借助弹性网卡的动态迁移功能做高可用容灾迁移，例如我们有多台  服务器，当某台服务器出现故障无法继续服务时，我们可以立即将其绑定的弹性网卡迁移至基于镜像创建的新服务器上，前端的负载均衡都无需剔除旧的后端机器后又新增后端机器，只要新的机器激活了迁移过来的弹性网卡，即可恢复前端负载均衡器的健康状态。

场景五： 或子网灵活路由配置及隔离
弹性网卡关联  内的子网，我们知道在  下可以为不同的子网配置不同的路由，这就给我们增加了很多灵活性。
假设一个公司在同城多个可用区分别有一个私有网络，多个私有网络用于增加应用的高可用性，所以会有基于内网的数据同步传输，同时应用又要对外服务，内部的运维人员也需要进行运维管理。
针对这种情况，我们可以给云主机新绑定  块弹性网卡，处于不同的子网上。 块弹性网卡分别用途如下：

弹性网卡 ，用于对外服务，绑定公网弹性 ，其安全组只开放  两个端口的入站连接，出站连接全开放。此弹性网卡所在子网的路由表使用默认，属于被动访问 。
弹性网卡 ，用于跟多可用区的服务器进行数据同步传输，无需绑定公网弹性 ，关联的安全组可以开放更多端口。此弹性网卡所在子网的路由表有“对等连接”的下一跳路由，可以正确的路由到到另外一个私有网络。
弹性网卡 ，用于运维管理，无需绑定公网弹性 ，关联的安全组可以类似弹性网卡  开放更多的端口，运维人员通过  连接进来，经由此弹性网卡所在子网路由表的  网关，可以互相通信。

上述  块弹性网卡都是辅助型弹性网卡，除此之外，云平台自动分配的主网卡则用于主动  访问，路由通过  网关出口到公网，流量也归宿到  网关。
这个实例经过配置后，可以实现主动、被动、内网数据同步传输和运维管理四个应用完全隔离，实现不同网络的差异化安全策略控制，保证云主机和内网安全，在金融行业可以较好满足安全规定。
场景六：微服务型态应用
在微服务应用场景中，我们会有微服务间通信、微服务与数据存储应用通信、微服务与  网关通信和微服务自动发现等等，结合弹性网卡的多子网和隔离的安全组功能，实现将不同的通信应用进行隔离，尤其是微服务与数据存储的通信，我们应当谨慎配置其通信安全策略，以保证数据的安全性。
在非微服务型态应用场景，我们也可以将业务运行和运维监控进行分开。
使用上的一些约束
在实际使用中，腾迅云对弹性网卡也进行了一些约束，主要根据  和内存配置不同的云主机，限定可以使用的弹性网卡数，以及网卡绑定的  个数，下表是他们的约束具体规则：

另外一个在使用中需要特别注意的约束是，因受到网络架构限制，私有网络中其他云主机互访辅助弹性网卡的  地址，需要在该台云主机绑定一块相同子网的弹性网卡才能互访。
测试体会
经过断断续续的两三次测试，可以发现腾迅云的弹性网卡是一种增强了虚拟网络应用的功能，不管是小型应用、金融应用或者中大型应用场景，都可以非常好的满足，总体上优点多于缺点，对于希望进行精细化运维的企业，可以结合需求多尝试。现在弹性网卡也开放了  接口，可以通过程序自动化处理，满足  的应用。
优点

细化了安全组的应用，这可以帮助很多运维人员减少在云主机内部配置防火墙规则的工作，这在  逐渐深入应用场景会很有帮助。
开放了 ，具有开发能力的运维人员可以整合到自己的运维管理平台。
即时绑定、解绑的功能，为容灾迁移带来了便利。
可以方便的结合子网路由和  实现丰富的安全策略控制。

一些不足
目前弹性网卡刚开放使用不久，功能还不是特别完善，同时也可能还存有一些小 。在本次体检中有遇到的几点不足：

绑定弹性网卡后，无法实现自动配置  到云主机上。应用角度应该是可以实现的，比如在腾迅云的  程序中增加触发更新  配置。阿里云的安全补丁就是通过其  程序进行修补的。
如果有一个界面可以查看到各子网当前已用  清单，对于还未实现运维自动化的运维人员会更有帮助。
关联的安全组只能一个，无法像云主机那样关联多个安全组。
受限于当前的网络架构，辅助弹性网卡的  地址，与其他主机互访时，要求双方均有相同子网的网卡及  地址，即在两台云主机绑定一块相同子网的弹性网卡。


相关推荐
新时代运维监控能力的进化——天网云用户体验监控平台实践
【腾讯云的种玩法】构建企业级应用环境之数据层面优化一
快速上云从这里开始接从源码出发浅析   的焦点移动原理 上篇
 
如果开发者没有指定，则用找指定方向上最近的视图看一下这里的用法

  找到所有的 
 
  {
      从中找到最近的一个
     =     
}
 ，从开始找所有的视图
       {
      __
}

      
           {
    
    
}
如果是一个单纯，则添加自己，但这种情况很少见，大部分的都是
 
        {
       = 

       = 

      = __ {
        
           = 
           = 

           =      {
               = 
               _ ==  {
                  
            }
        }
    }

      = __
               
            ||  ==  
             ||  {
          
    }
}
对于来说，遍历并添加自己的所有的这里有个变量，有三个取值

__：在所有子视图之前获取焦点
__： 在所有子视图之后获取焦点
__： 阻止所有子视图获取焦点，即使他们是的

 
       
            {
      =  {
          ==  {
             = 
        }
          取得考虑之后的焦点，该是相对视图本身的
              
        
          将当前视图的坐标系，转换到的坐标系中，统一坐标，以便进行下一步的计算
         
    }  {
        
    }

      {
        
         _
         _
         _
         _
             找出指定方向上的下一个视图
               
                     
        
                  
    }
}
 
    {
    
}

    {
     = 
     = 
     =     
     =     
}
这里是取得考虑之后的焦点，该是相对视图本身的
  
       {
       
}


             
    
 
    
            {

           
      ==  {
        
    }

      = 

           
     在树上往上层层遍历，直到为止
      = 
               
              =  {

          {
             把转换到当前当前的坐标系中去
              
                      
            
        }  {
            
              
                      
        }

         继续往上找
         =  
         = 
    }

                  
          
      ==  {
          {
             最后再转换一次，终于把的坐标转换到了的坐标中
              
                      
        }  {
              
                      
        }
    }  {
                 
    }
}
经过层层转换，最终把视图的坐标，转换到了坐标系中。这样就统一了坐标，以便进行下一步的计算。
 找出指定方向上的下一个视图
    
      
            {
           
              
    
     {
         _
             先虚构出一个默认候选，就是把向右移一个身位，按键向左，那么他肯定就是优先级最低的了
               
            
        
    }

      = 

      = 
     遍历所有的视图
       =      {
          = 

              
          ==  ||  ==  

                  
        
         将的坐标转换到的坐标系中，统一坐标
         

         进行比较，选出较好的那一个，如果都是默认候选的差，则为
             {
            
             = 
        }
    }
     
}
在统一坐标之后，对于所有的视图，进行一次遍历比较，得到最“近”的视图作为下一个焦点视图。这里用到了一个方法，从两个候选中找到在指定方向上离当前最近的一个，具体算法这里不细讲了。
至此，就找到了下一个焦点视图，然后调用方法，让其获得焦点。
小结
经过对源码的分析，系统本身寻找下一个焦点视图的过程是：

首先寻找用户指定了的视图，从当前焦点视图的节点开始遍历，直到找到匹配该的视图。也许存在多个相同的视图，但是只会找到视图节点树中最近的一个。
如果没有指定，则遍历找出所有的视图，统一坐标系，然后计算出指定方向上离当前焦点视图最近的一个视图。

结合事件的流转，处理焦点的时机，按照优先级顺序依次是：


回调


指定
系统自动从所有的视图中找下一个焦点视图

以上任一处都可以指定焦点，一旦使用了就不再往下走。
很多视图控件就重写了其中一些方法。比如，它会在的时候，自己去处理，用来进行内部的焦点移动或者整体滑动。
 

    {
               
      || 
}

    {
    

      {
            = _ {
              = 
              ==   = 
              = 
                     _
             如果不能滑动，则直接让下一个视图获取焦点
              = 
                      = 
                     _
        }
         
    }

      = 
     如果可以滑动，则进行本身的滑动
      == _ {
          {
             __
                  {
                     = _
                }  {
                     = _
                }
                
             __
                  {
                     = _
                }  {
                     = _
                }
                
             _
                  _  _
                
        }
    }

     
}
由于在里优先处理的，因此对于滑动方向的，就监听不到了。这也就是为什么里居然截获不到按键事件的原因。
本文从源码的角度分析了焦点的移动原理，如果大家有兴趣可以一起多多交流。月号知乎网友的提问 《如何评价腾讯开源的基于  和  协议栈的网络框架 ？》，我们将讨论内容和我们的一些想法进行了整理。
项目背景
 这个项目起始于的授权项目，当时是年，还未开源的时候，我们就基于做了授权，做完的时候正好也开源了，正式上线后单网卡性能达到万，后面又实现了一个简易的协议栈用于支持 。
后来合并进入腾讯云，腾讯云有大量业务需要高性能的接入服务，而虽然更适用于等简单业务场景，但是否能够对这些层的业务一样有性能提升效果呢。我们在原来授权的协议栈基础上实现了较为完整的协议栈参考了等，进行了业务性能测试，除了大并发短连接性能呈数十倍的提升外，其他常规网络指标如并发连接数、带宽等的性能也有比较大的提升。
后续在协议栈之上增加了协程框架，并且上层兼容了腾讯的服务端框架，使得腾讯云原有的业务可以无缝迁入来提升性能，兼顾了高性能、易用和通用性。但是经过近一年的线上使用运行，我们发现，线上的网络环境各式各样，这个协议栈并不能满足全部需求各种、网络调试等，而自己去实现各种协议既费力又不讨好，不如借助社区的力量，所以开始对开源协议栈进行了调研。
对于用户态协议栈来说，开源实现很多，有自研的、有和的用户态移植的，经过初步的筛选留下了和。其实一开始我们是倾向于选择的，因为其除了协议栈之外，尚有比较先进的编程理念和接口，只是上手门槛较高，但上手后使用体验还是很好的。但是在实际的测试使用中，我们也发现了的协议栈的很多不足之处，如无法处理大包、无法在外网正常运行等，我们尝试修复部分问题并提交后意识到这是又回到了原来的老路上了，最终决定放弃。
最后我们将协议栈移植到了用户态，好处主要有

协议栈功能完善，且有大量工具可以对网络进行调试分析，如、、、、、等
可以跟进社区的改进，无需自己开发维护
相比的协议栈实现复杂，的代码更清晰易懂；遵循协议开源，可能会限制部分用户的使用。

与的对比
相同
和都是基本完整的网络编程框架，包含了网络模块、用户态协议栈、异步编程接口等整个系统共用户接入使用。

应用性能实测差不多，在小包业务上对比都会有较大的性能损耗。
都提供了协程接口，可以实现用户同步编程，异步执行，用户只需关心自己的业务逻辑而不用处理复杂的异步逻辑。

不同
相当于用胶水粘合了协议栈， ，异步编程接口，上层应用等组成的系统，而则是新开发的系统，主要有以下区别。

使用纯开发部分第三方组件使用了进行了封装，容易上手；使用了， ，等比较现代和先进的特性，上手门槛较高，但上手后使用体验不错。
提供了接口，基本兼容系统等，现有程序可以做到简单改动即可接入，如果使用了的话就更方便了，直接配置使用即可得到性能提升。使用，必须要使用的接口重新开发。
的协议栈移植自 ，功能完善但也冗余去除了部分模块未编译进调试分析工具完善，运行稳定；按照协议自研协议栈，更精简，但外网运行不稳定。
有自己的内存管理系统类似，并且如果在启动时开启了参数并制定使用的路径后可以使用巨页并实现收发包的零拷贝；目前没有自己的内存管理系统，并未完全使用巨页，尚有内存拷贝，后续增加内存管理系统进行优化。
提供了用户态调度器，有异步磁盘相关接口目前尚未对磁盘进行相关优化，但后续会集成来优化存储服务。

其他问题
能否做成完全兼容？
有考虑完全兼容的方案，如_等，但还需有细节需要考虑和测试，最终肯定会提供完全兼容的。

的协议栈在外网运行有什么问题？
作为的子项目，其实用场景主要是内网数据库，并未对外网环境进行测试。我们的测试业务在外网上进行测试时，在传输较大文件或大并发小文件请求时，必现协议栈挂死完全无法访问的问题，外在表现是滑动窗口降为。当然在外网运行时可以使用协议栈，不能享受的高性能收发包，但可以体验其现代编程模式和接口。

是否可以列出剪裁的协议栈功能列表？
我们会进行整理并列出来。

单核性能提升有多少
目前版本的单核性能比内核协议栈高左右，多核优势更明显，后续会持续进行优化。发表者简介： 于旸， 专家工程师，玄武实验室，玄武实验室总监
导语 日“腾讯创新日：科技年技术盛宴”代表腾讯各个事业群技术实力的四级专家、腾讯微创新年度创意获奖团队欢聚一堂，一起畅谈、系统安全、架构设计、社交传播、推荐模式、游戏引擎等前沿科技和腾讯应用创新的台前幕后。来自玄武实验室总监、专家工程师于旸，就基架构和设计的安全，给大家进行了分享。

本次分享介绍了安全问题的成因可分为设计不当、实现不当、使用不当三类。设计类安全问题的数量相对较少，但形式变化无穷，而且一旦出现往往影响深远，解决成本巨大。同时，如果能在设计阶段就能引入安全考量，不但能减少设计出来的安全问题，也可以缓解其它类安全问题带来的风险。

以下为于旸演讲实录：
大家好！刚才听了李海波博士关于语音信息处理的回顾和展望的精彩演讲，我就在想：虽然说今天我们看人工智能没有达到科幻小说期望的那样，有的时候还是“人工智障”的状态，不能像《：太空奥德赛》中的那样能够真正成为站在我们身边的伙伴，但在某些场景中，已经能够做一些事情了，例如下围棋、语音识别；我相信，在真正匹敌人类智慧的所谓强人工智能出现之前，还有会有很多工作只有人类才能完成。第一次工业革命、第二次工业革命并没有消灭人类的工作，计算机出来的第三次工业革命之后，也没有消灭人类的工作。我们相信人工智能出来之后，可能会让人类世界有一些变化，但也会创造出一些新的岗位。没有计算机就不会有程序员这种职业、也没有腾讯，今天在座各位的工作都是计算机技术带来的。
在信息安全领域，很重要的一类工作是发现安全问题。最近这些年，自动化技术，包括一些人工智能技术在这个领域的引入，帮助我们发现了越来越多的安全问题。以前需要繁复的人工劳动的工作，现在可以用一些相关技术帮我们减轻很大工作量。但今天要分享的却不是这方面的内容，今天要讲的内容是目前阶段暂时还难以用技术处理，在未来很长时间内也一直需要由人去做的部分。如果有一天这部分内容也可以通过来实现，那就说明强人工智能已经出现。
今天我讲的题目叫“代码未写，漏洞已出”。在一般的认知当中，安全漏洞是出在代码里面，通常是写代码过程中的疏忽错误引发的。但实际上在所有的安全漏洞中，有一类问题不是这样，这就是设计类的问题。它的数量可能没有实现上的问题那么多，但这类问题一旦出现，影响深远而且巨大。最重要的是修复非常困难。房子哪块砖用的质量不好可以换掉，但是最初房子的建筑图纸画错，这个问题就不是换几块砖能解决的。

这张照片大家看出什么问题了吗？是一个密码锁，大家一看就能猜出这个密码很可能是“”对吧。如果没有真正把这个锁投入使用，一把新锁拿到你面前问设计有什么问题，你可能也想不到这个地方不该用油漆。坏的设计就像这样，本身会形成安全问题。而好的设计不仅仅可以做到自身安全，同时即使在实现阶段或其他的环节有人犯错误的时候，好的设计可以降低这些问题的危害。做到这两点，就是一个在安全角度上看真正的好设计。现实中，真正好的设计是不容易做出来的。
我们说这类安全问题属于设计不当，而设计不当又分两种。一种是单点设计不当，就是在设计当中某一个局部有一个小问题。还有一些问题是耦合性问题，多个点的耦合问题。多点耦合是相对的，因为单点问题往往也需要和其他点配合来最终形成危害，只是从大的方面看，更多问题出在内部。多点耦合问题又分系统内的耦合问题，以及设计的系统和其他系统间的耦合问题。除了系统和系统之间的耦合，还有一个常常被忽视的是系统和人的耦合。因为人其实也是系统，你的用户也是一个系统。
下面举几个比较有代表性的例子。首先我要强调的是，安全意识有时代背景。下面谈的这些问题，不全是设计者的错误。有些设计过去可能不被认为是安全问题。但时过境迁，一些新的安全攻击思路出之后，这种设计就不安全了。不能以今天的标准去苛求过去。比如岳飞，他是民族英雄，但当年也镇压过农民起义。今天我们提到岳飞还是说民族英雄，而不说军阀。
 
这是 消息摘要类中的一个函数，用来验证等数据。在这个函数本身设计的时候，这种写法可能还不被认为有太多问题，可能在座各位看这个函数也觉得没什么问题。但如果我们用刚才的这个函数去验证一个重要数据，假设是我们掌握的密钥，用户传递的密钥是，实际上用户可以用逐字节穷举的方式很快探测出真正的密钥。我们看这个函数是怎么验证比较的呢？它是一个字节一个字节比较的，只要一个字节不正确，它立即就会返回失败。如果第一个字节是对的，就比较第二个字节。所以，如果用户传递过来的密钥第一个字节是对的，和第一个字节是不对的，这个函数返回的时间会有一个微小的差异，整个指令执行周期会多一点。在这种情况下，攻击者本来要把所有数据都猜对才可以破解出这个密钥，而这是几乎不可能的。但是现在他可以一个字节一个字节猜，一下子把猜解速度提高无数倍。
所以在看安全问题的时候，时间这个维度很重要。我们看安全问题，常常更多看数据上的东西，时间维度往往容易被忽视。在计算机中处理的数据，除了关注类型、长度、内容，还要考虑时间因子。什么时候时间开始，什么时候时间结束，持续多久，这些往往会影响安全。和时间有关的安全问题非常多，这里只是举其中一个例子。

安全的设计是什么样子？这是改进后的写法。无论传递进来的密钥是什么样子的，是有几个字节对，是有几个字节不对，它处理的时间是完全一致，攻击者没有办法对通过时间差攻击来进行密钥猜解。
 协议大家非常熟悉，但用今天的眼光来看其实是不安全的。就像之前说的，我们不苛求古人，所以不说它是坏的设计，但我们说这是过时的设计。现代意义上的第一个版本是年出来的，实际上还有更早的版本。现在是用两种模式，一种是最原始的主动模式，年又出了被动模式。但这两种模式以今天的安全眼光来看都是有问题的。最早的主动模式会导致一种叫的攻击。被动模式能解决一些问题，但是又会影响服务器的防火墙安全策略。所以的设计在今天来看，虽然做了各种调整，但是还会有各种各样的问题。

 主动模式的协议是这样工作的。首先我们连接到这台机器，假设它是服务器——今天是创新日，大家看我这也是一个微创新，这个击键动画是用自带的功能来实现的——登录进去，服务器返回说，你登录进来了。这个机器假设是内网的一台机器，我们没有办法直接访问它，可能它是一台重要的，受保护的机器。但是这种的协议本身允许用户设定自己的。你去访问一个服务器，理论上它可以知道你客户端是什么，但服务器允许你指定另一个作为你的。当然，这种设计是有合理原因的，在这里不过度展开，大家只要知道它允许这样做就可以。红色的字都是攻击者的命令。成功了。这意味着服务器在这条命令之下连接了这台机器的端口，并且把执行结果发到了内网那台机器上。
如果我们再给它指定另一个端口。这里用端口。但是端口是关闭的，我们相应的可以看服务器给我们反馈连接失败。在这个过程当中，我们实现了通过这台服务器，间接连接到了一台我们根本没有办法触碰的内网机器，而且探测出那台机器的某个端口是开放或者关闭的，实现了端口扫描。实际上不止扫描，用这个技术还可以发起攻击。它影响了自己的安全吗？没有，但是它会影响身边其他服务器的安全性。这是一个很典型涉及协议的耦合问题，

谈到耦合问题，我就想到了这张图。这是一台交换机，红框处是一个键。这就不能说是历史原因了，因为设计交换机的时候一定已经有网线插头了。而且这种网线插头的设计本身又是很常见的设计，在做交换机的时候，把这个按钮放在这里。如果是稍微粗心一点的人来这么一下，整个交换机就重启了。

我们再来讲一下软件系统之间的耦合。这里有一个非常经典的例子，国内中小电商，一半以上在早年都犯过这个错误，现在基本都修复了。电商的交易和支付系统之间流程是这样，一个人过来说老板我要买一台冰箱，多少钱？两千。，你把钱付给支付系统。因为支付请求也是在用户侧的浏览器里提交的。这个过程对用户是不可见的，但攻击者实际上可以修改这个数据。攻击者可以修改浏览器提交的数据，本来交易系统让他提交元，攻击者改为提交元，然后支付系统就返回，说我收到钱了。这个到交易系统那里，交易系统一看支付成功了，那就安排发货，元钱就把冰箱买到了。大家不要笑，以上的电商出过这种问题。支付系统和交易系统在设计的时候，两边看自己的设计都没有问题，但是当你考虑到这个系统接口是要和别人配合的。支付系统要怎么样可以解决这个问题？不要只反馈是否，同时也把支付的金额和一起返回过去。是支付元还是元。这就解决了问题，现在的电商都改成这个设计了。
还有硬件耦合的问题。我去年在 讲过这个例子。这是我们年发现的问题，起名叫。条码阅读器这种设备大家非常熟悉，有各种各样的形式。去过机场，大家都会知道机场使用的都是这款机器。条码阅读器是三大部分，获取图像、解码转换和数据传输。数据传输这里有个和上位机耦合的问题。条码阅读器为了兼容性和用户体验，大多数条都支持键盘模拟模式，把自己模拟成键盘设备。这样条码阅读器插上去根本不需要驱动，把要读取的字符以键盘击键的方式发给上位机。这对软件来说也不需要专门去做读取数据的模块。但这种设计是容易出问题的。大家看一下我们的例子，我们构造了一个非常特殊的条码，扫过这个条码之后，就可以在它的上位机植入一个程序，并且执行起来。这是一个非常严重的安全问题。不同的条码设备有不同的工作原理，这种内部有一个摄像头去拍画面。还有一些条码设备阅读原理是发射激光，利用返回的信息去读去数据。大家注意桌面上的光点不是它发射出来的，而是我们从远处发射的。这个激光可以欺骗设备让它自己在阅读条码。你可以从很远的地方发射激光，就可以控制这台电脑做任何事情。这就是硬件之间的耦合问题。设计类问题一旦发生，影响非常深远，而且解决起来成本非常高。过去年，全世界所有条码阅读器厂家大部分产品都有这个问题，因为整个行业都是这么设计的。过去年里的设备都要更新？成本太高了。所以厂商没有意愿去解决这个问题。不过我们实验室目前和微信支付合作，对供应商的设备进行检测，和给出修复方案。所以现在微信支付提供给合作商户的条码设备，是没有这类问题的。

我刚才讲了软件设计问题、协议设计问题。下面讲的问题既涉及系统设计，同时又涉及协议设计，而且是多个协议设计，是一个多点综合性的耦合问题。这是我去年发现的，我起了一个名字叫。我这里列了点，是既往的协议和系统设计，它们诞生的时间点不一样，是由不同的公司不同的人在不同的时间去设计出来的。每个设计独立去看可能没有太大的问题，甚至是很有必要的。但是这九个设计综合在一起的时候引发了一个非常严重的安全问题。当时外媒报道它时甚至说“这是有史以来最严重的视窗问题，从影响到”。这九点协议协同工作的过程很复杂，大家可以看一下这个动画。在这个协同过程当中，存在一个非常小的缝隙，它不是一条直的路线，是非常弯曲的路。但是你只要找到它顺着走下来，最终可以实现劫持被攻击者的通信流量，窃取数据，甚至植入病毒。
再下面，我讲两个系统和人耦合的例子。一个是“短信保管箱”，一个是“自助换卡”，这是两个运营商的业务，也算是他们的“微创新”，但是这个微创新是有问题的。
前几年有运营商搞了“短信保管箱”。短信在我们的印象中，是只有手机会收到，除了在手机上看到，在其他地方看不到。所以在很多高安全要求的系统在设计的时候，是把短信作为一个相对可信的因素。比如网银，包括腾讯业务也会向用户发验证短信，通过验证码或者验证链接来确认你的身份。短信之所以有这个特点，是因为我们假设短信是独立于电脑的因子，也比你的个人电脑可信。但短信保管箱业务是什么？它在运营商服务器上把你的短信存了一份，你在电脑上可以登录网站看短信。本来我们认为短信是独立于电脑的安全因子，用它去验证一些更高安全级别的操作，现在运营商用这个业务之后，你的电脑一旦被别人控制，短信的第二把锁的意义就没有了。电脑一旦被别人控制，你能看短信，攻击者也可以。所以这个东西被很多网络犯罪者使用。所以最终这个业务的宿命就是被取消了。
还有“自助换卡”，这也算是一个微创新。大家看这是公安部的一个微博帐号发的信息，自助换卡的问题这条微博已经讲得很清楚了。这个业务上线之后，很快被网络犯罪分子找到了它的可利用之处。因为这个业务的设计其实是有问题的。这个业务要求你发的信息，一般用户看到没有办法很直观地知道这是要做什么。所以很容易被犯罪分子诱导去发这样一条短信。一旦发了这条短信，你的手机号就转移到犯罪分子那里去了。你的短信、来电，全都到他那里去了。以后依赖于短信验证的安全措施全等于零。因为你的手机号已经给别人了。这个业务的宿命也是下线，如果设计的时候多考虑一些，设计好一点，其实也许可以避免这个问题。所以我们在设计东西的时候，要考虑到内部的耦合、和其他系统的耦合、还要考虑和小白用户的耦合。你要知道使用你系统的人是各种各样的人，和人的耦合过程当中也会产生问题，所以必须要把小白用户的情况考虑到。
 所以我们说在做设计和架构的时候，在安全上需要多想一想，一是向外想一想，一是往前想一想。我们知道所有的设计一定会过时，但是我们是否可以做到三年之后、五年之后不要过时？古人说好医生“不治已病治未病”，好的君主“不治已乱治未乱”，好的设计者应该要把安全隐患扼杀在摇篮当中。 
谢谢大家！个人介绍：腾讯社交用户体验设计部高级工程师，前端开发组负责人，开发通道评委，腾讯云特邀布道师，《全栈工程师的自我修养》作者。

本文是我在“重庆前端交流会渝  ”上的演讲，整理分享出来，希望能对更多人有帮助，以及激起更大范围的讨论。本文并不是预先准备的演讲稿，而是后续根据  图片来复盘，所以内容跟现场表达可能会有些许差别。感谢主办方的安排和组织，感谢热情的现场观众，以下是正文：
大家好，感谢渝  组委会的组织，感谢各位付费来到现场，今天我给大家分享自己在面向未来的全栈开发方面的话题。

 “面向未来的跨界开发技术”是一个非常庞大的话题，为了能够稍微具体一点来讨论，我想分解为两部分来讲。
首先是“面向未来”。何谓面向未来，如何面相对来？
 
保罗·格雷厄姆是一个我很崇拜的程序员、产品经理、作家和投资人。
他在《黑客与画家》中说过，“年后的编程语言……拥有最小最简洁核心”，我认为与其说这是“预言”，不如说这是他的一个“理想”。

另一个行业大牛松本行弘之父读到《年后的编程语言》的时候，有不同的看法。
在《松本行弘的软件世界》中，他认为年后的编程语言，存在无限种可能性，技术上是无法预测的可能语音对话或者脑波输入？
预测年后的编程语言倒是可以试一试。松本行弘认为合理的预测方法是纵观过去年编程语言的进化规律，然后将各语言的起伏线条延伸，就应该是年后的编程语言。
根据这条线的延伸，松本行弘的预判是：编程语言要解决的问题将从“如何做”变成“做什么”，即完成一个任务需要的指令会更加简洁。

我更倾向于松本行弘老师的观点。我从  上找到了下图，图中显示了十几年来一些编程语言的“有名程度”的变化值。
有一些基业长青的编程语言，比如 、；也有一些近几年才从无到有异军突起的编程语言，比如 、、、 等。

 稍微分析一下，我发现新的语言兴起主要来自两个方面原因：

行业趋势从桌面到移动的转移， 和  是这一种。

技术趋势从  到  的转移，简单的说就是更容易完成一个需求。这一趋势就不只由语言本身决定，还由该语言配套的框架决定。


比如  的  框架就大大提升了  在  开发者中的竞争力，因为内置了一些最佳实践，甚至直接可用的项目架构，让  开发更容易。
而  在  端的发展也是由于  的易用。当然到了后期  的开发者更多了，会有更多竞争者加入，原本的框架可能会被更易用的框架来代替。
 
因此我开始调查一些框架的使用趋势，来验证这一判断。
先介绍一个我个人调研趋势的方法，就是在   中输入需要调查的技术关键词  。这个方法样能反映英语世界中的开发者对特定技术的学习热情，也就能相对客观地反映出未来趋势。
以  为例，我们能发现  已经不可避免地走下坡趋势，原因就是从年开始，直接操作  的模式已经被更易用的双向绑定和模板类库、、取代。也就是说从“怎么改变页面的行为和样式”变成“改变数据，而让页面的行为和样式自动变化”。

除了框架的使用之外，我还专门调查了前端构建工具的趋势。
前端构建已经是现代  开发必不可少的环节。因为  还没有完全普及有服务器的原因也有浏览器的原因，所以我们要把模块化的  和  模块混淆、打包以及化，以减少  请求数量并控制缓存。因为用户的浏览器的版本号不统一，所以我们需要把、、 等新功能转译成大部分浏览器都支持的最小子集。这些工作都需要用前端构建工具来完成。
从前端构建工具的趋势来看，是先烈，但是日渐式微被  赶超，原因一是基于文件的流程比基于  的流程慢很多，二是因为  的基于配置的方式比  的基于“正常  代码”的方式更固化，风格上不讨人喜欢。

而  兴起是因为  模块化编程这一趋势。 和  差不多是做一样的事情，就是把一个一个的  模块打包成一个文件这一过程称为 ，然后在浏览器环境中使用。其实在服务器端的  模块也可以打包，不过没有太大必要。本来  原生不支持模块，所以就有了第三方规范之类的，后来  新增了模块功能就叫  ，所以各种各样的模块要在一起协作就是要解决的一个问题。 和  就是解决这一问题的。

我想，可以得出一个结论是，无论是编程语言，还是配套的框架，和对应脚手架，都长期处于变化之中。有一些框架和脚手架能够顺应一时潮流和风格，也许能暂时拔得头筹，但很容易就会被后起之秀、超越，这样的迭代变化在未来也不会停止。
所以，唯一能面向未来的知识只有“又快又好地学习”的能力。

说到学习，我收到一个读者邮件。这个读者硕士毕业之后找了一份的工作，但是产品方面不太喜欢，希望转行做   开发。
我认为这个读者焦虑的主要原因在于两点：

从  到  转型学习的时间其实还比较短，远远不到小时。技能还不是很熟练，这时看到一些招聘要求出现大量不理解的词，就觉得理想与现实的差异太大。

学习过程比较独立，没有从做中学。


我说一下我理解的“编程”，可以分解为三点：智力、知识和经验。
 
具体如下：

具体到“编程”这门手艺而言，这三者都不可能单独去提升。也就是说不可能只提升经验，而不去学习；也不可能只是学习，而不去动手提升经验。
好的学习方法是循环式地，学习一些新的知识，然后边做边学  ，在这过程中再加入一些思考，提升智力。

对于有一些工作经验的程序开发者来说，可能已经进入这个循环中，遇到了一些瓶颈，这时候可以对照上图来看，现在卡在了什么地方。
对于初学者，或者从新开始学习一个技术栈的有经验者，就需要有一个学习路径。也就是“地图”，以及“我在哪里”。下图是一个学习的蓝图示例：

开启循环之后，就采用下面模式来循环。
 
我在年读到局外人的时候，学习到了一个终身受用的概念，就是小时定律。
这个定律大家都听过，好像很简单嘛，一句话就概括了一本书。
其实不是的，这本书里有很多发人深省的内容。比如讲了比尔盖茨和乔布斯都是同一年代出生，周围的环境和他们自己的兴趣给了他们练习小时的机会，才会有机会成为微软和苹果的创始人。
小时也不是重复重复再重复，而是要持续在 去练习。不是在 枯燥地重复已经会了的事情，更不是在 去恐慌。

我就这样跟这位读者说明了我的观点：

放松焦虑心情，工作才一年多，要成为 开发的大师需要小时；

要找到一个工作不需要小时，基本上小时可能就够了，但是要边学边用才有效；

开始用，而不是一直学。我看到你的，里面的工具很多，不要一昧追逐，可以看一些好的项目，自己去搭建博客、爬虫、等；

持续提交你的代码，看到项目的功能越来越多，也能减少焦虑；

每天小时也有点少，最好能增加到小时。


过了一天，这位读者竟然给我送了一张亚马逊礼品卡表示感谢。所以我把这个故事分享给大家，也希望大家有所收获。

再讲一个我亲身经历的例子。
我为了保持对算法和数据结构的“感觉”，偶尔会在  上找一些题目来做，特别是网站现在支持  了，就更加方便。
有一天我看到这样一个题目。

大家先不要看我的答案，来想一想这个题目怎么解。。我的第一次解法很直白，每次需要计算  到  之间的和的时候，就循环计算一次。心算了一下，感觉应该没有问题，就提交了。

然而，系统提示计算超时！
我看了一下超时的测试案例，是一个超长数组。更重要的是，系统对这个对象进行了多次求运算，导致超时。

唔……所以怎样才能不要运行那么多循环呢？各位开动脑筋想一想。。。
重点是题目中的“提示”部分。于是我想到这个优化后的方案：在初始化对象时就计算出一个  的数组，表示“从  到  的和”，这样要计算  的时候，就只需要  就好了，最后再处理一下边际情况。
因为假设数组不会变化，所以无需更新数组内容。
完美通过测试！

通过这个题目，我对时间复杂度和空间复杂度的印象又加深了，这是单纯看算法书不能提升的。
以上，就是我在学习编程、打磨手艺方面的经验。

说完了“面向未来”这一话题，下一篇我将讲讲“跨界开发”这一话题，敬请期待！

相关推荐下一篇 面向未来的跨界开发技术下人人都是网络工程师前言
近几年在领域动作频频，先是推出作为体验的敲门砖，随后发布 作为体验的基石，紧接着移动端的平台应运而生，今年在 大会上推出了升级版，近期发布了基于平台的  — ，这摆明了就是要怼早一步公布的平台的  — ，让无数开发者兴奋不已，两家公司的竞争态势也蔓延到组内移动端两股开发势力，前几个月隔壁组的同事可都是鼻子朝天走路的。

秉着对的好奇，自己对       ‘进行相关学习，也对进行实践操作和分析，结合各种专业人士的真知灼见，本文难免有所纰漏，欢迎大家指导交流。
和区别
比较正式的解释：

虚拟现实 ：利用计算机创造一个虚拟空间，利用虚拟现实眼镜能够使用户完全沉浸在一个虚拟的合成环境中，利用双目视觉原理，虚拟世界在眼镜中是立体的，无法看到真实环境。
增强现实 ：能够把虚拟信息物体、图片、视频、声音等等融合在现实环境中，将现实世界丰富起来，构建一个更加全面的虚幻世界。


而对于小白用户来说，最直观最接地气的解释是

不需要开摄像头，只有虚拟场景，没有眼前的真实场景

需要打开摄像头，既有虚拟场景，也有所处的真实场景。双管齐下，在这两方面都投入了很多的资源

方面，攻城锤是和，前者是体验级解决方案，属于入门级设备的首选，物美价廉；后者是消费级解决方案，提供了手持遥控设备，提高渲染效率，优化延迟。很多应用开发者都在平台上产出琳琅满目的作品，大量的影视作品、演唱直播都制作成格式。最近推出的 版本提出了 ，在平台上开发可以让手机与电脑一起联动，提高开发效率。



这次更新也提供了投射功能，将你所能看见的展现给在场的其他朋友一起观看


方面，主力军是 和，前者是利用高配置的软硬件结合方案，提供环境感知，位置跟踪等服务，应用于室内定位、三维建模、机器人等领域，应用于移动设备上的产品很有限；


后者是最近推出的针对移动设备上的单目  惯性测量单元的增强现实方案，试图打造用户量最大的平台，目前还处在阶段，主要对标苹果推出的。

工作原理浅谈
 在移动设备上运行主要有三大关键技术：
  运动追踪可以让手机了解并追踪其在现实世界中的位置。使用手机的摄像头观察房间里的特征点和传感器数据，判断设备所在的位置和方向，对虚拟物体进行精准放置，同时使用  室内导航定位周围的物体位置。
   环境感知 可以让手机检测到类似地板或桌面平面大小和位置。虚拟物体一般是放在平面上，可以利用动作追踪中使用的数据点判断水平表面，保证物体可以正常放置，增加现实感。
   光线感知 可以让手机感知真实世界环境中的光照条件，让开发者照亮虚拟物体的方式与周围环境匹配，虚拟阴影在光照条件下会自动调整，以便让虚拟物体看起来更真实。
上手
官方运行设备
被设计用来支持数量广大的设备，但是目前对设备要求比较严格，要求系统不低于    ，支持下列设备：

  和  
        


但是实际上可运行的设备并不限于以上手机类型，个人臆测其实应该是提前研发了，为了增加使用范围，所以在适配其他手机类型上花费了较多的时间，没想到苹果利用适配款式少、系统唯一等优势提前发布了，并直接宣称是世界上最大的平台，别说，就我们这些开发者也是不服的。出于各种因素，应该是提前发布了，并限定了可运行的手机设备，这些设备是满足各项严格测试的，还有其他部分设备只支持部分功能，存在未知隐患，所以还没有公布。但是可以通过修改代码的方式来去除设备限制，这个会在后文描述。
开发环境
根据目前的 文档描述，支持的开发环境有 、、、四种。下面以 为例进行开发。

首先搭建开发环境：

安装   或更高版本，运行环境    或更高版本。
需要使用上面提到的能支持  的  设备。
需要为   提供  ，可以下载     并解压或直接下载在上的项目

 不支持   等虚拟设备，满足要求的设备除了要开启大家所熟知的开发者模式之外，还需要提前安装，提供基础的 ，安装成功之后会在系统应用里面显示出 的提示，表示安装成功。

同时利用 可以反编译查看的结构

根据对包文件名称猜测，这个才是的核心，供应用中的接口调用。在   中，找到 ___，并打开  示例项目，主要依赖文件有_和

编译项目并在设备上运行，打开相机权限，移动拍摄位置，会出现很多星点，经过计算之后会识别出平面位置，点击平面会放置绿色的安卓，效果图如下。

其他可以使用的设备
在普通手机上运行该项目，会直接弹出“     ”的提示，然后就闪退了，连里面什么样子都看不见，支持的官方推荐手机都是元以上的高端机，像我这种手持低端机的开发者也想看看运行的样子，感谢上大神提出的这种简单易用的方法修改依赖文件，虽然不能从根本上解决问题，但还是可以绕过手机类型判断这一步。
解析过程

解压文件：中文件夹下有_文件，也是项目中的依赖文件，对其进行解压，再对其中的文件进行解压得到核心文件集，对文件进行修改。
反编译文件：需要将文件转换为文件，我采用的是工具进行反编译，在命令行中执行     
修改文件：文件名很直观的告诉我们这个文件主要执行对可运行设备的判断，里面的方法也很简洁：主要在中判断，而其中的一个判断条件主要是对由设备的各种信息拼接而成的内容进行匹配，所以可以直接一刀切，在中最后一个判断分支里面注释掉 的语句，如下所示：

     {
     {
          =  
          = 
          = 
          = 
          = 
            {
                    
             
        }

          ==      {
                    
             
        }
    }
       {
                  
    }
      {
            
         
    }
     
}

    {
      ||  ||  ||  ||  ||  ||  ||  ||  ||  ||  || __ ||  ||  ||  ||  ||  || 
}

    {
      ||  || 
}
 编译文件：利用 中的文件对文件进行编译，在当前的文件目录下执行       ，这里是对应我本地的  版本，因人而异。
 打包文件：将得到的文件重新压缩进文件中，在所在目录下执行     ，接着在_所在目录下执行  _  _
生成：在 中 新改的依赖包可能会不生效，然后运行安装在其他设备上，经过部分手机的测试， 也可以出现上文展示的效果，中也会展示出      ，进入了刚才修改的判断分支中，不过相比较于和，识别速度等会慢一些。而大部分手机虽然可以进入应用，但是只是在底部提示“  …”，主要的显示区域也是黑屏，并不能使用的主要功能。上述的项目中也展示了支持的手机测试清单，除了官方推荐，其余支持的手机目前只有 和 。
  
上文中的三个核心技术在中都有涉及，而且 和包里面的文件命名都出现了的字眼，由此不难猜测出其实是在的研发基础上进行的功能改造，一定要达到特定的软硬件标准才能够实现，比如下图是一台手机需要的部分组件

有专用的红外深度感应摄像头，可以创建丰富的纹理，直接测量距离。可以简单理解为检测平坦的表面，然后在上面放置虚拟物体，它并只是对相机反馈数据进行估计。但是苛刻的设备要求、大量产商不合作和用户需求不够强烈等因素使得一直不温不火，于是将的关键部分分离出来，移除了深度相机部分功能，让它适用于普通手机，就是为了解决这些痛点而存在，不需要严格的特殊硬件，主要从软件方面解决问题。但是毕竟现在还是预览版，能否真正实现未实现的目标还不得而知。
  
首先了解下的基础知识。是一种为构建增强现实的框架，意在实现将虚拟内容精确且真实地浸入真实世界场景上。框架提供了两种技术，一种是基于场景实现的增强现实，一种是基于场景实现的增强现实。的核心是为一些基本的关键功能提供支持，包括运动跟踪，水平面检测，以及环境光预测。

运动跟踪：移动设备提供了专用的运动协处理器。该功能采用   视像惯性测程，基于镜头捕捉的数据估计设备的三维定位及移动情况。
水平面检测：可以识别出水平面，将虚拟物体精确地置于真实物理场景中。
环境光预测：对虚拟物体产生真实阴影和光照效果相适配。

下图是针对两种框架下的官方实例对比，左侧是是 ，右侧是三星，分别识别出平面并添加物体，旋转一周，特征点发生明显的变化之后，再次重新定位

异同点

光线感知：和都可以对环境光进行简单的估计，为开发者提供了强度和色温选项，而提供了单像素强度值  和 。
建图定位：和都使用了离散点云图，跟踪器会提前去判断是否有预加载的图，没有的话就自定义新的模型，会获取到相机视角下的一个范围。当你移动设备时，摄像头会捕捉到新的一图像，并加载到之前新建的模型中，不断增加内容。在建图的时候使用了“ ”，只会在图中保存最近的时间和距离数据，旧的数据会被自动忽视，而会管理维护更大的数据和地图，保存的内容会更加持久稳定。
市场布局：只支持及以上处理器的设备，对应着就是 及以后的机型，手机系统的高度统一性也奠定了苹果庞大的设备基础，目前预览版只针对少量机型和系统，再加上产商各自为营，因此在普及度上短期内还是处于落后地位
产品开发：提前几个月发布，目前已经有多款实用的，展现了开发者无限的想象力  而近期才发布的还需要开发者脑洞大开，不过在过去的年里面已经积攒了开发工具和技术支持，这些应该可以为长期致力于的开发者提供良好的过渡和帮助。



比较看来，和核心功能点类似，中 在已经支持的设备上追踪性能与的识别能力十分接近，在建图和重定位方面具有一些优势，在集成和跟踪方面具有一定的技术优势，各自都有市场地位，在选择方面主要看开发者的个人偏好。
总结
和苹果两大巨头终于在领域部署基于系统层面的解决方案，推出了实际的可落实到移动设备上的框架产品，两者强势的竞争势头是众多领域开发者的福音，而对于第三方独立公司来说可能就是沉重一击，毕竟这两大巨头配套产商垄断了移动端的硬件设备和软件系统，在夹缝中生存的压力可想而知。和相爱相杀，不仅提高了应用的体验效果，又降低了开发门槛，是不是的春天真的来了，让我们拭目以待……
参考资料






一、概述
来自家族，是一款强大的数据处理工具，它可以实现数据传输，格式处理，格式化输出，还有强大的插件功能，常用于日志处理。
的数据处理流水线有三个主要角色完成： –  – ：


：必须，负责产生事件  ，常用：、、、、如： 【拓展阅读】
：可选，负责数据处理与转换  ，常用：、，、、、       【拓展阅读】
：必须，负责数据输出   ，常用：、、、、【拓展阅读】

二、应用部署
安装启动都非常简单，这里就简单提一下关键步骤：
、部署环境略
、安装 
①、下载：
②、解压
③、启动

      
三、常用配置：
、读日志文件：

   {
     =  
     = 
    _ = 
  }
}
、监听数据

 {
     {
         = 
    }
}
、读取数据

 {
   {
     = 
     = 
    _ = 
     = 
  }
}
、读取数据
 {
     {
        _ = 
         = 
        _ = 
         =  {
             = 
        }
        _ = {  =  }
    }
    {
        _ =  
         = __
        _ = 
         =  {
             = 
        }
        _ = {  = __ }
    }
}
网管这边主要用到，这里着重介绍下：

多模块：如果有多个日志源，即存在多个，那么可以写多个模块
：每个模块指定对应的用于读取指定日志
_：多个应指定为同样的_，表示是同一类，避免数据重复
：存在的都是数据，因此这里指定为解码
_：这里给不同类型数据加上区分字段，后面的和将会用到更多介绍：

四、常用配置
、慢日志：

 {
     这里就用到前文提到的区分字段了：
      == __ {
         {
             正则匹配不同版本慢日志格式可能不通，此处适用于 版本
             =   \\{}\\\\\\{_}\\\\_\{_}\_
\{_}\_\{_}\_\{_}\\={}\\
\\\\\
             慢日志里面的主机为主机名，因此这里变相处理下，加入_字段，值为指定的值
            _ =  _ {} 
             匹配到了就加入标签
            _ =   
        }
         未匹配的数据直接
              {
            {}
        }
         {
            这里对慢日志的时间戳进行格式转换
             =    
            _ =   
        }
         此处对进行运算，并存到字段，用于区分同一条
         {
            _ = {_ = {}}
             = 
                _  
                _ \\{}\ 
              
        }
         {
                 = 
                 = _
        }
         移除不需要的字段
         {
            _ = _      
            _ =       
            _ =       
            _ =       
            _ = 
            _ = _
            _ = 
            _ = 
            _ = 
            _ = 
        } 
     }
}
 有用的说明都在注释中，仔细看看吧
、访问日志

 {
     只处理标签为__的数据
      == __ {

         为了兼容中文路径，这里做了下数据替换
         {  
           =  \\ \\\
      }

       排除请求
            {
            {}
       }

      、已经将日志格式定制为，所以简单处理即可
       {
             从数据中取出
             = 
             删除多余字段
            _ =           
            _ =       
            _ =       
            _ =       
            _ = 
            _ = _
            _ = 
            _ = 
            _ = 
            _ = 
        }
    }
}
、系统日志
大同小异，就不做注释了。

 {
      ==  {
         {
               = {  = {_} {} {_}\{_}\ {
_} }
              _ =   {} 
              _ =   
        }
              {
            {}
        }
         {
             = _
             = 
             =           
             = 
        }

         {
             =  = 
        }
         {
            _ =       
            _ =       
            _ =       
            _ = 
            _ = _
            _ = 
            _ = 
            _ = 
            _ = 
        }  
    }
更多介绍： 
四、常用设置
、直接打屏
 {
    {
         = 
    }
}
、上报
 {
     {
         = 
         指定索引，按时间分表
         = {}{}
         由控制模板
        _ = 
    }
}
、上报
{
    {
        _ = 
        _ =   的地址
        _ = 
    }
}
、网管侧的配置示例：
 {
     上报系统日志
      ==  {   
         {
             = 
             = {}
             不管理模块，使用已保存模板
            _ = 
            _ = 
        }
    }
    上报慢日志
      == __ {
         {
             = 
             = {}
            _ = 
            _ = 
        }
    }
     上报日志
      == __ {
         {
             = 
             = __{}
            _ = 
            _ = __
        }
    }
}
 更多介绍：
五、附录
最后附上网管侧完整配置，仅供参考：

 {
     {
        _ = 
         = 
        _ = 
         =  {
             = 
        }
        _ = {  =  }
    }
     {
        _ = 
         = __
        _ = 
         =  {
             = 
        }
        _ = {  = __ }
    }
     {
        _ = 
         = __
        _ = 
         =  {
             = 
        }
        _ = {  = __ }
    }
}

 {
      ==  {
         {
               = {  = {_} {} {_}\{_}\ {
_} }
              _ =   {} 
              _ =   
        }
              {
            {}
        }
         {
             = _
             = 
             =           
             = 
        }

         {
             =  = 
        }
         {
            _ =       
            _ =       
            _ =       
            _ = 
            _ = _
            _ = 
            _ = 
            _ = 
            _ = 
        }  
    }

      == __ {
         {
             =   \\{}\\\\\\{_}\\\\_\{_}\_
\{_}\_\{_}\_\{_}\\={}\\
\\\\\
            _ =  _ {} 
            _ =   
        }
              {
            {}
        }
         {
             =    
            _ =   
        }
         {
            _ = {_ = {}}
             = 
                _  
                _ \\{}\ 
              
        }
         {
                 = 
                 = _
        }
         {
            _ = _      
            _ =       
            _ =       
            _ =       
            _ = 
            _ = _
            _ = 
            _ = 
            _ = 
            _ = 
        } 
     }

      == __ {
       {  
         =  \\ \\\
      }
       {
             = 
            _ =           
            _ =       
            _ =       
            _ =       
            _ = 
            _ = _
            _ = 
            _ = 
            _ = 
            _ = 
        }
    }
}

 {
      ==  {   
         {
             = 
             = {}
            _ = 
             _ = 
        }
    }
      == __ {
         {
             = 
             = {}
            _ = 
            _ = 
        }
    }
      == __ {
         {
             = 
             = __{}
            _ = 
            _ = __
        }
    }
}作者 |李力振编辑 | 顾乡
基于腾讯云搭建直播系统及空间直播问题定位
直播最近很火爆，空间推出了直播功能，是基于腾讯云搭建的。基本原理是用户在空间发起直播时，空间后台调用腾讯云的创建直播频道房间，终端通过协议把视频流推送到腾讯云；访客观看视频时通过协议从腾讯云实时拉取视频。
：   实时消息传送协议协议是 公司为 和服务器之间音频视频和数据传输开发的私有协议目前提供了一个并不完整的 给大众使用；
：  是苹果公司 实现的基于的流媒体传输协议，可实现流媒体的直播和点播。
、搭建一套直播系统
一、申请腾讯云直播服务

开通后有的免费试用流量，可以够玩一下的了。
二、创建直播频道

 
创建完成后，有两个地址：
、推流地址：
_=
、播放地址：
_ 
三、进行推流
这里使用进行模拟推流，就是把一个文件流化、推送到腾讯云。
这里的下载地址就不贴了
   \_\     _=
四、播放
这里使用进行播放。是一个功能强大的开源播放器。可能接收、、、等多种协议的网络视频播放

、空间直播问题简单定位
由于本人主要负责空间分享业务。这里主要讲直播再分享到空间后的定位。
怎么样分享到空间？这里略去，下载个最新版的空间独立版试一下就知道了。
说到定位后台定位问题，这就要借助龙哥功能强大的工具了。
、拉取分享列表
=_____=====
 
这里关键是找到一个“_”
、拉取房间信息
=__

直播地址：
_
点播地址：
_
空间直播支持回看功能，观看直播用最上面的地址，直播结束后，如果要观看点播则用下面的那个地址。
正常情况下，把上面两个地址中的一个拷贝到中，就可以观看。如果播放不了，通过进行抓包分析
、协议

                     文件头，必须放在第一行
       第一个分片的序列号
       每个分片的最大的时长
          是否允许
              文件结束符
                      ，分片的信息，如时长，带宽等

相关推荐
基于  的跨平台播放器实现直播应用的后台服务器性能测试实践直播回看：高可用架构入门 —— 腾讯云架构演变及经验原文【  ——  】

建立成功的项目
你们已经启动了你们的项目，你们正在传播它，同时有人正在查看它。真棒！现在，你如何让他们坚持下去。
一个受欢迎的社区是对你们项目的未来和声誉的投资。如果你的项目才开始收到第一次贡献，那么你们需要尽早的给贡献者们一次积极的经历，以至于能让他们继续参与贡献。
让大家感到受欢迎
可以通过被称之为贡献者漏斗的方法思考你们项目的社区。

当你们建立了自己的社区，你需要考虑如何让那些处在漏斗上方的人潜在用户转移到漏斗下方活跃的维护者。你们的目标是减少贡献者们在每个阶段遇到的摩擦。当人们能够轻易的取得胜利时，他们会乐意去做更多事。
从你的文档开始：

让大家很容易使地用你的项目。 一份友好的 以及清晰的代码示例将让大家很简单地开始你们的项目。

清楚的解释如何做贡献，使用你的 以及持续更新。


好的文档能够邀请他人参与你们项目的互动。最终，一些人会开一个或者 。将这些互动视为机会，将他们转移到漏斗的下方。

当一些人选择了你们的项目，请对他们表示感谢！仅仅只是一次消极的经历就能让一些人不想再回来。

及时回应。如果你们一个月都没有回答他们的问题，他们可能早已忘记了你们的项目。

对你以后接受的所有贡献者持开放态度。 很多贡献者是从一份报告或者小的修复开始的。这里有很多为项目做贡献的方式。让大家选择他们喜欢的方式。

如果你不赞成一个贡献， 首先你需要对他们的想法表示感谢，同时 解释为什么它不适合项目，如果有必要的话你可以给出相关的文档链接。



为开源做贡献对一些人来说很简单，但对另外一些人可能就不是这样了。有很多人因为没有做正确的事而害怕叫喊，或者只是不适合。。。。通过允许贡献者参与一些对技术要求比底的工作文档，  ，，可以极大的减少你对这些情况的关注。
—  “       ”

多数开源贡献者是“临时贡献者”，因为他们只是偶尔参与项目贡献。一位临时贡献者可能没有充足的时间全程跟踪你的项目，所以你们的工作是能让他们很容易地参与贡献。
鼓励其他的贡献者也是对你们项目的一种投资。当你们授权大量的粉丝做他们感兴趣的工作时，你们的压力就少了很多。
记录一切

你是否参加过一个技术活动，你不认识在场的人，但是似乎每个人站在一个小组里像老朋友一样聊天？。。。现在想象下你想为一个开源项目做贡献，但是你不知道为什么或者这个是如何发生的。
—  “  ”

当你开始一个新项目，你会觉得保持工作的私有性是正常的。但是开源项目发开始于你在公共平台记录自己的工作进程。
当你门把事情记录下来，会有更多的人能够按照你们的方式参与每一步。你可能会得到意想不到的帮助。
书写东西不仅仅只是技术文档。任何时刻，你们有写一些东西或者私自讨论项目的冲动，请询问自己是否能将之公开。
保持项目透明的项目路线：你们期待什么类型的贡献者，如何审查贡献，或者你们为什么做某些决定。
如果你们注意到有多个用户遇到过同样的问题，那么你们应该将答案记录在中。
对于经常遇到的问题，你们可以考虑发布你们的笔记或者相关的。在这种情况下得到的反馈将会令你们惊讶。
记录一切也适用于你们的工作。如果你正在进行大量的更新工作，请将其放入 并标记为正在进行。这样，可以让其他人感觉参与过早期工作。
积极回应
一旦你推广项目，人们将会给你们反馈。他们可能会问项目是如何工作的，或者需要你们帮助开始项目。
当有人列出一条，提交一个 ，或者询问项目的有关问题时，你们应该尽量回答他们。当你们快速地做出回应时，人们将感觉到他们参与了对话，以及他们将会更热情地参与。
如果你无法及时审查请求，请尽早确认，这样会有助于提高参与度。这里是在上如何回应一个 ：

一份研究发现 如果贡献者在小时内收到代码审查，他们会有很大的可能返回以及重复贡献。
与你们项目有关的话题也可能发生在互联网的其它地方，例如 ，，或者。你门可以在像这样的一些网站设置通知，这样当有人提及你们项目时可以收到提醒。
为你们的社区提供一个聚会的场所
有两个理由可以解释为什么要给社区提供一个聚会的场所。
第一个理由是为了他们。帮助人们相互认识。有着共同兴趣的人会想要一个可以聊天的地方。同时当信息是公开的而且是适宜的时候，任何人可以阅读过去的档案以至于能够快速的追赶以及参与。
第二个理由是为了你们。如果你们没有提供一个公共的场所来谈论你们的项目，他们可能会直接与你们联系。刚开始时，回复私有来信可能对你们来说很轻松。但是经过一段时间后，尤其是如果你们的项目变得流行的时候，你们就会感到累了。不要私下和人们谈论你们的项目，而是直接指明他们去指定的公共渠道。
公共交流和指明人们开一条一样简单，而不是直接发给你们发邮件或者在你们的博客发表评论。你们也可以为了方便人们谈论你们的项目设置一个邮件列表，或者创建一个账号，，护着渠道。或者尝试上述的所有方式。
              每隔一周抽出办公时间帮助社区成员：

每隔一周都会留出时间为社区提供帮助和指导。维护者已经同意留出时间专门与新手一起工作，帮助，以及讨论新特性。

公开交流需要特别注意的异常有：安全的和敏感的行为准则。你们应该为大家提供一个私下报告这些的方式。如果你们不想使用自己的个人邮箱，那么就创建一个准用邮箱。
让社区成才
社区非常有能量。这种能量可能是祝福也可能是诅咒，这取决于你们如何执掌它。随着你们项目社区的成长，有办法帮助它成为一股有建设性的力量，而不是具有破坏性的。
不要容忍糟糕的角色
一些流行的项目将不可避免地回吸引来一些伤害它们的人。他们可能从一些没必要的争论开始，对一些细小的功能进行谬论，或者伤害他人。
对于那种类型的人你们必须采取零容忍的政策。如果发现较晚，那些消极的人将会社区中的其他人不舒服。他们可能会离开。

事实是，拥有一个支持性社区是关键。如果没有来自我的同事，互联网上一些友好的陌生人，以及聊天渠道的帮助，我不可能做好这些工作。。。。不要太少。不要找麻烦。
—  “     ”

定期对你们项目琐碎方便的辩论，使他人，包括你们不能把注意力集中于重要的任务上。新人如果看见这样的情景，他们是不会加入你们项目的。
当你们发现社区中有消极行为时，需要公然指出来。特别说明的是，要用坚定的语气解释他们的行为为什么是不可接受的。如果这种问题继续发生，你们有必要要求他们离开。你们的行为准则是为这些情景准备的建设性指南。
知道贡献者在哪里
随着你们项目的成长，好的文档只会变得越加重要。临时贡献者不可能对项目非常熟悉，通过阅读你们的文档他们能很快找到他们需要的。
在你们的文件里，需要明确告诉新来的贡献者该如何开始。你们可能为了想要达到这个目的而准备一个专门的部分。

在你们的列表中，标签需要适合不同类型的贡献者：例如，“  ” “  ” 或者 “” 这些标签能够帮助新人快速浏览以及开始。
最后，使用你们的文档让人们在每一步都感到欢迎。
你们永远不会与登陆项目的大多数人互动。你们可能没有收到一些贡献，因为有些人感到害怕或者不知从和开始。即使是几个字也能阻止一些人沮丧地离开你们的项目。
例如，这里是如何开始它的贡献指南：

我们想感谢你们使用。这个项目是一个充满爱的劳动，我们希望所有用户查找，取得性能上的提升，以及帮助完善文档。每一个贡献都是有意义的，所以感谢你们的参与。话虽如此，但我们还是要求你们遵守一些指南，这样我们就能够找到你们的。

分享你们项目的所有权

你们的领导者们将有不同的观点，因为这是所有健康社区都该做的！然而，你们会体会到粗暴鲁莽的做法不能得到大家的认同，反而谦虚低调的做法更容易让大家接受。
—  “    ”

当大家觉得拥有项目的所有权时，他们会乐意为项目做贡献。这并不意味着你们需要转变项目的愿景或接受你们不想要的贡献。但是你们越信任他们，他们就会越忠诚。
看你们是否能尽快地找出向社区分享所有权的方法。下面有些建议：

反对你们自己修复简单非关键的。 相反，使用它们作为招募新贡献者的机会，或者指导想要参与贡献的人。开始时可能效果不是很理想，但经过一段时间你们会得到想要的结果。例如，要求一位贡献者提交一个 在一个 的下面，而不是自己修复它。



在项目中添加一个贡献者或者作者文件用于记录每一个参与贡献的人。

如果你们的社区有了一定的规模，那么发送一封信或者发表一篇博客感谢贡献者们。的   和的是两个非常好的示例。

给每个贡献者的通道。发现这样会使大家越发乐意斟酌他们的补丁，以及他甚至发现了他在一段时间没有工作的项目的新维护者。

如果你们的项目在上，那么将项目从你们的个人账号转移到一个组织，以及添加至少一个备份管理员。组织能让与其他人一起工作于同一个项目变得更加容易。


事实上很多项目只有一个或者两个做大量工作的维护者。随着你们的项目以及社区越来越大会更加容易得到帮助。
当你们不能总是发现一些人去回答问题时，你们可以释放一个信号增加其他人能接触到的机会。如果你们能尽早地开始，大家就能尽快地帮助。

你们最大的兴趣是招募喜欢你们项目以及能够做你们不能做的事的贡献者。你喜欢编码，但不喜欢回答？那么让社区中能做这件事的人去做。
—  “ ”

解决冲突
在你们项目的早期，做主要的决定是件容易的事。你们想做什么就可以做什么。
随着你们的项目越加流行，会有更多的人对你们的决定有兴趣。即使你们的社区没有大量的贡献者，如果你们的项目有很多用户，你们会发现大家的重点在决策上或者增加他们的。
在大多数情况下，如果你们培养了一个友好，尊重的社区并公开记录你的过程，你们的社区应该能够找到解决方案。但有时候你们遇到一个，有点难以解决。
建立友好的氛围
当你们的社区正在讨论一个很难的  时，气氛会很激烈。人们可能会变得愤怒或者沮丧，以及发泄在其他人或者你们身上。
作为一名维护者你们的工作是不要让这种情况出现。即使你们对话题有很强烈的观点，也要尽量站在一个主持者或者推动者的位置，而不是参与争吵以及推动自己的观点。如果有人不友好或者垄断话题，那么立即采取行动以保持有礼貌以及丰富的讨论。

作为一名维护者，尊重你们的贡献者非常重要。他们经常处理一些你们描述亲切的事情。
—  “      ”

一些人希望你们指导他们。编写一个好的示例。你们仍然可以表达失望，不高兴或者忧虑，但得心平气和。
保持你们的酷并不容易，但是展示领导能力能促进健康的社区。互联网感谢你们。
将你们的  视为宪法
你们的  不仅仅是一组指令。它也是一个谈论你们目标，产品愿景和路线的地方。如果人们过分专注于辩论特定功能的优点，它可能有助于重新审视您的，并谈论你们的项目的更高的愿景。关注你们的也会使对话变得个人化，所以你们可以进行建设性的讨论。
专注过程，而不是结果
一些项目用投票的方式做重要决定。虽然看上去是明智的，投票强调的是得到一个“答案”，而不是倾听以及解决每个人的顾虑。
投票会变成政治，社区成员在做感兴趣的事或者表决一个明确的方法时会感到压力。不是每个人都参与了投票，可能在你们的社区中保持沉默的人占了多数，或者用户不知道投票这件事正在发生。
有时候，投票是必要的手段。尽你们所能强调“寻求共识”而不是共识。
在寻求共识的过程中，社区成员讨论主要问题，直到他们感到他们已经得到充分的意见。当仅遗留下一些无关紧要的问题时，社区需要向前迈进。“寻求共识”不能确保社区能得到一个完美的答案。而是侧重聆听和讨论。

 不存在投票系统的部分原因是因为团队在所有情况下都不会遵循投票系统。有时我们必须选择我们认为是对的事，即使它不流行。。。。我能通过社区的反馈知道我能够提供什么以及做什么样的工作。
—   ’  

即使你们不确定是否采用寻求共识的方式，作为维护者，让大家知道你们正在关注他们。让其他人知道，以及承诺解决他们的问题，这在很大程度上减少了敏感情况的发送。然后，按你说的去做。
不要为了获得决议而急于做出决定。在做一个决议之前请确保每个人已经知道以及所有的信息以及公开。
将对话的重点聚焦于行动
讨论很重要，但是富有成效和没有效果的对话时有区别的。
鼓励讨论，只要它正积极地朝着解决问题的方向进行着。如果对话已经无法再进行下去，只有很少的人在参与或者大家正在讨论无关紧要的问题，这时候就该结束对话了。
允许这些对话进行下去不仅对解决问题没有帮助，而且不利于社区的健康发展。它释放了这样一个信号，表示允许或甚至鼓励这种类型的对话，它可能阻止人们提高或者解决未来的问题。
当你们或者其他人每提出一个观点时，请自问：“这如何使我们更接近一个决议？”
如果对话开始有解散的征兆，问团队：“我们下一步该做什么”才能重新对话。
如果一个对话没有清晰的方向，没有明确的措施可以采取，或者合适的措施已经被使用，那么关掉并解释为什么关掉它。

指导一件事朝着正确的方向发展是一门艺术。它对阻止人们浪费时间或者要求他们发表有建设性的看法没有作用。。。。反而，你们必须为接下来的进展给出条件：给大家一个路线，跟随一个可以得到你们想要的结果的途径，这样就不像是些无用的口头行为。
—   

挑战你们的智慧
上下文很重要。考虑谁参与讨论，以及他们如何代表社区的其他人。
社区中的每个人都为这个问题而烦恼，或者参与讨论了吗？或者只是一部分人感到困惑吗？不要仅关心活跃的声音，也请不要忘记考虑社区中保持沉默的人。
如果这个问题不代表社区的更广泛的需求，你们可能要承认只是少数人的担心。如果这是一个反复出现的，没有一个清晰的解决方案，那么指向他们以前讨论的话题。
找出社区中的决策者
通过一个态度端正和目标清晰的对话，很多困难都是可以解决的。即使在富有成效的对话中，对于如何进行的意见也可能存在差异。在这些情况下，确定一个人或一组人，可以作为决策者。
决策者可以是项目的主要维护者，或者是大家投票选出的一个小团体。理想情况下，在你们使用文件之前，你们已经确定了决胜者和与之相关的事宜。
使用决策者应该是你们最后才能采取的手段。分离是一个你们社区成长和学习的机会。利用这些机会以及协同合作，尽量找出解决方案。
社区是开源的 
健康，蓬勃的社区每周都会为开源付出大量辛勤的劳动。许多贡献者指出其他人在开源工作或不在开源工作的原因。通过学习如何建设性地利用这个权力，你们会帮助他人有一个难忘的开源体验。日前据悉，具有年历史的美国新闻出版机构《纽约时报》为了使其数字化基础设施实现现代化，计划将其业务从三个数据中心迁出，转向公有云。
《纽约时报》希望其业务在云计算服务，托管数据中心，自己的内部设施使用，并计划简化和升级其后端业务，以更多地依赖于云端和边缘设备中的缓存内容。

通过的核心
纽约证券交易所首席技术官 在接受记者采访时证实，《纽约时报》将放弃在纽瓦克，波士顿和西雅图的数据中心，但将在时代广场的“纽约时报”大楼内保留其内部数据中心。
其业务通过进行编排，数据库相关应用程序将部署在云平台上，而其余的应用程序将主要在谷歌云平台的容器中运行。
《纽约时报》的电子报刊采用了服务商公司运营的内容传送网络，它将在主要城市附近的边缘数据中心驱动器上缓存内容。该公司于年月与谷歌云平台合作，提供折扣价格。

表示，的成本是“无关紧要的”，而转向谷歌云平台的成本预计将降低成本。
对于其用于移动推送通知的主要，每分钟发送万个通知，在发生突发新闻时，纽约时报每月为提供的服务支付，美元的费用，而传统运营成本约是现有成本的倍。通过采用谷歌云平台和公司的服务，该公司预计每月花费约美元。
尽管主流媒体似乎陷入了收入螺旋下降的时代，《纽约时报》电子版的流量和订阅数字仍在增加。而唐纳德？特朗普总统的选举导致数字订阅上升了十倍。
在选举之夜的预期之后，由于特朗普掌握了头条新闻的能力，其流量仍然保持高位。尽管今年月宣布全面消减成本和裁员，纽约时报日前计划对其数字媒体再投资万美元。

美国总统选举时的数据流量变化
时代在改变
而主要云计算提供商转移到并不是唯一的合作伙伴关系，在传播出版物和互联网巨头之间。
公司在今年早些时候透露，正在测试由谷歌公司的母公司公司的另一家子公司开发的用于内容审核的工具。
来自以前称为 的“”旨在使用人工智能来发现被认为是负面的评论，以便将其删除。
纽约时报还有另一个主要的合作伙伴，纽约时报周日印刷版的用户在年收到了免费的 虚拟现实耳机。
在公司的其他方面，副科技编辑 在去年月份就谷歌数据中心对当地社区的积极影响撰写了文章，并于今年月加盟谷歌公司，成为了 的编辑负责人。
：机房入门
本篇会通过介绍一个简单的项目，走一遍抓取流程，通过这个过程，可以对对基本用法和原理有大体的了解，作为入门。
在本篇开始之前，假设已经安装成功了，如果尚未安装，请参照上一节安装课程。
本节要完成的任务有：

创建一个项目

创建一个来抓取站点和处理数据

通过命令行将抓取的内容导出


创建项目
在抓取之前，你必须要先创建一个项目，可以直接用命令生成，命令如下：
  
在任意文件夹运行都可以，如果提示权限问题，可以加运行。这个命令将会创建一个名字为的文件夹，文件夹结构如下：
|____      部署时的配置文件
|____          项目的模块，引入的时候需要从这里引入
| |________    
| |________
| |____      的定义，定义爬取的数据结构
| |____    的定义，定义爬取时的中间件
| |____        的定义，定义数据管道
| |____        配置文件
| |____          放置的文件夹
| | |________
| | |________
创建
是由你来定义的，用它来从网页里抓取内容，并将抓取的结果解析。不过这个必须要继承提供的类，并且你还要定义的名称和起始请求以及怎样处理爬取后的结果的方法。
创建一个也可以用命令生成，比如要生成这个，可以执行命令。
 
  
首先进入到刚才创建的文件夹，然后执行这个命令，第一个参数是的名称，第二个参数是网站域名。执行完毕之后，你会发现在文件夹中多了一个，这就是你刚刚创建的，内容如下：
    
 

 
     = 
    _ = 
    _ = 

      
        

可以看到有三个属性，，_，_，另外还有一个方法

，每个项目里名字是唯一的，用来区分不同的。

_允许爬取的域名，如果初始或后续的请求链接不是这个域名下的，就会被过滤掉。

_，包含了在启动时爬取的列表，初始请求是由它来定义的。

，是的一个方法，默认情况下，被调用时_里面的链接构成的请求完成下载后，返回的就会作为唯一的参数传递给这个函数，该方法负责解析返回的，提取数据或者进一步生成要处理的请求。


创建
是保存爬取数据的容器，它的使用方法和字典类似，虽然你可以用字典来表示，不过相比字典多了额外的保护机制，可以避免拼写错误或者为定义字段错误。
创建需要继承类，并且定义类型为的类属性来定义一个。观察目标网站，我们可以获取到到内容有  
所以可以定义如下的，修改如下：
 

 

     = 
     = 
     = 

定义了三个，接下来爬取时我们会使用它。
解析
在上文中说明了方法的参数是_里面的链接爬取后的结果。所以在方法中，我们可以直接对包含的内容进行解析，比如看看请求结果的网页源代码，或者进一步分析源代码里面包含什么，或者找出结果中的链接进一步得到下一个请求。
观察网站，我们可以看到网页中既有我们想要的结果，又有下一页的链接，所以两部分我们都要进行处理。
首先看一下网页结构，每一页都有多个为的区块，每个区块内都包含，，，所以第一部需要找出所有的，然后对每一个进一步提取其中的内容。

提取的方式可以选用选择器或选择器，在这里我们使用选择器进行选择，方法改写如下：
  
     = 
       
         = _
         = _
         =  

在这里使用了选择器的语法，首先利用选择器选取所有的赋值为变量。然后利用循环对每个遍历，解析每个的内容。
对来说，观察到它的为，所以可以用来选取，这个结果实际上是整个带有标签的元素，要获取它的内容，可以加来得到。这时的结果是大小为的数组，所以还需要用_方法来获取第一个元素，而对于来说，由于我们要获取所有的标签，所以用方法获取即可。
以第一个的结果为例，各个选择方法及结果归类如下：

源码

 = = =
         = =“                    ”
          = = 
         =
        
         =
            
             = = = 
             = =
             = =
             = =
             = =
        
    




 =          = = =“ 



 =          =“         



 = =“                    ”



“                    ”

_

“                    ”
所以，对于，要获取第一个元素即可，所以使用_方法，对于，要获取所有元素，使用方法。
使用
刚才定义了，接下来就要轮到使用它了，你可以把它理解为一个字典，不过在声明的时候需要实例化。然后依次对刚才解析的结果赋值，返回即可。
接下来改写如下：
 
   

 
     = 
    _ = 
    _ = 

      
         = 
           
             = 
             = _
             = _
             =  
             

如此一来，首页的所有内容就解析出来了，并赋值成了一个个。
后续
如上的操作实现了从初始页面抓取内容，不过下一页的内容怎样继续抓取？这就需要我们从该页面中找到信息来生成下一个请求，然后下一个请求的页面里找到信息再构造下一个请求，这样循环往复迭代，从而实现整站的爬取。

观察到刚才的页面拉到最下方，有一个按钮，查看一下源代码，可以发现它的链接是，实际上全链接就是，通过这个链接我们就可以构造下一个请求。
构造请求时需要用到，在这里我们传递两个参数，和。

，请求链接

，回调函数，当这个请求完成之后，获取到，会将作为参数传递给这个回调函数，回调函数进行解析或生成下一个请求，如上文的方法。


在这里，由于就是用来解析，，的方法，而下一页的结构和刚才已经解析的页面结构是一样的，所以我们还可以再次使用方法来做页面解析。
好，接下来我们要做的就是利用选择器得到下一页链接并生成请求，在方法后追加下面的代码。
 =   _
 = 
 = =

第一句代码是通过选择器获取下一个页面的链接，需要获取超链接中的属性，在这里用到了操作，通过加属性名称我们可以获取属性的值。然后再调用_方法获取内容。
第二句是调用了方法，它可以将相对构造成一个绝对的，例如获取到的下一页的地址是，通过方法处理后得到的结果就是
第三句是通过和构造了一个新的请求，回调函数依然使用的方法。这样在完成这个请求后，会重新经过方法处理，处理之后，得到第二页的解析结果，然后生成第二页的下一页，也就是第三页的请求。这样就进入了一个循环，直到最后一页。
通过几行代码，我们就轻松地实现了一个抓取循环，将每个页面的结果抓取下来了。
现在改写之后整个类是这样的：
 
   

 
     = 
    _ = 
    _ = 

      
         = 
           
             = 
             = _
             = _
             =  
             

         =   _
         = 
         = =

接下来让我们试着运行一下看看结果，进入目录，运行如下命令：
  
就可以看到的运行结果了。
        
      {_  _  _  _ }
     

 
 
      

 
 
 
 
 
 
 
 
 
 
      

 
 
 
 
      

     
               
        
         
         
       
{  
     
  \                    \}
       
{  
   
  \               \}

      
      
{_ 
 _ 
 __ 
 _ 
 _ 
 __ 
 __ 
  
 _ 
 _       
 __ 
 _ 
 _ 
 __ 
 __ 
  
  
  
  
 _       }
      
在这里贴出部分运行结果，中间的一些抓取结果输出已省略。
首先输出了当前的版本号，启动的项目。其次输出了当前在中的一些重写后的配置。然后输出了当前所应用的和，是默认启用的，如果要修改，我们可以在中修改，默认是空，同样也可以在中配置，后面会进行讲解。
再接下来就是输出各个页面的抓取结果了，可以看到它一边解析，一边翻页，直至将所有内容抓取完毕，然后终止。
在最后输出了整个抓取过程的统计信息，如请求的字节数，请求次数，响应次数，完成原因等等。
这样整个程序就成功运行完毕了。
可以发现我们通过非常简单的一些代码就完成了一个网站内容的爬取，相比之前自己一点点写程序是不是简洁太多了？
保存到文件
刚才运行完后，我们只在控制台看到了输出结果，如果想将结果保存该怎么办呢？
比如最简单的形式，将结果保存成文件。
要完成这个其实不需要你写任何额外的代码，提供了 可以轻松地将抓取结果输出，例如我们想将上面的结果保存成文件，可以执行如下命令：
    
运行后发现项目内就会多了一个文件，里面包含的就是刚才抓取的所有内容，是一个格式，多个项目由中括号包围，是一个合法的格式。
另外你还可以每一个一个，最后的结果没有中括号包围，一行对应一个，命令如下：
    
或 
    
另外还支持很多格式输出，例如，，，等等，还支持，等远程输出，另外还可以通过自定义来实现其他的输出。
例如如下命令分别对应输出为，，，，格式以及远程输出：
    
    
    
    
    
其中输出需要你正确配置好你的用户名，密码，地址，输出路径，否则会报错。
通过提供的 我们可以轻松地输出抓取结果到文件，对于一些小型项目这应该是足够了，不过如果想要更复杂的输出，如输出到数据库等等，你可以使用 更方便地实现。
使用 
至此，你已经可以成功地完成抓取并将结果保存了，如果你想进行更复杂的操作，如将结果保存到数据库，如，或者筛选某些有用的，可以定义 来实现。
 意为项目管道，当生成后，它会自动被送到 进行处理，我们常用它来做如下操作：

清理数据

验证爬取数据，检查爬取字段

查重并丢弃重复内容

将爬取结果储存到数据库


要实现一个 很简单，只需要定义一个类并实现_方法即可，启用后， 会自动调用这个方法，这个方法必须返回包含数据的字典或是对象，或者抛出异常。
这个方法由两个参数，一个是，每次生成的都会作为参数传递过来，另一个是，就是的实例。
好，接下来我们实现一个 ，筛掉长度大于的并将结果保存到。
修改项目里的文件，之前自动生成的可以删掉，增加一个类，内容如下：
   

 
     ____
         = 

     _  
         
               
                 =   
             
        
              

在构造方法里面定义了限制长度，长度限制为，然后实现了_方法，参数是和，首先判断的属性是否存在，如果不存在，那就跑出异常，如果存在，再判断长度是否大于，如果大于，那就截断然后拼接省略号，再将返回即可。
接下来，我们再将处理后的存入，如果你还没有安装，请先安装好。
另外还需要安装一个开发包，利用安装即可：
  
接下来定义另外一个，同样在中，实现另一个类，内容如下：
 

 
     ____ _ _
        _ = _
        _ = _

    
     _ 
         
            _=_
            _=_
        

     _ 
         = _
         = _

     _  
         = ________
        
         

     _ 
        

在这个类中，实现了定义的另外几个方法。

_，这是一个类方法，用标识，是一种依赖注入的方式，方法的参数就是，通过这个我们可以拿到全局配置的每个配置信息，在全局配置中我们可以定义_和_来指定连接需要的地址和数据库名称，拿到配置信息之后返回类对象即可。所以这个方法的定义主要是用来获取中的配置的。

_，当被开启时，这个方法被调用。在这里主要进行了一些初始化操作。

_，当被关闭时，这个方法会调用，在这里将数据库连接关闭。


那么最主要的_方法则执行了数据插入操作。
好，定义好这两个类后，我们需要在中使用他们，还需要定义的连接信息。
在中加入如下内容：
_ = {
    
    
}
_=
_=

赋值_字典，键名是的类名称，键值是调用优先级，数字越小越先被调用。
定义好了之后，再重新执行爬取，命令如下：
  
爬取结束后，可以观察到中创建了一个的数据库，的表。
到现在，我们就通过抓取完成了整个的简单入门，但这只是冰山一角，还有很多内容等待我们去探索，后面会进行讲解。
源代码
本节代码：

相关推荐
腾讯云主机环境安装爬虫框架过程及常见错误利用爬取所有知乎用户详细信息并存至作者：

序言
不同项目下里的往往是差异化最多的，用起来和自己的习惯相比经常是缺胳膊少腿，因此聊聊标准的的啥样的。
不同的  差异基本表现如下：

构造对象       {} 
是否有    等方法
是否有方法
是否有  
  结果链式的处理

有哪些标准




兼容扩展而来，里的准守规范，也是当今的标准规范。
标准的 
构造 

   {}

静态方法 






对象方法

  


方法参数可以直接返回数据实现链式，可以返回反转结果链式
不标准的使用

构造对象    请使用   {} 
   方法的使用  请使用 
   方法的使用 

第三方库的支持

  支持标准 规范
  支持标准规范，增加了等方法
  支持标准规范，增加了更多的工具方法，人气不如 
   都没完整准守，存在  等各种方法，的链式处理弱爆了


原文链接：


相关推荐通过  在  中调用动态链接库文件 简介由于腾讯云上提供了系统，所以我们这次编程选用腾讯云主机实验。
在上篇我给大家讲述了腾讯云上网络编程的目标
接下来我以为例为大家讲解环境配置，其实，等等的版本都是通用哒。
我的腾讯云主机预装了 ，截图如下：

下载

我们选择首先你要下载文件并安装，直接双击运行安装即可。
然后你需要下载开发包，首先必须注意的是，目前最新版本是没有开发包的，最新的开发包为，先见下图

下面的红色框说明了目前没有提供的开发包，最新版本的开发包是，他可以与的配套使用。
所以下载的开发包。
下载地址
然后把它放置到某个目录下
配置
首先你要有一个…这不是废话么…这里就不多说了
配置好和下载好相关的后，接下来我们就要进行的配置了。
好，文件新建项目控制台应用程序，可以修改下面的路径和项目名称，然后确定

接下来就会蹦出一个窗口点击下一步

下一步，勾选空项目，然后点击确定，空项目一定要勾选，不然会生成一些不必要的文件。

点击完成，现在看到的界面如下：

在项目名上右键单击，选择属性
链接器选项卡–输入–附加依赖项中在前面输入_ 两个类库，截图如下

选项卡—预处理器—预处理器定义键入_ 如图所示

目录，加入你的类库路径，文件夹应该叫，一个是一个是这是绝对路径，你的可能与我的不一样，截图如下

好了。点击确定，环境就配好啦。
接下来新建一个文件，运行程序就了…

如有问题，欢迎留言交流

相关推荐
腾讯云上网络编程一之前言、目标腾讯云上网络编程三之协议获得地址表腾讯云上网络编程四之主机通信作者：张浩 

在分布式大行其道的今天，我们在系统内部、平台之间广泛运用消息中间件进行数据交换及解耦。是腾讯云内部自研基于的高可靠、强一致、可扩展分布式消息队列，在腾讯内部包括微信手机业务红包、腾讯话费充值、广告订单等都有广泛使用。目前已上线腾讯云对外开放，本文对腾讯云 核心技术原理进行分享介绍。
消息队列主要适用于金融、交易、订单等对可靠性、可用性有较高要求的业务场景。
以腾讯充值系统为例，该充值系统通过 对交易模块、发货部分、结算系统进行异步解耦、削峰填谷，一方面大大降低了模块间耦合度，另一方面减轻了大量突发请求对后端系统的冲击。在月初充值该系统一天经过转发的消息超过十亿条，每秒峰值超过，最高时有数亿条消息通过的堆积能力缓冲了对后端消费模块的压力。架构如图：

图某充值系统结构
图中腾讯云消息队列整体结构如图所示，本文重点介绍后端 实现原理。通常情况下一个由个节点组成，通过多副本保证消息的可靠性、多节点提高系统可用性。当然，可以根据业务的实际需求通过增加内节点个数来进一步提高可靠性和可用性，

图整体架构图
  模块内部结构如图所示。

图 内部结构图
下面分别中数据高可靠、强一致，系统可用性，可扩展、消息全路径追踪方面分别介绍。
在可靠性保证方面主要包括以下三方面：生产可靠、存储堆积可靠、消费可靠：
生产可靠
如图所示，客户端生产的消息在 中超过半数的 刷盘成功后会返回确认消息告知生产消息成功。如果在一定时间之内客户端没有收到确认信息需要重试来确保消息发送成功。
可靠生产带来的一个问题就是消息的重复，在网络异常等情况下很可能 已经存储消息成功只是确认包在网络上丢失了，这样客户端重试生产后，在上存在两条重复的消息。考虑到消息去重开销较大，目前消息的幂等性需要业务逻辑来保证。
存储可靠
 中一个节点为 其他节点为， 负责所有消息的生产消费。当生产消息到达 节点后，通过 一致性模块将请求顺序写  并同步刷盘，同时将构造好的  按顺序通过网络发送到其他节点，节点同步刷盘并返回成功。当 收到过半数的节点同步成功信息后将此条请求提交到 处理状态机，由 状态机将请求应用到相应。大致逻辑图所示。

图数据存储原理示意图
由此可见，对于返回客户端成功的消息至少是分别在两个节点磁盘上存储成功的，这就将磁盘故障引起的数据丢失大大降低。另外数据在磁盘上存储时会将检验结果一同记下来，消费者在消费数据之前  会进行比较，确保消息是完整有效的。
消费可靠
消费者拉取消息时会指定当前消息的隐藏时间，在隐藏时间内消费者比较显式的对消息进行确认删除，如果超过隐藏时间没有主动删除，此条消息将重新对外可见，可以继续消费。
显式确认删除消息是为了防止消息在投递、处理过程中异常而导致的消息丢失。
对于消息的确认信息  的处理逻辑和生产消息过程类似，也是一个写入的过程，不同的是此时写入的数据的内容是 和消息状态。
强一致实现
假如一个中有个节点  为，   是。如上图所示，对于返回客户端成功的请求数据在 中至少在两个节点上存在假设为 ，此时如果 故障，  两个 会自动选举出一个新， 使用的 算法可以保证这个 一定是拥有最全量 信息中的一个，在此必定是。此时继续对外服务， 和 拥有相同的已经返回确认给用户的全量数据视图，数据是强一致的。
对于 和   所在的网络发生分区的情况如图，由于 得不到 中过半节点的回复所以不能处理请求， 在选举超时后会选举出一个新的 ，的接入层会自动进行切换。 算法保证新 同样具有完成的数据视图。

可用性保证
如上文所述， 负责所有消息的生产消费，当 故障时中其他节点会自动选举出一个新，客户端请求会自动重定向到节点，和配置的选举超时时间有关，目前是在左右。大致过程如上图所示。 
单个 在理论中优先保证了，当中过半数节点都正常工作时，才能进行消息的生产消费。对于多个节点同时故障的不可用情况，强大的监控调度能力能够快速对进行调度迁移恢复服务，将不可用时间降到最低。
横向扩展，无限堆积

上文中的概念对用户来说是透明无感知的，   根据的负载情况实时对进行调度搬迁。如果某个的请求量超过当前的服务阈值，  可以将 路由分布到多个 上来提高并发量，对于需要海量堆积的服务来说可以通过路由调度来提升堆积上限，理论上可以达到无限堆积。
目前只能保证特定情况下消息的严格有序，例如需要保证单个生产进程、单个消费进程，或者的消费窗口设定为等条件。
全路径消息
系统中，一条消息的完整路径包含生产者、、消费者三个角色，每个角色处理消息的过程中都会在 路径中增加相关的信息，将这些信息汇聚即可获取任意一条消息的状态和当前经过的完整路径，从而为生产环境中的问题排查提供强有力的数据支持。大大降低了业务定位问题的难度。
小结
是基于 算法来保证数据高可靠、强一致的分布式消息队列，主要服务于订单、交易类业务场景。消息的幂等性需业务侧来保证，在特定情况下可以保证消息严格有序。
对于更侧重高性能、高吞吐量业务需求，腾讯云由另外一个消息引擎来提供服务，在协议上同时兼容，很好的满足了大数据场景，具体原理请留意后续文章介绍。

相关推荐 腾讯云消息队列测试产品构架月日，“云未来”峰会在深圳召开。在数字经济高速发展，人工智能一日千里的时代，云计算为社会和经济带来的量变与质变究竟是什么？腾讯董事会主席兼首席执行官马化腾在会上表示，云已经成为产业革新的源动力、新型社会管理的主平台、人工智能的强载体。

图 ：腾讯董事会主席兼首席执行官马化腾
继去年提出“云是互联网的第一要素”、“未来是传统企业在云端用人工智能处理大数据”，马化腾今年着重提出，“云是数字经济最重要的基础设施”。过去“插上电”带来了电气化的革命，现在“接入云”将带来数字化的升级。在月底的贵阳数博会上，马化腾就强调了云在数字经济中的作用，并且指出“用云量”将成为一个重要的经济指标，能够衡量一个行业的数字经济发展程度。
马化腾引用报告指出，企业向云端迁移的速度在加快，未来很可能超过传统数据中心。但是，云还处于初始阶段，电力时代最终出现了计算机，而人工智能有望成为云时代像计算机一样的关键产物。“云人工智能”也许将相当于“电计算机”的概念，企业 “接入云”能够获得这种信息能源。
在本次大会上，腾讯云发布了年战略级新品——智能云，开放腾讯在计算机视觉、智能语音识别、自然语言处理的三大核心能力。这是腾讯云首度公布其战略路线，智能云将在传统云计算的结构上，建立起新的服务层“即服务”。
此外，马化腾还分享道，不管是新兴行业还是传统产业都蕴藏着巨大的商业机会，同时也有巨大的挑战。腾讯将会继续提升、丰富，以及开放云的能力和资源，支持各行各业创新、优化、升级，共建云上生态。马化腾强调：“在新的云时代，整个社会经济操作系统和运作模式都在发生数字化的迭代。”
以下是马化腾演讲全文：
尊敬的袁副省长，陈副市长，张教授， 教授，各位嘉宾、合作伙伴和媒体朋友们，大家上午好！
非常感谢大家来参加腾讯第三届“云未来”峰会，刚才袁宝成副省长给我们展示了他的独特风格——就是在一次演讲中展现两种画风的演讲，既能腾云驾雾，又能拨云见日。让我们感觉到了省委省政府的关怀。
刚才他在演讲中也提到，端午节时他问我人工智能到底有没有那么可怕？我想在云还没有发展得非常成熟的时候，人工智能可能还有很长一段路需要走，甚至未来包括量子计算、量子通信等技术发展成熟之后，才会对人工智能的发展有更大的促进。所以我觉得人工智能还是可知可管可控的。
过去几年云的市场发生了很多的变化，越来越多的企业开始关注这个市场，整个云的市场成长越来越快，我们自己对云这个产业的认识也越来越深。我们观察到企业向云端迁移的速度在加快。最近互联网女皇 的研究报告提到，全球传统数据中心的份额在下跌，更多的份额转向云形态的数据中心。去年这个份额接近五五开，我们相信今年或明年，云的比例会超越传统的数据中心。
去年的峰会我提到，云是互联网基础设施的第一要素。今天我也想说，云是数字经济的一个最重要的基础设施。在上个月，贵州召开的数博会上，我们提出了一个概念叫做“用云量”。大家知道我们过去通常用“用电量”来评估一个城市、一个国家当地的经济发展水平。我们相信未来“用云量”将是另外一个非常重要的反映数字经济发展的指标。我们用电能来对比云。电带来了上一轮的产业革命，我们认为新一代信息能源将会带来新一轮的产业革命。
下面我想对未来云时代的三个趋势跟大家分享，我们团队对这三个趋势应该用什么样的表述，做了大量的工作、仔细的斟酌，我提出来跟大家分享，抛砖引玉。
第一个趋势是，云是产业革新的源动力。这个听起来好像很大，很多人不相信，我可以打个比方：过去在电力时代，不管是在家庭还是在企业，大家有一个概念就是“插上电”。插上电之后就带来了电气化的革命；现在我们谈“接入云”，我觉得接入云之后，会带来数字化的升级，所以从这两个概念可以比较，其实是非常有道理的。
我们再比较一下，有了电之后才会有什么？涌现了大量的发明，电灯、电报、电车……各种各样的电器，也包括生产工具，全部跟电有关，后来又诞生了计算机。那么云出现了之后会跟着发明什么？我们看到的是一些互联网形态，比如说、微信、网络购物、搜索引擎。我们也看到云已经跟很多产业、行业结合了。比如说跟餐饮结合，我们看到有美团、点评、；又比如云跟汽车的结合，有滴滴；跟自行车结合，有摩拜等等。但是我们感觉，这还只是云的初始阶段，就好像在电力时代还没有出现计算机一样。在云未来的时代，出现像计算机的时候应该是什么呢？我推测也许就是人工智能。云人工智能也许就相当于是电计算机。
我们也可以举很多行业的案例。现在在各行业里面有很多用云的趋势，比如我们在座的合作伙伴中外运、顺丰等等，他们是传统的物流行业，现在也开始向数字化转型。他们通过接入云，带来了流程再造。最近通过我们的云提供的图像识别技术提升他们的工作效率：大家知道货运单上有很多手写的地址信息，现在用摄像头扫描之后，后台用人工智能图象分析之后转成文字，不管你写得多潦草，我们都可以比人眼识别更准确，并且把这些数据变成结构化信息之后进入云端，然后进行实时的管理。
还有一个案例是电子发票，我在两年前拜访国税总局王局长，我当时跟他说我很想做电子发票。这个想法来自于微信红包：我们觉得红包的实体都可以瞬间电子化，在微信里面迅速的流转，为什么我们用了几十年的发票不能更加智能化呢？从计算机、信息的角度来说，这个并不是很难，所以我们一直在推动。最近我们希望推动联通、金蝶、用友等合作伙伴，以及酒店前端的终端机等场景，来推动电子发票的发展。以后相信大家报销就会非常方便，拿出微信一扫，把你的发票抬头信息直接传过去，立刻就可以拿到一个云端存储的、不可伪造的、在国税总局数据库里有的一份电子发票。单位里的财务系统自动报销，钱立刻打回你的帐上，你不用每次出差拿着一堆发票去贴。这也是一个很好的使用云的案例。
第二个趋势是，云是新型社会管理的主平台。大家知道政府的公共部门现在非常积极地拥抱新技术，包括交通、安全、社区等等，都越来越依靠云这种新型的基础设施。基于云的数字化升级，能够实现高效、精细的新型社会管理。其实在安全、交通管理等方面，我们面临着很大的机遇，但是也有很大的挑战，比如说电信诈骗、网络犯罪、很多黑产等，他们对技术也很敏感，如果我们不了解云，不用云这个武器来对抗这些黑产，是根本抵挡不了这些犯罪分子的。所以我们说，只要把握了互联网信息、云技术和规律，未来这个高度互联的世界其实是可知、可管、可控的。重要的是我们要积极地拥抱这个新技术。
在这方面我们有几个案例。第一个案例是智慧建筑，我们这次在贵州数博会上输出新的腾讯办公大楼的智慧建筑方案，比如把很多摄像头、传感器通过云端的连接，能够建成大数据平台，实现安防、照明，甚至像海绵城市等等的功能。第二个案例是云电子证件，刚才我提到了发票，其实我们现在还可以做到把你的身份证，其它的证件，包括驾照等等，都不需要带实体，直接输入到微信里面，后台云端国家的数据库可以保证它的真实性，这是非常便捷的。第三个案例是我们跟广东交通厅合作的提供地理位置信息的大数据，我们通过指导交通部门进行春运疏堵，合理的调拨资源应对春运人流。第四个案例是云税务，我们在成都国税通过微信小程序，为办税人员进行云端的在线实名认证，缓解了办税的时候排长队的情况。第五个案例是云安全，最近病毒非常肆虐，突然间爆发，我们通过腾讯云快速地发布补丁，以及我们在攻击方面实现了高效率低成本的防御。
第三个趋势是，云是人工智能的强载体。这也是我们今天谈到的主题，我在很多场合提到，传统企业的未来就是在云端用人工智能处理大数据，听起来有点拗口，听起来就像是能用最短一句话把最热的词装在一块，但是实际上它非常有道理。云、大数据、人工智能是不可分割的。云可以提供海量的数据和强大的计算能力的，也是我们目前进行人工智能研究的一个必不可少的最强载体，大家看到外界报道腾讯的围棋人工智能，名叫“绝艺”，取得了很好的成绩，最近在日本的全球大赛中获得了冠军，证明腾讯在人工智能方面有一定的实力。“绝艺”的后台部分全靠腾讯云的支持，如果没有庞大的云计算能力，是不可能实现这种人工智能计算的。
我们还有一些案例。我们团队最近告诉我，在癌症诊断方面，腾讯优图团队和广东的医院合作，用计算机读取患者的图像，辅助医生做早期筛查。我们用大量片子做标注，通过人工智能、机器学习来形成认知，最后再来试验它的输出结果。目前我们初步的一个成绩就是查出肺癌的准确率达到，排除肺癌的准确率达到，超过了普通医生的平均水平。当然我觉得这个成绩还可以再提高。团队告诉我，如果再给他们三个月的时间，这个水平还可以再提升。未来人工智能如果和医疗进行结合，再有更多的医疗数据，可以极大地提升人工智能在医疗的应用。
还有一个案例是人脸识别，我们在微众银行等金融机构，我们用云降低了银行使用人工智能的门槛，我们可以通过云端进行人脸的识别。包括在联通的营业厅，有一个非常受欢迎的产品，是腾讯大王卡，块、块可以包月使用腾讯的所有服务的流量，非常受欢迎，但是它需要利用人脸识别来远程开户，这里面我们积累了大量的经验。很多黑客试图用照片来模拟，欺骗我们的人脸识别系统，我们不断地升级，有效地阻挡了几乎所有的造假。所以可以说我们在人脸识别的商用实战中是最有经验的。
还有一个案例是打击数字营销中的“羊毛党”。大家知道黑色产业链中有一批人，像黄牛党一样，我们把它叫做羊毛党，他掌控大量的不同地址的机器，可以瞬间把一个商家在网上做营销的礼品、补贴，模拟成千千万万的真实用户一下子把它取走，就像薅羊毛一样，我们叫羊毛党。我们的云提供了这个非常独特的抵御能力，如果企业要做数字营销，你们这方面没有经验，一定要用我们的服务。我们现在为东鹏特饮每天提供超过万次的判断，阻挡大量的黑手机刷它的饮料瓶的二维码兑奖，一年可以节省至少万元。
有很多的案例今天没有时间展开。总之我们觉得在新的云时代，整个社会经济操作系统和运作模式都在发生数字化的迭代。我们已经进入了这个新的云时代，不管是新兴行业还是传统产业都蕴藏着巨大的商业机会，但同时也有巨大的挑战。腾讯将会继续提升、丰富，以及开放我们云的能力和资源，我们将支持各行各业创新、优化、升级，我们希望和大家一起共建云上生态。
谢谢大家！作者 | 余宇翔编辑 | 迷鹿

余宇翔，年硕士毕业，就职于腾讯基础架构部金融业务组，从事服务器后端开发，目前参与腾讯云和微信支付推出的云支付项目的开发工作

导语
 的主要设计思想应该都是源自 的  协议，是互联网工程任务组    对谷歌提出的  协议进行标准化才有了现在的  。下面我们直奔主题分析  的新特性，并且与 作对比。
一、多路复用的单一长连接
单一长连接
在中，客户端向某个域名的服务器请求页面的过程中，只会创建一条连接，即使这页面可能包含上百个资源。而之前的一般会创建条连接来请求这多个资源。单一的连接应该是的主要优势，单一的连接能减少握手带来的时延如果是建立在上面，能减少很多不必要的握手，大家都知道握手很慢吧。
另外我们知道，协议有个滑动窗口，有慢启动这回事，就是说每次建立新连接后，数据先是慢慢地传，然后滑动窗口慢慢变大，才能较高速度地传，这下倒好，这条连接的滑动窗口刚刚变大，就创个新连接传数据这就好比人家一直在高速上一直开着，你是一辆公交车走走停停。由于这种原因，让原本就具有突发性和短时性的  连接变的十分低效。
所以咯，中用一条单一的长连接，避免了创建多个连接带来的网络开销，提高了吞吐量。
多路复用
明明是一条连接，怎么又是多路复用呢？后台开发的童鞋应该对多路复用很熟悉，例如用来管理一堆的，在这里，虽然只有一条连接，但是在逻辑上分成了很多。这个特性又很关键呐。先看下面这个网上借用的图 。

图片来源：_
以前的怎么干的？在一条连接上，多个请求只能串行执行！你说咱们现在的网络带宽这么大，这不浪费吗就不一样了，不管多少请求，只要有，就往连接里面扔好了，这能明显降低一个页面加载的时间。
多路复用怎么做到的？又来打个比方，你看高速公路，虽然路只有一条，但是收费的那个门是不是有很多个？
把要传输的信息分割成一个个二进制帧，首部信息会被封装到 ，相应的 就放到 一个帧你可以看成路上的一辆车只要给这些车编号，让号车都走号门出，号车都走号门出，就把不同的请求或者响应区分开来了。但是，这里要求同一个请求或者响应的帧必须是有有序的，要保证的，但是不同的请求或者响应帧可以互相穿插。这就是的多路复用，是不是充分利用了网络带宽，是不是提高了并发度？
更进一步，还能对这些流车道指定优先级，优先级能动态的被改变，例如把和文件设置得比图片的优先级要高，这样代码文件能更快的下载下来并得到执行。
现在回过头来看下，请求一个包含几十个或者几百个资源的页面，和在过程上面的区别，如下图所示：

我想英文不捉鸡的同学应该都能看懂，这里建了到个连接后，一个个请求串行地用这八个连接执行，而能一次把所有请求都发出去，还是压缩过的，高下立判。
二、头部压缩和二进制格式
 一直都是 对此我只能想到一个优点，便于阅读和。但是，现在很多都走，也把 变成了二进制，那这个优点也没了。
 于是搞了个压缩来压缩头部，减少报文大小调试这样的协议将需要这样的工具，要进一步地分析网络数据流需要类似的解析器。把报文中常见的字段名和值变成一个索引值，也就是维护了一张静态索引表，例如把  对应成索引表中为的一个值，但是头部还有一些不确定的东西，比如对应的浏览器名字啊。
所以它也维护了一个动态的索引表，静态表索引值为这时候数据传输过程中发现一个 那就把这个追加到动态索引表值为的地方，这次开始就用代替这个 ，所以这个动态索引表是在数据传输过程中逐步建立的，静态索引表写死的。
此外，对于资源路径这种完全不确定的东西，就采用编码来压缩，这样三管齐下，头部内容能大幅减少。可以看看下面的示意图：

头部为什么需要压缩？
因为一些重复东西在每个请求里面都有，例如 。当一个客户端从同一服务器请求一些资源例如页面的图片的时候，这些请求看起来几乎是一致的。而这些大量一致的东西正好值得被压缩。
另外， 请求的大小变得越来越大，有时甚至会大于窗口的初始大小，这会严重拖累发送请求的速度。因为它们需要等待带着的响应回来以后，才能继续被发送。尤其是当请求内容超过报文最大报文大小时，会被分成几个报文，这时候如果压缩，能减少了报文个数，就能减少几个时间了。
反过来，头部压缩也带来了消耗，而且如果刚好头部能被装到一个报文里面，压缩也没什么卵用。而且大部分响应报文的一般比大很多，这时候好像压缩头部也是多此一举。
三、服务端推送 
这个功能通常被称作“缓存推送”。主要的思想是：当一个客户端请求资源，而服务器知道它很可能也需要资源的情况下，服务器可以在客户端发送请求前，主动将资源推送给客户端。
这个功能帮助客户端将放进缓存以备将来之需。服务器推送需要客户端显式的允许服务器提供该功能。但即使如此，客户端依然能自主选择是否需要中断该推送的流。如果不需要的话，客户端可以通过发送一个_帧来中止。
以上就是最主要的几个新特性啦当然还有很多新特性，这里不详谈啦。最后安利一下  吧，貌似目前浏览器只有在服务器支持并且使用了的时候才会使用协议。总结一下为什么能去掉在上的开销？
单一的长连接，减少了握手的开销
头部被压缩，减少了数据传输量
多路复用能大幅提高传输效率，不用等待上一个请求的响应
不用像那样把多个文件或者资源弄成一个文件或者资源常见的优化手段，这时候，缓存就能更容易命中啊里面你揉成一团的东西怎么命中缓存？
哇。。写文章真的累。但是有时间我还会再写个如何部署，以及做些实验测试的性能。      

相关推荐
转发配置入门指南探索第一篇——概念作者：张博闵彪章恒

背景
“ ， ”这是个眼见为实的世界，这是个视觉构成的信息洪流的世界。大脑处理视觉内容的速度比文字内容快万倍，而随着智能手机的普及，图片、视频的产生和分享已经是人们在社交平台上的基本交流方式。用户通过手机、平板、电脑上传和分享自己的图片，而且这个趋势是每年都在增长参见图。
图  年统计报告
每天相册、微信朋友圈上，用户上传的图片数量有上亿张，这些图片被后台服务器存储下来，再通过网络分发出去。如果每张图片可以进行压缩，使得图片存储和传输分发的数据量越少，既节省了用户带宽，也提高了用户下载图片的速度，用户体验更好。那么图片是可以进行压缩的么？年，信息论学说的奠基人香农曾经论证：不论是语音或者图片，由于其信号中包含很多的冗余信息，所以可以对其进行压缩。图像压缩算法有：、、帧内压缩、帧内压缩，压缩能力是：  帧内压缩  帧内压缩，这个压缩能力是通过计算复杂度的提高来实现，其中、的计算复杂度是  压缩的  倍以上。目前在社交平台上用户上传的大量图片是格式，通过后台服务器用更加复杂的算法如、帧内压缩，进一步压缩以节省存储和带宽，所以对图像的压缩，从本质上是通过提高计算算力来降低存储和带宽。同时更加复杂的算法也带来计算算力的大量消耗和处理延时的增加。
从业务角度来看，对于离线业务，可以通过业务在波峰和波谷之间闲置的计算算力进行图片转码处理；但对于在线业务，图片转码处理对于处理延时的要求就会有较高要求，为了满足处理延时的要求，有时候会先进行图片转码处理，把转码好的图片存储下来，当用户需要的时候直接传输，这样通过消耗存储资源为代价来解决处理延时的要求。但是这又带来一个新问题，用户查看图片的智能终端屏幕大小不一，如果都传同样大小的图片，显然不是最优。最优处理方法还是能够通过计算算力，实时进行图片转码处理。
在数据中心里面，计算算力通常由 来提供，以前的 性能每个月就能翻倍众所周知的“摩尔定律”，但目前工业界的发展方向是摩尔定律已经走到终点。例如，年月日，英特尔宣布正式停用“工艺年架构年”处理器研发模式，未来研发周期将从两年周期向三年期转变。而国际半导体技术发展路线图    ，简写 在维持了数十年，每两年更新一次，为全世界半导体行业提供建议和规划指南，也在年宣布不再做进一步的更新。
一方面处理器性能再无法按照摩尔定律进行增长，另一方面数据增长对计算性能要求超过了按“摩尔定律”增长的速度。处理器本身无法满足高性能计算：  应用软件的性能需求，导致需求和性能之间出现了缺口参见图。
图  计算需求和计算能力的缺口发展形式
图像处理解决方案
图片服务支持的能力丰富多样，基础功能包括多种缩略剪裁方式、文字图片水印、格式转换、断点续传、镜像存储、防盗链等。我们结合当前图文时代的用户需求，提供图片的上传、存储、处理、分发的全方位一体化的解决方案。目前，互联网图片服务的解决方案中落地存储和下载大部分图片格式还是，但随着新的编码标准的出现，在同等图像质量下，的压缩效率会比好，可以节省大量的存储和带宽，但是的算法复杂度高导致的编码延迟和吞吐在线上环境中无法满足，因此，我们开发了基于的新的解决方案。图像处理方案可以很好的解决线上环境的需求，当然，图像处理解决方案也兼容当前用户线上系统的等其他图像转码格式，可以很好的适应不同用户的需求，提供低延迟，高吞吐，低成本的解决方案。
我们以  图像处理为例，来说明在互联网业务中图片上传，存储，处理和下载的架构。
图   图片上传存储，处理，下载解决方案
如图所示，图片 转码的部署主要是落地存储前以及下载前的转码服务器，使用做转码主要有以下优势：

转码落地存储，可有效节省存储成本。 转码服务器和转码相比可以降低服务器成本。
转码图片和相比吞吐量可以大大提高。
在下载时实时生成图片，使用进行图片转码加速，会大大降低转码延迟，提高用户体验。

图像编码算法分析
在图像和视频编解码算法中，各个模块都是基于像素级运算或者基于块操作，而且针对各个像素或者图像块的操作是相同和重复的。早期的图片压缩标准和，原始图像首先经过基于块的变换或者小波变换，变换后的系数经过量化后再进行熵编码包括编码或者自适应算术编码，进而输出压缩后的码流信息。在解码端，通过反向操作，可将码流信息进行解码。在中，变换被小波变换替代，可以更好的消除图像块内的冗余性，而且量化后的系统按照比特位平面进行自适应算术编码，可以达到更好的压缩性能。
除了这类对原始图像直接变换的方法，还有一种是基于块预测的方法。也就是对一个图像块先进行预测，原始图像块和预测块的残差再进行变换，量化和编码。比较典型标准就是从的帧内预测发展而来的。随着新一代视频编码标准的推出，其帧内编码的压缩性能，较上一代标准提升接近一倍。因此，将的帧内编码用于图像压缩也成为一种趋势。的帧内编码过程如图所示。
图 帧内编码的过程
在中，块划分的方式是基于非完全四叉树结构，这更适用于不同的图像场景。每一个最终确定大小的块只需要一个独立的预测模式。图是图片编码中块划分和预测模式的一个例子。可以看出当一个块可以通过单独的某一个角度进行预测的时候，则不需要划分为更小的块。而场景信息较为复杂区域则需要划分为较小的块。编码器的一项重要任务，就是寻找最佳的块划分方式和最优的预测角度。
图 图片编码块划分及预测模式 
图 就是根据最终的块划分方式和预测模式得到的预测图片。预测图片和原始图片的差值残差通过变换，量化之后，最终通过熵编码器输出。图片预测的残差如图所示。在解码器中，根据得到的残差数据，并进行和编码器相同的预测，可以得到最终的重构图片，图所示的就是重构数据。由于编码过程需要用到重构数据作为参考数据，因此在编码器也需要进行重构的过程。原始图片如图所示，可以看出，重构的图片和原始图片损失非常小。图 图片编码过程中的预测，残差，重构以及原始数据         
在的帧内编码中，由于要进行最佳编码模式的搜索，造成编码器的计算复杂度高。传统的无法达到理想的吞吐量。现在的虽然也大量应用的图片和视频领域，然而的并行化更适用的是各个像素点进行相同操作，完成之后再进行下一步的并行化操作。这并不利于图片编码各个模块控制较为复杂的情况。在的中，图片和视频编解码也采用的专用的芯片来处理。而可以实现各个不同的模块的流水化运算，实现时间上的并行。同时，由于只是进行帧内编码，不同图像之间是相互独立的，在中也可以设计多路的编码器，对不同的图片进行并行的编码压缩。
当然，对于基于块预测的图像编码方法，也存在一些限制并行化实现因素。但是，这些受到限制的部分，也可以通过设计的特点来解决。例如，如图所示，帧内预测的参考点需要通过重构的方法得到，这就增加了不同块之间的依赖性，限制了块之间的并行化，和流水化设计。在实际的设计中，可以在进行预测模式初选时，用原始数据替代重构数据作为参考，而在最终编码时用重构数据在作为参考数据。在的实现过程中，也可以更改扫描顺序，优先处理那些有依赖关系的像素点。此外，在自适应熵编码部分，由于存在更新码表和更新概率估计的过程，部分比特数据进行熵编码时，也存在依赖关系。在实际的设计过程中，可以通过将这些需要进行编码的数据进行分组，将没有依赖关系的数据分为一组，同时，通过数据缓存，可以预先判断接下来的数据是否存在依赖关系，从而提高熵编码的吞吐量。
图像编码算法的实现
图像编码架构
目前，我们图片业务已经实现和格式的硬件加速，下面以 帧图像硬件加速举例，说明图像编码在中是如何实现的。
的逻辑架构主要包括平台部分和编码器部分，其中平台主要包括 以及总线相关逻辑，这部分逻辑主要实现和 的数据通信以及和板卡上的通信。如图所示，架构上实例化了个 具体几个是和资源有关，每一个 完成编码算法的完整处理，这里核心并行工作，也就是同一时刻，个编码任务可以并行工作，同时输出条码流。
  图 内部逻辑架构
内部逻辑主要包括：

  编码器，实现的编码算法；
实现和 进行通信；
 寄存器读写以及中断处理；
  总线读写仲裁模块；
  总线控制访问逻辑；

图像编码流程
  内部算法处理流程如图所示：分为当前图像载入，预测初选，预测精选，编码，码流输出。
图  内部算法处理流程
那么如何设计 实现算法功能呢？这里，编码器模块流水线设计成四级流水，如图所示，四级流水处理性能设计接近，并行起来后，平均处理每个需要个周期，如果按照图片一共个计算，单核理论上编码可以达到编 帧 电路实现频率，这样核并行能达到帧。
具体来说，完成当前图像的载入逻辑，完成预测初选种模式的遍历，得到最优的预测模式，这级流水算法上做了优化，预测参考像素没有像传统方式选择重构像素，而是选择当前像素做参考像素，这样优化，使得预测初选可以单独划分为一级流水，和预测精选分开，使得编码器整体处理性能增加一倍。完成帧内预测模式精选以及模式选择，预测块大小支持，由于涉及到变换量化等运算量大的逻辑，这一级流水是整个编码器的资源消耗大户，设计上在算法上以及逻辑资源消耗上做了权衡；模块完成头信息的码流生成以及每个的语法元素和残差的编码，并完成码流的打包输出，这一级流水的主要问题在于的性能是否足够快，从而应对比较小编码更多的处理及时。
图 运算模块流水线 
性能和收益
用完成格式图片转成格式图片，图片分辨率大小为，处理延时相比降低倍，处理性能是机器的倍，机型单位性能成本是机型的参见图。
图图片转码和对比
总之，图片算法的实现，如果不考虑资源、硬件实现架构和处理性能，图像压缩算法可以完全在进行“复制”实现，算法压缩性能可以完全等同。但是现实没那么理想，算法实现要统一考虑性能，资源，算法实现复杂度等要素，只有联合设计才能设计出最优秀的方案，为了发挥硬件实现的速度优势，算法进行优化是必须要做的，综合考虑各方面，我们在实际应用中，往往的算法实现要做一些“让步”。另外，某种型号的一旦被选定，它的运算以及布线资源往往有个理论值，算法的实现同时要考虑资源的利用情况，如何能在相同的资源上实现最好的压缩算法成为设计的难点。我们用进行算法实现的目标实现算法性能尽量接近，图片处理吞吐量，以及处理延迟让望其项背。

参考文献： ：玛丽·米克尔“互联网女皇”年互联网趋势报告                                                                                                          
本文来自：腾讯架构师 公众号作者：

最近半年以来，热补丁技术热潮继续爆发，各大公司相继推出自己的开源框架。在最近也顺利完成了公司的审核，并非常荣幸的成为上第一个正式公开的项目。
回顾这半年多的历程，这是一条跪着走完，坑坑不息之路。或许只有自己真正经历过，深入研究过 才会真正的明白。

热补丁不是请客吃饭

对热补丁技术本身，还是对使用者来说都是如此。我希望通过分享在这历程中的思考与经验，能帮助大家更容易的决定是否在自己的项目中使用热补丁技术，以及选择什么样方案。
热补丁技术背景
热补丁是什么以及它的应用场景介绍，大家可以参考文章：微信热补丁实践演进之路。在笔者看来热补丁技术应该分为以下两个流派：

，代表有阿里的、与腾讯的内部方案；
，代表有的超级补丁、大众点评的、百度金融的 饿了么的以及美团的。

流派与流派都有着自己的优缺点，它们具体差异大家可参考上文。事实上从来都没有最好的方案，只有最适合自己的。
对于微信来说，我们希望得到一个“高可用”的补丁框架，它应该满足以下几个条件：
、稳定性与兼容性；微信需要在数亿台设备上运行，即使补丁框架带来的异常，也将影响到数万用户。、性能；补丁框架不能影响应用的性能，这里基于大部分情况下用户不会使用到补丁。其次补丁包应该尽量少，这关系到用户流量与补丁的成功率问题；、易用性；我们同时希望补丁框架简单易用，并且可以全面支持，甚至可以做到功能发布级别。
在“高可用”这个大前提下，微信对当时存在的两个方案做了大量的研究：、；最大挑战在于稳定性与兼容性，而且异常排查难度更高。另一方面，由于无法增加变量与类等限制，无法做到功能发布级别；、；最大挑战在于性能，即平台存在插桩导致的性能损耗，平台由于地址偏移问题导致补丁包可能过大的问题；
在年月，微信为了追寻“高可用”这个目标，决定尝试搭建自己的补丁框架—。
框架的演绎并不是一蹴而就，它大致分为三个阶段，每一阶段需要解决的核心问题并不相同。而 的核心问题是实现符合性能要求的补丁框架。
 —性能极致追求之路
为了稳定性与兼容性，微信选择了流派。当前最大难点在于如何突破方案的性能问题，通过研究 的冷插拔与的给了我们灵感。它们的思想都是全量替换新的。

简单来说，我们通过完全使用了新的，那样既不出现地址错乱的问题，在也无须插桩。当然考虑到补丁包的体积，我们不能直接将新的放在里面。但我们可以将新旧两个的差异放到补丁包中，这里我们可以调研的方法有以下几个：

、；它格式无关，但对效果不是特别好，而且生成产物大小非常不稳定。当前微信对于与部分资源，依然使用算法；、；它主要问题在于合成时内存占用过大，一个的，峰值内存可能达到多；、；通过深入格式，实现一套生成产物小，内存占用少以及支持增删改的算法。
如何选择？在“高可用”的核心诉求下，性能问题也尤为重要。非常庆幸微信在当时那个节点坚决的选择了自研算法，这过程虽然有苦有泪，但也正是有它，才有现在的。
一 技术实践
在不断的深入研究究格式后，我们发现自己跳进了一个深坑，主要难点有以下三个：、格式复杂；大致分为像，这些区域以及使用的区域。它们有大量的互相引用，一个小小的改变可能导致大量的与变化；、与校验；在这两个过程系统会做例如四字节对齐，部分元素排序等校验，例如按照内容的排序，按照排序、低内存，快速；这要求我们对每一块做到一次读写，无法像与那样完全结构化。

现在回想起来，这的确是一条跪着走完的路。与研究与执行一致，这是经历一次次翻看源码，一次次编查看日志，一次次内存结构换来的结果。
下面以最简单的区域举例：

要想将从左边序列更改成右边序列，算法的核心在于如何生成最小操作序列，同时修正与，实现增删改的功能。
、 ；元素被删除，它对应的是，为了减少补丁包体积，除了新增的元素其他一律只存；、  元素自动前移，无须操作；、； 在第五个位置增加这个元素。
对于区，由于每个可能有非常多的元素，这里会更加复杂。最后我们得到最终的操作队列，为什么可以做到内存非常少？这是因为算法是每一个操作的处理，它无需一次性读入所有的数据。的各项数据如下：

通过算法的实现，我们既解决了平台的性能损耗问题，又解决了平台补丁包过大的问题。但这套方案的缺点在于占体积比较大，微信考虑到移动设备的存储空间提升比较快，增加几十的空间这个代价可以接受。
二  的挑战
信心满满上线后，却很快收到华为反馈的一个：

而且这个只在 上出现，在当时对我们震动非常大，难道 不支持方式热补丁了？难道这两个月的辛苦都白费了吗？一切想象都苍白无力，只有继续去源码里面找原因。
在之前的基础上，这一块的研究并没有花太多的时间，主要是 的混合编译模式导致。更多的详细分析可参考文章： 混合编译与对热补丁影响解析。
三 厂商的挑战
刚刚解决完 的问题，还在沉醉在自己的胜利的愉悦中。前线很快又传来噩耗，小米反馈开发版的一些用户在微信启动时黑屏，甚至。

当时第一反应是不可能，所有的操作都是放到单独的进程，为什么只在平台出现？为什么小米开发版用户反馈比较多？经过分析，我们发现优化后文件存在有效性的检查：

平台：
平台： __

这就非常好理解了，因为之后系统改变了，文件用到的偏移地址很可能已经错误。对于文件，在升级系统已完成重新，而补丁是动态加载的，只能在第一次执行时同步执行。
这个耗时可能高达十几秒，黑屏甚至也是非常好理解。那为什么只有小米用户反馈比较多呢？这也是因为小米开发版每周都会推送系统升级的原因。
在当时那个节点上，我们重新的审视了全量合成这一思路，再次对方案原理本身产生怀疑，它在平台上面带来了以下几个代价：
、后黑屏问题；这里或许可以通过界面实现，但并不是很好的方案；、体积问题；一个的，在下产物只有左右，但在平台，可以达到多；、 的问题； 在混合编译上努力，被补丁全量合成机制所废弃了。这是因为动态加载的，依然是全量编译。
回想起来，方案它只把需要的类打包成补丁推送，在平台上可能导致补丁很大，但它肯定比全量合成的少很多很多。在此我们提出分平台合成的想法，即在平台合成全量，在平台合成需要的小。

算法已经非常复杂，事实上要实现分平台合成更加不容易。

主要难点有以下几个方面：

 的类收集；什么类应该放在这个小的中呢？
处理；对于怎么样处理，可能出现类从一个移动到另外一个
偏移二次修正 补丁包中的操作序列如何二次修正？
的大小； 为了修正偏移所引入的文件的大小？

庆幸的是，面对困难我们并没有畏惧，最后实现了这一套方案，这也是其他全量合成方案所不能做到的：
、全量合成，解决了插桩带来的性能损耗；、平台合成 ，解决了全量合成方案占用体积大 升级以及 的问题；、大部分情况下仅仅 解决由于补丁包可能过大的问题；
事实上，算法变的如此复杂，怎么样保证它的正确性呢？微信为此做了以下三件事情：
、随机组成校验，覆盖大部分；、微信个版本的随机校验 覆盖日常使用情况；、文件合成产物有效性校验，即使算法出现问题，也只是编译不出补丁包。
每一次算法的更新，都需要经过以上三个才可以提交，这样的这套算法已完成了整个闭环。
四 其他技术挑战
在实现过程，我们还发现其他的一些问题：
、等微信插件 市面上有各种各样的微信插件，它们在微信启动前会提前加载微信中的类，这会导致两个问题：

平台：出现         的；

平台出现部分类使用了旧的代码，这可能导致补丁无效，或者地址错乱的问题。


微信在这里的处理方式是若时发现安装了，即清除并不再应用补丁。
、反射成功但是不生效；部分三星版本存在反射成功，但      出现类重复时，查找顺序始终从开始。 
微信在这里的处理方式是增加反射成功校验，具体通过在框架中埋入某个类的变量为。在补丁时，我们自动将这个变量改为。通过这个变量最终的数值，我们可以知道反射成功与否。
 总结
一 关于性能
通过 ，的努力，我们解决了方案的性能问题，得到一个符合“高可用”性能要求的补丁框架。

它补丁包大小非常少，通常都是以内；
对性能几乎没有影响，的性能影响主要原因是微信运行时校验补丁文件的导致虽然文件在目录，微信为了更高级别的安全；
平台通过革命性的分平台合成，既解决了地址偏移的问题，占体积与方案一致。


二 关于成功率
也许有人会质疑微信成功率为什么这么低，其他方案都是以上。事实上，我们的成功率计算方式是：

应用成功率= 补丁版本转化人数基准版本安装人数

即三天后，的基础版本都成功升级到补丁版本，由于基础版本人数也是持续增长，同时可能存在基准或补丁版本用户安装了其他版本，所以本统计结果应略为偏低，但它能现实的反应补丁的线上总体覆盖情况。
事实上，采用方案，天的成功率大约为，这里还是有很多的优化空间。
三  －稳定性的探寻之路
在阶段，大部分的异常都是通过厂商反馈而来，并没有解决“高可用”下最核心的稳定性与兼容性问题。
我们需要建立完整的监控与补丁回退机制，监控每一个阶段的异常情况。这也是 的核心任务，由于边幅问题这部分内容将放在下一篇文章。
关注，来给我们吧。

本文来源于： 微信公众号作者：刘洋
团队公众号：腾讯移动品质中心
一、单元测试及单元测试简介
惯例，先简单介绍下理论知识，懂得的可以跳过。
、单元测试定义和特性
单测定义：
在计算机编程中，单元测试 又称为模块测试 是针对程序模块软件设计的最小单位来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类超类、抽象类、或者派生类子类中的方法。
单测特性：
截取下《单元测试的艺术》一书中的优秀的单元测试特性，牢记！

、单元测试
顾名思义，是在系统下进行的单元测试。
业界上已经有很多工具可以支持做系统下的单元测试，主要分为两大类：

通过系统的测试框架，我们可以编写测试代码，并且打包成，运行在手机上。
优点： 逼真；
缺点： 很慢；
代表框架：。
  
通过，以及第三方测试框架，我们可以编写测试代码，生成文件，直接运行在虚拟机中。
优点： 很快，使用简单，方便；
缺点： 不够逼真，比如有些硬件相关的问题，无法通过这些测试出来；
代表框架：   。
：一个单元测试框架，可以清除 通过技术，以便您可以测试驱动应用程序的开发，测试内部运行，用例执行速度很快。
其官网地址：。
：一种简洁，美观，可靠的 测试框架。
其地址：。
：一个针对  的单元测试模拟框架，它与  和  很相似，都是为了简化单元测试过程中测试上下文  或者称之为测试驱动函数以及桩函数  的搭建而开发的工具。
其中文开发文档：=。
：是在  以及  基础上的扩展，通过定制类加载器等技术，实现了之前提到的所有不能模拟的功能比如静态函数、构造函数、私有函数、 函数以及系统函数的模拟。
二、官方架构
在熟悉单元测试框架前，首先需要学习了下官方推荐的项目架构，好的框架单元测试也比较好开展。
其推荐的项目中各层所使用的单元测试框架如下图所示：

其测试架构图总结如下：

项目代码有兴趣学习的同学可以去自行下载去学习，学习这种优秀代码是最快的方式。
层：
职责：模式下，本身该做的事情都能做了，比如布局，数据渲染，点击按钮交互等等。
测试方式：以正常小的测试思维方法，就可以来定义这一层的测试方式，测试过程中需要真机或模拟器，并做真实的操作。
测试选型：依赖于环境，用谷歌强大的，用于模拟和验证各种各样的操作，代码存放于中。
层：
职责：这一层是拉皮条的，负责和层的对接，所以有较少的处理输入输出的机会，他只用来控制逻辑，去调用相应的和的逻辑。
测试选型：他的职责决定了他很少去断言输入输出，测试逻辑覆盖的路径是否正确即可，因此他与环境无关，用测试即可，代码存放于中。
层：
职责：负责数据的存取，数据可能来自于网络、数据库和内存。
数据库增删改查：需测试数据存取的准确性，依赖环境进行测试，因此使用，代码存放于中。
网络请求：不测试真实的网络请求，但提供了供其他层调用测试。
封装的门面类：决定了数据的来源和去向是来自于本地数据库  网络  内存，此为真正对其他层暴露的类。此类不做数据准确性的验证，只做测试，验证覆盖路径。选型，代码存放于中。
各个模块通信方式如下：

除了，还有一种的方式。
的全称为，即模型视图控制器。
：处理数据和业务逻辑等。
：显示界面，展示结果等。
：控制流程，处理交互。
各个模块通信方式如下：

和区别：
在模式中，和可以直接交互；在模式中，和模块不能直接交互，通过与间接交互。
在中，是基于行为的，可以被多个共享，可以负责决定显示哪个；在中和是一对一或这一对多的，并且和是通过接口交互的。
三、单元测试环境一些基本的准备工作
、新建一个标准的 工程
新建一个 工程，这个就不详细说明了，网上有很多教程。
成功后目录下就出现和下目录。
、源码和其他工程目录搬迁移植
将源码目录全部放在下适合老业务改造。
如果源码目录指定不对，需要修改的配置。

、增加工具框架依赖
在下增加工具框架的引用。

注：如果用到什么框架就将框架引用进来即可，但有些工具主要版本号的相互搭配，不匹配可能会出现错误。
网上有一个对的版本对应关系：

作者使用的是下面红色的组合，请根据实际情况匹配。

、增加覆盖率
增加的插件：

指定版本号和报告目录：

指定源码目录。自定义报告规则：

上面一切准备完毕后，配置好代码，就可以正常同步加载了。
如果你的 的 同步成功，那么恭喜你单测环境基本了，依赖库基本也已经下载完毕，下面可以愉快的开始着手代码编写了。
可能有的公司需要网络代理，那这个需要根据具体情况在中配置了。
四、编写下的单测用例
层的单元测试只简单介绍一下，作者实际编写单元测试的时候，部分的单元测试用例也是放在了目录下一起写的模拟的，运行不需要手机或模拟器，执行速度比较快。
虽然没有在实际项目中大量使用，但也将当初的尝试简单介绍一下，供参考。
的用例可以选取。
在目录下新建一个测试类。
比如我们测试一个这样的单测用例：测试更新页的点击更新所有，用户页面会弹出一个确认的弹框。
用例编写如下：


手机连上电脑，选中用例鼠标右键就可以运行看结果了。

五、编写下的单元测试用例
首先介绍下单测工具框架选取的过程。
、选取合适的测试框架
作者开始在业务中尝试使用测试框架，初心主要在于他的特性：
                                                              
它不需要你的模拟器，直接在上运行你的测试代码，能在短时间之内快速验证，通过体验之后，它确实非常高效，编写测试代码反而加速了开发效率。
另外被它强大的方式所吸引，可以完全实现自定义方式。
但在实际使用的过程中遇到了不少的坑，比如：
版本和版本强依赖。
 的不能使用的版本，只能使用以上的。为什么会有这种强依赖，是因为会大部分的代码，会有很多的类，也就会随版本的变化而变化。
首次启动下载相关的依赖失败。
即使我们在开发网下设置了代理，开通外网权限，首次启动还会去下载相关依赖，结果是下载失败，这个是由于本身代码里的逻辑，我们不能通过网络代理的方式解决。
唯一的办法只能一个一个手工的下载后丢到你的\\\目录下，让找到其所依赖的包，不需要在去下载，如下：

如果在重新指定的版本，那么这些需要的版本还要手工下载一遍。
运行报     业务使用了多包加载架构，运行出现上面的异常。
解决方法：里面人为增加方法         {}这样修改代码其实是有点犯忌的，但只改这一处还勉强可以接受，下面的就不能接受了。
运行在自定义的控件时有时会出现解析异常。跟踪解决了几个，发现要修改的地方比较多，这里省略一万字的修改记录。除了改动点比较多，也可能后续会出现更多的潜在错误。违背上面的单元测试特性之运行稳定，衡量再三，还是决定放弃了，另寻它径。
这里也声明下，工具还是很优秀的，它的解决思路很清晰，所有调用到相关的都会转移到其类，这样就可以完全脱离的限制，只是由于业务的特殊性才暂时不用。
于是又开始研究，见上面的编写单元测试用例。使用过程中总体感觉功能比较强大，只要合理的使用其提供的和规则，常用的逻辑基本都可以模拟，但唯一不爽的就是每次都要连接手机或者模拟器才能运行，的过程中，首先会打包，部署到手机上，然后再开始一个一个运行测试用例，好处是手机上的表现很直观，但这样调试和运行速度是真心的慢。
违背上面的单元测试特性之运行速度快，建议放弃。
尝试使用、和来编写三层的单元测试用例，在经过一阵探索后，三层的逻辑基本都可以通过和来模拟出来，运行起来关键是速度快，速度快，速度快，好的地方说三遍。
上面的单元测试特性也基本都能满足，最终决定使用、和这个框架组合来进行我们的单元测试用例设计和编写。
、选取被测模块和熟悉被测模块的代码逻辑
在单元测试前要对被测模块有个大致的代码逻辑熟悉，对代码的深入可以边写边熟悉。
、知识点掌握
单测用例编写过程中，熟练程度一部分完全取决于对单测工具框架的了解程度，这块没捷径可走，必须要掌握清楚明白，简单列一下其知识点，具体还是需要自己去搜索资料掌握的。
注解与的使用；
测试或模拟方法；
测试或模拟返回的静态方法；
与的使用；
如何验证方法调用；
如何验证调用次数的方法；
测试或模拟类或方法；
测试或模拟构造方法；
如何做参数匹配；
接口的使用；
如何使用进行部分模拟；
如何测试或模拟私有方法；
和的作用；
如何给私有的字段赋值；
如何模拟异常。
、设计单元测试用例
需要写单测列表。
在我们的项目中，单元测试对象建议和类相对应，这样的单元测试结果比较直观。单元测试分析被测类的业务逻辑，这里的逻辑不仅仅包括界面元素的展示以及控件组件的行为，还包括代码的处理逻辑。然后可以创建单元测试列表，列表用于纪录项目中单元测试的范围，便于单元测试的管理以及新人了解业务流程，列表中记录单元测试对象的页面，对象中的逻辑以及名称等，测试或开发工程师可以根据这个列表开始写单元测试代码。
用覆盖率来校验单测用例是否完备。
单元测试是工程师代码级别的质量保证工程，上述流程并不能完全覆盖重要的业务逻辑以及边界条件，因此，需要写完后，看覆盖率，找出单元测试中没有覆盖到的函数分支条件等，然后继续补充单元测试列表，并在单元测试工程代码中补上。
直到被测类所有逻辑的重要分支、边界条件都被覆盖，才认为该类的单元测试结束。
另外觉得复用或通用的逻辑建议做成工具类，直接复用。
整理了一个的单测流程图，供参考：

、公共的可复用的抽离出成工具类
将一些常用的场景抽象出工具类，如、、、、等等，这样提供给单测直接调用即可，不用在重复造车轮。
、几种场景的单元测试用例案例
单元测试用例设计，格式可以自己灵活去定义，另外也可以在代码中已的方式添加单元测试用例内容，输入、输出、断言几点明确就可以了。我们把一部分项目常用的场景通过实现后，剩下的基本都是工作量的问题了。
目前业务代码逻辑场景的模拟做了如下：
请求的模拟及回调和的模拟；
页面加载场景模拟；
页面加载场景模拟；
控件场景模拟；
数据回调场景模拟；
主线程场景模拟；
序列化的模拟；
的模拟；
其他等等。
这部分的模拟代码就不贴上来了，有点多，需要可以线下交流。
、单测类的编写经验
对象可以被整个类的测试方法共用的，时统一放到里；
对象仅供单个单测用例使用的，时可以直接放到单测用例里；
能抽象出来的对象，建议做成工具类调用；
单测用例一定要有断言，且断言准确，这样才能保证单测用例的有效性；
不要怕麻烦，开始都会感觉很难，写多了熟练了就好了。
、调试
执行时候如何出现一堆黄色的，心里当然感觉爽了。
但在单元测试编写运行中难免会出现各种异常错误，时出现空指针的场景会比较多，这时候我们就需要用调试方式。

然后设置断点，通过逐步跟踪下去吧，找出单测用例的编写的问题所在。
、生成覆盖率报告
在 的中输入 后，单元测试开始运行，无错误结束后就会在指定的报告生成目录下看到覆盖率结果了。
通过覆盖率结果，查看到单测覆盖情况，根据情况补充或修改单测用例，加大覆盖率结果的提升，单测是有望达到覆盖的。
单测过程中可能会出现某些类的覆盖率结果为的，但实际上应该有覆盖率的，这可能是由于一些页面单测场景下被测类在中声明了，导致这些类的覆盖率为。以前作者也介绍过的原理，其是修改字节码文件插桩的，但再经过这种指定后，也会修改的字节码，这样就把的插桩冲掉了，导致覆盖率为，这部分我们可以通过自己写脚本的方式来算覆盖率，然后在和的覆盖率相叠加算出总的覆盖率。
六、做单测的意义
现在各个项目的代码量都比较庞大，全部进行单测覆盖，工作量消耗是非常巨大的。
并且产出和收益也不一定成正比例。
其实我们做单测和做系统测试的出发点都是一样的，提升项目的总体质量。
两点实施方式：
、对于开发久，稳定的功能，单测的出发点为系统功能测试的互补。
单测的着重点在功能测试难覆盖的地方，通过单测发现功能测试难发现的问题及代码潜在的问题。
、对应刚开发，新功能，如果有时间和人力的话，可以考虑单测全覆盖。
尽量在开发编码时并行实施，或者推动开发自己写单测。
最后有一个话题有机会大家可以一起讨论下：
单测的投入和产出如何来平衡？