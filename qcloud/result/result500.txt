作者：

我们即将讨论的是如何在前端项目中引入自动化测试。虽然文章聚焦的是前端项目，但实际上讨论的内容也适合  端应用。

这是本系列文章的第一章，主要内容是对前端自动化测试有一个初步的了解。适合入门学习。
 引入自动化测试的必要性
好处很多，包括减少错误、提高效率等，尤其是前端项目越来越庞大且多人维护时，前端自动化测试就会显得尤其重要。
代价也有，毕竟需要额外的学习成本。但在你的项目中加入测试，也许没你想象的那么困难。
   
说起测试，需要先说一下主流的测试类型，包括  和 ，有点枯燥，但有必要有个简单的了解，因为会影响选择如何测试的策略。

  ，测试驱动开发，强调的是一种开发方式，以测试来驱动整个项目，即先根据接口完成测试编写，然后在完成功能时要不断通过测试，最终目的是通过所有测试。
  ，行为驱动测试，强调的是写测试的风格，即测试要写得像自然语言，让项目的各个成员甚至产品都能看懂测试，甚至编写测试。


 和  均有各自的适用场景， 一般更偏向于系统功能和业务逻辑的自动化测试设计，而  在快速开发并测试功能模块的过程中则更加高效，以快速完成开发为目的。

很容易在网络上找到很多这两者比对，比如：

 与  仅仅是语言描述上的区别么？  知乎
关于、和的一些看法
虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发

  测试框架 
本文以  为例，它是现在最流行的  测试框架  之一。当然你也可以使用  和  等。

                                      


所谓测试框架，就是运行测试的工具。通过它，可以为  应用添加测试，从而保证代码的质量。
将  安装在项目中：
    

但为了操作的方便，请在全局中也安装一下 
    

 断言库 
断言库 是用来写断言的库。
维基百科的 断言程序一文是这么解释断言的：在程序设计中，断言是一种放在程序中的一阶逻辑如一个结果为真或是假的逻辑判断式，目的是为了标示与验证程序开发者预期的结果－当程序运行到断言的位置时，对应的断言应该为真。若断言不为真时，程序会中止运行，并给出错误消息。
根据风格，断言库又区分为  风格 和  风格。   便是其中一个著名的代表，它同时支持这两种风格。


                      

将  安装在项目中：
    

 编写测试脚本
我们先梳理下 、 和测试脚本之间的关系，如果不能够理解清楚，则后续的讲解会比较懵。

 只是个测试框架，它的作用是运行测试脚本。它不负责具体的测试。
 只是一个断言库，它的作用是用来在测试脚本中编写断言。
测试脚本文件就像我们正常的编写模块一样，只不过测试框架提供了额外的全局方法和变量，比如 、等，如果不用测试框架来启动，则它是没法运行的。就好比  对象是浏览器提供的，只能用浏览器来启动，不能够用  启动。
测试脚本中，断言库提供了一些语法支持，用来做判断的标准，比如你想测试某个变量  应该为字符串，你只需类似这么写  即可，其他的交给   ，因为它们会正确的处理：如果为真则通过，如果为假则报错。
有些测试框架会自带断言库，但  没有， 作为单独的断言库，功能很强大，这两者是黄金搭档。

接下来我们将以一个简单的加法模块为例来说明。完整的代码可以 查看此处 。
 新建源码文件
我们新建一个源码文件，命名为 ，文件内容如下：
   {
       
}

 = 

 新建测试文件
我们新建一个测试文件，命名为 ，文件内容如下：

通常，测试脚本与所要测试的源码脚本同名，但是后缀名为表示测试或者表示规格。

  = 
  = 

加法函数的测试   {
     加  应该等于    {
         
    }
}

测试脚本里面应该包括一个或多个  块，每个  块应该包括一个或多个  块。  块也可以包括   块。

 块称为测试套件 ，表示一组相关的测试。
 块称为测试用例 ，表示一个单独的测试，是测试的最小单位。

上面的   就是一个断言，此处我们选择的是  的  接口方式，它是  风格 。其详细的  接口说明可以 查看这里。
 运行测试命令
在当前目录下，执行以下命令：
 

运行结果如下，可以看到测试脚本同构了测试，一共只有  个测试用例，耗时是  毫秒。


 命令后面紧跟测试脚本的路径和文件名，可以指定多个测试脚本。例如：    

 总结
本文仅作为入门介绍了前端测试的基础知识，并且以    为例，编写了相当简单的测试用例。
但这个用例太简单，太理想化了。真实的项目环境中，还有很多问题都需要解决，比如：

如何用  语法来写测试用例？
如果代码中有  操作怎么测试？
如何在不同浏览器中进行测试？
使用  等框架时怎么测试？
依赖  等场景时如何测试？


这些实际的情况，我们会在接下来的文章中继续讨论。但至少根据这一章节的内容，你已经可以去写一些纯函数的测试用例了，比如传入一个时间戳然后输出自定义格式的时间或日期。
赶紧试试吧！

原文链接：


相关推荐
概览：可视化前端测试
前端识别验证码思路分析
新用户秒杀——域名折上折，限量抢购作者：

 新增了几种集合类型，本文主要介绍以及其使用。
其基本描述为：

对象是值的集合，你可以按照插入的顺序迭代它的元素。 中的元素只会出现一次，即  中的元素是唯一的。

它的声明：

 
其中是一个可迭代对象，其中的所有元素都会被加入到  中。被视作 。也可以不传入，通过其方法来添加元素。


对于或者是比较熟悉的同学可能会比较了解这个东东。它是 新增的有序列表集合，它不会包含重复项。
的属性

返回实例的成员数量。 

默认的构造函数。


方法

添加某个值，返回结构本身。 
删除某个值，返回一个布尔值，表示删除成功。 
返回一个布尔值，表示参数是否为的成员。 
清除所有成员，没有返回值。
 返回一个键名的遍历器 
 返回一个值的遍历器 
 返回一个键值对的遍历器 
使用回调函数遍历每个成员

例子
先借用之前看过的一篇英文的例子。地址请戳    。
总所周知，数组是没有这个方法的。当我们需要从一个数组里面移除一个特定的元素时，我们通常会怎么写？
在之前，我们会这么写
   {
      = 
     
}

然后我们可以这么用
  =      
      

 移除其中的“”
 
      

 细心的同学会发现我们前面那么写的问题，如果我们再次移除“”的话，会发生移除最后一个元素
 
     

当数组查找不到某元素时会返回，则数组的会从末尾往前，移除了最后一个元素，于是我们会这么写
   {
      = 

      ==  {
         
    }
}

这样的话我们就每次总是需要去检测的值。
我们还可以用来写，这样则返回一个新的数组
   {
      =  == 
}

那么有了我们能怎写？其实也不需要写，因为其初始化可以接受一个数组，作为构造参数，另外自带了一个的方法
  =       
  
   {    }

  
   {    }

好像蛮好的，但其实集合中的值是不能重复的，如果所需要的数据结构是要允许有重复项的，那么也没有什么用。
中值的相等是这么说的

因为  中的值总是唯一的，所以需要判断两个值是否相等。判断相等的算法与严格相等===操作符不同。具体来说，对于  ，   严格相等于和是不同的值。尽管在最新的  规范中这点已被更改。从 和   开始， 视  和  为相同的值。另外，和都可以被存储在 中， 之间被视为相同的值尽管  == 。

另一个例子
既然它的值是唯一的，那么我们是不是可以用它来实现数组去重？
原先我们去重可能会这么写
  =        
 _ =    {
     === 
}
_     

或者利用对象的唯一性，这么写
  =        
  = {}
 _ = 
 {
    =    
    {
     = 
    _
  }
}
_     

于是现在还能这么写
  =        
  =  
 _ = 新增了一个静态方法，可以把类似数组的对象转换为数组
_     

除了，我们也可以这么转化数组
  =  
  = 


而利用与的相互转化，还可以很容易地实现并集和交集
  =    
  =    
  =   
    
  =   = 
  

总结
与相比：

中存储的元素是唯一的，而中可以存储重复的元素。
中遍历元素的方式：通过……，而通过……。
是集合，不能像数组用下标取值。


原文链接：前言
 软件库是一个框架，开发者只需使用简单的编程模型在大量计算机配置不高上对大型数据集进行分布式处理。


有两种安装模式

完全分布式
伪分布式单机

本文采用完全分布式进行安装。
准备

             
                
              
一、安装
执行下面代码
 
     _= = 

  
用安装
 _
    _ 
  
你会看到这个
      

      

             _
             _
              _

            
这里选择
现在设置和命令
    _ 
    _ 
   _
   _
查看是否安装成功
 

  _
     _
        
配置环境变量
 
在文件尾部加上下面的代码
 _=_
 _=_
 =__
二、服务器创建账号
执行下面代码
 
 
会看到下面
    
 
  
     
三、修改
执行下面代码
 
在文件下面增加下面三句
的 
的 
的 
四、设置机器之间免密码登陆
仅在用户下免密登陆，我听到很多人说配置后仍需密码，那是因为他们使用了用户来连接。              
  
  
  _ 
  _ 
  _ 
  _

五、下载
这里使用的一个稳定点的版本
 
 
 
  
  
   
 
六、配置
修改
在标签中间添加下面内容

    
    


    
    

修改
在标签中间添加下面内容

    
    
    


    
    
    


    
    

修改 
首先先运行下面命令
  
然后在标签中间添加下面内容

        
    

修改
 _=_
 _==
 __=
你的路径
七、复制到子节点
利用复制，速度有点慢，喝杯茶等一下
 
 
   
   
八、配置只在上进行
先进入路径
 
 
修改

修改


九、在上格式化
 
 
  
十、开启服务
使用下面命令，直接启动所有服务
 

相关推荐
基于的与集群准实时同步介绍【腾讯云的种玩法】伪分布式搭建 是微信开源的一款基于  协议实现的高可用、高吞吐和高可靠的分布式队列，保证 ，在微信内部广泛支持微信支付、公众平台等多个重要业务。
开源地址：
请给一个 ！欢迎提出你的和
消息队列概述
消息队列作为成熟的异步通信模式，对比常用的同步通信模式，有如下优势：

解耦：防止引入过多的  给系统的稳定性带来风险；调用方使用不当会给被调用方系统造成压力，被调用方处理不当会降低调用方系统的响应能力。
削峰和流控：消息生产者不会堵塞，突发消息缓存在队列中，消费者按照实际能力读取消息。
复用：一次发布多方订阅。

诞生背景
旧队列
微信初期使用的分布式队列称为旧队列是微信后台自研的重要组件，广泛应用在各种业务场景中，为业务提供解耦、缓存、异步化等能力。
旧队列以   作为同步机制，其中 =、==，刷盘方式采用异步刷盘，兼顾了性能和可用性。
新需求
随着业务发展，接入业务种类日益增多，旧队列逐渐显得力不从心，主要不足如下：

异步刷盘，数据可靠性堪忧对于支付相关业务，保证数据可靠是首要需求。目前大多数分布式队列方案是以同步复制异步刷盘来保证数据可靠性的，但我们认为需要同步刷盘来进一步提高数据可靠性。

乱序问题部分业务提出了绝对有序的需求，但  并不保证顺序性，无法满足需求。


另外旧队列还存在出队去重、负载均衡等其他方面的问题亟需改善。上述种种促使了我们考虑新的方案。
业界方案的不足
 是大数据领域常用的消息队列，最初由  采用  语言开发，用作  的活动流追踪和运营系统数据处理管道的基础。
其高吞吐、自动容灾、出入队有序等特性，吸引了众多公司使用，在数据采集、传输场景中发挥着重要作用，详见  。
但我们充分调研了 ，认为其在注重数据可靠性的场景下，有如下不足：
  性能与同步刷盘的矛盾
 在开启配置 =，打开同步刷盘特性后，吞吐会急剧下降。
该现象由如下因素导致：

 写放大业务消息平均大小在数  左右。而  一次刷盘的最小单位为一个  ，大小为 。当  对大小不足  的消息进行刷盘时，实际写入的物理数据量是消息大小的数倍。导致硬盘写带宽资源被浪费。

业务场景下   效果不好  ，简单来说，就是把多个消息打包在一起发送到 ，广泛用于大数据场景。按道理，效果足够，是能抵消写放大的影响的。但业务场景下的消息生产不同于大数据场景下的日志生产，每个需要入队的业务请求在业务系统中有独立的上下文，难度大。即使在业务和之间加入代理层，将转移到代理层内进行，也因代理层的节点数众多，效果难以提高，导致写放大无法抵消。


   同步设计上的不足
  同步设计概要：
   会跟踪与其保持同步的  列表，该列表称为即 。如果一个  宕机，或者落后太多， 将把它从中移除。
该同步方式偏重于同步效率，但是在可用性方面表现略显不足：

   过程成功率下降严重在 的场景下， 均匀分布在各  上，一个出现故障，就意味着的 、 离线，这时读写成功率下降：

对于  离线的 ，暂时无法读写，需要等待  选举出新的  后才能恢复；
对于  离线的 ，也暂时无法读写，需要等待一定时长取决于 ，默认后， 将故障  从  中剔除才能恢复。



也就是说，任意一个  故障时，读写成功率会在一段时间内降为。

同步延迟取决于最慢节点

在同步复制场景下，需要等待所有节点返回。
通过对比   与  的表现，我们认为在同步方式上  是更好的选择：

所以，我们基于旧队列，用  协议改造了同步逻辑，并且进行了包括同步刷盘之内的多项优化，完成了 。
 介绍
 目前在微信内部广泛支持微信支付、公众平台等多个重要业务，日均入队达千亿，分钟入队峰值达一亿。
其设计出发点是高数据可靠性，且不失高可用和高吞吐，同时支持多种常见队列特性。
支持的特性如下：

同步刷盘，入队数据绝对不丢，自带内部实时对账
出入队严格有序
多订阅
出队限速
出队重放
所有模块均可平行扩展
存储层批量刷盘、同步，保证高吞吐
存储层支持同城多中心部署
存储层自动容灾接入均衡
消费者自动容灾负载均衡

设计
整体架构

 由下列个模块组成。

  队列存储

 作为队列存储，引入了  库，以  协议作副本同步。只要多数派节点正常工作及互联，即可提供线性一致性读写服务。
为了提高数据可靠性，同步刷盘作为默认开启特性，且性能不亚于异步刷盘。
在可用性方面， 内有多个独立的  ，每个   仅  提供读写服务，平时  动态均匀分布在  内各节点，均衡接入压力，节点出灾时自动切换  到其它可用节点。

  生产者

 作为消息生产者，根据  决定消息存储路由。相同  的消息默认路由到同一个队列中，保证出队顺序与入队顺序一致。

  消费者

 作为消费者，以批量拉取的方式从  拉消息，支持多协程方式批量处理消息。
 以服务框架的形式提供服务，使用者以实现回调的方式，根据不同主题，不同处理类型定义具体的消息处理逻辑。

  消费者管理器可选择部署

 的作用是，收集  全局负载信息 对  做容灾和负载均衡。当使用者没有这方面的需求时，可以省略部署 ，此时各  根据配置权重决定与队列的处理关系。
部署  后，  与所有  维持心跳，在收集  的负载信息的同时，反向调整  与队列的处理关系。
当   宕机了后， 依赖下述分布式锁服务选举出新 ，不可用期间仅影响  的容灾和负载均衡，不影响  的正常消费。

  分布式锁可选择部署

 是一个分布式锁，其接口设计非常通用化，使用者可以选择将  独立部署，提供通用分布式锁服务。
 在  中的作用有如下两点：
     为  选举 ；     防止多个  同时处理一条队列。
 同样也是可选择部署的模块：
若部署了 ，就必须部署  为  选举出 ；否则，若业务对重复消费不敏感，可选择不部署 。
这里所指的重复消费场景是：若省略部署  的话， 需要通过读取配置得知可处理的队列集合；当队列有变更如队列缩扩容时，各  机器上的配置改变有先有后，这时各  在同一时间看到的配置状态可能不一样，导致一段时间内两个  都认为自己该消费同一个队列，造成重复消费。 的部署可以避免该场景下的重复消费。注意，即使省略部署 ，该场景仅造成重复消费，而不会造成乱序消费
 复制流程

  通过  协议进行副本复制。
 的工程实现方式分为三层： 层负责处理业务请求， 层执行 同步过程，状态机层更新业务状态。
其中， 层发起  提议， 层各节点通过  协议共同完成一个   的确认，之后状态机以   作为的输入作状态转移，更新业务的状态，最后返回状态转移结果给  层。
一致的状态机层，加上来自  层的一致输入，就产生一致的状态转移，从而保证多个节点强一致。
这里我们要基于  在状态机层实现一个队列，就需要作如下概念映射：


队列这种模型不涉及数据修改，是有序的数据集合，和   的定义很像，所以可以让入队的数据直接作为  ，而状态机只需要保存   序列。
  的严格递增特性，使得它可以方便地作为队列偏移。
队列中读偏移之前的数据，认为是可以删除的数据，这点和   的定义一致。

整体上队列状态机和  能很好地切合。
  高效刷盘及副本同步
未经优化的  协议并未解决同步刷盘的写放大问题。而且，其副本同步效率不如 。
原因是， 的副本同步是流式批量的，而  协议是以   为单位串行同步，每个   的同步开销是 个  次刷盘。
在多部署的场景下， 时延可达，这样会导致单个   的理论最高  仅。
我们采用多   部署 以及   的方式来同时解决同步刷盘的写放大问题以及吞吐问题。

如上图 我们部署多个 ，以   作为   的单位，一个   内对应多个，将多个在一段时间内入队的数据合并在一起，当等待耗时或积累数据数目达到阀值，才会触发一次同步和同步刷盘，等待期间前端阻塞。
与的批量逻辑相比，在存储层以   进行批量合并的好处如下：
   业务层无需关注如何组织请求进行批量；   在存储层以   为单位的聚合效果比上层聚合效果更好。
 与  对比
下面分别从设计、性能、存储层  过程三方面对比  与 。
设计对比
 架构虽然与  等常见分布式队列类似，但设计上仍有不少独特之处。为了能让对  有一定了解的读者更方便地了解 ，下面列出了两者的对比。
注：以下对比基于相同的数据可靠性场景：少数派节点失效，不会造成数据丢失，且整体依旧可用。

性能对比
测试环境
         
  
   
   
  
 
测试基准及配置

测试结果
开启  ：

关闭  ：

以上场景， 瓶颈在 ，使用率达  。
小结

 性能与  持平；
相同  下，由于不用等最慢节点返回， 平均耗时比  稍优；
关闭   后，在同步刷盘场景下， 性能可达  的倍，原因是， 存储层在写盘前做了 ，而  没有，所以后者会有写放大。

储存层  过程对比
主要对比杀死存储层的一个节点后，对整体吞吐的影响。

表现：

 期间，在不同阶段程度不同，入队成功率在  ；
 持续时间由租约决定，租约时长默认。

测试过程：
将  从  调整为 延长时间方便观察，然后   ，挑选个 ，观察  变化如下：
第一阶段未   ：
          
          
          

第二阶段   后持续：
          
          
          

第三阶段持续分钟左右：
          
          
          

第四阶段至此入队成功率完全恢复：
          
          
          
其中，第二三阶段标红处对应的入队成功率受损：

第二阶段期间，  均无法写入，入队成功率成功率下降至。
第三阶段期间，  可继续写入，但   无法写入，因为写入要等   回 ，但   已 ，入队成功率下降至。

而实际观察，第二三阶段期间完全没吞吐，原因是压测工具不断报连接失败，停止了写入。
压测工具输出：
             
             
             
             
             
     入队成功率受损
               吞吐下降严重
             
             
             
             
压测工具连接失败日志：
                
                
原因分析：
   是通过  选举出来的， 列表是  维护的。
前者的的租约是  定义的，后者的租约是  配置  指定的。
所以，第二阶段持续时间较短，是  的租约时间决定的，第三阶段持续时间较长，是  决定的。
当   被  时，前者影响本来   是  的   的入队成功率，后者影响   作为  的   的入队成功率。

表现：

 期间，入队成功率仅下降至；
 持续时间由租约决定，租约时长默认。
开启 换队列重试特性适合没有绝对顺序性要求的业务提高可用性后， 期间仍有入队成功率。

测试过程：
将   租约时长从调整为延长时间方便观察，然后  ，观察某  入队成功率：
关闭换队列重试特性：
     入队成功率受损


   
        
     
 _  
       
            失败：连接失败
            成功：仍有成功率
         失败：提示需要重定向到 
           
                      
                      
                    
                  
                 
                 
                 
                
                
               
 =             


 入队成功率完全恢复


   
        
     
 _  
       
            成功：成功率
           
                      
                      
                   
                 
                 
                 
                  
                  
                    
                   
 =                 
开启换队列重试特性：
     入队成功率受损


   
        
     
 _  
       
             失败：超时
             失败：连接失败
            成功：仍有成功率
          失败：提示需要重定向到 
            失败： 未选举出来
           
                      
                      
                   
                 
                 
                 
                 
                 
                
               
 =             

 入队成功率完全恢复


   
        
     
 _  
       
            成功：成功率
           
                      
                      
                   
                 
                 
                 
                 
                 
                
                
 =               
小结
在存储层  过程中， 和  的入队成功率均有一定时长的下降， 的入队成功率在  ， 的入队成功率在  ； 开启换队列重试特性后， 过程中入队成功率保持在； 和  均能自动切换 ，最终入队成功率完全恢复。
小结
 在存储层做了很多的努力：实现了  自动切换，且仍然保证线性一致，切换期间仍然高可用；保证了同步刷盘的吞吐，其性能不亚于异步刷盘。
另外实现了大部分队列实用特性，例如出入队顺序一致、多订阅、限速、消息重放等，适用于各种业务场景。
目前  已在微信内部大规模使用，也正式开源。
我们将保持  开源版本与内部版本的一致，欢迎读者试用并反馈意见。
开源地址：
请给一个 ！欢迎提出你的和

转载自【腾讯开源】公众号，腾讯官方开源资讯，期待您的关注。一般来说，个人网站或博客静态页面居多，甚至全是静态页面，比如说用  等工具制作的个人博客。静态网站在开发完成之后，其实可以不需要购买服务器就可以直接部署到网络上的。本文介绍的就是一种无需服务器、甚至免费实现静态网站托管的方法。
在此实践中，您将在腾讯云对象存储以下简称 上托管静态网站，访客可以通过您的自定义域名例如  访问托管的静态网站。无论您是想在  上托管已有静态网站还是从零开始建站，此实例都可以帮助您完成  上的静态网站托管工作。

腾讯云对象存储针对每位腾讯云用户，每月提供 的免费流量。如果你的网站每月流量少于这个数字的话，可以算是每个月不花钱就享受个人网站服务了。

以下是具体步骤：
步骤预览
事前准备
以下是您在实践过程中，将会用到的相关服务：
域名注册：如果您还没有已注册的域名，则需要先注册一个域名，例如  。您可通过腾讯云  域名注册申请域名。通常，只需少量费用，即可拥有一个域名。
对象存储 ：您将使用对象存储  创建  ，配置权限以允许每个人查看内容，然后上传网页内容。
内容分发网络 ：内容分发网络  和云解析服务将共同作用，使您的域名和网站内容绑定，同时为您的静态网站加速，降低访问延迟，提高可用性。
云解析：您可以通过云解析将您的域名和网站内容绑定在一起，实现使用自定义域名访问您的静态网站的目的。

本指南中的所有步骤都使用  作为域名。您需要使用您已注册的一个域名替换此域名。

步骤 ：注册域名与备案
域名注册是在互联网上建立任何服务的基础。注册域名之后，您还需要进行域名备案，网站才能正常访问。请根据您的具体情况进行操作：

已注册域名并备案，可跳过本步骤。
已注册域名但未备案，请进行  域名备案。
未注册域名，请先  注册域名，再进行  域名备案。

步骤 ：创建  并上传内容
在完成域名注册及备案后，您需要在  控制台中执行以下任务，以创建和配置网站内容：  
 为您的网站内容创建 。 配置  并上传内容。
 创建 
请使用腾讯云账号登陆   控制台，为您的网站创建相应的 。 是  中用于存储数据的容器，您的网站内容都将存储在一个存储桶中。您可以通过  概览页或  列表创建 ：

概览页登录  控制台后，当您首次创建  时，请直接点击概览页上的创建 。
 列表登录  控制台后，请点击左侧  列表，进入列表后点击 创建 。

弹出创建  对话框后，您可以为您的网站创建一个对应的存储桶并保存。
 配置  并上传内容
您可通过以下两个小步骤，配置  访问权限和上传您的网站内容。

将  的访问权限设置为公有读私有写，使您的内容可被公开访问。在  控制台，点击已创建好的 。进入到  后，点击 基础配置，点击基本信息的编辑按钮。修改  的访问权限为公有读私有写，保存即可。

将您的网站内容上传到已创建好的 。在完成第  步后，点击文件列表。在该项目下进行文件上传。有关具体分步说明，请参阅  上传对象。



公有读私有写：任何人包括匿名访问者都对该  中的文件有读权限，但只有  创建者及有相应权限的账号才对该  中的文件有写权限。  

私有读写：只有该  的创建者及有相应权限的账号才对该  中的文件有读写权限，其他任何人对该  中的文件都没有读写权限。
在此步骤中，您在已创建好的  中托管内容。该内容可以是文本文件、照片、视频——任何您想要托管的内容。如果您还未构建网站，则只需为此实践创建一个文件。  
例如，您可使用以下  创建文件，并将其上传到 。网站主页的文件名通常为 。在后续步骤中，您将提供此文件名作为网站的索引文档名。

当用户访问任何不带文件指向的一级目录时， 默认优先匹配对应  目录下 ，其次为 ，若无此文件，则返回 。

 

    
         
         =
    
    
        欢迎使用 的静态网站功能。
        这是首页！
    

步骤 ：绑定自定义域名

静态网站托管功能仅在用户为  设置了自定义域名时有意义，使用默认提供的域名 加速域名和  直接访问域名访问资源时将始终弹出下载框，只有绑定自定义域名并开启静态网站功能后，才可以直接在浏览器中打开文件资源。

您可设置自定义域名直接指向 ，并开通静态网站功能，达到通过浏览器直接访问您的网站的目的  中的内容。  
此步骤中，您首先需要创建  记录具体介绍请参考   记录，将您的域名如  映射到  提供的默认域名如 。然后通过云解析将此  记录添加到您的域名下，实现自定义域名绑定。具体的操作步骤如下：
 域名添加 域名解析
 域名添加
在进行自定义域名添加时，有两种途径供您选择：

通过  控制台添加
通过  控制台添加

如果您想在添加自定义域名的同时，进行  高级管理和配置，可优先选择  控制台添加域名。本指南中不涉及  高级管理和配置，如需帮助，请参考   配置管理。
如果您只需要先添加自定义域名，不进行其他配置， 控制台添加将节省您的时间。
通过  控制台添加

请登录  控制台，从左侧导航进入域名管理页面。
点击添加域名，进入域名配置界面。
请输入您的域名，选择源站类型为对象存储 ，并为源站选择您托管网站内容的对应  默认域名。业务类型选择静态加速，其他保持默认配置，提交即可。
域名添加完成。请关闭弹窗，耐心等待域名配置下发至全网节点约  分钟。获取系统分配的  记录，再进行下一步骤。

通过  控制台添加

请登录   控制台，从左侧导航进入  列表页面。
选择您的网站对应的 ，进入域名管理页面。
自定义域名条目下，点击添加域名，添加您的域名，保存即可。
请稍等几分钟，等待域名上线。获取对应的  记录，再进行下一步骤。

 域名解析
在您完成域名添加之后，系统会为您分配一条对应的  记录。请按以下步骤完成域名解析任务：


请登录云解析控制台，点击添加域名。在弹出的对话框中，填入您的域名，并且选择对应的项目，保存即可。
域名添加成功后，点击该域名，进入解析记录管理页面。
点击添加记录，将在步骤  获取的  记录填入对话框，确认保存。


注：记录值是步骤  获取的  记录。添加后大约需  分钟左右生效，请耐心等待。

步骤 ：开通  的静态网站功能
绑定自定义域名之后，您还需要开通  的静态网站托管功能，才能通过浏览器直接访问您的网站。具体步骤如下：

登陆  控制台后，从左侧导航进入您网站对应的 。
进入基础配置页面，找到静态网站功能。点击编辑按钮开通  的静态网站功能并保存，如下图所示。


静态网站功能的相关具体配置及参数说明，请参考  静态网站功能。

步骤 ：测试验证
在完成上述步骤后，您可通过在浏览器地址栏输入您的网站域名进行访问，来验证实践结果，以  为例：

 ——返回名为  的  中的索引文档。
 不存在的文件 ——返回名为  的  中的  文档。


在某些情况下，您可能需要清除缓存才能看到预期结果。日前，微信新增小程序测试系统，可便于开发者检测小程序缺陷，评估小程序产品质量。在小程序发布之前，开发者可将小程序代码提交到测试系统，在不同型号的手机真机上运行，执行完毕后自动生成测试报告。小程序云端测试平台，由提供基础支持，下载“微信开发者工具”即可使用。
小程序测试报告示例：
一、 云真机测试 
为了方便广大开发者检测小程序程序缺陷、评估小程序产品质量，微信提供了免费的云真机测试环境以及一整套测试方案。在小程序交付到真实用户手中使用之前，你可以将小程序分发到云真机测试平台由提供支持，以模拟用户使用的方式进行测试，执行完毕后自动生成测试报告。
 测试覆盖范围
● 缺陷发现 测试过程中自动发现小程序抛出的异常
● 性能数据分析 测试过程中收集包含加载时间、占用率、内存占用量等数据指标
● 机型覆盖 小程序会被随机分配到个不同机型的机器由当时的机器资源决定来执行，借此可以观察小程序在不同机型的执行表现
● 其他：弱网络环境测试、多场景测试等开发中
 如何测试
没有比这个更简单了，下载“微信开发者工具”，点击「测试」按钮，一般小时内可查看测试报告！
提交测试后当前的程序版本会被提交到云端测试队列等待测试，如果第二天仍然没有收到测试报告，请在开发者论坛反馈，微信工程师会尽快处理。
测出后，如何调试小程序
您可以在平台上选取问题机型，进行远程调试，复现并解决问题。
二、为微信提供终端云服务
自年起与微信达成合作。除新上线的小程序测试外，微信团队也在平台进行客户端兼容性测试、功能测试。
微信团队通过自动化、云端化测试，将测试效率提升了数倍。
三、最后
后续，会在近期上线“小程序自动化测试”功能，提供给小程序开发者更多测试机型和工具选择，助力提升小程序质量！
  
、云真机是真实的机器吗？是的。机器由腾讯质量开发平台部署和维护
、为什么我的小程序里一个很明显的错误没有在云测试时发现？在目前阶段，云测试的代理算法是一个以高页面覆盖率为目标的穷举随机算法，缺陷发现能力较弱。它的每一次的执行路径都不一样，且受执行时间限制，所以有可能没有执行到缺陷存在的路径
、云测试能发现我的小程序中的文本错误吗？
不能。代理算法不是一个智能体虽然我们在努力给它添加更多的智能行为，对人来说显而易见的错误它可能却无法发现，尤其是业务类错误。文本错误至少要求语义理解的能力，所以它不能。
、测试结果太差时会影响小程序的提审和发布吗
不影响。测试报告只是一种提供给你对照分析的工具，怎么利用完全取决于你自己
、我的小程序有额外的登录体系非微信登录，测试时总是停在登录页面怎么办？
这个功能是我们下一次迭代的内容，届时你可以配置测试账号和密码，帮助代理算法自动登录从而遍历到更多的页面

提供上千台真实手机，随时随地进行测试，保障应用手游品质。节省百万硬件费用，加速敏捷研发流程。
点击：  即可使用。
如果对使用当中有任何疑问，欢迎联系腾讯企业：导语：使用  模块来进行压测数据的绘制，并且生成静态  页面结果展示。

不少小伙伴在开发过程中都有对模块进行压测的经历，压测结束后大家往往喜欢使用处理压测数据并绘制数据可视化视图，但这样不能很方便的使用页面进行数据展示。本文将介绍使用模块来进行压测数据的绘制，并且生成静态页面方便结果展示。
简介
是一款使用开发的制图工具，提供了与主流数据分析语言交互的如：  。大家可以到官网 了解更多详细的信息。能够绘制具有用户交互功能的精美图表。

 安装
本文档主要是介绍使用的 来进行几种简单图表的绘制，更多的用法请参考
可以使用安装，并且最好在版本及以上安装使用，如果使用版本，请自行安装和对应的。
绘图实例

绘图效果：
生成的页面在右上角提供了丰富的交互工具。

代码：
 _
    
    绘制普通线图
    
    数据，为横坐标，为纵坐标的两项指标，三个长度相同
     = {
               
               }
    _ = 
    分别插入  
    _ = 
         = 
         = 
         =  
    
    __
    _ = 
         = 
         = 
         =  
    
    __
    设置指定图表轴和轴名称
     = =  ={} ={}
    将设置到图表
     = =_ =
    绘图输出路径为参数指定
     =

绘图效果：

代码：
 _
    
    绘制散点图
    
     = {
               
               __________}

    _ = 

    _ = 
         = 
         = 
         = 
        = 
        =
         =  
    
    __

     = =  ={} ={}
     = =_ =
     =

绘图效果：

代码：
 _
    
    绘制柱状图
    
     = {   
                  
                  }
    _ = 
    _ = 
         = 
         = 
         = 
    
    __

    _ = 
         = 
         = 
         = 
    
    __
     = =  ={} ={}
     = =_ =
     =

绘图效果：

代码：
 _
    
    绘制饼图
    
     = {     
                    } 
    _ = 
    _ = 
         = 
         = 
    
    __
     = = 
     = =_ =
     =

本例是绘制具有填充效果的堆叠线图，适合分析具有堆叠百分比属性的数据
绘图效果：

代码：
 __
    
    绘制堆叠填充的线图
    
     = {
               
               
               }

    计算的堆叠占比
    _ = 
    _ =       
    _ =         

    _ =  _   _   _
    _ =  _   _   _
    _ =  _   _   _

    _ = 
    _ = 
         = 
         = _
         = _
         = 
         = 
         =  
         =  填充方式 到轴
    
    __

    _ = 
         = 
         = _
         = _
         = 
         = 
         =  
         =  填充方式到下方的另一条线
    
    __

    _ = 
         = 
         = _
         = _
         = 
         = 
         = 
         = 
    
    __

     = =   ={} ={}
     = =_ =
     =
小结
本文介绍了利用绘制数据图的方法，实例中 线图 、散点图 、柱状图 、饼图 以及填充堆叠线图  这五种典型的图表基本上涵盖了大部分类型的测试数据，各位小伙伴可以加以变形绘制出更多的漂亮图标。文中所示代码在附件中_
参考资料
__导语
年“云未来”峰会即将在深圳盛大举行，本次峰会 技术专场将在月日下午举行。  专场给各家提供了针对  应用以及背后填坑之路作深度探讨的机会。现在让我们一起回顾下去年各位嘉宾在在现场分享了哪些云上的心得体会以及 云原生架构上的亲身实践。
本文是腾讯首席前端领域专家、顾问委员会代表、腾讯云布道师黄希彤在年腾讯“云未来”峰会 专场有关《云时代程序员的社会责任和机会》分享的回顾。
黄希彤：《云时代程序员的社会责任和机会》
在云计算风起云涌的新时代，身为程序员和开发者承担着怎样的责任？又应当如何正确使用云计算呢？
腾讯首席前端领域专家、顾问委员会代表、腾讯云布道师黄希彤指出，在互联网时代，程序员所理解的社会责任通常是建设系统，提升社会效率、建立人与人的连接、人和物品的连接、人和信息的连接等等，为大家人创造更方便的生活和更娱乐的网上生活。

然而在云计算时代，程序员的责任来自对用户的责任、对企业的责任、对社会的责任。我们有责任为企业创造良好的用户体验，按需使用资源，避免企业为不需要使用的资源买单，这和我们对社会环境的责任是统一的。

一、对用户的责任

提供稳定的服务
在云时代我们应该采用一些全新的技术手段帮助用户及时对业务质量作出反应，保证业务稳定正常运行，如云监控、云拨测。


节省用户的时间
在信息时代，我们也非常的注重优化和提升用户体验。到了云时代我们有了一些全新的技术手段，可以进一步提升用户体验，更快速的把数据分发到用户手里的移动设备。那么，我们有责任充分利用云分发技术，如内容分发网络。




减少用户的焦虑
在移动时代，用户经常处在于各种各样网络不好的情况或者它本身就处在一个比较小的运营商，那么我们需要设身处地的考虑有哪些服务可以优化弱网以及可以在中小运营商有更好的数据分发的体验，在云时代可以采用维纳斯数据通道的服务，减少用户在等待服务响应过程中的焦虑。




节约用户的流量
在移动时代，用户需要花很高的成本向运营商购买流量。所以替用户节约更多的流量，是开发者当下其中一个很重要的责任，此时我们可以采用一些云上节约流量的解决方案。如万象优图。可以按需裁剪，将图片压缩到适用于当前用户的移动设备所需的分辨率和图片质量。



二、对社会的责任

避免不必要的计算资源占用
在信息的时代，我们通常会按照系统最高需要去设置资源池，使它不会产生资源瓶颈，然而这样的设计会导致很多时候这些资源是闲置的。然而，在云时代我们应该考虑怎么样去避免空闲时期不必要的资源占用，在腾讯云上面提供了弹性伸缩这样的服务，在需要的时候可以在云上申请更多的资源，在不需要的时候把计算资源释放到云的资源池里面，这样不止是成本的考虑，更重要的是我们可以避免浪费这些资源，把这些资源让给别人跟我们一起共享使用，那么所有的人以及整个社会都可以用更低的成本享用到这些计算资源，这是我们必须具备的一个社会责任。




避免不必要的存储空间浪费
通常我们在设计系统会考虑，要在系统上放一个多大的硬盘用来存多少数据，但是为了保持这个系统的可发展性，我们会留下非常多的空间冗余，那么这些空间的冗余在我们产品发展的很长一段时间里面都是浪费的。那么我们在云时代应该考虑一些更先进的存储解决方案，比如：对象存储服务。可以按需的申请我们所需要的存储空间，同时也帮我们解决了硬盘不够大的困扰以及避免不必要的存储空间的浪费。




避免不必要的带宽占用
带宽是社会最紧缺的资源，通常我们会花费非常高的成本购买足够我们产品使用的带宽。在云时代，有一些流量分发方式，比如可以把我们的流量通过优图、这样的方式来进行分发，代替以前位于一台虚拟主机或者一台物理机去购买很大的带宽的解决方案，这样不但可以减少大量带宽的占用，我们的系统也具有一个很好的抗压能力。



三、对企业的责任
黄希彤认为，三大责任最终是一致的，程序员有责任为用户提供稳定服务、节省时间、减少焦虑、避免流量浪费，这些用户责任与企业对用户的责任一致，而企业责任和社会责任也是一致的，程序员有责任为社会善用计算资源、存储资源与带宽资源，通过弹性伸缩的云计算技术减少热量排放与能源浪费；就云时代而言，程序员有责任善用基于 云原生架构的方式为企业架构系统，帮助企业按需使用资源、节省生产成本、创造良好用户体验、从而让企业获得更好的竞争优势。

为了说明自己的观点，黄希彤举了一个非常形象的例子：“大家可能都看过《超能陆战队》，很多人都以为大白是里面最厉害的机器人，但其实小黑机器人更厉害，虽然它的构造非常简单，但是可以快速组合，几乎是一种无敌的存在，就连大白在它面前也只有逃命的份。因此即使是非常小、非常简单的系统，当我们将其有机组合、快速复制的时候，其战斗力也会比一个庞大的单体系统更加强大，并且具备更大的弹性，拥有更强的适应各种现实环境的能力。”
从 的特点来看，其核心思想可以被概括为：敏捷、快速迭代、灵活、小团队作战。这与《超能陆战队》中的小黑机器人极其相似。作者：熊训德

本文档说明  语言自带的测试框架未提供或者未方便地提供的测试方案，主要是用于解决写单元测试中比较头痛的依赖问题。也就是伪造模式，经典的伪造模式有桩对象  ，模拟对象  和伪对象  。比较幸运的是，社区有丰富的第三方测试框架支持支持。下面就对笔者亲身试用并实践到项目中的几个框架做介绍：

文档地址： 
 模拟对象的方式是让用户声明一个接口，然后使用  提供的  工具生成  对象代码。要模拟  被测试代码的依赖对象时候，即可使用  出来的对象来模拟和记录依赖对象的各种行为：比如最常用的返回值，调用次数等等。文字叙述有点抽象，直接上代码：
 
 中  依赖外部对象 ，本示例就是说明如何使用  框架控制所依赖的对象。
     {
      
     

     
}
 工具命令是：
  {_}  {_}
比如，本示例即是：
  _  _
执行完后，可在同目录下找到生成的 _ 文件，可以看到  工具也实现了接口：
 
接下来就可以使用  工具生成的  来生产  对象，使用这个  对象。  这个函数，在控制类时支持链式编程的方式，其原理和其他链式编程类似一直维持了一个对象，把需要控制的方法名，入参，出参，调用次数以及前置和后置动作等，最后使用反射来调用方法，所以这个对象是对象的代理。的早期版本也是自带的动态代理实现的最近的版本是动态配合代理模式。

在本示例中只简单的更改了返回值，抛砖引玉：
   {
    = 
 

    = 
   

    =
   

}
使用 命令执行这个单测：

从结果看：本来应该输出，最后输出就是，和其他语言框架相似，生产出来的对象不用自己去重定义这么麻烦。
更多示例可以查看官网一个囊括几乎所有功能的例子： 

由于在网络架构上的优秀封装，使得在很多网络场景被广泛使用，而协议是其中重要部分，在面对请求的时候，可以对的进行测试，算是的特殊应用场景。
看一个简单的示例就轻松的看懂了：
   {

     = 

     = 
     

     =  

    
        
        
}
 其中还支持对不同方法包括等的构造以及返回值的自定义，更多细节查看其官网

还有一个使用起来可以说兼容了《一》中的和，但是其使用稍微有点烦杂，使用继承匿名组合重新实现需要的接口，在这个接口里使用者自己使用反射实现被的接口。
《单元测试的艺术》中认为和最大的区别就依赖对象是否和被测对象有交互，而从结果看就是桩对象不会使测试失败，它只是为被测对象提供依赖的对象，并不改变测试结果，而则会根据不同的交互测试要求，很可能会更改测试的结果。说了这么多理论，但其实这两种方法都不是割裂的，所以框架除了像其名字一样可以模拟对象以外，还提供了桩对象的功能。以其实现来说，更像是一个桩对象的注入。但是因为兼容了多个有用的功能，所以其在社区最为火爆。
具体用法可参考其主页。

还有一种比较常见的场景就是和数据库的交互场景，是模拟驱动器，主要用于测试数据库的交互，提供了完整的事务的执行测试框架，最新的版本还支持参数化提交和执行的方案。
比如有这样的被测函数：
        {
      = 
      =  {
        
    }

      {
          {
         
             = 
        
            
        }
    }

     _  =     =     =  {
        
    }
     _  =   _ _ _       =  {
        
    }
    
}

  {

      =  
      =  {
        
    }
     

      =       =  {
        
    }
}
 单测时：
   {
       = 
      =  {
            
    }
     

    
      
      _
           
           
    

      =     =  {
           
    }

      =   =  {
           
    }
}

测试回滚
   {
       = 
      =  {
           
    }
     

    
      
      _
            
            
    

     执行被测方法有错
      =     ==  {
         
    }

     执行被测方法，对象
      =   =  {
           
    }
}
更多例子和详情，请查看官网：
 介绍了这么多框架，最后需要说明的也可能最重要的是写代码时就应该考虑代码是可被测试的。要使得单元测试容易写，或者说代码容易被测，其实很重要的一个部分就是被测代码本身是容易被测的，也就是说在设计和编写代码的时候就应该先想到相好如何单元测试，甚至有人提出可以先写单元测试，再写具体被测代码。因为一个接口或者称为单元在被设计好后，它实现就确定了，实际效果也确定了。这种方式被称作测试驱动开发  。而对于已经写好的代码，很大程度上不好测试，有一种方式是测试性重构，就是为了更好的测试而进行重构。这些一定程度上来说并了解这些框架更重要，有意向可以，可以查阅有关两本书《单元测试的艺术第版》《测试模式》
参考
《单元测试的艺术  第版  》《  测试模式 》 如何测试  代码  单元测试    往事回顾
连接池是一个很好的设计，通过将大量短连接转化为少量的长连接，从而提高整个系统的吞吐率。但是当跟事务一起使用时，如果使用方式不恰当时，就会发生一些奇怪的事。之前写过一篇文章专门讲述了遇到的一件奇怪的事情，详见《当连接池遇上事务一：神秘的幽灵锁》。
简单地说，《神秘的幽灵锁》一文，问题出在上层业务使用公共库时没意识到底层的连接池，导致使用方式不当。在上层看来是：
开启事务执行
而实际底层实现是：
获取一个连接开启事务扔回连接池获取一个连接执行扔回连接池获取一个连接扔回连接池。
这个过程无法保证每次拿到的都是同一个连接，也就存在了很大的隐患。当业务接口异常退出时，由于没有执行或的连接已经被放回连接池，导致该带状态的连接没有被释放，并且进一步影响到该连接后续操作过的表。
解决方案是修改所有使用事务的接口，在事务结束之前不能将连接放回连接池。但是由于改动量较大，在全部接口修改完成之前，先对可能导致接口退出的异常进行处理，避免异常情况的发生。这样也正常稳定地运行了一段时间，没有再发生之前的问题。
直到……
 非阻塞也来搞怪
 非阻塞的背景
之前说过，项目组使用作为 ，当需要执行调用时，早期很自然地选择了成熟的库。库是的一个开源库，对于常用的功能都能很好的满足，包括直接调用、代理转发、超时时间设置等。但是的库大多数阻塞调用的，对于这样一个异步非阻塞的高性能服务器来说，阻塞的调用对对整体性能造成致命的伤害。
因此，近期正在使用非阻塞的库来替换库。是的一个第三方开源调用的实现，采用了与一致的风格，支持直接调用、反向代理、超时时间设置等特性，最重要的，它是非阻塞的。
 调用方式居然影响到
按理说，替换库跟不应该有任何关系。阻塞与非阻塞强调的是调用方，只要保证替换库前后，对于同一个调用，被调用方收到的请求参数和请求方法完全一致即可。被调接口不应该也不能感知调用方使用的是阻塞还是非阻塞调用。
但是，奇怪的事情又双叒叕发生了……
替换库为非阻塞的之后，在页面配置时必现错误后续定位是引起的。奇怪的是，使用时错误必现，而恢复后则不会发生！！
 消失的记录
为了定位，在平台接口内加了很多日志。定位的结果居然是，平台接口往异步任务表插入一条记录，插入成功并且获取到一个自增长的任务 ，但是当之后再次查询该任务状态时，发现任务为的记录并不存在。并且，之后再往表插入记录，自增长的任务居然跳过了，直接是。
接口的日志和的任务，都证明了任务为的记录曾经存在过，但是从数据库中却找不到这条记录的任何踪迹。我把这叫做“消失的记录”。
 事物是普遍联系滴
奇怪的事情屡次发生，我又开始了艰辛的探索之路。这一次，我需要把两个看起来不相关的东西调用方式和联系起来。这很艰难，我还是根据现有的线索一步步往前推，看看究竟能走到哪。接下来还是以“提问解答”的方式进行。
 记录会不会是被删除了？
遇到消失的记录，首先的怀疑是，记录会不会被删除了？
于是对该接口代码进行审阅该接口是其他同事开发的。审阅的结果令人失望，所有代码都是那么的正常，连让人怀疑的地方都没有。于是又把所有代码都搜索了一遍，居然没找到有删除任务表的地方。至于第三方脚本删除，从时间上和删除记录的选择性上看，应该是不可能的。
当然，为了验证我的判断，解析了，发现任务为的记录压根就没有插入过，更没有被删除过。
记录被删除的可能，排除！
 记录是不是插入失败了？
既然从看，记录没有被插入过，那么接口日志为什么显示获得了自增长的任务 呢？一个合理的怀疑是，在获得自增长之后，因为某个未知的原因导致插入失败了。查看文档，确实在插入失败的情况下，仍然可能会占用一个自增长。
那么是否是插入失败了呢？因为接口日志显示的是插入成功并且没有发生任何错误，怀疑插入失败就是怀疑库有问题。。没事，咱有怀疑精神，确认就是了。于是又开始阅读库的源码了。源码并不复杂，确认了只有 返回正常时，库才会返回正常。 我还是信得过的，嘿嘿嘿。
也就是说，记录确实是插入成功了！
 插入成功的记录为什么没有？
有了上一次《神秘的幽灵锁》的经验，这一次我很快意识到可能是因为事务！在事务内，接口认为插入成功了，但是后面事务了，所以导致没有写入。那么，这一切就解释的通了。
因为平台接口没有使用事务，只有业务接口使用了，所以只能是跨接口影响。于是，我赶紧搜索的错误日志，希望找到上次一样的“   ”异常。但是很遗憾，这次所有接口都没有异常退出。
这条路到这里走到了尽头。。
 调用方式为什么会跟事务扯上关系？
既然从本身出发的路走不下去，那就从调用方式思考。
替换为，从请求的功能上看是完全等价的，唯一的不同在于调用方式从阻塞变成了非阻塞。也就是说，非阻塞调用导致了连接的混用，平台接口拿到了业务接口开启了事务的连接。
为了验证这个猜想，我再次查看的文档，找到了一个函数__，该函数返回连接被使用的次数。通过在业务接口和平台接口加上日志打印__的结果，确认了我的猜想：业务接口调用了平台接口，当使用时，平台接口第一次__的结果是，说明是新创建的连接；而使用时，平台接口第一次__的结果是业务接口调用平台接口前__的结果加，说明平台接口拿到了业务接口的同一个连接。
那么，非阻塞在这个过程中究竟起到什么作用呢？我百思不得其解，直到我看到了这么一句话：

                          

重点是“   ”！也就是说，的连接池是级别的！！
使用时，因为阻塞，所以新的请求不会被分配到业务请求相同的上，也就是说，开启了事务的连接，不会被其他请求使用，因为根本就没有其他请求会使用这个的连接池！
但是换成非阻塞的之后，业务接口发起请求后，该仍然可以接受新的请求，并且非阻塞内部接口调用类似于子查询，在看来就是同一个请求，所以必然分配到同一个。被调用的平台接口很自然的拿到了开启事务的连接，并往任务表成功插入了一条记录任务为。而在平台接口之后，因为该连接超过了时间已经被释放，事务没有被提交，再次获取连接查询时，就查不到刚才插入的记录了，从而造成“消失的记录”。
进一步推想，如果时间没超过时间，那么也是会有问题的。这次不会出现消失的记录，异步任务记录插入成功，但是由于该连接已开启了事务，会导致任务表被加上行锁和间隙锁，从而导致任务处理等锁而无法处理任务，任务最终还是会超时失败。
 那些年，我们那一如既往的幸运
“消失的记录”问题总算搞清楚了，现在再回顾一下，在《神秘的幽灵锁》一文，我说过我们使用“连接池事务”的方式一直是错误的，但是却很幸运地没发生过问题，其根本原因就在于我们使用了阻塞的请求库。阻塞的方式导致我们的连接池同一时刻只有一个请求在使用，也就避免了接口间相互影响的可能。而如今，非阻塞的，把我们的运气用完了，所以到了需要处理这个问题的时候了。
问题的处理方式之前已经说过，就是修改事务接口用连接池的方式，在事务结束之前不能将连接放回连接池。但这个改动量较大，在全部修改完成之前，只怕是不能上线了。导语
 内存是后台开发人员，需要深入了解的计算机资源。合理的使用内存，有助于提升机器的性能和稳定性。本文主要介绍  内存组织结构和页面布局，内存碎片产生原因和优化算法， 内核几种内存管理的方法，内存使用场景以及内存使用的那些坑。从内存的原理和结构，到内存的算法优化，再到使用场景，去探寻内存管理的机制和奥秘。
一、走进  内存
、内存是什么？
内存又称主存，是  能直接寻址的存储空间，由半导体器件制成内存的特点是存取速率快

、内存的作用
暂时存放  的运算数据硬盘等外部存储器交换的数据保障  计算的稳定性和高性能

二、  内存地址空间
、 内存地址空间  内存管理全貌

、内存地址——用户态内核态

用户态： 运行于用户态的代码则要受到处理器的诸多
内核态： 在处理器的存储保护中，核心态
用户态切换到内核态的  种方式：系统调用、异常、外设中断
区别：每个进程都有完全属于自己的，独立的，不被干扰的内存空间；用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用；内核态线程共享内核地址空间；


、内存地址—— 地址转换

 是一种硬件电路，它包含两个部件，一个是分段部件，一个是分页部件
分段机制把一个逻辑地址转换为线性地址
分页机制把一个线性地址转换为物理地址


、内存地址——分段机制
 段选择符

为了方便快速检索段选择符，处理器提供了  个分段寄存器来缓存段选择符，它们是：  和 
段的基地址 ：在线性地址空间中段的起始地址
段的界限：在虚拟地址空间中，段内可以使用的最大偏移量

 分段实现

逻辑地址的段寄存器中的值提供段描述符，然后从段描述符中得到段基址和段界限，然后加上逻辑地址的偏移量，就得到了线性地址


、内存地址——分页机制 位

分页机制是在分段机制之后进行的，它进一步将线性地址转换为物理地址
 位页目录， 位页表项，  位页偏移地址
单页的大小为 


、用户态地址空间


：代码段可执行代码、字符串字面值、只读变量
：数据段，映射程序中已经初始化的全局变量
 段：存放程序中未初始化的全局变量
：运行时的堆，在程序运行中使用  申请的内存区域
：共享库及匿名文件的映射区域
：用户进程栈

、内核态地址空间


直接映射区：线性空间中从  开始最大  的区间，为直接内存映射区
动态内存映射区：该区域由内核函数  来分配
永久内存映射区：该区域可访问高端内存
固定映射区：该区域和  的顶端只有  的隔离带，其每个地址项都服务于特定的用途，如： _ 等  

、进程内存空间

用户进程通常情况只能访问用户空间的虚拟地址，不能访问内核空间虚拟地址
内核空间是由内核负责映射，不会跟着进程变化；内核空间地址有自己对应的页表，用户进程各自有不同额页表


三、  内存分配算法
内存管理算法——对讨厌自己管理内存的人来说是天赐的礼物
、内存碎片
    基本原理

产生原因：内存分配较小，并且分配的这些小的内存生存周期又较长，反复申请后将产生内存碎片的出现
优点：提高分配速度，便于内存管理，防止内存泄露
缺点：大量的内存碎片会使系统缓慢，内存使用率低，浪费大

 如何避免内存碎片

少用动态内存分配的函数尽量使用栈空间
分配内存和释放的内存尽量在同一个函数中
尽量一次性申请较大的内存，而不要反复申请小内存
尽可能申请大块的  的指数幂大小的内存空间
外部碎片避免——伙伴系统算法
内部碎片避免—— 算法
自己进行内存管理工作，设计内存池

、伙伴系统算法——组织结构
    概念

为内核提供了一种用于分配一组连续的页而建立的一种高效的分配策略，并有效的解决了外碎片问题
分配的内存区是以页框为基本单位的

    外部碎片

外部碎片指的是还没有被分配出去不属于任何进程，但由于太小了无法分配给申请内存空间的新进程的内存空闲区域

    组织结构

把所有的空闲页分组为  个块链表，每个块链表分别包含大小为 ，，，，，，，，， 和  个连续页框的页块。最大可以申请  个连续页，对应  大小的连续内存


、伙伴系统算法——申请和回收
    申请算法

申请  个页块存储空间，如果  对应的块链表有空闲页块，则分配给应用
如果没有空闲页块，则查找   对应的块链表是否有空闲页块，如果有，则分配  块链表节点给应用，另外  块链表节点插入到  对应的块链表中
如果   块链表中没有空闲页块，则重复步骤 ，直到找到有空闲页块的块链表
如果仍然没有，则返回内存分配失败

    回收算法

释放  个页块存储空间，查找  个页块对应的块链表，是否有与其物理地址是连续的页块，如果没有，则无需合并

 

如果有，则合并成  的页块，以此类推，继续查找下一级块链接，直到不能合并为止


    条件

两个块具有相同的大小
它们的物理地址是连续的
页块大小相同

、如何分配  以上内存？
    为何限制大块内存分配

分配的内存越大 失败的可能性越大
大块内存使用场景少

    内核中获取  以上大内存的方法

修改 _ 重新编译内核
内核启动选型传递=参数 如=，预留部分内存；然后通过
__ 和 _ 将预留的内存映射到模块中。需要修改内核启动参数 无需重新编译内核 但这种方法不支持  架构 只支持   等非  架构
在 _ 中 _ 函数之前调用 __ 函数预分配大块内存 需要重新编译内核
 函数，内核代码使用它来分配在虚拟内存中连续但在物理内存中不一定连续的内存

、伙伴系统——反碎片机制
    不可移动页

这些页在内存中有固定的位置，不能够移动，也不可回收
内核代码段，数据段，内核  出来的内存，内核线程占用的内存等

    可回收页

这些页不能移动，但可以删除。内核在回收页占据了太多的内存时或者内存短缺时进行页面回收

    可移动页

这些页可以任意移动，用户空间应用程序使用的页都属于该类别。它们是通过页表映射的
当它们移动到新的位置，页表项也会相应的更新

、 算法——基本原理
    基本概念

 所使用的  分配器的基础是   为  操作系统首次引入的一种算法
它的基本思想是将内核中经常使用的对象放到高速缓存中，并且由系统保持为初始的可利用状态。比如进程描述符，内核中会频繁对此数据进行申请和释放

    内部碎片

已经被分配出去的的内存空间大于请求所需的内存空间

    基本目标

减少伙伴算法在分配小块连续内存时所产生的内部碎片
将频繁使用的对象缓存起来，减少分配、初始化和释放对象的时间开销
通过着色技术调整对象以更好的使用硬件高速缓存

、 分配器的结构

由于对象是从  中分配和释放的，因此单个  可以在  列表之间进行移动
_ 列表中的  是进行回收的主要备选对象
 还支持通用对象的初始化，从而避免了为同一目而对一个对象重复进行初始化


、 高速缓存
    普通高速缓存

 分配器所提供的小块连续内存的分配是通过通用高速缓存实现的
通用高速缓存所提供的对象具有几何分布的大小，范围为  到  字节。
内核中提供了  和  两个接口分别进行内存的申请和释放

    专用高速缓存

内核为专用高速缓存的申请和释放提供了一套完整的接口，根据所传入的参数为具体的对象分配  缓存
__ 用于对一个指定的对象创建高速缓存。它从 _ 普通高速缓存中为新的专有缓存分配一个高速缓存描述符，并把这个描述符插入到高速缓存描述符形成的 _ 链表中
__ 在其参数所指定的高速缓存中分配一个 。相反， __ 在其参数所指定的高速缓存中释放一个 

、内核态内存池
    基本原理

先申请分配一定数量的、大小相等一般情况下 的内存块留作备用
当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存
这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升

    内核 

_ 创建内存池对象
_ 分配函数获得该对象
_ 释放一个对象
_ 销毁内存池


、用户态内存池
     实例

、 内存
    什么是 

直接内存访问是一种硬件机制，它允许外围设备和主内存之间直接传输它们的  数据，而不需要系统处理器的参与

     控制器的功能

能向  发出系统保持信号，提出总线接管请求
当  发出允许接管信号后，负责对总线的控制，进入  方式
能对存储器寻址及能修改地址指针，实现对内存的读写操作
能决定本次  传送的字节数，判断  传送是否结束
发出  结束信号，使  恢复正常工作状态

     信号

： 请求信号。是外设向  控制器提出要求， 操作的申请信号
： 响应信号。是  控制器向提出  请求的外设表示已收到请求和正进行处理的信号
： 控制器向  发出的信号，要求接管总线的请求信号。
： 向  控制器发出的信号，允许接管总线的应答信号：


四、 内存使用场景
    的时代过去了吗？，内存再充足也不可任性使用。
、内存的使用场景

 管理
、内存池
用户态内存使用、 文件映射、共享内存
程序的内存 栈、堆、、
内核和用户态的数据传递__、__
内存映射硬件寄存器、保留内存
 内存

、用户态内存分配函数

 是向栈申请内存因此无需释放
 所分配的内存空间未被初始化，使用  函数的程序开始时内存空间还没有被重新分配 能正常运行，但经过一段时间后内存空间已被重新分配 可能会出现问题
 会将所分配的内存空间中的每一位都初始化为零
 扩展现有内存空间大小     如果当前连续内存块足够  的话，只是将  所指向的空间扩大，并返回  的指针地址。这个时候  和  指向的地址是一样的     如果当前连续内存块不够长度，再找一个足够长的地方，分配一块新的内存，，并将  指向的内容  到 ，返回 。并将  所指向的内存空间删除
 将一个文件或者其它对象映射进内存，多进程可访问

、内核态内存分配函数



函数
分配原理
最大内存
其他




___
直接对页框进行操作

适用于分配较大量的连续物理内存


__
基于  机制实现

适合需要频繁申请释放相同大小内存块时使用



基于 __ 实现

最常见的分配方式，需要小于页框大小的内存时可以使用



建立非连续物理内存到虚拟地址的映射

物理不连续，适合需要大内存，但是对地址连续性没有要求的场合


__
基于__ 实现

适用于  操作



实现已知物理地址到虚拟地址的映射

适用于物理地址已知的场合，如设备驱动


_
在启动  时，预留一段内存，内核看不见

小于物理内存大小，内存管理要求较高



、 申请内存

调用  函数时，它沿 __ 连接表寻找一个大到足以满足用户请求所需要的内存块



__ 连接表的主要工作是维护一个空闲的堆空间缓冲区链表
如果空间缓冲区链表没有找到对应的节点，需要通过系统调用 _ 延伸进程的栈空间


、缺页异常

通过 __ 申请一个或多个物理页面
换算  在进程  映射中所在的  地址
将  对应的  设置为物理页面的首地址
系统调用：—申请内存小于等于 ，_—申请内存大于 


、用户进程访问内存分析

用户态进程独占虚拟地址空间，两个进程的虚拟地址可相同
在访问用户态虚拟地址空间时，如果没有映射物理地址，通过系统调用发出缺页异常
缺页异常陷入内核，分配物理地址空间，与用户态虚拟地址建立映射


、共享内存
    原理

它允许多个不相关的进程去访问同一部分逻辑内存
两个运行中的进程之间传输数据，共享内存将是一种效率极高的解决方案
两个运行中的进程共享数据，是进程间通信的高效方法，可有效减少数据拷贝的次数


     接口

 创建共享内存
 启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间
 将共享内存从当前进程中分离

五、 内存使用那些坑
、 内存泄露

在类的构造函数和析构函数中没有匹配地调用  和  函数



没有正确地清除嵌套的对象指针
没有将基类的析构函数定义为虚函数
当基类的指针指向子类对象时，如果基类的析构函数不是 ，那么子类的析构函数将不会被调用，子类的资源没有得到正确释放，因此造成内存泄露
缺少拷贝构造函数，按值传递会调用拷贝构造函数，引用传递不会调用
指向对象的指针数组不等同于对象数组，数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间
缺少重载赋值运算符，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露

、 野指针

指针变量没有初始化
指针被  或  后，没有设置为 
指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针
访问空指针需要做空判断
 无法获取数组的大小
试图修改常量，如： ==  

、 资源访问冲突

多线程共享变量没有用  修饰
多线程访问全局变量未加锁
全局变量仅对单进程有效
多进程写共享内存数据，未做同步处理
 内存映射，多进程不安全  

、 迭代器失效

被删除的迭代器失效
添加元素_ 等、删除元素导致顺序容器迭代器失效

错误示例：删除当前迭代器，迭代器会失效 

正确示例：迭代器  时，需保存下一个迭代器

、  智能指针

_ 替换为 _



使用 _ 初始化一个 _



_ 智能指针助手

原理分析：

数据结构：

使用方法：
   获取所管理的对象的强引用指针  检测所管理的对象是否已经释放  访问智能指针对象
、  更小更快更安全

 原子数据类型 多线程安全
 定长数组开销比  小和  不同的是  的长度是固定的，不能动态拓展
  瘦身 __：将  减少为于  相同的大小
__ 是单链表 是双链表，只需要顺序遍历的场合，_ 能更加节省内存，插入和删除的性能高于 
_、_

用  实现的无序的容器，插入、删除和查找的时间复杂度都是 ，在不关注容器内元素顺序的场合，使用  的容器能获得更高的性能
六、 如何查看内存

系统中内存使用情况：  



进程的内存使用情况：
查询内存总使用率：



查询进程  和内存使用占比：



虚拟内存统计：



进程消耗内存占比和排序：  – 



释放系统内存缓存：_

       _
         _
         _上一篇文章提到了在服务器槡搭建服务来实现内网穿透因为我的服务器和本地环境都是的缘故故直接完成了客户端的链接那么在下如何使用搭建好的服务呢以及在配置和客户端链接的时候的指令有哪些呢下面给大家一一道来

下的编译与配置
首先肯定是配置下的的客户端。
其实和编译客户端一样，只需要一条指令就可以了
在目录下
 = =  
编译完成后，会自动生成一个名为_的文件夹，里面有一个的文件。同样配置好之后，执行命令，这里换成了下的命令行执行。
_ “

___ 

内容
执行指令：
   = = 
这里就成功的将端口转发出去了。
下面再说一下，如何外网访问端口的
  =   
端口
  =   

使用链接：
参考属性列表：


相关推荐
【腾讯云的种玩法】轻松搭建内网穿透服务
精通配置以及问题解决
高性能高稳定云服务器

更多技术文章可以前往说如今，协同过滤推荐 技术已广泛应用于各类推荐系统中，其通常分为两类，一种是基于用户的协同过滤算法 ，它是根据用户对物品的历史评价数据，如喜欢、点击、购买等，计算不同用户之间的相似度，在有相同喜好的用户间进行物品推荐，例如将跟我有相同电影爱好的人看过的电影推荐给我。
另一种是基于物品的协同过滤算法 ，它是根据用户对物品的历史评价数据，计算物品之间的相似度，用户如果喜欢物品，那么可以给用户推荐跟物品相似的其他物品，例如如果我们在购物网站上买过尿片，第二天你再到购物网站上浏览时，可能会被推荐奶瓶。更多关于 和 的阐述请参考《推荐算法之协同过滤》文章。然而，在用户评分不足的情况下，上述两种方法就不是很好使了，近年来，基于模型的推荐算法交替最小二乘在成功应用并取得显著效果提升，使用机器学习算法建立用户和物品间的相互作用模型，进而去预测新项。
基本原理
用户对物品的打分行为可以表示成一个打分矩阵，例如下表所示：

矩阵中的打分值 表示用户对物品的打分，其中表示用户没有打分，这也就是要通过机器学习的方法去预测这个打分值，从而达到推荐的目的。
模型抽象
按照 的思想，的行向量对应每个用户，按照 的思想，的列向量对应每个物品。 的核心思想是，将用户和物品都投影到维空间，也就是说，假设有个隐含特征，至于个隐含特征具体指什么不用关心，将每个用户和物品都用维向量来表示，把它们之间的内积近似为打分值，这样就可以得到如下近似关系：

其中，为打分矩阵，个用户，个物品，为用户对隐含特征的偏好矩阵，为物品对隐含特征的偏好矩阵。
上述模型的参数就是矩阵和，即求解出和我们就可以重现打分矩阵，填补原始打分矩阵中的缺失值。
显示反馈代价函数
要求解上述模型中的和 ，那么就需要一个代价函数来衡量参数的拟合程度，如果有比较明确的显式反馈打分数据，那么可以比较重构出来的打分矩阵与实际打分矩阵，即得到重构误差，由于实际打分矩阵有很多缺失值，所以仅计算已知打分的重构误差，下面函数为显示反馈代价函数。

其中，表示用户对物品的打分，为矩阵的第行 ， 为矩阵的第列，为正则项系数。
隐式反馈代价函数
很多情况下，用户并没有明确反馈对物品的偏好，需要通过用户的相关行为来推测其对物品的偏好，例如，在视频推荐问题中，可能由于用户就懒得对其所看的视频进行反馈，通常是收集一些用户的行为数据，得到其对视频的偏好，例如观看时长等。通过这种方式得到的偏好值称之为隐式反馈值，即矩阵为隐式反馈矩阵，引入变量表示用户对物品的置信度，如果隐式反馈值大于，置信度为，否则置信度为。

但是隐式反馈值为并不能说明用户就完全不喜欢，用户对一个物品没有得到一个正的偏好可能源于多方面的原因，例如，用户可能不知道该物品的存在，另外，用户购买一个物品也并不一定是用户喜欢它，所以需要一个信任等级来显示用户偏爱某个物品，一般情况下，越大，越能暗示用户喜欢某个物品，因此，引入变量，来衡量的信任度，其中为置信系数。

那么，代价函数则变成如下形式：

算法
无论是显示反馈代价函数还是隐式反馈代价函数，它们都不是凸的，变量互相耦合在一起，常规的梯度下降法可不好使了。但是如果先固定求解，再固定求解 ，如此迭代下去，问题就可以得到解决了。

那么固定一个变量求解另一个变量如何实现呢，梯度下降？虽然可以用梯度下降，但是需要迭代，计算起来相对较慢，试想想，固定求解，或者固定求解 ，其实是一个最小二乘问题，由于一般隐含特征个数取值不会特别大，可以将最小二乘转化为正规方程一次性求解，而不用像梯度下降一样需要迭代。如此交替地解最小二乘问题，所以得名交替最小二乘法，下面是基于显示反馈和隐式反馈的最小二乘正规方程。
显示反馈
固定求解
 
更直观一点，每个用户向量的求解公式如下：

其中，为矩阵的第行的转置，为矩阵的第行的转置。
固定求解

更直观一点，每个物品向量的求解公式如下：

其中， 为矩阵的第列，为矩阵的第列。
隐式反馈
固定求解

更直观一点，每个用户向量的求解公式如下：

其中，为对角矩阵。
固定求解

更直观一点，每个物品向量的求解公式如下：

其中，为对角矩阵。
 分布式实现
上述算法虽然明朗了，但是要将其实现起来并不是信手拈来那么简单，尤其是数据量较大，需要使用分布式计算来实现，就更加不是那么地容易了。下面详细阐述 是如何完成分布式实现的。为了更加直观的了解其分布式实现，下面用前面的打分矩阵作为例子，如下图所示。

由前面的原理介绍可知，按照显示反馈模型，固定求解，每个物品对隐含特征的偏好向量由以下公式得到：

计算时，只需要计算得到和 ，再利用库即可解方程，初次迭代计算时，随机初始化矩阵，假设得到如下初始形式：

假如求解，由于只有 和对 有打分，那么只需基于和来计算，根据相关线性代数知识就可以得到：

有了这个基本求解思路后，考虑的维度为，可以在单机上完成上述求解，那么就可以在不同里完成不同物品的计算，实现分布式求解，由打分矩阵可以得到如下图所示的关系图。

基于上述思路，就是要想办法把有打分关联的  和  想办法放到同一个分区里，这样就可以在一个里完成对  的求解。首先对和以分区的方式分区，假设分区数均为，那么分区后的大致情况如下图所示， 和 在同一个分区中被求解，和在同一个分区中被求解。

上面的图仅为感性认识图，实际上手头仅有的数据就是打分矩阵，可以通过一个表示打分矩阵，中的每条记录为  形式，由于是基于求解，把称之为，称之为，按照和的分区方式，将重新分区，得到的为，其中的每条记录为  形式，为和对应的分区组成的二元组，包含一个三元组  。对于前面的打分关系，原始打分矩阵重新分区如下图所示。

对于  来说，是要将自身信息发给不同的 ，对于  来说，是要接收来自不同  的信息，例如，要将发给、、，要接收和。那么基于上述重新分区后的打分，分别得到关于  的出口信息，以及  的入口信息，就可以通过将两者联系起来计算了。由于后面基于求，也需要求解关于  的入口信息，以及  的出口信息，所以一次性计算好并缓存起来。以计算  的入口信息和出口信息为例，在前面得到的重新分区后的基础上求解，如下图所示。

首先通过一个操作，将记录形式  转换为    ，其中为去重排序后，每个在其分区中的索引，最后根据做，合并相同对应的，合并过程中，对中的每个元素加上其对应的，这里做了一个优化，就是将和用一个编码表示，同时采用类似压缩编码的方式，进一步压缩和的对应关系。这样就按照  进行分区后，得到  的入口信息，即将跟  关联的  绑定在一起了。基于该入口信息，可以进一步得到  的出口信息，如下图所示。

在基础上根据和的对应关系，通过操作将    形式的记录转换为 得到，其中是一个二维数组，有行，每一行为所在中的索引，意为当前应该往每个发送哪些用户信息。
同理，在基础上初始化用户信息，得到，如下图所示，其中、、为随机初始化的向量。

接着对和做就可以模拟发送信息了，中保存了应该往哪里发送的信息，中保存了用户信息，即一个掌握了方向，一个掌握了信息，如下图所示：

完成了从  到  的信息发送，后面就是基于  的入口信息来收集来自不同  的信息了，计算  的入口信息跟计算  的入口信息一样，只是先要把打分数据的和交换一下，如下图所示。

将与前面的做，即可将具有相同的记录拉到一起，中包含来自  的信息，包含了与的对应关系以及打分数据，针对每个  找到所有给它发送信息的 ，进而套最小二乘正规方程计算得到。

得到后可以以同样的方法基于求解，如此交替求解，直到最大迭代次数为止。
总结
从基本原理上来看应该是很好理解的，但是要通过分布式计算来实现它，相对而言还是较为复杂的，本文重点阐述了 库中的实现，要看懂以上计算流程，请务必结合源代码理解，凭空理解上述流程可能比较困难，在实际源码实现中，使用了很多优化技巧，例如使用在分区中的索引代替实际或，实现代替，使用数组等连续内存数据结构避免由于过多对象造成 后的内存碎片等。导语
年“云未来”峰会即将在深圳盛大举行，本次峰会   技术专场将在月日下午举行。  专场给各家提供了针对  应用以及背后填坑之路作深度探讨的机会。现在让我们一起回顾下去年各位嘉宾在在现场分享了哪些云上的心得体会以及 云原生架构上的亲身实践。
本文是 奥思数据创始人、知名  布道师李明宇在年腾讯“云未来”峰会   专场有关《一个应用的云化之路》分享的回顾。
李明宇：《一个应用的云化之路》
奥思数据创始人，知名  布道师李明宇也来到现场进行《一个应用的云化之路》的主题分享，他通过一家工厂的扩张带来的系统架构管理问题，演示在云计算时代，如何使用   的模式进行架构重构，通过利用云的特性，对工厂进行资源规划、新生产流程管理等技术架构的重构。

某个集团下的  多个工厂，其投入产出比不够优化。那么该如何优化投入产出比？可以通过数据分析的手段找出问题的关键点。于是，这家工厂开发了一个数据分析软件，部署到各个工厂。

该软件架构用一个基于数据库的集成框架，按照各个厂的生产流程，将多个算法模块集成起来。将这个的应用开始做试点和推广，安装到各个工厂。一开始这个应用比较简单只有到个算法，试点也比较少，在试点的过程中感觉良好。于是，对其进行推广，为了丰富软件的功能，满足客户不同的需求，增加到到个算法，这期间就出现了频出、迭代周期变长、难以维护、新功能无法实现、版本混乱、部署实施成本高、资源规划等问题。

为了解决这些问题，使用 的模式对其进行架构重构，将算法模块进行了模块化、集成构架使用   服务编排工具将几个算法串起来、部署实施通过镜像  。

利用云的个特性，使用  解决结构化数据存储问题、使用   解决文件存储问题、使用  解决资源规划问题、利用镜像的更新解决算法的更新问题、利用新的   代替新生产流程。

以上所举的例子虽然不算是小团队，但是在解决软件部署、升级、维护中遇到的一系列问题，我们确实利用了云的手段，  技术手段解决了很多问题，节省了大量的人力资源并且解决了人力无法处理的问题。最后，李明宇还提到在   实践过程中还收获了教训，  虽然看起来很完美，但是在实践的过程中需要更多的考虑，或是说很多问题我们之前是没有考虑到的。所以提出一下几个需要注意的问题：
第一，虚机的  和实际服务消耗资源的比例过高，但是大多数   版本不支持 ；
第二，图形化是一个大坑；
第三，循环逻辑不便于实现。

最后，李明宇还提到了后续的工作，第一个是能不能用  替代虚拟机；第二个就是能不能实现 。

相关推荐云时代程序员的社会责任和机会一张图看懂位置大数据分布
什么是热力图
热力图 ，是一种简单但非常直观的信息展示方式，平台里的一个重要的应用服务。最早是在年由软件设计师 提出的。最初用来以图示的形式展示金融市场信息。
经过多年的演进发展，热力图被广泛用于展示网站流量数据，包括链接点击分布和网页浏览分布，为网站的网页优化提供直观的参考依据，提高网站的用户体验。
近几年，随着大数据的兴起，热力图越来越多的被应用在地理位置信息的展示上。热力图的展示方式也由最初的矩形色块加颜色编码发展为颜色经过平滑模糊处理的热力图谱。
地理信息系统中的热力图是以特殊的高亮形式展示某种现象聚集程度的图示，多用来展示用户或店铺等所在地理区域的分布。最早于年作为研究模型在微软内部发布。
随着的发展，地理位置相关信息的爆发，热力图的应用范围得到了极大的扩展。它作为数据可视化的一种方法，适用于展现地理对象某一特征的空间分布态势。比如人群或者店铺的分布、密度以及变化趋势。它通过颜色的变化程度，直观反映热点分布。如图是某一时间点故宫博物院的游客分布热力图。
▲图 游客分布热力图
热力图的绘制方式
热力图关注区域分布，它将一系列离散的点映射为颜色变化的图像，展示的时候不需要坐标轴，其背景通常是地图或者图片。
热力图的绘制有以下两种方法。采用简单叠加法，计算出每个点对应的所有数据之和，将其作为该点的数值，再映射成相应的颜色绘制到显示区域。但是通过这种方法得到的热力图粒度太粗，并不好看。采用辐射叠加法，根据每个点的数据、辐射半径对所有数据点进行计算得到每个点的密度值，再根据配色矩阵计算出每个密度值对应的颜色进行绘制。这种方法类似雨滴落到池塘里，每个雨滴落下的位置和速度不同，落到池塘里后产生涟漪的形状和大小也不一样，这些涟漪相互影响形成了水面上雨滴分布的“热力图”。
地理信息系统中的热力图
地理信息系统中，热力图多用来展示区域聚集信息，比如：景点的游客分布密度、某一区域内店铺的分布等。地理信息系统中，热力图的生成通常由服务端和客户端配合完成，如图。
▲图 热力图生成系统
服务端负责采集数据，比如定位数据、店铺位置、车辆位置等数据。采集后的数据经过处理，生成既定格式的数据保存在存储系统中。同时，服务端需要提供数据查询的接口，供客户端查询相应数据。
以腾讯位置服务提供的城市热力图为例，这些数据来自使用了腾讯位置服务的应用，比如微信、手机、腾讯地图、腾讯新闻、大众点评、滴滴出行等。腾讯位置服务每天上百亿次的定位请求量保证了城市热力数据的准确性。服务端采集到这些定位数据后通过数据挖掘计算出某一区域的实时人数。
客户端在展示热力图的时候，首先需要根据既有信息向服务端查询，获取数据后计算各点的密度，然后根据配色矩阵生成各点的色值，最终生成热力图。
计算热力图各点密度时，通常采用下面的方法。首先，将显示区域分为若干个离散的点。比如将显示区域分为个离散的点。接着，为每个离散的点建立一个“辐射区域”。通常使用圆形的“辐射区域”，以该点作为圆心，以该点在热力图上最远能影响到的距离作为半径。圆的范围即为该点能影响的区域。圆心的权重为，越靠近圆的边缘，权重越低，边缘的权重为。权重从圆心向边缘降低的程度可以根据实际要反映的数据采用相应的数学模型，比如线性递减、二次曲线递减等。
建立好“辐射区域”后，根据各点的数据，计算出其“辐射”到整个区域后每点的“辐射值”，再针对每个离散点计算其所有的“辐射值”之和得到该离散点的密度。
如果将这些密度映射到灰度图上，则密度越高的点灰度图越亮。也可以使用彩色的热力图来展示数据，显示效果更明快。此时需要一个彩色的配色矩阵来定义不同密度映射出的色值。比如，将的密度映射为如表所示的配色方案，从而生成彩色的热力图。▲ 表：热力图密度映射表
各点对应的颜色值计算出来后，就可以用相应的颜色绘制这些离散的点，生成一块一块的热力图，所有热力图连接起来形成整个区域的热力图。
渲染热力图时，渲染性能和热力图的分块关系密切。将区域划分为离散的点时，划分的越细，计算时需要处理的数据越多，计算越慢，但显示效果越好；反之区域划分越粗，计算时需要处理的数据越少，计算相对变快，但也在一定程度上牺牲了显示效果。
另一个影响热力图显示效果的因素是“辐射半径”。“辐射半径”设置的过小，每个点的数据只能影响到其附近很小的区域，热力图的显示粒度较粗。而“辐射半径”设置的过大，每个点的数据影响的范围过大，则会影响热力图中各个点的密度差异，降低各点之间的对比度。实际渲染热力图时应该根据所展示数据的特点合理分块，并设置合理的“辐射半径”。
小结
热力图作为地理信息系统中某种现象聚集度的直观展示方式，在城市规划、人口迁移、市政应急与决策、行业布局、商业建店、个人旅游出行、景区监控、等方面起了越来越重要的作用，是位置大数据服务中的重要组成。

本文来自： 公众号作者 |涂小刚编辑 | 顾乡  
通过文章“【教程】核心概念”我们知道，的核心是根据来实现的，任务调度则为核心实现的重要一环。的任务调度就是如何组织任务去处理中每个分区的数据，根据的依赖关系构建，基于划分，将每个中的任务发到指定节点运行。基于的任务调度原理，我们可以合理规划资源利用，做到尽可能用最少的资源高效地完成任务计算。
分布式运行框架
可以部署在多种资源管理平台，例如、等，本身也实现了一个简易的资源管理机制，称之为模式。由于工作中接触较多的是  ，不做特别说明，以下所述均表示  。部署在上有两种运行模式，分别为和模式，它们的区别仅仅在于 是运行在端还是端。如下图所示为部署在上，以模式运行的分布式计算框架。

其中蓝色部分是里的概念，包括、、和，其中和主要是负责与进行交互；作为应用程序的总控，负责分发任务以及监控任务运行状态；负责执行任务，并上报状态信息给，从逻辑上来看是进程，运行在其中的任务是线程，所以说的任务是线程级别的。通过下面的时序图可以更清晰地理解一个应用程序从提交到运行的完整流程。

提交一个应用程序，首先通过向请求启动一个，同时检查是否有足够的资源满足的需求，如果资源条件满足，则将的启动上下文，交给，并循环监控状态。
当提交的资源队列中有资源时，会在某个上启动进程，会单独启动后台线程，当启动后，会通过本地的连接，并开始向申请资源运行进程 一个对应与一个，当返回资源，则在对应的上启动。
线程主要是初始化对象，准备运行所需的上下文，然后一方面保持与的连接，通过申请资源，另一方面根据用户业务逻辑开始调度任务，将任务下发到已有的空闲上。
当向返回资源时，就尝试在对应的上启动进程，进程起来后，会向注册，注册成功后保持与的心跳，同时等待分发任务，当分发的任务执行完毕后，将任务状态上报给。
把资源申请的逻辑给抽象出来，以适配不同的资源管理系统，所以才间接地通过去和打交道。
从上述时序图可知，只管提交并监控的状态。对于的任务调度主要是集中在两个方面 资源申请和任务分发，其主要是通过、以及之间来完成，下面详细剖析任务调度每个细节。
任务调度总览
当起来后，则会根据用户程序逻辑准备任务，并根据资源情况逐步分发任务。在详细阐述任务调度前，首先说明下里的几个概念。一个应用程序包括、以及三个概念：

是以方法为界，遇到一个方法则触发一个；
是的子集，以宽依赖即为界，遇到做一次划分；
是的子集，以并行度分区数来衡量，分区数是多少，则有多少个。

的任务调度总体来说分两路进行，一路是级的调度，一路是级的调度，总体调度流程如下图所示。

 通过其操作，形成了血缘关系图，即，最后通过的调用，触发并调度执行。负责级的调度，主要是将切分成若干，并将每个打包成交给调度。负责级的调度，将给过来的按照指定的调度策略分发到上执行，调度过程中负责提供可用资源，其中有多种实现，分别对接不同的资源管理系统。有了上述感性的认识后，下面这张图描述了模式下在任务调度期间，、以及内部模块的交互过程。

初始化过程中，会分别初始化  以及。会启动一个服务与外界打交道，通过申请资源，并不断从中拿到合适的分发到执行。也会启动服务负责接收的心跳信息，监控的存活状况，并通知到。下面着重剖析负责的调度以及负责的调度。
级的调度
的任务调度是从切割开始，主要是由来完成。当遇到一个操作后就会触发一个的计算，并交给来提交，下图是涉及到提交的相关方法调用流程图。

由最终的和方法封装而成，将交给提交，它会根据的血缘关系构成的进行切分，将一个划分为若干，具体划分策略是，由最终的不断通过依赖回溯判断父依赖是否是款依赖，即以为界，划分，窄依赖的之间被划分到同一个中，可以进行式的计算，如上图紫色流程部分。划分的分两类，一类叫做，为最下游的，由方法决定，另一类叫做，为下游准备数据，下面看一个简单的例子。

由触发，该由和方法组成，根据之间的依赖关系从开始回溯搜索，直到没有依赖的，在回溯搜索过程中，依赖，并且是宽依赖，所以在和之间划分，被划到最后一个，即中，依赖，依赖，这些依赖都是窄依赖，所以将、和划分到同一个，即中，实际执行的时候，数据记录会一气呵成地执行到的转化。不难看出，其本质上是一个深度优先搜索算法。
一个是否被提交，需要判断它的父是否执行，只有在父执行完毕才能提交当前，如果一个没有父，那么从该开始提交。提交时会将信息分区信息以及方法等序列化并被打包成交给，一个对应一个，另一方面监控的运行状态，只有丢失或者由于失败才需要重新提交失败的以调度运行失败的任务，其他类型的失败会在的调度过程中重试。
相对来说做的事情较为简单，仅仅是在层面上划分，提交并监控相关状态信息。则相对较为复杂，下面详细阐述其细节。
级的调度
 的调度是由来完成，由前文可知，将打包到交给，会将其封装为加入到调度队列中，负责监控管理同一个中的。前面也提到，初始化后会启动，它负责跟外界打交道，接收的注册信息，并维护的状态，所以说是管“粮食”的，同时它在启动后会定期地去“询问”有没有任务要运行，也就是说，它会定期地“问”“我有这么余量，你要不要啊”，在“问”它的时候，会从调度队列中按照指定的调度策略选择去调度运行，大致方法调用流程如下图所示。

调度策略
前面讲到，会先把给过来的封装成扔到任务队列里，然后再从任务队列里按照一定的规则把它们取出来在给过来的上运行。这个调度过程实际上还是比较粗粒度的，是面向的。
是以树的方式来管理任务队列，树中的节点类型为，叶子节点为，非叶子节点为，下图是它们之间的继承关系。

支持两种调度策略，一种是，也是默认的调度策略，另一种是。在初始化过程中会实例化，表示树的根节点，是类型。如果是采用调度策略，则直接简单地将按照先来先到的方式入队，出队时直接拿出最先进队的，其树结构大致如下图所示，保存在一个队列中。

在阐述调度策略前，先贴一段使用调度策略的应用程序代码，后面针对该代码逻辑来详细阐述调度的实现细节。
  {
   =
      = {
      = 

      = 
      _\\
       =  

      = 

      {
          = {
         
          = 
         
      }
    }

      {
          = {
         
          = 
          
         {  =   }
      }
    }

    
      {}
    
  }
}
上述应用程序中使用两个线程分别调用了方法，即有两个会并发提交，但是不管怎样，这两个被切分成若干后终究会被交到这里统一管理，其调度树大致如下图所示。

在出队时，则会对所有排序，具体排序过程是从根节点开始，递归地去排序子节点，最后合并到一个里，代码逻辑如下。
   = {
      =  
      = 
        {
       = 
    }
    
  }
使用调度策略时，上面代码中的的类型为，排序过程的比较是基于来比较的，每个要排序的对象包含三个属性 值正在运行的数、值、值，比较时会综合考量值，以及值。如果对象的大于它的，对象的小于它的，那么排在前面；如果、对象的都小于它们的，那么就比较与的比值，谁小谁排前面；如果、对象的都大于它们的，那么就比较与的比值，谁小谁排前面。整体上来说就是通过和这两个参数控制比较过程，可以做到不让资源被某些长时间给一直占了。
本地化调度
从调度队列中拿到后，那么接下来的工作就是按照一定的规则一个个取出给，再交给去发到上执行。前面也提到，封装了一个的所有，并负责管理调度这些。

在初始化过程中，会对按照级别进行分类，的有五种，优先级由高到低顺序：_指定的，_指定的主机节点，_无所谓，_指定的机架，满足不了的就随便调度。这五种级别存在包含关系，_包含_，_包含_，然而包含其他所有四种。初始化阶段在对分类时，根据的判断它属于哪个级别，属于_的同时也会被加入到_、_类别中，比如，一个的指定了在上执行，那么它属于对应的_类别，同时也把他加入到所在的主机对应的_类别，所在的主机的机架对应的_类别中，以及类别，这样在调度执行时，满足不了_，就逐步退化到_，_，。
在决定调度哪些时，是通过上面流程图中的方法来实现，为了尽可能地将调度到它的上，它采用一种延迟调度算法。方法原型如下，参数包括要调度任务的 、主机地址以及最大可容忍的级别。
 
       
       
       
     
延迟调度算法的大致流程如下图所示。

首先看是否存在对应的_类别的任务，如果存在，取出来调度，否则根据当前时间，判断是否超过了_类别最大容忍的延迟，如果超过，则退化到下一个级别_，否则等待不调度。退化到下一个级别_后调度流程也类似，看是否存在对应的_类别的任务，如果存在，取出来调度，否则根据当前时间，判断是否超过了_类别最大容忍的延迟，如果超过，则退化到下一个级别_，否则等待不调度，以此类推…。当不满足类别会选择等待，直到下一轮调度重复上述流程，如果你比较激进，可以调大每个类别的最大容忍延迟时间，如果不满足时就会等待多个调度周期，直到满足或者超过延迟时间退化到下一个级别为止。
失败重试与黑名单机制
除了选择合适的调度运行外，还需要监控的执行状态，前面也提到，与外部打交道的是，被提交到启动执行后，会将执行状态上报给，则告诉，找到该对应的，并通知到该，这样就知道的失败与成功状态，对于失败的，会记录它失败的次数，如果失败次数还没有超过最大重试次数，那么就把它放回待调度的池子中，否则整个失败。
在记录失败次数过程中，会记录它上一次失败所在的 和，这样下次再调度这个时，会使用黑名单机制，避免它被调度到上一次失败的节点上，起到一定的容错作用。黑名单记录上一次失败所在的 和，以及其对应的“黑暗”时间，“黑暗”时间是指这段时间内不要再往这个节点上调度这个了。
推测式执行
在启动后，还会启动一个后台线程专门负责推测任务的调度，推测任务是指对一个在不同的上启动多个实例，如果有实例运行成功，则会干掉其他上运行的实例。推测调度线程会每隔固定时间检查是否有需要推测执行，如果有，则会调用的去尝试拿资源运行推测任务。

检查是否有需要推测执行的逻辑最后会交到，采用基于统计的算法，检查是否需要推测执行，算法流程大致如下图所示。

首先会统计成功的数，当成功的数超过可通过参数控制时，再统计所有成功的的运行时间，得到一个中位数，用这个中位数乘以可通过参数控制得到运行时间门限，如果在运行的的运行时间超过这个门限，则对它启用推测。算法逻辑较为简单，其实就是对那些拖慢整体进度的启用推测，以加速整个即的运行。
资源申请机制
在前文已经提过，和起来后，通过申请资源，就是用来专门适配申请资源的，当申请到，会在相应上启动进程，其他事情就交给。早期版本只支持静态资源申请，即一开始就指定用多少资源，在整个应用程序运行过程中资源都不能改变，后来支持动态申请，用户不需要指定确切的数量，会动态调整的数量以达到资源利用的最大化。
静态资源申请
静态资源申请是用户在提交应用程序时，就要提前估计应用程序需要使用的资源，包括数_、每个上的数_、每个的内存_以及的内存_。
在估计资源使用时，应当首先了解这些资源是怎么用的。任务的并行度由分区数决定，一个有多少分区，就会有多少。每个默认占用一个，一个上的所有共享上的内存，一次并行运行的数等于__，如果分区数超过该值，则需要运行多个轮次，一般来说建议运行～轮较为合适，否则考虑增加_或_。由于一个的所有会共享内存_，所以建议_不宜过大。_的设置则需要综合每个分区的数据量以及是否有缓存等逻辑。下图描绘了一个应用程序内部资源利用情况。

动态资源申请
动态资源申请目前只支持到，即可以不用指定_，通过参数来控制。由于许多应用程序一开始可能不需要那么多或者其本身就不需要太多，所以不必一次性申请那么多，根据具体的任务数动态调整的数量，尽可能做到资源的不浪费。由于动态的调整会导致动态的添加与删除，如果删除，其上面的中间结果可能会丢失，这就需要借助第三方的了，如果是部署在上，则可以在上配置的，具体操作仅需做两点

首先在中加上如下配置：

__


_







将  包_拷贝到每台的_下，并重启所有的。当启用动态申请时，在初始化过程中会实例化，它是被用来专门控制动态申请逻辑的，动态申请是一种基于当前负载压力实现动态增删的机制。一开始会按照参数设置的初始数申请，然后根据当前积压的数量，逐步增长申请的数，如果当前有积压的，那么取积压的数和中的最小值作为数上限，每次新增加申请的为的次方，即第一次增加，第二次增加，第三次增加，…。另一方面，如果一个在一段时间内都没有运行，则将其回收，但是在 时，要保证最少的数，该值通过参数来控制，如果上有的数据，则永远不会被，以保证中间数据不丢失。

结语
本文详细阐述了的任务调度，着重讨论  的部署调度，剖析了从应用程序提交到运行的全过程。 算是中的一个大模块，它负责任务下发与监控等，基本上扮演了大脑的角色。了解 有助于帮助我们清楚地认识应用程序的运行轨迹，同时在我们实现其他系统时，也可以借鉴的实现。

相关推荐搭建下的开发环境【教程】核心概念踩坑记：初试前言
最近发现服务隔三差五就会挂掉，导致我的网站和爬虫都无法正常运作。自己的网站是基于，在做爬虫存取一些资料的时候也是基于，数据量一大了，它就有点受不了了，时不时会崩掉，虽然我自己有网站监控和邮件通知，但是好多时候还是需要我来手动连接我的服务器重新启动一下我的，这样简直太不友好了，所以，我就觉定自己写个脚本，定时监控它，如果发现它挂掉了就重启它。
好了，闲言碎语不多讲，开始我们的配置之旅。
运行环境：腾讯云   

编写脚本
首先，我们要编写一个脚本，脚本主要执行的逻辑如下：
显示进程状态，如果判断进程未在运行，那么输出日志到文件，然后启动服务，如果进程在运行，那么不执行任何操作，可以选择性输出监测结果。
可能大家对于脚本比较陌生，在这里推荐官方的脚本文档来参考一下
  编程基础
脚本的后缀为，在任何位置新建一个脚本文件，我选择在  目录下新建一个  文件。
执行如下命令：
 
 
 
进入到中，我们添加如下脚本内容：

   
     

 ``   
  

 ``  

其中   是监测服务的运行状态，  是将其结果输出到空文件，也就是不保存输出信息 是拿到上一条命令的运行结果，  是判断是否大于，后面则是输出时间到日志文件，然后启动，否则不启动保存好了，那么我们执行如下的命令，来测试一下。

贴心的命令文字版本：
  
  

   
 
       
    
 
 
        
   
 
       

嗯，编辑完了文件之后，我们首先要对其进行授权，增加可执行的权限。
   
然后运行脚本测试一下，显示正在运行。把关掉，运行脚本，便会检测到已关闭，然后重新启动了，再次运行，便会发现正常运行了。
修改日志输出
好，接下来我们把输出的内容保存到日志里。修改脚本文件如下

   
     

 ``     _
  

 ``    _

这样，每执行一次脚本，输出结果都会被保存到 _ 中了。
添加定时任务
好了，脚本可以顺利执行了，那么我们就需要定时调用一下这个脚本来运行了，我们需要用到 。
首先我们需要编辑一下调度表格，命令如下：
 
如果你是第一次编辑这个，他会让你选择文件打开方式，随便选一个数字就好了。
比如我们用打开的，我们就在它的最后一行添加下面的一句话即可。

文字版本：
     _
代表五分钟执行一次，后面的四个点依次代表了，小时，日，月，星期。如果想要时间长一些，比如一小时调度一次，那就设置一下后面第一个就好了。
好，保存一下，重启服务。
  
嗯，调度任务已经添加进去了，这样，每五分钟系统就会调用一下刚才写的那个脚本。
过一段时间，我们来看一下运行效果，嗯，监控跑的很顺利呐。

内容：
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
结语
这样，我们就实现了五分钟定时检测进程服务，妈妈再也不用担心我的网站会宕掉啦。年月日，腾讯发布了截止月日未经审核的财年第一季度综合业绩。财报发布后，腾讯董事会主席兼马化腾、总裁刘炽平、首席战略官詹姆斯·米歇尔 及罗硕瀚等公司高管召开了财报电话会议，解读财报要点，并回答分析师提问。
以下为问答环节主要内容：

花旗集团分析师艾丽西亚·雅普 ：我的问题与公司云计算业务和人工智能有关。我们注意到腾讯正加大对云计算的投资，向更多的垂直领域进行渗透及海外扩张。最近，腾讯优图发起了人脸识别测试。管理层可否介绍一下腾讯未来一年在云计算市场有哪些机遇，以及在人工智能领域的投资目标，这些项目是否与腾讯在公开市场上的大规模收购有关？

刘炽平：你说的对，我们正在逐步加强在云计算业务方面的努力，原因就在于，我们将云计算看作是公司整体业务发展的战略篇章，提供相关基础设施以支持更广泛的生态系统建设和互联网渗透。我们看到越来越多的用户可以上网了，也拥有自己的手机了。腾讯可以给各行各业带来联网能力，无论是企业、组织，还是政府机构。因此，众多基础设施业务在帮助这些行业转型方面会变得至关重要，而云计算就是其中之一。这也恰恰是我们逐步加强在云计算领域投资的重要原因。
正如我们在陈述环节中所说，腾讯云计算业务获得了迅猛增长，第一季度增长速度依旧达到三位数。展望未来，我们确实相信腾讯可以继续扩大云计算业务规模，腾讯拥有庞大的基础设施，可以为客户带来效率和成本优势。与此同时，鉴于腾讯在开发各种不同技术及应用上拥有很长的历史，我们加强在云计算方面的投资，会加快这些技术和能力的开放速度和规模，为云计算客户提供支持。
至于将来，我们相信这种能力将有助于腾讯与越来越多的客户签约。很显然，云计算服务客户在市场营销团队方面具有很大的缺陷，而我们则正在大规模开发这种能力，让这些客户可以去覆盖更多的用户，为更多的渠道合作伙伴提供支持，在市场营销、品牌广告和客户服务等方面做得更好。
我们将人工智能看作是一种核心能力，可以帮助腾讯建立自己的业务。人工智能有潜力与广告等腾讯现有业务建立更好的联系，提升广告受众定位能力，为腾讯带来新的功能和相关信息，让我们可以继续优化产品，为用户提供个性化服务。在金融等领域，人工智能可以帮助客户基于社交图谱锁定合适的用户。进一步开发人工智能将有利于腾讯核心业务，而且还能让腾讯在未来挖掘新业务。我们正在积极开发这种能力。
我们会继续在人工智能和云计算领域加大投入，令其成为腾讯的核心能力，向云计算合作伙伴和生态系统合作伙伴全面开放。我们现阶段就是这样看待人工智能的。至于说人脸识别测试，主要还是与人工智能有关。我们觉得汽车的互联能力越来越强大，控制系统和自动驾驶系统日益智能化，因此假以时日，汽车终将成为一种智能设备，而虚拟世界与现实世界的连接更紧密。正因为如此，腾讯希望与这些领域的领导者建立合作，以便我们获得这种能力，了解能从他们身上学到什么东西，能否一起携手开创新业务。

美银美林分析师梁伟亮 ：一些社交媒体提到，腾讯越来越重视短视频，这种视频形式利于用户互动。请问管理层如何看到这种趋势，可否与我们分享有关运营指标的信息，看起来短视频正在改变腾讯平台上的用户行为？第二个问题，第一季度腾讯游戏、休闲游戏和智能手机用户的值分别是多少？

刘炽平：短视频的确非常受用户欢迎。短视频在腾讯所有产品上的播放量都增长迅速。在腾讯媒体产品上同样呈现这种趋势，特别是主要迎合年轻一代人需求的平台，这个人群更习惯于分享短视频，因此推动这种视频形式大受欢迎。与此同时，我们认为短视频还增加了多媒体内容消费时间，在腾讯许多媒体产品上，比如腾讯新闻、天天快报、腾讯视频，短视频的播放量同样增长迅猛。
罗硕瀚：年第一季度，游戏的值在人民币元至元之间，休闲游戏的值在人民币元至元之间，智能手机游戏的值在人民币元至元之间。

大和证券分析师 ：我的问题关于腾讯手游。管理层刚才提到付费帐号大幅增加是第一季度游戏业务强劲增长的主要原因。将来，哪种游戏会是推动公司游戏业务增长的引擎，鉴于腾讯上线了三款爆款游戏，是不是将来这种游戏的表现更好一些？可否分享一下值和付费用户等运营数据。另外，我还想要了解一下微信朋友圈广告的情况。相比市场之前预期，腾讯并没有在微信朋友圈大量且快速投放广告，请问公司在这个方面是如何考虑的？

刘炽平：说到手游，很显然最重要的事情是你能持续不断地推出成功的游戏作品。如果你看一看腾讯的整体策略，会发现我们在休闲游戏方面的表现更好一些。我们想要开发一些类型游戏，同时通过自主研发以及与合作伙伴联手的方式增加游戏数量。在过去一年，这两种游戏类型都获得了长足发展。
如果你仔细研究玩家对战游戏  ，会发现此类游戏的生命周期往往更长，可以媲美竞技类体育游戏，每次你在玩游戏的时候，游戏体验都大不相同，因此这不是一种由内容驱动的游戏类型。我们在游戏领域正处于初始阶段，我们的策略是开发一些受欢迎的热门游戏。在游戏方面，我们仍然坚持合作与自主研发并重的策略。游戏是否会获得成功，只有时间会告诉我们一切。这就是我们在手游方面所做的事情。
我们始终将效果型广告看作是一种长期的市场机遇，并且会努力挖掘这种机遇。我们会积极建立自己的能力，以充分了解用户的具体需要，优化广告产品定位技术，开发合适的广告形式，在收入增长和用户体验方面达到平衡。当然了，我们可以释放更多广告库存，而且做起来也很轻松，但此举会影响用户体验。正因为如此，我们才不会在短时间内大量投放广告。
我们当前的工作重点是获得理想的能力，能够基于现有广告库存不断提升自己的表现。我们会签约更多的广告主，随着时间的推移，我们自然而然地会释放库存，一点点地增加广告数量，但前提是不伤害用户体验。在不影响用户体验的情况下逐步增加广告量。所以，这就需要我们具有更强的定位能力，以锁定合适的广告商。这是腾讯在微信朋友圈广告上的策略。

分析师：很显然，同腾讯旗下其他业务一样，微信支付增长非常快，管理层可否详细谈一谈这项业务？

刘炽平：从业务角度讲，我们将支付业务看作是腾讯整个生态系统的基础设施服务，不仅仅是针对腾讯社交网络，而是覆盖腾讯生态系统以及合作伙伴的不同活动。因此，微信支付覆盖了用户日常生活的方方面面，他们无论是在线购物还是付费订阅内容，无论是在线下购物还是在享受线下其他各类服务的时候，微信支付都能派上用场。
这就是我们对支付业务的市场定位。从业务角度看，我们并不想在短期内将支付打造成为一项能赚钱的业务。相反，我们当前的工作重点仍然是让微信支付覆盖更多的用户和商户，提升他们使用微信支付的频率。通过上述几种方式，我们会逐渐扩大微信支付的覆盖范围和影响力。
支付服务主要由以下几个部分组成。第一部分是社交支付，其中就包括家喻户晓的微信红包，方便用户相互之间转账。第二部分是在线商家交易。用户在线购买商品并订购了送货上门服务，这时候他们就可以使用微信支付。第三部分涉及线下商家。这些商户可以利用腾讯支付平台获得付款，因此，众多线上零售商、餐馆等以及线下服务如滴滴打车，都可以从腾讯支付找到解决办法。甚至是在一些没有安装机的商家，如果你忘了带现金，也可以通过微信支付完成付款环节。这就是腾讯支付在不同场景下提供的不同服务。

摩根士丹利分析师格蕾丝·陈 ：我的问题与《王者荣耀》的成功有关。管理层能否从多个角度来谈一谈让这款游戏取得成功的设计元素？可否比较一下《王者荣耀》和《英雄联盟》等其他游戏的核心运营指标，比如生命周期、用户付费率和值。我认为，《王者荣耀》对腾讯整体手游收入贡献巨大，所以请谈一谈它对腾讯其他手游核心指标的影响。

刘炽平：毋庸置疑，《王者荣耀》是一款非常成功的手游，其成功源于极具吸引力的游戏形式，正是多样的游戏元素吸引了不同类型的玩家。第二，从技术上讲，在手机上进行实时对战始终是一件很困难的事情，而我们恰恰克服了这种挑战。第三，《王者荣耀》的成功受益于腾讯长期以来运营手游的历史。如果大家看一看腾讯管理游戏推广的方式，会发现我们始终针对不同的玩家群体。
我们之前就说过，《王者荣耀》是目前世界上用户覆盖率最高的手游之一。更为重要的是，这款游戏目前尚处于生命周期的初级阶段，我们要确保不断完善和优化《王者荣耀》，同时增加新功能和新内容，以便让玩家感到满意。这就是我们当前在《王者荣耀》游戏上的工作重点。

汇丰银行分析师曾琪 ：我有两个问题，首先根据管理层的发言，一二线城市的微信用户使用习惯与三四线城市有所不同，特别是如果服务和内容不同的话，他们在微信上停留的时间也不一样。第二个问题，能否与我们分享一下在线金融业务的最新情况。

刘炽平：说到不同城市用户的不同习惯，首先，三四线城市的用户仍然经常使用手机。如果看一看腾讯社交平台上的用户行为，会发现更多与业务有关。在电子商务产品上，一二线城市的用户更活跃。另外，对于公众号内容，由于兴趣的不同，他们关注的内容也不同。不过，不同城市的用户在微信上停留的时间极为相似。
我们认为，腾讯在线金融业务的各个产品类别都取得了进展。很显然，无论是在用户数量还是交易量上，腾讯在线支付业务都出现迅猛增长。在金融业务方面，我们创建了微众银行，并借此推出了微粒贷，这款产品很受欢迎。我们充分利用自己的大数据能力以及在用户数量的优势，为这个用户群提供便捷的小额借款服务。这项业务正以健康的速度增长。
至于微众银行的管理，腾讯通过与不同银行合作伙伴联手，加强在这个方面的管理。微众银行目前收费极低，而我们与其他银行合作来降低违约风险。当然了，微众银行目前在控制违约风险上做得还不够好，但我们会充分利用大数据来控制违约风险。至于理财通，这项产品同样取得不错的增长，我们同样以可控的方式来推动该业务。我们觉得，控制投资理财产品的质量是非常重要的一件事。在中国理财产品质量参差不齐，因此，腾讯选出了两款高品质的理财产品供用户选择。

瑞银集团分析师许明 ：我也有两个问题，第一个有关金融业务，最近我们注意到这个领域发生了几件很严重的事情。比如，中国中央银行对腾讯及主要竞争对手进行了罚款。请问这只是个案呢，还是说监管部门态度发生改变，对腾讯金融业务带来冲击？第二个问题，你们在二季度初期重组了广告业务团队，管理层能否分享一下最新情况，腾讯品牌广告业务何时会恢复强劲增长？

刘炽平：说到金融监管，这也是我们在开展金融业务时重点关注的一个方面，而罚款与中央银行要求的支付账户实名制有关，我们非常重视这件事，而且根据中央银行的要求进行了大量调整。我们面临的主要问题是，与同样拥有海量用户的阿里巴巴一样，使用腾讯支付服务的用户数以亿计，我们需要将所有这些人转化为实名制，我们也采取了一系列措施，但仍然难以彻底解决这个问题。实现这种转变仍然需要时间，我们会尽力对用户进行管理，让他们按照监管部门要求行事。

中银国际分析师托马斯·庄 ：我的问题关于腾讯游戏、云计算和支付业务在海外市场的扩张战略。未来几年，腾讯将尤其专注于发展哪个领域？

刘炽平：游戏肯定是腾讯未来几年关注的焦点领域，正如大家所看到的，通过进行投资和并购，腾讯已经在全球游戏市场建立了很大的知名度，而且会继续利用这两种手段扩大在这方面的影响力。与此同时，我们也会推出自主开发的游戏产品，从海外游戏市场学习相关经验和进行基础设施建设，寻找合适的游戏，但这些工作可能会花费我们很长时间。很显然，我们的首要任务仍然是开发新游戏。
微信支付的规模已经很大了，拥有大量用户，其中一些用户开始在海外进行交易。为了追随这种市场趋势，服务于不同地区的不同用户群体，考虑到不同地区的监管政策不同，我们必须要做到因地制宜，这同样是一项长期任务。至于云计算业务，我们当前的工作重点仍然是在国内市场。与此同时，大家会注意到许多客户已经在海外开展业务，这就需要我们在海外创建支付业务基础设施，为这些客户提供相应服务，这也是腾讯云计算业务开拓海外市场的第一步。假以时日，随着我们的市场份额足够的多，我们将可以向当地客户提供云服务。

中金证券分析师娜塔莉·吴 ：首先，在腾讯第一季度手游收入中，平台和安卓平台各占多少？具体到安卓平台，在腾讯自主开发的手游收入中，多少是由自有渠道贡献的，又有多少来自于第三方应用商店？第二个问题，微信支付将针对所有商户进行大规模推广，请问腾讯在这个方面的预算，以及对公司年利润率的影响？

詹姆斯·米歇尔：虽然每个季度的情况有所不同，但就整体而言，安卓平台的收入贡献更大一些，而平台的收入也增长了三位数，不过占比仍然较小。很有意思的是，游戏类型不同，平台和安卓平台的收入贡献也不同。例如，在射击类游戏中，安卓平台的收入贡献更大，而跑步游戏的收入平台的贡献更大。
至于安卓平台上的收入，绝大部分来自于腾讯自有应用商店。过去几年，为了实现游戏收入的全面增长，腾讯也与第三方应用商店建立了合作。但是，与第三方应用商店合作分发游戏会使得营收成本增加，从而对利润率带来不利影响。因此，自有销售渠道的利润水平更高一些，而与第三方应用商店合作会拉低利润水平。
刘炽平：我来回答与微信支付有关的问题。我们这一次主要围绕订餐服务展开营销推广活动，原因就在于这个垂直领域竞争非常激烈，而腾讯会充分利用与美团、大众点评的良好关系，这两家公司在订餐领域的服务覆盖了大量用户。与此同时，腾讯会提供力度非常大的优惠活动，让用户重新回到餐馆。在过去半年或一年左右，腾讯在订餐产品类别的市场份额有所减少，尽管失去的份额不太多。所以说，我们希望通过这种推广手段重新给市场带来竞争。

原文来自腾讯科技，本文经编者加工整理。编译：马骏豪需求
之前一直都用服务器，由于网站访问量比较大，另外加上旧服务器快到期了，准备迁移到腾讯云服务器上，所以决定采用服务器。
迁移过程比较心酸，之前一直用，对服务器配置不熟悉，踩了很多坑。下面说一下我的网站从旧主机配有服务器迁移到腾讯云主机配有服务器的过程。
那这里是我新购买的云主机：

代码迁移
这个过程其实也是比较心酸的，查看了一下目录结构占用空间已经足足快个了，可想而知里面占用的大部分空间是上传的图片素材。
不过要是迁移全部图片的话工程量实在是巨大。不过，好消息是我从开始就使用了七牛加速，所以，上传的图片会自动存放到七牛，只不过也在主机本地留了备份而已，所以，我可以安心地删掉它们了。
那么对代码进行瘦身之后，这里就有两种方法来迁移了：
可以用上传到，然后用另一台主机把代码拉下来即可，在此不再赘述。
打包上传，然后直接在另一台主机上下载下来，由于我的两台主机在同一局域网内，所以我直接采用了这种方式，传输速度快。
打包
由于代码中含有  目录，所以这部分我们不需要打包，那么压缩时我们就需要排除这个文件夹。

文件夹名叫，那么我们就打包一下，排除目录，使用如下命令
   = 
运行结束后会出现  文件，这就是目录压缩包。然后我们只需要在另一台主机上输入
 
即可完成下载，速度可是嗖嗖的然后解压即可，代码便完成了迁移。
数据库迁移
数据库用二者的导出和上传即可。我导出  文件，大小为，而的上传限制大小是，怎么办？其实我们可以压缩  文件为 格式，压缩之后就有了了，分分钟完成上传。要知道  可是支持  文件的。
接下来是一个比较重要的部分，那就是配置一下站点信息。直接修改数据库的两个。
分别是  和 ，一定要修改为  的形式，也就是把原来的域名改成加目录的形式，要不然网站是无法访问的，会出现多重循环定向的提示。
好，其他的没什么问题，连接数据库错误的话就修改一下目录的  文件吧，连接数据库的信息修改正确就好了。
配置
和  一样，我们多个域名肯定要可以解析到不同的目录吧， 当然也是支持的。
接下来我们需要把新域名解析到  目录，在  下怎么做呢？其实还是比较简单的。
在  目录下可以新建一个 文件夹。在这里我们要解析  目录，那么我就新建一个  文件。
现在例如我要把  解析到  文件夹，配置如下
 {
     
    _  

       
     

      {

          _ {
             _  
             _\  
               
        }
    }

      \ {
        _ 
          
        _ 
        _ 
        _ _ __
         _
    }
}
其中 
  {

          _ {
             _  
             _\  
               
        }
    }
这一部分是伪静态重写，因为我的博客用的是，所以伪静态重写是这样的。当然还有其他的重写方式可以尝试。之后在  中的 {} 中添加一行
 
则代表引用了这个文件。
注意，还要把 域名设置一下，添加一条记录到主机上。
好了，一切大功告成了。
后记
迁移和配置的过程坑实在是太多了，列列吧，警醒世人呐。
代码迁移过程上传，整个项目差不多个，由于数据量太大，导致内存不够无法正常上传。后来删除了图片，发现项目还是很大，结果发现是  目录已经占用了上百兆，后来打包排除这个目录迁移的。
数据库迁移的时候由于上传大小限制，修改了一番上传大小结果发现没生效，还倒腾了一下，后来发现可以直接上传压缩包，那就分分钟完成了。
配置完之后发现网站首页正常访问了，可是其他页面全部出现了错误，后来配置了一番伪静态解析发现配置代码直接写在了  里面，后来发现可以直接新写一个 ，然后配置域名，然后配置伪静态重写才成功。
总之，坎坷是多，但是，自己慢慢摸索出来，也是一种不错的体验。
当你成功之后，会觉得世界又是那么美好。

相关推荐
 基本入门
腾讯云下定时监测进程终止后自动重启的方法
【腾讯云的种玩法】关于服务器反向代理 的一点思考脚本
下环境配置前言
现在应用可以使用苹果的技术——，将有真实感的虚拟物体与现实世界无缝衔接，给用户带来身临其境、有参与感的体验。在 里，将的虚拟物体叠加到通过摄像头实时拍摄的真实环境中，制造出虚拟物体真实存在的错觉。用户可以通过改变设备的位置，从不同角度来探索虚拟物体，如果设计得当，也可以通过手势或者动作来与虚拟物体互动。
设计有参与感的体验
使用全屏让用户参与其中：尽可能使用更多的屏幕空间来呈现物理世界和里的虚拟物体。避免过于杂乱的操作和信息出现在界面里，影响临场感。
构建仿真物体时要有说服力：不是所有的体验都需要仿真物体。但如果需要用到仿真物体，就需要把在这个物体在真实世界里的相关元素也设计进去。为了获得最佳表现，需要为物体设计逼真的材质，使用提供的信息把物体放到现实世界的平面上，并且缩放到适当的比例。同时，需要在虚拟物体上投射环境光，在现实空间里投射出物体的阴影。当相机的位置发生变化的时候，需要实时刷新视效。
将物理限制考虑在内：一定要记住，用户可能会在非最佳体验的环境里使用你们的。例如，他们可能在一个没有多大的移动空间，或者没有足够大的平整的平面的地方打开你们的。要提前考虑那些会出现问题的场景，清晰地向用户传达要求或预期。可以考虑在不同环境下，给用户提供不同的功能。
要考虑用户的舒适度：人处在某个距离、保持某个角度长时间持握设备，会产生疲劳。要考虑用户持握设备使用时，仍能获得愉快的体验。比如，你可以默认设置成，把物体放在一个不需要用户靠近的距离。做游戏的时候可以把每个关卡设计得短一些，多加入一些短时间的休息。
如果你的鼓励用户做出一些动作，需要渐进的引导：例如，在一个游戏刚开始的时候，不能让用户大步移动来躲避虚拟的投射物。需要给他们一些时间来适应这种体验，然后逐步引导他们。要考虑用户的安全：当用户所处的环境里有很多人或物体的时候，太频繁地让用户移动，会带来潜在的危险。要考虑用户可以安全地使用。例如，游戏设计时需要避免大幅度的动作，或要求用户突然地做出动作。
使用音频或触感来提升临场感：在虚拟物体和物理表面或其他虚拟物体发生了接触时，使用音效或者震动可以提供很好的反馈。在一个身临其境的游戏中，使用背景音乐也可以很好的把用户带入到虚拟的世界里。相关指南可以看音频和触觉反馈部分。

尽可能在上下文中提供线索：例如，在可以旋转的物体周围放一个旋转示意的箭头，这要比单纯的文字提示更直观。但在表面检测完成之前，或是用户对上下文提示没有进一步操作时，文字提示还是有必要的。
如果一定要使用文字说明，请使用容易理解的文案：是一个前卫的概念，容易让一些用户退缩。为了让用户更容易接受，要避免使用太过技术性的、面向开发的词汇，例如、现实检测、追踪。而要用大部分用户可以理解的友善的、对话型的词汇。
例如，可以使用：
“无法找到表面。可以尝试走到一边，或挪动一下手机的位置。”“点击要放置物体的位置”“试一试打开灯光，或是来回走动一下。”“试一下慢一点移动你的手机”
不要使用：
“无法找到平面，调整跟踪。”“点击平面来定位物体”“功能缺陷”“检测到运动过频”
避免打断体验的不必要的操作：每一次用户退出或重新进入的时候，都会重新检测环境和表面，此时手机和摄像头的位置很可能发生过改变，会导致之前放置的物体会被移位，甚至可能不再出现在平面上了。为了避免这种问题，要让用户可以在不退出的情况下，也能调节物体、设置。例如，用户把想购买的椅子放进房间时，他们可能会想试一试其他面料的选项，可以把选项的调整设计在环节中。
进入增强现实

在初始化的时候需要告知用户：每次你的进入时，都会进行初始化，此时会对环境进行评估，大概需要几秒的时间。为了减少用户的困惑，加快初始化进程，可以向用户展示初始化正在进行的事项，鼓励用户探索他们周围的环境，或是去寻找实物表面。
放置虚拟物体
提示用户定位表面，以及放置物体的时机：当进入了“表面定位模式”，可以用视觉标识来传达。例如，在屏幕中间放一个梯形框，可以帮助用户了解到此时他们需要找一个水平面。当表面已经选中时，要变换一下提示的图标，来告诉用户“现在可以放置物体”了。设计视觉标识也是设计的一部分。
用户放置物体时，要予以恰当的反馈：在表面检测时时间非常短，精度会逐步提高。如果此时用户点击屏幕来放置物体，要尽可能使用已获得的信息尽快放置物体。一旦表面检测完成，再巧妙地优化物体的位置。如果一个物体放置的位置超出了检测到的表面，就需要将物体轻轻地推回表面上。
避免将物体对齐到检测出的表面边缘：在中，表面的边缘是近似的，进一步分析用户环境之后，可能会发生改变。
与虚拟物体互动

直接控制物体，比操作多个按钮要好：通过点屏幕上的物体直接发生互动，会带来更强的临场感，要比在屏幕的不同区域，操作多个独立的按钮要好。不过要记住的是，当用户在移动的时候，直接控制物体会变得难以操作。
通过标准、用户熟悉的手势让用户与虚拟物体直接互动：例如，可以考虑使用单指拖拽物体，使用两指旋转物体。更多相关的规范可以参考“手势”。
一言以概之，交互要简单：轻触手势本质上是二维的，但在体验中涉及到三维的真实世界。可以参考以下几点来简化用户和虚拟物体互动的交互。

当操作手势接近可交互的虚拟物体时，要予以反馈：对用户来说，要精确的点击一些比较小、薄、放在较远距离的物体上的某一点是很难的。当你的检测到，在接近交互区域有手势操作时，就可以假设用户想要完成这个互动。
要考虑是否有必要让用户缩放物体：通常来说，没有固定尺寸的玩具或者是游戏角色，用户可能希望可以看到它放大或是缩小的状态，提供缩放功能也显得比较合理。而对于一个在现实世界有相对尺寸的物体，比如说固定尺寸的家具，缩放功能就没有必要了。缩放不是一个调节物体距离的补救措施，把物体放大并不一定能让它看起来离用户更近，可能只会让用户感觉这是一个离自己较远的较大的物体。
要小心手势冲突：例如，两指的捏的手势，可能和用两指旋转的手势很接近。如果要设计这样类似的手势操作，一定要提前测试，确保操作起来不会有冲突。
确保虚拟物体的变化要顺滑：物体缩放、旋转、移动到某一点的过程，不能是跳跃式的，需要平滑地过渡。
探索更有临场感的交互方式：在中，手势不是唯一能和虚拟物体产生互动的方式。你的也可以考虑运用其他细节来让内容变得更生动。例如，一个游戏角色可以在他走向用户的时候把头转向用户。
问题处理
允许用户重置：不要强迫用户去等待客观条件具备，或是在放置物体有困难的时候，也要他们先完成放置。给他们一个重新开始的选择，看看是不是可以获得更好的结果。

发生问题时，提示用户可能的解决办法：“环境分析”和“表面识别”有时可能因为一些原因无法完成。比如说光线不够好，平面上的反光太强，平面没有足够的细节，或摄像头移动得太快。如果你的可以检测到这些问题，或者当表面检测太慢时，可以给到用户解决办法。
问题——建议的解决办法
检测到功能缺陷——试一试打开灯光，或是来回走动一下。检测到运动过频——试一下慢一点移动你的手机表面检测时间过长——试一试来回走动一下，打开灯光，确保你的手机对准有纹理的表面。
只为硬件条件具备的设备提供功能：如果你的的核心功能就是，让你的仅支持可以支持的设备。如果在你的里，功能不是核心功能——比如说“有商品照片的家具目录，支持用户在场景里看商品”，就需要避免让一个不支持的设备进入模块时卡在报错环节。如果设备不支持，最好一开始就不对用户展示功能入口。
更多
开发指南请参阅。 
苹果官方原文地址： 文章《查询分析》讲述了使用慢查询和命令来定位性能瓶颈的方法，定位出性能瓶颈的语句后，则需要对低效的语句进行优化。本文主要讨论索引原理及常用的查询优化。 
一个简单的对比测试
前面的案例中，___表只有一个自增，字段未加索引的执行情况如下：

在上图中，=，=，=。该未使用索引，是一个效率非常低的全表扫描。如果加上联合查询和其他一些约束条件，数据库会疯狂的消耗内存，并且会影响前端程序的执行。
这时给字段添加一个索引：
  ___   _ 
再次执行上述查询语句，其对比很明显：

在该图中，=，=索引名_，=。该使用了索引_，且是一个常数扫描，根据索引只扫描了一行。
比起未加索引的情况，加了索引后，查询效率对比非常明显。
索引
通过上面的对比测试可以看出，索引是快速搜索的关键。索引的建立对于的高效运行是很重要的。对于少量的数据，没有合适的索引影响不是很大，但是，当随着数据量的增加，性能会急剧下降。如果对多列进行索引组合索引，列的顺序非常重要，仅能对索引最左边的前缀进行有效的查找。
下面介绍几种常见的索引类型。
索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。
、索引类型
 主键索引  
它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。

当然也可以用  命令。记住：一个表只能有一个主键。
 唯一索引 
唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。可以在创建表的时候指定，也可以修改表结构，如：
  _   
 普通索引 
这是最基本的索引，它没有任何限制。可以在创建表的时候指定，也可以修改表结构，如：
  _   _ 
 组合索引 
组合索引，即一个索引包含多个列。可以在创建表的时候指定，也可以修改表结构，如：
  _   _  
 全文索引 
全文索引也称全文检索是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。
可以在创建表的时候指定，也可以修改表结构，如：
  _   
、索引结构及原理
中普遍使用做索引，但在实现上又根据聚簇索引和非聚簇索引而不同，本文暂不讨论这点。
树介绍
下面这张树的图片在很多地方可以看到，之所以在这里也选取这张，是因为觉得这张图片可以很好的诠释索引的查找过程。

如上图，是一颗树。浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项深蓝色所示和指针黄色所示，如磁盘块包含数据项和，包含指针、、，表示小于的磁盘块，表示在和之间的磁盘块，表示大于的磁盘块。
真实的数据存在于叶子节点，即、、、、、、、、、、、、、。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如、并不真实存在于数据表中。
查找过程
在上图中，如果要查找数据项，那么首先会把磁盘块由磁盘加载到内存，此时发生一次，在内存中用二分查找确定在和之间，锁定磁盘块的指针，内存时间因为非常短相比磁盘的可以忽略不计，通过磁盘块的指针的磁盘地址把磁盘块由磁盘加载到内存，发生第二次，在和之间，锁定磁盘块的指针，通过指针加载磁盘块到内存，发生第三次，同时内存中做二分查找找到，结束查询，总计三次。真实的情况是，层的树可以表示上百万的数据，如果上百万的数据查找只需要三次，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次，那么总共需要百万次的，显然成本非常非常高。
性质
 索引字段要尽量的小。
通过上面树的查找过程，或者通过真实的数据存在于叶子节点这个事实可知，次数取决于数的高度。
假设当前数据表的数据量为，每个磁盘块的数据项的数量是，则树高=㏒，当数据量一定的情况下，越大，越小；
而 = 磁盘块的大小数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的；如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如占字节，要比字节少一半。
 索引的最左匹配特性。
当树的数据项是复合的数据结构，比如的时候，数是按照从左到右的顺序来建立搜索树的，比如当张三这样的数据来检索的时候，树会优先比较来确定下一步的所搜方向，如果相同再依次比较和，最后得到检索的数据；但当这样的没有的数据来的时候，树就不知道下一步该查哪个节点，因为建立搜索树的时候就是第一个比较因子，必须要先根据来搜索才能知道下一步去哪里查询。比如当张三这样的数据来检索时，树可以用来指定搜索方向，但下一个字段的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是的数据了， 这个是非常重要的性质，即索引的最左匹配特性。
建索引的几大原则
 最左前缀匹配原则
对于多列索引，总是从索引的最前面字段开始，接着往后，中间不能跳过。比如创建了多列索引，会先匹配字段，再匹配字段，再匹配字段的，中间不能跳过。会一直向右匹配直到遇到范围查询、、、就停止匹配。
一般，在创建多列索引时，子句中使用最频繁的一列放在最左边。
看一个补符合最左前缀匹配原则和符合该原则的对比例子。
实例：表___建有索引_

不符合最左前缀匹配原则的语句：
   __  _=\
该直接用了第二个索引字段_，跳过了第一个索引字段，不符合最左前缀匹配原则。用命令查看语句的执行计划，如下图：

从上图可以看出，该未使用索引，是一个低效的全表扫描。
符合最左前缀匹配原则的语句：
   __  =  _=\
该先使用了索引的第一个字段，再使用索引的第二个字段_，中间没有跳过，符合最左前缀匹配原则。用命令查看语句的执行计划，如下图：

从上图可以看出，该使用了索引，仅扫描了一行。
对比可知，符合最左前缀匹配原则的语句比不符合该原则的语句效率有极大提高，从全表扫描上升到了常数扫描。
 尽量选择区分度高的列作为索引。
比如，我们会选择学号做索引，而不会选择性别来做索引。
 =和可以乱序
比如 =    =    = ，建立索引可以任意顺序，的查询优化器会帮你优化成索引可以识别的形式。
 索引列不能参与计算，保持列“干净”
比如：‘‘。原因很简单，假如索引列参与计算的话，那每次检索时，都会先将索引计算一次，再做比较，显然成本太大。
 尽量的扩展索引，不要新建索引。
比如表中已经有的索引，现在要加的索引，那么只需要修改原来的索引即可。
索引的不足
虽然索引可以提高查询效率，但索引也有自己的不足之处。
索引的额外开销：
 空间：索引需要占用空间；
 时间：查询索引需要时间；
 维护：索引须要维护数据变更时；
不建议使用索引的情况：
 数据量很小的表    
 空间紧张   
常用优化总结
优化语句很多，需要注意的也很多，针对平时的情况总结一下几点：
、有索引但未被用到的情况不建议
 的参数以通配符开头时
尽量避免的参数以通配符开头，否则数据库引擎会放弃使用索引而进行全表扫描。
以通配符开头的语句，例如：   __    \

这是全表扫描，没有使用到索引，不建议使用。
不以通配符开头的语句，例如：   __    \

很明显，这使用到了索引，是有范围的查找了，比以通配符开头的语句效率提高不少。
 条件不符合最左前缀原则时
例子已在最左前缀匹配原则的内容中有举例。
 使用！= 或  操作符时
尽量避免使用！= 或 操作符，否则数据库引擎会放弃使用索引而进行全表扫描。使用或会比较高效。
   __   = \

 索引列参与计算
应尽量避免在  子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。
   __     \

 对字段进行值判断
应尽量避免在子句中对字段进行值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：低效：   __      
可以在上设置默认值，确保表中列没有值，然后这样查询：高效：   __    =
 使用来连接条件
应尽量避免在子句中使用来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：低效：   __    =    = 
可以用下面这样的查询代替上面的  查询：高效：   __    =       __   = 

、避免 
在解析的过程中，会将 依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间。
所以，应该养成一个需要什么就取什么的好习惯。
、  语句优化
任何在 语句的非索引项或者有计算表达式都将降低查询速度。
方法：重写 语句以使用索引；
  为所使用的列建立另外一个索引

  绝对避免在 子句中使用表达式。
、 语句优化
提高  语句的效率 可以通过将不需要的记录在  之前过滤掉
低效
   
 
  
  = ‘
  = ‘
高效
   
 
  = ‘
  = ‘
  
、用  代替 
很多时候用  代替  是一个好的选择：         用下面的语句替换：          =
、使用  代替 
尽可能的使用  代替  ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。
、能用的就不用 
          
可改为： 
         
、能用 就不要用
 不执行 函数，这样就会减少很多不必要的资源。
、在表的时候使用相当类型的例，并将其索引
如果应用程序有很多 查询，你应该确认两个表中的字段是被建过索引的。这样，内部会启动为你优化的语句的机制。
而且，这些被用来的字段，应该是相同的类型的。例如：如果你要把  字段和一个  字段在一起，就无法使用它们的索引。对于那些类型，还需要有相同的字符集才行。两个表的字符集有可能不一样斯坦福大学人工智能实验室李飞飞教授，实现人工智能要素：语法、语义、推理。语言、视觉。通过语法语言语法解析、视觉三维结构解析和语义语言语义、视觉特体动作含义作模型输入训练数据，实现推理能力，训练学习能力应用到工作，从新数据推断结论。《       》  。
看图说话模型。输入一张图片，根据图像像给出描述图像内容自然语言，讲故事。翻译图像信息和文本信息。 。
原理。编码器解码器框架，图像编码成固定中间矢量，解码成自然语言描述。编码器 图像识别模型，解码器网络。{…}字幕词，{…}对应词嵌入向量，输出{…}句子下一词生成概率分布，{…}正确词每个步骤对数似然，总和取负数是模型最小化目标。
最佳实践。微软  数据集  。    数据集。超过万张图片，万个标记实体。对原数据集万张图片，用亚马逊 服务，人工为每张图片生成至少句标注，标注语句超过万句。版本、版本。版本张图片，验证集张图片，测试集张图片。图像分类库  。
构建模型。___。
 ____  _
 ____  
 ____  _
   
   _
   _
     _
 
      
         
         
  
   ____   _=
     
    
          
          
      _       
    
         
     = 
     = 
    _ = _
         
     = 
                 
       
     = __
        =_
        =_
          _   
     = 
          _ _
    _ = 
          _ _
    _ = 
           _ _
    _ = 
          _ _
    _ = 
          _ _ _
    _ = 
                
    _ = 
          _  _
    ___ = 
          _  _
    ____ = 
           
    _ = 
            
    _ = 
       
    _ = 
   _
             
      == 
   _ _ _=
         
    
      _       
      _          
        
    
                
    
     ___
                                          _=_
                                          =_
                                          =_
                                          _=_
                                          _=_
   _
        
    
      
      _
      _    
      _    
    
      == 
                
      _ = = = =_
      _ = =
                                  =   _
                                  =_
            
       = ___ 
      _ = __ 
               
      _ = 
      _ = 
    
          
      _ = ___
          
          __
          _=_
          _=_
          __=___
          ___=___
          __=___
               
              
       __   == 
      __ = 
       _  __
        __ = _
        _  = ___
            __
            _=__
            _=__
         = __ _=_
        __ 
        
      _ =   __ 
                        _
       _ _ _ = 
          ______
                                           _=_
                                           _=_
     = 
    _ = _
    _ = _
    _ = _
   __
            
    
      
    
      _
    
    _ = __
        
        =_
        _=_
    _ = _
        _ =
          
     __  
      _ = _
          =_
          _=_
          _=
          _=
          _=
          =
           
    _ =_
    _ = _
   __
        
    
      _
    
      _
    
     __ 
      _ = _
          =
          =_ _
          =
      _ = __ _
    _ = _
   _
      
    
      _
      _
      _    
      _    
    
      _    
      ___    
      ____    
    
            _    
                 
     _  
    _ = 
        _=__ __=
      == 
      _ = 
          _
          __=___
          __=___
     _ =  _
                
      _ = __
          _=__ =
      _ _ = __ _
             
      __
        == 
                  
         
        = =_ =_
                
        _ = =
                                    = __
                                    =_
        _ = =_ ___= =
             
        _ _ = _
            =_ =
            =_
            
        = =_ =
      
                 
        _ = __ 
        _ _ = _=_
                                            =_
                                            _=_
                                            _=_
                                            =
                                            =_
       
    _ = _  __
     _  _
       = _
          =_
          _=_
          _=
          _=
          =_
      == 
       =
    
       = _ 
       = __ 
        
       = _____=
                                                              =
      _ = _ 
                          _
                          =_
      __
      _ = __
        
      _ _
      _ _
         _
           
      _ = _
      ___ =      
      ____ =      
   __
             
      = 
          
       = _
       _
              
                        __
         __
      _ = _
   __
         
    _ = 
        _=
        =_
        =
        =_ _
    _ = _
   
          
     构建模型
    _  构建输入数据
    __  采用 构建图像模型，输出图片嵌入向量
    __  构建输入序列
    _  、串联，构建完整模型
    __  载入 预训练模型
    __  记录全局迭代次数
训练模型。。
 ____  _
 ____  
 ____  _
   
   
   ___
 = 
___ 
                             
___ 
                           _ 
__ 
                             
__ 
                             
___     
____ 
                                
_
 _
   __ __  
   _ _  
  _ = 
  ___ = __
  ___ = __
  _ = 
     
   创建训练结果存储路径
  _ = _
    _
        _
    _
      
   建立数据流图
   = 
   _
       
     构建模型
     = ___
        _ = _=_
    
         
     定义学习率
    ___ = 
     _
      _ = ____
    
      _ = ___
       ____  
        ___ = ____ 
                                 __
        _ = ___ 
                          ____
         _____ _
           _
              _
              _
              _=_
              _=____
              =
        ___ = ____
         
     定义训练操作
    _ = _
        =_
        _=_
        _=_
        =_
        _=__
        ___=___
              
     = __=____
    
   训练
  
      _
      _
      ___=___
      =
      _=_
      __=__
      _=_
      =
 ____ == ____
  
预测生成模型。_。
 ____  _
 ____  
 ____  _
 
 
   
   
   _
 _  _
 _  
 = 
__ 
                              
                         
__      
__ 
                               
                         
_
 _
      
   = 
   _
     = _
    _ = ___
                                               _
  
     
   = _
   = 
   _  _
    _
         
                   _
   =  
         
    _
               
         _     
        
     = _ 
       
          
         = 
       = _ 
           
          
             
         = __    
         =  
            =    
 ____ == ____
  
参考资料：《技术解析与实战》
欢迎推荐上海机器学习工作机会，我的微信：月日晚，  蠕虫病毒在全球大肆爆发。据、等媒体报道，恶意攻击者利用 美国国家安全局泄露的   利用工具对个国家实施了超过次攻击。
什么是比特币勒索蠕虫病毒？
这次攻击的始作俑者是一款名为“”中文名：想哭的勒索病毒，带有加密功能，它利用  在  端口的安全漏洞潜入电脑并对多种文件类型加密并添加后缀使用户无法打开，用户电脑存在文档被加密的情况，攻击者称需支付比特币解锁，如下图图片来自互联网：

事件影响：国内高校网络系统沦为感染重灾区
这次  的攻击，被感染的机器有六个小时的时间缴付大约  美元的赎金，随后每隔几小时赎金上涨一次。英国   系统中超过  的机构目前已受到攻击，这些机构已经取消了所有的门诊预约并劝告可能的情况下尽量避免急诊。
受到攻击的还包括西班牙的电讯公司 ó、俄国内政部、  等等。
国内高校网络系统沦为感染重灾区。据有关机构统计，目前国内每天有数万台机器遭到该蠕虫病毒袭击，被黑的大四学生毕业论文被加密导致无法打开且被勒索赎金。如下为全球受影响地区分布图图片来自互联网：

腾讯云安全专家直播解答网友疑问
昨天，腾讯云安全专家张祖优还做客腾讯新闻，通过直播互动的方式，为网友们解释了此次比特币勒索蠕虫病毒的相关信息，并逐一回答了网友们关心的安全问题，给出了应对的具体措施。
直播回看如下：
当前浏览器不能支持视频播放，请采用或以上浏览器
腾讯云安全团队紧急为云上用户排查、提供修复建议
此外，腾讯云安全团队  月  日凌晨为云上用户紧急排查，连夜进行了分析，针对受害用户的主机的病毒和木马样本进行了提取、特征比对和入侵原因分析，发现大量受害主机可能是由于没有及时安装  更新补丁导致被攻击者入侵，从而使系统迅速感染病毒、 数据被加密，对此，腾讯云安全团队提供了如下应对方案：
腾讯云用户修复建议：
当前已受影响的用户，建议对未被加密的重要数据进行备份，并开展重装工作；
对于采用非腾讯云官方  镜像的用户，建议采取如下措施进行缓解：

在安全组策略中，检查您名下所有  云主机是否已关闭 、 、  服务端口的对外访问，建议禁止外部访问此类高危端口，详细修复可参考如下链接：；

目前微软官网发布的补丁已经修复了可导致该蠕虫病毒被传染的漏洞，建议用户及时安装  最新版本补丁包含此次受影响的  补丁，避免成为勒索蠕虫的受害者；

目前腾讯云官网提供的  镜像已经在月日全网更新完成，默认已安装最新补丁，并不受此次“比特币勒索蠕虫病毒”影响，请您放心使用。


温馨提醒
此次比特币勒索蠕虫病毒在互联网上的传播范围极广，影响范围巨大，建议针对您的重要业务系统立即进行数据备份，针对重要  系统安装补丁并制作系统镜像，以做好灾难应急恢复工作。前提

已经购买并且启动系统没有买的同学先去 旁边在用半个小时买个哈可以点击这里购买
能登陆
已经有域名解析到的公网没有也没有关系，但是你得会改，不会的话可以留言咨询

准备工作

把的外网、账号、密码放入记事本备用
已经打开浏览器

开始
打开，登陆，复制命令并且右键输入
        
      
然后一路回车

输入回车

经过分钟的等待，我们安装完了基础的软件。
双核的话估计可以到分钟左右，双核带宽可以到分钟左右

把上面这些内容复制到记事本备用，拖动选择，复制

复制最后这个组合的链接到浏览器打开

 打开之后输入账号密码然后点保存，账号密码可以自己想
然后登陆
 
添加我们的第一个网站

 红框的地方选一下，然后点击提交

 复制好，放入记事本保存一下

左侧打开文件管理，进入到域名的文件夹下面点击“下载”

输入
_
粘贴进去

 等待下载完成，整个文件，大概分钟不到就能完成受限制于对方服务器慢，左右

解压一下
进入目录

全选，剪切

返回根目录，粘贴一下
好了我们打开自己的域名解析到的公网或者修改到公网，自动跳转到安装界面

开始安装
把记事本的数据库的信息复制粘贴过来

提交一下

进行安装

取个名字、取个用户名、可以用自动生成的密码。填入邮箱，点击“安装”

安装完成，自动跳转到后台的页面

这是前台，著名的世界你好 ！
剩下的就是不断的投入时间美化、优化、更新网站啦！

相关推荐
博客平台
【腾讯云的种玩法】发送邮件设置
利用腾讯云搭建个人博客作者：、
 导语： 水坑攻击是一种常见的高级攻击方法。电脑管家安全感知系统最近捕获到一例，分析如下。

“门前大桥下游过一群鸭 快来快来数一数二四六七八……”
“”
“”
“”
““
故事梗概
故事情节是这样的：
一大波小黑，或许是为了免费体验游戏和游戏聊天平台，或者是为了彰显自己的技术实力，虚心了学习 网络上传至的破解视频，并忠心耿耿的下载了提供的工具，心急如焚的在自己电脑上在显身手，功夫不负有心人他们居然破解成功了。哼着小曲，玩着游戏……
此时此刻幕后的亦哼着小调，欢乐着盯着屏幕上的数据：二四六七八……
 
 某游戏玩家玩的不亦乐乎，殊不知，你的游戏被黑客截图回传了
故事原型
故事绝无虚构，如有雷同，纯属吻合。
事实上，腾讯反病毒实验室在追溯 系列攻击案例中，关注到一个网络为的黑客或黑客组织，利用水坑攻击引导受害者下载执行其定制的 ，进而控制受害者电脑。
初步预测已有数十万机器沦为的肉鸡。
截止撰稿前一周里，仍有多受害者变身为的“小鲜肉”。
 
从的后台上传来看，沦陷的机器多为游戏资深玩家和一些小黑客，部分机器上发现装有 开发环境 和  等黑客工具。
 
受害者电脑上的游戏帐号、网上银行信息以及比特币等敏感信息均会被回传至服务器，致使受害者财产面临着严重的安全威胁。
 
事件盘点
【投毒黑客工具】
盘点一下案例，提供了免费的  和 破解工具，并在等视频网站投放教学视频，手把手教用户怎么破解 和 ，然后坐等受害者入坑。
受害者通过搜索引擎发现视频 或 、破解工具，下载并执行恶意代码，恶意代码在受害者电脑下载并执行 ，黑客利用  服务器监视、控制受害者电脑。
 
【 】
 
基于视频资料，至少年起 就已经存在， 原本是一个简单的键盘记录器，记录用户的按键行为，并回传至黑客服务器。历经两三年的发展， 恶意程序开发发团队不断迭代新的功能，将 从一个简单的键盘记录器演化成了一个模块化的间谍软件，并通过互联网对 进行出售，而买家可以按需购买 模块，进而方便地部署利用 木马。
 
 的最常见的攻击方式是利用钓鱼邮件进行鱼叉式攻击，邮件中藏有恶意文件。用户一旦打开并允许程序执行，该恶意文件 就会自动下载安装 。但是随着针对性攻击事件不断发生，人们对钓鱼邮件的警觉性正在逐渐增强，钓鱼邮件的攻击成功率势必受到影响。
【水坑攻击
似乎并未受到影响，没有利用钓鱼邮件，而是利用水坑式攻击的思路，主要针对游戏玩家、黑客或破解爱好者这个群体，进行靶向攻击。首先，在互联网部署一个植入恶意代码的黑客工具，并通过发布其使用教程。受害者在相关视频引导下会主动下载并运行这个黑客工具，进而遭受的攻击。
 
 
 
“姜太公钓鱼，愿者上勾”，黑客工具一旦在受害者电脑上运行，就会执行事先植入的恶意代码，进而下载定制的 木马。 此时此刻就如同潜伏在水坑旁的狮子，享受着等待着猎物受害者的“投怀送抱”。借助  服务器与受害者电脑进行通信，对受害者电脑进行监控、控制，甚至窃取受害者银行帐号、游戏帐号、以及比特币等敏感信息并将回传到服务器。
黑客利用 木马向服务器回传了大量的受害者帐号信息。
 
木马危害
木马保留了远控功能，可通过接收服务器发送的指令下载执行任何恶意代码  同时该木马会收集各种软件信息、系统信息、文件信息，并通过木马定制窃取客户端、浏览器数据、邮箱帐号信息、比特币钱包等隐私数据，涉及的软件客户端有上百款：
 
【木马运行流程
木马会从资源中解密加载执行
、首先会通过检测指令运行时差、检测鼠标移动等方式进行调试检测，如果认为木马程序被调试，则会进入一个死循环，永不进行后续代码的执行。
 
、利用“借尸”方法创建一个同名的进程，然后通过，将再次解密的恶意代码注入到新建的进程中。
、通过，，恢复目标进程的执行。从而完成“僵尸”进程的创建，继而执行注入恶意代码。
、恶意代码可以同时包含数百个窃取信息的函数，每个函数可以针对一种或一类软件进行信息窃取，罗列了几种窃取场景：
①窃取 浏览器帐号密码存储
存放着 浏览器记录的帐号密码信息，通过命令。
将转换成文件，再利用   可以轻易的解密加密后的帐号密码。
 
转换的命令行如下：

       \ \\\\\

\\
②窃取浏览器的密码存储
通过查找文件，索引数据库表项，获取敏感信息 。
 
 
 
③窃取帐号密码
是一款包含服务端和客户端的软件。木马可通过查找相关文件获取到帐号信息。
 
 
④窃取邮箱信息
通过查询注册表获取邮箱信息 。
 
 
⑤窃取网络赌博平台帐号信息
目前是世界上最大的网络平台扑克室。
通过遍历查找特定文件夹中是否含有文件，解密其中的字段或者其他字段进行窃取。
 
⑥窃取比特币信息
比特币钱包的文件对于比特币账户来说非常重要，文件里存有私钥信息，如果没有通过严格加密，是完全有可能造成私钥泄漏，出现比特币被盗的。
 
传播趋势
服务器上传的截图分析发现，大部分受害者都是游戏爱好者，喜欢研究游戏破解，这些受害者或可称为“ ”。
受害者电脑上发现有使用包括屏幕录像直播、游戏开发引擎、鼠标自动点击、内存编辑，注入在内一款或多款工具 以及一些游戏：
 
地区分布来看美国、欧洲一些国家感染比较明显，亚洲地区主要集中在东南亚地区，这跟游戏及的发布地区密切相关。前言
很久没写文章了，额，因为最近自己整了一个网站大部分精力投在了我的个人网站 上，喜欢皮卡丘文章的朋友可以关注下哦
今天给大家带来的是腾讯云的文字识别如何使用它来识别身份证
当然，它还可以识别名片，还有许多功能，喜欢研究的小伙伴可以深入深入
本教程采用了语言，需要其他编程语言的，可以参考腾讯云的文档
正文
好了，现在开始正文
第一步下载
首先去文档中下载我们所需要的
点开这个连接你就会进入腾讯云这个项目的，直接下载你会得到
接下来把它解压出来
第二步安装我这里展示的方法
打开进入刚刚解压的路径
然后执行  
安装完毕
第三步编码
在解压的目录下新建测试文件 然后根据文档提供的信息，进行编码编码内容最后放出来
第四步创建万象优图的
地址 必须先登陆控制台
创建好后，查看我们的 _ _ 
进入云密钥进行查看

第五步完成编码并运行
代码如下：
 
    


从_包导入相关
 _  
 _       


设置你的 _ _ 
 = 
_ = 
_ = 
 = 

 =  _ _ 
_
_

身份证识别
单个或多个图片     表示身份证正面
 = _ 
 这里说明下 
腾讯云识别身份证的算法可能有点过拟合了，导致许多身份证不能读取，程序最后运行出现错误代码 所以这里笔者提供了一张“身份证”供大家测试
哈哈，测试了很多张，最后这张最好了其他的都了
目录结构

运行结果

好了，最终附上代码 _
最后祝大家国庆加中秋快乐  导语 ：白纸黑字是用户一贯的阅读习惯。在实际的使用场景中，黑底白字和白底黑字哪一种阅读体验会更好？对于我们的眼睛来说，哪一种搭配方式又会更舒适呢？

在人们的日常生活中，接触最多的书本、网页大部分都是白底黑字，这种方式已经成为一种阅读习惯。但是部分网站黑色背景浅色字体的搭配又让人们觉得体验很好、极具吸引力。那么就会有一些疑问：我们的眼睛更喜欢白底黑字还是黑底白字呢？哪一种搭配的可读性更高呢？
针对这个问题，可以从生理感知和心理感知两个方面来探讨
一、生理感知
从人类眼睛的生理机制来研究。人类视力是由光线进入角膜，角膜屈光后进入瞳孔，经过瞳孔的调节之后进入水晶体，然后集中在视网膜上再传导至大脑，如此转化为我们看到的影像。在这一过程中，有一些独特的生理现象对我们的视觉造成微妙的影响。
、侧抑制

侧抑制效应图：同样的颜色但是左侧方块会看起来更深 
侧抑制是指相邻的感受器之间能够互相抑制的现象，即在某个神经元受到刺激而产生兴奋时，再刺激相近的神经元，则后者所发生的兴奋会对前者产生抑制作用。当一个感受器受到刺激时，由此产生的神经冲动将对邻近部位的输入信号产生抑制性的影响。

因为侧抑制现象，人们在明暗变化的边界上，常常在亮区看到一条更亮的光带，在暗区看到一条更暗的线条，这个更亮和更暗的区域就是马赫带效应
总体来说，侧抑制网络在信息预处理中的主要功能有以下几个方面：

可以突出边缘，增加反差。
将很大的输入变化范围压缩到网络本身的动态范围之内，具有明显的亮度适应作用；
可以对图像的细微间断处进行拟合，具有明显的聚类作用。

影响：在阅读文字信息时，盯住的字会最清楚，这个字周边的其他字就会被视觉中枢弱化。侧抑制也是造成人类多种视觉错觉的原因之一。
、视觉适应

锥形细胞和杆状感光细胞
视觉适应是视觉器官的感觉随外界亮度的持续刺激而变化的过程。视网膜中包含锥状细胞和杆状感光细胞，锥状细胞负责在光线之下使视力清晰，并且感知颜色；杆状感光细胞让我们能在黑暗的环境感知弱光。视觉适应的机制就是这些细胞和神经活动的重新调整，可以分为暗适应和明适应。
暗适应：照明停止或者由明亮环境进入黑暗环境的时候，眼睛会暂时看不见事物，这个时候杆状感光细胞开始工作，提升对弱光的敏感度，使人类逐渐适应黑暗环境。杆状感光细胞有障碍的人就是“夜盲症”啦，并且杆状感光细胞不能辨别颜色，所以黑暗中看什么都是一个颜色！
明适应：照明开始或者由黑暗环境进入明亮环境，人眼感受性下降，眼睛过渡到明视觉状态。比如走出电影院，开始觉得阳光刺眼，但很快就能恢复正常状态。
影响：暗适应和明适应是人类眼睛应对环境光线刺激的反应能力，但是频繁的视觉适应会导致视觉迅速疲劳。
、视觉后像

盯住白色区域看秒，再看别处会看到白色区域的影像
光刺激对视觉器官的作用停止后，细胞的兴奋并不随着刺激的终止而停止，感觉现象能保留一个短暂的时间，这种现象叫做视觉后像。比如盯着灯泡看数秒，再看别处，会看到发光灯泡的影像。
影响：强烈刺激会引起视觉器官兴奋，产生视觉后像，同时会加速视觉疲劳。根据上面的几个视觉现象，可以得出这样的结论：
① 因为侧抑制的视觉现象，不论是白底黑字还是黑底白字，人类的眼睛都可以增加反差，让黑色字体更黑，白色字体更亮，从而清晰的识别文字。
② 因为视觉适应的原理，我们在光线充足的时候阅读黑底白字的信息，视觉聚焦于白色文字，黑色背景也会更暗，眼睛需要进行暗适应，所以会加速视觉疲劳。而在夜晚则相反，眼睛已经是暗适应的状态，阅读黑底白字的信息，不需要进行视觉适应，疲劳感不会增加。所以在晚上使用深色底浅色字的夜间模式会减少刺激，使眼睛更舒服。
③ 阅读黑底白字的信息时，因为侧抑制会使白色字体更加炫目，黑色背景更加沉重，长时间浏览白色字体，会产生强烈的光刺激从而产生视觉后像，造成视觉疲劳。所以即便在使用黑底白字的时候，也要通过降低对比度的方式，减弱这种光刺激，从而减轻视觉的疲劳感。而阅读白底黑字的信息时，聚焦的文字为黑色，不会产生光刺激，视觉后像的情况基本不会出现。
二、心理感知
、背景颜色属性

图为黑色和白色
黑色：黑色可以定义为没有任何可见光进入视觉范围显示屏是主动发光，不发光即为黑色，黑色可以让其他颜色变得更亮，从而凸显出来。从色彩心理学上来看，黑色传递出高雅、正式、名望、权力的感觉，大面积的纯黑会给人一种严肃和压抑的感觉。
白色：一种包含光谱中所有颜色光的颜色，通常被认为是“无色”的，且明度最高，无色相显示屏中把三原色组合在一起就发出白色光。白色是一个中立的颜色，常常被用作页面的背景色，大多数的印象就是干净和简洁，大面积的白色会有一种舒张、放松的感觉。
、搭配效果

单行字体效果对比
白底黑字：传统的白底黑字整体效果比较干净清爽，阅读时焦点不会第一时间落在文字上，由于周围白色区域反光，读者的注意力会不时发生游离。但是因为侧抑制的现象，聚焦不反射光的黑色字体时，视觉刺激并不强烈，所以长时间阅读造成的视觉疲劳感较弱。
黑底白字：对于黑底白字的形式，侧抑制的现象会使聚焦的白色字体变得更加炫目，视觉刺激强烈，能够迅速抓取读者的注意力，但是同样因为强烈的视觉刺激，会产生视觉疲劳感，不适合长时间阅读。
、阅读习惯

传统纸张书籍
用户普遍的文字阅读习惯源于白纸黑字的书籍，这种阅读习惯是悠久的历史延续下来的。因为最早期用来记录信息的工具比如木炭、墨水等多为深色，用于承载文字的动物皮、竹简等多为浅色。后来早期造纸术使用植物纤维本身也是浅色，所以白纸黑字已经成为人类历史多年积累的阅读习惯，再者目前市场制造的方面来说，纸张即便需要漂白，在成本上都比均匀染色要低的多。
、文字可读性

较长的信息文本
用户体验领域最著名的先驱之一   经研究得出：“文字和背景应当使用高对比度的配色。白底黑字能将可读性提升到最高，而黑底白字在可读性上的效果几乎是一样的。虽然两种配色方式对比度是相同的，但是后者还是会让用户对文字的识别稍慢一些。受限于配色方案，白色的文本内容相比于白底黑字的情况，会显得更加纤细、模糊，整体的清晰度其实是不如常见的黑字。这种情况在纯黑背景和纯白字体的搭配下，最为明显。”
根据上面几个方面，可以得出如下结论
① 白底黑字是人类长期以来的阅读习惯，可读性略高于黑底白字，聚焦时视觉刺激较弱，产生的疲劳感较少，比较时候多文本的长时间阅读。
② 黑底白字在阅读的时候，聚焦于白色字体，视觉刺激强，能够迅速的吸引注意力，但是同时因为视觉兴奋而易于产生疲劳感。比较适合需要突出重点，吸引读者注意力的场景。
三、总结
通过生理感知和心理感知两个层面进行分析，可以发现黑底白字和白底黑字的使用不是一个相对孤立的问题。人类的视觉生理机能很强大，可以通过侧抑制来强化自己需要阅读的部分，也可以通过视觉适应来应对不同强度光的环境。但是强大的视觉机能也对应着相应的视觉负担，所以黑底白字和白底黑字的使用可以根据以下几个方面来考虑
、根据产品所要展示的内容类型
白底黑字可读性更高，适合长时间阅读；黑底白字视觉刺激性强，能够吸引视线，不同的产品希望达到的目的不尽相同，所以要根据产品需求来进行设计。

注重文字阅读的网站
比如一个深度阅读的产品就可以使用白底黑字降低长时间阅读的疲劳感，增强文字的可读性来打造舒适的阅读体验。

注重视觉冲击力的摩托车主题站
、文字和背景的对比度

黑白底色上不同对比度文字的显示效果
背景和内容两者之间的对比度和可读性是成正比的，对比度越大，信息的可读性就越高。但是视觉刺激也会越大，所以控制合适的对比度，在视觉刺激和可读性中找到一个平衡点可以让读者阅读的更加舒服。比如即便是白底黑字也很少用纯黑纯白，多数使用浅色搭配深色的方式，黑底白字也是一样。
、使用产品时的环境因素
书籍的阅读基本都是有亮光的环境，因为纸质书籍是反射光，没有光就无法看清，白底黑字看着也最适合。电子产品、手机虽然都是屏幕自发光，但是同样要考虑环境光对于屏幕发光的影响。

知乎的正常模式和夜间模式
比如一些软件的夜间模式，就可以使用黑底白字来避免用户的眼睛从暗适应到明适应频繁转换，从而达到减弱刺激，降低疲劳感的目的。
最后，对于黑底白字和白底黑字的选择，需要结合明确的产品目的，配合恰当的对比度以及贴切的使用场景。正确的选择能在保证视觉生理舒适的情况下获得清晰的阅读体验，这样才会得到我们眼睛的喜爱！
作者：宗文博；深入思考设计中的细节与使用场景，从而打造更好的用户体验。现负责游戏平台部相关设计工作。写在前面的话：
、项目来源于主自学中的一个项目实践，主自身能力不足，因此文章很浅显
、泰坦尼克数据集是中一个好的可选数据集，网上有很多基于此数据集的分析存活预测实践的文章
、要有点基础哦 没有也没关系，先下载软件跑跑代码也是好的
话不多说，这就开始

一、前期准备
数据下载：_
软件准备：   安装  库                                                                                         
多嘴说一句，懒得装各种库各种包的童鞋，请直接下载。
另外推荐，代码报告结合神器
  用过的人都说好用，没用过的小伙伴赶紧开始尝试吧
 
二、分析开始
、导入数据查看基本信息
   
   
   
_=
 = __=  导入数据
    查看数据集的基本信息
   查看数据的摘要信息
    查看前几行数据，方便了解数据具体情况
以   “    ”    为例，运行后输出如下结果：
 
其中：

 = 乘客
 = 是否生还
 = 乘客等级等舱位
 = 乘客姓名
 = 性别
 = 年龄
 = 堂兄弟妹个数
 = 父母与小孩个数
 = 船票信息
 = 票价
 = 客舱
 = 登船港口

从数据集的基本信息可以看出， \  \  是存在缺失值的，其中字段缺失值过多。
对于少量缺失值的情况，常用的方法是去除和补齐，数值型的数据是可以根据统计学的方法或者机器学习的方法将其进行补齐的。
对于存在大量缺失值的字段，应衡量此字段的重要程度与修复代价之间的权重。主是果断的没有再考虑这个字段了
、分析 乘客存活率与各单变量之间的关系
 先看下全部样本的存活率是多少：
_ =   
 _ _
运行代码输出：_     
【舱位】
再看下 舱位和存活率之间的关系：
=======
===   == \
        ==   ==  \
        ==    == 
                               
                               
                               

__ =   
__=
__ 

输出结果如下：

可以很清楚的看出，舱位与存活率之间的关系。三等舱的乘客们很惨
【性别】
可以再简单看看性别的影响：
__ =   
__=
__ 

【年龄】
数据集里面的年龄是一个数值型变量，先按照未处理的裸数据来绘图
__=
__
__ 

 
得出的结果特别难懂。
对于连续型数值变量，可以先做特征离散化，将年龄分布在各个年龄段中，效果就好多了呢。
这里引出了特征工程中的概念离散化。
最近主刚上了一届特征工程的课，等待主的课后笔记吧
__= 去除年龄数据中的 
= 岁，每岁一段年龄最大岁 
_=__ 
__=___ 
__=____ 计算每年龄段的幸存率 
__=
___ 


感兴趣的小伙伴可以多尝试几个变量，看看能不能找到更有趣的结论哦
、分析 乘客存活率与复合变量之间的关系
一个数据表象，往往是多个因素影响的结果，其中多个因素的影响力各不同可以稍微联想主成份分析的概念。因此复合变量的分析也是必不可少的哦 
单变量中舱位和性别对存活率的影响都很大，主好奇到底是哪一个主要决定了乘客能否登上救生船，因此就对舱位和性别整合为复合变量，做了分析。
___=
___=
___ 


结果发现三等舱的女性存活率 高于 一等舱的男性存活率。可见当时的绅士风度啊！

再想想当时的帅哥，美男们     对不起我歪楼了。。。。。
、挑选更有意思的分析角度，得出让人信服的数据结论
对的，你没看错，主自认得出的结论很浅显，就不在这边现眼了，大家各自表演吧
写在后面的话：
、小白第一篇文章，有细节问题的话请大佬指导
、虽然自己很多时候是用   搞定数据分析的，但是大腿不能放
 喜欢你就收藏下吧    数据分析同道中人赶紧私戳 主一起携手走上人生巅峰作者|高剑林编辑|京露

高剑林，腾讯架构平台部，平台开发中心基础研发组组长。先后从事过通讯设备的开发和存储设备的研发工作。目前致力于一体化的涉及—从硬件和软件的结合，以及多个层面综合考虑系统设计，找出最优路径的设计思想。

接认识多种处理芯片的特性和实战上篇
 的架构
和类似，都是用门电路资源实现固定的算法，不同之处是是固定排列的门电路阵列，固定的排列方式决定了编程过程有大量的冗余电路没有充分利用，造成门电路资源的浪费，而是经过专门优化之后的门电路布局，相比较精简的多。根据厂商的提供的资料，实现同等功能所需的门电路数目可能比高倍。
从使用方式来比较，可以重复编程，而一次编程后无法更改。由于可重复编程的灵活性，设计芯片多数时候会先用实现逻辑功能，然后基于的结果进行优化和整合，得到最终的芯片需要的电路设计。
在真正的实践中，并没有进行的设计和实际的制造，这是因为的设计和制造非常昂贵，和合作厂商沟通的结果大概需要百万美元的投入。芯片的昂贵决定了它不可能在小规模应用的场合出现，而必须是大规模达到百万以上的量级的应用场景才可以分摊的昂贵投入取得经济上的合理性。这种特性导致一个有趣的结果，一种计算算法初步启动时常常使用作为硬件载体，利用承载算法，随着规模扩张，就有商业性的芯片出现。一旦规模达到经济上的合理，芯片的成本就远小于的成本并取代的地位。
一个事实就是 的应用。早期的 都是使用作为内部算法的硬件载体，而年以来随着 应用的规模化，已经有芯片出现并在一些 的产品中应用。后续芯片很可能替代在 的应用。
 计算实践和对比
为比较各种芯片的计算性能，以格式的图片进行解码和重新编码的计算为例子。下图展示了图像处理的算法过程。

图像的压缩过程：所有的图像数据首先要进行色彩空间的转换，从色彩空间转换为色彩空间。然后将图像分割为像素像素的图像块，对每个图像块进行离散余弦变换，然后对变换后的数据量化得到量化值，最后对量化值进行墒编码，得到压缩后的图像数据。
而图像的解码过程则是编码过程的逆向过程，首先对压缩的图像数据进行墒解码，得到量化之后的数据，然后执行反量化获得量化之前、离散余弦变换之后的数据，最后进行反离散余弦变换，获得原始图像数据。
  的实践和性能
对比测试的项目以每秒钟图片解码然后重新编码的性能为准，对单张图片循环重复计算，单位为张数。计算平台采用的处理器为至强，计算平台使用的转码软件是，多进程并发循环执行。下表给出的性能数据。

  的实践和性能
利用进行图片解码和再编码时，首先遇到了顺序执行的问题。解码里面的墒解码器使用的是霍夫曼解码。霍夫曼解码在解码图像数据时候，依次处理一个个图像块，块之间没有分割标志，因此存在数据依赖关系，必须把前面图像块的数据解码完成，才能处理下一个图像块。这种必须顺序执行的计算部分运行效率非常低，如果霍夫曼解码在里面完成，整体效率甚至不如。我们和公司的软件团队讨论了这个问题，最后确定的方案是将霍夫曼解码部分由完成。使用的异构编程应当被看做是的计算辅助单元，共同和完成计算任务，由于架构和配套资源的特点，很难把当作完整的解决方案。
第二个重要的问题是内存的分配和管理。以操作系统的角度来看，异构编程其实是对外部设备的编程，软件代码可以分成两部分，一部分在上面执行，另一部分在上执行。的内存分配其实是对设备内存的分配，这种分配操作运行性能很低，严重影响整体计算的效率。在实际测试的代码中，将所有的设备内存分配都在开始时候一次完成，避免实际使用时的内存分配。数据从内存复制到的设备内存后，才能进行高性能计算。因此需要减少内存的复制时间，尽量使复制过程和的计算叠加起来，形成流水式的操作。
使用的异构编程，需要时刻关注的利用率指标。这个指标代表的繁忙程度，如果利用率很低，说明没有充分利用内部的流处理器，存在流处理器较多时间空闲的情况，就需要调整和优化代码结构。一般说来，的利用率应该大于，这是才比较充分的利用了的性能。
最终的测试是和公司的软件团队共同完成，实验性能得到了公司的认同。下表给出对图像再编码的性能数据。
 
  的实践和性能
是一个单独的芯片，为了能在服务器环境使用芯片，需要设计一张计算卡，该卡使用接口和主机连接，卡上安装一片 的芯片，同时具有的内存。编程没有操作系统的支持和辅助，因此内部的资源必须用户自己管理，比如访问内存的数据，必须通过硬件逻辑来实现，芯片和外部设备之间的数据交换也必须全部由使用者设计硬件逻辑实现功能，比如通过接口将主机内存复制到卡内的内存等。
而且软件设计的生态环境和的环境不同，通常设计没有大量可用的开源软件。即使有一些公司提供商业的解决方案，费用一般也很昂贵。实际上在硬件设计领域，一般都流行商业授权的模式。商业公司通常将开发的硬件逻辑打包为 ，有购买意向的使用者和商业公司谈判使用模式和费用，谈判完成前一般不提供试用版本。
为了解决编程困难、生产效率低的问题，我们创建了一个编程框架，利用框架提供用户需要的控制和数据，用户只需要聚焦于算法和功能，而不必关心底层功能的实现。编程框架弥补了 没有操作系统支持的弱点，其实质上类似一个小型的操作系统，实现对资源的管理和使用。如下图所示：
 
上图绿色部分展示了编程框架的构成，当前编程框架包含对接口协议的封装、内存的存取和多路仲裁、功能、邮箱消息接口等。编程框架里面包含了下列的重要部件：
设备配置空间：设置设备配置空间的信息，包括设备，制造厂商和设备端口以及 资源：启动功能，从主机内存物理地址复制数据到卡内存的指定地址，或者从卡内存的指定地址复制到主机内存物理地址。
：从卡内存指定地址读数据，每次读出数据。或者往卡内存指定地址写数据，每次写入数据。
邮箱：邮箱提供主机和芯片之间的消息接口。
中断资源：中断接口管理和控制，通过接口可以触发一个系统中断。
在程序实现时最重要的问题就是资源利用率。和不同，如果资源没有限制，理论上可以部署足够多的计算单元，性能可以达到无限。在图片转码的实践中，基于的芯片，实际上部署了路的编解码核心，这时资源利用率达到。下表给出的性能数据。

 结论和综述
从整个实践的过程理解，芯片的使用是很复杂的过程。性能和性价比是否具有优势需要针对业务的计算类型设计程序和优化，并进行实际的验证得出结论。希望简单和一致性的结论没有可能，而厂商的结论多半并不可信，和实际验证的数据差别巨大。现实是硬件、环境和算法资源都很缺乏，这可能是异构编程应用不广泛和困难的原因。脱离了的支持，使用等芯片的异构编程困难太多，如果像集成一样，同样在内部集成功能，方便用户的选择和使用，将大大推动各种场景的实际应用。
相关推荐
 倍效率， 成费用，创业公司拥抱  的另一个选择国内首款  云服务器，性能是通用  服务器  倍以上导语
在深圳的研发部培训中，我们组给定一个有趣的课题便是：马里奥游戏的智能通关，本文就神经网络和增强学习两个点进行整理，并将我们最后用的算法以及扩展找到的算法进行了简单梳理。如果能够在游戏自动化测试、智能中应用这些有趣的算法，想想还是有点小激动哒 
马里奥实现方式探索：神经网络增强学习
儿时我们都曾有过一个经典游戏的体验，就是马里奥顶蘑菇，这次里约奥运会闭幕式，日本作为年东京奥运会的东道主，安倍最后也已经典的马里奥形象出现。平时我们都是人来玩马里奥游戏，能否可以让马里奥智能的自己闯关个呢？，利用人工智能的相关算法来进行自动化通关一直是一个热门的话题，最近最火的相关东东就是传说中的啦。而在游戏的自动化测试当中，这种算法也是非常实用的，可以大量的减少测试人力成本。首先，对于实现马里奥当中涉及到的神经网络和增强学习的相关概念进行整理，之后对智能通关的两种方式进行阐述。本人才疏学浅，在神经网络和增强学习方面基本门外汉，如有任何纰漏，还请大神指出，我会第一时间改正。
神经网络
像飞机的灵感来源于鸟类，雷达的灵感来源于蝙蝠，红外线的灵感来源于蛇，而本文要讨论的神经网络灵感来源于我们自己，人类大脑的神经元结构。从神经元结构被提出，到时下火热的无以复加的深度神经网络，发展过程也可为一波三折。我们按照时间的顺序，对一些经典的神经网络模型进行整理：
模型
年代初心理学家  和梳理逻辑家  提出  模型为啥叫模型，看看这两位大牛的名字，也不考虑下我们非英语系国家人民的感受。。。，神经网络被引入到计算机领域当中，其最初起源的灵感就是人类大脑中的神经元，如下图：

生物学上具体的专业术语我们这里不展开描述，我们总结一下神经元结构的特点：

每个神经元都是一个多输入单输出的信息处理单元；
神经元输入分兴奋性输入和抑制性输入两种类型；
神经元具有空间整合特性和阈值特性；
神经元输入与输出间有固定的时滞，主要取决于突触延搁。

由此两位大牛提出了神经网络的早期模型，如下图：

该模型的基本思想很简单，就是仿照神经元接受多个输入信号，由于突触的性质和突触强度不同，所以对神经元的影响程度不同，我们加上了权重的概念，其正负模拟了神经元中的兴奋和抑制作用，最后所有信号累加整合，其值为：

输入信号有了，神经元是否被激活，要看输入信号是否超过了某一阈值电位，如果被激活神经元输出脉冲，否则神经元不会输出信号，其过程如下函数：

当然这里我们也可以写成矩阵的形式
类似神经元结构的特点，经典的模型的特点可以总结如下：

每个神经元都是一个多输入单输出的信息处理单元；
神经元输入分兴奋性输入和抑制性输入两种类型；
神经元具有空间整合特性和阈值特性；
神经元输入与输出间有固定的时滞，主要取决于突触延搁；
忽略时间整合作用和不应期；
神经元本身是非时变的，即其突触时延和突触强度均为常数。神经网络中权重在训练结束后是固定的

结合两个公式来看这几个特点：对于特点，我们的公式有多个输入信号，但我们的输出信号只有一个；权重的正负体现了特点中输入分兴奋和抑制；对于第个特点，我们第个公式中只有当输入信号的累加和超出电位阈值才会有输出；另外我们的公式只考虑了所有输入信号的整合，并没有去考虑时间整合就是不管你信号早到晚到，只要到了都是好信号，体现了特性和。
随着模型的提出，神经网络的研究有三次兴起，最近的一次就是随着卷积神经网络提出的深度学习的火热。
早期神经网络
模型很简单，仅仅是一种单个神经元上的建模，并没有形成网络，没法去完成一些特定的任务。由此人们提出了神经网络的概念，而早期的研究，由于当时硬件水平和计算条件的限制，神经网络结构一般比较简单。
两层神经网络
由此年，计算科学家提出了由两层神经元组成的神经网络。他给它起了一个名字“感知器”其结构如下图：

这种简单的单层神经网络有点类似于逻辑回归，通过简单的权重训练，能够处理简单的线性分类问题，类似下图：

而对于非线性的分类问题如经典的异或问题却无能为力，后来研究人员也发现了这一点，神经网络研究遍进入了低谷期好伤心
三层神经网络带有隐层
问题总是用来解决的嘛，既然两层神经网络不住非线性分类问题，那么我们就加一层，称为隐含层，由此而来的三层神经网络如下图：

这种三层神经网络具有非常好的非线性分类效果，其计算公式如下：

当然啦，就像我们平时的逻辑回归模型一样，在模型中是必不可少的，所以我们在原有结构上加入偏置节点，结构图如下：

神经网络中偏置节点是默认存在的，而且它非常特殊，就是没有输入，并且会输出的后一层的所有节点。加入偏置节点后计算公式如下：一般情况下，偏置节点不会被画出来
与两层神经网络不同，理论证明三层神经网络能够无限逼近任意连续函数。这里我们不禁会有疑问，我们知道两层神经网络是线性分类问题，那么两个线性问题拼在一起为什么就可以解决非线性分类问题了呢？

上图很好的解释了我们的疑问。首先上图左侧部分可以看出，三层神经网络的决策分界非常平滑，而且分类的很好。而上图右侧部分展示了该图经过空间变换后的结果，我们可以看到输出层的决策分界仍然是直线，关键是，从输入层到隐含层时，发生了空间变换。也就是说三层神经网络可以做非线性分类的关键便是隐含层的加入，通过矩阵和向量相乘，本质做了一次线性变换，使得原先线性不可分的问题变得线性可分。所以多层神经网络本质就是复杂函数的拟合。现在三层神经网络结构定了，如何来进行网络的训练，这就需要用到反向传播算法本质就是梯度下降，还说的这儿玄乎
算法
上面我们提到两层神经网络，其中隐层的权值是需要我们学习的，而这个权值我们不能直接获取，所以我们利用输出层得到输出结果和期望输出的误差来间接调整隐层的权值。算法的学习过程由信号的正向传播和误差的反向传播两个过程组成。

正向传播时输入样本从输入层传入经各隐层逐层处理后传向输出层。若输出层的实际输出与期望的输出教师信号不符则转入误差的反向传播阶段。
反向传播时，将输出以某种形式通过隐层向输入层逐层反传并将误差分摊给各层的所有单元从而获得各层单元的误差信号此误差信号即作为修正各单元权值的依据。

下图展示了整个算法的信号流程图：

网络有三个要素：

网络拓扑结构
传递函数
学习算法

网络拓扑结构便是我们之前总结的两层神经网络结构，我们主要从传递函数和学习算法进行整理阐述下。
传递函数
首先什么是传递函数呢？请看下图：

图中是最基本的单个神经元的模型，针对于多个输入，我们会进行整合并利用一个非线性函数进行输出，函数的要求必须是可微单调递增函数，通常采用非线性变换函数———函数也称函数形状，有单极性型函数和双极性型函数两种高中数学里的东东。

单极性型函数定义如下：


函数曲线图如下似乎不够。。

双极性型函数定义如下：

函数曲线图如下：

可以看出根据上面的函数，我们会整合所有输入，输出一个新的值，从之前生物学的原理来看也就是说神经元是否被激活。
学习算法
学习算法是神经网络结构的核心，也是两层神经网络有一次兴起的重要原因，因为人们找到了如何去训练一个神经网络来达到我们预期的分类效果拟合不同的非线性连续函数。而算法反向传播算法的本质其实就是一种逐层梯度下降。
我们以三层感知器为例，当网络输出与期望输出不一致时，存在误差，定义如下：

将以上误差反向逐层展开体现了反向传播算法中的反向含义

最终我们展开到输入层如下：

根据上式我们发现误差是的函数，我们发现调整权值可以改变误差的大小，而调整权值的原则是使得误差不断减小。因此我们应该使得权值与误差的梯度下降成正比，如下：

其中值得注意的是表示学习效率，即权重调整的幅度。我们可以看出对于权重的调整是从输出层逐层反传过来的，而且我们也发现我们在梯度下降的过程中需要求导，这也就是我们在最初要求传递函数可微的原因
深度神经网络
有三层神经网络，我们自然而然就会想到将神经网络加入更多层，扩展到深度神经网络，但是一个非常显著的问题就是参数的个数，比如之前我们的三层神经网络每层有个节点，那么我们需要调整的权值参数就达到了量级，这问题限制了很大程度上限制了深度神经网络的发展。这就要把大哥叫出来帮忙了，就是近期一直火热的 ，由于本人在这方面也是门外汉，只从经典的卷积神经网络进行一些归纳整理。
的解决之道
根据网上的资料总结，的核心点有三个：

局部感知：形象地说，就是模仿你的眼睛，想想看，你在看东西的时候，目光是聚焦在一个相对很小的局部的吧？严格一些说，普通的多层神经网络，隐层节点会全连接到一个图像的每个像素点上，而在卷积神经网络中，每个隐层节点只连接到图像某个足够小局部的像素点上，从而大大减少需要训练的权值参数。我们用两张对比图来说明下：


从图中我们可以看出，对于一张×像素的图片，假设神经网络中的隐节点有个。对于传统的深度神经网络，所有的隐节点会连接到图像中的每个像素点，那么我们需要训练的权重参数就达到了匪夷所思的量级。而提出局部感知，即图中右侧展示的，每个神经元只与×个像素值相连，那么我们的权重参数就下降到，参数数量为原来的万分之一虽然还是很多

权值共享：形象地说，就如同你的某个神经中枢中的神经细胞，它们的结构、功能是相同的，甚至是可以互相替代的。局部感知的方式在一定程度上减少了参数，那么另一个减少参数的神器便是权值共享。在上面我们提到的局部感知的例子中，对于个神经元，每个神经元需要局部感知×个像素点，那么参数个数是×个，那么如果我们在这里假设每个神经元的权重参数都是相同的，那么我们的参数个数就会骤减到个，很夸张对不拉，做到这一步的神器便是卷积操作。

权值共享基于的原理或者说假设是图像中局部的统计特征与其他部分是一样的，也就意味着假设我们在图像的局部学习到了一组特征，那么我们可以直接将这组特征应用到图像的其它部分。就拿上面的例子来看，我们假设在第一个神经元中学习到了局部×像素点的特征，那么我们完全可以将这个特征应用在图像的其他位置上，那么我们另外的的神经元权重参数就不需要训练了，所以我们只需要训练第一个神经元的权重参数即可，而这第一个神经元得到的局部特征称为卷积核。当然啦，我们不会这么变态的只用一个卷积核，这样对于图像特征的提取也是不充分的，所以往往中都会有多个卷积核来进行卷积操作，每个卷积核会提取出图像某一方面的特征。如下图展示了卷积操作的基本原理：

图中展示了一个×的卷积核在×的图像上做卷积的过程。每个卷积都是一种特征提取方式，就像一个筛子，将图像中符合条件激活值越大越符合条件的部分筛选出来。

池化：形象地说，你先随便看向远方，然后闭上眼睛，你仍然记得看到了些什么，但是你能完全回忆起你刚刚看到的每一个细节吗？不能也没必要，我们通常会提取整个图像中一些关键的点作为一种“映像”放到脑海中。同样，在卷积神经网络中，通过卷积获得了特征之后，下一步我们需要利用这些特征去做分类，当然我们可以利用所有这些特征去做分类如分类器，但同样的这里又会遇到我们的老问题，计算量过大。所以，在进行分类之前，我们利用人类判别图片记录关键特征的原理，同样在处理卷积层输出的特征时，我们也可以做一些“压缩”或者说提取处理，这种方法被称为池化。以最大池化 为例，×的图像经过×的卷积核卷积后，得到的是×的特征图参考上图×图像经过卷及操作变成了×的图像，然后使用×的池化规模，即每个点组成的小方块中，取最大的一个作为输出，最终得到的是×大小的特征图。池化得原理我们可以用下图形象的说明：


整体结构
上面我们从的三个核心点出发，阐述了的基本原理，下图我们列出了的整体结构：

图中从左至右描述了神经网络的几个不同层

输入层图像：在神经网络的输入当中，一般为了减少复杂度，往往采用灰度化后的图像作为输入，而如果使用的彩色图像，那么输入会分为三个分量图像。输入图像一般都需要归一化，常规的可以使用我们前面阐述的函数，归一化到，如果使用激活函数，则归一化到 。这一部分我们涉及到了我们上面阐述的局部感知的方式来减少参数。

多个卷积下采样层：将上一层的输出与本层权重做卷积得到各个层，然后下采样得到各个层，这一部分主要涉及了我们上面阐述的三个核心点中的卷积和池化操作，而这些层的输出称为 。

 光栅化：是为了与传统的多层感知器全连接。即将上一层的所有 的每个像素依次展开，排成一列。

传统的多层感知器最后的分类器一般使用，如果是二分类，当然也可以使用逻辑回归。至此关于的基本原理基本阐述完毕啦，关于的参数训练等内容这里不再赘述，可以参考 ：五十一的反向求导及练习


总结
长出一口气，从最一开始单个神经元模型的提出，到两层和三层的简单神经网络，再到时下火热的深度学习，我们可以用下图从时间上进行一个大致的梳理：

我们可以看到，神经网络的发展经历了三次跌宕起伏：

 感知器：第一次兴起的研究点便是科研人员利用两层神经网络起了个玄乎的名字感知器进行了简单的分类问题，当时的人们大呼找到了人工智能的奥秘，从而兴起了对神经网络的研究，但是随着众多学者发现两层感知器只能完成最简单的线性分类问题，对于经典的异或分类问题都无法完成时，神经网络陷入低谷。


算法：第二次兴起的关键点便是算法的提出，当人们发现两层神经网络无法胜任非线性分类问题时，已经想到了增加神经网络层数，但是随着网络层数的增加，权重参数如何训练的问题无法解决，直到反向传播算法的提出，解决了这一问题，从而发生了神经网络的又一次兴起。但是随之而来的其它算法，如，等算法的提出，人们发现这些算法的通用性和可计算性都优于神经网络，神经网络进入到了第二次低谷。

深度学习：第三次兴起的关键点便是时下火热的深度学习了，它的标致之一便是卷积神经网络的提出，将它用于图像分类问题当中当然了这也离不开硬件水平的提高，比如高并行的诞生。


而对于每次神经网络可解决的问题，我们可以用下图来阐述：

上图中我们可以看出，随着神经网络的发展，我们在解决最基本的分类问题时的效果越来越好，这也是神经网络的魅力所在啦。当然在神经网络发展的过程当中，计算机硬件水平的发展也是不容忽视的，随着计算能力和性能的提高，原来不可能实现的想法、算法都能付诸实践进行试验。
增强学习
机器学习领域，我们都知道两位大哥就是监督学习和非监督学习，我们有样本和标记或者未标记的，我们通过训练可以做一些分类或者聚类的任务。但是，对于一些序列决策或者控制问题，是很难得到上面那样的规则样本的，比如机器人的控制问题，决策机器人下一步该怎么走，那么这时我们就需要清楚另外一位大哥——增强学习，虽然他似乎曝光度并不是很高，那么何谓增强学习呢？
增强学习  ，其英文定义如下：

       ——      ——        

也就是说增强学习关注的是智能体如何在环境中采取一系列行为，从而获得最大的累积回报。
通过增强学习，一个智能体应该知道在什么状态下应该采取什么行为。是从环境状态到动作的映射的学习，我们把这个映射称为策略。
接《马里奥  实现方式探索 ：神经网络增强学习下》 简介
本是在 里引入的一种跨平台的基于的布局系统，它实现了规范，随着该系统不断完善，对其进行重启发布，并取名为。详情可以参考 。
有如下特性：

完全兼容布局，遵守的规范。
支持、、、四种语言。
底层代码使用语言编写，性能不是问题，并且可以更容易跟其他平台集成。
支持流行框架如 。

 简介
年，提出了一种新的方案——布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。
目前的前端主要是使用实现，其中用于前端的布局。任何一个的容器可以通过指定为布局，一旦一个容器被指定为布局，其子元素就可以按照的语法进行布局，但是设为布局后，子元素的、和会失效。
指定布局的方式如下
{     }
的基本语法
想要使用，首先必须要了解的基本语法，因为布局中的属性均是使用的语法进行设置的，只是具体的不一样而已。的基本语法不是本文想要讲解的内容，但是在网上有很多学习资料，在官网的   中也有部分对的基本介绍，可以通过其进行一些了解。
 应用
 新增内容
  宽高比
 宽高比是较之于规范新增的属性，主要适用于已知一个方向的长度以及宽高比的布局情况，比如说，或其他多媒体类型，它接受大于的类型的值。 的特性

 依赖于的最小和最大尺寸。
 比有更高的优先级。
如果的 ，和属性均被定义，则轴的尺寸被覆盖规范有轴和轴的概念，由容器的属性指定轴的方向。

 自右向左布局
前端不支持，而支持。
对于，和新增了和的值，当当前布局方向为时，表示右边而表示左边，这与布局恰好相反。熟悉 布局的可能对和属性比较熟悉，因为在之后也引入了和，用于适应某些国家或某些人的书写方向的习惯。
 搭配开发的环境配置
方法一：自己安装使用编译项目进行环境配置

由于是使用构建的，所以首先需要在你的电脑上安装，通过 官网_ 可以了解如何安装和使用进行编译，网上也有许多关于构建的资料可以自行查找，这里就不进行赘述了。
从上获取， 在目录下使用进行编译，由于这里只是进行开发环境的配置，所以目前只需要编译目录下的代码即可。编译命令为   和   。编译过程中出现的一些问题可以在文章最后的章节看到。
编译完成后，在目录下的下找到了许多包，但是并没有编译出库，尝试各种方法都没有办法输出库，根据 中所说的，使用  命令编译，则出现了     错误。错误信息说是指定的编译属性无法识别，查看文档， 文档中没有这样指定编译属性的说明，网上这方面的资源也比较少，找不到相关的错误和解决办法，摆弄好久都没有解决掉，所以这块只能暂时放在一边了。

方法二：从示例工程获取已存在的模块导入使用

获取并编译 ， 运行成功，其项目结构只是一个普通的工程导入的外部工程模块。
新建一个工程，通过         导入下的模块，并切换到视图，右键点击自己工程的  ，打开工程结构，选择下的后选择的，添加新的模块依赖后重新执行一遍即可。也可以再文件中直接加入 
接着便可以在新建的工程中使用的 编写相关代码，并成功运行。

可以看到通过方法二便可以使用特性和编写代码了，其关键在于这个模块，现在来看看这个模块到底是什么吧。
模块中目录下主要有两个包，和，可以在方法一的第点中所说的目录中找到。目录下为代码和一些库，代码为 中目录下的代码，库则是 中所说的生成的一些库，但是通过方法一无法成功生成这些库，只好借用一下别人生成的。
这个模块，可能是以下三种来源中的一个。一是对外发布的，二是上项目生成的，三是该示例的作者自己写的，具体情况还不确定，但是有一点可以确定，就是在新建项目或者已存在的项目通过导入该模块便可以直接使用的特性。
 在上的使用
如何在上使用布局呢？这里首先要复习一下 ， 因为在的与中设置属性有极大的类似。这里对其分别简述一下方便对比。
 在上的使用

使用语言指定容器和子项目 =
   =
   =


使用语言指定容器为布局 {
   
}

设置容器属性以及子项目布局属性 {
   
}
  {
   
}

设置容器外观属性和子项目外观属性
= {
   
   
   
   
   
   

  
          
         
          
         

   
}
 {
   
   
   
   
   

   
          
}

执行结果

 在上的使用

创建
  =  
  =  
  =  

属性设置


  
  
_

  
  
   

  
  
   
_

设置容器和子项目，与不同的是，这里不需要进行指定布局方式，而是只要有的就是容器，没有的就是子项目。 
 

计算布局

获取布局结果



创建自带控件并根据布局结果设置控件位置属性，因为和的适配目前还不完善，在上使用布局只能获取布局计算结果并且自己设置。


  =  
_




  =  
_




设置容器外观属性以及子项目外观属性。由于无法设置外观属性，实际上设置的外观属性还是针对控件来设置，使用简单设置一下外观，以下分别是背景和小圆点。

 =
    =
     =
        =


 =
    =
     =
     = =
     =
        =


执行结果


可以看出，这两种布局方式大同小异，都是指定容器和子项目，并设置其属性。其属性设置也均符合规范，只是一个直接指定，一个调用方法指定。不同的是使用需要调用获取布局结果，而布局结果也只是每个中保存了一些位置和大小等信息，并不是向中直接有显示布局结果。
按照上述所说，使用的方法后，每个内就保存了它在屏幕上应该存在的位置与大小，但是这些属性如何使用在的布局系统上呢？或者说如何与的布局联系起来呢？
之前有一个想法是，通过这些属性信息，再对的控件的属性信息设置，或者说，本身就进行了这样的处理。
于是看了看官网，按照官网上所说，用来将和其他布局系统联系起来的参数，使用能够使一个和一个联系起来。

于是编写如下代码：
  =  
  =  


再次运行程序，屏幕上并没有显示。所以可能确实是要自己根据计算的布局结果来进行相应的设置，这样一来就特别麻烦，需要自己写一个库来进行相应的处理以便进行这些设置。
这里简要写一个可以显示布局效果的，通过仿照 中的骰子写的，其中的控件的位置是通过计算结果然后自己设置的，所以代码比较丑。
首先使用进行布局
  =  
  
  
_

 =   
 =   


  =  
_

 

  =  
  
  

 

  =  
_

 

  =  
  
  
   
 

  =  
  
  
   
 

  =  
  
  
   
 

  =  
  
  
   
 


接着新建动态并且根据布局结果设置的属性
  =  
_




  =  
_




  =  
_




  =  
_
  
  


  =  
_
  
  

执行结果如下，代码可以从 获取。

总结

优点

可以只写一次布局，然后在不同终端上让自己计算布局情况，并进行布局。

缺点

在上的并不太好用，使用计算出的结果只是一些位置信息，并且无法兼容自带的控件，需要自行加些适配。

对现有代码的入侵特别大，需要将所有的的布局替换成的布局模式。
由于属性的局限性，部分可以实现的布局使用无法实现。

总的来说的概念虽好，但是还不太成熟，对于这块，还没有进行相应的适配，无法和自带的控件结合起来，导致实现麻烦且很多布局无法实现。不过如果结合起来了，又怎么跨平台布局呢？所以说还有很长一段路要走。


主要为编译的过程中出现的问题

编译一开始会出现找不到下部分文件的错误。解决办法：删去目录下文件相关代码之后编译正确。可能是某些不存在，但是部分是用于验证自己修改源代码是否正确，提交前测试的，所以目前并不需要这部分，所以可以暂时删去。

然后会出现未指定_和_的错误，解决办法是：新建一个文件指定或者在环境变量中设置_  _即可，因为之前都是在 中设置的，没有设置环境变量。

      使用的情况，即，但是打开的相应文件夹发现没有该文件夹，所以考虑使用 下载相应的库。这个还有一个解决办法是指定  为 \目录下存在的库。作者：
团队：腾讯移动品质中心
一、概念篇
测试左移 通俗的说即将测试行为放入软件开发周期的较早阶段进行，不局限于软件提测后再介入测试。我们理解的测试左移思想有两个层面：
、测试流程上左移，即软件开发周期较早阶段介入测试 ，比如在需求阶段，设计阶段等；
、测试早于或者同步于开发活动，即是在软件开发各个阶段提供软件质量保证，比如单元测试，准入测试等。我们理解的测试左移的思想贯穿整个软件开发周期。 
图  测试左移 
测试左移的目的是尽可能的将大部分软件缺陷发现在软件开发周期早期，这样除了可以保证软件质量，也能够控制和减短软件开发周期。测试左移要做到：尽早的测试接入，尽早的发现测试问题，可以从产品流程规范和测试效率的提升保证测试左移的效果。
二、方法篇
这里主要介绍浏览器在版本迭代流程中使用的测试左移方法，概括起来主要包括：产品开发流程规范化和测试方法自动化测试。
图 浏览器测试左移方法 
产品开发流程的规范主要包括：
、需求评审 测试人员参与需求评审，需求确定，避免由于后续测试变更引入的新问题。
、测前质量把控：严格控制版本量，测试提供给开发，加强开发自测，提升提测质量。
、合流准入规范： 控制代码合入质量标准，执行 合入规范等。测试方法：
、单元测试：与开发代码同步，问题发现在编码阶段；
、测试： 跟随版本编译，保证每个版本主要功能正常；
、其他自动化测试： 准入测试，接口测试等。
相应的自动化准备成熟稳定后，持续集成管理，保证测试质量和效率。
三、实践篇
这里主要介绍浏览器自动化测试相关实践，所列的内容基本都处于建设阶段。
、单元测试
单元测试是测试左移的方法之一，单元测试工作在开发编码阶段， 能够较早的发现代码缺陷。单元测试在一些公共或者核心模块收益比较大，单元测试代码与开发代码在一起，开发开发过程中，可以发现比较隐蔽的问题，保证代码质量稳定性。单元测试一般是开发主导的测试行为，单元测试效果依赖代码耦合度，实现起来难度比较大，所以测试需要引导开发养成编写单元测试的习惯，并且可以提供单元测试用例给开发。
浏览器以小说模块后台作为单元测试试点，使用 作为单元测试框架，目前正在调研编写单元测试用例中。
、接口测试
接口测试主要是保证常用的接口的功能的稳定性，接口测试需要保证接口输入数据的全面性。浏览器目前对模块、小说模块和文件模块进行了接口测试。由于接口自动化测试直接使用浏览器对应的功能接口，自动化实现后非常稳定，不会受到等变化的影响，维护成本小，属于低投入高回报类型测试。接口测试基本上可以用于软件开发的各个阶段，老的接口自动化测试可以保证接口原先功能的稳定性，可以通过需求和设计，通过等手段，补充新功能的接口自动化用例，保证新功能的正确性，提升测试效率。
目前小说接口建设情况如下表所示：
图 小说接口测试
浏览器文件模块支持了文档，图片，音乐，压缩包等四大接口，覆盖种文件格式，文件持续集成后的接口测试结果如下图：
图 文件支持格式测试结果 
、准入测试自动化
所谓的准入测试自动化，既是将功能模块的常规功能做成自动化，开发在对这个模块进行修改提测后，需要执行对应模块的自动化测试，自动化测试通过后方可提测新功能。准入测试的宗旨在于保证老功能的正确性，保证修改不会造成老功能有问题，提升提测质量，缩短测试时间。
浏览器文件能力支持了系里格式，每种格式支持很多种属性，浏览器对属性的支持是逐步完善的。 每次完善或者添加新的属性，必须要保证老的属性的正确性，保证排版的稳定性。浏览器文件针对每种格式文件，搭建了准入测试自动化库，目前包括用例条。自动化触发入口搭建在平台，测试将自动化自动化触发入口交给开发，开发在提测新的功能时，触发对应的自动化用例即可执行准入自动化测试。
准入测试适用平台管理，可以将接口直接交给开发，触发运行。
准入测试结果通过后，开发才能够提测相应功能。
收益：
提升开发提测质量，缩短测试时间，提升测试效率；
插件半年提测次，准入通过后版平均每轮可以减少小时人。
、测试
概念：
  版本验证测试，是在所有的开发工程师都已经提交自己代码后，编译生成版本之后进行的测试，主要目的是验证最新生成的软件版本在功能上是否完善。测试用例只需要覆盖主要的软件能力，能够在版本构建成功后，快速运行得到整体测试结果。
浏览器测试
 浏览器测试一般需要在集成测试后进行功能均已提交  浏览器功能比较复杂，测试用例 按照形式建设，这样可以保证功能之间的独立和运行时间的控制，目前浏览器建设情况如时数据，多数名用代替：
图 浏览器建设情况
、测试用例：按照各个进行测试用例准备，保证用例之间的独立性，目前各个都在加紧用例的准备补充和完善中。
、代码覆盖率： 衡量自动化测试的指标之一，目前在模块和文件模块两个接入了代码覆盖率统计，目前单个覆盖率左右。
、执行情况： 采用构建触发的形式进行集成后的版本测试，会统一接入平台运行，当前可以构建运行的是文件，构建运行次，平均每次节省人力，后续会陆续接入其他 测试。
图 浏览器任务 
总结：浏览器自动化相关时间正处于建设阶段，在测试左移的使用效果会在后续版本给出进一步数据。
获取更多测试干货，关注腾讯移动品质中心公众号。 类型系统
最近纠结一个问题，前端的  由于其动态的特性，写几行代码，在浏览器刷新一下就能看到结果了，非常适合快速开发和迭代。但随着代码的规模越来越大，到了后期就会变得难以维护，任何的改动都有可能引入新的 ， 工程师需要花费越来越多的时间来调试修复各种 。
造成这样结果的原因有多样，而其中之一的原因，是由于  缺乏类型系统，导致我们无法通过工具来在开发的过程中检测到那些可能会发生的错误，也无法通过具体的类型定义来约束别人如何调用自己写的代码库。
这样的想法其实在  社区里已经得到越来越多人的认同，最近几年也陆续推出了多种不同的  类型系统用于增强  的健壮性，其中像就是其中的佼佼者。当然我今天要讲的并不是 ，而是由  推出的。
 和  不同， 是  的超集，是另外一门语言向下兼容 ，而 ，则是一个静态类型检测工具，并没有修改  的语言特性。 通过自动推断  代码中各个变量的类型，来约束代码的行为，举个例子，在  中对两个变量进行相加，在不同情况下会得到不一样的结果：
  =  
  = 
  = 
  = 
  = {   }
  =     

 情况 
      
 情况 
     
 情况 
      
 情况 
       
 情况 
      
上面的  种情况，在  中都是被允许的，然而情况  和 ，在一般情况下并不是我们所期望的。而在  中，则只允许情况  通过检测，而对于情况  和  则直接报错了。
   
               
   
 

   
               
   
 
 除了可以自动的进行类型推断外，还可以通过类型声明的来进一步限制代码的行为，例如我们声明一个函数，接受一个参数，并返回一个字符串，如果我们不进行额外的类型声明， 默认是会接受  和  两种类型的参数
  {
       
}



但如果我们希望我们的函数只接受  作为参数，并且明确返回 ，则可以
    {
       
}
这是如果再传入  则会报错，对于完整的  使用，大家可以参考  这里

                 
    {
                     
 环境的搭建
要在项目中使用 ，需要完成三件事情
第一安装  命令行工具
    
 
   
第二，编写  代码，并在代码的第一行，加入注释  
 
 =     {
       
}
这时候， 已经知道该文件是需要做类型检测的，这时候运行   命令初始化 
_ 
 会自动在该目录下创建 文件，接着我们运行  命令，就可以在后台启动  进程进行类型检测了
   =
    
 
如果需要停止  进程，只需要运行   命令即可
_ 
到现在为止，虽然  已经可以正常运行了，然而因为我们在  代码里添加了额外类型声明，导致  代码不能直接在浏览器里执行，这时候我们需要做第三步，通过代码构建的方式，把  转换成浏览器能执行的形式。
这里我采用的   作为我们构建环境，所以首先我们需要安装  和 
     
然后我们需要安装  的  套装，使得  支持 
   
然后我们编写  的配置文件 
 = {
   
   {
     __
     
  }
   {
     
      {
         
         _
         
      }
    
  }
}
还有我们的  配置文件
{
   
    
  
}
到这里为止，我们已经完成了构建环境的配置，接下来执行  命令，就会产生我们的目标文件
_
打开目标文件，我们就会发现， 的类型声明已经被正确去掉了。
到现在为止，整个  的环境已经算搭建完成了，然而在写了没几行代码之后，我们就会发现，每次要对代码进行检测，都需要打开 ，敲上一堆命令才能看到结果，实在是不爽。有没有办法可以节省这些多余的工作，把  集成到编辑器中呢？答案当然是肯定的。
这里我使用的编辑器是  ，如果有的同学是使用其他编辑器，可以在  这里，找一下
对与像我一样使用  的同学，首先我们要在  里安装  插件，   打开  ，选中   。输入 ，安装即可。
 是一个语法校验的框架，但其本身并不会去做实际的校验工作，我们需要另外安装  的  插件，同样是打开  ，输入 ，安装即可。
这时  就会在当前文件夹向上查找 文件，并对带有   的文件进行自动检测，如果出现错误，就会直接在编辑器上提示，十分的方便。  

加入  语法校验
除了类型检测，有时候我们还需要对  进行语法校验，当然很多成熟都工具都可以帮我们完成这样的功能，这里我使用的 ，对于其他的例如 ，，小伙伴都可以自行 。
首先我们要安装  以及 ，使得  可以集成到  里
    
安装好  后，就可以执行   命令来初始化  了
 _ 
这时  就会问你一些问题，一步步帮你完成初始化的工作，并生成对应 文件，这时候，我们需要更新一下  文件，加入对  的支持，记得  一定要写在  之后，这样  才能正确执行
 = {
   
   {
     __
     
  }
   {
     
      {
         
         _
          
      }
    
  }
}
不过如果这时候，你试着执行  命令进行构建，你会发现，报错了，原因是  不认识  的类型声明语法。为了让  能通过  的类型声明，我们需要安装两个工具，一个是  的  插件 ，另一个是  的  版  解析器 ，这是由于  默认的  解析器认不得  的类型声明
    
接着我们修改一下  的配置文件，把  字段设置为 ，然后分别在  和  加入  相应的设置
{
   {
     
     
     
     
  }
   
     
    
  
   
   {
     
  }
   
    
  
   {
       {   }
      
      
      
  }
}
，现在我们再次执行  命令就能正常进行构建了。
最后最后，我们再通过在  中安装在  的插件  就可以让我们的编辑器也支持  的语法校验了。
这就是我这次给大家分享的，如何大家一个摩登的前端开发环境学爬虫我们已经了解了多种请求库，如 、、 等。我们接下来首先贴近实战，了解一下代理怎么使用。
下面我们来梳理一下这些库的代理的设置方法。
 获取代理
在做测试之前，我们需要先获取一个可用代理，搜索引擎搜索“代理”关键字，就可以看到有许多代理服务网站，在网站上会有很多免费代理，比如西刺：，这里列出了很多免费代理，但是这些免费代理大多数情况下都是不好用的，所以比较靠谱的方法是购买付费代理，很多网站都有售卖，数量不用多，买一个稳定可用的即可，可以自行选购。
或者如果我们本机有相关代理软件的话，软件一般会在本机创建  或  代理服务，直接使用此代理也可以。
在这里我的本机安装了一部代理软件，它会在本地  端口上创建  代理服务，也就是代理为 ，另外还会在  端口创建  代理服务，也就是代理为 ，我只要设置了这个代理就可以成功将本机  切换到代理软件连接的服务器的 了。
所以本节下面的示例里我使用上述代理来演示其设置方法，你可以自行替换成自己的可用代理，设置代理后测试的网址是：，访问该站点可以得到请求的一些相关信息，其中  字段就是客户端的 ，我们可以根据它来判断代理是否设置成功，也就是是否成功伪装了。
下面我们来看下各个库的代理设置方式。
 
首先我们以最基础的  为例，来看一下代理的设置方法，代码如下：
   
    _

 = 
_ = {
       
       
}
 = __

     = 
    
   
    

运行结果如下：
{
   {} 
   {
      
      
      
     
  } 
    
   
}

在这里我们需要借助于  设置代理，参数是字典类型，键名为协议类型，键值是代理，注意此处代理前面需要加上协议，即  或者 ，此处设置了  和  两种代理，当我们请求的链接是  协议的时候，它会调用  代理，当请求的链接是  协议的时候，它会调用代理，所以此处生效的代理是：。
创建完  对象之后，我们需要利用 _ 方法传入该对象来创建一个 ，这样就相当于此  已经设置好代理了，接下来直接调用它的  方法即可使用此代理访问我们所想要的链接。
运行输出结果是一个 ，它有一个字段 ，标明了客户端的 ，此处的  验证一下，确实为代理的 ，而并不是我们真实的 ，所以这样我们就成功设置好代理，并可以隐藏真实  了。
如果遇到需要认证的代理，我们可以用如下的方法设置：
   
    _

 = 
_ = {
       
       
}
 = __

     = 
    
   
    

这里改变的只是  变量，只需要在代理前面加入代理认证的用户名密码即可，其中  就是用户名， 为密码，例如  为，密码为 ，那么代理就是 。
如果代理是  类型，那么可以用如下方式设置代理：
 
 
   
   

__  
 = 

     = 
    
   
    

此处需要一个  模块，可以通过如下命令安装：
  
本地我有一个  代理，运行在  端口，运行成功之后和上文  代理输出结果是一样的：
{
   {} 
   {
      
      
      
     
  } 
    
   
}

结果的  字段同样为代理的 ，设置代理成功。
 
对于  来说，代理设置更加简单，我们只需要传入  参数即可。
还是以上例中的代理为例，我们来看下  的代理的设置：
 

 = 
 = {
       
       
}

     =  =
    
   
     

运行结果：
{
   {} 
   {
      
       
      
      
     
  } 
    
   
}

可以发现  的代理设置比  简单很多，只需要构造代理字典即可，然后通过  参数即可设置代理，不需要重新构建 。
可以发现其运行结果的  也是代理的 ，证明代理已经设置成功。
如果代理需要认证，同样在代理的前面加上用户名密码即可，代理的写法就变成：
 = 

和  一样，只需要将  和  替换即可。
如果需要使用  代理，则可以使用如下方式：
 

 = 
 = {
       
       
}

     =  =
    
   
     

在这里需要额外安装一个  模块，命令如下：
  
运行结果是完全相同的：
{
   {} 
   {
      
       
      
      
     
  } 
    
   
}

另外还有一种设置方式，和  中的方法相同，使用  模块，也需要像上文一样安装该库，设置方法如下：
 
 
 

__  
 = 

     = 
    
   
     

这样也可以设置  代理，运行结果完全相同，相比第一种方法，此方法是全局设置，不同情况可以选用不同的方法。
 
 同样也可以设置代理，在这里分两种介绍，一个是有界面浏览器，以  为例介绍，另一种是无界面浏览器，以  为例介绍。

对于  来说，用  设置代理的方法也非常简单，设置方法如下：
   

 = 
_ = 
__=  
 = _=_


在这里我们通过  来设置代理，在创建  对象的时候通过 _ 参数传递即可。
这样在运行之后便会弹出一个  浏览器，访问目标链接之后输出结果如下：
{
   {} 
   {
     == 
       
     = 
      
      
      
           __      
  } 
    
   
}

可以看到  同样为代理  的地址，代理设置成功。
如果代理是认证代理，则设置方法相对比较麻烦，方法如下：
   
   
 

 = 
 = 
 = 
 = 

_ = 
{
     
    _ 
      
     
        
        
        
        
        _
        
        
    
     {
         
    }
}


_ = 
  = {
         _
         {
           {
             
             
             
          }
        }
      }

{   }  {}

  {
     {
         {
             
             
        }
    }
}


            
            { _}
            

  {       }

_ = __
 _   
     _
     _
_ = 
__
___
 = _=_


在这里需要在本地创建一个  配置文件和  脚本来设置认证代理，运行之后本地会生成一个 __ 文件保存配置。
运行结果和上例一致， 同样为代理 。

对于 ，代理设置方法可以借助于 _ 参数，也就是命令行参数，代理设置方法如下：
   

_ = 
    =
    =

 = _=_

_

在这里我们只需要使用 _ 参数，将命令行的一些参数定义为列表，在初始化的时候传递即可。
运行结果：
{
   {} 
   {
     == 
       
      
      
      
                
  } 
    
   
}

运行结果的  同样为代理的 ，设置代理成功。
如果需要认证，那么只需要再加入  选项即可，这样参数就改为：
_ = 
    =
    =
    =


将  和  替换为认证所需的用户名和密码即可。
 本节代码
本节代码地址为：。
 结语
本节介绍了前文所介绍的请求库的代理设置方法，稍作了解即可，后面我们会使用这些方法来搭建代理池和爬取网站，进一步加深印象。作者  译：  

原文 《        》 
 的普及导致了一个非常活跃的技术，框架和类库的生态系统。 随着这充满令人惊叹的多样性和能量的生态圈的到来，许多人的烦恼也变得越来越多。
什么样的技术才是你应该关注的呢？在哪里投入你的时间才能获得最大的利益？ 哪些技术栈是是招聘公司现在所需要的？ 哪些技能又具有最大的增长潜力？现在知道的最重要的技术是什么？ 
你需要了解的信息，都在这篇高度概括的文章中。文章中收集了能让你快速学习它们的链接。
记住，当你正在学习体验一些实际的代码。 你可以在  上执行这些代码。 如果你还在学习，你可以了解到它是如何使用   进行转换。 
这是列表很长，但不要气馁，你可以完成它！ 如果你在查看这个列表时，担心是否能学习这些建立现代应用程序所需要的一切知识，那么请阅读 “ ’    ” 。 然后扣下来上班。然后全身心的投入到工作中吧。  
可选学习笔记
这种标致  表示是严格可选的，这意味着，我推荐他们，如果你对他们感兴趣，或者你的工作需要了解它们，但你不应该感到有学习他们的义务。 标记有星号例如， 的任何内容都是可选的。
任何没有标记为 的东西都应该学习，但不要把学习这些当成义务。 而那些非可选的东西你应该有一个大题的认知，不用在各个方面都成为一个独当一面的专家。
   基础知识
在你找到一个以  为生的工作前，你需要对  的基础知识有深刻的了解。

 内置方法 学习标准的数据类型     还有 。
   函数  纯函数你可能认为你已经掌握了很多函数，但有一些技巧，你需要学习纯函数来掌握函数式编程。
 闭包 了解函数作用域的一些特征
回调 回调是当另一个函数用于在有结果就绪时准备执行的函数。 就像你说，“做你的工作，做完后给我打电话。
  是处理异步回调的一种方式。 当函数返回一个时，你可以在解析之后使用方法来附加回调函数。 解析的值被传递到你的回调函数，例如。 = 

  =  =    = {
     

   = {
    
  } 
}

  =  = 

   

    
     
        
  


    
 
       
    

     和服务器调用 那些最好玩的应用程序最终需要与网络通信。您应该知道如何使用那些  去进行通信。
 当前版本的 是  ，但很多开发人员还没有正确学习 。 已经是过去式了。
             
  函数式编程基础 函数式编程通过组合运算函数来生成程序，避免共享状态和可变数据。多年以来，我没有看到有大量使用函数式编程应用程序。是时候掌握基本原理了。
   在我看来，最好的方式来写异步代码看起来同步。它的学习曲线比较陡峭，但一旦你学会了，代码将更容易阅读。
  —   “ ”  “”
    渐进式应用程序 “   ”  “     ”
    允许你在服务器上使用，这意味着你的用户可以将数据存储在云中并随时随地访问。  是  社区中最流行的框架。
 一个伟大的，模块化的实用程序工具包，包含功能编程的好东西。从  导入  功能模块。

工具

   检测和  调试器：在我看来它是最好的调试器，虽然也有一些非常酷的你想要体验的工具。
 语言的标准开源代包存储库
   分布式版本管理器  随时查看你源码中的修改。
 用于编译  以在旧版浏览器上工作。
 最流行的标准  打包工具。通过一个简单的配置文件，让项目快速运行。
       你需要一个编辑器。  和  是当今最流行的编辑器。  是另一种解决方案，对质量工具提供非常强大的支持。我建议学习  ，或至少加入你的备忘单，因为迟早，你需要在服务器上编辑文件，掌握  是最简单的方法   安装在几乎所有的  兼容的操作系统，通过  终端连接可以很好的运作。
：早期捕获语法错误和风格问题。在代码审查和后，你可以做第三件事，以减少代码中的错误。
：类型推理工具的标准，目前我最喜欢的类型相关的  工具  不需要编译步骤或注释。 提供了大部分的好处，几乎没有使用静态类型系统的  的成本。
 类似于 ，但安装行为是确定性的，的目标是比  快。
 的静态类型。完全可选，除非你学习 。 如果你不使用  ，你应该在选择之前仔细评估。我喜欢很多，我赞赏  团队的出色工作，但是你需要知道的权衡。所需阅读：“关于静态类型的令人震惊的秘密”和“你可能不需要”。
 的静态类型检查器。请参阅“与”，以获得令人印象深刻的客观比较。注意，使用  来使我的  有表现好的反馈有一些困难，即使使用的是 。

 是一个用于构建用户界面的  库，由  创建。 它基于单向数据流的想法，这意味着对于每个更新周期：

 接受组件的输入作为 ，并有条件地渲染  更新，如果数据已经改变了  的特定部分。 在此阶段的数据更新不能重新触发渲染，直到下一个绘图阶段。
事件处理阶段  在渲染  之后， 侦听和事件，将事件委托给其  树根为了更好的性能的单个事件侦听器。 你可以监听这些事件并更新响应中的数据。
使用对数据的任何更改，该过程在步骤中重复。

这与双向数据绑定形成对比，其中对的改变可以直接更新数据例如，如在 和  的情况下。 使用双向绑定，在  渲染过程称为  中的摘要循环中对 的 更改可能会在绘制完成之前重新触发绘图阶段，从而导致回流和重绘  从而降低性能。 没有规定数据管理系统，但推荐使用基于  的方法。  的单向数据流方法借鉴了函数式编程和不可变数据结构的思想，改变了我们对前端框架架构的思考方式。
有关＆架构的更多信息，请阅读 “               ”。

 ：开始使用  的最快方法。
 ： 的简单路由。
 ：简单的通用渲染和路由  ＆  。
 ：的动画  允许您使用    在页面上进行交互式视觉运动设计。


 为您的应用程序提供事务性，确定性状态管理。在  中，我们遍历操作对象流以减少到当前应用程序状态。要了解为什么这很重要，请阅读  “     ”。要开始使用 ，请查看  创建者   的优秀课程：

“   ”
“     ” 

 是强制性学习，即使你从未使用  作为实际项目。为什么？因为它会给你很多实践，并教你使用纯函数的价值，并教你如何将通用函数 ，用于迭代数据集合并从中提取一些值。 通常有用，以至于已添加到  规范。 不仅仅对于数组是重要的，同时学习使用 的新方法本身也是有价值的。

 ： 的同步样式的副作用库。使用它来管理  例如处理网络请求。

 
  是  广受欢迎的  框架的继承者。 因为它疯狂的人气，掌握它会使简历看起来很棒—— 但我仍旧建议优先学习  。我喜欢   ，因为：

 更简单
 很受欢迎，许多工作都需要它使用 也是  

为此，我推荐学习 ，但我认为  严格可选。 如果你对 有强烈的偏好，请随意交换它们。 首先学习 ，并考虑可选。 两者都将会使你的简历看上去更优秀。无论你选择什么，尽量将精力集中在它至少个月  年后，再去学习另一个。 掌握它们真的需要相当多的实践。
 为什么我没有列举出你们喜欢的那些框架
很多人问我，“为什么没有列举出他们喜欢的框架？” 因为其中一个重要标准是，“在工作中能被真正的用上”。是的，这是一个人气竞赛，但当你在思考学习的时间投入在什么上时，了解一个框架的时机变得格外重要。为了回答这个问题，我看了一些关键指标。 首先，趋势。 如果您想重现此趋势图，请记住按主题而不是关键字进行选择，因为其中几个字词会带来大量的假阴性。 换句话说，这些是以主题为主的趋势，而不是关键字搜索：
 
这告诉相关的各种项目对什么有兴趣。  如果人们正在搜索它们，那么它们很可能正在搜索的选择，或寻找帮助或文档。 这是一个相对合理的评价指标。另一个很好的数据来源是 ，它汇集了来自各种来源的工作列表数据。 近年来，招聘广告的人气急剧下降，但他们仍然收集足够的数据，以便做出良好的相对比较，告诉你框架，人们实际上在生产项目中使用，在工作上：

要重现这些发现，搜索   并将该位置留空。 正如你可以清楚地看到： 和  遥遥领先 除了，它用于所有网站  包括非应用程序的巨大份额  因为它被几乎所有的遗留系统使用，包括流行的  系统，如 。  
你可能会看到  在这些列表中比  有显着的优势。 为什么我依然推荐优先学习 ？ 因为：

更多的人对学习  比对  感兴趣
 在用户满意度方面显着引领  

换句话说， 赢得了社区活跃和用户体验的战斗，如果过去一年半的趋势继续保持， 有一个非常明显的机会，使 代替  成为主导的前端框架。  拥有改变这个局面的机会，所以  可以卷土重来，但到目前为止， 正在处于一个优势的局面。

是的反应式编程实用程序的集合。把它比作  的 。   响应时编程已经正式进入了  场景。   提案是一个阶段草案，  是规范的标准实现。虽然像我很喜欢  ，但如果你一次打包完整的 ，你的包将会变得很大这其中有有很多运算符。 为了减少打包体积，不要导入整个包，请改用补丁导入：
 {  }  
      
 
 

  =   
 =    = 
使用补丁包将减少你的使用补丁导入可以将捆绑包中的  依赖关系的大小减少约 。 这是一个很好的优化，它会让你的应用程序更快。
下一步
现在，你已经研究了所有这些最流行的技术，接下来请阅读 “          ”。 
    。 如果你不是会员，那么你错过了。

原文作者   是 “  ”和 “    ” 的作者。 他为  ， ，华尔街日报，， 以及包括 ， ， 等顶级唱片艺术家的软件体验做出了贡献。
他花费大部分时间在旧金山湾区与世界上最美丽的女人。

原文链接：


相关推荐     你可能不知道的 的变化英译微信小程序 扶持计划《大话  》系列文章通过通俗易懂的语言并结合基础实验，用最简单的描述来讲解  中的重要概念。让读者对分布式存储系统有一个清晰的理解。
引言
那么问题来了，把一份数据存到一群  中分几步？
 的答案是：两步。

计算 
计算 

计算 
首先，要明确  的一个规定：在  中，一切皆对象。
不论是视频，文本，照片等一切格式的数据， 统一将其看作是对象，因为追其根源，所有的数据都是二进制数据保存于磁盘上，所以每一份二进制数据都看成一个对象，不以它们的格式来区分他们。
那么用什么来区分两个对象呢？对象名。也就是说，每个不同的对象都有不一样的对象名。于是，开篇的问题就变成了：

把一个对象存到一群  中分几步？

这里的一群 ，由  组织成一个集群，这个集群由若干的磁盘组成，也就是由若干的  组成。于是，继续简化问题：

把一个对象存到一堆  中分几步

 中的逻辑层
 为了保存一个对象，对上构建了一个逻辑层，也就是池，用于保存对象，这个池的翻译很好的解释了  的特征，如果把  比喻成一个中国象棋棋盘，那么保存一个对象的过程就类似于把一粒芝麻放置到棋盘上。
 再一次进行了细分，即将一个  划分为若干的  归置组  ，这类似于棋盘上的方格，所有的方格构成了整个棋盘，也就是说所有的  构成了一个  。
现在需要解决的问题是，对象怎么知道要保存到哪个  上，假定这里我们的  名叫 ，共有  个 ，给每个  编个号分别叫做      。
要解决这个问题，我们先看看我们拥有什么、不同的对象名。、不同的  编号。这里就可以引入  的计算方法了  。
对于对象名分别为和的两个对象，对他们的对象名进行计算即

 = 
 = 
 = 

对对象名进行  后，得到了一串十六进制输出值，也就是说通过  我们将一个对象名转化成了一串数字，那么上面的第一行和第三行是一样的有什么意义？ 意义就是对于一个同样的对象名，计算出来的结果永远都是一样的，但是算法的确将对象名计算得出了一个随机数。
有了这个输出，我们使用小学就会的方法：求余数！用随机数除以的总数，得到的余数一定会落在 之间，也就是这个中的某一个：

   === 
   === 

于是乎，对象保存到编号为的中，对象保存到编号为的中。对象永远都会保存到 中！ 对象永远都会保存到 中！
现在又来了一亿个对象，他们也想知道自己会保存到哪个中，说：“自己算”。于是这一亿个对象，各自对自己对象名进行，得到输出后除以总数得到的余数就是要保存的。
求余的好处就是对象数量规模越大，每个分布的对象数量就越平均。
所以每个对象自有名字开始，他们要保存到的就已经确定了。
那么爱思考的小明同学就会提出一个问题，难道不管对象的高矮胖瘦都是一样的使用这种方法计算吗，答案是， 也就是说不区分对象的真实大小内容以及任何形式的格式，只认对象名。毕竟当对象数达到百万级时，对象的分布从宏观上来看还是平均的。
这里给出更一点的说明，实际上在中，存在着多个，每个里面存在着若干的，如果两个里面的编号相同，怎么区分呢 于是乎，对每个进行了编号，比如刚刚的池，给予编号，再建一个就给予编号，那么在里，的实际编号是由__组成的，也就是说，刚刚的对象会保存在这个里，这个对象会保存在这个里。其他池里的名称可能为 等。
中的物理层
理解了刚刚的逻辑层，我们再看一下里的物理层，对下，也就是我们若干的服务器上的磁盘，通常，将一个磁盘看作一个实际上，是管理一个磁盘的程序，于是物理层由若干的组成，我们的最终目标是将对象保存到磁盘上，在逻辑层里，对象是保存到里面的，那么现在的任务就是打通和之间的隧道。相当于一堆余数相同的对象的组合，把这一部分对象打了个包，现在我们需要把很多的包平均的安放在各个上，这就是算法所要做的事情：计算的映射关系。
加上刚刚的对象映射到的方法，我们将开篇的两步表示成如下的两个计算公式：

池  对象名  _ === _
_ === 

使用代替？
在讨论算法之前，我们来做一点思考，可以发现，上面两个计算公式有点类似，为何我们不把

_ === 改为
_ _ ===  

我可以如下几个由此假设带来的副作用：

如果挂掉一个，_，于是所有的  _的余数都会变化，也就是说这个保存的磁盘发生了变化，对这最简单的解释就是，这个上的数据要从一个磁盘全部迁移到另一个磁盘上去，一个优秀的存储架构应当在磁盘损坏时使得数据迁移量降到最低，可以做到。
如果保存多个副本，我们希望得到多个结果的输出，只能获得一个，但是可以获得任意多个。
如果增加的数量，_增大了，同样会导致在之间的胡乱迁移，但是可以保证数据向新增机器均匀的扩散。

所以只适用于一对一的映射关系计算，并且两个映射组合对象名和总数不能变化，因此这里的假设不适用于的映射计算。因此，这里开始引入算法。
引入算法
千呼万唤始出来，终于开始讲算法了，如果直接讲的博士论文或者的代码的话，可能会十分苦涩难懂，所以我决定尝试大话一把，希望能让没有接触过的同学也能对其有所理解。
首先来看我们要做什么：

把已有的_映射到上，有了映射关系就可以把一个保存到一个磁盘上。
如果我们想保存三个副本，可以把一个映射到三个不同的上，这三个上保存着一模一样的内容。

再来看我们有了什么：

互不相同的_。
如果给也编个号，那么就有了互不相同的_。
每个最大的不同的就是它们的容量，即还是的容量，我们将每个的容量又称为的权重，规定权重为，为，也就是以为单位的值。

现在问题转化为：如何将_映射到有各自权重的上。这里我直接使用里面采取的算法，翻译过来就是抽签，说白了就是挑个最长的签，这里的签指的是的权重。
那么问题就来了，总不至于每次都挑容量最大的吧，这不分分钟都把数据存满那个最大的 了吗？是的，所以在挑之前先把这些搓一搓，这里直接介绍的方法，如下图可忽视代码直接看文字：


_ _ _   === 
     _ === _
   __

第一行，我们姑且把当做一个常数，第一行实际上就做了搓一搓的事情将_ _和一起当做_的输入，求出一个十六进制输出，这和对象名完全类似，只是多了两个输入。所以需要强调的是，对于相同的三个输入，计算得出的的值是一定相同的。
这个到底有啥用？其实，希望得到一个随机数，也就是这里的，然后拿这个随机数去乘以的权重，这样把随机数和的权重搓在一起，就得到了每个的实际签长，而且每个签都不一样长极大概率，就很容易从中挑一个最长的。
说白了，希望随机挑一个出来，但是还要满足权重越大的被挑中的概率越大，为了达到随机的目的，它在挑之前让每个都拿着自己的权重乘以一个随机数，再取乘积最大的那个。那么这里我们再定个小目标：挑个一亿次！从宏观来看，同样是乘以一个随机数，在样本容量足够大之后，这个随机数对挑中的结果不再有影响，起决定性影响的是的权重，也就是说，的权重越大，宏观来看被挑中的概率越大。
这里再说明下造出来的随机数，前文可知，对于常量输入，一定会得到一样的输出，所以这并不是真正的随机，所以说，是一个伪随机算法。下图是_的代码段，我喜欢叫它搅拌搅拌再搅拌得出一个随机数

如果看到这里你已经被搅晕了，那让我再简单梳理下选择一个时做的事情：

给出一个_，作为_的输入。
__ _  得出一个随机数重点是随机数，不是。
对于所有的用他们的权重乘以每个_对应的随机数，得到乘积。
选出乘积最大的。
这个就会保存到这个上。

现在趁热打铁，解决一个映射到多个的问题，还记得那个常量吗？我们把，再求一遍随机数，再去乘以每个的权重，再去选出乘积最大的，如果和之前的编号不一样，那么就选中它，如果和之前的编号一样的话，那么再把，再次选一次，直到选出我们需要的三个不一样编号的为止！
当然实际选择过程还要稍微复杂一点，我这里只是用最简单的方法来解释在选择的时候所做的事情。
下面我们来举个例子，假定我们有个，需要从中选出三个副本：

这是 = 的情况，这时候，我们选出_    的值最大的一个，也就是的这就是我们选出的第一个。然后，我们再让 = ，再生成一组_的随机值，乘以的，再取一个最大的得到第二个，依此得到第三个，如果在此过程中，选中了相同的，那么将再加一，生成一组随机值，再选一次，直到选中三个为止。
算法的应用
理解了上面选择的过程，我们就很容易进一步将算法结合实际结构，这里给出在他的博士论文中画的一个树状结构图：

最下面的蓝色长条可以看成一个个主机，里面的灰色圆柱形可以看成一个个，紫色的可以也就是一个个机柜， 绿色的可以看成一排机柜，顶端的是我们的根节点，没有实际意义，你可以把它看成一个数据中心的意思，也可以看成一个机房的意思，不过只是起到了一个树状结构的根节点的作用。
基于这样的结构选择，我们提出了新的要求：

一共选出三个。
这三个需要都位于一个下面。
每个内至多有一个。

这样的要求，如果用上一节的选的方法，不能满足二三两个要求，因为的分布是随机的。
那么要完成这样的要求，先看看我们现在有什么：

每个的。
每个主机也可以有一个，这个由主机内的所有的累加而得。
每个的由所有主机的累加而得，其实就是这个下的所有的权重之和。
同理推得每个的有累加而得。
的其实就是所有的的权重之和。

所以在这棵树状结构中，每个节点都有了自己的权重，每个节点的权重由下一层节点的权重累加而得，因此根节点的权重就是这个集群所有的的权重之和，那么有了这么多权重之后，我们怎么选出那三个呢？
仿照选的方法：

从下的所有的中选出一个。
在刚刚的一个下面的所有中，选出三个。
在刚刚的三个下面的所有中，分别选出一个。

因为每个都有自己的权重，所以选的方法和选的方法完全一样，用的权重乘以一个随机数，取最大。然后在这个下面继续选出三个，再在每个下面选出一个。
这样做的根本意义在于，将数据平均分布在了这个集群里面的所有上，如果两台机器的权重是：，那么这两台机器上分布的数据量也是：。同时，这样选择做到了三个分布在三个不同的上。
那么结合图例这里给出算法的流程：

 ============ 
  ======== 
  =====    在下
  ========    在三个下
 ================   

这里给出算法的两个重要概念：

  和我们的磁盘一一对应，是除了以外的所有非子叶节点，比如上面的等都是。
 ： 选择遵循一条条选择路径，一个选择路径就是一个。

一般分为三步走   。这一步负责选择一个根节点，这个根节点不一定是，也可以是任何一个。 做的就是按照每个的以及每个语句选出符合条件的，并且，下一个的选择对象为上一步得到的结果。就是输出最终结果，相当于出栈。
这里再举个简单的例子，也就是我们最常见的三个主机每个主机三个的结构：

我们要从三个下面各选出一个，使得三个副本各落在一个上，这时候，就能保证挂掉两个，还有一个副本在运行了，那么这样的就形如：

 ============     注意是根节点的名字
  ========    
  ========    


这里我们来简单总结一下：我们把一个生产环境的机房画成一个树状结构，最下面一层为层，每个有自己的权重，的上面由等等节点构成，每个节点的权重都是由下层的节点累加而成，选择每个节点的算法都是一样的，用它们的乘以一个随机数取其中最大，只是我们通过的语句来判断选择的节点类型和个数。最后不要忘了选出来的结果是的映射，比如     和      每个都有自己到的映射关系，这个关系用公式总结就是： _    。
到目前为止，我们已经完成了一份数据保存到一群的第二步，再整体回顾下这个流程：

每个文件都有一个唯一的对象名。
_  对象名  _ 得到_
_ 得到该将要保存的组合
这个对象就会保存到位于这些上的上就是磁盘上的目录

所以，算法负责计算对象名到的映射，负责计算到的映射，暂且记住这一点。
里的虚虚实实
现在，我们有三台主机，每台主机上的配置如下：

但是想要构建成如下的结构：

这里我们不能把一台主机劈成两半把盘和各分一半，所以就来介绍下里面的虚虚实实，什么是实？所有的都是实实在在的节点！什么是虚？除了之外的所有都是虚的！
也就是说，我们可以建立几个，分别名叫 ，而这些不需要和实际结构有任何关系，可以看成是我们假想出来的结构，为了达到分层的目的，我们可以假象出任意形式的。
将所有的添加到节点下，再将加入到根节点下，同理处理剩下的三个盘。那么现在可以制定两个：

：

 
 





 
 




具体的建造指令可以参考之前的这篇博客《自定义》自定义
这一节想要说明的是，里面的节点除了之外的所有都是可以自定义的，并不需要和实际的物理结构相关，但要记住这样做的目的是将分开，从而建立适当的去选择，所以不要把树状结构建立的脱离了实际情况，比如从三个机器上各挑一个然后放到一个自定义的节点下，虽然可以这样做，但是是没有意义的，说白了要根据自己的数据分布要求去构建树结构，因为只认并不知道你底层的实际结构！！！
 甚至，你可以像这篇博客《：层次聚类映射示例》里面一样构建出花式的树状结构！一切都在于你的想象力以及集群的应用需求。

中的
现在再正式介绍算法在中的存在形式，首先导出一个集群的 
      
      
       
    
   
 __ 
 ___ 
 __ 
 __ 
 __ 

 
  
  
  
  
  
  
  
  
  

 
  
  
  
  
  
  
  
  
  
  
  

 
  {
                 
      
     
          
       
       
       
}
  {
                 
      
     
          
       
       
       
}
  {
                 
      
     
          
       
       
       
}
  {
                 
      
     
          
       
       
       
}

 
 _ {
     
     
    _ 
    _ 
      
         
     
}

   
 
简单介绍下几个区域的意义：

：还记得_算法中的变量吗，选择失败的时候这个值经常会自加一，__ 这个就是用来限定总共失败的次数的，算法本身是个递归算法，所以给定一个总共失败次数防止算法无限选择失败。那么如果要选出副本，选失败了次只选出一个，那么最终结果是？将输出， ，这样的输出，也就是说只给出一个，一般很少会遇到这种情况，除非你要从一个只有一个的下面去选出三个。
   就是所有的的集合。
 就是集群内所有的的类型的取值范围，所有的都要属于这些类型，当然，你可以自己增删这里给出的类型，注意后面的数字必须唯一，因为算法在保存类型时不是使用字符串，而是类型对应的数字，所以类型名称在眼里是没有意义的。
：就是树上的除了以外的节点，从内容来看可以发现，每个都有向下包含关系，这里看到和类型的是一样的，在底层并不保存节点的名称字符串，而是以数字保存的，值得一提的是，的是大于等于零的，的是小于零的。还有就是 ，因为是最公平的选择方法，其实还有三个算法  ，因为没有综合分高，所以就不介绍了。
： 最下面的区域是我们修改的最多的地方，_这个是这个的名称，需要唯一，同样只保存这个的，其就是 这里的所以需要添加一个的时候需要注意名称和都不能重复。下面的三个就是的三步走策略，里面具体的参数我就不再赘述，可以参考官方文档《地图》这章。

还是简单的讲解下这句     ， 实际的里面分为和两种，其中用于选择多个，是最终选择结果，相当于 。用于选择多个，并在这些下各选出一个，是最终选择结果，相当于    。后面的就是要选择的类型。后面的是选择的副本数，等于副本数，也就是的意思，具体参考官方文档的解释。
所以论文中的图，对应到实际的就是：
 _ {
     
     
    _ 
    _ 
      
         
         
     
}
总结
介绍完了这两步走的核心流程之后，最后再着重强调下计算两字，可以发现，从对象计算再到计算组合，从头到尾都是通过计算得到最终的映射关系的，但是这些计算不论放在客户端还是服务器端，计算的结果都是相同的，因为里面所谓的随机值都是伪随机，只要传入一样的输入得到的输出结果都是一样的，所以把计算对象存储位置的任务发放给客户端，实际上，客户端在计算完一个对象需要保存的之后，直接和建立通讯，将数据直接存入中，只要集群的没有变化，客户端和服务端计算出来的保存位置都是一样的，所以这大大的降低了服务器端的计算压力。
本文没有直接介绍算法，而是从把一个对象存进的流程来分析，着重解释了对象到的映射，到的映射这两个流程，介绍了它们的计算方法。
最后再给一个别人画的计算路径图，仅供理解。

大话系列文章
《大话》之那点事儿《大话 》之  那点事儿《大话  》之  那点事儿

本文来自： 公众号平台简介
指的是多款软件的集合。指的是系统，指的是网站服务器，指的是数据库软件，指的是软件。目前是一款最流行的免费开源的操作系统。可以做为高性能的和反向代理服务器，也可以作为代理服务器。
关于学习与入门，可参考本人下面这篇文章，详细介绍了相关知识【 】。是一个小型关系型数据库管理系统。是一种在服务器端执行的嵌入文档的脚本语言。
软件安装
源码安装

安装依赖包

          

源码包编译安装，在官网下载

          解包
  
  __            配置
                                           编译
                                    安装

将程序做个软连接，方便执行

       连接
软件包采用的是模块化的设计，模块分为内置模块和第三方模块。
服务器安装好之后，程序的主目录在下，该目录下分别为主配置文件目录，网页根目录，日志文件目录，主程序目录。默认无执行脚本，需要手动输入命令来管理。常用的命令如下：

启动主程序

 

关闭主程序

   

重载配置

   
默认监听本机端口。
安装数据库
多线程，多用户的数据库管理系统。软件包，；服务：
安装软件包：
      
重启服务 
   
默认监听本机端口。
安装软件
 一种编程语言，最初用于设计生产动态网站。与，类似。软件包    。软件用来连接。用来连接数据库。
  –   
   
默认监听本机端口。
启动服务



                               前面已经做好软连接



           
              开机自启动



   
    
建立平台
与的内在联系
只能处理静态的页面请求，处理动态页面请求。当用户连接端口时，首先由判断请求是静态还是动态，若是静态页面，直接将请求结果返回给客户机；若是动态页面，则将请求转交给本机的端口。监听本机端口，正好由解释器去处理动态页面。最终将请求结果返回给，再由将结果返回给客户端。
连接
连接数据库，进行数据的读取。
测试平台
测试目标

配置支持网页

创建测试页面，测试使用连接数据库的效果


测试方案
使用台虚拟机，其中一台作为服务器、另外一台作为测试用的客户机，如图所示。

处理步骤

确认所有服务已经启动
   |         
   |       
   |       

修改主配置文件


   
  {
               
                   
           }
     \  {                修改连接的配置部分
                       
            _   
            _  
                    
        }

编写测试的代码

     初始界面



客户端测试：
  
访问页面如图：


编写测试连接的代码

  

 

 =  
 __{
       __
}
 =    
 = 
 = _{
    
    
    
    
}


客户端测试：
  
测试结果如图：

总结

扩展包用来连接和，没有它，平台搭建失败。用来连接和，同样不可或缺少。

启动服务时，若服务无法启动，则检查是否本机端口被某种服务占用。检查是否由语法错误。在上一篇中我们讲到准备  基础环境改造，这一篇将继续讲述如何为应用提供高可用的底层数据层，以下是本次要进行实验的拓扑红色为已完成搭建，蓝色是本次文章涉及的区域：

、    上一篇我们搭建好了底层，这一篇来讲述如何创建一个可用组对外提供服务，设置两个节点的高可用属性：

、    通过登录，新建一个数据库作为应用数据，记得更改数据库管理员为：

、    界面展开到 高可用性，点击新建可用性组：

、    指定可用性组名称：

、    选择需要高可用的数据库前提需要做好完整备份：

、    勾选自动迁移及，选择可读辅助副本由于本篇并非专门介绍这里不做相关设置详解，从起就可以支持添加 节点作为节点，如果这里实现，相当于你的应用数据层是基于三层保护下：

、    切换到侦听器页，侦听器的建立，这里也需要一个内网同时绑定两个主机操作略，请参照上一篇：

、    选择模式，并输入我们在第一篇准备的共享位置：

、    环境准备完成，但是在完成最后一步时发现了问题：

、    点击连接，并点开详细日志：

、    再看看日志查看器：

、    发现跟计算机账户之间没有权限，默认服务使用本地计算机账户作为服务账户，统一将服务账户改为重启服务即可：

、    这时候就可以看到一条成功的日志出来了：

、    继续创建：

、    ，这样就完成了底层数据层的改造及创建：

相关推荐【腾讯云的种玩法】构建企业级应用环境之数据层面优化一【腾讯云的种玩法】在腾讯云创建您的 ——机准备篇作者：

摘自 前端小吉米
伴随着今年   大会的召开，一个很火的概念   诞生了。这代表着我们  端有了和原生  媲美的能力。但是，有一个很重要的痛点， 一直不能使用消息推送，虽然，后面提出了  ，但这需要网页持续打开，这对于常规  实现的推送，根本就不是一个量级的。所以，开发者一直在呼吁能不能退出一款能够在网页关闭情况下的  推送呢？
现在， 时代已经到来！
为了做到在网页关闭的情况下，还能继续发送 ，我们就只能使用驻留进程。而现在  的驻留进程就是现在正在大力普及的  。换句话说，我们的想要实现断线  的话，需要用的技术栈是：


 
 

这里，我先一个简单的  样式。

说实在的，我其实  很烦的这 。一般使用  端的，也没见有啥消息弹出来，但是，现在好了  一搞，结果三端通用。你如果不禁用的话，保不准天天弹。
  我已经在前一篇文章里面讲清楚了。这里主要探究一下另外两个技术  和 。首先，有一个问题，这两个技术是用来干嘛的呢？
  
这两个技术，我们可以理解为就是  和  之间， 和  之间的消息通信。

  将更新的信息传递给 
  将更新的信息推送给用户

可以看出，两个技术是紧密连接到一起的。这里，我们先来讲解一下  的相关技术。

那现在，我们想给用户发送一个消息的话应该怎么发送呢？代码很简单，我直接放了：
  {
    =   
    =      
    = 
    = 
    = {
     {
            
    }
  }
  
     {
       
       
       
       
    }
  
}
大家一开始看见这个代码，可能会觉得有点陌生。实际上，这里是结合  来完成的。 是  接收到后台的  信息然后出发。当然，我们获取信息的主要途径也是从  中获取的。这里为了简便，就直接使用写死的信息了。大致解释一下 。

 该方法是用来延迟  的结束。因为， 可能在任何时间结束，为了防止这样的情况，需要使用  监听 ，使系统不会在  执行时就结束 。
  该方法执行后，会发回一个  对象。

不过，我们需要记住的是  中的  只是很早以前就退出的桌面  的继承对象。这意味着，大家如果想要尝试一下 ，并不需要手动建立一个 ，而只要使用 
 桌面端
  =    {     }
 =  {  }

 在  中使用
    {
   {   }
}

  {
  
    ===  {
    
  }  {
    
  }
} 
不过，如果你想设置自己想要的  效果的话，则需要了解一下， 里面具体每次参数代表的含义，参考 ，我们可以了解到基本的使用方式。如上， 的基本格式为  

 很简单，就是该次  的标题

 这个而是一个对象，里面可以接受很多参数。

该对象是一个数组，里面包含一个一个对象元素。每个对象包含内容为：
 表示该  的行为。后面是通过监听  来进行相关处理
 该  的标题
 该  显示的 。大小通常为  





 的上限值，通常根据   确定。通过在  中定义好  触发，最后我们会通过，监听的  来做相关处理：
  {  
    = 

  
     通过设置的  来做适当的响应
    ===  {  
      
  }  
     ===  {  
    =    
  }  
   {  
    =    
  }  
} 

：  显示的主体信息
：  显示信息的方向，通常可以取：   
： 显示的  图片路径。
： 在  里面附带显示的图片 ，大小最好是  的比例。
：用来标识每个 。方便后续对  进行相关管理。
：当重复的  触发时，标识是否禁用振动和声音默认为 
：用来设置振动的范围。格式为振动暂停振动暂停。具体取值单位为 。比如：。振动 ，静止 ，振动 。这样的话，我们可以设置自己  都有的振动提示频率。
： 设置音频的地址。例如： 
 用来附带在  里面的信息。我们一般可以在  事件中，对回调参数进行调用。



针对于推送的图片来说，可能会针对不同的手机用到的图片尺寸会有所区别，例如，针对不同的 。
具体参照：

看下  提供的 ：
  {
   {
      ===  {
       {
          {
            
           
                 
           
        }
      }
    }
  }
}
当然，简单  的使用就是上面那样。但是，如果我们不加克制的使用 ，可能会让用户完全屏蔽掉我们的推送，得不偿失。所以，我们需要遵循一定的原则去发送。
推送原则
、推送必须简洁
遵循时间，地点，人物要素进行相关信息的设置。
、尽量不要让用户打开网页查看
虽然这看起来有点违背我们最初的意图。不过，这样确实能够提高用户的体验。比如在信息回复中，直接显示：回复： 这样的格式，可以完全省去用户的打开网页的麻烦。
、不要在  和  出现一样的信息
比如 



不要推荐原生 

因为很有可能造成推送信息重复

不要写上自己的网址

因为， 已经帮你写好了

尽量让  和推送有关联

没用的 
实用的 
推送权限
实际上， 并不全在  中运行，对于设计用户初始权限，我们需要在主页面中，做出相关的响应。当然，在设置推送的时候，我们需要考虑到用户是否会禁用，这里影响还是特别大的。我们，获取用户权限一般可以直接使用  上挂载的  属性来获取的。

 表示需要进行询问。默认情况是不显示推送
 不显示推送
 显示推送

简单的来说为：
  {
      {
    
  }

   检查是否可以进行服务器推
      {
    
  }

   是否被禁用
    ===  {
    
  }

    ===  {
     
    
  }

   如果还处于默认情况下，则进行询问
   {
     检查订阅
    
       {
         检查是否已经被订阅
          {
           没有
          
        }
         有
         
      }
       {
           
      }
  }
}
我们在加载的时候，需要先进行检查一遍，如果是默认情况，则需要发起订阅的请求。然后再开始进行处理。那，我们上面的那段代码该放在哪个位置呢？首先，这里使用到了 ，这意味着，我们需要将  先注册成功才行。实际代码应放在  注册成功的回调中：
  {
      {
    
    
  }  {
      \    
  }
}
为了更好的显示信息，我们还可以将授权代码放到后面去。比如，将  和  的  事件进行绑定。这时候，我们并不需要考虑  是否已经注册好了，因为 的注册时间远远不及用户的反应时间。例如：
    = 
    {
      {
      
    }  {
      
    }
  }
我们具体看一下  内容：
  {
    = 
   = 

   {
     请求订阅
    { }
       {
         = 
         =   
         = 
         
      }
  }
}
说道这里，大家可能会看的云里雾里，这里我们来具体看一下  具体含义。该参数是从  注册事件回调函数获取的。也就是说，它是我们和  交互的通道。该对象上，绑定了几个获取订阅相关的 ：

  该方法就是我们常常用来触发询问的 。他返回一个  对象回调参数为  对象。这里，我们后面再进行讨论。这里主要说一下  里面有哪些内容

用来表示后续信息是否展示给用户。通常设置为 
 一个  。用来加密  端  的信息。该  是一个   对象。





例如：
{
       
        
    }

  用来获取已经订阅的   对象。
  该  用来获取当前网页消息推送的状态   或 。里面的  和  里面的内容一致。

为了更好的体验，我们可以将两者结合起来，进行相关推送检查，具体的  中，则为：
  {
    = 
    {
      {
      
    }  {
      
    }
  }
      {
    
    
  }  {
      \    
  }
}
当然，这里面还会涉及其他的一些细节，我这里就不过多赘述了。详情可以查阅  。
我们开启一个  询问很简单，但关键是，如果让用户同意。如果我们一开始就进行询问，这样成功性的可能性太低。我们可以在页面加载后进行询问。这里，也有一些提醒原则：

通过具体行为进行询问比如，当我在查询车票时，就可以让用户在退出时选择是否接受推送信息。比如，国外的飞机延迟通知网页：

让用户来决定是否进行推送因为用户不是技术人员，我们需要将一些接口，暴露给用户。针对推送而言，我们可以让用户选择是否进行推送，并且，在提示的同时，显示的信息应该尽量和用户相关。


推送处理
  在实际协议中，会设计到两个 ，比较复杂，这里我们先来看一下。 是如何处理接受到的信息的。当  接受到  传递过来的信息时，会先触发  事件。我们通常做如下处理：
  { 
  {
          
    }  {
         
  }
}
其中，我们通过   过来的  通常是挂载到  里的。并且，该部署了  的相关 

 返回  的内容
 返回 经过   的对象
 返回  对象
 返回  对象

我们知道   并不是常驻进程，有童鞋可能会问到，那怎么利用  监听  事件呢？这里就不用担心了，因为浏览器自己会打开一个端口监听接受到的信息，然后唤起指定的 如果你的浏览器是关闭的，那么你可以洗洗睡了。而且，由于这样随机关闭的机制，我们需要上述提到的   来帮助我们完成持续   的效果，防止正在执行的异步程序被终止。针对于我们的  来说，实际上就是一个异步，所以，我们需要使用上述  进行包裹。
  {
  =  
  
}
当然，如果你想在  里面做更多的异步事情的话，可以使用  进行包裹。
  {
      =   
  
}
之后，就是将具体信息展示推送给用户了。上面已经将了具体  里面的参数有哪些。不过，这可能不够直观，我们可以使用一张图来感受一下：

左：，右：
另外，在   里面，还有一些属性需要我们额外注意。
属性注意

对于指定的  我们可以使用  来表明其唯一性，这代表着当我们在使用相同  的  时，上一条  会被最新拥有同一个  的 替换。即：
      =  
      = {
        \\  \\
       
    }
     
显示样式为：

接着，我显示一个不同  的 
  =  
  = {
       \\  \\
      
}
 
结果为：

然后，我使用一个同样  的 ：
        =  
        = {
          \\  \\
         
      }
       
则相同的  会被最新  的  替换：


该属性是  里面又一个比较尴尬的属性，它的实际应用场景是当有重复  被替换时，震动和声音能不能被重复播放，但默认为 。那何为重复呢？就是，上面我们提到的  被替换。一般应用场景就是和同一个对象聊天时，发送多个信息来时，我们不可能推送多个提示信息，一般就是把已经存在的  进行替换就 ，那么这就是上面提到的因为重复，被替换的 。一般我们对于这样的  可以设置为
        =  
        = {
              \\
         
         
      }
       
并且，如果你设置了  而没有设置  的话，这是会报错的 

防止自己推送的  发出任何额外的提示操作震动，声音。默认为 。不过，我们可以在需要的时候，设置为 
    =  
      = {
         \\
       
    }
     

对于一般的  来说，当展示一定时间过后，就可以自行消失。不过，如果你的  一定需要用户去消除的话，可以使用  来进行长时间留存。一般它的默认值为 。
      =   
      = {
         \\
       
    }
     
交互响应
现在，你的  已经显示给用户，不过，默认情况下， 本身是不会做任何处理的。我们需要监听用户，对其的相关操作其实就是  事件。
  {
      
}
另外，通过我们在  里面设置的 ，我们可以根据其作出不同的响应。
  {
  {
       
}  {
     
}
}
关闭推送
这是应该算是最常用的一个，只是用来提示用户的相关信息：
  {
  

           
}
打开一个新的窗口
这里，需要使用到我们的  里面的一个新的  。
  
    就是当前页面的 
    
  
这里需要注意的是  必须是和当前  同域名才行。不过，这里有两种情况，需要我们考虑：

指定的网页已经打开？
当前没网？

聚焦已经打开的页面
这里，我们可以利用  提供的相关  获取，当前浏览器已经打开的页面 。不过这些  只能是和你  同域的。然后，通过匹配 ，通过  进行聚焦。没有的话，则新打开页面即可。
    =   

    = {
     
     
  }
   = {
      = 

       =      {
        = 
        ===  {
         = 
        
      }
    }

      {
       
    }  {
       
    }
  }

  
检测是否需要推送
另外，如果用户已经停留在当前的网页，那我们可能就不需要推送了，那么针对于这种情况，我们应该怎么检测用户是否正在网页上呢？
  = {
     
     
  }
   = {
      = 

       =      {
        = 
        {
         = 
        
      }
    }

     
  }
   = {
      {
           
    }  {
      \     
    }
  }

  
当然，如果你自己的网页已经被用户打开，我们同样也可以根据推送信息直接将信息传递给对应的 。我们通过  获得的  对象，调用  来进行消息的推送。
 {
              
            
        }
合并消息
该场景的主要针对消息的合并。比如，聊天消息，当有一个用户给你发送一个消息时，你可以直接推送，那如果该用户又发送一个消息呢？这时候，比较好的用户体验是直接将推送合并为一个，然后替换即可。那么，此时我们就需要获得当前已经展示的推送消息，这里主要通过   来进行获取。该  返回的也是一个  对象。当然，我们怎么确定两个消息是同一个人发送的呢？这里，就需要使用到，上面提到的  的属性。这是我们在  里面附带的，可以直接在  对象中获取。
     
     = {
       

        =      {
       检测已经存在的  和新消息的  是否一致
          
           ===  {
           = 
        }
      }

       
    }
     然后，进行相关的逻辑处理，将  的内容进行更替
     = {
       
        = {
         
      }

        {
                  
          =   

         = `  {}    {}`
         = {
           
           
        }
         = `   {}`

        
      }  {
         = `{}`
         = {
           
           
        }
         = `   {}`
      }

       
        
        
      
    }
相当于从

变为：

上面提到了在  中使用， 获取窗口信息，这里我们先补充一下相关的知识。
 
我们可以将  理解为我们现在所在的浏览器，不过特殊的地方在于，它是遵守同域规则的，即，你只能操作和你域名一致的窗口。同样， 也只是一个集合，用来管理你当前所有打开的页面，实际上，每个打开的页面都是使用一个   进行表示的。这里，我们先来探讨一下  

 用来和指定的窗口进行通信 
 表明当前窗口的上下文。该值可以为    或者 
 使用一个唯一的  表示当前窗口
 当前窗口的 。
： 该方法是用来聚焦到当前  控制的页面。下面几个也是 ，不过是专门针对 = 的。
 将当前页面到想到指定 
 表示用户是否停留在当前 
 用来表示当前  的可见性。实际和  没太大的区别。可取值为     。

然后，  就是用来管理每个窗口的。常用方法有：

 用来获得某个具体的  

 {
   打开具体某个窗口
   
}

 用来匹配当前  控制的窗口。由于  是根据路径来控制的，有可能只返回一部分，而不是同域。如果需要返回同域的窗口，则需要设置响应的 。
 是否返回所有同域的 。默认为 。只返回当前  控制的窗口。
 设置返回  的类型。通常有：   和 。默认是 。



 常用属性为：
{
     
     
  } {
    =        {
     ===  {
      
    }
  }
}

 用来打开具体某个页面
 用来设置当前  和同域的  进行关联。


先贴一张  关于   的详解图：

上述图，简单阐述了从  产生信息，最终到手机生成提示信息的一系列过程。先说一下中间那个  。这是独立于我们常用的    的架构，浏览器可以自己选择  ，开发者一般也不用关心。不过，如果你想使用自己定制的   的话，只需要保证你的  能够提供一样的  即可。上述过程为：

用于打开你的网页，并且，已经生成好用来进行  的 。然后， 开始初始化  。

用户订阅该网页的推送，此时会给   发送一个请求，创建一个订阅，然后返回   的相关信息。

浏览器获得   的相关信息后，然后在发送一个请求给该网页的 。

如果  这边检测到有新的信息需要推送，则它会想   发送相关请求即可。


这里，我们可以预先看一下   返回来的内容：
{
   
   {
      _=
        ==
  }
}
 就是浏览器订阅的   的地址。这里的  我们放到后面讲解，主要就是用来进行   的加密。根据官方解释，  与用户将的通信，借用的是  的   协议。上面的图，其实可以表达为：
                      
    |     |           |   |       |  |
                      |       |
        |                      |               
        |             |                      |
        ||                      |
        |               |                      |
        |====================|                      |
        |                      |                      |
        |                       |
        ||
        |                      |                      |
                                                    
        |                      |           |
        |           ||
        ||                      |
        |                      |                      |
接下来，我们就需要简单的来看一下使用   的基本原则。
 基本原则

首先， 发送的   必须被加密，因为这防止了中间的   去查看我们的推送的信息。

通过  发送的  需要设置一个失效时间，以为   真正能够作用的时间是当用户打开浏览器的时候，如果用户没有打开浏览器，那么   会一直保存该信息直到该条   过期。


那么如果我们想让用户订阅我们的   我们首先需要得到用户是否进行提示的许可。当然，一开始我们还需要判断一下，该用户是否已经授权，还是拒绝，或者是还未处理。这里，可以参考上面提到的推送权限一节中的  函数方法。这里我们主要研究一下具体的订阅环节假设用户已经同意推送。基本格式为：
  {
      = {
       
       
        
      
    }

     
    }
       {
         
      }
这里有两个参数  和 。这两个属性值具体代表什么意思呢？

该属性可以算是强制属性你必须填，而且只能填 。因为，一开始  的设计是 可以在用户拒绝的情况下继续在后台执行推送操作，这造成了另外一种情况，开发者可以在用户关闭的情况下，通过   获取用户的相关信息。所以，为了安全性保证，我们一般只能使用该属性，并且只能为 如果，不呢？浏览器就会报错。

前面说过它是一个  。用来加密  端  的信息。该  是一个   对象，而且它 需要符合  规范实际，所以我们一般可以叫做    或者  ，我们的  其实有私钥和公钥两把钥匙，这里和  协商机制类似，不过不会协商出  ，直接通过   进行信息加解密。不过，它还有其他的用处：

对于信息
进行加密解密，增强安全性


对于  
保证唯一性，因为  会将该  发送过去。在   那边，会根据该  针对每次发送生成独一无二的 ，然后根据该  给某些指定用户信息  。



整个流程图为：

另外，该  还有一个更重要的用途是，当在后台  需要进行  ，向   发送请求时，会有一个  头，该头的内容时由   进行加密的。然后，  接受到之后，会根据配套的  的   进行解密，如果解密成功则表示该条信息是有效信息发送的  是合法的。
流程图为：

通过  异步调用返回的值  的具体格式为：
{
   
   {
     _=
    ==
  }
}
简单说一下参数， 就是   的 ，我们的  如果有消息需要推送，就是想该路由发送请求。而  就是用来对信息加密的钥匙。得到返回的  之后，我们需要发送给后台  进行存储。因为，每个用户的订阅都会产生独一无二的 ，所以，我们只需要将  和关联用户存储起来就  了。
 {
     
     {
       
    }
     
  }
接下来就到了  推送  的环节了。
服务器推送信息
当服务器有新的消息需要推送时，就需要向   发送相关的请求进行  。不过，这里我们需要了解，从服务器到  的请求，实际上就是  的  。我们看一个具体的请求例子：
    
   
   
   
 =  
   
 
  

=\_\_
当然，变化的是里面推送的具体的  和  内容。我们可以看一下具体头部代表的意思
头部参考










可以理解该头是一个   ，用来验证是否是真实的订阅 



用来表示加密的 。它由两部分组成==。其中  就是由   加密的  的 



它用来放置加盐秘钥。用来加密 



如果你没发送  的话，那么就不用发送该头。如果发送了，则需要将其设置为 。这是为了告诉浏览器我发送的是  



用来描述  的长度没有  的不用



该头必须一直是  不论你是否发送 


   
表示该  可以在   上停留多长时间为什么停留？因为用户没有打开指定浏览器，  发布过去。如果  为 ，表示当有推送信息时，并且此时   能够和用户的浏览器建立联系，则第一时间发送过去。否则立即失效



该头实际上和  中的  头类似。如果  先后发送了两次拥有相同  的  请求，如果前一条  正在  状态，则会被最新一条  代替。不过，该  必须 =  个字符


实验特性
表示该消息的优先级，优先级高的  会优先发送。默认值为 。可取值为 






返回的响应码
通常，  接受之后，会返回相关的状态码，来表示具体操作结果：










表示推送消息在   中已经成功创建



此时，  有太多的推送请求，无法响应你的请求。并且，  会返回  的头部，表示你下次重试的时间。



无效请求，表示你的请求中，有不符合规范的头部



你的  过大。最小的  大小为 



发送过程
可以从上面头部看出，  需要的头很复杂，如果我们纯原生手写的话，估计很快就写烦了。这里推荐一下  里面的库，可以直接根据    来生成我们想要的请求头。这里，我们打算细节的了解一下每个头部内容产生的相关协议。

首先，这个  是怎么拿到的？需要申请吗？
答案是：不需要。这个  只要你符合一定规范就 。不过一旦生成之后，不要轻易改动，因为后面你会一直用到它进行信息交流。规则简单来说为：

它是  端生成   的公钥
它是可以通过  加密库，依照  曲线，生成｀｀ 签名方式。
该  需要是一个  位的非负整型数组

简单  为
  {
    = 
  

   {
     
     
  }
}

 也可以直接根据  库生成
  = 
具体头部详细信息如下：
头部参考

 头部的值上面也提到了是一个   简称为 。基本格式为：
    
实际上，该头涵盖了很多信息手写很累的。。。。所以，我们这里可以利用现有的一些  库，比如 。专门用来生成， 的。我们看一下它显示的例子：

简单来说，上面  部分都是将对象通过   加密生成的字符串。 代表：
{  
     
     
}
用来表示  的加密算法是啥。 代表：
{  
   
   
     
}
其中 

 表示，  是谁
表示过期时间，并且是以秒为单位，最多只能是一天。
 用来表示   的联系方式。

 代表：它是用来验证信息安全性的头。它是前面两个，     的字符串通过私有  加密的生成的结果。

这就是我们公钥的内容，简单格式为：
 =     =      

 两个参数分别代表：

==
   
这几个头是涉及  传输时，需要用到的。基本格式为
      
 
 
其中，只有  是可变的，用来表示  的长度。
  
这几个头上面已经说清楚了，我这里就不赘述了。
最后放一张关于  的总结图：


原文链接：


相关推荐开发性能优化核心定义介绍篇【就是快】分钟搭建一台服务器！人工智能是一项前瞻性科学研究，自信息技术产生发展以来，人们在这一领域进行了长期的科学探索和技术攻坚，并不断涌现出新思想、新观念、新理论、新技术，成为未来科学技术革命的重要发源地。就现阶段发展来看，智能化是未来信息技术的发展趋势，人工智能技术也为基于互联网和移动互联网等领域的创新应用提供理论基础。腾讯优图也在用自己的方式——“开放”努力着。
近日，腾讯优图开放平台发布了版本，正式更名为腾讯优图·开放平台。除了直观的视觉冲击改变，本次版本更新为开发者提供了更全面的能力和更丰富的产品解决方案。

亮点一：更全面的技术开放

人脸融合技术重磅上线—揭秘天天图人脸变妆的秘密 

火爆朋友圈的全民军装照活动创吉尼斯世界纪录！参与人数达亿，参与人次达亿。其背后的黑科技——人脸融合技术也重磅上线了，将用户上传的照片与特定形象进行脸部层面融合，让生成的图片效果既有用户的五官特点，也呈现出对应形象的外貌特征，从此军装照、民族照、二次元照、爱豆照……想怎么玩就怎么玩，一键变脸不再是梦！


人脸聚类——轻松管理你的相册相册的照片太多，找起来太麻烦怎么办？优图人脸聚类来帮你。优图独创深度人脸模型，对电脑或手机中的照片进行聚类，自动将属于同一人的照片归为一组，使相册的管理更加智能、方便。同时自研去遮挡技术和人脸演变模型，有效减少眼镜、口罩、帽子等遮挡物对人脸聚类算法的影响，以及即使面部随着年龄增长，皮肤、肌肉、骨骼发生明显变化，也能被正常识别并聚类。



车辆属性识别——解密车辆信息的钥匙相信你肯定也会有这种困扰，当在街头看到让你怦然心动的那款车时，却无法知道车的具体品牌、车系及参配、价格口碑等详细信息。有了优图车辆属性识别能力，用户只需上传车辆的拍摄图片，即可快速获取车辆信息，如品牌、车型、车系、颜色、车标位置等，大大简化了信息获取的成本。该技术不仅能为购车的消费者提供便利，同时也可以为监控和安防系统提供智能的数据处理能力，减少人工审核的成本。



银行卡、车牌优图最具竞争力的战队又加入了新成员——银行卡和车牌。金融及第三方支付行业使用银行后，用户无需手动输入，轻轻一拍即可快速获得卡号、有效期、发卡行等信息，极大提升了用户体验，降低出错率，加速行业智能化升级。车牌被广泛运用于治安卡口违章识别和停车管理，自动识别车牌信息，既能实现车辆进出全自动化，还能对违章车牌号码的车进行进一步处理，助力智慧警务的全面升级。


亮点二：丰富的产品解决方案
优图天眼寻人解决方案优图天眼寻人解决方案，是基于优图海量人脸检索技术针对寻人场景专门研发的一款“天眼寻人引擎”，让助力公安，公益寻人，帮助更多走失的人员被找回。将优图天眼寻人引擎与城市的走失人口库相结合，当大家在路边发现疑似的走失人员时，随手拍一张照片，就可以快速的和城市的走失人口库进行比对，返回最相似的人脸识别信息。让破碎的家庭重拾温暖，让走失的家人不再流浪。 


优图天眼交通解决方案

无论是在人类生活领域还是经济发展领域，交通作为不可缺少的元素发挥越来越重要的作用。而交通监控是保障交通平安、畅通必备的手段。优图面向交通行业推出智能化解决方案，可以检测并追踪车辆、结构化存储车辆信息、自动识别车辆违章行为、自动识别拥堵等路面情况，助力城市智慧交通的建设。

安全审核解决方案优图安全审核解决方案是针对广告、社交、游戏、直播、短视频等行业存在的图片内容涉黄、涉恐、涉政、隐含恶意广告等违规问题推出的解决方案，该方案基于优图智能鉴黄技术、暴恐图片识别技术、技术和人脸识别技术，可以精准识别出图片中的露点不雅行为等色情内容、暴力恐怖内容、恶意文本以及政治敏感人物，为客户提供一站式图像内容监控服务，辅助甚至代替人工过滤垃圾，提高审核效率，助力客户更好地进行违规处理与风险管控。

亮点三：优图学术论文全新开放
优图学术论文全新开放，在这里你可以获得最前沿、最全面的人工智能领域学术论文。
人工智能的生命刚刚开始，而且它还有很长的路要走。我们要做的是开放，让每一位开发者都能拥有坚强的技术后盾，开发者不再需要进行重复且耗费大量资金和时间去做基础研发，而是可以通过优图开放平台获取最领先的技术能力，不仅提升了的应用发展速度，也将在全世界率先掀起行业共建生态的热潮。
开放助开发者一起用改变世界。戳我：推荐使用桌面端本文作者： 朱灵子

通用化建设与性能优化
本文主要介绍通用化建设以及对项目进行性能优化的方案，总体来讲主要围绕以下几个方面展开：

 通用化建设 
   本地分包 
 项目线上性能分析 
 项目首屏加速和性能优化 

 通用化建设
 通用化建设主要做了一下几个方面的事情：

通用化入口： 为项目设置通用化入口，实现项目上线的弱客户端依赖更新离线包即可，同时后台串下发字段，这里如果稳定，客户端也可以一律写死，不根据来下发字段
版本自由切换： 通过后台串下发实现任何项目全屏半屏 版本与版本之间的自由切换 
离线包机制优化：离线包拉取、解析与线上发布流程优化
本地分包：实现基础包和业务包的拆分
底层监控能力支持：为线上项目内存率渲染时间等各方面的数据获取提供通用化的接口


接下来重点介绍线上离线包优化机制以及项目本地分包方案

线上离线包优化机制
为了实现线上项目版本与版本的自由切换，同时合理地管理好不同项目不同版本的离线包与离线包，我们的方案是将离线包和 文件打在同一个离线包中放在同一个号的离线包中。
若后台地址下发中携带=字段，同时离线包中可以检测到 文件并且版本号符合离线包中所配置的离线包生效所要求的版本范围，则优先加载项目版本。若不满足上诉几点要求，我们则优先加载 本地文件或直接走项目线上资源。
如下图所示为离线包优化整体流程图 

  本地分包方案
下图为推出的消息流页面加载耗时分布图 

从这张图中我们可以看出，加载速度最大的瓶颈其实在于图中绿色的区块 ，这块时间也就是的执行时间；同时若多个项目同时上线，多个业务却不共用基础模块，文件会越来越大，的离线包文件负荷也会越来越大
基于以上提出的两个问题，我们的解决方案是 本地分包策略

一般基础包压缩以后有左右，而较复杂的业务所分离出的业务包体积最多也不到。打包方案是一套类似 的轻量模块系统，保持轻量和对特性关注也是不使用和而是自己实现打包的原因。要实现 本地分包，我们要做到依赖引用业务包去  基础包中的模块，因此我们需要把基础包中包含的模块列表导出来给业务包打包时使用。

以下为已实现的 本地分包方案的主要思路：

用户在访问 时，客户端检索到离线包中的业务包文件以后后与基础包文件进行简单的合并，然后注入 最后展示 

使用这一打包思路实现本地分包的优势


减少离线包体积，降低离线包热更新流量损耗；
降低客户端工作量，不用引入复杂的 算法来分离业务包与基础包的重复部分；


以上打包方法确实解决了中 打包以后文件包体积过大的问题，但是却没有解决 加载以及执行时间过长的问题，基于这一点我们提出的方案是
预加载基础包，再运行业务包，而且多个业务切换的时候可以直接复用基础包
该方案的可行性分析：


按照之前的方案打出的基础包可以独立运行，所以我们可以凸显加载基础包，基础包加载以后业务后也可以正常运行；
预加载基础包的时机可以是部分，也可以直接提前到整个 以后，这样可以很大程度上减少庞大的基础包的加载时间
这一优化功能的实现我们需要修改 部分的源代码，经过调研，源码中有对应接口可以实现 和  的分离


 项目线上性能分析
以下为短视频项目的线上数据，主要从首屏时间、、内存以及率等方面和项目进行对比

通过对比可以发现项目和相比在首屏时间以及等方面存在较大的优势，但是其在内存方面存在劣势，而且在首屏时间方面的优势还存在较大的提升空间
 性能优化方案
接下来我们从首屏加速、性能优化这两个方面进行分析主要的优化策略如下图所示： 

首屏时间方面的优化主要有


文章第一部分详细讲述的 本地分包方案，以及后面提出的先加载基础包后加载业务包的优化
前端数据缓存优化以及图片预加载，客户端提前加载的预加载优化
针对安卓端提出的安卓端上下文预加载优化


接下来具体介绍针对安卓端提出的安卓端上下文预加载优化
使用 开发混合应用的过程中，我们第一次进入页面 会有一个短暂的白屏过程在真机上近 秒，在模拟器上比较快，在 毫秒左右，而且在完全退出后再进入，仍然会有这个白屏。
 
安卓端打点后可以发现在的方法中，耗时最多的是 和这两个操作 对于安卓白屏的问题我们的优化方案是：提前创建进行，在之后直接将创建好的挂载在 上去
这里是安卓源码时序图 

具体来讲就是将方法中的和这两个耗时比较多的方法提前到上一个中进行处理或者在整个启动以后进行处理
这一点我们可以借鉴空间团队的思路，主要优化思路为：客户单预初始化上下文与预加载的结合，主要流程图如下图所示：

在打开以后自动预初始化客户端上下文 在点击入口以后直接复用客户端初始化好的与此同时客户端发起请求，预加载数据并缓存，前端直接读取缓存数据 【注：由于不存在渲染文件，所以我们通用的在这里不太适用】
性能优化方案


 端以及客户端版本一起进行版本升级，内存优化：


最新版源码已改为模块按需加载的模式，升级客户端与端的源码至最新版，可以很大程度上降低项目运行的内存损耗，同时还可以降低运行的 率


项目开发过程中减少层的嵌套，优化


减少绘制，优化


性能优化，内存优化


我们在测量短视频项目启动时的内存变化量时发现了一个有趣的现象：每次测量时是否杀掉进程重新开启来进行测量和不杀进程进行多次测量的内存变化量相差较大

为什么会存在这个问题呢？因为短视频项目使用的是组件 首次加载时都默认最多加载  个子项，所以能保证启动速度，但是在滑动的过程中会逐渐向  中添加子项，新出现的子项都是通过创建新的 ，而完全没有复用的过程。所以若应用中 的子项数量特别多， 滑动过程中内存会逐渐上涨，离开后内存也不会快速释放，所以就是出现之前内存测量的奇怪问题
而是最常用的组件之一，优化势在必行，这里我们提出两种方案：

版本升级之前可以使用能够进行内存自动回收的第三方组件
最新版本推出了可以直接进行内存回收的原生组件


感谢您的阅读，欢迎提出问题以及修改建议。

原文链接：作者：梁伟盛

那些年我们踩过的坑
事件背景
有一天给程序员分配了一个需求，一看，需求很简单嘛，就是在页面异步拉取数据展示就了，于是就和同事阿翔对接了一下接口，就啪啪啪敲键盘的开始码代码了，不到天就完成了需求。
    各种高逼格代码
    

    {
        
       
          {
            判断是否正确返回
            

            
       }
    }

       {
           =   =      {
            使用到中的_ _ 各种_
        }
    }

       {
        使用到中各种_属性
    }

    各种
    
完成效果图：

一切都是那么的完美，就等提测了！！哈哈哈，我实在太聪明了自白

阿翔之坑
正当信心满满没问题的时候，阿翔突然和他说，_这个命名错了，要改成_才行，我去。。。我好多地方用到了_。

此时一般很多人都立刻去把_属性全部改为_，但是并没有这么做，他心想没准后面其他属性又会改，我不会再被坑一次，于是加了一个函数。
       {
         _ = 
           =   =      {
              = 
            团队规范需要命名驼峰式
            _{
                 _
                 _
                 _
                各种_
            }
        }

         _
    }
    
        
    

这样就算阿翔把属性名改一万遍，在此函数只需要改一次就可以了，不用每个地方都修改，完美！此后在数日子等待提测。。。
阿翔之坑
提测之日快到了，阿翔又通知，创建时间那个字段说数据库中不能直接存放这种日期格式，全部要改成秒，你在前端把数据格式化成正常日期吧。此时心里一万个草泥马在奔腾，我的翔啊。。。你怎么又坑我了！

   立刻改造了代码
       {
        格式化时间
    }

       {
         _ = 
           =   =      {
              = 
            团队规范需要命名驼峰式
            _{
                 _
                 _
                 _
                各种_
            }
        }

         _
    }

        
    
提测顺利通过，项目终于如期发布了，也松了一口气了！
事后一根烟时间
经过这次被阿翔坑过次的，事后他回想了很多，如果以后属性名不确定，数据需要各种格式化，或者其他接口的属性也用到一样的格式化方式，或者说其他接口返回的数据也是一样的，这样能否抽离出一个数据化格式工具呢？不能再被我的翔坑了！      
 于是苦思冥想，抽离出了一个格式化工具函数并放上了公司的平台 暂时只能内网访问，请等待同步到公网。
楼主总结
没有一个程序员一开始就能写出高抽象，复用性高的代码，和一世人流流长，总会爱上几个人渣一样，程序员总会遇到各式各样的坑，关键是遇到坑之后是视若无睹还是努力学习改进，同一个坑如果遇到两次还不改进，你是傻啊！

另：本故事人物均为虚构，若有雷同，纯熟巧合。。。。原文链接：


相关阅读【腾讯云的种玩法】利用 节省成本 日新进用户，解密《龙之谷》手游背后的压测故事导语：【  技能分享】 这个系列会分享一些我在日常使用中有意思的小技能以及一些软件的基础使用，半个月一更。 零基础篇是为了让有基础的同学也能简单使用，除此之外也会分享一些小的插件。本文为基础教程分享后的后补充与总结，如果有其他未涉及到的疑问 欢迎交流指正。

第一篇我们主要了解之后简称的软件界面、功能分布，以及运动的基础操作。
界面模块

我将的主界面分为六个模块，以便大家更容易去理解。
功能区：工具栏、功能与效果都在这个模块，与相同。
项目、控件：可以理解为你的素材库。双击这里可以添加需要用的素材，这类视频编辑软件都会有项目的概念，把素材添加到这里才能使用，并且在这里的素材只要你不用就不会显示在图层列表中。同时在制作过程中，如果你添加了效果、控件，这里就会变成你的效果器，在这个地方调节你的效果，并且可以点击切换项目与效果的显示。
查看器：类似里的画板。顾名思义就是看效果、看素材的地方。这里有几个常用的功能，一个是百分比数值，这里是你的放大缩小显示画面的地方，选择“适合”就会自适应你的画面。另一个是透明图层的显示，当内容色与背景色相近的时候，显示透明图层会更方便查看。
信息：就像右上角的信息栏。但能展示更多的功能，比如说“对齐”、“字体选项”、“色彩内容”等，功能区的“窗口”里选择添加或删除这里展示的内容。
图层：就是中的图层栏。把素材拖入这里才能在西查看器中显示，并且进行素材、关键帧的编辑。这里除了遮罩、、混合模式、等与相同的功能外。还有父级，等独有的功能。
时间轴：显示时间的模块。、是我们在中最主要的操作区域。蓝色的竖线指的是当前选中的时间，顶部的两段浅灰色长条是可操作的。点击边缘蓝色区域即可以拖动它的长度。长条是选择时间轴显示的时间范围，长条是选择我们渲染查看的时间范围。：默认时间长度为，若要编辑总时间长度，在项目中右键选择合成，进入合成设置，底部即可修改。马上就介绍合成。
中的基础名词释义
合成：合成最简易的理解就是“画板”。在中新建项目不等于新建画板，就像一样，新建了项目后还需要添加画布才行。在顶部功能栏中点击“合成 — 新建合成” 即可添加。合成设置中可以选择合成的尺寸，名字，背景颜色、帧数等等。默认帧速率为。如果创建完成后需要修改，在项目中选择合成，“右键”进入合成设置即可。

关键帧：关键帧=物体有运动状态变化的那一帧。帧就是一秒钟显示的画面，一般我们制作使用的是帧／秒，游戏和一些电影用的是帧每秒。比如球从开始向右运动，到的时候结束。那么“”与“”的两帧就是关键帧。是球开始运动的那帧，是运动结束的那帧。
帧：就是设置关键帧 一般来说在运动的开始、结束以及变化点设置关键帧，素材就可以运动了。
基础运动操作
我们新建合成后，首先在项目栏中添加素材，或者是直接使用功能栏中的图形工具绘制图形。
绘制图形后，在图层栏选择运动项目的下箭头白色框，就可以展开你的图层选项了。然后我们会看到“内容”与“变换”两个小箭头。

内容：关于图形本身的属性 比如尺寸大小、描边、填充颜色、遮罩等设置。
变换：运动的基本要素。通过这些信息来调整运动的变化。这里我们主要关注变换中的内容。
运动的基本要素：时间、描点、位置、缩放、旋转、透明。这是给出的基本运动要素，通过控制六项基础内容完成所有的运动。
描点：图层运动的中心点。图层会围绕着这个点运动。与图层本身的中心点不同。位置：就是图层的坐标位置“”。缩放：放大缩小，可以单独控制横向、纵向的变化。旋转：围绕着描点进行旋转。透明度。
在每种运动要素的前面都有一个计时器，点击它就能设置在当前的这一帧时间轴里蓝色的竖线设立关键帧。并且在时间轴上会出现菱形这就是关键帧标示。
然后只要选择运动结束的时间，调整你想要变换的参数，图层就可以运动了！点击每行最左侧的菱形也可以添加关键帧。

：每个运动至少需要两个关键帧开始与结束。运动的速度取决于你的运动时间。拖动关键帧的位置可以调整运动速度。每种运动要素的关键帧互相独立，如果不动的话要看是不是错位置了。如果想要图层跟随另一个图层运动，可以在图层栏最右侧父级选项中选择要跟随的图层即可。

通过不同的要素组合运动，就可以制作出大部分的运动效果了。掌握关键帧的运用，就掌握了基础的运动操作了。下一期会分享如何调整运动曲线，让运动更佳流畅自然。作者 |邵建永编辑 | 顾乡
使用进行的库主要有三个，更熟悉的名字可能是，和。
资格最老，核心由语言打造，接口精炼，性能最棒，缺点是环境依赖较多，安装复杂，近两年已停止更新，只支持，不支持。
为替代而生，纯打造，接口与兼容，安装方便，支持。
是一个框架，它并不提供底层的数据库操作，而是要借助于、等第三方库来完成，目前在编程领域应用广泛。
本文主要介绍的正确使用方法，示例代码都是选自实战项目。
安装
简单的方式：
  
如果无法联网，需要进行离线安装，例如：
  
导入
 
连接
 __
     =
                           =
                           =
                           =
                           =_
                           =
查询
 __
    _ =  __
                   __
                   _=  
    _

     = ___
     = 
    _
     = 
    
    

      ==    _   
     
简单插入
 __ _ _
         = ___
         = 
        
            _ =   __ _ _ 
                             _ _
            _
            
        
            
              
            
        
            
            
批量插入
_ =    

 = ___
         = 
        
                  _ _ _ _
                                                      _
                  == _   
                
           
                
                  
        
                
                
更新
     __ _
         = ___
         = 
        
            _ =  _
                          __
                          _=  _
                          
            _

            _
              ==        

            _ =  __
                           __=
                          _=
                           _=  _
            _
            _

              ==          
            
        
            
              
            
        
            
            
已经相当成熟，和一样，它在很多发行版本中都是可选的安装组件。

相关推荐
腾讯云主机环境安装爬虫框架过程内核深度优化  实现解析作者简介：


 李智桦老师，北京站金牌讲师，台湾著名精益布道师，敏捷专家，著有《精益开发与看板方法 》。

先学开发还是先学测试
对于初学者或新人而言，由测试开始是再好不过的了。
一旦写程序的功力够了，制造缺陷的机率自然会下降些，这个时候再来写程序，才不会害己害人。
原因很简单；因为缺陷是程序没写好所造成的，所以想要写的一手好程序，先学如何测试别人的程序，先看懂别人的程序，再来尝试写好程序，似乎会好一些
先学 还是 
大部份的时候；你可能完全没有选择的余地，这可不是老天能安排的，而是看老板的安排。
从属性上来看

 容易探讨未知，处理复杂项目，拿来开发新东西威力无比。 是教我们如何自我检讨，可以迅速消除浪费，而得到好的效能。

如果你是开发团队，当然是先从 开始。

先检讨团队的基本动作，整顿好了再来开始作新的东西，从事开发的动作，自然减少浪费。这是精益 的好处。
有太多开发团队，只晓得一意往前冲刺，忽略了自己在开发上的浪费，这会造成很难走得久远，尤其是的团队尤其如是。

如果你是运维团队，当然是先从 开始。

视觉化是最大的亮点，团队可以看见工作上的维护流程是一件相当有价值的事，针对个人亦是如此，人们常常因为养成习惯了，就一直持续做同样的事情，很少会有机会回过头来检讨，哪里做得浪费了应该改进。
看板方法的第一步 视觉化。正是团队可以拿来持续改进的基础。这一点对维护工做更显得珍贵。

如果你是测试团队，当然是先从 开始。

看的见以后才可以减少猜测的比例。测试团队在拟定测试计划之前，一定要对待测的产品或程序有足够的了解，才可能写出实用的测试案例，不至于浪费大量的测试资源，或做了过多的重复性测试。

你可能觉得奇怪，为什么都是  先行呢

其实原因很简单，因为它单纯“，不是简单喔 它没有想像上的简单，因为它可以演进得很有深度，但是它的目的很单纯，就是追求效能。不像 的目的，是要来应付复杂的项目开发作业，基本上的方向就完全不一样的

将看板方法融入的开发过程才是上策
看板方法是一种流程控制，他不是一种具有完备基础的方法学，虽然他的潜在发展相当可观，但目前他仍只是一种提供我们产出高效能的流程控制法而已。
他缺少需求描述、没有完备的会议规划、少了团队职责分配，少了很多很多软件开发上该有的措施，这一点让他看起来十分空泛，但就是这个特性也让他十分适合融入其它开法方法中，尤其是。
看板方法之父    是在 公司推行敏捷开发法  的时候发明看板方法的。他原本的目的只是要求能够在最少阻力之下顺利在组职中推行敏捷式的开发方法而已。却由于他熟悉限制理论的运作而开创了看板方法 。做出了对敏捷开发的精益 一支的重大贡献。
也就是这样的典故，让看板方法 可以十分容易的融入到的开发过程。
著名的《   》 的作者  它是年 敏捷理论最畅销书，书中就大量的采用 的观念，实际的运用在工作看板上面。让在开发流程上减少了许多的浪费现象。

看板方法先行
因为它可以减少组织在推行敏捷上的阻力，它能让工程师以最好的节奏持续进行开发工作。又能将精益观念带入团队运作。
融入的开发过程
因为看板方法的流程控制方式是用来提升运行时的效能，让  能真正用来克服复杂的软件程序开发过程。

 的目的在解决复杂的软件开发作业
许多人误把 当成加速软件开发的银子弹。这是错的 
他的目的不在加速开发加速开发工作是开发工具的广告词，它的目的是在解决复杂的软件开发作业，让它提高成功率。在协助团队能够提供给客户真正要的产品，且让他在市场上具有实际的竞争力。这一点也正好是看板方法所缺少的。 
开发团队千万别因为实施了看板方法而误以为需要把  抛弃了，这是一种错误的想法，让他们相辅相成才能有更大的效益。下一回就来谈运用看板方法的十个不应该放弃 的理由。
测试难还是写程序难
让我们回到一开始的主题，到底是测试难还是写程序难 其实正确的说法应该是写出正确无缺陷的程序难 实际上程序设计人员在写出程序之后，也必须透过测试，才知道他是否能正确运行。因此写跟测实质上是一体的二面，一样重要。
至于 与   之间，则都是通往敏捷开发的路径。已经在使用  作开发工作的人士，学习   可以让他们进入精益的领域，有所依据的持续追求更好的效能。
先学会  再跨足  的人呢 则可以看到敏捷开发在处理复杂问题上的具体方法，真正懂得去追求效能之外的正确性与方向。
先学 还是  二者之间并没有冲突存在，就看你现在最需要的是那一样，那一样就先来吧
原文链接：

文章来自：时代社区月日，腾讯“云未来”峰会云安全专场在深圳举行。会上，腾讯云隆重介绍了三款重磅云安全新品，分别为主机安全、反诈骗云、网站安全，同时发布腾讯云在车联网、移动、直播三大领域的安全行业解决方案。腾讯智慧安全的能力，正借助“即服务”的方式全面对外开放。
本次发布的系列新品，均为云安全领域的创新突破。比如由“腾讯云云鼎实验室”全新发布的“云镜”，凭借基于管理，而不是简单反病毒的新思路，全面管理软硬件资产，既保障安全，又提高运维效率。云镜重点关注云平台遇到的风险，落实下来，的主机安全问题都能得到有效解决。搭配其它云安全产品与解决方案，能够全面提升安全能力与运维水平。
本次智慧安全新品的集中发布，是腾讯针对安全的基础设施、计算力、算法、海量安全大数据，以及腾讯安全联合实验室研究成果和近二十年安全经验积累的进一步开放。借此机会，腾讯云更对其安全生态进行了全面介绍：已联手家合作伙伴，推出超过款云端安全产品，涵盖主机、网络、移动等七大安全领域。

腾讯云副总裁、腾讯社交网络与腾讯云安全负责人黎巍指出，安全攻防是一场技术赛跑，过去安全界的法宝，无论是“修长城”找到边界和要塞隔离、审计、控制，还是“搭迷宫”制定成千上万的策略限制黑客，都已经无法应对严峻的安全形势。 “无论我们情愿不情愿，身处这个赛道里，要想克敌制胜，我们必须要具备更加智能高效的高纬打击能力。”
为此，腾讯云正以和大数据为驱动力，以云为平台和管道构建新一代智能安全防御体系。包括利用大规模图挖掘与机器学习追踪恶意团伙；通过人群画像与建模，应对羊毛党与欺诈；整合多维度数据和威胁情报信息，通过机器学习，建立更加积极主动的态势感知系统。
除了提高云平台的安全打击能力，腾讯云还致力于开放技术积累，帮助用户构建智能的安全防御能力。为此，腾讯云在本次大会上，一口气发布了三大新品、三大行业安全解决方案，并推出腾讯云安全产品矩阵。

新品一：云镜
作为腾讯云“云鼎实验室”全新发布的主机安全防护产品，云镜主要为云上企业用户提供黑客入侵检测和漏洞风险预警等安全防护服务，包括密码破解拦截、异常登录提醒、木马文件查杀、高危漏洞检测等安全功能。基于腾讯安全积累的海量威胁数据，云镜利用机器学习，可以帮助用户低成本地构建云主机安全防护体系，防止数据泄露。
通过云镜的资产管理，用户能够容易且及时地发现漏洞并进行漏洞管理；云镜还能够对可疑异地登录进行告警提醒，对于暴力破解，将直接在云端网络链路上进行快速检测和拦截；对比传统做法，云镜更额外增加了虚拟执行和机器学习的方式对进行检测，对于加密变形类，具备更好的检出率；云镜能对系统漏洞的修复情况进行普查，后台更接入了电脑管家的引擎，依托电脑管家的亿万覆盖率，可以快速发现并检测各类病毒，解决行业内主机防护软件缺少海量样本，检测能力薄弱的的问题。依托云镜，的主机安全问题都能得到有效解决。
新品二：反诈骗云
“腾讯安全反诈骗实验室”首次在云端输出反诈骗技术能力，主要面向政府与金融行业，能够最大限度帮助用户在面对诈骗行为时成功止损。以金融行业为例，腾讯云反欺诈产品包含有反薅羊毛、反骗贷、反洗钱、反骗保保险、移动银行保护、防盗刷等众多的。依托年的安全积累、亿级体量的黑产数据，腾讯从计算力、算法、数据等三方面能力， 为反诈骗的创新提供了坚实基础。
新品三：网站管家
作为专业为网站服务的一站式智能防护平台，网站管家，对比传统的应用防护系统，拥有更多新的功能特性。网站管家包含云智能防火墙、业务防控、高级威胁检测、多地容灾保障四大防御体系，能够有效抵御恶意入侵，隔离垃圾访问，护航企业传播，免疫链路故障。通过立体协同的防御策略，全面保护网站的系统安全和业务稳定。
网站管家的背后，拥有一支专业安全团队，×小时跟进全球互联网最新出现的漏洞，并能够及时提供虚拟补丁，防护的同时不中断业务。网站管家还会把黑客的攻击行为和特征存到大数据信息库，黑客再作恶将面对整个平台的封禁。腾讯还拥有强大的数据与基础能力积累，亿级黑库、遍布全球的百万个节点，能够有效进行智能业务防控，防范高级威胁，为合法内容的有效传播保驾护航。
全新的行业安全解决方案：车联网
随着车联网的深化，系统越来越复杂，直接体现在背后的代码行数正不断增加。现在智能车联网代码行数将近亿行，相当于开发了一个加，复杂的系统带来大量的潜在漏洞风险。
腾讯云车联网安全方案在大会上首次发布，针对车联软件的全生命周期提供安全解决方案。从安全管理、概念风险验证、产品研发、产品运营、技术支持的全面阶段，为车联安全提供事前、事中、事后的全面防护解决。通过在腾讯云的底层安全能力保证，以软件安全开发生命周期结合 网联汽车网络架构安全指南，提供安全评估和咨询服务。同时，以腾讯安全科恩实验室技术能力为验证，确保安全能力达到全球领先水平。
特斯拉、蔚来、比亚迪、通用等汽车公司均正使用腾讯云的车联网安全解决方案。此前，腾讯安全科恩实验室就凭借“全球首次远程无物理接触方式入侵特斯拉汽车”研究成果，被选入“特斯拉安全研究员名人堂”，并获得特斯拉的公开致谢。
升级的行业安全解决方案：移动安全
经过全新升级，移动安全解决方案目前已涵盖盗版监控、跟踪、漏洞扫描、应用加固、游戏反外挂、伪基站检测、木马检测、网站识别、欺诈风险识别等主要功能，从数据运营、应用安全、终端支付安全三大层面，为移动应用保驾护航。
其中，应用加固能力是应用宝、腾讯云双平台指定加固方案，已为数十万进行加固，覆盖超过亿台终端。反外挂更是腾讯的专有解决方案，开放王者荣耀级别的反外挂技术，能对抗不同的修改器和变速器。更提供来自腾讯电脑管理的的木马检测能力，查杀能力在国内外评测标准中都名列第一。
升级的行业安全解决方案：视频直播
得到升级的还包括直播安全解决方案，新版本方案包含恶意消息处理、图片鉴黄、语音识别、身份验证等能力。能力的背后是腾讯的强大技术积累：腾讯系相关的图片处理能力每天可以处理超过亿张图片，人脸检测与分析技术在年的排名中就刷新了世界记录。
腾讯云希望通过智能协同的方案，以更低的成本更早发现业务安全风险。过去有直播平台需要雇佣数百名内容审核人员，但每天发现不到一个带有问题内容的房间，应用该方案后，效率能得到数十倍的提升。
大会上，腾讯云进行了全新的安全生态合作的发布仪式。知道创宇副总裁汤周华，思科大中华区战略合作高级总监曹玉荣，云安全服务总经理、华南区销售总监王志国，华南区总经理龚建川，启明星辰高级产品总监郝春光，深信服生态合作运营总监倪金宝，与腾讯云副总裁、腾讯社交网络与腾讯云安全负责人黎巍共同在屏幕上按下象征紧密携手的手印。

在腾讯云全力打造的安全新生态中，目前已联手超过家合作伙伴，推出超过款联合云端安全产品，涵盖主机安全、数据安全、网络安全、运维安全、风控安全、移动安全、安全服务等七大领域。其中，三位腾讯云安全合作伙伴的代表也来到了会场，带来了云安全实践的重要分享。
北京启明星辰信息安全技术有限公司副总裁袁智辉表示，信息安全跟云结合后，已经变成基础设施的基本要求。解决云安全问题，需要云服务商、云租户、监管机构各自承担责任角色。启明星辰的云安全方案主要关注云安全接入，云安全监管，云安全检测及防护，以及云数据安全。袁智辉指出，启明星辰已经和腾讯云建立了战略合作伙伴关系，通过越来越多的协作，已经互为生态，并将继续往前推进。
富途证券国际香港有限公司陈伟华认为，安全是一个大大的帽子，是一个系统工程，拥有一大堆正交的领域。安全还是一个关乎负体验的问题，要在确保安全的同时，不会产生大量控制带来的高额成本。面对复杂的安全系统，陈伟华将安全体系分成了四部分：信息安全、运营安全、办公网安全、实体安全，并且对每部分进行了展开，讲述富途证券的安全实践经验。
思科系统香港有限公司大中华区副总裁庄敬贤先生认为，在云、未来数字化的时代，安全必须演变，从安全有跟无的关系到安全有效和无效的关系。思科和腾讯云等合作伙伴一道，建立有效的安全，定位在以未知威胁为中心，做架构性的联防联动，实现在最新的混合云的环境下的最好应用。大家好，我们的团队是由来自三个不同专业的小伙伴组成，且都是萌新，这是我们团队第一次参加数据挖掘比赛。我们团队从月号下载数据后开始看题目，找相关资料等，就在当天晚上我在腾讯官方微信公众平台上看到了腾讯数据挖掘工程师陈成龙分享的“  数据挖掘比赛经验分享”的干货，这份干货对数据挖掘小白的我们实在是太有用了，于是我和队友花了整整一天的时间研究了一下这份干货，随后再去看题目，这才有了一些思路。尽管我们在初赛过程中困困重重，但我们经过两周的共同的努力，目前以的成绩进入了决赛。下面我就针对具体问题介绍一下我们的做法。
数据集构造方面
我们在看了好几遍题目后，开始尝试用干货中提到的数据清洗策略清洗本次数据。首先是分别统计了  中 = 和 = 的样本数量，发现这个比例是：，很明显是正负样本不均衡的问题。然后发现数据分布在个 文件中和除外，这里需要做的工作就是 ，但真正要把  做好就需要找对连接的标签和采用的连接方式，我们用了左外连接。另外在  划分方面，我们随机选取数据集的作为  ，因为不同的随机数种子产生的  集的  会有些差异，但是要注意数据泄露的问题，比如用的数据去做训练，天的数据去做测试，这就有可能导致数据泄露，这里我们尝试改变随机数种子使得线上线下接近一致。
模型构建方面
我们队使用的模型是模型 ，没有调参，也就是默认的参数。我们的主要精力放在寻找特征上，在决赛中我们可能考虑用 ，因为决赛数据是预赛数据的倍，所以为了尽快看到结果，所以会选择 。
特征工程方面
在广告点击率和转化率的特征中，特征可以分为三类，一是   无序特征，二是  有序特征，三是  数值特征。我们队对于特征的处理如下：
使用统计频率、转化次数特征、转化率特征代替  ，这里我们对 =的用户进行统计分析，针对用户的历史交互，安装  等信息，从用户的角度去思考可能决定他点击广告后发生激活的原因，由此提取出一些可能的特征，之后再进行特征提取以及验证。
对训练集和测试集中的重复样本构造是否第一次点击，是否中间点击，是否最后点击，第一次和最后一次间隔特征。
大量使用组合特征，主要是用户特征和广告上下文特征。
总结
在初赛过程中，我们不断地挖掘特征，检验特征，阅读  上竞赛获奖者的开源代码等，尽管我们目前的成绩不是太好，但是我们真正学到了东西，正所谓，一次参赛，终身受益。最后感谢腾讯为我们提供的平台和服务。
最后预祝小伙伴们在决赛中取得好的成绩。谢谢。微软大会期间领域的 之外，就是   ，大家都知道    是基于运行的， 也是闪亮登场， 是一个非常重要的里程碑版本，支持 位部署，还有支持等，  和微软的 的可操作性，兼容性也得到了更好的统一，还有很多特性为的游戏之王准备，今年的平台会有全面的升级。
 的安装方式也进行了全面升级，安装更加简单，安装包的仓库也是非常的先进了，有个有钱的微软老爸就是好，具体参考 。
下面我们就来简要介绍下在腾讯云上的 的安装包方式安装，当然我安装 的主要目的是运行
一、  系统更新运行
 – 
二、 参照官方的安装，首先添加安装包仓库
  

  ==

  
三、安装
  
等待几分钟的下载安装，安装完后我们使用 – 检查我们的安装是否成功：
我们很简单的就成功安装了 
目前覆盖的范围还是 了，也就是赶上了 ，后面我们的生活就很好了，的也覆盖全了，  和 以及 三大平台助力我们成为一个全栈开发工程师。相关推荐
宋宝华：   易用剖析器  是什么为什么以及怎么办   
宋宝华：   易用剖析器 是什么为什么以及怎么办   


本文来源于  微信公众号作者：柯灵杰


    前言
现在、技术正值风口，催生了一大批相关的，使得图像学不再是游戏开发人员的专属知识，而是更多的普及开来。
本文主要针对一些对有兴趣的同学，普及图形学知识，不涉及深入的技术探讨和样例介绍。对于不是从事相关开发的同学也能了解相关的知识
部分材料来源于网络和书籍。
    什么是图形学
图形学也称计算机图形学，简称。它是研究图形的输入、模型图形对象的构造和表示、图形数据库管理、图形数据通信、图形的操作、图形数据的分析，以及如何以图形信息为媒介实现人机交互作用的方法、技术和应用的一门学科。它包括图形系统硬件图形输入输出设备、图形工作站图形软件、算法和应用等几个方面。
图形学的研究内容非常广泛，如图形硬件、图形标准、图形交互技术、光栅图形生成算法、曲线曲面造型、实体造型、真实感图形计算与显示算法，以及科学计算可视化、计算机动画、自然景物仿真、虚拟现实等。
平时我们开发游戏或者应用用到的，属于其中的一个分支：实时渲染
渲染，或称“绘制”在电脑绘图中，是指：用软件从模型生成图像的过程。模型是用语言或者数据结构进行严格定义的三维物体或虚拟场景的描述，它包括几何、视点、纹理、照明和阴影等信息。图像是数字图像或者位图图像。渲染用于描述：计算视频编辑软件中的效果，以生成最终视频的输出过程。
渲染是三维计算机图形学中的最重要的研究课题之一，并且在实践领域它与其它技术密切相关。在图形流水线中，渲染是最后一项重要步骤，通过它得到模型与动画最终显示效果。自从二十世纪七十年代以来，随着计算机图形的不断复杂化，渲染也越来越成为一项重要的技术。
渲染的应用领域有：计算机与视频游戏、模拟、电影或者电视特效以及可视化设计，每一种应用都是特性与技术的综合考虑。作为产品来看，现在已经有各种不同的渲染工具产品，有些集成到更大的建模或者动画包中，有些是独立产品，有些是开放源代码的产品。从内部来看，渲染工具都是根据各种学科理论，经过仔细设计的程序，其中有：光学、视觉感知、数学以及软件开发。
实时渲染经常用于三维视频游戏，通常依靠图形处理器完成这个过程。
    效果展示

    渲染管线

  什么是渲染管线
渲染管线也称为渲染流水线或像素流水线或像素管线，是显示芯片内部处理图形信号相互独立的的并行处理单元。在某种程度上可以把渲染管线比喻为工厂里面常见的各种生产流水线，工厂里的生产流水线是为了提高产品的生产能力和效率，而渲染管线则是提高显卡的工作能力和效率。
渲染管线就是显示核心中负责给图形配上颜色的一组专门通道。它是显示核心中单独设计的一组电路，拥有单独的晶体管。渲染管线越多，那么所绘出的图形它的填充效率就越高，自然我们看到的画面也就越流畅越精美。这就是为什么渲染管线越多越好的原因。如果少了，那么自然就会使显卡的性能下降。当然渲染管线越多，显示核心就会越大，因为它所使用的晶体管数目增加了。
  渲染管线的流程
   总流程图

   顶点着色器

为了实现逼真的场景，仅渲染对象的形状和位置是不足够的，它们的外观亦需要模拟。这些描述包括第每对象材质，以及光源照射对象产生的特效。模拟材质和光源的方法有很多种，包括从最简单的颜色到精细的物理特性描述。
决定光和材质特效的操作称为着色。它包括了计算不同点的着色方程。典型的某些这类的计算运行在几何阶段的模型顶点数组上，另外一些则运行在逐象素的光珊化阶段。各类的材质数据，例如点所在位置，法向量，颜色或其它着色方程需用到的数值信息，可储存在每个顶点中。顶点着色的结果这可能是颜色，向量，纹理坐标或其它种类的着色数据会被送进光珊化阶段去插值。
着色阶段通常被认为是发生在世界空间。在实践中，有时则将相应的实体例如摄像机和光源变换到其它空间例如模型或视觉空间并在那运行计算更为方便。因为如果所有包含在着色计算中的对象均被变换到同一空间，则光源、摄像机和模型的相对关系是保留的。
   图元装配

经过变换的顶点流按照顺序被送到下一个被称为图元装配的阶段。首先，在图元装配阶段根据伴随顶点序列的几何图元分类信息把顶点装配成几何图元。这将产生一序列的三角形、线段和点。这些图元需要经过裁剪到可视平截体三维空间中一个可见的区域和任何有效地应用程序指定的裁剪平面。
   背面剔除

我们知道，渲染的基本单位是一个个的三角形面片。无论多么复杂的 模型都是由一个个基本的三角型的面片组成的。既然是一个面片，那必然就有两个面，如果其中有一个面被称为正面，那相应的另一面就被称为背面。
同一时刻我们在看见某一面的同时，另外一面则必然是看不的。在这里我们可以想象一个封闭的不透明的几何体，我们肉眼只能看到它的外面，而它的内部我们是看不见的。如果没有开启表面剔除，则可能有很多从一般常识上看来是看不见的那一面比如几何体内部，它也会去渲染。这显然会大大降低渲染效率和增加不必要的系统开销。
渲染中通过顶点的排列顺序来决定正反面
   光栅化

得到已变换及投影后的顶点及与之相关联的着色数据，光珊阶段的目标是计算并设置像素的颜色。这个过程叫光珊化或扫描变换，即从二维顶点所处的屏幕空间所有顶点都包含值即深度值，及各种与相关的着色信息到屏幕上的像素的转换。
   测试和混合

  裁剪测试
将超出屏幕的部分裁剪掉，无需后续运算
  采样

采样又称取样，指把时间域或空间域的连续量转化成离散量的过程。
抗锯齿英语：，简称，也译为边缘柔化、消除混叠、抗图像折叠有损等。它是一种消除显示器输出的画面中图物边缘出现凹凸锯齿的技术，那些凹凸的锯齿通常因为高分辨率的信号以低分辨率表示或无法准确运算出图形坐标定位时所导致的图形混叠而产生的，反锯齿技术能有效地解决这些问题。它通常被用在在数字信号处理、数字摄影、电脑绘图与数码音效及电子游戏等方面，柔化被混叠的数字信号。
    超级采样抗锯齿
超级采样抗锯齿 ，简称此是早期抗锯齿方法，比较消耗资源，但简单直接，先把图像映射到缓存并把它放大，再用超级采样把放大后的图像像素进行采样，一般选取个或个邻近像素，把这些采样混合起来后，生成的最终像素，令每个像素拥有邻近像素的特征，像素与像素之间的过渡色彩，就变得近似，令图形的边缘色彩过渡趋于平滑。再把最终像素还原回原来大小的图像，并保存到帧缓存也就是显存中，替代原图像存储起来，最后输出到显示器，显示出一帧画面。这样就等于把一幅模糊的大图，通过细腻化后再缩小成清晰的小图。如果每帧都进行抗锯齿处理，游戏或视频中的所有画面都带有抗锯齿效果。而将图像映射到缓存并把它放大时，放大的倍数被用于分别抗锯齿的效果，如：图，后面的、、就是原图放大的倍数。 超级采样抗锯齿中使用的采样法一般有两种：
顺序栅格超级采样  ，简称，采样时选取个邻近像素。
旋转栅格超级采样  ，简称，采样时选取个邻近像素。
    多重采样抗锯齿
多重采样抗锯齿 ，简称是一种特殊的超级采样抗锯齿。首先来自于。具体是只对缓存和模板缓存 中的数据进行超级采样抗锯齿的处理。可以简单理解为只对多边形的边缘进行抗锯齿处理。这样的话，相比对画面中所有数据进行处理，对资源的消耗需求大大减弱，不过在画质上可能稍有不如。
    覆盖采样抗锯齿
覆盖采样抗锯齿 ，简称是在及其衍生产品首次推向实用化的技术，也是目前  系列独享的技术。就是在基础上更进一步的节省显存使用量及带宽，简单说就是将边缘多边形里需要取样的子像素坐标覆盖掉，把原像素坐标强制安置在硬件和驱动程序预先算好的坐标中。这就好比取样标准统一的，能够最高效率的执行边缘取样，效能提升非常的显著。比方说取样性能下降幅度仅比略高一点，处理效果却几乎和一样。有着的处理效果，性能消耗却和相同。
    可编程过滤抗锯齿
可编程过滤抗锯齿  技术起源于的家庭。简单地说就是扩大取样面积的，比方说之前的是严格选取物体边缘像素进行缩放的，而则可以通过驱动和谐灵活地选择对影响锯齿效果较大的像素进行缩放，以较少的性能牺牲换取平滑效果。显卡资源占用也比较小。
    快速近似抗锯齿
快速近似抗锯齿   它是传统多重采样抗锯齿效果的一种高性能近似值。它是一种单程像素着色器，和一样运行于目标游戏渲染管线的后期处理阶段 。
    时间性抗锯齿
让电影画质的游戏体验达到逼真水平。
 抗锯齿 比 和 以及  的画质更高，制作电影的电影制片厂会在抗锯齿方面花费大量的计算资源，从而可确保观众不会因不逼真的锯齿状线条而分心。如果想要让游戏接近这种级别的保真度，那么开发商需要全新的抗锯齿技术，不但要减少锯齿状的线条，而且要减少锯齿状闪烁情形，同时还不降低性能。为了便于开发商实现这种保真度的提升，英伟达设计了画质更高的抗锯齿模式，名为该模式专为直接集成到游戏引擎中而设计。与电影中所采用的技术类似，集的强大功能与复杂的解析滤镜于一身，可呈现出更加平滑的图像效果，远远超越了所有同类技术。此外，还能够对帧之间的整个场景进行抖动采样，以减少闪烁情形，闪烁情形在技术上又称作时间性锯齿。目前，有两种模式： 和 。 可提供堪比 的视觉保真度，然而所需性能却与 相类似； 的图像保真度胜过，所需性能仅仅与 相当。
    多帧采样抗锯齿
英伟达根据改进出的一种抗锯齿技术。目前只有使用  架构的显卡才可以使用。在  上，英伟达推出了用于光栅化的可编程采样位置，它们被存储在随机存取存储器  中。如此一来便为更灵活、更创新的全新抗锯齿技术创造了机会，这类抗锯齿技术能够独特地解决现代游戏引擎所带来的难题，例如高画质抗锯齿对性能的更高要求。只要在控制面板里为程序开启并在游戏中选择就可以开启。画面表现明显强于同级别的，这种全新抗锯齿技术在提升边缘画质的同时能够将性能代价降至最低。通过在时间和空间两方面交替使用抗锯齿采样格式， 的性能代价仅相当于 ，但是抗锯齿效果却与 相当。
  模板测试

模板测试是所有测试中比较复杂的一种
在模板缓冲区中为每个像素保存了一个“模板值”，当像素需要进行模板测试时，将设定的模板参考值与该像素的“模板值”进行比较，符合条件的通过测试，不符合条件的则被丢弃，不进行绘制。
条件的设置与测试中的条件设置相似。但注意测试中是用浮点数来进行比较，而模板测试则是用整数来进行比较。比较也有八种情况：始终通过、始终不通过、大于则通过、小于则通过、大于等于则通过、小于等于则通过、等于则通过、不等于则通过。
  深度测试

  什么是深度？
深度其实就是该象素点在世界中距离摄象机的距离绘制坐标，深度缓存中存储着每个象素点绘制在屏幕上的的深度值！
深度值值越大，则离摄像机越远。
深度值是存贮在深度缓存里面的，我们用深度缓存的位数来衡量深度缓存的精度。深度缓存位数越高，则精确度越高，目前的显卡一般都可支持位的 ，一些高级的显卡已经可以支持位的 ，但一般用位 就已经足够了。
  为什么需要深度？
在不使用深度测试的时候，如果我们先绘制一个距离较近的物体，再绘制距离较远的物体，则距离远的物体因为后绘制，会把距离近的物体覆盖掉，这样的效果并不是我们所希望的。而有了深度缓冲以后，绘制物体的顺序就不那么重要了，都能按照远近值正常显示，这很关键。
实际上，只要存在深度缓冲区，无论是否启用深度测试，在像素被绘制时都会尝试将深度数据写入到缓冲区内。这些深度数据除了用于常规的测试外，还可以有一些有趣的用途，比如绘制阴影等等。
   混合

“混合”是指两种颜色的叠加方式。在新图片将要渲染画到屏幕上的时候，将用在新图片中的红、绿、蓝和透明度信息，与屏幕上已经存在的图片颜色信息相融合。
说的具体一点，就是把某一像素位置上原来的颜色和将要画上去的颜色，通过某种方式混在一起，从而实现特殊的效果。
把源颜色和目标颜色各自取出，并乘以一个系数源颜色乘以的系数称为“源因子”，目标颜色乘以的系数称为“目标因子”，然后相加，这样就得到了新的颜色。
   抖动

  什么是抖动
对于可用颜色较少的系统，可以以牺牲分辨率为代价，通过颜色值的抖动来增加可用颜色数量。抖动操作是和硬件相关的，允许程序员所做的操作就只有打开或关闭抖动操作。实际上，若机器的分辨率已经相当高，激活抖动操作根本就没有任何意义。默认情况下，抖动是激活的。
  如何抖动
图案化使用图案来表示象素的灰度，那么我们来做一道计算题。假设有一幅××的灰度图，当用分辨率为×的激光打印机将其打印到×英寸的纸上时，每个象素的图案有多大？
这道题很简单，这张纸最多可以打× ××=×个点，所以每个象素可以用×=×个点大小的图案来表示，即一个象素个点。如果这×的方块中一个黑点也没有，就可以表示灰度；有一个黑点，就表示灰度；依次类推，当都是黑点时，表示灰度。这样，×的方块可以表示级灰度，比要求的共级灰度还多了一个。所以上面的那幅图的灰度级别完全能够打印出来。
这里有一个图案构成的问题，即黑点打在哪里？比如说，只有一个黑点时，我们可以打在正中央，也可以打×的左上角。图案可以是规则的，也可以是不规则的。一般情况下，有规则的图案比随即图案能够避免点的丛集，但有时会导致图象中有明显的线条。
如下图所示，×的图案可以表示级灰度，

当图象中有一片灰度为的的区域时，如下所示，有明显的水平和垂直线条。

如果想存储级灰度的图案，就需要××的二值点阵，占用的空间还是相当可观的。有一个更好的办法是：只存储一个整数矩阵，称为标准图案，其中的每个值从到。图象的实际灰度和阵列中的每个值比较，当该值大于等于灰度时，对应点打一黑点。下面举一个级灰度的例子加以说明。

上图，左边为标准图案，右边为灰度为的图案，共有个黑点，个白点。其实道理很简单，灰度为时全是黑点，灰度每增加，减少一个黑点。要注意的是，×的图案可以表示种灰度，当灰度是才是全白点，而不是灰度为时。
下面介绍一种设计标准图案的算法，是由在年提出的。
先以一个×的矩阵开始：设

通过递归关系有：

其中和均为×的方阵，的所有元素都是。根据这个算法，可以得到

为级灰度的标准图案。
×阵比较特殊，称为抖动表。是一个×的矩阵。
根据上面的算法，如果利用一个象素要用×的图案表示，则一幅×的图将变成×大小。如果利用，就更不得了，变成×了。能不能在保持原图大小的情况下利用图案化技术呢？一种很自然的想法是：如果用阵，则将原图中每×个点中取一点，即重新采样，然后再应用图案化技术，就能够保持原图大
小。实际上，这种方法并不可行。首先，你不知道这×个点中找哪一点比较合适，另外，×的间隔实在太大了，生成的图象和原图肯定相差很大，就象下图最右边的那幅图一样。

我们可以采用这样的做法：假设原图是级灰度，利用抖动表，做如下处理
     打一白点  打一黑点
其中，代表原图的象素坐标，代表该点灰度。首先将灰度右移两位，变成级，然后将，做模运算，找到表中的对应点，两者做比较，根据上面给出的判据做处理。
我们可以看到，模运算使得原图分成了一个个×的小块，每个小块和×的表相对应。小块中的每个点都参与了比较，这样就避免了上面提到的选点和块划分过大的问题。

    坐标变换
 
  自身坐标系

自身坐标系又叫做建模空间，这是我们定义物体的三角形列的坐标系。自身坐标系简化了建模的过程。在物体自己的坐标系中建模比在世界坐标系中直接建模更容易。例如，在自身坐标系中建模不像在世界坐标系中要考虑本物体相对于其他物体的位置、大小、方向关系。
  世界坐标系

一旦我们构造了各种模型，它们都在自己的自身坐标系中，但是我们需要把它们都放到同一个世界坐标系中。物体从自身坐标系到世界坐标系中的换叫做世界变换。世界变换通常是用平移、旋转、缩放操作来设置模型在世界坐标系中的位置、大小、方向。世界变换就是通过各物体在世界坐标系中的位置、大小和方向等相互之间的关系来建立所有物体。
  视图坐标系

世界坐标系中的几何图与照相机是相对于世界坐标系而定义的，如图所示。然而在世界坐标系中当照相机是任意放置和定向时，投影和其它一些操作会变得困难或低效。为了使事情变得更简单，我们将照相机平移变换到世界坐标系的源点并把它的方向旋转至朝向轴的正方向，当然，世界坐标系中的所有物体都将随着照相机的变换而做相同的变换。这个变换就叫做视图坐标系变换  。
  投影

视图坐标系的主要任务就是将场景转化为图像表示。这种从维转换成维的过程就叫做投影。投影的方法有很多种，但是我们只对一种特殊的投影感兴趣，那就是透视投影。因为透视投影可以使离照相机越远的物体投影到屏幕上后就越小，这可以使我们把场景更真实的转化为图像。
投影变换的实质就是定义可视体，并将可视体内的几何图形投影到投影窗口上去。
接《 图形学基础 下》相信各位都对知乎存在着不解！ 知乎到底如何将优化起来了，下面我们来对知乎的进行解答。
结构好
每个问题上面都有相关标签以本问题为例我们可以看到以下标签 知乎，搜索引擎优化，网站运营，口碑营销，工具 这些标签每个都与本页的主题紧密相关，而且任何知乎用户都可以修改矫正。
 右侧的相关问题。推荐的很靠谱也是与本主题非常相关的问题，使得关键词密度进一步提升，便于搜索引擎分析到页面主题内容。  
 每一个回答者都可以定义自己在这个问题领域的专属签名档，内容又进一步加深了页面相关度。  
 投票机制让高质量答案排名提升，让高质量内容出现在代码更靠前的位置，方便搜索引擎识别抓取。  
 不断有新回答、关注人数、浏览次数的更新，造成页面内容持续不断更新，迎合了搜索引擎喜新厌旧的特性。  
 每个答案的静态输出产生大量优质页面。当然为了避免相似重复页面，知乎做了一定程度的内容填充工作，相当于伪原创。
 通过标签的组织方式，使得内部相关链接极丰富，形成良好的网状结构。  
内容好
高质量原创的内容搜索引擎自然喜欢，而且问题一般伴随着新闻热点、潮流热点大量涌现，大量专业人士的讨论使得内容呈现出丰富的专题效果。  
被引用多
高质量的内容被各大网站和社会化媒体引用次数多，外链极为丰富，无论数量还是质量。   
以上内容只是表述为什么知乎的效果好。 
但是知乎很多看似非常的做法，初衷并不是为了，而是为了更好的内容展现、内容的再次消费、聚合与传播。  
比如问题投票机制，目的是希望让用户看到高质量、有价值的回答排序甚至不是纯粹的按点赞数量排序，只是这种做法刚好又符合了规则。 
比如标签的使用，是为了每个问题都有完善的相关词条，让内容更好的组织、导航，取代传统的分类做法。初衷也肯定不是像不少网站一样导入各种词库，产生大量垃圾索引页抢流量。 
另外：一个网站拥有良好的用户体验非常重要，对实际的效果也有正反馈作用，但不是说完全不需要，一提就觉得逼格瞬间变。 搜索引擎也在进化发展，在它没有变的像人一样聪明前，作为百度、谷歌等搜索引擎也希望网站按他们的规则来做优化，让蜘蛛更好的识别抓取网站内容，这是理论上的双赢。  
不是为了作弊，欺骗搜索引擎获得高权重、高排名。搜索引擎和网站之间绝对不是对立关系，需要互相扶配合，各自为自家的产品赚得流量、用户、影响力！ 
新媒体时代内容依然为王
传统媒体的没落，并非是内容出现了差池，而是读者在便捷性上做出了选择。偷懒使人进步。在人类的伟大历史上，这一点总是被一再地证明。如今，则通过传统媒体的衰落再次证明了它的存在。当你怀揣着一部手机，能够轻易地打开电子书或电子报纸的时候，或者通过类似于网易新闻客户端去获得一些新闻的时候，我实在想不出还有什么理由促使读者非要去买一份报纸。
如今，新媒体并非尚未到来，而是已经泛滥成灾。若非如此，我们不能猜想传统媒体何以会衰落。尽管媒体人总是抱怨国人不爱阅读，其实阅读却一直存在，且不断增长。业界人士之所以如此抱怨的原因，不是他们看到了真正的阅读数据，而是一种固化的思维在作怪：国家统计数据说国人每年人均读一本多书，由此可以证明国人不爱阅读。这纯属凭空想象。
而事实是，在读者打开一个新闻客户端的时候，他们就一定是在阅读；在他进入“多看”或“”的时候，他们当然也是在阅读；当他们打开某个网站时，自然同样是在阅读……这就是事实，阅读无处不在。假如能汇总这样的数据，相信媒体人会欢喜雀跃：天啊，他们太能读了。不错，的确是太能读了。那么多动辄百万字、千万字的网文，居然就从头到尾读完了。而且读完的时间是如此之短。这让人如何想象？
然而，就是在阅读如此之广泛，阅读量是如此之大的情况下，我们媒体人却每日都在提心吊胆，似乎行业消亡就在今天，自己失业也眨眼可见。为什么？
我们应该好好想想，什么是媒体或者出版？然后再想想如何通过媒体或出版去让自己生存获得效益？想清楚这两点，也就想清楚自己的定位，以及这个行业的明天。
对于第一个问题，我是这样理解的。所谓的媒体或者出版，就是将选择的内容简便地传递给读者的过程。这里面有两个要点：其一是“经过选择的内容”；其二是将这些内容简便地传递给读者。网络时代较之过去有了很大的不同。内容的生产者已经高度多元化，因此使内容泛滥成灾。如今不是担心看不到、找不到内容，而是看不到“想看的”、找不到“想找”的内容。这一点恰恰是媒体人或出版人千百年来始终如一的职责和使命。
我们的任务就是从如此之多的内容中，筛选出更好的东西，或者整合出特定的内容，去奉献给读者。也就是说，你得让你的读者去“省心”。自然，你得了解你的读者，这点跟过去并无不同，只是如今的读者口味更“刁钻”一点罢了。所以，一般来说，你不能去搞千篇一律的东西——那是新浪或搜狐这种门户网站的使命，即便是它们也不能搞个百把十个，有那个三两个足以。
有人会说，我们过去就这么搞，照常活得好啊。不错，过去能活得好。但过去活得好，是因为过去所存在的“壁垒”保护了你。一个北京的读者很难去买一份南京的报纸来看，所以，尽管大量内容同质，两地的两份报纸都活了下来。而一份《北京晨报》和一份《北京晚报》也同样活了下来，那是因为你们分享了这个城市的都市报读者。其实假如就一家，卖的份数会更多，不是吗？
但如今的形势变了，网络时代让这种壁垒不复存在。前例的情形直接就消亡了。所以，你不可能搞一个南京客户端，一个北京客户端。而最多只能类似于上面的《北京晨报》和《北京晚报》，同样的客户端去分享众多的读者。结果就是，这样的客户端只能类似于《北京晨报》和《北京晚报》一样，只能存在那么三两个，除非你能让《北京晨报》看起来真的和《北京晚报》不同。其实，《北京晨报》和《北京晚报》的区别远远比两个这样的客户端大。毕竟纸质报刊是一次性的，《晨报》发了新东西，《晚报》就无需再发，而可以增加当天的新内容。但两个客户端却可以“随时更新”。
上面罗嗦这么多，其实就一个观点：在网络媒体时代，同质的东西不能同时存在，至少不能大量同时存在。因此，你想做一份新媒体，那么只有唯一的一个选择：创建自己独特的内容。新闻或者某个城市发生的那些鸡毛蒜皮的事情，肯定永远不会成为“独特内容”了。所以，都市报、新闻报之类的媒体唯有消亡一途——扪心自问，你能做得比网易新闻客户端等等这些门户网站的更好吗？
因此，我们看到了新媒体虽然泛滥，但诸如网易新闻客户端等等这种整合新闻的媒体极少，大多数都是类似于“氪”、“知乎”等等这些极具特色的东西。而且，在每种媒体所涉及的领域内，同样也不能大量存在。比如，更多的类似“氪”的大众科技新媒体，那实在不可想象。一份足以，两份嘛，那就你们俩分享读者啦。因此，从传统媒体转型新媒体的途径也唯有一条：创新，真正意义的创新。创建你独有的内容，这才是出路。
在选择内容之后，还得学会“简便地传递”给读者。这点也很重要。你不能搞得太麻烦。这个就不多说了，各家都有一本经，难念好念，自己多想想也就是了。除了自我推广，比如创建一个，新媒体同样和传统媒体一样，也需要一个类似于邮政发行系统的东西，来集合推广这些媒体。这点目前发展的当然不是太好，但也有了一些苗头，比如在“多看”上，已经有了若干新媒体的刊物在逐期发布，类似于“读览天下”也在做一些数字媒体的推广和订阅。这些通路将来肯定会不断发展，并最终成为一些有效的通路。所以，做新媒体倒也不必过于担心销售问题。
对于第二个问题，就是如何如何通过新媒体去生存。这个问题当然是目前媒体或出版人所最感头痛的。实际上我们也能看到，大多数新媒体基本都是在免费阅读。其实，按我的看法，新媒体免费真的没什么不好，也不会与过去有什么更大的不同。难道过去存在的诸多都市报们不是在免费阅读吗？虽然看上去每份报纸卖上几角钱或几块钱，但相对于它的编辑成本、印制成本，其实这点卖报收益真的可以忽略不计。原来怎么赚钱的？无非是靠广告嘛。当然，图书可能是个例外。但这个例外在新媒体时代，或许就不会仍然例外。互联网的条件，使图书也可以靠广告来获得收益，也慢慢成为可能。自然，相较于报刊类新媒体，电子书从广告获得收益仍然有些难度，毕竟品种在那儿，不像报刊那样按期操作。
如上，只是说明了一个问题：其实，在新媒体时代，报刊们仍然可以通过广告去获得主要收益。这点跟过去并无不同。同时，它们仍然可以去订阅，去卖出某个价格，甚至这个价格比传统媒体时代更有意义——毕竟电子媒体的成本远远小于纸质媒体。因此，在新媒体时代，获利的方式不是复杂了，而是简单了。
从上面罗嗦已极的论述中，我们可能很容易就认识到一点：在新媒体时代，内容的意义不是降低了，而是增加了。相较于传统媒体时代，内容为王可能更会成为现实。只有内容才是一份新媒体得以存在的基石。
但是，即便内容方面，就真的与过去有很大的不同吗？所谓内容，其实仍然不外乎两点：其一是独创内容，比如纸质的《自然》杂志，倘若将其数字化，其实仍然可以卖出原来的价格，因为它的内容是绝对独有的，读者的选择是唯一选择。一些虽然不是十分独创，但属于深度报道的，也有类似的特点，比如《南方周末》，它仍然具备在新媒体时代继续原来内容销售的潜质。其二是整合的内容。像过去的都市报，多数都是一种整合内容，只是会因为某种时间差或记者的接触面而造成一些差异，但“大路新闻”却千篇一律。
如今在这种新闻层面的整合上面，新媒体除去像网易新闻客户端等几个大巨头，别人并无此种优势。但在某个子市场或子领域中，这种优势就是可创造的。比如前面所说的“氪”就是如此。虽说若干也是某人所撰述，但内容的本质的确很多都算不上独创，只能算作“独写”。但是，将这些特定领域的内容整合在一起，对某个特定关注人群就有了意义，就会成为他们的必然和唯一选择。这就是“氪”存在的意义。
在内容整合层面上，对试图创建一份新媒体的媒体人来讲，创造一个“氪”却并无意义。网络思维是先入为主的，这种先入为主可能是第一个创建者，也可能是第一个通过推广获得声誉者，总而言之，是首先成为“领域”领跑者。所以，创建新媒体即便你不能创建独特内容，你也要创建独特概念或“内容集”，否则就没什么出路。在广泛互联的网络界面上，试图通过地域等等的壁垒来同质化存活，已经不再存在。
我个人是比较看好新媒体的，因为我相信由此会更能看到媒体人的创新，而不是千篇一律的同质化内容。同时，也能看到众多的“内容集”，使读者在浩瀚海洋一般的网络信息中更容易找对内容。这是读者的福分，也是媒体人的未来。
该文章来自于：爱好者  更多资讯请关注我们哦！作者：

文章摘自 前端小吉米。
随着前端异步的发展，  这种耦合方式的书写不利于前端异步的  回调。而且，写起来也是很复杂。  本来是在  中提出的，不过，后面觉得好用， 就把他挂载到  对象下。 这样，在前端的正常通信中 我们也可以直接调用。 但 毕竟比较新，看一下他的兼容性。

在  端上 就   和  比较   的话 基本上是不能用的 当然 前端一直是个拥抱变化的职业 官方已经有一个现成的  可以使用 这样的话 就没必要过多担心 
每用到一个新的  我们首先得知道他能不能用  这个库做的挺好的 这里 我们简单的了解一下就  了。
  = 
 基本格式
可以说  就是    使用的方式和  提供的  差不多。
  
    
     {  
        ==  {  
        `返回的响应码{}`  
          
      }

       获得后台实际返回的内容
       {  
          
      }  
    }  
    
   {  
         
  }
上面的  很好的参数了  的几个特点





 和  是  自带的两个方法 我这里就不多说了 我们来看一下 是干嘛的。 
因为返回回来的数据不仅仅包括后台的返回的  内容 还有一些  所以在  方法里面返回来的  实际上并不是我们在业务中想要的内容 就和在  里返回数据是一个道理 我们最终要的是  这个数据 而  方法实际做的事情就是调用  处理数据 并且返回一个新的  看一下  源码就应该了解。
 =  {
     
}
这里需要注意的是， 中的  都是  对象。
 传输格式
上面的  是一个  方法的请求 当然 除了   还有其他的       等 这里 我们就说一个  其他方法的基本格式还是类似的。
 {
   
   {
     
  }
       
} {
    {
     
  }    ==  {
     
  }
}
看起来  和  并没有多大的区别，但是，  里面的内容真不少。往底层看一看  实际上是      个接口的整合 不过 这个只能在  里面使用。 这里当做原理参数一下即可。
 操作
 的操作无非就是  这里我就不过多赘述直接看代码吧：
  =  
  =  
 
 
 自定义头
当然 你也可以使用字面量的形式：
 =  {
   
   
   自定义头
}
接下来就是 头部的内容的检测相关。
  
  
 
 新增自定义头

  
  自定义头 新增自定义头


  
不过 鉴于安全性的考虑 有时候在多人协作或者子版块管理时 对于头部的限制还是需要的 这里 我们可以通过  属性 设置  的相关策略。
 通常可以取     。
我们这里不探讨全部 仅仅看一下  这个选项。
当你设置了  之后 如果你设置的  涉及到    这个是浏览器自动设置的 那么该次操作是不会成功的。
   通常有：






















对比与 ， 我们没有办法去设置 的 ， 所以，这只能在  里使用。
 操作
 的基本用法和  差不多。
  =   {
   
   {
     
  }
    
}

 {
   
   {
     
  }
    
}
那  有什么用呢？
关键的地方在于， 实际上就是  的容器， 相当于就是两个元数据， 只是实际进行的操作。所以，为了达到更高的复用性，我们可以  的请求，实例化为一个个具体的对象。
  =  {}
  =  {}

 发送请求

={}


={}
在浏览器里 一切请求都逃不过跨域和不跨域的问题  也是 对于跨域的请求 主要的影响还是体现在  中 这   这 没多大影响 不过 我们需要在  设置  属性 来表示这是一个跨域的请求。
 { }  
   {  
       
  }
常用的  属性值有：

 表示只请求同域 如果你在该  下进行的是跨域的请求的话 那么就会报错
 正常的网络请求 主要应对于没有后台没有设置  话句话说 就是用来处理   等的请求的 他是  的默认值
 用来发送跨域的请求 在发送请求时 需要带上
 这是专门针对  支持出来的 ，会事先多发一次请求给 ，检查该次请求的合法性。

另外 还有一个关于  的跨域内容 在  中我们了解到  这个属性就是用来设置在进行跨域操作时 对不同域的  是否发送本域的  一般设置为 不发送 在  当中 使用的是  属性。
 常用取值为：

 发送请求时不带上  默认值
 发送同域请求时会带上 
 只要发送请求都会带上 

所以 如果你想发送  时 带上  那么你就需要使用  如果想在跨域时也带上  那么就需要 。
 跨域请求
 { }  
   {  
       
  }
 操作
 应该算和  最为接近的一个对象  的实际其实就是  回调函数传回的参数  中比较常用的属性有四个    。

 返回的状态码 
 返回状态码代表的含义 比如 返回
 用来检差  是否在和之间
 表示请求是否跨域 或是否出错 取值为 “” “” “” “” 或“”

 { }  
   {  
     
  }
这里 我们主要关心一下  上面挂载的一些属性

 同域通信类别 可以正常的访问  的 除了  头。

 跨域通信类别 一般只能访问以下的头：
 
 
 
 
 
 

 网络错误类别。


 无法理解类别 当使用  发送跨域请求时会触发。

另外在  上面还挂载了几个常用的方法 

 主要用来处理  返回的  类型数据。

 主要用来处理  返回的  类型数据。


使用方式都是流式 
  
   {  
    ={}
    ={}
  }
 处理
我们通过  请求数据时，可能会收到，，，， 等等。并且，在发送的时候比如：
  =  
 {
   
   
}
 会自动设置相关的  的头。另外，如果我们可以手动生成一个响应流方便后面其他操作。
  =     {   }
流的处理
因为， 都是以流的形式存在的，即， 的  只能被使用一次。相当于就是一个文件从缓存读到硬盘里面，那么原来文件就已经消失了。我们可以通过  去检查，该对象是否已经被使用。
  =    
  
 {
    
}
  

 {
       
}
这样做的原因主要是为了让以后  更好的处理视频的相关数据。那如果我有时候想要使用多次，那该怎么办？例如，我们   中，使用   缓存响应，然后后面我还要将该响应返回给浏览器，那么这里  流就被使用了两次。这里，就和普通的流操作一样，将该流克隆一份，使用：
  {
    =  
    
    = 
    

  
    
    

   {
     
  }
}
参考
基本的内容就是上述内容 如果想更详细参考的话 请查阅：
     


原文链接：，腾讯专家工程师，资深技术专家。从事研发年，负责腾讯自建和云业务的整体技术架构和运营，在海量服务方面经验丰富。

提起，大家一定立即想到图片，下载，视频等静态内容的分发和就近接入等加速应用。今天的互联网应用场景下，通过承载的内容越来越多，已经成为了一项不可或缺的网络基础设施了。
腾讯上运营的带宽总量已经超过，储备的带宽超过，占到业务产生的总体带宽量的八成以上。根据我们在腾讯云和内部业务的运营数据，全国范围内使用可以把用户到机房的“平均光缆长度”降低到以内。试想，如果没有，全国的用户都到同一个机房来访问，数据平均要经过才能够抵达用户手中，除了用户的访问速度会变慢以外，对于运营商的网络负载会增加数倍，以现在的网络基础设施是一定承担不了的。
为了承担海量的数据分发需求，我们建设了超过个超过百的边缘节点，分布在全国各个地区和运营商，保证用户可以同省访问到的资源。相比集中式的服务，的资源能够为用户提供非常大的网络质量优势。那么站点和应用服务来说，如何更有效的利用这些资源？除了传统的静态类内容分发以外，还能做点些什么？这篇文章从腾讯视频服务的实践经验来说明一下如何更好的支持到业务。
腾讯视频是一个综合型的服务，用户可以通过多种方式来访问，除了视频播放以外还有检索等多个功能。首先来看看传统的服务架构：
 
这个是一个典型的动静分离的服务架构，其中影片检索，用户登录等动态功能不能够缓存，需要集中的来处理；而网站的影片页面，播放页面和封面图片等可以通过来提供就近的服务。实际上早先的大部分腾讯的服务都是通过类似的方案来提供的。
如果需要增加新的独立功能，我们通常会申请一个新的域名，独立部署来进行服务，各个功能点的开发，部署，运营等工作都可以独立来进行，互不干扰。但是也有一个额外的问题，功能点多起来以后，网站的域名数增多，每个功能点都需要做运营商分布，网络优化，负载均衡和灾备等；用户访问每个功能都需要连接一个单独的域名，分别解析和建立连接。到了／的时代，这个问题变得更加严重，每个域名都需要分别部署服务，需要投入重复的运营工作，用户的访问代价也更大。
首先的问题是，动态的这一部分工作可否移到来做呢？答案是肯定的。通过来接入动态的内容，可以提供更快，更安全的服务质量，同时提供更方便，更快捷的运营能力。
链路优化
用户通过边缘节点就近接入，获得了第一跳的最佳访问质量；而后服务器通过全国的节点和跨运营商专线资源组成一个数据传输网络，在这个网内，我们可以通过智能路由算法基于实时的网络情况找到一个接入点和源站之间的最佳中转方案；的网络可以保证用户，尤其是接入状况不太好的用户获取到最佳的接入方法，例如小运营商用户和移动客户端的用户。而这部分用户才是对质量抱怨最多的用户。
由于解决了用户接入和路由的问题，源站服务器可以部署在单个运营商，甚至可以仅部署在腾讯云的网内，仅需要关心容量，不需要刻意考虑接入点分布的问题；节省运营精力的同时获取到更好的接入质量。
 
负载均衡和故障屏蔽
源站采用集群服务的情况下，由于请求全部通过来进行接入，因此可以很方便的对源站进行负载均衡控制。我们在上可以通过简单配置来实现丰富的负载均衡策略，例如轮询，服务器权重，基于用户或者地址的会话保持，等等；并且还可以进行方便的进行定制。同时单个服务器发生故障时，还可以支持自动向可用服务器进行重试，从而实现故障屏蔽的同时保持用户无感知。
 
监控和问题定位
用户接入到以后，请求都是在受控的服务器上中转，通过实时监控和日志分析，我们可以立即掌握到服务的负载，请求书，以及源站的访问延迟等信息。同时当用户访问失败的情况下，可以通过访问链定位到问题节点。我们也可以通过自定义规则把部分用户定位到单独的服务器进行访问，对于新版本的灰度发布和现网问题排查都很方便。

网络安全
当前互联网上，对于业务站点的安全攻击层出不穷。入侵问题，拒绝服务攻击等对源站的稳定服务造成了巨大的威胁。通过使用服务，可以把源站隐藏起来，因此针对业务的攻击会直接导向的网络上。对于攻击，最简单的手段最有效：比拼容量。  攻击的定义是，攻击者通过发送大量的请求超过业务的服务能力，从而使得正常用户无法访问；然而具备海量的服务能力和非常大的节点分布，目前我们遭遇到最大的攻击大约是，而我们单个业务的访问量最大已经超过了，两者不在一个数量级。通过的海量服务能力，我们可以把恶意请求过滤在门外，把真正的用户请求放进来。

协议栈加速和数据压缩
优化中间非常关键的一个环节是协议栈单边加速。过去一段时间我们对于协议栈单边加速进行了相当多的探索，也取得了相当不错的进展；不过这里单独说一下针对动态内容的部分。首先是可以单独为信令类型的重要数据在协议层面提高传输优先级，保证及时送达；另外，服务器之间的传输两端都是受控的，因此我们可以采用双边加速，进一步提高传输的质量和稳定性。同时服务器之间采取共享字典压缩，节约传输需要的带宽。
现在，站点上的静态内容，动态内容都通过来服务；能不能够结合起来一起看呢？这个就是要提到的全站加速的概念了。仍然以腾讯视频站点作为例子，我们一起来看一下新的主要架构：
 
在这个架构下，动态的内容和静态的内容域名都采用单个域名来提供服务，对于静态的内容进行缓存，同时对动态内容进行加速。用户只需要访问单一域名，建立一条连接，就可以得到完整的功能，节省了多次解析和建立连接带来的额外开销。尤其是引入了协议的情况下，多个请求可以并发的处理，相比单纯的链路加速，这里还能够进一步提高用户的性能。
后面腾讯云上对于动态加速和全站加速会有对应的产品，感兴趣的同学可以关注一下。为了应对多客户端  的挑战， 年我们在团队层面和技术栈上做了很大胆的尝试：我们把前端团队和移动端合并了，组成了客户端团队。这个团队采用同一套基于  体系的技术栈去构建 、 和  应用，可以跨端复用很多业务逻辑代码。这次变革让我们体会到了统一技术栈在开发效率、团队协作和知识共享等方面带来的提升。
实际合并的过程是年月开始的，在此之前我们做了很久的铺垫准备。整个过程分为三个阶段：
第一阶段： 
熟悉我们团队的人应该知道我们在过去两年累积了很多使用  开发大型  应用的经验。我们的  应用是一个建站平台上线了，上线了 | 简单易用・专业美观， 整个网站编辑器就是一个交互非常丰富的大型单页应用   。 以及其社区的几个核心思想：组件化、单向数据流、纯函数 、不可变数据，大大简化了构建这种大型  应用的过程。我们也想把这种开发体验通过   带到移动端开发。于是在年月份，我们进入了第二阶段。
第二阶段： 
在年月，我们开始使用   构建“上线了”  应用。这款应用可以让用户直接通过手机建立网站，管理商城订单和留言，用户不再需要电脑进行这些操作。在这个应用的开发过程中，我们把  和  可以共用的代码，包括业务逻辑和通用的工具辅助类代码从原来的   代码里抽出来，放到  目录下方便  和  复用。整个项目前后花了个月左右就把  和安卓应用写完了。 和  代码重用达到了，其中也包括不少  端也可以共用的代码。
第三阶段：跨平台开发
基于前两个阶段的铺垫，我们有了比较深厚的  开发经验，也写了很多跨平台的业务逻辑。这些业务代码只要接上不同的视图层就可以开发出在不同平台上的应用了：对于  应用，视图层就是 ，对于移动端应用就是  。两者的开发体验非常类似的，我们甚至可以让同一位开发者去开发 ， 和安卓的应用。
因此，第三阶段我们从团队结构上重新进行了分配。之前，对于每一个功能模块，在不同平台上都需要不同的开发者去完成。

而现在，我们可以根据功能模块去分配。一位全端开发者独立把 、 和安卓平台都做出来。

三个阶段总共用了两年时间。从最初听到  的工程师畅想着通过  可以开发不同平台应用到现在我们团队已经实现了这个目标，我很庆幸这是客户端工程师一个美好的时代。年，我们将基于这个团队结构和技术架构，更快速的做出新功能模块！
我司  在   做了一次关于全端团队搭建过程的分享，有兴趣的可以在这看视频
服务端架构的思考

在构建大型前端应用时，客户端和后端工程师通过  的方式进行合作， 就是双方通信的协议。现在主流的  设计范式是  ，然而在实践中，我们发现  在一些真实业务逻辑的需求下不是很适用。为此我们往往需要构建自定义  节点，而这违背了  的设计理念。
我们认为  的  是目前最接近完美的解决方法。服务端只需要定义好业务逻辑中设计的数据类型系统，客户端工程师就可以使用  自定义查询的数据及其结构，大大地提升了  的灵活性。关于  可以具体解决哪些问题，可以读一下我司  前年在  上发布的文章，在这就不仔细阐述了。
自年月推出  规范到今天，除了  之外社区里不乏有些先锋开始陆续使用起来。其中知名的包括有 ，， 和其他。 这家公司也是先锋中的其中一员。 作为一家在  应用领域一直有一些超前做法的公司，在年全力投入了大量资源打造基于  生态系统的 。 本身也投入了一整个团队把内部的旧  系统升级到对标社区规范的新系统，并发布了几个在实战中使用到的工具。
鉴于  目前在社区生态上已经比较完善了，年我们将开始使用  渐渐替换掉内部已有的  。
构建复杂的  应用
 服务端代码主要是基于    开发的。 的设计哲学是 おまかせ，它提倡和遵循“惯例重于配置”  的理念，并提供了丰富的工具链，让  开发人员非常容易上手。 的惯例大多是  开发领域多年总结下来的最佳实践，即使是新手，也能够在短时间内开发出安全，健壮的  应用，这个对于初创企业来说是非常有帮助的。
但是当应用的逻辑开始变得复杂的时候， 就开始显得力不从心了，它所提供的惯例和最佳实践没有办法再很好地指导开发人员写出具备高可维护性的代码。
要解决这问题，我们需要重新审视  在  应用开发中的定位。 只是一个  框架，它不是一个应用开发框架，不能也不应该负责  应用中领域相关的部分。我们不妨从  社区借鉴      ，引入      的概念。
在我们总结的设计模式中，一个  对象就是一个普通的  对象，它的  方法除了提供其他  对象的依赖注入， 之外不包含任何参数，对象本身也不保留任何状态。在应用中，一个  对象通过工厂类产生，工厂类负责完成依赖注入，在这个过程中，可能需要调用其他  的工厂类来产生对象。
为了解决 上线了应用中不同场景下的不同问题，我们使用了以下  类  对象：

 对象
 对象
 对象
 对象
 对象


 对象的功能是描述领域相关逻辑中的操作或过程。比如一个典型的  应用中支持用户注册、登录、登出等操作，有些应用可以支持用户付费升级和取消套餐等等，这些操作都是适合用  对象来描述的。
 对象提供了介于用户界面上的表单和  定义之间的一层封装。 本身提供了简单易用的表单，但是  的表单跟相应的  之间有非常强的耦合性，这样等于说把应用的  层实现细节直接暴露给了用户，非常不灵活。 对象替代了真正的  层来作为表单的  层，把用户输入转换成真正的  对象。
 对象和  对象相对比较简单，它们分别定义了封装权限检测逻辑和数据查询逻辑的对象。
 对象提供了介于应用内部领域相关接口和应用外部依赖接口之间的一层封装。应用内部领域相关的逻辑应该有自己固定的接口并不与外部依赖接口之间产生强耦合关系。比如  提供域名的购买和管理服务，这个服务提供了域名查询、购买、验证、续费、取消等操作，这些操作都是域名这个领域内的“标准操作”，并不依赖于我们的上级域名提供商。我们应该允许上级域名提供商修改它们的，允许切换到另一个上级域名提供商，甚至支持多个上级域名提供商。在有  这一层封装之后，我们可以做以上这些更改而不需要更改任何域名领域内的操作代码，需要修改的仅仅是  对象的代码而已。
今后随着系统的复杂性进一步增加，我们可能会使用更多的  对象类型来解决新的问题。我们相信，通过这种方式，可以有效地降低我们系统内部模块之间的耦合性，使得代码的可维护性大大增强，也更方便我们编写高效的测试代码。
关于这一部分的详细内容可以参考我们团队的资深  工程师   在    上的演讲 “   ”。
微服务架构的演进方向
 对象和依赖注入可以很大程度解决单个应用中业务复杂性造成的可维护性问题，但是应用规模、复杂度和用户数目的增加还带来了其他问题，对于这些问题，我们必须从系统整体架构上做调整来解决。
首当其冲的就是用户网站的高可用性。 建站产品的特性决定了用户会对自己的网站有较高的可用性要求，对网站的管理平台和编辑器的可用性则没有很高的要求。这就需要从系统层面做切分，对用户网站所依赖的功能提供不同于管理平台和编辑器的可用性保证  。
其次，应用中的每个模块都有自己独特的流量特性，而单一应用则决定了比较单一的技术栈和通信、数据存储等方面服务的选择。例如用户网站的流量特性就跟管理平台和编辑器的流量特性完全不一样，每个用户网站的流量特性也不一样。即使在用户网站中，不同的功能模块因为功能的区别和使用率的不同，流量特性也不完全一样。如果能够对于每个模块采用各自最适合的技术方案，就可以最大化模块的性能。
再者，单体应用导致所有大大小小的改动都必须重新部署整个代码库，而为了保证新代码的正确性，部署之前需要对整个项目的前端和后端代码进行自动化测试，整个流程持续时间很长。每个小的改动都重新部署整个代码库代价太大，而如果降低部署的频率的话又会在一定程度上影响迭代效率。
解决这些问题的有效方案是将目前的单体应用合理地拆分成为多个微服务。例如，所有用户网站相关的服务都会被拆分出来作为微服务，并且每一类网站模块所依赖的服务都会成为单独的微服务。这样可以保证用户网站整体的高可用性，可以允许因为后台维护的原因出现某个服务短时间不可用，极大地降低网站整体上服务不可用的情况的出现。在微服务架构下我们可以为不同的服务选择不同的技术方案，并且各个服务可以分开部署。由于每个服务都非常小，测试和部署需要花费的时间非常短，可以极大地提升迭代效率。向微服务架构演进是一项非常复杂的系统性工程，这也是为什么我们从几年前就开始思考引入微服务架构的可能性，但是因为当时的痛点还不大，并没有付诸实施。目前我们正在做关于微服务的元研究 ，也就是在研究为了迁移到微服务架构，有哪些具体技术方向的研究需要完成：

服务发现
通讯协议
生命周期管理
运行状况监控
日志管理
服务部署
服务设计最佳实践
服务迁移过程
数据管理和集成
本地开发

如下图所示：

这张图是目前总结下来的微服务领域我们需要研究的具体技术方向，随着实践的深入可能会添加新的内容。年我们把微服务架构作为一个主要目标，并不是在这一年中需要完成微服务架构的迁移，而是在这一年中把大方向和一些重要的细节确定下来，完成必要的技术储备，并且完成几个最重要的微服务的迁移；而整个架构的迁移完成可能会需要持续～年的时间。我们在这个领域仍然比较缺乏经验，希望能够借此机会跟领域内有丰富经验的工程师多交流，更希望能够在这一年中找到能一起在未来～年内一起完成这个大工程的人才。
可靠的基础设施
 最初是部署在  平台  上的， 负责分配和管理下层基础设施，我们只需要关注在应用本身。年我们从  迁移出来。当时我们引入了刚刚兴起的  容器技术作为应用的打包部署方案，应该说是比较前卫的，但是在基础设施的管理上，包括 ，， 的分配和设置等等，还是采用手动管理的方式，在计算资源需要伸缩的时候也是通过手动方式进行操作。这样的管理方式带来了不少问题。
首先，手动操作容易造成操作错误，尤其是在维护正在运行应用的基础设施的过程中，如果不小心关掉了某台服务器或者设置网络的时候规则设置错误，都可能造成服务中断，影响用户使用。
其次，手动操作效率比较低。我们除了生产环境之外，还有多个沙盒环境供线上测试使用。为了保证测试的有效性，这些沙盒环境都要做到尽量跟生产环境一致。对于一个运维工程师来说，手动创建完成并测试通过一个沙盒环境往往需要～天的时间，并且无法完全保证这个沙盒环境和生产环境的一致性。
再次，生产环境和沙盒环境的当前状态非常不透明，即使使用文档记录了环境创建的操作步骤和当前的状态，也很难保证文档和环境之间一直保持同步。这样我们就无法有效地了解当前的环境是否符合我们的预期，很可能会出现考虑不周全的情况。
为了解决这些问题，我们需要更有效的方式来管理我们的基础设施。
基础设施即代码  
我们选择的解决问题的方向是基础设施即代码  。所谓基础设计即代码，就是指开发和运维工程师不再使用手动方式或者过程式的脚本来分配管理基础设施，而是采用声明式的代码来定义基础设施，这里的代码既可以作为定义基础设施的文档，也可以运行来完成基础设施的配置，还可以作为自动化测试的来测试当前的基础设施配置是否符合预期。
基础设施即代码提供一种全新的方式来看待云计算时代的运维工作。传统的时代，很多运维工作需要通过手工的方式来完成，手工操作的缺点在上文已经提过了。有一些自动化意识比较强的公司和个人，会采用过程式的脚本来自动化大部分的运维工作，确实减少了手工操作带来错误的可能性以及带来了效率的提升。但是复杂的脚本同样带来了不透明的问题：你怎么确定这个脚本运行的结果是符合预期的？如何测试脚本的正确性？如何保证脚本运行的幂等性？
基础设施即代码通过声明式的配置代码解决了这些问题。这些配置定义了我们所期望的状态，而运行这些配置的过程，则是不断地检测特定的计算资源是否符合定义，如果不符合，则通过调用云平台的来操作使得该计算资源符合定义。
我们最初选择了  作为配置基础设施和自动化部署的解决方案，基于  设计和实现了一整套运维工具。这套工具帮助我们实现了两个重要的目标：

任何一个工程师都能够简单地使用这套工具来部署／回滚，而不需要了解任何底层的实现细节
可以高效地复制一套新的生产／沙盒环境而不需要太多的手动操作

第二点在我们准备在  中国区域推出“上线了”服务的时候起到了很大的作用，我们几乎一键完成了整个生产环境和几个沙盒环境的基础设施配置，并且照搬了整个应用部署／回滚的方案，节约了大量的时间。
随着系统复杂度的增加，我们渐渐发现  虽然在实现自动化部署方面很好用，但在定义和配置基础设施上并不那么方便，不能完全解决上面提到的个问题。经过研究和比较，我们选择了  作为新的基础设施配置解决方案，并使用  完全重写了所有的配置代码。现在我们可以在任何时候重复运行这些配置代码来把基础设施更新到最新定义，并且使用这些配置代码很快地创建新的沙盒环境来满足多个产品团队并行测试的需求。
容器的编排和集群管理
基础设施即代码很好地解决了基础设施的管理问题，但是并无法解决基础设施之上的服务的生命周期管理问题。在确定微服务架构的演进方向之前，我们已经做了一些分布式计算的尝试，即将一部分相对独立的模块拆分出来作为独立的服务存在。我们引入了  容器技术来管理服务的打包和部署，每个独立服务各自分配和管理自己的基础设施和计算资源。这种方案决定了系统整体的基础设施复杂度将随着服务数目的增加而线性增长。对于每个独立的服务，我们都需要单独的配置文件来定义它的基础设施，并且需要对这些基础设计进行维护和监控。同时，我们对于每个服务预留了一定流量爆发性增长的弹性空间，但不同的服务之间无法共享这些预留的弹性计算资源，也造成了一定的浪费。
未来演进到微服务架构会需要我们有能力管理更多更细粒度的服务，而目前通过管理基础设施来管理服务的方式将面临非常大的局限性。我们需要一个方案来解耦基础设施和服务之间的直接关联。
具体来说，我们不仅仅需要容器来封装服务和它的运行环境，我们更需要一个容器调度、编排和集群管理方案，可以帮助我们管理下层的基础设施和计算资源，并作为资源池的形式提供给上层的服务容器消费。服务容器并不关心下层基础设施的管理和分配，基础设施也并不随着上层服务数目的变化而变化，只要基础设施提供了足够的计算资源给上层服务使用就可以。同时，这个方案中需要包含一套命令行工具甚至  界面来让工程师更方便地创建和管理服务生命周期。简而言之，我们需要搭建一个简单易用的内部  平台。
目前容器领域内比较成熟的容器调度编排方案有以下几个：

 公司提供的  
 开源的 
 提供的  和  

这些主流的容器调度编排方案都支持  的容器标准，目前我们正在测试和评估这些不同的方案，预计在年完成  平台的设计和实现。
自动化回归测试
为了在快节奏迭代部署的同时保证产品可用性的稳定， 年我们搭建了一套完整的自动化测试方案：从单元测试、集成测试、功能回归测试到  回归测试。
我们  的流程是这样的：

单元测试和集成测试将会在   时跑。功能回归和  回归测试就需要等待代码部署到沙盒环境后才会在    环节跑。在此之前，我们在单元测试和集成测试上已经下了很大工夫了， 年重点解决的问题是搭建功能回归和  回归测试。
功能回归测试

功能回归测试我们选用了来自蚂蚁金服的一套基于  协议的测试框架  。 协议对各种设备的交互已经制定了  规范， 也严格遵守了这套协议并为 、 和  都实现了对应的驱动。这就意味着我们的  工程师只需要学习  就可以测试 ，， 的应用。
除了使用代码做自动化的功能回归测试，我们也用了  众测 方案。在这个平台上，我们的  工程师和产品团队只需要写好测试用例的步骤，平台会自动分发给有测试经验的测试人员进行手动测试。
步骤定义：

步骤定义：

 是一个小时都在运行的服务。相比于团队内部成员手动测试，这个方案平均把测试所需的时间缩短到原来的二十到三十分之一。也就是说，之前一位  团队成员需要一天才能完成的测试，使用  就可以在一小时内完成。
 回归测试
对于一款建站工具，在快速迭代的过程中，保证用户通过我们工具做出来的网站  一致也是很重要的需求。我们采用了  截图比对回归测试。在部署到沙盒环境上后，我们会做一些截图然后和上一次的截图 做比对并高亮出两图之间的差别，只要截图有偏差就会报错并通知工程师和  工程师进行排错。

在过去一年中，我们搭建了一套完整的从代码到部署的自动化流程，并完成了了一部分的功能回归测试用例。 年我们的目标是基于这套流程达到  的功能回归测试覆盖率。
总结
总结一下，我们希望在年实现以下目标：

借助一致的技术栈极大提升多客户端团队的产品开发效率，做出更多更好的产品特性
引入  重构  层，提供更丰富灵活的 
遵循  和依赖注入的思路，充分解耦后端产品代码的复杂度
向微服务方向转型，提供更高的系统可用性，优化系统的自动伸缩能力，提升开发效率
基于已有的自动化测试流程，加入更多的测试用例，使得功能回归测试达到  的覆盖率
构建基于容器编排的内部  平台，简化基础设施的管理复杂度以及应用服务的管理

 崇尚用技术解决问题，以技术驱动产品，我们坚信，一个伟大的产品背后，一定有坚实的技术基石。这些技术目标的实现离不开一个自由，创新，充满黑客精神的技术团队。希望在年有更多的小伙伴能够加入我们，一起实现这些目标。欢迎大家加入和我们一起努力：  技术团队招聘。
如果你想体验上线了，可以在腾讯云市场搜索上线了。接上篇 经典游戏服务器端架构概述。
全服分线模型
一    模型描述
由于多进程服务器模型的发展，游戏开发者们首先发现，由于游戏业务的特点，那些需要持久化的数据，一般都是玩家的存档，以及一些游戏本身需要用的，在运行期只读的数据。这对于存储进程的分布，提供了非常有利的条件。于是玩家数据可以存放于同一个集群中，可以不再和游戏服务器绑定在一起，因为登录的时候便可根据玩家的去存储集群中定位想要存取的存储进程。
图全区分线模型
二    存储的挑战
、需求：扩容和容灾
在全区分线模型下，游戏玩家可以随便选择任何一个服务器登录，自己的帐号数据都可以提取出来玩。这种显然比每个服务器重新“练”一个号要省事的多。而且这样也可以和朋友们约定去一个负载较低的服务器一起玩，而不用苦苦等待某一个特定的服务器变得空闲。然而，这些好处所需要付出的代价，是在存储层的分布式设计。这种设计有一个最需要解决的问题，就是游戏服务器系统的扩容和容灾。
 从模型上说，扩容是加入新的服务器，容灾是减掉失效的服务器。这两个操作在无状态的服务器进程上操作，都只是更新一下连接配置表，然后重启一下即可。但是，由于游戏存在大量的状态，包括运行时内存中的状态，以及持久化的存储状态，这就让扩容和容灾需要更多的处理才能成功。
 最普通的情况下，在扩容和容灾的时候，首先需要通知所有玩家下线，把内存中的状态数据写入持久化数据进程；然后根据需要的配置，把持久化数据重新“搬迁”到新的变化后的服务器上。——如果一个游戏有几千万用户，这样的数据搬迁将会耗时非常长，玩家也被迫等待很长的时间才能重新登录游戏。所以在这种模型下，对于数据存储的设计是最关键的地方。
、分区分服的关系型数据库
我们常常会使用这种关系型数据库来存放游戏数据。由于能够表述非常复杂的数据操作，这对于游戏数据的一些后期处理有非常好的支持：如客服需要发奖励，需要撤销某些错误的运营数据，需要封停某些特征的玩家……但是，分布式数据库也是最难做分布的。一般来说我们都需要通过某一主键字段做分库和分表；而另外一些如唯一关键字等数据，就需要一些技巧来处理。

图分表分库
以玩家作为分表分库是一个非常自然的选择，但是这种方案，往往需要在逻辑代码中，对玩家数据按照自定义的规则，做存储进程的选择。但是如果发现这个分表分库的算法原则不符合需求，就需要把大量的数据做搬迁。如上图是按玩家做奇偶规则分布到两个表中，一旦需要增加第三台服务器，数据存储的目的服务器编号就变成了，这样就需要把好多数据需要从原来的第一、二台数据库中拷贝出来，非常麻烦。
有的开发者会预先建立几十个表如个表=，一开始是全部都放在一个服务器上，然后在增加数据库服务器的时候，把对应的整个表搬迁出来。这样能减轻在搬迁数据的时候造成的复杂度，但还是需要搬迁数据的。最后如果与建立的表还是放不下了，依然还是需要很复杂和耗时的重新拷贝数据。
、
在很多开发者绞尽脑汁折腾的时候，横空出世了。实际上在很早，目录型存储进程就在等特定领域默默工作了。系统最大的好处正是关系型数据库最大的弱点——分布。
 由于主键只有一个，因此内置的分布功能使用起来非常简便。而且游戏玩家数据，绝大多数的操作都是根据主键来读写的。“自古以来”游戏就有“大法”之称，其本质就是对存档数据的简单读、写。在网游的早期版本游戏时代，玩家存档只是简单的放在硬盘的文件上，文件名就是玩家的。这些，都说明了游戏中的玩家数据，其读写都是有明显约束的——玩家。这和简直是天作之合。
图
的确是非常适合用来存储游戏数据。特别是有些服务器如还带有丰富的字段值类型。但是，本身往往不带很复杂的容灾热备机制，这是需要额外注意的。而且的访问延迟虽然比关系型数据库快很多，但是毕竟要经过一层网络。这对于那些发展了很多年的库来说，缺乏了一个本地缓存的功能。这就导致了还不能简单的取代掉所有服务器上的“状态”。而这些正是分布式缓存所希望达成的目标。
、分布式缓存
在业界用的比较多的缓存系统有，开发者有时候也会使用诸如这样的库提供的功能。但是这些缓存系统在使用上往往会有一些限制，最主要的限制是“无法分布式使用”，也就是说缓存系统本身成为性能瓶颈后，就没有办法扩容了。或者在容灾的情景下，缓存系统往往容易变成致命的单点。
 公司有一款叫的产品，就是一种能很好解决以上问题的“能分布式使用”的产品。他利用局域网的组播功能来做节点间的状态同步，同时采用节点互相备份的方案来分布数据。这款产品还使用接口来提供功能。这让整个缓存系统既使用简单又功能强大。更重要的是，它能让用户对于数据的存取特性做配置，从而提供用户可接受的数据风险下的更高性能——本地缓存。
 由于游戏的数据，真正变化频繁的，往往不是“关键”的需要安全保障数据，如玩家的位置、玩家在某次战斗中的、子弹怪物的位置等等。而那些非常重要的数据，如等级、装备，又变化的不频繁。这就给了开发者针对数据特性做优化以很大的空间。而且，大部分数据的读、写频率都有典型的不平衡状态。普遍游戏数据都是读多写少。少量的日志、上报数据是写多、几乎不读。
 对于缓存系统来说，有三个重要的因数决定了在游戏开发中的地位。首先是其使用的便利性，因为游戏的数据结构变化非常频繁，如果要很繁琐的配置数据结构，则不会适合游戏开发；其次是要能提供近似本地内存的性能，由于游戏服务器逻辑基本上都是在频繁的读写某一特定数据块，如玩家位置、经验、等等，而且游戏对于处理延迟也有较高的需求应用在秒以内都可以忍受，游戏则要求最好能在以内完成。要能同时满足这两点，是不太容易的。
 图分布式缓存
、集成缓存的
根据上面的描述，读者应该也会想到，如果数据库系统，或者叫持久化系统，自带了缓存，是否更好呢？这样确实是会更好的，而且特别是对于系统来说，能以一些内部的算法策略，来降低前端逻辑开发的复杂程度。一般来说，我们需要对集成缓存的系统有以下几方面的需求：首先是冷热数据自动交换，就是对于常用数据有算法来判别其冷热，然后换入到内存以提高存取性；其次是分布式扩容和容灾功能，由于是可以知道数据的主关键字的，所以自然就可以自动的去划分数据所在的分段，从而可以自动化的寻找到目标存储位置来做操作；最后是数据导出功能，由于支持的查询索引只能是主键，对于很多后台游戏操作来说是不够的，所以一定要能够到处到传统的服务器上去。
在这方面，有很多产品都做过一定的尝试，比如在或者上做插件修改，或者以系统封装以试图构造这种系统等等。
图集成缓存的
三    跳线和开房间
、开房间型游戏模型
在全区分线服务器模型中，最早出现在开房间类型的游戏中。因为海量玩家需要临时聚合到一个个小的在线服务单元上互动。比如一起下棋、打牌等。这类游戏玩法和有很大的不同，在于其在线广播单元的不确定性和广播数量很小。
这一类游戏最重要的是其“游戏大厅”的承载量，每个“游戏房间”受逻辑所限，需要维持和广播的玩家数据是有限的，但是“游戏大厅”需要维持相当高的在线用户数，所以一般来说，这种游戏还是需要做“分服”的。典型的游戏就是《英雄联盟》《穿越火线》这一类游戏了。而“游戏大厅”里面最有挑战性的任务，就是“自动匹配”玩家进入一个“游戏房间”，这需要对所有在线玩家做搜索和过滤。
图开房间型游戏
这类游戏服务器，玩家先登录“大厅服务器”，然后选择组队游戏的功能，服务器会通知参与的所有游戏客户端，新开一条连接到房间服务器上，这样所有参与的用户就能在房间服务器里进行游戏交互了。
由于“大厅服务器”只负责“组队”，所以其承载力会比具体的房间服务器更高一些，但这里仍然会是性能瓶颈。所以一般我们需要尽量减少大厅服务器的功能，比如把登录功能单独列出来、把玩家的购买物品商城功能也单独出来等等。最后，我们也可以直接想办法把“组队”功能也按组队逻辑做一定划分，比如不同的组队玩法、副本类型、组队用户等级等等。
虽然这种模型已经可以对很多游戏做很好的承载了，但是在大厅服务器这里依然无法做到平行扩展，原因是玩家的在线数据比较难分布到不同的服务进程上去，而且还带有大量复杂的数据查询逻辑。
、专用聊天服务器
不管是还是开房间类游戏，聊天一直都是网络游戏中一个重要的功能。而这个功能在“在线人数”很多，“聊天频道”很多的情况下，会给性能带来非常大的挑战。在很多类型的页游和少部分手机游戏里面，在线聊天甚至是唯一的“带公共状态”的服务。
 聊天服务处理点对点的聊天，还有群聊。用户可能会添加好友、建立好友群组等各种功能。这些功能，都是和一般的游戏逻辑有一定差别的功能。这些功能往往并不是非常容易实现。很多游戏都期望建立类似腾讯的游戏聊天功能，但是是一整个公司在做开发，要用仅仅一个游戏团队做成这么完整的功能，是有一定困难的。
因此游戏开发者们常常会专门的针对聊天功能来开发一系列的服务进程，以便能让游戏的聊天功能独立出来，做到负载分流和代码重用的逻辑。很多网游系统，其聊天系统从客户端来说就是和主游戏进程分开的。
聊天服务器的本质是对客户端数据做广播，从而让玩家可以交互，所以有很多游戏开发者也直接拿聊天服务器来做棋牌游戏的房间服务器，或者反过来用。由于在游戏“分服”里面单独部署了聊天服务器，这类服务器也往往被用来承担做“跨服玩法”的进程。比如跨服团队战、跨服副本等等。不管这些服务器最终叫什么名字，实际上他们承担的主要功能还是广播，而且是运行玩家“二次登录”的广播服务器。以至于后来，有部分游戏直接全部都用聊天服务器来代替原始的“游戏服务器”，这样还能实现一个叫“跳线”的功能，也就是玩家从一个“在线环境”跳到另外一个“在线环境”去。——这些都是对于“广播”功能的灵活运用。
图专用聊天服务器
全服全线模型
尽管分服的游戏模型已经运营了很多年，但是有一些游戏运营商还是希望能让尽量多的玩家一起玩。因为网游的人气越活跃，产生的交互越多，游戏的乐趣也可能越多。这一点最突出表现在棋牌类网游上。如联众、游戏这类产品，无不是希望更多玩家能同时在线接入一个“大”服务器，从而找到可以一起玩的伙伴。在手游时代，由于手机本身在线时间不稳定，所以想要和朋友一起玩本来就比较困难，如果再以“服务器”划分区域，交互的乐趣就更少了，所以同样也呼唤这一个“大”服务器，能容纳下所有此款游戏的玩家。因此，开发者们在以前积累的分服模型和分线模型基础上，开发出满足海量在线互动需求的一系列游戏服务器模型——全服全线模型。
图全服全线模型
一    服务进程的组织

静态配置

全服全线模型的本质是一个各种不同功能进程组成的分布式系统，因此这些进程间的关系是在运维部署期间必须关注的信息。最简单的处理方法，就是预先规划出具体的进程数量、以及进程部署的物理位置，然后通过一套配置文件来描述这个规划的内容。对于每个进程，需要配置列明每个进程的文件位置；内部通讯用的地址，如端口或者消息队列；启动和停止脚本路径；日志路径等等……由于有了一套这样的配置文件，我们还可以编写工具对所有的这些进程进行监控和操作批量启停。图静态配置
虽然我们可以以静态配置为基础做很丰富的管理工具，但是这种做法还是有可以改进的空间：每次扩容、更换故障服务器或者搬迁服务器这在运营中很常见，我们都必须手工修改静态配置数据，由于是人工操作，就总会产生很多错误，根据个人经验，游戏运营事故中的以上，是跟运维操作有关；由于整个分布式系统被切分成大量的进程，对于新进入此项目的程序员来说，要完整的理解这个系统，需要在思想上跨越层层阻隔：每个进程的功能、它们部署的关联、每个进程间的协议报的含义、每个业务流程具体的跨进程过程……这要花费很多时间才能搞明白的。而且大部分游戏的这种架构并不统一，每个游戏都可能需要重新理解一次，知识无法重用；在开发测试上，由于分布式系统的复杂性，要多搭几个开发、测试环境也是很费时间的，以至于这项工作甚至要安排专人来负责，这对于小型游戏开发团队来说几乎是不可承担的成本。因此我们还需要一些更加自动化，更加容易理解的全服全线游戏服务器模型。

基于中心点的动态组织

架构模式是业界一个比较经典的分布式软件架构模式，这个架构的特点是能动态的组织一个非常复杂的分布式服务系统。这个系统可以包含提供各种各样供的服务程序，而这些服务程序都以同一个标准接口来使用，并且服务自己会注册自己到集群中，以便请求方能找到自己。这种架构使用 来作为服务接口标准，通过发布来提供接口，这极大的降低了开发者对这些服务的使用成本。在游戏领域，服务器端提供的功能程序，实际上也是非常多样的，如果要构建一个分布式的系统，在这个方面是非常适合架构的思想的；然而，游戏却很少使用协议及其之上的 做通讯层，因为这个协议性能太低。不过，类似的，基于中心节点的动态组织的服务管理思路，却依然适用。图基于中心点的动态组织
一般来说我们会使用一组目录服务器来充当“中心点”，代表整个集群。开源产品中最好的产品就是了。当然也有一些开发者自己编写这样的目录服务器。由于每个服务进程会自己上报负载和状态，所以每个进程只需要配置自己提供的服务即可：服务名字、服务接口。对于请求方来说，一般都可以预先编写目标服务接口的类库，用来编程，有些项目还使用功能，使用语言配置直接生成这些接口类库。当需要请求的时候，执行“名字查找”“路由选择”“发起请求”就可以完成整个过程。由于有“查找”“路由”的过程，所以如果目标服务故障、或者新增了服务提供者，请求方就能自动获得这些信息，从而达到自动动态扩容或容灾的效果，这些都是无需专门去做配置的。

服务化与云尽管动态组织的架构有如此多优点，但是开发者还是需要自己部署和维护中心节点。对于一些常用的服务，如网络代理服务、数据存储服务，用户还是要自己去安装，以及想办法接入到这套体系中去。这对于开发、测试还是有一定的运维工作压力的。于是一些开发团队就把这类工作集中起来，预先部署一套大的集群中心系统，所有开发者都直接使用，而不是自己去安装部署，这就成为了服务化，或者云服务。

图服务化、云
使用专人维护的服务化集群确实是一个轻松愉快的过程。但是游戏开发和运营过程中，往往需要多套环境，如各个不同版本的测试环境、给不同运营平台搭建的环境、海外运营的环境等等……这些环境会大大增加维护服务化集群的工作量，对于解决这个问题，建立高度自动化运维的私有云，成为一个需要解决的问题放上了桌面。提高集群的运维效率，降低工作复杂程度，需要一些特别的技术，而虚拟化技术正式解决这些问题的最新突破。
二    提高开发效率所用的结构
、使用提高网络接口编写效率
在分布式系统中，如果所有的接口都需要自己定义数据协议报来做交互，这个网络编程的工作量将会非常的大，因为对于一个普通的通信接口来说，至少包括了：一个请求包结构、一个响应包结构、四段代码，包括请求响应包的编码和解码、一个接收数据做分发的代码分支、一个发送回应的调用。由于分布式的游戏服务器进程非常多，一个类似登录这样的操作，可能需要历经三、四个进程的合作处理，这就导致了接近十个数据结构的定义和无数段类似的代码。而这些代码，如果在单进程的环境下，仅仅只是三、四个函数定义而已。
因此很多开发者投入很大精力，让网络通信的编写过程，尽量简化成类似函数的编写一样。这就是前文所述的远程调用的方法。在全区全线的游戏中，如果是比较重度的游戏，采用方式做开发，会大大降低开发的复杂程度。当然也有一些比较轻度的游戏，还是采用传统的协议包编解码、分发逻辑调用的做法。
、简化数据处理
在分布式系统中，对于避免单点、容灾、扩容中最复杂的问题，就是在内存中的数据。由于内存中有游戏业务的数据，所以一般我们不敢随便停止进程，也难以把一个进程的服务替换为另外一个进程。然而，游戏数据对比其他业务，还是非常有特点的：

写入越不频繁的数据，价值越高。比如过关、升级、获得重要装备。
大量数据都是读非常频繁，而写非常不频繁的，如玩家的等级、经验。
大量写入频繁的数据，实际上是不太重要，可以有一定损失，比如玩家位置，在某个关卡内的等……
因此，只要我们能按数据的特性，对游戏中需要处理的数据做一定分类，就能很好的解决分布式中的这些问题。
首先我们要对数据的分布做规划，一般来说采用按玩家做分布，这样能让服务进程中内存的数据缓存高度命中。常用的手法有用一致性哈希来选择路由，调用相关的服务进程。
其次对于读频繁而写不频繁的数据，我们采用读缓存而写不缓存的策略。每个服务进程都保留其读缓存数据，如果需要扩容和容灾，仅仅需要修改服务访问的路由即可。
再次对于读不频繁而写频繁的数据，我们采用写缓存和读不缓存的策略。由于这些数据丢失掉一些是不要紧的，所以容灾处理就直接忽略即可，对于扩容，只需要对所有服务进程都做一次回写即可。
最后，有一些数据是读和写都频繁的数据，比如玩家位置，这类，我们采用读写都缓存，由于数据重要性不高，只要我们多分几个服务进程即可降低故障时影响的范围；在扩容的时候调用全节点清理读缓存和回写脏数据即可。

在和持久化设备打交道的时候，传统的类库往往能帮我们把数据存入关系型数据库，然而，使用一个自带数据热备的也是很好的选择。因为这样能节省大量的分库分表逻辑代码。
、自动化部署集群环境
最新的虚拟化技术给分布式系统提供能更好的部署手段，以为标志的虚拟化平台，可以很好的提高服务化集群的管理。我们可以把每个服务进程打包成一个映像文件，放入虚拟机中运行，也可以把一组互相关联的服务进程打包运行。这些环境问题都由处理了。
但是，我们同时需要注意的是，如果我们的进程的资源是静态分配的前文提到，在的虚拟机中可能因为内存不足等原因直接无法启动。这就需要我们把完全静态分配资源的程序，修改为有资源限制，但是动态分配的程序。这样我们才能在任何可以部署的机器上部署我们的游戏服务器。
三    分布式难点：状态同步
、分布式接入层
一般来说，我们全线服务器系统碰到的第一个问题，就是大量并发的网络请求。特别是大量玩家都在一起交互，产生了大量由于状态同步而需要广播的数据包。这些网络请求的处理，显然应该独立出来成为单独的进程。同时这些网络接入进程，还应该是一个集群中的成员。这就诞生了分布式接入服务层。
 这些网路接入进程的第一个功能，就是把并发的连接，代理成为后端一个串行的连接，这可以让后端服务进程的处理逻辑更简单，而且网络处理消耗变得更小。
 其次，网络接入进程需要支持广播功能。如果只是普通的广播实现，很多人会需要拷贝很多次需要广播的内容，然后挨个对做发送。这其实是一个消耗很高的操作。而单独的网络接入进程，可以善用“零拷贝”等技术，大大降低广播的性能开销。而且还可以通过多个进程一起做广播操作，以达到更大的在线同步区域。
 最后，网络接入进程需要支持一些额外的有用功能，包括通讯的加密、压缩、流量控制、过载保护等等。有些团队还把用户的登录鉴权也加入网络接入功能中。
图分布式接入层
、使用
网络状态同步产生的广播请求中，绝大多数都是客户端之间的网络状态，因此我们在可以使用的客户端之间，直接建立的数据连接，会比通过服务器转发降低非常多的负载。在一些如赛车、音乐、武打类型的著名游戏中，都有使用技术。而接入进程天然的就是一个撮合服务器。
 有些游戏为了进一步降低延迟，还对所有的玩家状态，只同步输入动作，以及死亡、技能等重要状态，让怪物和一般状态通过计算获得，这样就更能节省玩家的带宽，提高及时性。加上一些动作预测技术，在客户端上能表现的非常流畅。
展望
一    可重用的游戏业务模版
游戏服务端的各种架构中，以前往往比较关注那些非功能性的需求：容灾性、扩容、承载量，延迟。而在现在手游时代，开发效率越来越重要，有些团队甚至不设专门的服务器端程序员。因此游戏服务端架构应该更多的关注业务开发的效率。
现代游戏中，只要是带元素的，角色系统、物品系统、技能系统、任务系统就都会具备，而且都有一批比较稳定的核心逻辑。只要是能在线交互的，就有好友系统、邮件系统、聊天系统、公会系统等。另外商城系统、活动系统、公告系统更是每个游戏都似乎要重复发明的轮子。
游戏的后端应用也有很多可重用的部分，比如客服系统、数据统计平台、官网数据接口等等。这些在游戏服务端框架中往往是最后再添加进去的。
如果把以上的问题都统一考虑起来，我们实际上是可以在一个稳定的底层架构上，构造出一整套常用的游戏业务逻辑模板，用来减少游戏领域的业务代码开发。所以这样一套可以运行各种业务逻辑模版的底层架构，正是游戏服务端架构发展的方向。
二    动态资源调度的云
现在有的团队已经在搭建自己的云，这可以让游戏服务器在虚拟云上动态的生长，从而达到真正的动态扩容和动态容灾。加上如果游戏服务器不再是一个个服务进程，而是真正意义上的一个个服务，可以动态的加入或者离开云环境，那么这就是一个游戏领域的系统。我热切的希望能看到，可以用一套，开发或重用那些成型的业务模版，然后动态注册到服务云中就能运行，这样一种游戏服务器架构。

相关推荐经典游戏服务器端架构概述 浅析海量用户的分布式系统设计【腾讯云的种玩法】如何利用腾讯云搭建分布式应用导语
是一款高效的数据库，本文主要是对中淘汰数据的机制进行一个简单的介绍。在中淘汰数据有俩种，一种是过期淘汰，另外一种是基于淘汰算法的数据淘汰。
因为最近项目需要，打算实现一个简单的算法缓存，来用作服务器中缓存最新访问的图片。初期想造轮子的时候感觉还是挺简单的，但是后来细想发现需要考虑的东西还是很多的：

多线程访问

淘汰时机

淘汰机制


不知如何实现，那就看已有轮子是如何造的，所以抽时间看了一下中。下面就给一个简单的记录。在讲解的缓存淘汰之前，先简单提一下的事件库—。
事件库
一个非常小巧而又精巧的事件库，它可以处理文件、定时俩种事件。细节和原理就不说了，发现上有很多介绍的。
事件库是在函数的最后进入，当然在进入事件库之前很多初始化工作已经做好。比如读取配置文件、创建定时事件、创建文件事件、初始化系统等。进入事件库即调用方法之后，就在该方法中一直循环处理各种事件，直到退出。在方法中可以看到每次循环会首先执行方法，然后调用处理定时事件和文件事件。
如下代码：
     
{
    
       
    
    
    
     
}

   
{ 
     =  
      
    { 
           =  
               
           __ 
     } 
}
过期淘汰入口
如上代码所示，每次循环都会调用，该方法会执行下面几个操作

触发淘汰过期数据

处理一些和客户端相应的操作

处理


淘汰过期数据的触发除此之外还在定时事件中会被触发，定时事件的回调方法。该方法会被定期调用，主要执行了以下几个操作

触发淘汰过期数据

 数据库

数据库


俩个入口都会调用同样一个方法 ，根据来决定是快速执行还是慢速执行淘汰。在方法中是快速的执行淘汰数据，而在是慢速执行。快速简单理解就是需要快速执行完还要考虑上次执行的情况，来决定方法是否要直接返回。
淘汰入口
会在每次执行命令的时候进行检查，当发现超过了最大可用内存的时候就会执行释放内存的操作。

下一篇文章《 缓存淘汰机制  淘汰》就对过期淘汰数据和基于的淘汰机制进行详细的介绍。背景
 数据库作为数据持久化的存储系统，在实际业务中应用广泛。在应用也经常会因为  遇到各种各样的瓶颈。最常用的  引擎是 ，索引类型是  索引，增删改查等操作最经常遇到的问题是“查”，查询又以索引为重点没索引不是病，慢起来太要命。踩过  优惠券、摇一摇周边两个业务的一些坑，当谈到  优化时，想分享下 下  索引的一些理解与实践。
接下来的内容，安排如下：

介绍索引的工作原理

引用实例具体介绍索引

如何使用  排查线上问题

实际碰到的问题汇总


索引如何工作
当查询时， 的查询优化器会使用统计数据预估使用各个索引的代价，与不使用索引的代价比较。 会选择代价最低的方式执行查询。 如何使用索引，可以用下面的伪代码来说明：
_ = _

__ = 

  _

       _

        _ = 

        _  _

            _ = _

            __ = 
_：不使用索引时的代价
_：查询表上所有的索引 ：基本是由“估计需要扫描的行数”来确定
_：查询  中的  子句
大致的意思： 会遍历该查询相关的表的每一条索引，然后判断该索引能否被本次查询使用_。当索引可以使用时， 预估使用该索引进行查询的  ，然后选择预估代价最低的代价的方式执行查询。
索引匹配
怎样判断索引是否匹配查询？
、索引的左前缀规则；索引中的列由左向右逐一匹配，如果中间某一列不能使用索引则后序列不在查询中不再被使用。
例如，如果有一个列索引_，其中_为字符串，则对_、_和_上的查询进行了索引。
如果列不构成索引最左面的前缀， 不能使用索引。假定有下面显示的  语句。
   _  _=

   _  _=  =

   _  =

   _  =  =
如果_，，有一个索引，只有前个查询使用索引。第个和第个查询确实包括索引的列，但和，不是，，的最左边的前缀。
、 语句中列的表达式为 = 、  、 = 、 、= 、 、 或者  ’  ’其中’  ’不以通配符开始
、每个  组作为表达式匹配索引。
   _  _=   =  =
因为_= =作为一组，不匹配索引中的列，所以查询不匹配索引。
、如果表达式中存在类型转换或者列上有复杂函数则与该列不匹配索引中的列。
   _  _=

   _  _ = ‘’
第个查询，因为是整数、_是字符串，所以不匹配索引；第个查询_有复杂函数，同样不匹配索引。
索引的
 如何计算索引的 ？
索引的  基本是由“估计需要扫描的行数”来确定。数据来源于_，在  启动的时候读入内存，运行时只使用内存值，存储引擎会动态更新这些值。
我们可以通过  看下“估计需要扫描的函数”，可以通过_查询适用每一条  的具体的  值。 也是线上排查问题的利器，后面会重点介绍。
索引实例分析
索引的字段究竟是怎么从  语句中提取，并被  使用呢，下面将以一个实例分析这个过程。内容全文为摘取何登成的文章《  中的  条件，在数据库中提取与应用浅析》，并做了部分删改。
我们创建一张测试表，一个索引索引，然后插入几条记录。注意：下面的实例，使用的表的结构不是  引擎所采用的聚簇索引表。图例仅为说明，原理适用  
              

  __    

    ’’
    ’’
    ’’
    ’’
    ’’
    ’’
    ’’
    ’’
表的存储结构如下图所示只画出了__索引与  表结构，没有包括  表的主键索引：

简单说明上图，__索引上有三个字段，不包括字段。__索引，首先按照字段排序，字段相同，则按照字段排序，以此类推。 
考虑以下  ：
      =            =    = ‘’
可以发现条件使用到了四个字段，而  表的__索引，恰好使用了这三个字段，那么走__索引进行条件过滤，应该是一个不错的选择。
所有的条件，均可归纳为大类：      ， ， 。
接下来，让我们来详细分析者大类分别是如何定义，以及如何提取的。
、 
用于确定  查询在索引中的连续范围起始范围结束范围的查询条件，被称之为  。由于一个范围，至少包含一个起始与一个终止，  也被拆分为    和    ，分别用于定位索引查找的起始，以及索引查询的终止条件。

  

提取规则：从索引的第一个键值开始，检查其在条件中是否存在，若存在并且条件是= 、= ，则将对应的条件加入   之中，继续读取索引的下一个键值，使用同样的提取规则；若存在并且条件是，则将对应的条件加入   中，同时终止  的提取；若不存在，同样终止    的提取。
针对上面的，应用这个提取规则，提取出来的    为 =    。由于  的条件为 ，提取结束，不包括。

  

提取规则：从索引的第一个键值开始，检查其在  条件中是否存在，若存在并且条件是=、=，则将对应条件加入到  中，继续提取索引的下一个键值，使用同样的提取规则；若存在并且条件是  ，则将条件加入到  中，同时终止提取；若不存在，同样终止    的提取。
针对上面的，应用这个提取规则，提取出来的    为  ，由于是  符号，因此提取之后结束。
、 
在完成   的提取之后，我们根据  条件固定了索引的查询范围，但是此范围中的项，并不都是满足查询条件的项。在上面的  用例中，，均属于范围中，但是又均不满足  的查询条件。
  的提取规则：同样从索引列的第一列开始，检查其在  条件中是否存在：若存在并且  条件仅为 =，则跳过第一列继续检查索引下一列，下一索引列采取与索引第一列同样的提取规则；若  条件为 =、、、= 其中的几种，则跳过索引第一列，将其余  条件中索引相关列全部加入到 之中；若索引第一列的条件包含 =、=、、、= 之外的条件，则将此条件以及其余  条件中索引相关列全部加入到   之中；若第一列不包含查询条件，则将所有索引相关条件均加入到   之中。
针对上面的用例 ，索引第一列只包含 =、 两个条件，因此第一列可跳过，将余下的、两列加入到   中。因此获得的   为      =  。
、 
  是最简单，最易懂，也是提取最为方便的。提取规则：所有不属于索引列的查询条件，均归为   之中。
同样，针对上面的用例 ，  就为  = ‘’。
根据以上实例其实可以总结出一些规律， 语句究竟怎样是否匹配索引，不用迷信出自他人之口的规则。只需要简单的按照索引自左向右的每一列，从  语句提取条件，能否从索引树的根节点出发，到达索引树的叶节点，成功匹配出一个或几个范围区间，即能自己自行判断是否能使用索引。反过来，最左前缀匹配、 不能以通配符开始、 分组，也都是由  本身特性决定的。
索引问题排查
前面我们谈使用索引的  的值提到过。下面介绍  的值，并以一个实际遇到的问题说明如何排查问题。
详解
使用一个示例  来解释  ：
   ____    =    =    _ =   

___  是表____的其中一条索引。_均为类型。
我们着重关注几个重点字段的重点值：
 索引的使用方式
  _      …  索引关联匹配若干行
             …  索引前缀匹配   
            …  索引范围扫、、=、得到数据
           …  索引全扫描
               …  表全扫描
示例中使用的索引是使用全索引范围扫描，所以为
 _：适用查询的索引列表。示例中有三条索引适用本次查询。
  查询实际执行使用的索引。示例使用的为__
 _：查询使用索引的长度。
     字节
     字节
       字节
     字节
     字节
    字节
    字节
   变长字段且允许  ：===变长字段
   固定字段且允许  ：===
以上是常用类型的长度，示例中_为，即：字节 _  字节 _ 允许为  字节  字节  允许为  。所以本次查询是使用了索引的所有字段加速查询
 ：查询预估扫描的行数
跟进问题
摇一摇周边后台的数据统计接口尔会有小尖峰，涉及了一条 ：
一条搞定卡方检验计算   ____    =    =    _ =    _ =    ；表____ 的主要字段信息如下：
  
_   
_ 
索引为：_____
结果如下

观察以上结果可以看到一切正常，“符合预期”的走了索引。但是稍微多了点，但是看起来也“好像”。但是问题就是出现尖峰。
问题排查：
首先，注意到的一点就是  中的  异常，是  。按照上面的解释，如果走了索引那应该是  类型才对啊。
其次，观察_，，发现确实有些不对，怎么会这么小。按照类型所占字节，刚好为_的长度，确定这条 虽然走了索引，但是只使用了 _ 字段。原因呢？
然后执行“ ____”，查看表结构的索引字段，突然发现_的类型怎么是 ，再看中_=。突然意识到了什么，此时刚好违反索引匹配的第四条规则。更改“_=”为“_=‘’”验证，如下

可以看到=、_=，符合预期。接下来要做的就是更改表中_的类型为 。隔天再看接口的尖峰果然削平。
 是一个很好的工具，可以用来验证  是否使用了索引，更重要的是验证  是否如预期的使用索引上。排查线上问题还有  和 _，由于实际没有太多用到暂且不表。
常见问题汇总
 怎么使用索引？
   详见上文
  使用索引吗？
该问题可以由以下资料解释：
       ’                                       总之一句话：索引本身并不能避免排序，当根据索引取出的数据已经满足 子句的要求就可以避免排序操作。
  太慢？
  避免数据排序，采用索引排序分页查询文艺写法
`  太慢？
 避免大，使用语句过滤更多的行。更多参考的实践《     》
 为什么不走索引索引也走了，还是慢？
类型是否一致   、 字符集是否一致：涉及表关联时，两表字符集是否一致。

相关推荐一条搞定卡方检验计算一条搞定信息增益的计算内核深度优化背景
很多人一说网关，都是从微服务架构开始说起，说其是现在微服务架构中必备的一个标配组件，其实在微服务概念流行之前，网关的就已经诞生了，如银行、证劵等领域常见的前置机系统，解决访问认证、报文转换、访问统计等；而我今天的切入点是从的应用的兴起。

随着移动应用的风靡，应用程序开发人员需要简单地访问后端功能和数据；将后台的功能具体化有助于与系统交互。对一个企业， 的地位从‘最好能够具有‘转变为’必须具备‘，也已成为了主流。
那开发人员眼有中的是什么样子的？ 
前端和后端真正的分离前端专注于页面展示的开发，通过约定好的和后端交互，以及对结果的处理逻辑；后端专注于各类实现，返回指定类型的数据等，这样前端和后端可以作为独立的项目进行并行的开发，由于更加专注和独立，所以对于代码质量和开发效率都是有很大好处的； 
为多平台提供服务基于的应用，由于独立性，对服务的对象没有要求，可以是项目，可以是移动，可以是其他别的系统等等，这些终端通过调用进行数据交互和数据处理，所以适用性更广。
  
图    应用
那再回来聊的主题网关
它的作用在于提供统一的入口来访问内部的 隔离外部访问与内部系统。集成了非业务性的功能如安全检查、频次限制、监控、日志上报等，生命期管理、请求的转发、合成、协议转换、服务发现等多种功能。从图就可以看出网关功能以及在业务所处的位置。

图   网关业务应用示意图   
网关需要考虑的因素

性能问题 

作为流量入口，所有请求经由网关，对请求进行检查及决策，通过验证后进行反向代理转发到后端的进行处理，可想而知，这对性能的要求是特别高的，尤其针对互联网中海量的用户要与后端交互，如果不能保证性能，就只能通过堆机器来水平扩容，无疑会加大投入的设备成本；像目前业务已有不少高性能的方案，如有在上，基于框架 的 、构建在事件循环，回调机制的 、有基于事件驱动型、协程的  、也有基于件驱动型、协程的 。
高可用
网关不可用将会是致命的影响，要通过冗余部署、自愈、多维度监控告警，确保网关小时的稳定运行；
扩展性 
网关是业务性比较强的一个组件，如报文的转换、认证、验证等 所以它提供了一个脚本架，业务可以自行去扩展及变动；
服务发现 
后端服务的存在很大的变动性，尤其是微服务化后应用基于对获取服务的位置提出了挑战，大家可能会提公司的这个确实可以解决部分场景的服务发现，但如果是后端是在中，变动性比较大，解决不了，这就要启用集群的服务发现了。
缓存处理 
可用来缓存变化频率不大及大部分用户看到的共同数据，同时也可以用来处理后端故障迟迟无数据返回时将缓存数据返回，保障用户的体验。
服务调用 
支持进程间同步及异步的通信模块，可根据后端情况支持所需要的通信机制。 
业界常用的网关方案对比

图   业界已有方案对比 
这里看一个示例，通过对其内部实现进行分析，来看看其是如何实现网关的功能 
是基于 而是寄生在上， 性能极高， 先天的事件驱动型设计、全异步的网络  处理机制、极少的进程间切换以及许多优化设计，都使得  天生善于处理高并发压力下的互联网请求。 的稳定性也在各大网站得到验证。官方提供的常用模块都非常稳定，每个  进程相对独立， 进程在  个  进程出错时可以快速“拉起”新的  子进程提供服务。支持热部署，可以不停机更新配置文件、更新日志文件、更新服务器程序版本。 
而复用了的诸多特性，同时暴露了处理的各个阶段的钩子，业务可以灵活的在各阶段去挂载自己的业务，如下图所示，将各个功能插件巧妙的挂载到的各个执行阶段，如可在阶段做身份验证、安全、流量控制等，在阶段，转发流量做反向代理等等。 
在规则增、修、删上这些方案大都提供接口来实现，可通过 来实现规则的变换，为便捷操作这块大部分方案都配套有管理操作界面，可直接在上面进行操作，其原理也是通过模拟发送来实现。 

图  内部实现
而的流量刷选则是通过对相关参数进行正则匹配来实现，规则可以重叠生效，图显示的就是的内部流量刷选规则。

图  流量刷选规则
网关的优点：

给服务加一层安全保护可在这一层做注入、攻击防范等层面的安全保护；
对外提供统一的通信协议，如或  屏蔽内部的通信协议系统内部可采用自身熟悉的通信协议，如 或等；
降低代码耦合度、降低开发成本将非业务性功能如访问控制黑白名单、频次限制等集中在网关层处理，开发只需关注自己本业务的需求实现即可，降低了开发成本；
可灵活灰度及新功能测试通过细粒度的流量识别，进而反向代理，业务可灵活灰度及测试；
服务发现随着后端变动甚至云化对服务发现提出了新挑战，通过在网关实现服务发现可以简化客户端的实现。
减少客户端与后台的交互随着微服务化更加细粒度，这势必会加大客户端对后台的访问次数，如做一些返回数据合并，让客户端通过一次请求在网关处合并需要的数据一次性返回等，但这一块业务性太强，像业界的方案很少有做一块的，大部分实现是在网关后端加了一个  来做数据的整合；
对进行管理；

缺点：
得开发、部署、维护一个开可用的网关组件；
总结：
不管是由于的普及，还是作为微服务架构中的一员，实现网关是很重要的。在具备对请求做决策判断后的转发、协议转换、路由等基本功能外还需要有良好可扩展性。在功能实现时要尽可能的跟业务层解耦。作为一个高可用、伸缩性强的组件，优缺点并存，但相对其带来的功能这些缺点是可以容忍的。前言
 ——一种为现代多平台应用而诞生的静态编程语言

 是由  开发的一个基于 虚拟机 的新的编程语言。
文件可以编译成的字节码，也可以编译成，这样就很方便那些没有安装的设备运行。
兼容，相比于而言，它有很多优点，待会笔者会就几个写一下，并给出实际例子。
文件以作为拓展名，这是的官方参考文档。
在这笔者顺便打个广告
广告内容
腾讯课堂《跟鹅厂老司机学新技术》系列课程第一课 “遇见” 将于今晚点半开始啦
本期的主题为如何学习和分享一些学习过程的小技巧 ，欢迎各位开发者和小伙伴们前来围观哦
笔者是已经准备好凳子了的 
这是课程地址，还没报名的小伙伴们赶紧了！
广告结束。好了，现在开始正文
优点 与语言的互通性
与互通，不通你打死我
你可以用继续你的项目
所有你熟悉的框架仍可用。
任何框架，不管是  写的，还是你写的都可以。

调用
文件：
   {

      

       {
         = 
    }

       {
             
    }

       {
         
    }

        {
         = 
    }

           {
         
    }
}

文件
  = 


``    说明： 在里是关键字，所以用``符号括起来
调用
文件
    {
      {
             
    }
}

文件：
  =  

优点 与语言的相似
这里可以看官方的文档

  {

       = 
       = 

      {
          = 
         
    }

          {
           
    }

         =       

}
在这里可以看到，的每行代码结尾是可以不加“；”的，加了也没问题
优点 对字符串的操作
这里拿对字符串的插值来说

  = 
  = 
      {  }  输出结果：      
在这里来说，相当于有一个比中的字符串格式化函数更加优秀的字符串函数
优点 类型判断与自动转换
会根据代码逻辑对变量的类型进行推断还会进行自动的类型转换自动类型转换提高了代码的可读性，因为没有自动转换的话，需要人工进行转换，还会有很多进行检查
这里是官方文档

  =                           
  =                               

   =                   明确声明为型
   =     明确声明为字符串型

    {
           不确定是否为型
}
优点 直观的相等比较
在中不像调用函数那么麻烦。它可以直接对字符串进行比较

  = 
  = 
 ==         结构相等
 ===       参照相等
参照相等 ===： 就是判断 是否为同一对象。也可以使用内联函数 判断参照相等。
结构相等 ==：  判断的。 的值是不是一样的，相当于。
优点 默认参数 和 命名参数
不再使用不同的参数来定义类似的构造器：
结合默认参数值，命名参数可以消除  的使用 

     =    =  {
      
}

  
 =   =   =   
 =   =   = 
优点 
 替换成了  ，代码更具可读性：

  {
        
        
           
               
          
}
下面的既可为表达式，也可用作语句，也可作用于：
   =  {
     ==   
        
       
}
优点 属性的和
直接在属性后面就可以生成和

  {
       = 
       = 

      
         =         
}
优点 类
类这是一个   简单的对象，其中包含，，和等方法，与不同，它占用的代码量少了很多

    
                    
                    

  =   
优点 操作符重载
重载操作符提高代码可读性

        {
        =      
}

  =     
优点 解构
一些对象可以被解构，如对进行迭代

     {
     
     
}
优点 变量范围
为了程序可读性而诞生

    {  } 
      {  }
      {  } 
      {  } 
    {  }
优点 扩展函数
向已有的类里添加新的函数这是官方文档

   {
       _
}

  = 
这样就拓展了原来的类



 
优点 安全机制
是一个几乎静态类型的编程语言。的变量类型在一些情况下会等于，导致程序猿总是要担心。
的类型默认是不允许为空的，但是可以通过在后面加一个问号来表示允许为空，例如：
   = 
 =                  编译报错

   = 
 =                  编译通过
当你访问一个可能为空类型的时候，会编译报错，除非加上一个检查机制如：
  =          编译报错： 可能为

  ==  
  =         编译通过
也可以使用安全调用，这样该表达式在  为空时返回，而不是抛出空指针异常：
  =         为可空的型
安全调用问号可以进行套用，以避免像其他语言一样存在大量嵌套的检查。如果我们想要一个非外的默认值，可以用 “”操作符
  =   
如果上面你不想用的话，你刚刚又有不明确的要求，那只有抛出异常
  =    
  =               和上面一样
优点 更好的 
语法简单直接，如：
  = {         }    相当于  = {   }
  =                        相当于： == 
的表达式优点体现在：如果表达式是方法的最后一个参数或者是唯一参数的话，那么该方法的括号可以移动或者省略如果我们选择不去声明单参数的表达式的参数，那么会隐式的将其命名为所以说，下面的代码效果是一样的：
{    }
 {    }
 {  }
还可以让你的代码更漂亮如：

     {  =  }
     {  }
     {  }
     {  }
好了，上述就是笔者要说的一些优点，当然还有很多优点或一些确定是没说的，这就等着我们明晚和鹅厂的们一起探讨吧！首先很感谢腾讯举办这次比赛，让我们学生党可以接触到这么丰富的数据。这是我们团队第二次参加数据挖掘的比赛，虽然在第一次的比赛中没能取得好的成绩，但也从中吸取了很多经验和教训，让我们尽快地开展了工作。抱着学习和交流的心态，我们参加了这次腾讯举办的广告社交大赛。
在参加比赛中，我们觉得以下几点可以帮助我们尽快融入比赛中的：
、首先要理解业务场景。
刚看到题目时，我们并没有着急开始分析数据，而是，首先明确了任务要求和提供的数据。在这个比赛中，我们要预测的是天的转化率，官方提供了到天的 历史行为数据，还有用户和广告的基本信息；对于业务的理解，我们需要知道提供的每张表格中那些信息，每种信息是怎样关联起来的。了解业务场景有助于我们提取优秀的特征，我们可以假设自己是一个点击的用户，从一个用户的角度来思考怎样的特点会吸引发生转化行为；
、如何开展特征工程。
构造怎样的特征工程和你对业务理解有关，这是一个关于时间序列的问题，用户的过去行为反映了用户在天的可能转化的情况，所以我们可以考虑用户过去时间里的点击后发生转化的比率来表征用户的特征，同时我们也用了点击后发生转换的比率来表征的特征；在构造特征的过程中，由于这是一个关于时间序列的问题，要防止“穿越”行为——用用户未来的数据表征当前用户的特征；同时，构造特征时，除了自己对了业务的理解外，还可以进行数据分析，    一个方法是按进行分组统计的操作，看看哪一类特征在中有着不一样的分布下面这一段代码统计在不同的和类型下的转化率。
_=   _ = _
_=   _ = _
这是我们的实验结果：
 

从结果可以看出不同的在转化率上有着很大的差别，所以我们把的转化率作为一个重要的特征，在不同的类别上的转化率并没有很大的区别，所以‘’的区分能力并不强；
对于表格数据表达信息不直观的问题，可以考虑做数据的可视化，下面是对的转化率做可视化的结果：

同样展现了不同的类型在转化率上没有较大差别，也就没有很大的区分能力。对于如何进行数据可视化，上有一个不错的分享：

、特征工程的重要性。
就像一句老话说的那样，“数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已”，所以说，在比赛的前期阶段我们更加要重视特征工程的构建，一个好的特征就能使得损失下降很多。举一个例子来说明，在这个比赛中，组合特征就是一个很强的特征，用户点击后安不安这个和这个性质有很大关联，有些是针对男性的，有些是针对未婚人士的，所以我们提取了和性别、年龄、婚姻状态来做组合特征，加上这几维特征后，我们线上的损失直接下降了，相对于调参和换其他算法，这样的提高来得更加直接些；当做特征工程没有很大的作用时，我们才开始考虑做参数调优和模型融合；
、多和别人交流。
由于我们参加比赛的经验不足，在思路方面不是很开阔。在交流群上和别人进行交流能打开自己的思路，同时，也可以多多参考上类似的比赛，除了能学习到别人的思路想法以外，还可以学到大神的代码风格，增强实现自己想法的能力。
抱着学习进步的心态参加这次比赛，学习很多大神分享的经验，就算没能获得很好的名次，也是一次很难得的经历。希望这次比赛越办越好，大家在这次比赛中有所收获。梁定安腾讯织云负责人，腾讯运维技术总监，开放运维联盟委员，腾讯云布道师，腾讯学院讲师，  讲师，凤凰项目沙盘教练，复旦大学客座讲师。

因英雄联盟总决赛在线抢票玩家数量过多，硬是把独家线上售票机构的服务弄挂了，众多玩家表示很不开心。

官方也发文致歉广大的游戏玩家。

作为一名运维，看到这篇新闻时，我同感不开心。因为这个故障很有可能会导致某个运维小伙伴背黑锅，虽然我们都知道“冰封三尺非一日之寒”，酿成本次故障的原因绝不仅是运维岗的责任，但事与愿违的是，往往“受伤的”却总是运维岗。
，干得了这行我们就承受得住故障的暴击，但同时我们也要不断的用先进的理论知识来武装自己，提升运维团队的整体实力。让我们一起用视角来看下，故障发生后，我们如何能做到“引以为鉴，举一反三”制定有效的规避措施，保障类似的故障不再发生。
的文化精髓，可以为我们指引改进的方向。


文化 是指拥抱变革，促进协作和沟通
自动化 是指将人为干预的环节从价值链中消除。
精益 是指通过使用精益原则促使高频率循环周期。
指标 是指衡量每一个环节，并通过数据来改进循环周期。
分享 是指与他人开放分享成功与失败的经验，并在错误中不断学习改进。

首先，是一种新的思维模式，我们不能以老观点来评判这次抢票的故障。是一个很关键的词，提出对待故障的正确方法，是不要责怪，不要罚钱，而是应该让团队在故障中学习和提高。这是的目标：分享责任、分享经验、分享信息、分享成功与失败，践行持续改善。

除了告诉我们要要，还有丰富的技术实践供我们参考学习。从价值链流转图中，我们能找到可以改进的点。

站在产品岗的角度，反思这次故障，可以尝试以下优化：

排队购票机制，从产品体验上引入先来后到的队列机制，可以降低突发大量的用户冲击技术架构。这种招数在社交的场景屡试不爽，如打地鼠抢红包。

预估业务量，产品经验有必要提前估算这次购票活动会带来的请求量规模，让技术团队能够有一定的依据来准备容量，可结合英雄联盟的热度和历史经验。

错峰预约策略，这是一种产品策略，把相当于把峰值提前打散。如双的提前预约再抢购，红米手机在空间的活动，先抢资格择日再买。


站在开发团队的角度，在提升架构的性能吞吐的同时，可以站在运维的角度为架构增加些非功能性的特性。

高性能服务，结合分布式、消息队列、逻辑解耦等架构设计思路，提升接入层扛大并发的性能。
数据垂直切分，避免热点过度集中压垮。
自动拒绝服务，防止后台服务发生雪崩。
做好实时监控流数据的监控，让运维具备发现异常和响应处理的能力。
引入容器技术，让快速扩容具备条件。
预留柔性策略开关，以备不时之需。
合理选择路由服务，可结合实现服务自发现，或用名字服务代替直连。

站在测试团队的角度，在对业务逻辑验收完成的前提下，还要监督和保障所有非功能规范都能按要求实现。

验收非功能特性，保证应用在上线前，所有可运维性需求都被实现。
压测应用性能，把单机吞吐量告知运维，后者可合理的估算容量。
测试用例服务化，让运维有能力在完成应用部署后，自动化调用测试用例验证服务功能，以实现自动部署自动上线。

终于轮到运维团队的改进措施，不仅是针对此次抢票故障，运维务必有一套规范流程对业务的运营活动进行质量保障。

容量规划，根据业务活动的请求量和单机吞吐量，规划集群的容量，并保证备用设备能应对计划外的流量。

扩容能力，提高扩容的速度和质量，给开发的架构提建议，给测试的工具提需求，以建设运维自动化为目标。

容灾容错预案，调度、柔性的工具和策略要提前准备好，并时常演练，养兵千日用兵一时。

参数调优，性能的优化与内核参数有关，找到最贴切的参数组合，在运维侧为架构优化助力。

防攻击能力，每次运营活动，都请保证所有请求的合法性，切勿因为安全问题导致服务不可用。

实时的监控与告警，确保在关键时刻你的眼睛没瞎，能在第一时间收到火警，将火苗扑灭。

与合作团队多沟通，重大的活动需要郑重对待，但首先得确保每个产品的重大活动都能够通知到运维团队。


综上对抢票故障的规避措施，要想整体提升企业能力，关靠个别团队的努力是不足够的，如方法论体系图描述的一样，我们需要结合精益、敏捷、持续交付、等理论和技术，为企业打造一个完整的文化与工具体系。

欢迎关注腾讯织云，获取最新技术资讯上一篇：《基于  的微信安全通信协议  介绍上》
  协议 — 使用对称加密密钥进行安全的通信
经过上面的  过程，此时  和  已经协商出了一致的对称加密密钥 __，那么接下来就可以直接用这个 __ 作为密钥，选择一种对称加密算法如常用的 加密业务数据，将密文发送给 。是否真的就这么简单呢？实际上如果真的按这个过程进行加密通信是有很多安全漏洞的。
 认证加密 
加密并不是认证在密码学中是一个简单的共识，但对于我们很多程序员来说，并不知道这句话的意义。加密是隐藏信息，使得在没有正确密钥的情况下，信息变得难以读懂，加密算法提供保密性，上面所述的  这种算法只是提供保密性，即防止信息被窃听。在信息安全领域，消息认证 或数据源认证  表示数据在传输过程中没有被修改完整性，并且接收消息的实体能够验证消息的源端点认证。 这种加密算法只提供保密性，但是并不提供完整性。这似乎有点违反直觉，好像对端发给我一段密文，如果我能够解密成功，通过过程就是安全的，实则不然，就拿  加密一段数据，如果中间人篡改部分密文，只要不篡改  部分，大部分时候仍旧能够正常解密，只是得到的明文和原始明文不一样。现实中也有对消息追加  校验来解决密文被篡改问题的，实际上经过精心构造，即使有  校验仍然能够被绕过。本质的原因是在于进行加密安全通信过程，只使用了提供保密性的对称加密组件，没有使用提供消息完整性的密码学组件。
因此只要在用对称加密算法加密明文后，再用消息认证码算法对密文计算一次消息认证码，将密文和消息认证码发送给 ， 进行验证，这样就能保证安全性了。实际上加密过程和计算消息认证码的过程，到底应该如何组合，谁先谁后，在密码学发展的历史上先后出现了三种组合方式：     ，根据最新密码学动态，目前学术界已经一致同意  是最安全的，也就是先加密后算消息认证码的方式。鉴于这个陷阱如此险恶，因此就有人提出将  和  直接集成在一个算法内部，让有经验的密码专家在算法内部解决安全问题，不让算法使用者选择，这就是这就是    类的算法。 彻底禁止  以外的其他算法。 经过综合考虑，选择了使用  这种  类算法，作为协议的认证加密组件，而且  也是  要求必须实现的算法。
 密钥扩展
 明确要求通信双方使用的对称加密  不能完全一样，否则在一些对称加密算法下会被完全攻破，即使是使用  算法，如果通信双方使用完全相同的加密密钥进行通信，在使用的时候也要小心翼翼的保证一些额外条件，否则会泄露部分明文信息。另外， 算法的初始化向量如何构造也是很有讲究的，一旦用错就会有安全漏洞。也就是说，对于  协议协商得到的 __ 不能直接作为双方进行对称加密密钥，需要经过某种扩展变换，得到六个对称加密参数：  
       用于  算消息认证码，以及  验证消息认证码
        用于  算消息认证码，以及  验证消息认证码
   用做  做加密，以及  解密
   用做  做加密，以及  解密
     加密时使用的初始化向量
     加密时使用的初始化向量
当然，使用  作为对称加密组件，  和   只需要一个就可以了。
握手生成的 __ 只有  个字节，上述几个加密参数的长度加起来肯定就超过  字节了，所以需要一个函数来把  字节延长到需要的长度，在密码学中专门有一类算法承担密钥扩展的功能，称为密钥衍生函数  。 使用的  做密钥扩展， 也是选用的  做密钥扩展。
在前文中，我用 __ 代表握手协商得到的对称密钥，在  之前确实叫这个名字，但是在  中由于需要支持  握手，协商出来的对称密钥可能会有两个，分别称为   和  。从  文档中截取一张图进行说明一下：

上图中   就是代表握手的方式，在   握手方式下，
= = ____ __
在   下
=_____ __ 
=____ __
在   握手下，
== 
在   握手下，
= ，
=____ __
前面说过  使用的密钥扩展组件为 ，该组件定义了两个函数来保证扩展出来的密钥具有伪随机性、唯一性、不能逆推原密钥、可扩展任意长度密钥。两个函数分别是：
   
该函数的作用是对  进行处理，保证它的熵均匀分别，足够的伪随机。
    __ 
参数   是已经足够伪随机的密钥扩展材料， 的返回值可以作为  ， 用来区分扩展出来的  是做什么用，__ 表示希望扩展输出的  有多长。 最终使用的密钥是有  扩展出来的。 把  参数分为：，，_。其中  等于 __， 是标记密钥用途的固定字符串，_ 表示握手消息的  值，这样扩展出来的密钥保证连接内唯一。

 草案中定义的密钥扩展方式比较繁琐，如上图所示。为了得到最终认证加密的对称密钥，需要做  次  和  次  操作，实际测试发现，这种密钥扩展方式对性能影响是很大的，尤其在  握手情况 握手没有非对称运算这种密钥扩展方式成为性能瓶颈。 之所以把密钥扩展搞这么复杂，本质上还是因为  是一个通用的协议框架，具体的协商算法是可以选择的，在有些协商算法下，协商出来的 __ 和 就不满足某些特性如随机性不够，因此为了保证无论选择什么协商算法，用它来进行通信都是安全的， 就在密钥扩展上做了额外的工作。而  没有  这种包袱，可以针对微信自己的网络通信特点进行优化前面在握手方式选择上就有体现。 在不降低安全性的前提下，对  的密钥扩展做了精简，使得性能上较  的密钥扩展方式有明显提升。
在  中，__ 和  经过密钥扩展，得到了一个长度为 __ _ 的一段 ，用 _ 表示，其中：
__ = ___
__ = _____
__  = _____ _
__  = ___ ___ _
 防重放
重放攻击 是指攻击者发送一个接收方已经正常接收过的包，由于重防的数据包是过去的一个有效数据，如果没有防重放的处理，接收方是没办法辨别出来的。防重放在有些业务是必须要处理的，比如：如果收发消息业务没有做防重放处理，就会出现消息重复发送的问题；如果转账业务没有做防重放处理，就会重现重复转账问题。微信在一些关键业务层面上，已经做了防重放的工作，但如果  能够在下层协议上就做好防重放，那么就能有效减轻业务层的压力，同时为目前没有做防重放的业务提供一个安全保障。 　　
防重放的解决思路是为连接上的每一个业务包都编一个递增的  ，这样只要服务器检查到新收到的数据包的   小于等于之前收到的数据包的  ，就可以断定新收到的数据包为重放包。当然   是必须要经过认证的，也就是说   要不能被篡改，否则攻击者把   改大，就绕过这个防重放检测逻辑了。可以将   作为明文的一部分，使用  进行认证加密，明文变长了，不可避免的会增加一点传输数据的长度。实际上， 的做法是将   作为构造  算法参数  的一部分，利用  的算法特性，只要  认证解密成功就可以确保   符合预期。
上述防重放思路在  的握手方式下是没有问题的，因为在  握手下，第一个  是没有业务数据的，可以在这个  下由  和  共同决定开始计算   的起点。但是在  的握手方式，第一个业务数据包和握手数据包一起发送给服务器，对于这第一个数据包的防重放， 只能完全靠  发来的数据来判断是否重放，如果客户端发送的数据完全由自己生成，没有包含服务器参与的标识，那么这份数据是无法判断是否为重放数据包的。在  给了一个思路来解决上述这个 跨连接重放的问题：在  处保存一个跨连接的全局状态，每新建一个连接都更新这个全局状态，那么  握手带来的第一个业务数据也可以由这个跨连接的全局状态来判断是否重放。
但是，在一个分布式系统中每新建一个连接都读写这个全局状态，如此频繁的读写，无疑在可用性和性能消耗上都不可接受。事实上， 跨连接防重放确实困难，目前没有比较通用、高效的方案。其实在  的    中也存在  跨连接重放的问题，由于  主要应用在  浏览器上，在浏览器上访问网站时，建连接的第一个请求一般是  而不是 ，所以  加密的数据不涉及多少敏感性，被重放也只是刷新一次页面而已，所以其选择了不解决  防重放的问题。但是微信短连接是  请求，带给  的都是上层的业务数据，因此  防重放是必须要解决的问题。 根据微信特有的后台架构，提出了基于客户端和服务器端时间序列的防重放策略， 能够保证超过一段时间  的重放包被服务器直接解决，而在短时间  内的重放包需要业务框架层来协调支持防重放，这样通过  层和  框架层一起来解决   请求包防重放问题，限于篇幅，详细方案此处不展开介绍。
四、小结
 是参考  草案标准设计与实现的，使用  来做密钥协商， 进行签名验证， 作为对称加密算法来对业务数据包进行认证加密，使用  进行密钥扩展，摘要算法为 。另外，结合具体的使用场景， 在  的基础上主要做了以下几方面的工作： 　　

轻量级。砍掉了客户端认证相关的内容；直接内置签名公钥，避免证书交换环节，减少验证时网络交换次数。　
安全性。选用的基础密码组件均是  推荐、安全性最高的密码组件； 防重放由  层和  框架层协同控制。　　
高性能。使用  握手方式没有增加原有  和  的交互次数；和  比，优化了握手方式和密钥扩展方式。　
高可用性。服务器的过载保护，确保服务器能够在容灾模式下提供安全级别稍低的有损服务。

五、参考资料

 协议分析与现代加密通信协议设计

       作者 | 梁源编辑 | 京露

梁源，腾讯前端工程师，目前就职于腾讯网络媒体事业群产品中心，负责腾讯网的相关业务。热衷于前沿技术的研究，创新，分享。  

《易打卡》—— 精准定位，一键打卡，记录便捷导出，排名实时更新，戒掉迟到，换你高效人生！这款小程序是在微信内测开始时期就一边学习一边开发，开发过程中也是随着微信小程序的功能以及迭代而不断更新调整产品的形态与功能。
此次的开发总结，将会把我在整个开发过程中遇到的问题以及解决方法和开发技巧跟大家分享，希望能够帮助想要从事开发小程序的小伙伴。

扫一扫右上方二维码或搜索小程序：易打卡，即可体验小程序。
最近一个月的数据分析如图：

一、准备阶段
 微信小程序接入
在微信公众平台官网首页点击右上角的“立即注册”按钮。


 获取小程序
菜单  设置  开发设置

 绑定开发者
通过用户身份管理可以绑定开发者，开发者总共可绑定个，体验者可以绑定个。：这比最初期个开发者和个体验者数量都有所提高。
菜单  用户身份  开发者

  框架知识储备
这里分享一下我的学习整理，帮助大家对框架有个整体的认识。
 微信小程序 框架
小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生  体验的服务。框架提供了自己的视图层描述语言  和 ，以及基于  的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。

 微信小程序 组件
框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。
什么是组件：

组件是视图层的基本组成单元。

组件自带一些功能与微信风格的样式。

一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内。


 =
     

注意：所有组件与属性都是小写，以连字符连接

 微信小程序 
框架提供丰富的微信原生，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。
说明：

 开头的  是监听某个事件发生的接口，接受一个  函数作为参数。当该事件触发时，会调用  函数。

如未特殊约定，其他  接口都接受一个作为参数。

中可以指定  来接收接口调用结果。



 下载并安装开发工具
为了帮助开发者简单和高效地开发微信小程序，微信推出了全新的 开发者工具 ，集成了开发调试、代码编辑及程序发布等功能。

二、产品阶段
 产品调研
小程序方向研究：小程序短期内并不会取代，低频、非刚需场景的长尾服务提供者最适合来做微信小程序
小程序定位分析：适合做小程序的产品方向为个人信息管理、金融服务、便捷生活、电子商务、游戏、新闻
小程序总结建议：建议从汽车资讯、美食、日历、个人信息管理、生活服务几个方向优先考虑
通过脑暴选择了试手项目：易打卡
 产品需求分析
产品核心需求：
快速打卡 —— 快速查看需要需要打卡的任务，并完成打卡任务任务管理 —— 管理所有任务，并可以新建任务个人中心 —— 用于帐号的设置、扫一扫、关于等页面
 产品原型
第一版原型图


三、设计阶段
 
第一版　　　　　第二版

 视觉交互规范





 优化细节
快速打卡优化过程
基于页面上下的比重考虑，将页卡的信息部分下移。左右滑动提示箭头去掉，因为大多数人见到页卡数字，自然会知道页面可以滑动，去掉之后让页面更简洁。距离信息的提示提出来，增加定位的一些的提示图标。中心的较大的打卡增加用户吸引力，在打卡的时候增加绿色外环的动态效果，增强用户交互。
中的细节优化部分在与旋转翻转效果，而且的线条粗细调整为。





四、开发阶段
 前端
源码文件结构如下：

小程序配置：

功能点分析：

页面滑动组件的使用

打卡签到动效使用

列表渲染，数据绑定，模版，事件，引用以及内部页面的跳转的的使用，这里以任务管理为例子说明



滑动组件的页面结构及属性设置

  
打卡动效的页面结构

页面样式：

页面：

任务管理页面截图：


新建打卡任务使用技能，学会的使用即可，其中事件绑定使用官方没有明确说明，这里为了绑定上报数据还是这么写了，跳转的配置为页面路径，用于自定义页面效果样式

、：、：
新建打卡任务使用技能，学会的使用即可，其中事件绑定使用官方没有明确说明，这里为了绑定上报数据还是这么写了，跳转的配置为页面路径，用于自定义页面效果样式
页面结构：

事件绑定 
页面结构：

页面：

 后端
后台服务器架构：

后端接口：
后端  列表
任务
 获取任务列表 

 
 
 和选填一个

： 返回某个的任务详情
： 返回某个用户的所有任务信息

  创建任务 

 
  任务名称
  地点
 开始时间
 结束时间
 应该签到的时间
 经度
 纬度
{} 成员列表， 字段必填
{…} 有效的日期，为无效，为有效

  被创建任务的
  被创建任务的任务名称

  添加成员 

 
 ，需要被添加用户的任务
 
  必填 被添加用户的
  被添加用户的昵称
  被添加用户的头像地址
 删除成员 

 

 ，需要被删除用户的任务
 ，需要被删除的用户

签到
 用户签到 


 
  时间戳。上传签到时的本地时间，用于与服务器时间对比，防止用户本地篡改时间
 
任务

经度
纬度
说

 获取签到情况 

 

  返回条数限制，不填该参数默认返回  条

  必填任务，筛选返回结果为某个任务的签到情况
  =时，必填；其他情况下，不需填写，筛选返回结果为某个用户的签到情况
  {} 必填开始时间，筛选返回结果为开始时间之后的签到情况
  {}必填结束时间，筛选返回结果为结束时间之后的签到情况
  {}必填查询类型，转换签到情况为某种类型的统计数据
  {}= 时，必填查询细节，转换个人签到结果为某种类型的统计数据


= 某一天某个任务全体的成员的最新打卡情况

用例：====

备注： 与  需一致

返回值 


{
    准时签到的人数
    迟到签到的人数
    请假的人数
    未打卡的人数
}

= 某个时间段某个任务所有成员的签到情况统计

用例：====

返回值 



    {
          用户昵称
          准时签到次数
          迟到签到的次数
          请假的天数
          未打卡的天数      
    }


== 某个时间段某个任务某个成员的签到情况统计

用例：======

返回值


{
    准时签到的次数
    迟到签到的次数
    请假的次数
    未打卡的次数
}

== 某个时间段某个任务某个成员的迟到情况统计

用例：======

返回值

{
    记录日期
    签到时间
    迟到多久
    当日出勤比
}


== 某个时间段某个任务某个成员的请假情况统计

用例：======

返回值



  {
      记录日期
      理由
      当日出勤比
  }


== 某个时间段某个任务某个成员的按时签到的情况统计

用例：======

返回值



  {
      记录日期
      签到名次
      当日出勤比
  }


== 某个时间段某个任务某个成员未签到的情况统计

用例：======

返回值

{
    记录日期
    备注
    当日出勤比
}



任务迟到
 用户签到 

 
任务

请假开始时间  {}
请假结束时间  {}

重复请假回返回  状态码 

五、数据统计
统计方式：

 平台自带数据分析



 腾讯移动分析 推荐


使用方法：

六、总结
技巧总结：

小程序中没有的概念，所以不要想着在里面打开一个网页不推荐文章链接类产品

视频需要和组件开发的小伙伴合作

页面样式单位使用，设计图以为标准页。

服务器需要配置后端接口域名



还有很多技巧需要开发中去体会，也许在微信不断更新后会更完善。
最后对于开发团队的总结：

前端主动驱动 —— 小程序开发中前端技术比重较大 ，前端开发者需兼顾整个开发流程 在遇到问题时，不是寻求方案而是先提早预想解决方案，然后引导大家对方案进行优化即可

敏捷开发 —— 版本迭代、每个功能，每个，在提出后的短时间内均快速实现

两套方案 —— 预想方案是大胆的假设方案，必须安排时间进行预研、突破和实现。 保底方案是必定能行的方案，一般是很简单粗暴的方法，目的是为了保证整个产品逻辑起码能形成闭环。



感谢我们一起奋斗的小伙伴
用户研究：于洋
产品：明慧
设计弟弟：戴天骄
前端开发：梁源
后端开发：罗昊天
感谢阅读

相关阅读
微信小程序的编程模式一起脱去小程序的外套和内衣  微信小程序架构解析富途牛牛云上小程序开发一手体验项目中使用了基于构建的，并且通过调用 来完成一些动态解析定义之类的功能，上线前使用的工具检测是否存在内存泄漏的风险。
的使用十分简单，通过设置一定的参数启动二进制可执行程序，并且在执行结束之后收集结果输出即可。但是我们的是通过运行的，不能直接使用启动，一圈之后没有找到相关的实践，只好自己动手。
首先，直接执行二进制可执行程序，可以看到进入了交互模式 ，并且提示等待用户输入如下图。不过如何输入参数？如何确定和的调用方法？以及如何区分两种方法的参数，却仍是未知数。

继续深入研究，全局搜索”  ”后找到了线索，在文件中找到了_函数定义如下
 _
{
      = 
     
      = 
     

      =       == 
        

    \    \
             
    \   \\
      =   =  = \  {
         = 
        
          {
             = 
              =   == 
                
        }
    }
     = \
    \   \  \
         \\
     
}
继续搜索_的调用之处，发现只有一处调用，如下：
 __ 
{
     
     

                
               
                
              
     __   

          __    
              
         __   
     _ =  
        _ =  
    {
        __
         
    }

        
     _ == 
         = _
      _
    {
         = _

          =     ==  
        {
             
        }
    }
      _
         = _
     {      
           _ \
        
    }
        
      == 
    {
         
    }

     = __
    
     
}

查看__函数，可以看到是通过宏_来获取调用模式，宏_的作用是获取环境变量“_”。同时，还看到除了_函数之外，还定义了_以及_函数来分别处理和请求。
其中_和_函数的输出结果都直接作为参数传递给__函数进一步处理，所以模式应该跟模式的输入参数是一致的。
来看接口的调用方式，__函数首先通过_环境变量确定输入参数的格式等，然后通过_环境变量的取值进入调用_函数的分支，并且在_函数中通过_环境变量获取输出参数字符串的长度。

分析到这里，现在大致可以确定如何直接启动二进制文件并输入参数了。

 模式下，输入的参数就是通过方式调用时，后部所带的参数，形如：==，所以对于接口的测试的步骤很简单

使用启动二进制文件进入模式 = =_ = = = __

输入参数列表，并以回车结束。如果参数中有需要的字符请自行转换。===

查看_中的结果输出


接口的调用方式稍微复杂一些。

设置环境变量 _=
 _=
 _=

启动，进入_分支，等待用户输入，只是没有提示信息 = =_ = = = __

输入格式字符串参数{}

查看_中的结果输出

测试完成后，将环境变量恢复
 _
 _
 _


最后，贴一个集成两种方式的脚本：

   

      
       _ _ 
     


   ==   
      
     _=
     _=
     _=

        

     = =_ = = = 

     _
     _
     _

     = =_ = = = 
作者：，腾讯团队产品经理。

为了避免手机性能成为游戏选择时的壁垒，游戏厂商必须进行更好的游戏性能优化。本文利用平台的工具，通过三步完成游戏内存检测与分析的过程，希望为游戏开发者提供一些内存优化的方法和思路。
众所周知，手游在年进入了成熟期，全球的开发商数量在减少，游戏增速也在放缓，更少的游戏意味着高质量的游戏将获得更多的传播和更久的生命力，质量的提升就会带来画面的美化、场景的丰富等，对手机性能也带来了更多的考验。为了避免手机性能成为游戏选择时的壁垒，游戏厂商必须进行更好的游戏性能优化。那么，游戏性能是什么？游戏性能就是决定了游戏耐久度，承载能力和运行速度的因素。

简单来说，游戏性能决定了你的游戏能否跑的更稳，跑的更久，跑的更快。进入了手游精品时代之后，为什么不管什么游戏，言必谈手游性能？因为在时代，如果游戏性能优化一般，玩家加个内存换个或者刷个主频就能轻松搞定；到了手游时代后情况则显得比较严峻，捉襟见肘的内存使得资源加载时如履薄冰，加上高中低不同配置的机型让性能问题显得更加突出，对于玩家来说，为了一款游戏而更换手机的可能并不大，一个低端机型上的卡顿就可能造成一大批用户的流失，如果手游性能表现糟糕，再好的游戏设计都会付诸东流。
那么什么样的手游才是更稳，更久，更快的呢？
我们一般看这样几个指标：

对于手游来说，这些指标的情况就决定了游戏的实际表现，如果光看这些指标没有直观的感受，可以看下图：

如果说左边是玩家经常会遭遇到的表面现象，那右边则是基于手游性能深挖后的问题本质。
为了让游戏的优化能够更加系统，更加有的放矢，腾讯将监控手游性能相关的每个指标，并根据测试的结果进行优化。
那么，先来说说手游性能的重头，内存指标的检测。为什么是重头呢？内存的占用过高通常会带来“游戏闪退”、“卡顿”、“系统重启”等现象，其中每一个结果基本都对游戏的体验是致命的。我们从腾讯平台的工具出发，通过简单的三步，介绍如何通过内存的检测，发现内存管理的问题，优化手游的性能。
第一步：测试游戏
首先要注意：手机必须 
安装助手
登录官网，在“产品“菜单下选择”性能测试“，点击”客户端性能测试“

或者直接登录，点击“版 下载”，也在页面末尾扫描二维码直接下载。


登录
安装好客户端后点击助手启动，选择一种账号登录方式登录。

测试
测试类型选择“”。


首先确认“手机状态”为”手机已“；

点击“应用选择”选择需要测试的应用选择游戏 ，非游戏可以点击“通用性能检测”





选择测试类型，测试类型分为四类：性能测试标准、性能测试重度、资源测试、内存检测。那么这时候，问题就来了，一般应该先开始进行哪项测试呢？
选项一：性能测试标准首先我们看第一个，性能测试标准，该测试主要满足引擎游戏日常性能审核的测试需求，覆盖、、、内存峰值四个维度；建议使用该测试获取准确性能数据，了解游戏的一个整体的性能表现，如果测试结果良好，说明游戏目前的性能表现已经非常好了，可以不需要进行很大程度的优化；如果测试结果不好，则可以考虑进行其他的测试模块。
选项二：性能测试重度该测试在性能测试标准的基础上，增加了函数耗时统计、单个点中各帧的帧时间、数量及每个函数具体出现的位置；建议使用该测试定位性能问题，为之后的性能优化做准备。
选项三：资源测试该测试可以获取游戏过程中多种资源数据，包括资源重复率、数量 、纹理大小 、网格大小 、动画剪辑大小 、音频大小 、关卡间保留资源 、对象拷贝数量等。建议在对内存优化进入到了资源阶段的时候，可以进行这个测试。
选项四：内存检测该测试提供了获取快照点的内存对象情况对象类型、对象大小、对象堆栈、对象引用关系 等；建议在定位存在问题的内存时，可以进行这个测试。

确定测试类型之后，点击“开始测试”性能测试标准、性能测试重度、资源测试中都可以通过点击“开始记录”、“结束记录”来记录核心场景的性能数据、资源数据。




  内存检测中通过点击“内存快照”获取当前内存的详细情况，单次测试中可以任意在需要快照点的位置设置快照。


“上传”，退出游戏，选择测试游戏的游戏类型最多选择两类，点击“确定”，在弹出的上传页，点击“上传”，完成数据的上传。



日志
日志主要是记录历史测试数据，显示历史测试中数据是否上传的状态，绿色为“已上传”，红色为“未上传”。
通过点击“清空历史记录”可以清除客户端的日志中记录的历史数据。

第二步：查看报告中的内存情况
点击“我的主页”

测试类型选择“”

找到测试报告，点击“查看”

第三步：分析报告
如果要对手游内存管理进行优化，首先要明确一个分析的策略，团队的建议是看四块内容：

了解手游内存整体表现
通过内存查看是否发生内存泄漏
通过快照定位存在问题的内存
通过内存分配总表定位存在问题的函数

了解手游内存整体表现
要观察手游内存的整体表现，首先观察游戏的堆内存峰值是否超过了建议值，如下图：

其中，建议值的来源是根据腾讯内部的性能标准，对手机的配置等级而形成的内存阈值，图中的高配机型，内存峰值到达或者内存到达的时候就会开始预警。
如果需要更加详细的指标情况，可以选择“性能报告”部分中的“内存”：

如下图，我们可以看到内存峰值的超标线，如果超过，那么那一刻你的游戏极有可能出现上述“闪退”，“卡顿”和“系统重启”的现象了；如果没有超过，那么恭喜你，继续进入下一个关卡，检查你的游戏是否存在内存泄漏的现象。

通过内存查看是否发生内存泄漏
对于目前绝大多数基于引擎开发的项目而言，其托管堆内存是由分配和管理的。“托管” 的本意是可以自动地改变堆的大小来适应你所需要的内存，并且适时地调用垃圾回收 操作来释放已经不需要的内存，从而降低开发人员在代码内存管理方面的门槛。
那么我们所说的内存泄漏情况，就是游戏在调用了一些资源结束之后比如游戏中的副本，没有及时的释放这些内存，从而导致堆内存的大小越来越多，从而超过了手机内存的阈值。
在比较合理的内存策略下，内存应该上升到一定阶段之后便不再变化，如下图：

如果内存产生了泄漏，便有可能出现下图的情况，堆内存的数值阶段性的不断提升。

如果你的游戏堆内存出现了不断上升的情况，需要排查一些内存泄漏的原因，可以进入下一个阶段，检查具体场景中内存的分配情况。
通过快照定位存在问题的内存
对于内存泄漏，一般只能通过猜测不断修改代码测试的方法来修复问题，效率很低，腾讯平台的工具提供了内存快照对比的功能，并包括对象分配堆栈，对象引用关系等详细信息，是定位内存泄漏问题的一大利器。在具体操作中，需要我们进行一次“内存检测“，具体操作可见上文”第一步“和”第二步“。
在“内存检测“的测试报告中，我们可以发现测试报告对每个场景都进行了标记，形成了一个”快照“，对比两次，查看两者之间的新增对象：

这些不同的内存使用情况的波动意味着游戏在进行游戏内存分配和释放，通过对这些进行对比，可以发现哪些内存新增了，哪些内存保留了，从而找到游戏在内存分配上产生的问题，那么如何进行操作呢？

如上图所示，在“内存检测“的测试报告中，每两个都可以进行对比，通过鼠标单击就可以选择，选中两个场景之后就可以点击”提交对比“：

点击之后会得到两个场景之间的内存分配比较，其中”对象堆栈“就代表游戏中实现的一个对象，以游戏为例，上图中的和所对应的两个场景可能就是“战斗副本“和”游戏大厅“，通过右上角的”快照间新增“和”快照间保留“，我们可以了解到这两个不同的场景之间，哪些对象的资源被保留了，哪些对象的资源新增了如果需要更多数据，可以点击右上角的”下载对比报表“，而这些行为是否是游戏程序所需要的。

可以看到，按钮按下前后新增的最大对象即为代码中生成的对象，并且该对象被引用的次数为。那么，如何在游戏运行中看待这种快照之间新增或保留堆栈的现象？
比如说，王者荣耀这类游戏在副本和游戏大厅之间，会保留地图和的对象资源，保证下次开始游戏时可以更快的读取和进入游戏；而天天酷跑之类的跑酷游戏在在副本和游戏大厅之间，就不会保留地图和的对象资源，原因就在于王者荣耀这类的游戏，地图和的出现的情况是完全相同的，为了更好的游戏体验，保留对象资源是合适的；而天天酷跑之类的跑酷游戏，有不同的关卡副本，如果保留对象资源，会导致内存不断的被占用，因此选择不保留对象资源。因此我们可以说，内存分配是否合理没有绝对意义上的标准，都要游戏开发者根据自己的开发策略，结合内存检测的报告，判定内存分配的情况是否在自己的计划之中。
通过内存分配总表定位存在问题的函数
重新刷新一下报告，我们最后来看一下游戏整体运行过程中具体功能的内存分配的情况：

图中的”分配堆栈“代表的就是游戏每次调用的一个函数，开发人员需要关注右上角”分配总次数“和”分配总大小“，关注是否有函数频繁分配内存，根据计划中的内存分配和实际的内存分配情况，开发人员应该进行针对性的优化。
测试报告分析到这里，基本可以发现内存管理方面存在的一些分配方面的问题了，但是内存优化的道路，到这里才完成了一半，游戏在运行时的内存占用情况可以用下图表示：
 
内存和内存是内存主要的组成部分，内存更多的起到内存调用的功能，因此常常成为了开发人员优化内存的起点；而内存中包含了大量对象的资源，也是内存优化中的重要部分，这部分内容在测试报告中也有具体的细分，如下图：

这部分的内存检测，将在后面的干货中继续介绍。
针对手游的性能优化，腾讯平台的工具提供了基本所有相关指标的检测，为手游进行最高效和准确的测试服务，不断改善玩家的体验。目前功能还在免费开放中。点击立即体验！
商业转载请联系腾讯获得授权，非商业转载请注明出处。最新腾讯云技术公开课直播，提问腾讯代表，如何从小白成为技术专家？点击了解活动详情。
作者 |张红林编辑 | 顾乡

| 导语 实际工作中，对模型和算法的效果如果不满意，需要进行调优，但往往不知道该怎么下手，本文是一片博客的学习笔记，分享给大家


取材于：

相关推荐机器学习入门系列，简介机器学习在 视频编码中的实践深度学习入门实战一像一样算法生成梵高风格画像导语
 作为萌新，很荣幸能参加到第一届腾讯社交算法大赛，我们的队名是“竟然有这种操作”，在这里我希望和大家分享一些比赛过程中和处理的技巧。
其是最开始参加比赛是奔着前名提交得文化衫去的，但当真正进入比赛后，我才感受到了竞赛场上的厮杀，目的也已不是单纯的拿件文化衫那么简单了，特别是初赛阶段很长一段时间都保持在前名更是给了我莫大的信心，进入初赛阶段，队伍始终保持在前，最终以名进入决赛，这无疑是让我们萌新打了鸡血一样，也非常感谢在腾讯算法群里面分享和讨论自己的大大们比如已跃升第三的‘中大渣渣’，我从中受益颇多，目前刚进入决赛阶段，下面聊聊比赛的和。
关于
整个初赛阶段大家讨论的最多的无疑是传说中的了，第一周郭大神的登顶就是靠首先发现了，榜中，大佬们说这个能让线上成绩提升个千分点大几十名的差距啊有木有，事实上，就我们队来说，利用这个构造的个特征把队伍成绩从拉到了，近千分点难不成和特征工程好坏成反比？。
虽有相助，奈何萌新特征工程不过关成绩仍不理想。关于这个特征，首先是和重复数据有关，细心的人应该发现了重复数据的标注是有规律的，按时间顺序大部分标在了最后一条上，当我在舒舒服服的澡堂洗澡的时候突然想到群大佬的一句话”训练集上的情况也会在测试集上出现”划重点！，回去后秒试了一把，将数据分为类进行标注：非重复、重复非最后一个、重复最后一个要相信模型，通过标记让模型自己学习这个规律，进行炫酷的一波操作后，效果不错，提了近个千分点。第二天，想要再次从中发现点什么的我和队友讨论数据的规律，发现重复数据的不仅是标在最后一条，还有标在第一条的，甚至有少量的标在中间，于是仍交给模型学习这个规律，又经过一波炫酷操作，线上，总共提了个多千分点。尝到了甜头，于是又开始挖掘的信息，注意到只利用上了时间顺序，没有用到时间差，又联想到群里大佬的“真实情况不存在信息泄露”。加上了列时间差特征，分别是与重复第一条的时间差和重复最后一条的时间差，于是，线上成绩从突破到了。
关于透露的比较详细了，稍微发散一下应该有不错的效果，个人感觉这个还能继续挖掘。
关于
相信很多第一次参加比赛的小伙伴们会跟我一样遇到泄漏的问题，即同了未来信息来预测当前，造成线下成绩很美好，线上成绩爆炸，我们队通过参考一些比赛获奖选手的经验使用滑动窗口解决了这个问题，如下图：

我们构造统计特征时统计前一周的统计量，来避免信息泄露，这是个比较好的避免泄漏的方法，当然还有很多其他方法，作文萌新就不赘述了=。=！
最后，希望大家在比赛中关注的不仅仅是成绩，学到的东西和经验才是最宝贵的。作者：梁伟盛

据说本贵族圈每月不分享就邀请雪糕。所以分享下一个简单的插件，元素是的一部分，允许脚本语言动态渲染位图像，你可以使用用它来绘制图形、图标、以及其它任何视觉性图像。它也可用于创建图片特效和动画反正就是好东西。
既然是的特性，那必须是只有支持的浏览器才能使用，兼容性如下图：
  

使用到的
 参考资料

  定义：开始一条路径，或重置当前的路径。
      


 定义：创建弧曲线用于创建圆或部分圆。
            

参数

：圆的中心的  坐标。
：圆的中心的  坐标。
：圆的半径。
：起始角，以弧度计。弧的圆形的三点钟位置是  度。
：结束角，以弧度计。
：可选。规定应该逆时针还是顺时针绘图。 = 顺时针， = 逆时针。



定义：绘制当前路径的边框
    



    

定义：返回包含一个对象，该对象包含以像素计的指定字体宽度。
参数

：要测量的文本


定义：在画布上绘制填色的文本
       

参数

：规定在画布上输出的文本。
：开始绘制文本的  坐标位置相对于画布。
：开始绘制文本的  坐标位置相对于画布。
：可选。允许的最大文本宽度，以像素计。



定义：清空给定矩形内的指定像素。
       

参数

：要清除的矩形左上角的  坐标
：要清除的矩形左上角的  坐标
：要清除的矩形的宽度，以像素计
：要清除的矩形的高度，以像素计

实现思路
了解了以上后，我们就可以动手干活了，其实很简单。实现只有个步骤。
，画出带有透明度的内圆
    

    设置透明度，样式与线条宽度
     {
         
         
         
    }            

    绘制圆
               

    画出圆形
    


，根据进度画出外圆
    

    设置透明度，样式与线条宽度
     {
         
         
         
    }                            

    根据当前进度绘制圆
                   

    画出圆形
    


，根据进度画出数值
    

     {
         
         
         
    }            

    得出数值宽度
     = 

              


最后暴露出设置进度函数给外部调用即可
    清除内容
                                   

    _

    _


测试用例
     
    
    
         =
         = == = =  
         ==
         ==
         ===
        
    
        
     = = = =
    
     = =
     =
          =  { }

          = 

          =  {
              ==  {
                        
            }  {
                
            }
        } 

    
    


实现效果
背景与进度颜色根据喜好变换
  
最后
今天分享就到此位置了，有兴趣的可以去看下代码。

原文链接：


相关推荐关于错误捕获玩转正则表达式作者：廖亿富

平台的目的
说到性能测试，大家想到最多的是在端利用、和等工具进行测试和性能指标的分析，但是如果我们测试的是上的，我们该如何保证数据准确度、如何测试起来更方便快捷、如何才能够小白式进行性能测试呢？ 
解决方案
带着这些问题进行了深入的学习、思考与讨论，最后敲定了一键测试的解决方案，就是用户只需提交一个，就可以得到一份完美的报告。

带着这些思路，让我们一起走进性能测试平台的实现，手把手一起打造性能测试平台。
搭建平台所需的知识
搭建平台的方式和使用的语言有很多，为了方便、快捷、高效，我们使用了的架构进行页面的展示和数据交互，进行任务的调度和处理，进行文件的解析与瀑布流的展示。
 
框架
采用了的框架模式，即模型，视图和模板。从的架构图可以清晰地把握的组成部分。

 
是一个可扩展的持续集成引擎，非常易于安装和配置，简单易用。主要利用的定时任务功能实现性能测试任务的调度功能。
 
是基于格式来可视化跟踪工具创建的日志文件。可以很方便的展示生成的文件。
平台架构
整个平台涉及到的资源比较多，包括：、平台、 服务和手机端的功能。

主要流程：
用户提交，平台将数据保存入数据库并加入到任务队列

 任务每分钟向平台发起执行任务请求，平台查询是否有等待任务，有则向的 接口执行测试任务与数据收集

 测试任务执行完毕后，将测试结果传给平台进行解析与入库处理

结果完成后，请求页面会自动跳转到结果页面或到任务列表查看结果信息

注：平台、与 服务之前的调用采用的是 的请求方式。
平台的实现
 性能平台功能实现
根据的架构流程逻辑，可以轻易的实现从请求到视图响应的流程。
 用户在浏览器上打开一个链接。

 接收到一个请求后，会在配置文件中查找对应的函数。

在实现请求参数获取、数据库查询和返回到。

最后在中实现页面的展示，包括了、和。
 任务调度的实现
   任务调度主要实现配置定时任务和实现请求。
任务配置
在中配置一个，定时任务配置成分钟执行一次。

在配置信息里面指定执行的批处理任务。

请求实现的代码。
通过的轻松实现一个请求的访问。

平台页面功能解说
 请求页面

用户在页面上提交一个，平台将存储到数据库中，并每隔查询任务执行的状态。目前平台暂时只支持公司下的测试，后续将扩展到更多手机和各种网络下进行性能测试。
 任务列表
用户提交了页面测试后可以在任务列表中查看任务排队和执行情况，如果执行完成，可以进行结果查看。

 结果详情展示
结果页面提供了丰富的性能指标，包括：项关键指标、域名资源统计、资源统计信息、图片资源统计，并给出了详细的建议和终端的瀑布流。可以根据这些指标和详细建议对其进行分析和定位。



相关推荐【腾讯】从到：打造移动端性能测试平台手机会员加速方案——技术内幕 腾讯移动分析导语  在一些混编系统中，我们使用成熟的网络调度框架编写框架代码，使用编写适用于计算密集型的，通过函数进行全局静态的加载卸载。业务场景有对实现动态加载替换的需求，但并没有直接动态加载的机制。本文将深度剖析加载的实现机制，并提出一套动态加载的方案。

在一些业务场景中，为了支持单点单动态链接库的热更新，需要在框架层动态加载替换。这里动态加载，是指当前提供服务的时候，需要动态加载另一个同名，并对旧的进行替换，而不影响现有服务。
考虑开发效率和成熟的网络调度框架，我们使用作为网络和调度框架；而计算密集型或者某些只能使用的场景如，我们会使用编写作为算法业务代码实现。这个过程涉及到的加载，一般都是使用函数或者，通过调用动态链接库，整个流程在业界已经非常成熟。那我们如何实现框架中的动态加载呢？
一、如何实现动态加载
框架实现的动态加载比较简单，通过得到加载的的句柄 ，获得函数地址。一般为

框架中维护一个到句柄的，，成功后，将新的句柄替换至；
新的流量请求通过转发到新的函数；
待老的没流量之后，将老的卸载即可完成的动态加载。

二、加载原理剖析
在解决动态加载之前，我们跟着源码来看是如何实现的以下源码都以为例。前面已经描述静态加载一般都是通过或者实现，实际两者调用的代码是一致的，所以我们以为例。
 跟着以及看下去略去中间步骤，我们找到了下面的接口：
 
 
       
 
     

   
     

       {
   = 
   = 
   = 
}
 
 在源码中找到中对应的代码，下面是的实现，_里面即是加载的地方。
 

       ___
      
   
 
  
_____
         
{
      

     
     =     _
     
 在源码中找到_的实现
___ _  
   _
  _  
   
  {
     
    _ = _   
  }
   
 跟进_，有三个不同实现分别对应三个平台_ _ _，这里只看_
 
  _      
{
    =  _
    =  {
      
     
}
 
到这里恍然， _即是下 的最终实现，其实跟加载动态链接库是一样的。
那我们是否可以利用返回的句柄来进行动态加载呢？答案是否定的，因为没法接受 ，在的时候，并没有将加载的句柄返回给代码。官方文档也说明，实际上 都是全局加载的，没法同时加载两个同名。
                   
那么我们如何实现动态加载呢？
三、中动态加载
我们没法通过重复加载同名或者直接动态替换，也没法在层拿到返回的句柄，所以我们没法在代码层实现的动态加载。当然还有一种做法是先卸载，再加载，但这个过程不是无损的。
最终我们设计了一套代理方案，通过加载，然后在中实现了跟文章第一节说的动态加载过程。中会维护一个 为框架中传入的，为包含返回的句柄，拿到的函数地址以及相关的上下文信息。在进行数据的转发并且封装了相应的转换，彻底的将算法与框架解耦开了。如图所示：  
图 框架、代理与算法解耦    
图 动态加载流程
动态加载流程为：

会监听目录，但发生变更后，通过调用的方法，并将该对应的及路径传入；
完成及之后，会将新的句柄，函数等存入，后面所有的请求都会被指向新的；
在一段时间后，延迟卸载旧的

四、总结
综上，我们详细剖析了加载的机制，并设计了一套在框架中动态加载的方案。我们将这套机制成功应用于图像识别服务框架中从到打造轻量级图像识别服务框架。是一个非常轻量级的，实现简单并且实测下来，性能跟直接通过加载无明显差异。媒体行业是传统而又新兴的行业，在数字化、信息化、移动化快速演进的今天，无论是用户、社会还是行业、政府都意识到，传统媒体与新兴媒体融合发展是必然之路。但媒体融合需要内容和技术双驱动，内容是硬道理，技术是生产力。融合并不是简单的内容复制和粘贴，需要有一个促使融合从梦想到现实的因子，这个因子就是技术。
年人民日报媒体技术股份有限公司联合腾讯云共同发布了我国首个媒体融合云服务平台中国媒体融合云，意在为媒体融合发展消除技术瓶颈。本文结合中国媒体融合云的背景及技术架构优势，剖析数字经济时代，云技术平台如何为媒体融合发展创新赋能。
一、媒体融合发展的期望
数字经济时代，从媒体行业的发展来看，有两个较大的变化：一是信息传播的方式发生了演变。我们知道最早的广播、电视，都是由一个“中心点”发出，甚至我们早期的网络结构，也是集中由 “中心点”服务器管理资源。互联网到来，信息传播转变为“去中心”的方式，分布式的存储与服务使得信息传播更丰富、更稳定、更有效。而现在的数字经济时代，更强调更高效、有机地协作，信息传播的方式进而演变成“融中心化”。信息传播方式的演变可以用下图来表示：
图：信息传播方式的演进
另一个是信息化的建设模式发生了重大转变。传统方式的信息化建设模式，每个业务系统，从前端、中间的逻辑、到后端数据库，再到底层操作系统、网络及硬件，都是采用相对独立的，隔离的纵切建设模式。我们会发现，在传统的纵切模式中，需要很多类型的技术人才，需要考虑非常多的技术点；业务系统的建设、扩容、改造、迁移都特别复杂；资源的利用率也成为问题。而数字经济时代，更好的信息化建设模式已转变为：“平台应用”的建设模式，即横切的计算、存储与网络等相关的资源池层，数据库、中间件及通用组件的平台层以及最上面的应用服务层。这种横切的信息化模式，就是典型的云技术平台，通过云平台技术一体化管理，可以让我们的产品与技术人员更专注于业务，业务的上线、扩容、迁移都变得十分简单。两种信息化的建设模式示意如下图：
图：信息化建设模式的转型注：图片来源于时代学院姚乐老师《从传统信息化到互联网化》
数字经济时代的变化对各行各业都将产生四个方面的挑战：一是速度，二是协作，三是价值重构，四是个性化定制。媒体行业也不例外。媒体融合过程中，将对原来的内容生产、传播及运营都带来全新的模式与挑战见下图，包括：
图：媒体融合的挑战
媒体生产现在不仅有文字，还有语音、视频以及交互，如何最快速地生产出包括文本、图片、语音、视频等多种形态的内容？无论是专业的编辑、记者，还是用户报料，还是网络收集，这些渠道是否可以协同展开？报纸、电视、手机、等渠道都可以承载内容，生产好的内容如何协同渠道快速分发？用户通过不同的媒介渠道是否可以得到体验一致的内容？融合媒体运营中，传播已不再是单向，是否可以马上得到用户或客户的反馈，是可以评估传播的效果？是否可以针对不同人群提供适合他们的内容？如何确保信息的安全？显然，媒体融合发展是一项复杂的系统工程，也是一场划时代的变革与创新。在媒体融合的过程中，用户会更强调个性化，媒体如何让用户产生黏性，从而提供精准服务；产品更多样，形态更丰富，如何更快进行迭代；对于媒体员工来说，如何让他们更加专业、协同和高效，并赋予他们成就感；媒体效益如何提高，除了影响力，还有盈利能力；资本能否认可。这些都给媒体融合提出了要求。也就是说，数字经济时代，对媒体融合发展，有以下五个方面的期望：•用户  个性化；更强的连接，更精准服务•产品  多样化；丰富的形态，更快速迭代•员工  专业、协同、高效；成就感•效益  影响力传播、引导、公信；盈利•资本  认可、助力、繁荣生态
腾讯董事会主席马化腾于年月在深圳举办的“云未来峰会”上谈及云时代未来三个趋势时表示，云是产业革新的原动力，是新型社会管理的主平台，也是人工智能的强载体。现在衡量经济发展的标准，很多时候是“用电量”，同样，将来衡量媒体的发展也会有一个重要指标，那就是“用云量”。 因此，云作为数字经济时代的一个基础设施，无论是应对媒体融合发展的挑战、还是满足融合发展创新的期望，云技术平台都是媒体融合发展创新的最佳选择。
二、云技术平台赋能的技术优势
一年前，人民日报媒体技术股份有限公司联合腾讯云共同发布了我国首个媒体融合云服务平台——中国媒体融合云，意在为媒体融合发展消除技术瓶颈。
、中国媒体融合云概述
中国媒体融合云源自于人民日报的“中央厨房”概念与系统，见下图：图：人民日报“中央厨房”体系    “中央厨房”体系由空间平台、业务平台、技术平台构成，不仅将人民日报、合作媒体、政府、认证用户及社会公众有机连接起来，也打通了国内外合作媒体、互联网合作伙伴及人民日报社的各媒体终端，提供了空间和业务模式分享、内容协作生产与分享推送、技术能力支撑以及盈利分享体系的接入。中国媒体融合云正在基于“中央厨房”的成功应用，把“中央厨房”全媒体平台上的技术能力、内容、生产和分享能力以及渠道能力全部开放出来，着力打造“内容融合能力渠道开放连接生态”，可以帮助我们媒体融合发展创新得更快，更方便，生态也会更丰富。
、实现与支撑中国媒体融合云的技术架构
中国媒体融合云的技术支撑架构如下图所示。图：中国媒体融合云技术支撑架构
从上图可以看出，中国媒体融合云是典型的横向切分“平台应用”的信息化建设模型。底层是腾讯云提供技术支撑的，包括云服务器、存储及网络的资源池，也有公共组件如大数据、直播、安全防护等服务；中间一层是媒体通用的生产运营组件，如集成部署、订购计费等；最上层是利用媒体生产、协作、分发及应用商店、可视化工具等媒体应用相关的业务服务层。    由架构可见，中国媒体融合云很好地将传统媒体与新兴媒体结合，给员工及专业伙伴提供了丰富的工具与能力，可以打造形态丰富的媒体产品，为用户提供了多样的且个性化的内容，在协作与效率方面，扩展与增长方面都有强大的支持。
、中国媒体融合云具备的优势
腾讯沉淀多年的技术能力
媒体融合云直接输出了腾讯沉淀多年的技术能力，包括但不限于：拥有全球最强大的互联网基础设施，与微信这些海量互联网用户产品的服务经验，全球领先的互联网产品与技术研发能力，互联网安全实战能力等等。
 腾讯云丰富且强大的、、能力
媒体融合云直接引用腾讯云丰富且强大的、、能力，包括：计算、网络、存储、数据库、安全、域名服务、移动与通信、监控与管理、视频点播与直播、大数据与等全面的技术能力，而且这些能力还在不断地升级、扩展中。见下图：图：中国媒体融合云当前具备的技术能力
性能卓越的高可用架构及分布式部署
目前，基于腾讯云立足中国，布局全球的服务节点，中国媒体融合云上的服务可以享有性能卓越的高可用架构及分布式部署优势，比如全球个服务节点，可以让全球用户快速就近访问媒体服务见下图；国内多达线的优质网络，让复杂网络环境下的中国网民均可顺畅访问高效地访问所需的媒体内容；机房多出口容灾，可以在秒内完成异常流量调度；双平面网络架构，使提单接入层交换机故障情况下，用户无缝切换；国内加速节点超过个，海外超过个，总体高达的防护，可让业务在攻击面前高枕无忧。

图：腾讯云全球服务节点分布
 顶尖的互联网信息安全能力
中国媒体融合云通过底层腾讯云，自动获得业界认可的最高等级的安全认证。包括：

信息安全等级保护三级认证
国内首获云计算领域认证 
首批通过可信云服务认证
项 可信云认证

其次，具有久经考验的互联网信息安全技术与处置能力。包括：

日对抗黑客扫描及攻击次数超过亿次
日化解帐号破解尝试次数高达亿
月扛攻击次数
单节点可抵御流量，总体抗流量举例来讲，正是因为云技术平台陆续开发出的验证码服务、垃圾消息过滤、后门木马检测、异地登录提醒、漏洞扫描等新技术，在技术风险和网络安全问题面前，“可以承受每天超过亿次以上的账号破解尝试。” 独创的专属服务区让融合更灵活、安全、高效
中国媒体融合云独创专属服务区，可以依据用户需要进行资源的量身定制，不仅满足用户的高性能要求，也提供灵活的部署能力。见下图示意：图：中国媒体融合云专属服务分区示意图

专属服务区的资源可以做到独享隔离，并且提供精细的访问控制，接入及互连的方式可以多种多样，不仅连接的链路可以多路由冗余，互通组网方式也非常便捷。举例而言，我们在专属服务区可为客户提供专用宿主机：   、黑石物理服务器：  、私有网络：  、专线接入： 技术能力，分别简介如下：：可以让客户以独享宿主机资源方式购买、创建云主机，以满足您的资源独享、安全、合规需求；购买专用宿主机后，客户可在其上灵活创建、管理多种自定义规格的独享型云主机。在此之上，可使用高质量的网络，，弹性重新映射等服务。：是一种按需购买、按量付费的裸金属云服务，为客户提供云端专用的高性能、安全隔离的物理集群。使用该服务，客户只需确定配置和数量，获取服务器时间将被缩短至小时，服务器供应及运维工作交由中国媒体融合云，而客户则可专注于业务创新。：是在中国媒体融合云上自定义的逻辑隔离网络空间，与客户在数据中心运行的传统网络相似，托管在私有网络内的是客户在中国媒体融合云上的服务资源，如云主机、负载均衡、云数据库等。客户可以完全掌控自己的私有网络，包括自定义网段划分、地址和路由策略等，并通过安全组和网络等实现多层安全防护。同时，客户也可以通过或专线连通私有网络与客户自有的数据中心，灵活部署混合云。：是中国媒体融合云提供的高可靠专用网络接入服务。客户可以利用专线接入将媒体融合云与客户的办公室、数据中心、第三方合作伙伴相连接，实现大容量高可靠网络互联的混合云部署。
 融合云打造了开放协同的共赢生态圈
云是一个开放协同的共赢生态，中国媒体融合云更是如此，它使得媒体、用户、开发者、内容提供商、技术服务商、资本都在云上，大家一起在云上生长、云上开放。
总结一下，中国媒体融合云具备以下领先优势：功能强大、性能高效、安全可靠、专属分区、生态协同。可以帮助我们媒体融合创新得更快，更方便，生态也会更丰富。如果大家都在这个平台上，很多内容都可以互通，技术也可以共享。
三、媒体融合云的未来展望
媒体融合云专注服务于媒体行业，专注于媒体融合发展与创新，未来首先是将不断探索内容和服务创新的技术能力建设。比如，如何通过技术，打造更新、更形象生动、更受欢迎的富媒体内容？也许未来我们系统推送的不仅是单调的文字、图片，还会加入很多特别的动态因素，例如技术的应用见下图。未来、、、等技术的充分应用，甚至不排除可以用户或受众对媒体内容产生身临其境的感觉。
图：利用技术产生更生动的富媒体内容
再比如，我们能否通过技术自动生成内容？依据热度及用户读者画像，在机器学习进一步发展的情况下，不仅是推荐个性化内容，还应该可以自动生成个性化、适个每一个用户的内容。不仅是预测热点，还可以自动产生评论、智能客服务，智能提升产品内容质量与活跃度见下图。
图：智能自动生成个性化内容　　未来还是万物互联的世界，是协作的世界，所有可见的资源和设备都会连入互联网见下图。在云平台技术支撑之下，所有东西连接起来，未来可以把媒体资讯推送到里面去，也可以接收到信息反馈，生成更好的内容。也就是说，媒体融合发展创新的想象空间是无限的。

图：未来是万物互联的世界
新技术与应用场景在快速进化与演进当中。一切细微之处，皆是演进之端。未来在云技术平台支撑下，万物互联，协作共享，不断进化造就无限可能的媒体融合创新共赢生态。云技术平台也将使得媒体的价值无限延伸。


于广州在上一篇系列文章《【私房菜】收集  访问日志》中，我们已经完成了收集日志的目标，再收集其他日志也就小菜一碟了。
下面，我们一起看看如何收集日志。
一、日志格式
和一样，也可以变相将日志输出为格式，给我们的收集带来了极大的便利。在日志收集一文，我们已经设计好了必要的日志格式，所以这里只需要将对应的日志变量改为的就好了，配置代码如下：
 使用获取客户端真实，这里比方便多了
 ___  {
  _
 \ 
 }

新增日志格式
_ __ {___________________________}

在站点对应的模块内配置日志：
_  __
：如果需要调整日志参数，可以参考本文最末的附录：日志变量详解。
：后文的内容和《收集日志》所用配置是一样的，看过前文的可以忽略。
二、部署
按照《【私房菜】安装部署及配置详解》在需要采集日志的服务器上部署，然后编写如下配置：
 

  

 _ 
   
  _ __

_ 
_ 
 

  

        
   
       
   {}
  _ 
  _
    _ 
  _ 
   
  __ 

  
 
_ 
_ 

   
   
   
三、配置
在正式上报数据之前，我们先配置下的：
：如果前面已经做过日志收集，且设计的日志格式一样，则可以跳过这一步
{
     __
     {
       {
               {
                 {
                   __  
                      
                }
                _ {
                   _
                   
                }
                _ {
                   _
                   
                }
                _ {
                   _
                   
                }
                _ {
                    
                }
                 {
                     
                }
                 {
                   
                }
                _ {
                     
                }
                __ {
                   _
                   
                }
                __ {
                   _
                   
                }
                 {
                   _
                   
                }
                _ {
                   _
                   
                }
                __ {
                  
                }
            }
        }
    }
}
 ：这里就不详细说明每个字段含义了，请参考系列文章《 简介整理中》
将上述模板保存为  的文件，然后执行如下命令进行导入：
  ___  

主机为地址和端口
_ 表示模板方法
__ 是我们给这个模板取得名字
 模板文件，表示将这个模板文件导入到

正常将返回如下结果：
{
    
}
四、配置
模板导入之后，我们再配置 。
：这里和上一篇日志收集的配置一样，如果是从同一个读取，则复用一套即可。
 
 {
     {
        _ = 
         = __
        _ = 
         =  {
             = 
        }
        _ = {  = __ }
    }
}

 {
      == __ {
       这里对单字节编码做了下替换处理，否则有中文会出现无法解析报错
       {  
         =  \\ \\\
      }
       这里排除了下请求，如需要排除其他关键词，可自行添加
            {
            {}
      }
       {
             = 
            _ =           
            _ =       
            _ =       
            _ =       
            _ = 
            _ = _
            _ = 
            _ = 
            _ = 
            _ = 
        }
    }
}

 {
    {
         = 
    }
      == __ {
         {
             = 
             = __{}
             禁止管理模板，并指定模板
            _ = 
            _ = __
        }
    }
}
这里由于我们上报的已经是格式，所以不需要做正则匹配和其他处理，简单多了。
五、配置
启动上报数据之后，我们还需要在里面配置下索引：
①、如图打开索引管理：

②、如图点击创建索引：

③、如图输入指定的索引前缀，自动带出字段后选择时间戳字段，点击【】即可：

最后，回到界面就能看到期待已久的高清美图了：

本文就介绍这么多，更多的奇淫巧计请关注《私房菜系列文章之教你玩转整理中》。
六、附录：日志变量详解

                    请求中的参数值
_            同 
_                请求中的值
_                 如果请求中有参数，值为，否则为空字符串
                     请求中的当前不带请求参数，参数位于，可以不同于浏览器传递的_的值，它可以通过内部重定向，或者使用指令进行修改，不包含主机名，如。
_            同 
_           当前请求的文档根目录或别名
                    优先级：请求行的主机名请求头字段符合请求的服务器名请求中的主机头字段，如果请求中的主机头不可用，则为服务器处理请求的服务器名称
                主机名
                   如果开启了安全模式，值为，否则为空字符串。
__      客户端地址的二进制形式，固定长度为个字节
__         传输给客户端的字节数，响应头不计算在内；这个变量和的__模块中的参数保持兼容
_              传输给客户端的字节数
              连接的序列号
_     连接当前的请求数量
_           请求头字段
_             请求头字段
_             名称
_              用于设置响应的速度限制
                    当前的时间戳
_           版本
                     工作进程的
                    如果请求来自管道通信，值为，否则为
__     获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串
_           当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径
_             客户端地址
_             客户端端口
_             用于基础认证服务的用户名
                 代表客户端的请求地址
_            客户端的请求主体：此变量可在中使用，将请求主体通过_，_，_和_传递给下一级的代理服务器
__       将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置____。如果将次文件传 递给后端的代理服务器，需要禁用 ，即设置___ ，___ ，___ ， ___ 
_      如果请求成功，值为，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空
_        当前连接请求的文件路径，由或指令与请求生成
_          请求的长度 包括请求的地址，请求头和请求主体
_          请求方法，通常为或
_            处理客户端请求使用的时间单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。
_             这个变量等于包含一些客户端请求参数的原始，它无法修改，请查看更改或重写，不包含主机名，例如：=
                  请求使用的协议， 或 
_             服务器端地址，需要注意的是：为了避免访问系统内核，应将地址提前设置在配置文件中
_             服务器名
_             服务器端口
_         服务器的版本，通常为  或 
                  响应代码
_            服务器时间的 格式
_              服务器时间  格式
_             客户端请求头中的变量，前缀_加上名称的变量，该变量的值即为名称的值
_               匹配任意请求头字段；变量名中的后半部分可以替换成任意请求头字段，如在配置文件中需要获取请求头：，__即可
_
_               请求地址，即浏览器中你输入的地址或域名
_            跳转来源用来记录从那个页面链接访问过来的
__         用户终端浏览器等信息
___
__          可以设置任意响应头字段；变量名中的后半部分可以替换成任意响应头字段，如需要设置响应头，___即可
___
__
___
___
___
__
___原文链接
简介
印记中文的成立主要是为了协助社区更好地翻译与部署文档。最近联合腾讯云一起设计了一套有效提升访问速度及降低流量消耗成本的方案，即  对象存储服务 及  加速方案。本文主要描述方案大体的实现过程，如果你是技术文档的管理者，苦于没有优秀的文档部署方案，可以联系印记中文，我们会提供接入服务。如果你遇到性能问题，我们也可以提供免费的技术咨询服务
群：
官网：
代码存放及构建
一般而言，对公有代码，一般采用    存放及构建方式。而对于私有代码来说，则会直接使用    自有的构建服务。
  
自动构建与部署服务的架构如下图： 
在代码仓库方面，我们需要两个分支，一个是 分支，用于存放文档源码，另一个是  分支，用于存放生成的文档文件。
然后，我们需要配置文件，用于  构建和部署我们的项目，下面是求全配置，表示仅在在 分支有 或者   事件的时候，才会触发构建，使用语言是，版本是 ，首先运行完安装依赖的 之后，再运行 。
      _ _            
那么脚本中，主要就是承担构建、鉴权，以及代码推送的功能。
   第一部份，用于构建代码   
   第二部份，用于与鉴权 =  _={}                {_}    __  __  _  _    _   _
   第三部份，用于向推送代码    _     是生产代码目录， 所跑脚本是   ，最终将代码推送到 分支
那第二部份的   怎么生成呢？其实整个  的鉴权原理不难，用工具成生   公钥与私钥，然后将公钥存放到  的  中，将私钥存放到代码库中，在 推送代码之前添加私钥，那么推送的时候就可以顺利鉴权成功。
那具体怎么生成  呢，具体可以参考这个文档        。
然后，到你的文档本地代码仓库键入以下示例命令：
                _ _
当有以下问题的时候，可 跳过。
     
打开 _ 文件，将内容复制，然后到线上代码仓库  中，添加   。
   
然后安装   ，用于上传   信息到  服务器。上传完后，运行以下命令：
   _
  
使用，将以下代码复制到  中，并且将 _ 文件复制到目录下。记得千万不要上传_ 文件。
    __  __  _  _ 然后使用以下命令进行登陆
  
  
   与    的流程是大体相似的，你可以稍微参考一下上一节的架构图。只是个别流程有细微出入。
生成   与  的办法一样，可参考    。
然后前往 ，或者点击网站左下角头像，进入  ，， ，进行公钥添加。

至于  脚本，也略有一些出入。
   第一部份，用于构建代码   
   第二部份，用于与鉴权 =   _={}                 {_}   _     _   
   第三部份，用于向推送代码    _     是生产代码目录， 所跑脚本是   ，最终将代码推送到 分支

设置 ，是用于在构建完毕后，向部署服务器发起请求，触发自动部署的脚本。只要跟部署服务器约定好  路径，然后根据需要配置好  即可。
 
以下是 设置的截图。
   
    
 
以下是 的  设置截图。

部署服务
腾讯云 
，即对象存储  ，是面向企业和个人开发者提供的高可用，高稳定，强安全的云端存储服务。您可以将任意数量和形式的非结构化数据放入，并在其中实现数据的管理和处理。支持标准的 接口，是非常适合作为静态文件部署存储服务。
首先，创建一个 ，没有备案的域名请选择海外的节点，同时选择  加速后面需要用：

创建后，会进入   的文件列表页面，目前是空的。到 基础配置，中开启静态网站配置。

然后进入域名管理，添加域名。

然后到你的域名管理提供商，配置一下 解析。直接用上图的域名和 值。

如果需要开启 ，还可以去申请  证书，腾讯云可以申请免费的  证书。
腾讯云 
等域名加速部署好后，可以点击  域名配置 中，具体域名的 高级配置，进入  管理界面。
进入 缓存配置，添加一些缓存规则，如    等带有  的资源可以长久缓存，而  等资源则不宜缓存。

然后进入 高级配置，在当中配置 证书 和 开启 。
部署服务器
在部署服务器中，需要部署一个服务，用于监听  或者  发出来  请求，然后根据请求参数，去运行脚本自动将文件部署到腾讯云  存储服务当中。
技术方案可大体如下实行。
监听请求方面，    部署一个小型服务，根据参考运行腾讯云 文件上传脚本，然后用 反向代理技术将请求代理到此小型服务中。
至于 腾讯云  文件上传脚本，本人推荐  与  版本的，尤其是  版本的比较容易安装部署。  工具

本地同步工具

小型服务根据请求参考，先到本地部署好的文档分支代码处，先行更新代码，然后再运行文件上传工具，将文件依次上传到  服务中。
以下是使用 工具的一个简单示例：
   = _  =   =   =    基本配置   = {   _  _    _  }  执行命令方法   {   =  { }{} }  =   {  从请求  参数中获得  和  部署节点区域的值   =  ||   =  ||  { }，{}        {}！   分支代码存放位置   = {}   {  =  {}     }  更新  文件   =  {}           更新  配置   =    {_}  {_}  {}  {}  {}  {_}   筛选要上传的文件或文件夹   = {}   =  = {   ===  {   }   }   上传文件  = {   =    = {}{}   {  =     {}{} {} }  {  =    {}{} {} }  }  = 全球化在整个互联网领域仍是大势所趋，而在红海时代来临的游戏行业，“游戏全球化”已成为近年来的热点。游戏全球化运营，对节点分布、网络稳定、网络加速、安全防护等云端基础能力提出了很高要求。腾讯云作为国内游戏行业领先的公有云，腾讯云的全球化布局一直走在快车道，更好地助力游戏厂商实现全球化运营。本期腾讯云沙龙北京站，与来宾聚焦探讨腾讯云在全球化方面的技术布局，并邀请到了游戏全球化先行者的代表分享实践与洞察。演讲主题：腾讯游戏云全球化实践
嘉宾简介：

马亮   腾讯游戏云资深产品经理曾任畅游游戏公司研发经理、运维经理；现任腾讯云资深产品经理，负责游戏云全球化布局和游戏生态建设。
演讲概要：
游戏出海增长迅猛，新兴市场增长比例超过，全球同服架构渐渐成为游戏的标准框架，如何满足游戏厂商新兴市场的布局需求，如何让全球同服架构更简单、更安全、更可靠，游戏云全球化实践为您解读腾讯云全球化最佳的解决方案和案例分享。
视频回放：我们都知道 _ 有三种可选配置：、、，相应地，基于这三种模式的  分别称为   、、。 同时，我们也知道，  可以支持比较灵活的  规则，可以设置某些库、某些表记录或者忽略不记录。
通常地，我们强烈建议不要设置这些规则，默认都记录就好，在  上也是如此，默认所有库都进行 ，不要设置 、、 规则。 如果非要设置这些规则的话，可能会导致某些场景下或者某些特定的  无法被记录，就需要特别注意了。
我经过比较简单的测试，不同的 _ 可能会导致某些  不被记录的情况总结如下：

上面的测试区分了两种模式，一种是连接时指定了其他数据库，一种是连接时未指定任何数据库，相当于下面的两种方式：
假设规则中的名字叫的话，是规则之外的其他

一种是：连接时指定了规则之外的其他
          

还有一种是：连接时不指定任何
         

，加上  是的缩写，其作用是连接后不读取数据库、表、字段信息。与其相反的选项是 ，也就是连接后会读取数据库、表、字段信息，以便自动补齐
更多情况请读者自行进行测试吧 ： 开发背景
随着网卡性能的飞速发展， 网卡已经大规模普及， 网卡也在逐步推广， 内核在网络数据包处理上的瓶颈也越发明显，在传统的内核协议栈中，网卡通过硬件中断通知协议栈有新的数据包到达，内核的网卡驱动程序负责处理这个硬件中断，将数据包从网卡队列拷贝到内核开辟的缓冲区中，然后数据包经过一系列的协议处理流程，最后送到用户程序指定的缓冲区中。在这个过程中中断处理、内存拷贝、系统调用锁、软中断、上下文切换等严重影响了网络数据包的处理能力。操作系统的对应用程序和数据包处理的调度可能跨  调度，局部性失效进一步影响网络性能。

而互联网的快速发展亟需高性能的网络处理能力，  方案也越来被人所接受，市场上也出现了多种类似技术，如 、、_ 等，其核心思想就是内核只用来处理控制流，所有数据流相关操作都在用户态进行处理，从而规避内核的包拷贝、线程调度、系统调用、中断等性能瓶颈，并辅以各种性能调优手段，从而达到更高的性能。其中  因为更彻底的脱离内核调度以及活跃的社区支持从而得到了更广泛的使用。

 开发框架
 是一款兼顾高性能、易用性和通用性的网络开发框架，传统上  大多用于 、、 等简单的应用场景下，对于复杂的  协议栈上的七层应用很少，市面上已出现了部分用户态协议栈，如 、、、 等，也有用户态的编程框架，如  等，但统一的特点是应用程序接入门槛较高，不易于使用。
 使用纯  实现，充当胶水粘合了 、 用户态协议栈、 、微线程框架和上层应用、，使绝大部分的网络应用可以通过直接修改配置或替换系统的网络接口即可接入 ，从而获得更高的网络性能。
发展历程

  调研下一代  方案应对日益严重的  攻击
 上线  版本权威  解析程序 ，单机  网卡性能达到  万 
 实现用户态简易  协议栈，支持  ，性能达到  万    
 上线 通用网关应用
 完善协议栈和应用层接口的开发框架 ，在腾讯云对象存储， 等业务中上线
 移植  协议栈替换自研协议栈的全新  开源。

 架构

 总体架构如上图所示，具有以下特点

使用多进程无共享架构。
各进程绑定独立的网卡队列和 ，请求通过设置网卡  散落到各进程进行处理。
各进程拥有独立的协议栈、 表等资源。
每个  节点使用独立的内存池。
进程间通信通过无锁环形队列_进行。
使用  作为网络  模块，将数据包从网卡直接接收到用户态。
移植    协议栈到用户态并与  对接。

 协议栈
原本  使用自己开发的  协议栈，但是随着腾讯云各种复杂业务的接入，原有协议栈已越来越不能满足需求，继续研发并维护一个完整的协议栈将耗费大量的精力，所以决定使用开源的协议栈来代替原有协议栈。在调研了多种协议栈之后，考虑到协议栈的稳定性、完整性、社区活跃性、生态完善程度等因素，最终决定将  协议栈移植到用户态，提供了完整的协议栈功能并可以快速跟进社区对协议栈的改进。
主要修改：

调度：对    的内核线程、中断线程、定时器线程、、 等进行了去除。
锁：对    的锁操作进行了去除，包括 、、、、 等。
内存相关：、___、、_、 等实现。
全局变量：、、、 等初始化。
环境变量：、 实现。
_：_。
时钟：、、、定时器等实现。
其他： 和  的  转换、胶水代码、移除了不需要的功能模块等。

典型  场景性能测试
以下分别为使用  中的  在  网卡下测试  短连接和长连接小包 大小为  字节的性能表现，实际带宽性能会随着  的增加而增加，并可达到网卡线速。
下图中的  和  都是原生 ， 表示网卡队列中断到不同 ，另外的是采用系统默认配置，未将网卡队列中断到不同 。


更多场景下的  性能测试数据请关注后续文章。
 交流

 欢迎业务使用、 或者加入开发、 顺便  一下我们的项目，有任何问题可以提  联系我们。
 官方网站，官网资源持续完善中，如果您的项目使用了 ，也希望通知我们，让我们加入到应用列表中。
微信公众号：搜索公众号关注，会不定期发布  的技术细节、使用技巧和应用场景等文章，同时欢迎投稿。
微信讨论群：我们建立了  讨论群，欢迎联系我们拉您加入。接上文《 海量之道系列文章之弱联网优化 一》
 快链路
我们需要有一条相对快速、相对顺畅、相对稳定的网络通道承载业务数据的传输，这条路的最好是传输快、不拥堵、带宽大、收费少。生活中做个类比，我们计划驱车从深圳到广州，如果想当然走广深高速十之八九要杯具，首先这个高速略显破败更像省道，路况不佳不敢提速；其次这条路上的车时常如过江之鲫，如果身材不好操控不便，根本就快不起来；最后双向六车道虽然勉强可以接受，但收费居然比广深沿江高速双向八车道还贵；正确的选路方案目前看是走沿江高速，虽然可能要多跑一段里程，但是通行更畅快。实际上，真实情况要更复杂，就如同【图二 有线互联网和移动互联网网络质量差异】所示，漫漫征途中常常会在高速、国道、省道、田间小道上切换。
如何才能做到快链路，且听下面分解。
 协议栈参数调优
纯技术活，直接上建议得了，每个子项争取能大致有个背景交待，如果没说清楚，可以找。
①　控制传输包大小
控制传输包的大小在字节以下。暂时不讲为什么这样建议，先举个例子来类比一下，比如一辆大卡车满载肥猪正在高速上赶路，猪笼高高层叠好不壮观，这时前方突然出现一个隧道限高标识，司机发现卡车超限了，这下咋整。方案一，停车调头重新找路，而且十之八九找不到，最后只能哪来回哪；方案二，把其中一群猪卸下来放本地找人代养，到达目的地卸完货回来再取，你别说，这个机制在协议栈中也有，学名“分片”，后面会专门介绍。这个故事侧面证实美国计算机科学家也曾经蹲在高速路边观察生猪超载运输的过程，并饱受启发。且慢，每次遇到问题，想到一些方案后我们都应该再扪心自问：“还有没有更好的办法呢？”。当然有，参照最近流行的说法，找个台风眼，把猪都赶过去，飞一会就到了，此情此景想想也是醉了。
回归正题，概括的说，我们设定这个阈值，目的是减少往复，提高效能。因为网络中也有类似高速限高的规定，如果在超限时想要继续顺畅传输，要么做分片要么把应用数据拆分为多个数据报文意指因为应用层客户端或服务器向对端发送的请求或响应数据太大时，协议栈控制机制自动将其拆分为若干独立数据报文发送的情况，后面为简化讨论，都以分片这个分支为代表，相关过程分析和结论归纳对二者均适用。而一旦一个数据报文发生了分片，便会在数据链路层引入多次的传输和确认，加上报文的拆分和拼接开销，令得整个数据包的发送时延大大增加，并且，分片机制中，任何一个分片出现丢失时还会带来整个数据报文从最初的发起端重传的消耗。有点枯燥了，我们从一些基础概念开始逐步深入理解：
 【以太网】
这个术语一般是指数字设备公司  、英特尔公司      和    公司在   年联合公布的一个标准，它是当今采用的主要网络技术。以太网采用一种称作      的媒体接入方法，其意思是带冲突检测的载波侦听多路接入      。随着以太网技术的不断演进，传输速率已由最初的 发展到如今、、等。
我们现在使用的网络协议，基本上都在以太网上传输，数据被封装在一个个以太网包中传递，这些以太网包就是那一辆辆运猪的大卡车。以太网包的封装格式可以参考【图三 以太网的封装格式 】，很容易看出以太网包能传输的有效“数据”大小在  字节之间。如果我们把以太网看做是运猪的高速公路，能承载有效数据的最大值看作是高速路上隧道的限高，那么这个限高在协议中学名是  ，最大传输单元。属于链路层制定的逻辑并非物理特性限制，所谓无规矩不成方圆。

【图三 以太网的封装格式 】
 【数据报】
数据报被封装在以太网包的“数据”中，通过【图四 数据在数据报中的封装】可以看到，一个数据报包括包头、包头和数据三个部分，其中两个包头分别用于层和层的报文传输控制，可以理解为运猪的大卡车和猪笼。数据则是有效载荷，可以理解为那群肥猪。

【图四 数据在数据报中的封装】
我们再来详细看看数据报，如【图五 数据报格式及首部中的各字段】所示，一个标准数据报中，包头大小为字节，如果加上可选项，则包头最大可以达到字节。

【图五 数据报格式及首部中的各字段】
数据报如【图六 数据报格式及首部中的各字段】所示，一个标准包头大小为字节，如果加上可选项，则最大也可以达到字节。

【图六 数据报格式及首部中的各字段】
 【 】
    ，最大报文段长度，后面均简称表示协议栈一次可以传往另一端的最大数据长度，注意这个长度是指报文中的有效“数据”即应用层发出的业务数据部分，它不包括报文包头部分，我们可以把它理解为卡车能装运生猪的最大数量或重量。它是选项中最经常出现，也是最早出现的选项，占字节空间。
是在建立链接的三次握手过程中协商的，每一方都会在或数据报文中通告其期望接收数据报文的也只能出现在或数据报中，说是协商，其实也没太多回旋的余地，原因一会讲。如果协商过程中一方不接受另一方的值，则协议栈会选择使用默认值：字节。
有了以上的基础知识，我们就能比较清晰的描述出以太网、、数据报文和之间的关系了，如【图七 数据报、在以太网格式中的关系】所示，和关系用公式表达就是：
 = 包头  包头  ；
对照到我们肥猪装运的例子，自然得出公式如下：
限高 = 卡车高度  笼子高度  生猪数量或重量；

【图七 数据报、在以太网格式中的关系】
注：  是指帧校验值；
实际上值太小或太大都不合适。
太小比如设为字节，那么为了传输个字节的数据，得搭上包头的字节和包头的字节，如果再加上链路层、物理层的其它开销，显然效率低下不够环保，这就如同卡车跑一趟只拉一头肥猪一样，相当坑。
是不是越大越好呢，这也符合我们的正常思维逻辑，就好比养猪场和买家都希望卡车一趟能多运几头肥猪，可以加快资源周转效率。但实际情况是如果设得太大，封装的数据过多，不但传输时延会增加，还很可能因为超过的限制，使得在层传输过程中发生分片又是它，忍着，马上就会展开了，接受方在处理分片包所消耗的资源和处理时间都会增大，前面也提到过，如果分片在传输中出现分片丢失，哪怕只是丢失一个分片，都会引起整个数据报的重传，这是因为层本身没有设计超时重传机制，有兴趣可以研读《详解 卷一：协议》了解详细细节。由此可以想见网络开销会因此大大增加。
协议设计者是不希望分片出现的，现在有点明白前面说协商回旋余地不大的含义了吧。另外，同滑动窗口和拥塞控制也有关联，后续谈到相关话题时我们再细聊。
 【分片】
快乐运猪路遇限高紧急应对方案二闪亮登场，数据报文传输过程中，任何传输路径上节点的层在接收到一份要发送的数据报文时，首先会通过路由选路判断应从本地哪个网络接口把数据报转发出去，随后查询获取该网络接口的，如果数据报文长度超过了这个，且该数据报文没有设置 ，不要分片，非缺省值标志位，就得做分片，即把接收到的数据报文拆分成多个更小不超过该接口的数据报文继续传输，并且，分片的数据可能在路上会被再次分片，分片到达最终目的地后会按顺序重新组装还原，【图五 数据报格式及首部中的各字段】中位标志和位片偏移就是用来干这个的。
为了避免分片，协议设计者在层实现了协商机制，设想如果最终确定的小于路由路径中最小的那个，那么就能避免分片的发生。
在链接三次握手过程中，网络通讯的两个端点在和数据报文中分别把自己出口发给对端，以便对方了解自己的“限高”水平，最终控制发出的应用数据报文大小，达到避免分片的目的。
如果运气好，路由路径上的路由设备会积极参与三次握手过程中协商机制，一旦发现自己出口的比数据报文中的那个小，就会主动修改数据报文中的，这样整个路由链路端到端这条“高速路”的整体“限高”水平就准确清晰了。
通过【图八  协商过程】，可以了解上述 的协商过程。注意，这个“完美”方案需要运气好才行。因为中间路由设备五花八门，不能支持或者不愿支持协商的情况时有发生。想让大伙都积极支持协商的美好愿望，就如同满怀对全世界各国政府官员实施财产公示的期许，结果是一样一样的。

【图八  协商过程】
快乐运猪路遇限高紧急应对方案一有没有发挥空间呢？很好的问题，聪明的协议设计者当然不甘心，于是利用前面提到的标志位设计了一个叫做路径发现的机制就用到了方案一的原理，如果数据报文的位标志字段中的位置为，则层遇到需要分片时，就会选择直接丢弃报文，并返回一个相应的出错报文，看到了吧，此路不通，请带领群猪原路返回。这个方案运作成本颇高。不继续深入描述了，有兴趣可以研读《详解 卷一：协议》。
至此，我们可以得出如下结论，数据报文大小超过物理网络层的限制时，会引发分片，从而增加时空开销。
因此，设定合理的至关重要，对于以太网值建议是字节。什么，你的数学是体育老师教的吗？前面说以太网最大的传输数据大小是字节，数据报文包头是字节，报文包头是字节，算出来怎么也得是字节呀。如果回答是因为很多路由设备比如路由器把设定为字节，大伙肯定不干，回忆一下和的数据报包头都各有字节的可选项，中还需要为这些可选项留出空间，也就压缩了的空间。要是再追问为啥这个值不是字节，那就有点过分了。
那么问题来了，控制“限高”哪种方案才最强。我们尝试探讨一下。
接《 海量之道系列文章之弱联网优化 三》 什么是 
编程语言组织程序，都有一定的可见范围，比如的包、的文件。就像我们平时使用的文件夹一样，有了这些组织机制，变量、函数的命名在一定程度上就可以重复。
但在程序链接时，这些机制多少都要失效一些，就像每个小朋友在家都叫宝宝，到了幼儿园就没办法通过宝宝来区分彼此了。为了解决名字的唯一性，就需要 技术。
其实说白了就是对名字进行重新编码的一种规则。比如使用随便打开一个文件，或是链接时，我们有时候可以看到一些类似与下面这样的古怪字符串：
__
这就是经过 处理后的符号。
 中的 
的复杂度相对于肯定是复杂很多的，其中表现之一就是的名字管理，比如支持重载、支持类、命名空间等。不同的函数可以使用相同的函数名、不同的类可以有相同名字的成员变量。这样的 就会比复杂很多。
当然，再复杂的，也都不过是各种 的一碟小菜。对于的 规则，标准并没有做具体的规定，但各个编译器平台形成了一些事实性的标准，比如的一个简单规则：
          
  = _  


  =   

  =   
就是一个类的成员函数可能会被 编码为：_长度名字
  中 的相关工具
 工具集中提供了 相关的工具，最典型的和，使用举例如下：
 __
_     

  _ |  
  _     
  _     
有了这些工具，再也不怕链接报错和二进制分析时看到的一些奇怪符号了。腾讯云商业智能分析产品由北京永洪商智科技有限公司提供，永洪一站式大数据分析平台

普通表格常见设置
表格组件是以表格的形式展现数据的载体，表格可以绑定任意一查询的多个字段。根据是否给字段使用统计函数来区分，可划分为细节数据表格和汇总表格。细节数据表是没有汇总统计函数的表，显示的都是具体的细节数据；汇总表格是使用了汇总统计函数的表，按照维度分组，把数值类型的数据汇总统计。在数据分析过程中，通过表格显示数据是非常常见的操作。接下来，简要介绍一下产品中普通表格的常见设置。
一、组件格式修改
表格常见的设置组件格式，这里可以修改单元格内容的对齐方式，单元格字体，表格边框，字体颜色和背景颜色，组件透明度。、单元格对齐方式在表格组件上右击，选择组件格式，在对齐页签中设置对齐方式如图所示。图注：勾选自动换行可实现单元格内容自动换行
、设置字体在表格组件上右击，选择组件格式，在字体页签中设置字体如图所示。图注：这里修改字体是修改整个表格组件的字体，包括标题、表头和表格内容的字体。若是要单独修改标题或单元格的字体，选中单元格，右击局部格式中的字体进行修改。
、设置表格边框在表格组件上右击，选择组件格式，在边框页签中设置表格边框，可以修改边框颜色、线条粗体。
、设置颜色在表格组件上右击，选择组件格式，在颜色页签中设置字体颜色和表格背景颜色，背景颜色可以设置为单色、双色、图片等。
二、局部格式
局部格式和组件格式不同的是：局部格式是针对所选中的内容设置的格式修改，如单元格，表标题，表头等，组件格式是针对组件设置的格式修改。在数据分析中，在表格的操作中，设置标题的格式，表头格式等是很常见的，这些修改都需要通过局部格式来修改。局部格式提供格式、对齐、字体、边框、颜色、透明度五个方面的设置，其中后四项与组件格式中的设置方式是基本一致的，只是针对的对象不同。接下来说一下局部修改中的格式，在格式页签中主要是修改文字的格式，如图所示，针对单元格的格式对话框，这里可以设置单元格中显示内容的数据类型及显示格式。如图所示，如果单元格中的内容是日期类型，可以在这里设置日期显示格式。图图
三、合并单元格
在表格的使用中常会用到合并单元格的功能，产品合并的单元格的操作步骤如下：、页面空白处右击，选择元数据模式，如图所示图、把需要合并的单元格选中，右击合并单元格即可，如图所示。然后在页面空白处右击选中取消元数据模式即可。图
注：若是想要某一列中相同内容的单元格合并，直接选中元数据模式下对应列的单元格右击，选择合并单元格即可。
四、高亮设置
在数据分析中，常有一些数据需要着重显示，如利润低于目标值，数据显示为红色等。这个可以高亮功能实现。高亮的设置步骤如下：、表格组件需要设置高亮效果的列对应的单元格上右击，选择高亮，进入高亮设置界面，如图所示。图注：高亮效果是针对某列，而不是这个表格组件。、由于一个表格可以设置过个高亮，每个高亮在高亮列表中右击选择新建高亮，如图所示，点击后进入如图所示的高亮过滤器设置界面。图、设置高亮过滤器，这里过滤器跟普通过滤器设置不同的是，除了可以根据数据集中数据列来设置，还可以设置每隔几行显示不同的格式，如图所示。这里是每三行显示不同的格式。、设置满足高亮条件的数据展示形式，可以从字体、颜色及展示格式进行设置，如图所示。图、设置后显示效果如图所示。图情感分类是对带有感情色彩的主观性文本进行分析、推理的过程，即分析对说话人的态度，倾向正面，还是反面。它与传统的文本主题分类又不相同，传统主题分类是分析文本讨论的客观内容，而情感分类是要从文本中得到它是否支持某种观点的信息。比如，“日媒：认为歼能够抗衡，这种说法颇具恭维的意味。”传统主题分类是要将其归为类别为“军事”主题，而情感分类则要挖掘出日媒对于“歼能够抗衡”这个观点，持反面态度。
这是一项具有较大实用价值的分类技术，可以在一定程度上解决网络评论信息杂乱的现象，方便用户准确定位所需信息。按照处理文本的粒度不同情感分析可分为词语级、短语级、句子级、篇章级以及多篇章级等几个研究层次。按照处理文本的类别不同，可分为基于新闻评论的情感分析和基于产品评论的情感分析。
文智系统提供了一套情感分类的流程，可以对句子极别的评论进行分析，判断情感的正负倾向。接入业务的用户只需要将待分析文本按照规定的协议上传，就能实时得到情感分析的反馈。如果持续上传不同时间段的评论、综合分析，还能得到事件的发展趋势，或者产品的情感走势等。
一常用分类方法介绍
文本分类方法一般包含如下几个步骤：训练语料准备、文本预处理、特征挖掘、分类算法选择、分类应用。具体的分类流程可以参考另一篇文章《文智背后的奥秘—自动文本分类》。这里，对一些常用的特征挖掘和分类算法做简单的介绍。
特征挖掘方法
常见的特征选择方法有：、卡方、互信息、信息增益、统计量、交叉熵、判别式等方法，这里介绍一下工业上常用的两种方法。
 
的主要思想是：如果某个词或短语在一篇文章中出现的频率高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。这里介绍一种对  的傻瓜理解法：
：词频，表示特征在文档中出现的次数，比如一篇谈论乔布斯的文章，可预期“”、“苹果”的值为较高。
：包含特征的文档数，越高，表示特征对于衡量文档之间的区别作用低。比如“我”、“的”这样的词，一般最高。
：定义为 =||，||为所有文档数。与成反比，值越高，表示特征对区别文档的意义越大。最终定义：=
 信息增益
信息增益  是公认较好的特征选择方法，它刻画了一个词语在文本中出现与否对文本情感分类的影响，即一个词语在文本中出现前后的信息嫡之差。傻瓜式理解下信息增益：

其中，是总类别数，是第类出现的概率，若每类平均出现，则=
是出现词语的文档数除以总文档数，否=
|即出现时，出现的概率，等于出现且属于的文档数除以所有出现的文档总数。
|否即不出现但属于的概率，等于未出现但属于的文档总数除以未出现的所有文档数。
分类算法
常见的分类算法有，基于统计的算法、贝叶斯算法、算法、支持向量机方法，基于规则的决策树方法，和较为复杂的神经网络。这里我们介绍两种用到的分类算法：朴素贝叶斯和支持向量机。
朴素贝叶斯
贝叶斯公式：|=|
先验概率通过计算训练集中属于每一个类的训练样本所占的比例，类条件概率|的估计—朴素贝叶斯，假设事物属性之间相互条件独立，|=∏|。
朴素贝叶斯有两用常用的模型，概率定义略有不同，如下：设某文档=…，是该文档中出现过的单词，允许重复。

多项式模型：

先验概率= 类下单词总数整个训练样本的单词总数。
条件概率|=类下单词在各个文档中出现过的次数之和 类下单词总数||

伯努利模型：

先验概率= 类下文件总数整个训练样本的文件总数。
条件概率|=类下包含单词的文件数类下单词总数
通俗点解释两种模型不同点在于：计算后验概率时，对于一个文档，多项式模型中，只有在中出现过的单词，才会参与后验概率计算，伯努利模型中，没有在中出现，但是在全局单词表中出现的单词，也会参与计算，不过是作为“反例”参与的。
 支持向量机模型
展开来说较为复杂，这里借助两张图帮助概念性地解释一下。对于线性可分的数据，可以用一超平面=将这两类数据分开。如何确定这个超平面呢？从直观上而言，这个超平面应该是最适合分开两类数据的直线。而判定“最适合”的标准就是这条直线离直线两边的数据的间隔最大。

而对于线性不可分的数据，则将其映射到一个更高维的空间里，在这个空间里建立寻找一个最大间隔的超平面。怎么映射呢？这就是的关键：核函数。
现在常用的核函数有：线性核，多项式核，径向基核，高斯核，核。如果想对有更深入的了解，请参考《支持向量机通俗导论理解的三层境界》一文。
二情感分类系统实现
情感分类与主题分类除了第一章提到的挖掘信息不同外，处理的文本也大不相同。情感分类主要处理一些类似评论的文本，这类文本有以下几个特点：时新性、短文本、不规则表达、信息量大。我们在系统设计、算法选择时都会充分考虑到这些因素。情感分灰系统分为在线、离线两大流程，在线流程将用户输出的语句进行特征挖掘、情感分类、并返回结果。离线流程则负责语料下载、特征挖掘、模型训练等工作，系统结构如图所示：

图 情感分类系统框架图
 语料库建设
语料的积累是情感分类的基石，特征挖掘、模型分类都要以语料为材料。而语料又分为已标注的语料和未标注的语料，已标注的语料如对商家的评论、对产品的评论等，这些语料可通过星级确定客户的情感倾向；而未标注的语料如新闻的评论等，这些语料在使用前则需要分类模型或人工进行标注，而人工对语料的正负倾向，又是仁者见仁、智者见智，所以一定要与标注的同学有充分的沟通，使标注的语料达到基本可用的程度。
迄今，我们已对涵盖电商、新闻、影视、音乐、等类别的多个站点评论进行抓取，累计已有亿标注语料，每天新增标注语料多万。

极性词挖掘
情感分类中的极性词挖掘，有一种方法是“全词表法”，即将所有的词都作为极性词，这样的好处是单词被全面保留，但会导致特征维度大，计算复杂性高。我们采用的是“极性词表法”，就是要从文档中挖掘出一些能够代表正负极性的词或短语。如已知正面语料“：微信电话本太赞了！能免费打电话，推荐你使用哦”，这句话中我们需要挖掘出“赞”、“推荐”这些正极性词。分为以下两步：
文本预处理 语料中的有太多的噪音，我们在极性词挖掘之前要先对文本预处理。文本预处理包含了分词、去噪、最佳匹配等相关技术。分词功能向大家推荐腾讯的分词系统，功能强大且全面，拥有短语分词、词性标注等强大功能。去噪需要去掉文档中的无关信息如“”、标签等，和一些不具有分类意义的虚词、代词如“的”、“啊”、“我”等，以起到降维的作用。最佳匹配则是为了确保提出的特征能够正确地反映正负倾向，如“逍遥法外”一词，如果提取出的是“逍遥”一词，则会被误认为是正面情感特征，而“逍遥法外”本身是一个负面情感词，这里一般可以采用最长匹配的方法。
极性词选择 文本预处理之后，我们要从众多词语中选出一些词作为极性词，用以训练模型。我们对之前介绍的方法略作变化，用以降维。因为我们训练和处理的文本都太短，和值大致相同，我们用一个值就可以。另外，我们也计算极性词在反例中出现的频率，如正极性词“赞”必然在正极性语料中的值大于在负极性语料中的值，如果二者的差值大于某个域值，我们就将该特征纳入极性词候选集，经过人工审核后，就可以正式作为极性词使用。
目前，我们已挖掘出 极性词，通过人工审核的有  个，每天仍会从语料中挖掘出 个极性词。

极性判断
极性判断的任务是判断语料的正、负、中极性，这是一个复杂的三分类问题。为了将该问题简化，我们首先对语料做一个主客观判断，客观语料即为中性语料，主观语料再进行正、负极性的判断。这样，我们就将一个复杂三分类问题，简化成了两个二分类问题。如下：

在分类器选择中，主客观判断我们使用了上节介绍的支持向量机模型。而极性判断中，我们同时使用了朴素贝叶斯和支持向量机模型。其中朴素贝叶斯使用人工审核过的极性词作特征，而支持向量机模型则使用全词表作为特征。两个模型会对输入的语料分别判断，给出正、负极性的概率，最后由决策模块给出语料的极性。

在朴素贝叶斯模型中，我们比较了多项式模型和伯努力模型的效果。伯努力模型将全语料中的单词做为反例计算，因为评测文本大多是短文本，导致反例太多。进而伯努力模型效果稍差于多项式模型，所以我们选择了多项式模型。
支持向量机模型中，我们使用的是台湾大学林智仁开发的工具包，这是一个开源的软件包，可以解决模式识别、函数逼近和概率密度估计等机器学习基本问题，提供了线性、多项式、径向基和形函数四种常用的核函数供选择。 使用的一般步骤是：

按照软件包所要求的格式准备数据集；
对数据进行简单的缩放操作；
考虑选用 核函数；
采用交叉验证选择最佳参数与；
采用最佳参数与 对整个训练集进行训练获取支持向量机模型；
利用获取的模型进行测试与预测。

在我们的模型中，经过几次试验，选用的高斯核，自己调的参数。文智平台当前情感分类效果：

业界效果：  中文倾向性分析评测

备注：

语料来主要源于个领域手机、翡翠、保险的微博数据；
针对观点句进行情感判断；
测试集是篇人工标注微博评论。
垂直领域的情感分类

上述介绍的是我们通用的情感分类系统，面对的是通用的主观评论语料。但在一些领域中，某些非极性词也充分表达了用户的情感倾向，比如下载使用时，“卡死了”、“下载太慢了”就表达了用户的负面情感倾向；股票领域中，“看涨”、“牛市”表达的就是用户的正面情感倾向。所以我们要在垂直领域中，挖掘出一些特殊的表达，作为极性词给情感分类系统使用：
垂直极性词 = 通用极性词  领域特有极性词
该系统即为垂直领域的情感分类系统。目前，我们已对社会事件、、电影几个领域建立了垂直情感分类系统。领域的覆盖正在不断扩大……
页面展示
情感分类系统已于线上正常运行，并为兄弟部门服务每天会对当日热门事件进行舆论分析统计，并给出主流正负面代表评论。移动端展示请观注文智公共号，页展示请获得权限后登录 查看。页面效果如下：

 系统优化
情感分类的工作，我们还在继续。我们在现在和未来还可以做更多的工作来优化我们的情感分类系统：

挖掘更多的极性词多领域
尝试不同的分类器，调优现有的模型
句式识别：否定句，转折句，排比句等……
语料清洗：识别水军评论和用户评论
极性词扩展：采用近义词、反义词等方法，将挖掘的极性词扩展更多

三总结：
 文智平台情感分类系统基于多个领域数、亿标注语料的学习，可对众多评论数据进行倾向性分析，掌握用户舆论走向。尤其是对新闻、影视、产品等领域句子极别的评论数据，倾向性分析更为准确、有效。系统目前已上线运营，并为兄弟部门提供舆论倾向服务。系统使用简单、效果可靠，期待能为其他业务部门提供更为广泛的应用。
 欢迎有需求的团队联系我们，使用腾讯文智自然语言处理。

相关推荐 【 文智背后的奥秘 】系列篇：结构化抽取平台 【 文智背后的奥秘 】系列篇：文本聚类系统 【 文智背后的奥秘 】系列篇：关键词智能提取作者：邹世杰

前言
年月号微信小程序正式上线，小程序不需要安装就能使用，依托微信强大的生态环境，能做到很多所不能做的事情。从微信小程序发布这段时间，陆陆续续开发了不少小程序相关的项目，总结了一些通用性的组件，但是对于小程序如何做测试，依然是一头雾水，直到做了不少的项目，积累的一些经验和开源库之后才理清如何做测试，下面将会介绍如何对小程序做测试和单元测试。
工具的准备







介绍

这个应该不用多做介绍了，不过这次中要求版本应该大于，因为要求最低版本是，但是因为官方示例中大量使用  等新特性，所以需要使用  或更高版本的 ，能让异步回调代码更加简洁，不然整个代码都是

 团队出品的一款更友好的   ，用于代替用户在页面上面点击、拖拽、输入等多种操作，常见的使用场景还是应用到自动化测试，可以对页面进行截图保存为图片或者，解决爬虫无法实现的一些操作异步加载页面内容 。
类似的工具：






可以让小程序脱离开发者工具或者微信客户端直接运行在浏览器上面，后台使用，提供小程序的模拟返回、等，前端实现了  层、 层和控制层之间的相关通讯逻辑。

测试框架，在浏览器和环境都可以使用，通过测试框架，可以为你的代码添加相应的测试用例，使得项目代码更加强健。

是一个模式的断言库，在和浏览器环境都能运行，通俗易懂，断言类型和方式丰富，搭配，江湖人戏称为”抹茶“
配置环境

     —   

在安装有可能会出现以下报错
       ___     
        _
      \\_\\\
      
      
      
        __
      __
      __
      
      
      \\_\\
其实是因为下载完包之后有执行 去下载实验版，但是由于网络的原因，下载失败了，我们可以避免缺省的下载 ，通过设置环境变量来阻止 ___=然后手动去下载，上面有给出链接_

直接看官方给出的
  = 
  = {
  这里和官方不一样的就是，需要手动指定目录所在的地址上面链接下载之后解压，为则不会打开
    =  {  }

  相当于新建选项卡
    =  
  跳转到指定
   
  截图
   { }
  关闭页面或者选项卡
   
}
上面几行代码其实就是相当于我们日常的一些操作：打开新建选项卡输入并回车页面截图保存，也可以看出是站在使用者的角度去设计。
跑通测试之后，来试试小程序这边，首先必须让小程序跑在上面，就要用到了。
 直接在小程序根目录上面执行然后打开，访问 ，就可以看到小程序运行在上了，接下来要让去抓取小程序里面的内容，直接上代码
  = 
  = 
  = {
          =  {  }
          =  
        设置展示的设备
          
        多一个参数，指跳转之后等待网络空闲之后再执行下一步操作，没有这个的话，截图很有可能是白屏，因为内容还没渲染出来
          { }
        小程序的内容其实是放在一个里面，外面是无法直接抓取到里面的内容，所以这里需要获取页面所有的
          =  
        根据的属性来获取正确的
          =  =  === 
        在上下文环境中获取需要抓取的内容
          =   = {
        上下文执行环境，跟一致
              = 
              = 
        }
           
         

}
直接来看页面执行的效果

这样我们就能拿到小程序的内容，便于我们后续的单元测试，接下来我们可以加入”抹茶”来测试输出是否符合预期，先上代码
  = 
  = 
  = 
   = {
       测试帐号   = {
          = {
            小程序内容获取代码跟上述一致
            
             测试帐号
            
        }
    }
}
运行效果

结语
小程序其实也有上线一个云测试，但是我觉得有个不好的地方，假如你的小程序是依赖于后台返回数据作为展示，那么你必须先上线才能使用云测试，不够灵活，更希望有一个能自己数据来测试不同情况下的小程序的展示。
本篇文章介绍使用和来对小程序做测试，对于测试环境和正式环境还是有差异的，比如小程序是不支持这个的，但是测试环境是可以跑通的，当然测试环境下面也可以通过某种方式比如来禁用不支持小程序的，从而达到测试环境尽可能的贴近小程序的正式环境。当然更希望的是小程序官方能给出相应的单元测试方案吧。背景
机器学习主要分为分类和回归两类。上一篇文章我们通过实例介绍了利用决策树和随机森林来做分类。 这次我们来预测房价，实际演练一下语言中的回归分析模型。
数据集
这次选择的竞赛网址为：
竞赛给了已经成交的近座房子的个特征，然后让我们根据这些特征来预测房子的销售价格。数据集包含的特征字段相当多，除了地段、面积、层数等基本信息外，还有诸如地下室、离街道的距离、房屋的外墙材料等在国内完全不会关心的特征。 在房价如此疯狂的中国，基本只需要看到地段和面积就可以估算出来价格了。
数据熟悉
在动手构造模型之前，我们还是先熟悉一下数据的缺失和分布情况。
首先下载训练数据和测试数据，放在目录下，然后合并训练数据和测试数据。其中就是这次要预测的房价字段。
读取训练数据集和测试数据集
  
  


 合并两个训练集
  
   
首先查看一下各个变量的情况。这里变量很多，在附件中附上变量的具体解释。

结果：
        
                  
                  
                    
                 
                 
                     
                  
                   
                    
                  
                  
                  
                   
                     
                     
                   
                     
                 
                 
               
                
                  
                   
                    
                    
                     
                  
                  
                  
                     
                   
                   
                   
                   
                  
                   
                  
               
                 
                    
                  
                     
                     
               
               
                
               
                
                
                
                
                
                
                    
                
                     
                  
                    
                     
                 
                   
                  
                  
                     
                     
                     
                  
                 
               
                  
                 
                
                     
                  
                    
                 
                  
                  
                   
                  
             
变量主要分为两类，一类为数字类型，一类为因子类型。
 获取数据中 变量的个数
    

结果
  
       
总体来看，数据集一共个变量、个记录，其中个因子变量，个数字变量
特征处理
从上面的变量取值情况可以看到数据集中有很多变量存在缺失值，所以第一步我们要处理缺失值。
首先按照各变量中的缺失值所占比例排序
 统计所有变量的缺失值
      

 按照缺失率排序
   =

执行结果 — 这里只给出了有缺失值的变量，并经过人工注释
 变量           缺失数   缺失比例  含义
                 泳池质量
            特殊的设施
                  房屋附近的小巷
                  房屋的篱笆
            壁炉的质量

                房子同街道之间的距离

             车库
         
           
           
           

              地下室
        
            
        
        

             外墙装饰
          

               其他
           
        
        
          
         
         
          
          
           
         
          
         
          
          
            
然后查看有缺失值的变量的概况。这里只给出了缺失值比较多的变量
 查看有缺失数据的变量

结果
                              
                                   
                                  
                             
                                       
                                        
                                                         
                                                        

              
                                  
                           
                           
                                
                               
                                
                                                    

                
                                     
                                    
                                     
                                
                                
                                                    
                                                       

                             
                             
                             
                                  
                                        
                                       
                                                 
                                                               

                         
                           
                          
                        
                               
                        
                        
                                                

                          
                                    
                            
                           
                                 
                        
                                    
                                      

                    
                      
                
                 
                   
                 
                
                            
缺失数据的变量有很多，处理情况可以分为如下几类：
直接数据集中剔除哪些存在大量缺失值的变量
缺失量比较多的、、、、是由于房子没有泳池、特殊的设施、旁边的小巷、篱笆、壁炉等设施。 由于缺失量比较多，我们直接移除这几个变量。
 删除如下变量
    
  
将作为新的一个因子
查看变量的描述文件可以知道，车库相关的五个变量、、、、也是由于房子没有车库而缺失。
同理，、、、、五个变量是关于地下室的，都是由于房子没有地下室而缺失。
此类变量缺失的数量比较少，直接用来替换缺失值。
 将如下变量的值填充为
  
  
     
{
    = 
  
}
其中为车库的年份，我们用房子的建造年份来替代
 单独处理车库年份
  
人工补齐缺失值
对剩下的变量我们依次查看其详细数据，可以分别如下处理。
变量  房子到街道的距离
这是一个数值变量，我们用中位数来补充。
 用中位数来填充
    = 
变量  外墙装饰材料
这个变量对价钱的影响应该不大，中的用它本身的来代替
 用补充
  
变量  外墙装饰材料的面积
这个缺失值对应着的值，应该将用来替代
 用补充
  
变量  没有区分度，直接丢弃
 删除变量 
  
变量         则是由于不存在相应的设施而缺失，这些变量都是数字变量，所以都补充为即可。
 由于设施缺失，导致数量缺失，补充为 
  
          
变量这些变量都是因子变量，并且只有几个缺失值，直接用最多的因子来代替
 用最高频的因子来补充
  
          
生成训练集
经过一系列的缺失值补齐之后，我们看到最后剩余个变量，并且不存在缺失数据。我们通过是否为来将数据集拆分为训练集和测试集，为后面的模型训练做准备。
 通过是否为空来区分训练集和测试集
   
   
回归模型
线性回归的最主要的问题就是自变量的选择。选择那些与最后预测的响应变量相关度比较高的特征变量是模型成功的第一步。变量选择有很多方法，其中最关键同时也是最直接的方法就是分析师根据业务场景人工筛选。我们首先尝试这种变量选择的方法，作为我们模型的第一步。
接下篇《 实战     》本文的目标读者是毫无机器学习经验的码农，不讨论机器学习背后的数学原理，不讨论算法实现的细节，不讨论如何调参，只描述一些基本概念和实践方法，方便没有这方面经验的同学入门。不了解机器学习模型背后的数学原理，并不影响应用机器学习解决实际问题；关于机器学习与数学的关系，打个比喻：不懂发动机构造的老司机照样可以玩漂移，但超一流的赛车手对赛车的各个部件都非常熟悉。为了简便，后文会把“机器学习”简写为“” 。
 什么是机器学习
本节通过一个示例，比较“直接编程方法”与“机器学习方法”在问题求解思路上的差异，简要说明什么是机器学习。示例问题是大部分码农初学编程时，都解决过的“水仙花数”问题。
 直接编程方法
直接编程解决水仙花数问题，一般的做法，首先根据“水仙花数”的定义设计算法水仙花数的定义：一个位的非负整数，其各位数字的次方和等于该数本身；然后，使用某种编程语言实现该算法。伪代码如下：

 __ 

{

         如果是负数，返回；

         得到的总的位数，以及各个位上的数值、、…、；

         如果等于    …  ，返回；否则，返回。

}
给定输入，函数__的输出给出了判定结果。
 机器学习方法
用如何解决水仙花问题？并不直接根据“水仙花数的定义”编程，而是面向“数据”编程。方法一般可粗略分为四个步骤：收集数据、选择模型、训练模型、应用模型。
首先“收集数据”。“数据”也称“样本”，本例中，每条样本都带有一个标签，这个标签标注了某个数是否是水仙花数。样本是方法的基础。下表例举了一些“水仙花数问题”的样本：



数值
标签是否是水仙花数

































然后“选择模型”。有许多种模型可以选择，这里以“神经网络” 模型为例来说明。
其次“训练模型”。可以把模型也想象为一个“函数”，该函数的“实现”不是直接编程得到的，而是通过“学习算法” 间接获取的。“学习算法”能利用数据“拟合”出一个函数，这个函数的定义域和值域与上面的函数__是一模一样的，区别在于，拟合出来的函数内部是一个神经网络，而__内部是直接根据水仙花数定义的算法实现。“学习算法”利用数据拟合出模型的过程被成为“训练”。
最后“应用模型”。训练好模型后，可以认为我们得到一个如下形式的函数：

 ____ 

{

          神经网络模型输出是否是水仙花数。

}
我们把传给函数____，函数输出是否是水仙花数的结果。这一过程也称为“预测”。
小结上述两种方法的求解过程：
，  直接编程方法：
         根据问题定义，设计“算法”；
         实现“算法”。
，  机器学习方法：
         根据问题定义，选择数据和模型；
         设计“学习算法”，利用数据训练模型；
         使用训练好的模型做预测。
可以看到，与“直接编程方法”不同，方法并不直接对“问题的定义”编程，而是对“数据”编程。一种通俗的理解是，“数据”中包含了特定问题的“知识”，如本例中判定水仙花数的知识，“学习算法”让模型能直接从数据中“学到”知识，这个过程就是机器学习。
 适用机器学习的问题类型
比较上面两个解法，可能有人会说，“直接编程方法”几行代码就能解决问题，有必要用机器学习这种看上去更复杂的方法吗？上文例举水仙花问题只是为了行文方便，我们看下面这个问题：给定一张图片，图片的内容是～之间的一个手写数字，编程输出图片中数字的数值。这就是经典的“手写数字识别”问题。示例图片如下所示：

观察图示的内容，一个手写数字有各种各样的形状，每个人写出来的数据都不太一样，很难用“直接编程方法”根据“数字形状的定义”设计算法来识别这些数字。而这个问题对来说非常简单，手写数字识别只是领域中“ ”级别的问题。
我们可以得到一个初步的、不严谨的结论：适合解决那些用“直接编程法”无法或很难解决的编程问题。但不是万能的，它也有自身的局限性。
 搭建开发环境
本节介绍开发环境的搭建。有很多计算机语言适用于解决问题，如、、、等，本节只介绍最常用的。有很多库、框架可以用，如、、、等，本节只介绍后续章节要用到的和。
 
安装包的下载地址：。 支持、等多个操作系统。 是使用最广的版本。
如果安装的版本是  = 或   =，则自动安装了包管理系统：。两个常用的命令：
 ：搜索包
 ：安装包
的库通常会依赖多个其他的包：如用于基础运算的、用于科学计算的、用于可视化的等。手工依次安装这些包会很繁琐，高效的做法是直接安装集成环境，推荐使用，下载地址：。
中有个名为的包也可通过  安装，它提供了一个交互式环境，支持查看文档、性能分析等强大功能。
 
集成环境中带有包。若要手工安装，可直接在命令行输入：  。
对不同的算法，封装了底层的实现细节，提供了一组易用的、统一的。常用的两个是和：用于训练模型；用于预测结果。
在线文档：。
 
是开源的库，对神经网络算法、尤其是深度学习 支持非常好。安装指南：__。
预编译好的安装包分为和两类，安装时要注意区分。的优势是矩阵运算效率非常高，而图片识别、文本处理等任务需要大量矩阵计算，所以线上环境中的大规模神经网络模型一般都跑在上。
从版开始支持，但目前只支持位的 环境。
系统已支持上述的开发环境，详见：。
 应用机器学习的一般步骤
上文节中简要描述的步骤，本节将其细化一下。应用的一般步骤如下：

定义问题

收集数据和特征工程

训练模型和评估模型性能

线上应用和持续优化


定义问题
目前还没看到有一个模型适用于解决所有问题。不同类型的问题有各自适用的模型，如图像相关问题有深度学习、推荐相关问题有专门的推荐算法、安全相关问题有异常检测模型等。脱离具体问题去讨论模型是没有意义的。
收集数据和特征工程
上面我们提到过，是面向数据编程，数据是的基础。训练模型时，一般会把数据按：的比例拆成两部分，其中成数据用于训练模型，称其为训练集 ；另外成数据用于测试“模型的好坏”也称“泛化能力”，称其为测试集 。机器学习可以粗略分类两类：“监督学习”和“无监督学习”。“监督学习”是指用带标签的数据训练模型的算法，如上述的水仙花数训练集，样本中的每个数值都有个标签标识它是否是水仙花数；“无监督学习”是指用未带标签的数据训练模型的算法，如大部分的异常检测算法，它的输入样本中并没有某个字段标识样本是否是异常的。
有人总结了收集数据的三要素：，的缩写，即收集数据包括三部分：抽取数据、转换数据和加载数据。
同一个算法，好的数据能让其表现更好，差的数据会让模型毫无用处。用“性能”一词表示模型表现的好坏，此处“性能”的含义不同于软件工程中的“程序性能”。什么是“好的数据”？并没有统一定义，从结果看，能让模型表现良好的数据就是“好的数据”。一个可行的办法是想象“人”在解决该问题时，会依据哪些数据和特征做决策，然后挑选这些数据和特征作为模型的输入数据，这个过程就是特征工程。在应用时，可能需要反复做多次特征工程，特征工程是个试错的过程
 训练模型和评估性能
成熟的库都封装好了训练模型的，如的接口、在中运行优化器等。
训练模型的“学习算法”是如何起作用的？不同的模型基于不同理论，如决策树模型基于信息熵、基于支持向量、神经网络基于损失函数、梯度下降和反向传播等。限于篇幅，这里不展开讲了，感兴趣的同学可进一步阅读参考资料。了解模型背后的原理有助于训练出更好的模型。
训练完模型后如何知道模型性能的好坏呢？有许多量化指标用于评估模型性能，如查全率、查准率、、、等，更详细的描述可参考阅读参考资料。
若训练出来的模型性能达不到要求，通常的优化方法有三个方法：调整模型超参数、重做特征工程、获取更多数据。模型的“超参数”用于区别模型的参数模型的参数一般是指模型的输入，即数据和样本，每类模型的超参数都不一样，如神经网络模型的超参数包括：学习速率、正则化项、激活函数类型、网络结构等。调用库构造模型的的参数一般就是超参数。
 线上应用和持续优化
训练完模型，并且在训练集和测试集达到性能指标后，就能灰度应用于线上了。需要注意的是，在训练集和测试集上取得好的性能并不意味着在线上环境也能取得好的性能。
模型在训练集上性能达标，但在线上环境性能不达标，这一现象被称为“过拟合”。通常的原因是用于训练模型的数据中特征的分布与线上数据偏差太大，此时需提取更具代表性的数据重新训练模型。
模型在线上应用后，需持续跟踪模型的性能表现，尤其是那些数据特征变化很快的场景，如安全中的反垃圾：恶意用户会想尽办法绕过我们的模型，用新的方式生产垃圾。不要忘了我们的是面向数据编程，若恶意用户生产垃圾的特征并不包含在我们用于训练模型的数据中，模型当然检测不出恶意用户。在类似的这些场景中，需要持续优化模型。
 案例： 
初学编程的第一个例子一般都是打印“ ”，领域的 是手写数字识别。本节的内容来自官网的文档： ，  按第节给出的应用步骤将其重新组织一遍。
本例的问题定义很明确：给定数据集，训练模型，识别图片中的数字。
是一个带标签的图片数据集，它包含了如下所示的手写数字图片：
每张图片各自对应的标签是、、、。可直接用封装好的代码加载图片和对应的标签。示例代码地址：_ 。本例中，直接把图片作为模型的输入，无需额外做特征工程。
示例代码构建了一个如下图所示的神经网络：

使用梯度下降 训练模型。关于神经网络的细节见参考资料。
模型训练完后，最终的预测准确率为左右。进一步提高准确率的优化方法在这里：。
 参考资料
周志华，《机器学习》
  ， ，   背景介绍
随着互联网业务的快速发展，基于传统关系数据库的数据存储方案暴露了系统架构可伸缩性差、海量数据下性能存在短板、数据模型过于复杂并难以调整等问题，而关系数据库所提供的强一致性、事务性、关联操作在许多互联网应用模型中并不是必须的，所以在新的场景下，去关系化的数据库应运而生。数据库具有高扩展性、高性能、灵活的数据模型、高可用等特点，其中的一大分支是数据库，数据库采用键值对的形式来组织、索引和存储数据，具有简单、易用、可扩展性好等特点。
而作为数据库里的最热门的一员，在保持数据库的简单快速的优点基础上，具有一些部分关系数据库的优点，例如数据结构丰富、操作原子性等特点。
   的现状和问题
推出后具备诸多优点得以广泛流行，目前高居数据库热度榜第一。
首先，的数据全量保存在内存中，采用单线程无锁事件驱动的方式进行服务处理，协议上支持流水线批量和增量操作，无需像那样取出全量数据进行操作，所以具有相当高的性能；
再次，提供多种键值数据类型来适应不同场景下的存储需求，并借助高层接口使其可以胜任诸如缓存、消息队列系统、排行榜、计数器等不同的业务场景，借助单线程工作方式，甚至支持部分的事务特性；
最后，采用可读易懂的协议接口，并支持了几十余种语言的客户端库，对开发者来说简单易用，开源生态也比较活跃，目前大量公司采用它来作为缓存或者存储系统，年以来大部分云服务提供商都提供了相关存储服务。
虽然在数据结构和接口上简单易用，但在业务实践和运维过程中，还是存在不少的问题：

伸缩性不佳，业界普遍使用的原生在架构上是一个单机存储系统，当单机容量出现瓶颈时，分库分表需要业务强参与，而且数据无法自动平滑迁移，许多时候都需要停服进行数据迁移；同时，单线程既是系统的一个独特的优势，但也成为性能瓶颈，一个实例容量再大，单线程也限制了它所能提供的性能；

全内存的部署方式，性能虽然不错，但一方面，数据都在内存里，无法区分冷热数据，而在互联网应用中，大部分业务数据模型都有冷热之分，另一方面，内存相比磁盘容量更小，无法实现大数据量的存储，这点也成为单位数据存储成本居高不下的罪魁祸首；

本身虽然通过和来实现数据持久化和主备同步，但实现的方法比较粗犷，是通过一个子进程，通过遍历当前内存里的数据生成文件，这中间依赖系统调用的内存机制，如果业务的写量较大，则可能导致，另外在大内存进程进行存在卡机的现象，对用户访问服务质量会造成影响；，是增量流水落地磁盘文件，因为该操作是在主线程中执行，所以如果出现问题，会对服务质量造成比较大的影响，此外，写量大的时候，也会触发流水的机制，这时也会造成堵塞，进而引起比较严重的性能问题。


业界也有一些解决方案来解决单机版的扩展性问题，例如和，他们采用了代理节点进行数据分片的方式来连接后端多个服务器，而 采用了去中心化的方式组成服务器集群。
但这些方案基本上都是在单机版的基础上实现了分片机制，而并没有解决单机版本身存在的问题，主备同步机制仍然借助、等机制，容易造成性能颠簸；另外，这些集群版在运维能力的建设方面也比较缺乏，例如监控、上报、单系统的多实例化、运维自动化等。 的去中心化方式，虽然少了代理节点一跳，但需要更改客户端代码，而且该实现方式还不够成熟，业界还缺乏最佳实践。
    云存储产品
  综述
   是腾讯云推出的兼容开源协议的分布式云存储产品。该产品基于承载日均万亿请求的存储平台，在原有的高可用、高可靠、高扩展性的分布式数据引擎框架基础上，引入了的数据结构和协议支持，实现的一个分布式存储平台。
突破了单机版容量限制，能为客户提供海量的存储，支持单实例多达上百的存储量；接口上兼容开源协议，业务代码无需更改就可以轻松接入；在分布式解决方案中独创地支持分布式事务处理能力和批量处理命令；并提供了方便易用的平滑迁移工具，能够将用户原有的数据无缝迁移到；便捷易用的控制台，能够方便实现多维度监控、数据导入导出、无停服扩容等管理运维操作。
依托于支撑海量用户的存储平台，支持个高可用的跨、跨地区的多拷贝部署机制，以及可持久化存储，数据存储稳定可靠；所有节点都无单点故障，能够在数秒内进行故障屏蔽与恢复服务；具有高可靠的备份和流水机制，能够按需将全实例或部分数据恢复到任意时刻的状态；提供内存与两种存储介质，并支持两者的自动冷热分离功能，为客户提供更低成本的存储方案。
  与业界产品的比较
 
  架构设计要点
系统将数据的存储和用户的接入分开，同一个用户的数据分布在多台机器上，从而突破单机内存容量的限制；同时，多个用户的数据，保存在同一台机器， 通过一定的策略，隔离多个用户，避免用户之间相互影响。 如下图所示，整个系统包括如下几部分：
 •在线存储系统： 接入集群、存储集群和导入导出服务；
 •数据高可靠系统： 主备同步模块、流水系统和冷备中心；
 •运维监控系统： 日志中心和多维监控系统；
 •支持系统： 任务中心、配置中心和路由系统。
 
其中核心在线存储系统是基于存储平台进化而来。
下面先从的业务现状、历史版本变化、技术特点再到引入的改造优化技术点来介绍的架构特点。
   介绍
是专门针对即通业务数据轻、访问量大、容灾要求高等特点，在资料系统、关系链系统基础上开发的更抽象、更通用的存储系统，具备数据类型和操作接口丰富、可多地部署、可在线遍历等多种优势。
当前已经在深圳、天津、上海、加拿大部署了机器，承载了业务，总数据存储量达到，每秒峰值访问量达到万次，每天访问量达到万亿次。从服务启用至今，平均服务可用率达到了。
从年年发布了第一个正式版本到现在，经历了几次大的优化里程碑：
年月，支持了批量操作、对用户侧进行了优化，并通过合并写提升了写性能；
年月，支持了跨地区的异地部署能力；
年月，支持平滑扩容与多系统间平滑迁移运维能力；
年底，支持存储介质的版本发布；
年月，支持全球部署，并有登录相关业务实现了深圳、天津、上海、加拿大四地多拷贝部署；
年底，实现了多集群自动化管理平台，能够一键实现部署、扩容、迁移等常见运维操作，同时也优化了自动故障处理流程，很好提升了运维效率；
年月，实现了公共仓库部署模式，冷热分离，并优化了存储组织结构、寻址方式与同步机制，将单机读写性能提升了。
   架构与技术特点
如下图所示，系统由接入层、数据存储层和配置运维中心三大模块组成：
 
接入层：负责和用户的客户端直接通讯，无状态，可无限扩展；
数据存储层：负责存储用户的数据，支持多拷贝之间的同步，以及平滑扩容；
配置和运维中心：负责管理、下发配置信息，管理、调度运维指令，以及告警监控等功能。
        数据分布方式
中存储的数据按主在集群中以一致性算法进行分布，一致性算法拥有无限平行扩展、消除热点、最小化迁移量等优点，算法根据主的值，将其落在某台机器所属的虚节点上，以此来决定其所在机器，示意图：

使用自研的改进割环算法来决定各机器节点在环上的位置，根据此算法的计算结果，可以在保持每台机器只有个虚节点的前提下，支持至台服务器，同时保证各机器数量和负载的最大偏差。
        同步机制和异地部署能力
的数据可同时存在于多个拷贝中，采用一主多备的结构，最多支持个拷贝主备。数据的所有改变由主机实时同步给备机，支持增量同步、全量同步以及全量数据恢复等同步机制，备机可分摊读请求，支持异地部署以提高客户读请求的响应，非常适合读多写少的场景。主备集群的状态由运维中心统一监控管理，在出现同步差异过大、死机等情况下可实现秒级的状态切换和服务恢复。
        数据解析插件机制
在传统的存储基础上，对做了各种数据结构的扩展，其中数据结构和其存储引擎是分离的，即系统框架部分只负责数据的存储、落地、同步、扩容等基本操作，具体到涉及的结构的操作，则是通过编写插件完成，只需要实现几个简单的接口并向系统注册动态库，即可给增加新的数据结构处理功能，例如，我们可以让对外提供、甚至接口进行访问，而不需要改动它本身的主体引擎代码，只需新增几个动态库即可，插件机制给了极强的功能扩展能力，将和其他数据库的特性有机地结合在一起，也给使用其他数据库产品的用户接入提供了很大的便利。
        数据存储介质
在中，不但存储引擎和数据结构是分离的，数据处理逻辑和具体的落地方式也是不耦合的，逻辑处理只关心抽象数据本身，具体数据的存放则交给下层的库来做，因此理论上数据可以存放在内存、磁盘甚至远端的其他数据库引擎，目前实现了存放于内存和磁盘的落地方式，配合数据的冷热分离算法，可在保证足够的访问性能前提下极大压缩成本。
        冷热分离
因为业务场景的关系，用户的数据，总会有访问密度的差别，某些数据比较“热”，可能会连续多次的读写访问，某些数据比较“冷”，可能会几天都得不到访问。鉴于上述情况，如果将用户数据完全部署在内存版本，系统成本代价大，降低了资源有效利用率， 反之，如果将数据都部署在， 可能导致访问时延加大，服务体验变差。为了取得“性价比”与“服务质量”的平衡， 启用了“冷热分离”的混合部署方式。
一旦启用冷热分离模式， 系统会按照预置的“冷热规则”，开始自动的识别“筛选”数据，将热数据迁移到高效的内存系统，将冷数据沉降到系统。而“冷热规则”，可以根据需要，实时动态调整门限，以达到系统容量与性能的平衡。

   基于的解决方案
        数据插件
利用的数据解析插件机制，可以很容易给增加数据接口和存储：

如上图所示，我们在数据机嵌入了数据插件，可直接解析协议，而下方通用存储层则完全不感知数据格式，只是按照的命令以一定格式将序列化的数据落地，并支持同步等操作。
数据机在处理协议时，先将数据从存储中通过格式处理模块恢复为的各种数据结构，根据从协议中收到的命令对数据进行读取或修改，修改后的数据被写回到存储中，从而完成了数据存取流程。在这个流程中，插件引擎通过内建机制，保证了数据存取效率。
        分布式事务
单机版本提供多条命令事务支持，扩展到分布式系统，这里需要引入分布式事务的能力。对分布式事务的支持，原理与“二阶段提交”类似，首先为确保事务的一致性，事务执行的协调者，会生成全局的事务， 用事务来锁定分布式的资源，资源一旦被锁定，仅持有该事务的执行过程，可以访问或修改该资源，其它访问被阻塞或丢弃。当资源锁定都后，可以认为资源准备成功，开始申请资源修改过程，所有操作结束后， 协调者主动发起释放锁，通知各资源提交，事务成功结束。如果修改操作失败，协调可以发起回滚操作，终止事务提交。
整个过程中，可能会遇到两种异常：链路不可达，节点异常宕机。 采用了两种手段来应对， 其一是定时解锁与主动回滚机制，主要应对链路不可达引起的超时异常；另一是事务流水日志恢复机制，主要应对节点宕机引起的提交异常。

        云上多租户上报与监控
由于系统中，每一台机器都会服务多个业务，需要对各个业务的各种命令进行监控，因此加入了多维上报系统。
多维上报系统提供简单高效的上报接口并支持从任意维度进行数据的上报和聚合。后端存储服务会根据业务的上报信息自动建表和分表，因此业务无需事先申请需要上报的维度，可以自由扩展。由于上报的数据量巨大，多维上报系统在客户端会对一分钟内的数据进行一次汇聚再传递到服务端做存储，以减小对服务端的压力。
目前系统通过多维上报系统来生成日报，能知道各个业务每天的详细运营情况，如下图所示：

        集群化配额管理
 在云环境中，机器以分布式的方式进行工作。在单机的流量、、内存等资源有限、数据热度分布不均的情况下，如何对资源进行统一有效的管理与隔离，防止单一业务大量耗费资源，进而导致整个云的服务质量下降，成为需要解决的一个问题。
为此我们开发了集群化配额管理系统。系统记录了每个业务在每台机器所使用的资源的情况，并将该数据提交到调度中心。由调度中心根据该业务在每台机器的使用情况及其所能使用的资源额度，调整该业务在每台机器的配额，同时确保所有业务在单台机器上使用的资源不会超过该机器的最大能力，防止机器过载的情况发生。
        无缝迁移
在目前常见的迁移方案如 的中，业务做迁移时都需要停服，无法灰度而且在不满意新的方案时也不能回滚。因此提供了无缝迁移模块，支持对单机，及数据的迁入。

的无缝迁移模块支持不停服迁移，业务在迁移过程中可以灰度修改配置或代码。用户还可以通过端查看当前的迁移进度，并可以配置在何时将服务真正迁移到中数据从中读取，何时下架旧的服务。
在迁移过程中 会对业务使用的命令进行校验，如果有不支持的命令则停止数据迁移并通知业务做相应的修改。此外，无缝迁移模块在用户真正确认下架旧的服务之前会尽量保证旧的服务和中数据的一致性，因此用户如果发现有不能满足业务需求的地方，可以及时回滚。
        数据用户管理机制
提供了数据导入、导出、快照和记录流水功能，在数据管理方面，形成完整的闭环解决方案，为用户数据提供健康保障。

目前提供了以下功能，满足用户数据管理的需求：
 •导入——将用户的文件导入到
 •导出——将数据导出为文件
 •生成快照——在运行时生成用户数据快照
 •快照恢复——用户选择快照恢复数据
 •时间点恢复——将用户数据恢复到指定时间点
 •级快照恢复——从指定快照恢复
 •级时间点恢复——将指定回滚到指定时间点
基于以上功能，用户可以方便地在自建和间迁移数据，可以根据需要生成快照，并在实例和级对数据进行回档操作，满足日常运维和运营需求。
   小结
在基于支撑日均万亿请求、个可靠性的存储平台之上，支持了协议和存储结构，并有效解决了当前主流服务存在的可伸缩性不佳、运维能力欠缺、成本高等问题，为用户提供了高可靠、高扩展、功能丰富、价格有竞争力的云服务。

相关推荐
设计思路学习与总结单机主从高可用性优化操作  云爬虫初探作者：刘恒兵

感言
终于有时间停下来来回顾一下上海  分享《  极限优化解决方案》旅途。不喜欢总结，往往是比较痛苦的，些许时间之后回过头来，发现部分细节已然模糊。不得已要求自己写点什么，哪怕随便写写，给自己看也好，给其他人参考也好。总归于相忘于历史较好。
首先很感谢这个大平台，也感谢组织者臧秀涛全程的鼎力帮助。特别感谢郝培强老师的支持，有幸能和罗升阳、 赵世婚、李跃辉、胡文江白衣、董一凡 几位大牛一起分享《移动开发新趋势》这个专题。
心路历程
一次收获颇多的成长历程”，用这句话概括，最适合不过了。至于聊到收获，大致概括为：

人脉 ——又认识了很多新同学，都是在自己领域擅长的同学。在几天的认识和交往中，一部分成了很好的朋友，在以后的技术然所之路上会有莫大的帮助。

技术——既然是一个技术盛会，免不了诸多的技术交流、探讨。对之前未曾涉猎的一些领域都有了一些了解，算是门外汉入门吧。

分享——我是一个乐于分享的人，之前的一些分享，总归没有这一次听众多，除了线下的，线上分享，后期视频观看的人数，远大多余在场人数。对分享的技巧也是一个挑战。这些很宝贵经验，同时也是我后续努力提升的方向。

准备——所谓“兵马未动，粮草先行”的道理在这次分享过程中，记忆犹新。相对而言，这次准备已是相对较长的时间了，可仍感不足，也激起了后续继续分享的欲望。


 之前没怎么在上海停留，这次分享之余，在上海停留一天。将以前没有去过的地方走了一遭，也算是完成了长时间的夙愿。
移动之殇
要提及分享主题，我们先从移动说起分享中口述带过。 是唯一兼容端、移动端 、、的跨平台语言。由此带来诸多革命性的变革，低成本、低门槛、可复用、高效率，借助技术，混合模式也逐渐被认可即能基本满足的丰富、高体验的要求，又能满足高效率、快迭代的场景。
似乎一切都很美好，但良辰兄表示不服。当我们以为我们的业务是这样的时候。

其实我们的业务大部分是这样的。

除了复杂的元素之外，还包含多资源图片、音视频等。
从上面的业务对比可以看到，随着的到来，业务复杂度不断增加。而实际的开发过程中，我们也不断的发现：


页面打不开打开慢 
页面菊花
操作卡顿
页面展示错误
产品体验不过关

这些问题，几乎在所有移动端开发的场景都会遇到，针对这些问题，随着经验的积累，我们已然有一套行知有效的解决方案。

资源加载

——提升初始化速度，提前处理网络请求，并行，减少串行处理的情况；
——通过浏览器缓存，减少网络请求，加快网络速度；
离线包机制——走客户端通道，将文件拉取下来，到本地，异步检查更新，用户直接使用本地文件，成功率可以提升到三个。


数据加载

化——针对页面数据展示问题，通过数据以及客户端的能力，将数据缓存到本地，页面内二次用户、页面间的缓存，提升缓存命中率，使更多的用户能够通过数据缓存加快页面的展示速度。


体验优化

优化——页面的体验优化，通过前端的性能优化，渲染优化等方案，提升移动性能。

——客户端提供的的能力，提升产品体验，达到体验要求。




移动优化之道
优化，这个老生常谈的问题，在很多场合，我们都会提到优化。重复的优化，造成了很多人力的浪费，而这些优化，我们尝试去找到一些共性，尝试找到统一的解决方案。
提到移动优化，一个页面加载展示中间到底经历了哪些流程？        。

流程之下，我们才能针对性优化。在模式下，多了一环的加载，因此除了进行移动优化之外，就是减少的初始化时间。
在流程上，优化进一步细化之后，可以分为以下三个方面：


网络优化——加载策略、优化请求、缓存优化
资源优化——、图片、、
渲染优化——、动画、

进一步细化：


到了这里之后，似乎一切看起来有美好了。流程熟悉了，针对流程优化也有了标准，且具体到了每一项具体的优化点和规范。进而针对 开发，也有了基于客户端提供的优化、离线包体系、等。看起来移动开发将无所不能。
其实并不然。
移动监控体系
虽然有了优化方案，也有了优化细则。然，我们依然被用户反馈所恼。？
细想之下，方案太过于普遍化，没有具体到用户的场景，举个栗子：一个用户反馈数据加载过慢，而你却在拼命优化页面渲染执行，其实效果不一定明显，因为针对用户而言，最重要的网络时间，一个的小文件，网络所需的时间大概在左右    ，及时页面执行效率在高，也很难弥补网络瓶颈所带来的时间消耗。因此，优化第一步——  找到你页面瓶颈
透过监控窥方案
首先要完善我们的监控，需要有监控规范，我们监控的点需要囊括

以及对应的具体规范策略

在有视频资源之下，监控还需要涵盖视频的监控

监控数据
有了监控，我们在回到我们的本质目的。通过监控，我们继续举一些栗子，来看一下监控体系下的数据与数据差异化。

  



与的对比，  。即便是在同样的网络环境下，访问次数的差别也是不一样。正因为有如此大的差别，我们想办法将资源本地化离线包，减少资源网络的时间。

离线包更新率



这里以五个版本为例说明，离线包版本更新情况，从这里也可以看到，离线包迭代天内基本可以替换。但要基本完全覆盖会在天左右。当有某些大版本不兼容的时候，除了我们提前更新版本保证兼容之外，我们可以更好的知道我们的版本影响的用户时间和范围。而对于统计来讲，我们只需要上报用户，版本号，离线包的状态就可以获得这些信息。因是因为有这些完善的监控，我们才能针对我们的不同条件的监控数据给予不同的优化方案。

视频数据



以直播为例，数据相当于数据倍。而录播更大，达到了倍。可以看到，针对明显的对比数据，我们就可以知道我们的优化方案：减少录播资源片段。
方案策略
有了这些监控之后，我们在回到我们前面提到的一些问题，我们瓶颈在哪？不同的场景，所遇到的瓶颈不尽一致，这样是我们之前说到的当我们做了很多优化之后，反馈依然。

不同的情况，选不同的方案；不同的场景，用不同的策略
业务实践才是王道
优化体系，离不开三端：、、

具体的业务之中，优化重要的一环——资源优化。
资源优化之

前端上报数据到接入层，接入层，然后再通过推送中心将数据分发。

第三方接入系统，提供 给第三方接入；
数据存储中心，采用存储；
到管理系统统计、报表等。

通过系统，基于 机制为什么选择 ？参考 ，基本可以将我们的脚本错误控制在。
图片资源优化之  

图片的优化一般从两个方面：请求数、大小。通过雪碧图、等方案来减少图片请求。提供不同压缩的尺寸来减少图片大小和默认拉取大小。
然而事事上，我们的图片可以进一步优化为

在我们的应用场景以及我们的环境支持主要是移动的支持情况下，通过可以将我们的终端提升近。
而在图片的另一个方面，就是考虑将多个不同尺寸的同样图片归纳为一图——矢量图。矢量图可以有 与 ，然不支持。
对于，首先得有个平台，其次得考虑上传，然后使用下载，最后反馈平台。这是一个体系化的应用，基于构建工具以及平台之上的低开发、维护成本的应用。应用之后，整个业务资源节省。
，视觉、开发，通过这个平台大大减少了沟通成本以及维护成本，提升了开发效率。
  
拒绝重复的事情，在开发的过程中，我们不断累积功能，随着功能的增加，由模块形成组件。当组件组件增加的时候，我们就希望有一个平台在维护这些组件，且最好是能和构建工具打通。这也是我们将要提到的平台。

对比现有的系统，其实我们不难发现，我们将我们好的一些优化方案和组件同步到现有的组件平台、、、等，面问领的问题是，别人很难找到，而且我们自己要找一个组件也相对麻烦，招到组件之后也不一定能够相信他和使用它，只能通过以及的数等做响应的参考，而在系统中，我们想要的目标是，能够快速的找到发现可信任的组件，以及对组件完善的反馈改善体系，这就是平台的独有部分，认证和反馈。

开发这通过开发和发布组件，使用者来使用组件。从而保证组件最大范围的复用。同时，支持内外网源以及组件权限认证能力，满足局域网开发的需要。
通过支持组件复用的方式，补足移动端优化的需要，保证一次优化之后，可以在多处同场景下使用。
移动的未来
最后的最后，还是想抛砖引玉一下，移动的未来。针对移动优化，很多优化方案犹如雨后春笋般层出不穷、、 、等。同时，我也坚信，移动的未来是要端结合。在开发方式不变下，寻求夸端的高度融合，去掉相对令人诟病的、移动端协议下的数据加载。我们的移动未来将更广阔
小结
移动话题源源不断，移动优化也会经久不息。那么在移动优化的时候，需要顾及场景、瓶颈。针对不同的场景，不同的瓶颈做不同的事情。专业的事，要留给专业的方案来解决。回到我们的主题，极限优化，什么是极限优化？就是要细分场景优化，这样才能俱到。要做到俱到，需要做到如下：

掌握加载的细分场景
  找到瓶颈
规范是一切的基础
方案比代码更重要
透过数据窥方案

描述了很多，也讲了很多，希望能够给到大家一些帮助。也同时，给这个不喜欢总结的我，一个机会去细细回归一下上海的内容，感谢那些能花时间阅读至此的小伙伴，谢谢你们不厌其烦的看我长篇累赘的描述。我尝试者精简，竭尽所能之后，还是有这么多。足可见此次分享的内容过于臃肿，导致分享过程语速过快，这里也算是一种抱歉吧。把把分享的内容大致这么一扑通的罗列出来，不加任何修辞和装饰，能看到这里的小伙伴，再次感谢。
最后可以在这里下载和阅读，及关注我和在这里讨论。

原文链接：


相关推荐开发性能优化核心定义介绍篇磁盘读写速率测试如何从到搭建个人站点导读
月日，腾讯“云未来”峰会进入到各专场的环节。来自腾讯技术工程事业群的领导及员工作为演讲嘉宾参加了政企、大数据、开发者个专场，并向行业合作伙伴介绍了在该领域的沉淀和探索。以下是来自腾讯研发管理部的产品组组长陆莹在开发者专场的演讲内容整理。

演讲主题：腾讯敏捷研发体系揭秘
演讲嘉宾：研发管理部产品组组组长 陆莹
当今的互联网时代是一个快鱼吃慢鱼的时代，市场环境瞬息万变，对用户和环境的快速响应，成为团队制胜的法宝。在腾讯这样有着两万多人研发的企业，同时进行着两千多个项目，运行着四百多个产品。腾讯这种几万人的企业如何进行高效合作呢？

腾讯有不同类型的产品，覆盖了社交、娱乐、资讯、支付、工具等各个类型，每个研发团队的研发规模和团队的研发模式都各不相同，腾讯的团队想要保持持续创新，除了秉承以用户为主的理念，一套敏捷高效的开发平台必不可少。什么支撑了腾讯这么一个庞大的研发体系，并且能够支持不同类型的研发团队高效协作呢？

年，腾讯敏捷研发体系产生了，到今年正好是十一年时间，它是提炼借鉴主流敏捷方法，比如说、、等等，并结合互联网产品研发的特色框架，承载的是腾讯敏捷研发最佳实践。的核心理念是敏捷迭代、小步快跑，快速改进、拥抱变化，用户参与等等，也就是腾讯率先进行敏捷转型，公司内部所有的团队都开始实施敏捷，想要实施敏捷，除了有一套敏捷体系，一套完整的成熟的敏捷工具也必不可少。

于是在同一年，腾讯敏捷研发平台也诞生了，覆盖了腾讯敏捷研发生命周期的全过程，包括有的产品规划，有迭代计划，有故事墙和燃烧图来跟踪，还有测试计划和缺陷进行敏捷测试，文档还有发布计划来管理灰度发布，还有用户反馈。在此基础上，的定制化引擎帮助各个模块进行灵活定制，并且的开放平台提供了丰富的接口，帮助第三方应用的接入。

有三大核心特点，首先是极致敏捷，小步快跑。腾讯从年开始实施敏捷，我们经过了十多年的验证，的灵活和强大是经得起考验的。我们也有成熟的解决方案支持团队成长。承载了腾讯敏捷研发的精髓，这个就是腾讯敏捷研发的框图，可以通过进行敏捷的需求规划，包括有故事的层级拆分，管理好用户故事，有清晰的迭代计划，可以进行可控的故事墙、燃烧图，有一体化的解决方案，包括测试计划等等。有强大的缺陷管理，工作流程随心配，有丰富的在线文档，我们提供了可多人协作的思维导图还有文档等等，包括团队在研发过程中文档的沉淀和协作。有精细化的任务和工时管理，帮助团队进行更精细化的管理，另外我们有精准的发布计划来做整个发布的计划跟踪，有丰富的自定义报表和定时报告，并且支持我们的项目报告和定制报告的发送。

腾讯的敏捷比较丰富，但总结来说可以有三种模型，第一种是迭代模型，也是使用最广泛的，稳定的迭代周期和发布节奏，交付周期是到周，这种模型包括有微信等等团队都在使用。实际使用中也呈现多样性，比如有长短性并行迭代，有特性组并行的迭代等等，第二种是大象模型，进行跨部门跨地域的合作，周期一般会进行两个月，最典型的是手机团队，第三种是极速模型，是单周迭代，特别适合互联网的运营团队，这三种都可以在承载，为什么它可以支持丰富的迭代模型呢？


答案就是极致灵活，随需而变。的二十个模块可以灵活应用，可以自己搭配适合自己研发过程的流程。我们提供了自定义对象，去定制个性化应用来满足团队个性化需求。它的工作引擎可以实现每个模块的工作流，提供系统报表的同时，我们业提供了很多自定义报表，帮助团队进行报表沉淀以及报表的发送。的灵活赋予了团队更多的可能，对于一个发展型团队来说，团队的规模和业务不断变化，团队的敏捷模式也不会一成不变的，所以提供了成熟的解决方案来支持团队成长。

当团队规模较小，团队成本过高的时候，一般会追求快速的协作，我们推荐使用轻量团队协作的解决方案，可以进行以看板为主的敏捷协作，并且用文档来管理团队过程中的沉淀，当团队规模得到一定的增长，并且希望能够进行更规范的敏捷实践管理的时候，就可以使用轻量敏捷项目管理解决方案，包括有需求、迭代、故事墙、缺陷、报表和，这样的解决方案能帮助团队更快适应敏捷团队管理，当团队的规模增大到人以上，需要引入更多的敏捷实践的时候，就可以使用敏捷全生命周期管理的方案，实现了从反馈、需求、迭代到测试管理到发布管理整个敏捷全生命周期的全过程。

如今已经部署到云端，提供给腾讯云的小伙伴们使用，我们支持敏捷研发协作生态，从年月份开始就进行了内测，年的月份，开始给腾讯的一些投资公司和腾讯云部分用户使用，到了年月，已经实现了全面的开放注册，到目前为止，已经成功支撑了三千多家企业来进行敏捷研发协作，其中就包含了有新美大、同城旅游、恒大集团等等。

愿意和腾讯云一起开放给更多致力于敏捷研发效率提升的小伙伴们，我们会把腾讯云近十年来的研发协作成功案例和经验分享给大家，让腾讯云生态上的小伙伴们都能进行敏捷研发，让协作更敏捷，更多内容可以关注官网，如果大家有兴趣了解也可以到外面的体验区来进行详细功能体验，谢谢。前言
本文主要说明在环境上如何使用共享内存。阅读本文可以帮你解决以下问题：

什么是共享内存和为什么要有共享内存？
如何使用进行共享内存？
如何使用共享内存？
如何使用共享内存？
如何使用共享内存以及共享内存的相关限制如何配置？
共享内存都是如何实现的？

使用文件或管道进行进程间通信会有很多局限性，比如效率问题以及数据处理使用文件描述符而不如内存地址访问方便，于是多个进程以共享内存的方式进行通信就成了很自然要实现的方案。系统在编程上为我们准备了多种手段的共享内存方案。包括：

内存共享映射。
共享内存。
共享内存。

下面我们就来分别介绍一下这三种内存共享方式。
内存共享映射
本来的是存储映射功能。它可以将一个文件映射到内存中，在程序里就可以直接使用内存地址对文件内容进行访问，这可以让程序对文件访问更方便。其相关调用原型如下：
 

   _        _ 

   _ 
由于这个系统调用的特性可以用在很多场合，所以系统用它实现了很多功能，并不仅局限于存储映射。在这主要介绍的就是用进行多进程的内存共享功能。产生子进程的系统调用是，根据的语义以及其实现，我们知道新产生的进程在内存地址空间上跟父进程是完全一致的。所以的实现了一种可以在父子进程之间共享内存地址的方式，其使用方法是：

父进程将参数设置_方式通过申请一段内存。内存可以映射某个具体文件，也可以不映射具体文件置为，设置为_。
父进程调用产生子进程。之后在父子进程内都可以访问到所返回的地址，就可以共享内存了。

我们写一个例子试一下，这次我们并发个进程写共享内存来看看竞争条件的情况：
   _ 
 
 
 
 
 
 
 
 
 

  

 _ 
{
     

       
     = 
    
    
     = 
       

    
}

 
{
    _ 
     
     _

    _ =    _|_ _|_  
     _ == _ {
        
        
    }

    _ = 

     = {
         = 
            {
            
            
        }

          ==  {
            __
        }
    }

     = {
        
    }

    _ \ _
    _ 
    
}
这个例子中，我们在子进程中为了延长临界区 处理的时间，使用了一个中间变量进行数值交换，并且还使用了加强了一下的效果，最后执行结果：
  _ 
_ 
  _ 
_ 
  _ 
_ 
  _ 
_ 
这段共享内存的使用是有竞争条件存在的，从文件锁的例子我们知道，进程间通信绝不仅仅是通信这么简单，还需要处理类似这样的临界区代码。在这里，我们也可以使用文件锁进行处理，但是共享内存使用文件锁未免显得太不协调了。除了不方便以及效率低下以外，文件锁还不能够进行更高级的进程控制。所以，我们在此需要引入更高级的进程同步控制原语来实现相关功能，这就是信号量的作用。我们会在后续章节中集中讲解信号量的使用，在此只需了解使用共享内存的方法。
我们有必要了解一下的内存占用情况，以便知道使用它的成本。我们申请一段比较大的共享内存进行使用，并察看内存占用情况。测试代码：
   _ 
 
 
 
 
 
 
 
 
 

  
  

 
{
    _ 
     
     _

    _ =   _|_ _|_  
     _ == _ {
        
        
    }

    _ 

    

    _ 
    
}
我们申请一段大概的共享内存，并置。然后在执行前后分别看内存用量，看什么部分有变化：
   
                                         
                                                                  
                                 
  _ 
 
   
                                         
                                                                   
                                 
可以看到，这部分内存的使用被记录到了和中。当然这个结果在不同版本的上可能是不一样的，比如在 的环境中的共享内存只会记录到中。除了占用空间的问题，还应该注意，方式的共享内存只能在通过产生的父子进程间通信，因为除此之外的其它进程无法得到共享内存段的地址。
共享内存
为了满足多个无关进程共享内存的需求，提供了更具通用性的共享内存手段，共享内存就是这样一种实现。是组织对定义的一套接口标准  。由于系统的历史悠久，在不同时间点的不同厂商和标准化组织定义过一些列标准，而目前比较通用的标准实际上是。我们还会经常遇到的标准还包括  标准，它们大概的关系是，是标准的超集，定义了部分额外附加的接口，这些接口扩展了基本的规范。相应的系统接口全集被称为标准，除此之外还定义了实现必须支持的的哪些可选部分才能认为是遵循的。它们包括文件同步，存储映射文件，存储保护及线程接口。只有遵循标准的实现才能称为操作系统。
共享内存在底层的实现实际上跟没有什么本质不同，只是在使用方法上有所区别。其使用的相关方法为：
 
 

 _  _   

      _ 

 
 

       

   
我们首先要来理解的是这一个参数。想象一下我们现在需要解决的问题：“在一个操作系统内，如何让两个不相关没有父子关系的进程可以共享一个内存段？”系统中是否有现成的解决方案呢？当然有，就是文件。我们知道，文件的设计就可以让无关的进程可以进行数据交换。文件采用路径和文件名作为系统全局的一个标识符，但是每个进程打开这个文件之后，在进程内部都有一个“文件描述符”去指向文件。此时进程通过打开的子进程可以继承父进程的文件描述符，但是无关进程依然可以通过系统全局的文件名用系统调用再次打开同一个文件，以便进行进程间通信。
实际上对于的共享内存，其的作用就类似文件的文件名，返回的类型的就类似文件描述符，注意只是“类似”，而并非是同样的实现。这意味着，我们在进程中不能用、、这样的方法去控制一个共享内存，因为它并不是“文件描述符”。对于一个的共享内存，其是系统全局唯一的，这就方便其他进程使用同样的，打开同样一段共享内存，以便进行进程间通信。而使用产生的子进程，则可以直接通过访问到相关共享内存段。这就是的本质：系统中对共享内存的全局唯一表示符。
明白了这个本质之后，我们再来看看这个应该如何产生。相关方法为：
 
 

_     _
一个是通过函数，使用一个和一个_产生的。就是说，在一个可能会使用共享内存的项目组中，大家可以约定一个文件名和一个项目的_，来在同一个系统中确定一段共享内存的。并不会去创建文件，所以必须指定一个存在并且进程可以访问的路径。这里还要指出的一点是，实际上并不是根据文件的文件路径和文件名产生的，在实现上，它使用的是指定文件的编号和文件所在设备的设备编号。所以，不要以为你是用了不同的文件名就一定会得到不同的，因为不同的文件名是可以指向相同编号的文件的硬连接。也不要认为你是用了相同的文件名就一定可以得到相同的，在一个系统上，同一个文件名会被删除重建的几率是很大的，这种行为很有可能导致文件的变化。所以一个的执行会隐含系统调用也就不难理解了。
最后大家还应该明白，作为全局唯一标识不仅仅体现在的共享内存中，标准的其他进程间通信机制信号量数组和消息队列也使用这一命名方式。这部分内容在《环境高级编程》一书中已经有了很详尽的讲解，本文不在赘述。我们还是只来看一下它使用的例子，我们用的共享内存来替换刚才的：
   __ 
 
 
 
 
 
 
 
 
 
 
 
 

  
  

 _ _
{
     
     _ _
    _ _
     使用产生 
     _ =  _ ==  {
        
        
    }
     在子进程中使用取到已经在父进程中创建好的共享内存，注意的第三个参数的使用。 
    _ = _  
     _   {
        
        
    }

     使用将相关共享内存段映射到本进程的内存地址。 

    _ =  _  
      _ ==   {
        
        
    }

       
     = _
    
    
    _ = 
       

     使用解除本进程内对共享内存的地址映射，本操作不会删除共享内存。 
     _   {
        
        
    }

    
}

 
{
    _ 
     
     _
     _ _
    _ _

    _ = 

     使用约定好的文件路径和_产生_。 
     _ =  _ ==  {
        
        
    }

     使用_创建一个共享内存，如果系统中已经存在此共享内存则报错退出，创建出来的共享内存权限为。 
    _ = _  _|_|
     _   {
        
        
    }

     将创建好的共享内存映射进父进程的地址以便访问。 
    _ =  _  
      _ ==   {
        
        
    }

     共享内存赋值为。 
    _ = 

      打开个子进程并发读写共享内存。 
     = {
         = 
            {
            
            
        }

          ==  {
            __
        }
    }

     等待所有子进程执行完毕。 
     = {
        
    }

     显示当前共享内存的值。 
    _ \ _


     解除共享内存地质映射。 
     _   {
        
        
    }

     删除共享内存。 
     _ _    {
        
        
    }

    
}
共享内存跟在实现上并没有本质区别。而之所以引入和的概念，也主要是为了在非父子关系的进程之间可以共享内存。根据上面的例子可以看到，使用可以根据创建共享内存，并返回一个。它的第二个参数用来指定共享内存段的长度，第三个参数指定创建的标志，可以支持的标志为：_、_。从 之后，还引入了支持大页的共享内存，标志为：_、__等参数。除了可以创建一个新的共享内存以外，还可以访问一个已经存在的共享内存，此时可以将置为，不加任何标识打开。
在某些情况下，我们也可以不用通过一个来生成共享内存。此时可以在的参数所在位置填：_，这样内核会在保证不产生冲突的共享内存段的情况下新建一段共享内存。当然，这样调用则必然意味着是新创建，而不是打开已有得共享内存，所以位一定是_。此时产生的共享内存只有一个，而没有，所以可以通过的方式将传给子进程。
当获得之后，就可以使用来进行地址映射。之后，通过访问返回的当前进程的虚拟地址就可以访问到共享内存段了。当然，在使用之后要记得使用解除映射，否则对于长期运行的程序可能造成虚拟内存地址泄漏，导致没有可用地址可用。并不能删除共享内存段，而只是解除共享内存和进程虚拟地址的映射，只要对应的共享内存还存在，就仍然可以继续使用映射使用。想要删除一个共享内存需要使用的_指令处理。也可以在命令行中使用删除指定的共享内存或。

共享内存由于其特性，与进程中的其他内存段在使用习惯上有些不同。一般进程对栈空间分配可以自动回收，而堆空间通过申请，回收。这些内存在回收之后就可以认为是不存在了。但是共享内存不同，用之后，实际上其占用的内存还在，并仍然可以使用映射使用。如果不是用或命令删除的话，那么它将一直保留直到系统被关闭。对于刚接触共享内存的程序员来说这可能需要适应一下。实际上共享内存的生存周期根文件更像：进程对文件描述符执行并不能删除文件，而只是关闭了本进程对文件的操作接口，这就像的作用。而真正删除文件要用，活着使用命令，这就像是共享内存的的_和命令。当然，文件如果不删除，下次重启依旧还在，因为它放在硬盘上，而共享内存下次重启就没了，因为它毕竟还是内存。

在这里，请大家理解关于为什么要使用，和相关共享内存的概念。后续我们还将看到，除了共享内存外，的信号量、消息队列也都是通过这种方式进行相关资源标识的。
除了可以删除一个共享内存以外，还可以查看、修改共享内存的相关属性。这些属性的细节大家可以  查看细节帮助。在系统中还可以使用 命令查看系统中所有共享内存的的信息，以及指定删除共享内存。
这个例子最后执行如下：
  __ 
_ 
  __ 
_ 
  __ 
_ 
  __ 
_ 
到目前为止，我们仍然没解决的问题，所以得到的结果仍然是不确定的，我们会在讲解信号量的时候引入锁解决这个问题，当然也可以用文件锁。我们下面再修改刚才的_程序，换做方式再来看看内存的使用情况，代码如下：
   __ 
 
 
 
 
 
 
 
 
 
 
 
 

  
  

 
{
    _ 
      _
     _

    _ = _  
     _   {
        
        
    }


    _ = _  
      _ ==   {
        
        
    }

    _ 

    

     _   {
        
        
    }

     _ _    {
        
        
    }

    
}
我们在这段代码中使用了_方式共享内存，这是与前面程序不一样的地方。执行结果为：
   
                                         
                                                                  
                                 
  __ 
 
   
                                         
                                                                   
                                 
跟的共享内存一样，的共享内存在现实中也会占用和的消耗。实际上，在内核底层实现上，两种内存共享都是使用的方式实现的，所以它们实际上的内存使用都是一致的。
对于系统来说，使用共享内存的时候可以通过系统调用的参数来申请大页内存 ，当然这样做将使进程的平台移植性变差。相关的参数包括：
_   
__ __   
使用大页内存的好处是提高内核对内存管理的处理效率，这主要是因为在相同内存大小的情况下，使用大页内存一页将比使用一般内存页一页的内存页管理的数量大大减少，从而减少了内存页表项的缓存压力和 缓存内存地质映射的压力，提高了寻址能力和内存管理效率。大页内存还有其他一些使用时需要注意的地方：

大页内存不能交换
使用不当时可能造成更大的内存泄漏。

我们继续使用上面的程序修改改为使用大页内存来做一下测试，大页内存需要使用权限，代码跟上面程序一样，只需要修改一下的参数，如下：
   ___ 

    _ = _  _|

其余代码都不变。我们申请的内存大约不到，所以需要在系统内先给我们预留以上的大页内存：
     _
    |  
     
_    
_     
_        
_        
        
是页数，每页，所以这里预留了几乎的内存空间给大页。之后我么好还需要确保共享内存的限制不会使我们申请失败：
     
     
之后编译执行相关命令：
     _ 
   
                                         
                                                                    
                                 
  ___ 
 
   
                                         
                                                                    
                                 
    |  
     
_    
_      
_        
_        
        
大家可以根据这个程序的输出看到，当前系统环境  再使用大页内存之后，命令是看不见其内存统计的。同样的设置在 环境下也是相同的显示。这就是说，如果使用大页内存作为共享内存使用，将在中看不到相关内存统计，这估计是命令目前暂时没将大页内存统计进内存使用所导致，暂时大家只能通过文件中的相关统计看到大页内存的使用信息。
共享内存的系统相关限制如下：
：限制系统用在共享内存上的内存总页数。注意是页数，单位为。
：限制一个共享内存段的最大长度，字节为单位。
：限制整个系统可创建的最大的共享内存段个数。
共享内存是历史比较悠久，也比较经典的共享内存手段。它几乎代表了共享内存的默认定义，当我们说有共享内存的时候，一般意味着使用了的共享内存。但是这种共享内存也存在一切缺点，最受病垢的地方莫过于他提供的＋的命名方式不够，没有遵循一切皆文件的设计理念。当然这个设计理念在一般的应用场景下并不是什么必须要遵守的理念，但是如果共享内存可以用文件描述符的方式提供给程序访问，毫无疑问可以在上跟、、这样的异步事件驱动机制配合使用，做到一些更高级的功能。于是，遵循一切皆文件理念的标准的进程间通信机制应运而生。
接进程间通信共享内存 下李光：现任职于腾讯社交网络运营部织云产品团队，负责织云监控告警平台规划与运维新产品开发工作，多年业务运维、运营规划经验。

概述
腾讯社交网络事业群拥有众多海量规模的业务，在海量的运营压力下，服务器设备的数量也突破了大关，并有序的分布在全国不同的中实现异地容灾的高可用架构。但正因为社交业务的多管理的复杂性，使运维小伙伴们经常会遇见一些难搞定的场景，如运营商网络出口异常流量骤降、网络时延飙高、断电断网、光钎被挖断、等突发事件，假设没有第一时间发现和处理好这些事件，就会有较大的几率影响腾讯社交产品的服务质量，甚至会造成用户大范围的登录与消息交互异常。
如何在种种不可控的突发情况来临时，业务能较从容的第一时间在用户“零感知”的情况下恢复服务质量呢？这就需要我们的业务要有完善的异地容灾架构与快速的全网调度用户能力。
本文介绍的是手机与两个服务于海量用户的平台级业务，在无损用户服务质量的基准原则下，通过亿量级人次的限时调度实战演习来验证我们的异地容灾架构与快速调度能力。

与异地容灾能力概要介绍
与 分钟级千万用户调度能力概要介绍
亿人次的调度演习

与异地容灾能力概要介绍
海量服务之道就是要给亿级用户持续提供高质量与分级可控的服务，所有的研发与运维行为都应该围绕保障与提升用户服务质量展开，面对种种不可控的突发情况时，恢复业务的服务质量为最高优先级要务。
让我们把时间拨回一年前，年日天津爆炸事件，相信很多的互联网从业人员都印象颇深，腾讯天津数据中心距离起爆点直线距离仅一公里，可能会受到波及，华北 多万用户将面临着登陆和访问中断的可能，那天晚上我们通过多次调度与柔性控制，在用户“零感知”的情况下，顺利的将天津全量用户调回深圳。
容灾能力是服务于业务，随着业务的持续发展。现在我们的整体容灾架构是三地分布，在各业务分布上实现化部署，链路均衡分布，完善容量架构，从而减少风险。
与的容灾能力演进主路线也是 单地—双地—三地。
三地分布也提升了服务质量，方便用户更加的就近接入。

与 用户数据三地均匀分布 ：：
单地常态负载，两地容一地    

可在用户“零感知”的情况下，将用户调往三地之一。
为了行文方便，后续出现“双平台”字眼时，如无特殊说明均指“”的统一体。
与分钟级千万用户调度能力概要介绍
对于调度用户，一般都是从流量入口即接入层分流用户，双平台也沿用与此思路。
 手机接入层
前端支撑手亿同时在线用户，后端连接多个业务模块，自身机器主要分布在三大城市的多个，每分钟处理亿个业务包，小时不间断为亿万用户提供着稳定的接入服务……这就是手接入层。
手终端与之间一般使用长连接，当前这是主流。当然也有使用短链接的场景，当终端无法跟后台建立长连接，或者有连接但数据通道不通的情况下会使用。然而，手终端与之间不是直连的，它们中间还隔了一层叫的东西。全称是 ，它是公司内部自研的一套多网统一接入，支持负载均衡的系统；它具有可靠性高、扩展性强、性能好、抗攻击能力强等特点。加入后终端与、后台之间的关系如下图所示：

用户登录概要流程如下图所示：

的主要流量入口来自手，因此双平台用户可以联动调度。
 调度能力介绍
根据业务发展的推动与场景的细化，双平台的调度能力主要为两个方向。
测速调度

全网网络质量的最优路径测算
实时干预能力即将用户调度到最优路径上
更细力度调度 如按网关调度


重定向调度

禁用原新建客户端链接
将原登录用户重定向到新



在对后台无冲击压力的情况下，我们可以完成千万在线用户分钟之内调度完毕，并且在调度期间用户无感知 上图就是我们在单次调度时清空一地在线用户数的下降速率。
调度场景

三地用户常态分布比例选用全网质量测速调度
紧急事件时选用快速的重定向调度方式
非极端情况下不会选用跨运营商调度，例如将电信用户调往联通

调度保护

地域、运营商、多纬度调度前后接入层容量自动保护
在达到某地接入层容量保护阀值后，调度行为自动终止调度操作
分钟级完成调度配置并实时计算下发
全自动化估算三地容量变化

 
亿人次的调度演习
为什么要现网演习？
故事场景： 某个电闪雷鸣、风雨交加的夜晚，运维小哥正舒服的窝在床上看着电影，突然手机一波告警袭来，个服务时延集体飙高，经排查是运营商网络出口异常，运营商也暂时未能反馈修复时间，经评估后快速根本的解决方法就是将故障城市的万用户调度到城市，运维小哥正准备使出洪荒之力乾坤大挪移的将用户移走，但是杯具的是调度系统掉链子了，调度任务计算与下发异常，极速吼上相关同学排查调度系统问题，同时开启后台柔性提供部分有损服务撑过故障期。
故事场景：活动开始，用户量逐步攀升，并且有地域聚集现象，城市的整体负载已经偏高了，需要迁移万用户调度到城市，以便减少的整体负载，在调度过程中发现因某条业务链路的短板，所能承载的增量用户要小于前期建设评估的整体用户量，增量压过去，会把压垮。
上面两个场景，运维小伙伴们可能都经历过，直接折射出问题是：只有通过实际场景检验的能力，才是我们运维手里真正可用的武器，而不是在军械库里放着，只是在盘点的时候“具备”的能力。

容灾能力与容量架构把控是海量运维必修内功，能力的锻炼就是要通过不断的实战演习得来。

如上图所示，通过一个完整的闭环流程，来不断的精耕细作数据化提升我们的能力，通过实战将问题暴露出来，避免紧急事件时的被动。
演习就是要伴随着场景、问题、目标来进行，要产生出可用于推动服务质量优化的可量化与精准的数据。
双平台是服务于海量用户，全网业务链路复杂，我们期望能从下面三个维度检验我们的能力。
、验证业务质量与容量 

通过实地演习验证三地分阶段建设容量，条带化容量建设是否符合预期
每增加千万用户时整体与关键业务链路负载是否可控
短时间内千万用户集中登录与关联行为的冲击后台是否能抗的住
柔性控制是否符合预期

、量化调度能力

异地调度时每秒能迁移走多少用户？ 
每调度用户需要多少时间？
清空一个城市的用户需要多少时间？

、运营平台

现有的平台能力实时容量、地区容量、调度平台、业务质量监控是否能较好的支撑到演习与实际场景调度
发现平台能力的短板

演习也是灰度逐步递进的节奏，下面图例展示了，我们对一个城市持续三次的调度演习，用户量级也是逐步增多  →  → 清空一个城市。
 
 
 
 
投诉量也显示对目标城市操作期间，对用户无影响。
我们持续进行了次实际演习调度，共累计调度亿人次。整个演习期间用户“零感知”，业务质量无损，无一例用户投诉。
如何规划演习的整体流程
演习流程的生命周期主要分为三个阶段

演习前期规划与准备
演习实施
演习结束，整体质量评估与问题跟踪

直接上实际我们的演习流程图，一图顶千言。


涉及哪些业务与同学业务第一负责人
地域目标容量与调度容量的对齐
业务质量的监控平台与异常时的回滚方案
假设因演习出现业务质量受损，这个影响范围要可量化与评估的
演习开始、过程、结束时演习角色、关注人的划分

演习质量评估
如何评估演习的质量，一般来说可以主要从下面两个纬度评估
调度质量

调度效率是否符合预期
调度速率是否可控，调度的用户量细化到分钟粒度应该是基本均等，不能忽快忽慢
调度量级是否符合预期

业务质量

调度期间是否有用户共性投诉反馈
后台服务质量是否可控
监控系统是否有批量告警
业务负载增长是否符合预期

演习流程的闭环跟踪
演习的目的就是在于发现问题而不是展示我们多，暴露的问题越多越好，每个问题都要完全闭环，一般通过以下几点描述所发现的问题。

问题说明
问题原因
负责人一定要落实的具体负责同学
解决方案
问题完成时间点
验证策略作者：黎斌

摘要
堪称中国最火爆的手机游戏“王者荣耀”，拥有亿级用户体量，千万级日活用户，如何快速、低成本地保障业务突发？本文从该问题出发，论述了问题对应的解决方案，并对其效果做出总结。

背景
“王者荣耀”是一款国民级手机游戏，用户体量巨大，而且一直保持着较高的更新频率。这种业务场景下，突发也变得非常频繁，然而业务体验是至关重要的，使用必不可少。类似地，经常有带宽突发的场景，比如新闻爆点视频、大型直播活动、热门影视剧上线、热门游戏等应用发布。同时，由于家庭带宽和移动网络的快速升级，突发带宽量级越来越大，经常达到级，甚至 。如何快速、低成本地保障业务突发，成为的一大挑战。
年，腾讯自建启用，接入了第一个业务腾讯网。到现在带宽量级，从最早的数十，发展到现在的数十；单业务的带宽也越来越大，大部分业务常量带宽在几百，部分突发业务达到了。网络的快速升级，移动用户爆发式增长，以及视频类业务包括点播和直播的兴起，使得业务突发越来越频繁，突发带宽越来越高，对的要求也越来越高。
自建得益于腾讯业务的蓬勃发展，先后支持了游戏下载、流媒体视频加速、春节红包等腾讯内部业务；年腾讯将全面能力开放，成为腾讯云产品，除承载内部业务外，也开始接入第三方客户，比如快手点播、斗鱼直播等。以上各种业务都有突发场景，也有很强的成本诉求，在如何低成本地保障业务突发，腾讯积累了丰富的经验。接下来就挑战和问题、解决方案、效果三个方面来解析。
一、挑战和问题
下面将从业务特点开始，分析目前存在的挑战和问题。
、 业务特点和挑战
多样化的场景，注定了突发业务充满挑战。突发业务具有体量大、场景多样化、 无规律等特点。
 体量大：突发业务带宽大部分都超过，部分甚至达到了 ；
 场景多样化：点播中的热剧和新闻爆点；直播中的／／等游戏直播，／世界杯等体育直播，演唱会等综艺直播；应用下载中的王者荣耀等游戏下载；静态网页加速中的红包活动、电商促销等；
 无规律：部分突发活动无法预知，活动快要开始或已经开始了才知道，比如新闻爆点。
体量大，需要准备更多的资源；场景多样化，需要满足不同的资源需求；无规律性则对我们的扩容效率提了很高的要求。
、 目前存在的问题
仅仅为了满足业务突发需求而储备大量的资源，成本太高，会造成资源极大的浪费。所以一般会通过复用资源来应对业务突发。但是直接复用资源，存在两个问题：
 只能复用部分资源：业务，一般按业务类型来区分平台和资源使用，主要原因是不同业务类型对资源需求不同，比如点播类需要更多的存储；有较多请求的静态页面类，则需要更多资源。这种限制使得资源无法充分利用，加大了资源准备的难度。比如视频突发主要使用视频，而下载类和网页类无法直接使用，这限制了的大小。即使复用同类型资源，因为涉及多个业务资源的协调，准备时间一般会超过两天，无法应对临时突发；
 无法降低成本：另外针对部分突发业务，比如游戏应用下载，带宽高峰期在上午和中午，如果只使用本平台资源，会导致结算带宽明显上涨，从而增加成本。无法利用同其他业务错峰的特点来降低结算带宽。
二、解决方案
腾讯云通过虚拟化复用现有资源，搭建全业务通用的突发池，所有平台共享。 突发池中的设备为虚拟机，虚拟机有不同的规格，只要业务有需求，都可以按需使用。突发池中的带宽储备达到了，基本能满足所有业务突发需求 。任何业务有突发需求，配合自动化上架接口，可在分钟完成突发池的扩容。
、 突发池系统架构
突发池系统架构见图图 突发池系统架构
 突发池：在各平台物理机的上层，由虚拟机组成的资源池，对内存磁盘等使用进行了限制，防止对物理机造成影响。原有业务依然部署在物理机上，不用调整。
 自动化部署和监控系统： 能根据业务实际需求，自动预测需求并扩容 。所有的突发需求，都能在分钟内扩容完成。针对点播下载业务，自动分发热点文件，降低回源带宽。
 调度系统：突发业务的突发性和体量大两个特点，使得相比域名调度系统，直通车更占优势。直通车调度更灵活，生效时间快，能达到分钟级。
虚拟机和物理机部署了上报，业务信息和服务器负载每分钟都会上报到监控系统。监控系统会根据历史带宽预测一个值，并与当前带宽比较，如果当前带宽超过预测值的，则认为有突发。根据带宽上涨的比例，系统会自动从突发池中扩容相应数据的设备。针对提前准备的突发活动，运维可以指定带宽需求量，之后系统便会自动计算设备需求并扩容。
分钟粒度上报的服务器负载信息则为监控系统做调度决策提供了依据。系统会依据机房剩余带宽、服务器带宽、、等综合信息决定虚拟机是否需要从直通车中启用或者禁用。用户访问时先请求直通车调度系统，直通车会根据调度策略返回一个地址，地址中为实际资源地址。用户跳转到地址，并获取实际内容。
、技术优化
使用虚拟化技术复用资源的重要前提是，不影响现有业务。这就要求对资源有充分的隔离，比如／磁盘，以及对带宽的使用。下面是实现过程中存在的几个问题及解决方案：
● 精准控制单机负载：负载过高会影响业务质量，需要对单机负载进行精准的控制。
解决方案： 配额系统：直通车中有配额系统，对每个虚拟机可使用的资源做了限制，包括／和带宽。监控系统中上报的信息，结合配额系统，可以确保服务器负载被限定在制定的范围内，粒度为分钟级。 部分请求返回：对／带宽／等做了限制后，应用程序能根据母机当前负载，实时判断是否处理一个请求。如果负载在限制范围内，直接处理；如果负载超出限制，则返回，使用户跳转到直通车的调度地址，这样能在尽量不影响业务质量的情况对负载做精准控制。程序层面对负载的实时控制，是配额系统的有效补充。 网卡流量控制：在极端情况下，业务带宽超过设定阈值，这时虚拟网卡会主动丢包，避免对母机造成影响。
● 限制磁盘大小：在文件系统中无法对文件／目录级别进行磁盘大小限制。
解决方案：由于腾讯云业务基本都是使用文件系统，这种情况下只能对根据用户或用户组对磁盘进行限制，但现网业务都是直接在环境下使用。这里我们使用 来解决磁盘大小限制问题。虚拟机中突发业务使用挂载在 上的目录，这样就可以间接限制磁盘大小，防止使用太多磁盘影响其他业务。
● 绑定：默认是绑定所有，部分单负载高会影响母机业务。
解决方案：通过脚本每分钟采集一次系统所有单负载，为避免频繁调整和受毛刺数据影响，取分钟的均值。最后选取负载较低的部分核，并通过配置文件来动态绑定，将虚拟机对母机业务影响降低到最小，并且能充分利用资源。
效果
突发池上线后，高效支持了王者荣耀下载、直播、游戏直播等多次大型突发活动，节约成本万。通过共享，搭建突发池能显著提高突发能力和降低成本。

总结
腾讯云通过技术复用资源，搭建级别突发池，能支持直播、点播、静态等各种业务突发，能自动检测到业务突发需求并在分钟内完成资源扩容，具有发布快，成本低等特点。资源复用能提高资源利用率，为业务提供极大的突发池，但要注意复用业务之间不能相互影响，这需要对服务器进行实时的监控和及时的调度。另外还有一些待改进的地方，比如内核参数基于容器隔离，方便不同业务调优；部分业务客户端不支持跳转，调度系统需要支持域名调度方式。
相关推荐
免费体验一分钟学会使用大赛简介
腾讯社交广告算法大赛以广告领域常见的转化率预估问题作为出题思路，从用户历史一个月的行为数据中采样竞赛数据，数据规模达几十。比赛题目足够诚意的同时，资金投入也显得诚意满满。比赛单奖金及奖品投入就近百万元人民币，一等奖奖金高达万，指导老师的奖励也颇为丰厚。
笔者在腾讯主要从事广告与上下文画像，点击率预估相关的工作。在大多数人眼中，点击率预估与转化率预估除了优化目标上的不同，其他差异并不明显。两者的解题套路以及使用的工具也颇为相似。但事实真的是这样吗？我将从点击率预估的视角来谈谈我对此次竞赛题目——转化率预估的看法。
转化率预估与点击率预估的异同
点击率预估和转化率预估都是广告领域的典型问题，它们之间有很多的相似之处，例如都是典型的二分类，点击率预估的工具和方法也常常应用于转化率预估问题上，但是它们又有着各自的特点。
相同点
无论是点击率预估还是转化率预估，都是一个典型的二分类问题，可以描述成下面统一的形式：

除掉建模对象需要考虑的信息不尽相同外，两者解决的问题极为相似。因此，用于点击率预估的常用方法、手段和工具，也常常应用于转化率预估问题上。
不同点
虽然两者从问题的定义上看是一致的，也确实共用了不少算法、工具和方法论，但是两者面对的问题和挑战存在差异，从某些方面来说，转化率预估要做好比点击率预估更难。
转化率预估效果采集更困难
点击率预估预测的是用户的点击行为，用户的点击行为可以通过在广告位上埋点进行上报，由于用户点击数据影响流量主的收益，因此通常流量主会尽可能保证点击效果回流的质量和数量。而转化率预估的是用户跳转到广告主推广页面的转化行为，数据采集依赖于广告主的配合。即使在广告主配合的情况下，也存在转化数据链路的工程稳定性问题。
转化率预估在效果数据采集上的困难是广告系统采用计费的一个主要难点。转化数据采集的能力，是腾讯社交效果广告的一大优势，在类广告中这种优势体现得尤为突出。
此次比赛数据中，转化效果数据是否存在漏报、误报的情况，也需要选手们自己去探索。
转化预估效果回流时间更长
广告曝光后，用户的点击行为往往随之触发，除掉部分特殊广告位外，点击效果回流时间多在分钟级。而用户的转化行为则发生在广告点击之后，部分转化动作发生周期比较长，例如，电商的下单转化、的激活转化。从点击到发生转化，这个时间可能达到小时级，甚至天级，当然，对于不同商品类型的广告，转化回流时间差异也很大。
不同类型商品的转化效果差异大
点击率预估在不同广告位上的点击率差异往往比较大，而转化率预估在不同商品类型上的转化效果差异更加明显。拿电商和的转化数据来说，两者的转化指标差异能达数倍之多。因此，如何考虑不同商品类型广告间天然的转化差异也是转化率预估的一个难点。分商品类型来优化是一个常见思路。
不过此次赛题只涉及一种商品类型广告的转化率预估，使问题难度降低了不少，也可以让选手更专注于其中一种类型商品的转化分析。
转化预估的效果定义更加丰富
点击率预估的效果就是用户的点击行为，而转化率预估的用户转化行为的定义则多种多样。常见的包括，用户的下单行为、的激活转化、微信上微信公众号的关注行为，也有在社交广告上新兴的赞点评转化。
现在还比较少涉及多目标优化，此次赛题也只以用户的激活转化作为转化率预估的目标。
转化预估的数据更加稀疏
点击率预估的训练数据是用户的曝光、点击日志，数据规模极大，多数情况下不需要考虑样本充分度的问题。而转化率预估预测的是用户点击行为后的转化，训练数据的规模与点击日志的规模相当，数据量减少了几个数量级。因此，不少在点击率预估问题上行之有效的方法和特征，在转化率预估问题上可能需要重新审视，比如模型复杂的时候训练样本是否充分，是否需要调大正则化系数等等。 
 计费：按广告的实际转化效果扣费
总结
笔者从点击率预估的视角对腾讯社交广告大数据竞赛的赛题做了点评，主要对比了广告点击率预估与转化率预估的异同点，突出比较了两者的差异性。选手在采用常见的点击率预估方案来解决此次的转化率预估问题的过程中，也可以参考上面提到的两个问题间的差异，求同存异，设计更合适的解决方案。使用云 实例的好处可能大家都知道 ，数据的安全性会得到保障，云有迁移工具，但貌似需要同版本迁移才可以，我的生成环境是   也是云服务器，因为后续是内网访问，所以需要手工迁移。

在云平台上，把数据库和数据库帐号都建立好，并建立好权限。
比如_  密码：要建立的强度高一些，放置恶意访问。
 在原有服务器上，生成脚本
由于是针对某一个库单独进行迁移，所以选择第二个选择特定数据库对象这里推荐前期先拿业务量不大的进行迁移，防止中间有问题，不好处理
下一步，点击高级 会有详细的生成表的细节，如果你有就选择上对应的。生成脚本即可。我选择的是因为以后我要直接复制到查询分析器里
 用自建的  连接
这里是要连接的内网。用最开始建的帐号和密码 进行登录，登录成功看到我们的数据库已经存在了，正常调出查询分析器，把刚刚生成的脚本进行运行中间如果有建库等多余的那些 你是可以删除掉的，保留最主要的表、存储过程什么的就行。
到此 运行脚本没有问题的话，会生成对应的目标表和存储过程
迁移数据
在自建  的对应数据库上右键，导出数据
填好原库帐号和密码，以及目标，目标帐号和密码，目标库名下一步，我这里选择第一个 复制一个或者多个表或者视图的数据我是全量迁移，如果有特别需求可以自己写全选数据表，之后看到目标表也是默认是同样的对应表名；而且在下面可以看到【编辑映射】激活了，我们点击
选择好，启用标识插入，保证数据一致性。
这样下一步就搞定了。我们把原有业务连接数据库的改一下测试，如果没问题，那么到此数据就迁移完毕了。
外网访问
   由于腾讯云上的数据库实例是内网，外网调试时候 有时候不方便，我们需要进行端口映射。腾讯云上有帮助手册是通过云，配套或 访问的由于我这里服务器都是使用的是环境，网上找了下 端口转发的工具进行转发，应该类似工具的不在少数在我们自己的云服务器上，我们配置一下
本地端口记着在防火墙要放过这个端口，以及映射主机的内网，以及默认端口，点击确定启动该映射。
这样我们可以通过云主机的外网： 访问这台数据库了。
：在管理上请使用   或者更高的版本，要不然会无法打开设计表的。

相关推荐
腾讯云下定时监测进程终止后自动重启的方法
轻松在云端部署、使用数据库
数据库的高可用性分析系列文章：关于程序员转型这件事，三位老炮跟你聊些干货上关于程序员转型这件事，三位老炮跟你聊些干货中
  智亮：你是我的眼——对计算机视觉的介绍

今天我们主要聊的是计算机视觉，咱们先从最大的概念开始说一说，人工智能，机器学习，计算机视觉。

人工智能这个概念一点都不新，机器学习也一点都不高深，那个计算机视觉也谈不上神奇，为什么这样说？
我们人工智能实际上在历史上，浪潮至少三次。
第一次年代到年代，叫符号主义流派，专家系统占主导地位。
什么叫专家系统？就是人去学一个东西，然后把学到的知识理论化，再把这些理论模型化，最后把这个模型程序化，形成一个系统，就叫专家系统。
专家系统巅峰在年，公司的跳棋，战胜了当时的人类高手，引爆了第一次浪潮。
专家系统能解决一些问题，但是也解决不了很多问题。
到了年，统计时代开始盛行。统计流派巅峰在年，系统性的提出了一篇论述叫支持向量机，现在这个算法在很多地方被大量的使用，它非常有效。
引爆第二波浪潮的重点就是年，的深蓝战胜了当时的国际象棋冠军卡斯帕罗夫。

年的阿尔法狗引爆了第三波浪潮，我们这一波的流派现在还没有名字，我更倾向于把它叫暴力流派。
年提出过一个经典的论文，这篇论文虽然在年提出，但是我们神经网络是一个非常老的概念，它的前身要追溯到年的多层感知器反向传播算法。
这里边还有一段历史公案，就是老爷子和老爷子，他们学术矛盾很深，在、年代外面一个占据主流的时候，神经网络被打压到连论文都发不出去，业都毕业不了。现在老爷子算是打了一个翻身仗。
刚才说到我们三次浪潮，前两次每次都是这样，说人类要毁灭了，后来发现其实并不是这样。

我们现在就处在这个状态，人类又要毁灭了。其实和前两次比，还是有一点区别。
我觉得最大的一个区别就是它现在真的是深入到我们生活的每一个角落，打开你的手机看看，淘宝，智能推荐，拍一拍，谷歌翻译，搜索引擎，智能出行，智能规划，微信，智能助理，头条，智能推荐，还有机器识别，其实它已经深入的改变了我们生活的每一个角落，而将来它会改变更多。

然后我们刚才说为什么机器学习一点都不高深。当年，老爷子他提出支持向量机有一个核心概念，这个世界是线性可分的。
什么叫线性可分呢？线性就是一条直线，二维空间里它就是一条直线，三维空间里它就是一个平面，他认为这个世界用直线能全分割开，在我们的二维世界给它变一个纬度也能分开。
有点像我拿着一堆木球和铁球，你在它们在地上滚，然后你让它一刀切，分成两堆这是不可能的，但没关系，我把它放到水里，木球漂起来，铁球沉下去，横着来一刀，这就是支持向量机的核心理念。

虽然有些时候是这样的，但是并不是所有时候都能够成立，所以支持向量机当时只能解决简单世界的问题。
而神经网络是用了一个比较复杂的结构，多层感知机。
现在深度神经网络用了一个非常复杂的多层、高阶的结构，然后去拟合我们现实的世界，它比支持向量机要成功得多。但是如果说它真的能够拟合我们真实世界的所有情况，其实还差那么一点意思。这也就是说为什么我说，机器学习或者神经网络没有那么高深。

它本质上不对这些问题进行数学上的建模，我就是用一个很复杂的神经网络，做出了一个足够复杂的方程，等于，这个方程参数非常多的，阶数高，非常的巨大，我们的输入是，这个方程给我们算出来。
然后我们比如说我们看一张图片，我们这张图片输入就是，一只猫，这只猫它真的是一只猫，我们的期望就是这个，计算出来的结果等于猫，这就是我们目标，怎么让它等于呢？就是我们用大量的数据不断的迭代。
当年，老爷子提出这个东西之后，被老爷子批评，说你这个东西一点数学的美感都没有，老爷子在数学成就上确实不如他老人家，这也是历史公认的。但是一句话，我好使，我有用。
但是现在也有人质疑什么呢？我们这么算出来的东西，为什么？什么原理啊？它怎么就好使了呢？不知道，但是我们知道，这个复杂的非线性方程，它能够在某种程度上模拟出来我们真实世界的情况，但它具体怎么模拟的，是一个黑箱，我们都不知道，阿尔法狗下棋能赢柯洁，没问题，但是你让他去教围棋，那是一把瞎，别说阿尔法狗教不了，写阿尔法狗的人也教不了。

再说智能，我们的大脑就是一个典型的智能。
佛家有六识，眼、耳、鼻、舌、身、意，它对应的是六尘色、香、声、味，触、法。视觉，听觉，嗅觉，味觉，触觉，以及我们的思考，这个构成了我们的智能。
而计算机如果想有智能，它首先也得有这些感官，有输入才能有思考，有思考才能有输出，有了输入、思考和输出，它才有智能。而我们今天主要讲的就是在我们生活中，我们最大的信息来源，视觉。放在计算机上，就是计算机视觉。

当前的计算机视觉，它的技术上一般是有叫卷积神经网络。这个东西就是用大量的神经网络堆叠起来。
比如，给一个输入说，这是个人，而且是个女人，计算完了以后，得到输出，只要这个网络得出的是个女人，就。换句话说，我给它的每一个训练数据，我都告诉他正确答案是什么，这个就是监督式学习。
然后呢，它和以前的模式识别，特征检索，是有比较大的区别，区别在哪里？
其实它也有特征提取和特征检索，为什么说有区别？
区别在这，它的特征不是我们告诉的，不是我们编码，不是我们手工设定，而是通过大量的数据，它自己学习出来的，这也是神经网络和以前的所谓专家系统最大的区别。

那我们来看看，单就计算机视觉这个领域它能做什么。上图就是大家现在能做得非常好甚至超过人的一个例子，在这张图片里面，有很多东西，计算机能够把它分析出来。它能够从一个图片里面区分出不同的物体，并且辨别出它们是什么，在哪里，这是能做得事情。

这张图是毕加索的公牛，毕加索在画这一系列的图时有一个目的，说我画的公牛跟真的公牛一模一样，你能认出来，说明我画的好，如果我画的跟真实的公牛不一样，你们是怎么认出来？
我全涂成黑的，是牛；我再黑一点，细节全都丢失了，还是牛；那我把纹理去掉，把形状变一下，把各种全都抽象起来，到这还是跟我们平时看到的比较接近，画到后来还有人认为是牛，那么对人来说牛到底是什么东西？为什么这个样子是牛？这就是抽象。
我要说的就是计算机视觉现在有两个非常大的不能做的事情，第一就是抽象。

第二件事情很有意思，看上图，计算机第一反应有可能是猫，但是再仔细看看，就不认识了。我们的计算机视觉至少在目前这个阶段，它不知道自己不知道，这个事它做不到。
这两个事，一个是看到抽象的东西它认识，另外一个是看到不认识的东西，它知道自己不认识。在目前的卷积神经网络这个结构下，计算机是做不到的，它并不是万能的。
当然它也能做很多事情，接下来，我就仔细的看一下，卷积神经网络的一个大致的发展历程。
卷积神经网络开拓者 做了一个非常简单的卷积网络，去做手写数字的识别，也就是我们现在每个人初入机器学习，一定接触到的一个。
他做了一个数据集，用了一个卷积神经网络去计算一个手写的数字，它到底是一二三四五六七八九中的哪一个。这个东西做的非常的成功，美国的邮政和银行都在用，但是并没有产生太大的反响，因为支持向量机，也能做到同样的事情。
第二个，，刚才两位老师也提过，他也是老爷子的学生。年，他刷爆了计算机视觉的比赛，以碾压性的优势，干掉了所有的的东西，从那以后卷积神经网络才成为了计算机视觉的标配。
第三个人，何凯明，微软亚洲研究院出来的，年他提出的参加网络也是卷积神经网络的一种。这一年，计算机在的比赛成绩超过了人类，虽然不像阿尔法狗那么有名，但是在计算机视觉史上这个时间点是要被铭记的。
下一个时代在哪里？是不是在你们中间，我也不知道。
介绍完了历史，我们来看一看卷积神经网络最大的特点。这个特点在于它能够自己去学习这些特征，我们看一下一个非常经典的一篇论文，叫做《   》，非常有名。
他们做了一个实验说，我训练一个非常简单的积卷神经网络，训练出来之后，我想看一看究竟学到了什么，大家都说它是黑箱，那我们打开看一下，到底学到了什么东西。

第一层，他们发现，都是非常简单的直线，斜线，各种颜色，这些非常简单的纹理。用这种形状的卷积核能够把图片上面的线条区分出来。这个网络在没有任何人工指定的情况下，大量的学习数据网络，它天然学到的，非常的巧合，或者说也是必然。
第二层，每个九宫格是个神经元，在我们用大量数据去输入它的时候，它会给出一个反馈。这个反馈是一个数，越高，代表它越兴奋，对这个输入越敏感。
它在所有的数据里面，找出了让这个神经元最敏感的九张图，并且通过反卷积的方式把它计算出来，它不代表这个神经元就是这个内容，而是这个神经元对这样内容的东西最为敏感。我们能看到第二层里面出现了圆形和各种角度的弧线，我们在大量的观察之后，得出一个判断，这个网络的第二层对形状敏感。

第三层，我们看到的纹理有点像长颈鹿，在经过大量的数据研究之后呢，我们认为它的第三层是对形状，纹理，这些信息比较敏感。

第四层，就开始对纹理形状结合，是对形状和纹理的复杂结合开始敏感。
第五层的时候，它就开始把所有的信息结合起来，形成一个高阶的概念。比如，我对狗敏感，我对花敏感，我对人脸敏感，它在一层一层这样不断递进之后，把上一层的信息，结合起来，然后形成下一层的输入，通过不断的训练自己，让每一层的神经元对不同的信息产生反映。

计算机视觉这个领域，它现在的课题大概就是这么几个。
首先就是识别，比如，这张照片，我能说出来它是人，那么就。
然后就是检测，检测的目标是我不但要说出来这个照片都有哪些东西，我还要知道它在哪一块。
再然后是语义分割，就是我画框已经满足不了我，我要精确的描绘出来这个人的轮廓，我要把有语义的东西从背景里面挑选出来。
最后一个叫描述，比如我给你一张图，你要给我一句话，一个女人和孩子在看电视，如果我们粒度再细腻点，还要说电视里面有一只狮子，这就是我们描述要做得事情。
识别检测分割和描述，就是当前计算机视觉的四个重要课题，现在很多论文都是围绕着这几个方面。
识别已经超过人了；检测还比人差点，但是不会差特别多；语义分割差的稍微远点，人能画出来，它不一定能画的像；描述，英文方面，现在是大概能看，说出来的东西比较靠谱，中文，基本上是一个空白，现在大概就是这样的情况。

然后如果说我们刚才看到的识别，检测，分割和描述，是我们现在在研究的这个领域，那么它的未来在哪里？
这是我个人的判断，首先说我们人在看到这个世界的时候，不是通过一张张的照片去认识这个世界，我们看到的是连续的，流动的物体，我们在大脑里面接受的是视频，这个也是视觉的一个发展方向，它未来必然是以视频或者序列为基础。
第二个大的发展方向，就是理解和分组，像上图，我们人一看到，就知道这是草地上有一条公路，公路上有一辆车，有一个树把车挡住了，在我们的脑海里是这个样子。但是计算机确实不是这么理解的，而让他能够这样去理解问题，就是我们未来的一个研究的目标。
第三个，叫无监督和。比如，我们现在都知道这个大赛，它一共有个类别，每个类别平均下来有一千张图像，加在一起是一百多万张图片，每张图片都有标签，都告诉你这张图片是什么东西。
所以大家现在看到的很多这种检测都是这样，为什么呢？因为他们只有这样一个大量的数据都有标签，我们倒是想训练出来一个能识别其他的东西的，但是没数据。
所以未来我们的方向有一个很重要的分支，我们怎么样能够缩减数据的需求量，最好是什么呢？我给你图片，哪怕一千万张都可以，但是你别让我每张数据我都给它标个标签，太累。
无监督学习是个分组的过程。举个例子，分组的过程就相当于是，我看到无数只猫的图片，我不知道它叫什么，但是我知道所有这些猫都是同一个东西，当我把猫这个概念抽离出来以后，你给我一张照片，说这个物体叫做猫，我瞬间就明白了猫这个概念，这个是我们的无监督学习。也是我认为非常重要的一个方向，甚至说能不能够改变我们未来的产业的格局，就是最后一点。
如果说每一个数据都要监督，每一个分类都要一百张带标签的图片，那就只有、这样的公司玩儿得起这个产业，但是如果当无监督出现之后，我们会看到，整个这个人工智能或者叫计算机视觉这个领域，会进入到一个群雄并起的局面，这个技术的成功，或者失败决定了未来的产业化的发展方向。

介绍一下目前用计算机视觉技术做的一些市面上的应用，这个东西就是我们做得一个识花的东西，对着一个花，拍张照片，我告诉你它是什么，从技术本身来讲其实没有太大的难度，就是一个简单的识别。

然后还有一个比较有意思的东西，，用到的是英文，给你一张照片，选定一个名作，比如梵高的星空，选定一个艺术风格之后，对这张照片进行应用，我们得到一个内容还是这张照片，但是风格变成了星空，或者呐喊的这样一张图片。
为什么把它们两个提出来呢？因为这两个应用用的技术都不难，投入也非常的小，像我们花伴侣，第一个用了一个星期训练，一个下午写，出来之后，大概四个多月的时间就有了一百多万的用户，最可怕的是什么呢？它从到十万，花了三个月的时间，然后到三月的时候，春天来了，野花开了，一个月的时间，从十万变成一百万。而是周，一千万用户。
我们并没有用多复杂多高深的技术，都是计算机视觉技术一个简单的应用，但是引爆了我们的社会，这也是我们为什么要去了解计算机视觉，了解机器机学习技术的原因，因为在之前这些技术并不是保密，是公开的，他们都流传在学术界。
我们为什么说机器学习是个的大的机会，学术界的宝藏，刚才两位老师也提到了，算法的红利，在于把它拿到工业界，学术界已经玩儿的不爱玩儿的东西，但是你把它向公众开放，让大家看到它能做什么之后，往往会爆发出连你自己都想象不到的一个巨大作用。
然后接下来就介绍一些前沿的尝试，这个是从年开始，在学术界就非常热门的一个叫对抗生成网络的技术。
意思就是说我有两个网络，一个网络不断的去创造出来东西，相当于各种各样的造假；而另外一个网络呢，我就去负责分辨真伪，这两个网络不断的去训练自己，去提升自己。
造假一张接着一张的往外造，分辨网络再去分辨是真是假，这样它们两个在不断对抗磨合的过程中，只要有训练数据，就等生成一个以假乱真的东西。

这个是对抗生成网络的一个例子，你用手画个猫的轮廓出来，它给你生成一只猫，但是很快被人玩儿坏了。左边这样的东西，大家能够说很像是猫。但是右边呢？真正能像人一样，画出来的都像猫吗？有一定的距离，但是这个技术现在确实是未来的一个非常重点的一个方向。

这几张图是哪位大师的作品呢？我们肯定不知道，因为都是电脑画的，没有一张是人画的，但是看起来好像都很厉害的样子。计算机造了大量的图片出来，然后让人去挑，说哪个你觉得最有艺术价值。

然后这个呢，是挑战对世界的理解，为什么这么说？上边大家看到的是真实的行车记录仪拍摄下来的记录，下边这个是计算机根据第一帧的真实的画面，自己训练的生成后面的画面，凭空生成，无中生有，这也是对抗神经网络的一个非常可怕的点，也许有一天你看到的视频，你根本就不知道是真是假。

最后一个，是比较老的论文，但是我觉得代表了很多东西，就是它不光是能够学习图片上的特征，它还能学习它的语义。大家看，我有一堆照片训练出来说第一个戴眼镜的是男人，然后剪掉一个男人，加上一个不戴眼镜的女人，得到的是戴眼镜的女人，这篇论文非常的有意思，后来没有在语义上面学术界没有跟得太紧，但是这可能是我们未来一个很大的一个爆发点，很有意思。
【完】

文章来源：科技大本营一、服务的三种访问方式介绍
中对于服务的访问，提供了多种访问方式，以适应不同的使用场景。其中主要的访问方式有以及三种。
三种访问方式详细对比说明入下表所示



访问方式
说明
优点
缺点
备注




方式
默认类型，自动分配一个仅内部可以访问的虚拟。可以通过来访问该服务
使用简单
仅支持集群内部访问



方式
在基础上为在每台机器上绑定一个端口，这样就可以通过来访问该服务
支持内部和外部访问，无额外外部依赖
直接作为负载均衡器，性能较差。同一个集群内，服务的不可重复。
默认端口范围为


方式
在的基础上，借助 创建一个外部的负载均衡器，并将请求转发到
能更好的利用平台的负载均衡能力
创建时依赖于各个云平台的 ，存在两次转发
 中 已经独立成



  访问方式，适用于集群内服务间相互访问的场景，其访问的流程如下图所示：

访问的数据流向为     
、  通过访问，可以通过环境变量或者查询
、   通过或者端口转发到服务的任意一个端口，可能在同一节点，也可能在不同节点
  访问方式，在无外部负载均衡器的情况下，可以通过提供外部访问的能力，其访问的流程如下图所示：

访问的数据流向为    
、 通过访问，可以是集群中任意一个节点的一般通过随机分配，默认分配范围为
、  同访问
  在外部存在负载均衡器的情况下，一般通过的方式实现外网访问其底层依赖于，其访问的流程如下图所示：

访问的数据流向为  负载均衡器  
、 负载均衡器  通过访问，也可以通过负载均衡器中绑定的域名进行访问
、负载均衡器  负载均衡器在可用的节点中，根据均衡算法选择一个节点进行转发，转发的目的端口为
、  同访问
二、服务访问在腾讯云容器中的使用情况
腾讯云容器服务目前提供的服务访问方式包括  对公网负载均衡访问，同内内网负载均衡访问，仅集群内访问等几种方式。同时用户也可以通过创建负载均衡器，先通过外部的负载均衡器将流量转发到 上，再有实现转发目前仅支持层转发。
 外网负载均衡访问，在创建服务时选择负载均衡访问方式为公网。客户端访问流程集群中的服务流程入下图所示

访问的数据流向为  外网外网负载均衡器  
访问的具体流程，与访问方式相同，腾讯云容器服务在内嵌入腾讯云的 。在控制台创建服务时，如果选择了公网访问，腾讯云的 会自动调用腾讯云的负载均衡服务创建一个外网的，并与该服务绑定。
在容器服务控制台，点击服务选中一个服务后单击选中展示服务信息可以看到服务中访问有关的信息，下图是作者用来的一个例子


其中访问相关的信息包括： 服务关联的负载均衡器，外部访问服务的方式通过，集群内范围服务的方式通过等
点击展示的负载均衡器，跳转到负载均衡器页面，可以看到负载均衡器信息。

从负载均衡器中的展示信息可以看到，负载均衡器暴露服务端口在服务创建时用户填写，建议与容器端口保持一致对外提供访问，负载均衡器后端监听各个节点，监听端口为该为该服务分配的该端口由集群随机分配，默认范围为。
 同内内网负载均衡访问，在创建服务时选择负载均衡访问方式为内网。客户端访问流程集群中的服务流程入下图所示

访问的数据流向为  内网外网负载均衡器  
处理流程与通过外网负载均衡访问集群内服务相同，只是负载均衡器为一个内网，仅支持在同一内访问，不提供外网访问的能力。在控制台创建服务时，负载均衡器模式选择内网，腾讯云的 会自动调用腾讯云的负载均衡服务创建一个内网的，并与该服务绑定。
 仅集群内访问，创建服务时默认提供服务间互相访问的能力，通过服务名称和都可以访问，但仅限于集群内部服务互访

访问的数据流向为     
集群内访问能力，为默认提供的能力，如果需要仅支持集群内访问则在创建服务时选择仅支持集群内访问选项。在外网和内网负载均衡器访问的服务中，集群内访问能力依然支持
三、腾讯云容器服务中对应的安全组设置策略
安全组策略设置，一直遵循的原则是开放最小权限。例如在一个服务的场景中，访问流程入下图所示：

访问的数据流向为  外网外网负载均衡器前端服务后端服务
根据安全组设置最小权限原则，安全组开放规则为
前端服务节点开放端口的外网内网入规则，开放端口的内网出规则
后端服务节点开放端口的内网入规则
在集群中，由于前端服务和后端服务采用分布式部署的策略，根据资源的使用情况不同服务的还会出现实例的迁移。所以建议在设置容器服务安全组策略时，将集群内所有节点的安全组策略设置为一样。
同时考虑腾讯云容器服务中提供的访问方式，外网负载均衡，内网负载均衡，集群内访问，访问的数据流为外网负载均衡数据流  外网外网负载均衡器 
内网负载均衡数据流  内网外网负载均衡器 
集群内服务互相访问     
所以需要放通的安全组规则为：
、放通该服务内外网访问的入规则 外网负载均衡，内网负载均衡
、放通该服务容器端口内网访问的出入规则   外网负载均衡，内网负载均衡，集群内访问
、放通服务访问的端口，协议
为了简化用户在设置集群中服务访问安全组规则的复杂性，腾讯云容器服务提供了集群中服务访问的通用规则模板。用户在集群创建时，点击新建安全组，则可以自动创建。该模板规则如下：


通用规则规则为： 
入规则：放通端口，支持通过的访问             放通内网直接相互访问，支持服务直接集群内互访                  放通服务端口 主机通用设置
出规则： 放通全部端口
在创建集群或者往集群内添加主机时，建议将安全组规则设置为该模板提供的通用规则。如果有更强的安全防范需求，用户可以在该规则的基础上，做进一步的修改，以满足业务的访问需求，但最小规则应该满足集群中服务访问所需要满足的规则。前言

对于来说，内存泄漏就是出来的对象没有，俗称野指针；对于来说，就是出来的 放在上无法被回收；本文通过和中内存泄漏实例来讲中内存泄漏分析解法和编写代码应注意的事项。
 中的内存分配

静态储存区：编译时就分配好，在程序整个运行期间都存在。它主要存放静态数据和常量；

栈区：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存；

堆区：通常存放  出来的对象。由  垃圾回收器回收。


四种引用类型的介绍

强引用： 宁可抛出  ，也不会让  回收具有强引用的对象；

软引用：只有在内存空间不足时，才会被回的对象；

弱引用：在  时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存；

虚引用：任何时候都可以被回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为回收的标志。


我们常说的内存泄漏是指出来的无法被回收，即为强引用：

内存泄漏发生时的主要表现为内存抖动，可用内存慢慢变少：

中分析内存泄漏的工具

  是一个  插件，它是一个快速、功能丰富的 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。

 插件的下载地址： 

 使用方法介绍：



和内存泄漏如何监控

和 的内存泄漏采用解决方案，是一个性能监控、分析的统一解决方案，它从终端收集性能信息，上报到一个后台，后台将监控类信息聚合展示为图表，将分析类信息进行分析并提单，通知开发者；

由和

 两部分组成；

在自动内存泄漏检测中是一个衔接检测组件和自动化云分析的中间性平台，它从的内存自动化上传；

后台会定时提交分析任务到；

分析结束之后会更新数据到 上，同时以单形式通知开发者。


常见的内存泄漏案例
  单例造成的内存泄露
单例的静态特性导致其生命周期同应用一样长。
解决方案：

将该属性的引用方式改为弱引用
如果传入，使用

：

泄漏代码片段


       
  {
}    
    {        
      ==  {           
         {                
              ==  {
                 =  
            }
        }
    }        

     
}    

  被点击的
 
   =     
    {
     = 
}
：使用
       
  {
}    
    {        
      ==  {            
          {                
              ==  {
                 =  
            }
        }
    }        

     
}    

  被点击的
 
   =     
    {
     =  
}
  匿名内部类
在中，非静态内部类 和 匿名类 都会潜在的引用它们所属的外部类，但是，静态内部类却不会。如果这个非静态内部类实例做了一些耗时的操作，就会造成外围对象不会被回收，从而导致内存泄漏。
解决方案：


将内部类变成静态内部类

如果有强引用中的属性，则将该属性的引用方式改为弱引用

在业务允许的情况下，当执行时，结束这些耗时任务



：
     {  
    
        {    
        
        _
        
    } 
    这儿发生泄漏    
       {    
           {      
            
               {        
                  {          
                     {
                        
                    }    {
                        
                    }
                }
            }
        }
    }
}
：
     {  
    
        {    
        
        _
        
    }  
    加上，变成静态匿名内部类
        {    
           {     
            
               {        
                  {          
                     {
                        
                    }    {
                        
                    }
                }
            }
        }
    }
}
    的不正确使用
在应用程序中通常可以使用两种对象：和。当类或方法需要对象的时候常见的做法是使用第一个作为参数。这样就意味着对象对整个保持引用，因此也就保持对的所有的引用。
假设一个场景，当应用程序有个比较大的类型的图片，每次旋转是都重新加载图片所用的时间较多。为了提高屏幕旋转是的创建速度，最简单的方法时将这个对象使用修饰。 当一个绑定在上，实际上这个对象就会成为这份的一个成员变量。而静态变量的生命周期要长于。导致了当旋转屏幕时，无法被回收，而造成内存泄露。
解决方案：


使用代替，因为会随着应用程序的存在而存在，而不依赖于的生命周期；

对的引用不要超过它本身的生命周期，慎重的对使用“”关键字。里如果有线程，一定要在里及时停掉。



：
   

    {  
    
      =  
        
      ==  {
         = _
    }
    
    
}
：
   

    {  
    
      =  
        
      ==  {
         = _
    }
    
    
}
  引起的内存泄漏
当中有延迟的的任务或是等待执行的任务队列过长，由于消息持有对的引用，而又持有对其外部类的潜在引用，这条引用关系会一直保持到消息得到处理，而导致了无法被垃圾回收器回收，而导致了内存泄露。
解决方案：


可以把类放在单独的类文件中，或者使用静态内部类便可以避免泄露

如果想在内部去调用所在的那么可以在内部使用弱引用的方式去指向所在使用  的方式来达到断开与之间存在引用关系的目的。





   {        
            
      =  {
        
    }
     = 
     = 
}
  注册监听器的泄漏
系统服务可以通过 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的监听器中。然而，这会让服务持有 的引用，如果在 时没有释放掉引用就会内存泄漏。
解决方案：


使用代替

在执行时，调用反注册



 =  _
：
 =  _
下面是容易造成内存泄漏的系统服务：
  =  __
：
   {        
      =  {
        
    }        
      =  { 
        
    }        
      =  {
        
    }        
    
}
  ，没有，没有
资源性对象比如，文件等往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 虚拟机内，还存在于虚拟机外。如果我们仅仅是把它的引用设置为而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如在析构函数如果我们没有关闭它，它自己会调关闭，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的函数，将其关闭掉，然后才置为 在我们的程序退出时一定要确保我们的资源性对象已经关闭。
：

调用


   {
    
    
}

在中调用

   {
      {            
        
    }

    
     = 

     =         
      =  {
            
    }        
      =  {
        
    }
}
  集合中对象没清理造成的内存泄漏
我们通常把一些对象的引用加入到了集合容器比如中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是的话，那情况就更严重了。所以要在退出程序之前，将集合里的东西，然后置为，再退出程序。
解决方案：

在退出之前，将集合里的东西，然后置为，再退出程序。


      
   {        
      =  {
        
         = 
    }
}
  造成的泄露
当我们不要使用对象时，应该调用它的函数来销毁它，并释放其占用的内存，否则其占用的内存长期也不能被回收，从而造成内存泄露。
解决方案：

为开启另外一个进程，通过与主线程进行通信，所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。

  构造时，没有使用缓存的
初始时会从中根据当前的屏幕布局实例化一定数量的对象，同时会将这些对象 缓存起来。
当向上滚动时，原先位于最上面的 的对象会被回收，然后被用来构造新出现的最下面的 。
这个构造过程就是由方法完成的，的第二个形参 就是被缓存起来的 的对象初始化时缓存中没有对象则是。导语
日常喜欢浏览各种技术网站包国内主要浏览等 会遇到一些不错的文章整理推荐给大家。内容包括最新的最热门的以及基于的 还有等方面高质量文章。
 || 
  
 手册
 文档
  

每天花两分钟时间就可以了解到一些精选的实践，这些实践包括性能，语言应用等
如何写一个你自己的库？
如何成为一个 大牛？
这篇文章讲述了如何从一个新手成长为大牛的一般过程，非常值得一看。

  
 

    
        
    
     
     
   
 
  
       ’  
对比几种主流动态更新方案包括  和  以及的 最后指出在可整合性声明式组件化开发等方面相对做的更好，推荐优先采纳从这篇文章，可以看出各方面的优异，是一个可以近中期投入的技术。
      
数据变动检测是界面开发的核心问题。本文讨论了三种主流框架数据变动检测的方式，分别是的数据绑定，手动负责更新；的脏检查，定时检查那些已注册进观察对象里的片段，如果有变动，就更新这些片段的虚拟，将界面抽象为虚拟树界面变化时 前后虚拟对比，最小化更新已变动的地方。

核心算法探索
使用优化
      
的新引擎— 是什么？
     
     
 
 动画研究和对比
  
   
      

       
               
也谈全栈式开发
     
     
面试

      
  
 
        
           
     
 
   兼容实现总结

 能使得绝大部分浏览器都能支持 用法和正常使用媒介查询一样

    
  
阮一峰讲
将的代码转换成什么样子

 实用调试技巧


函数式编程术语解析
目前个人正在维护一个，将持续追踪最新优质前端资源，欢迎一起贡献分享。接《关于程序员转型这件事，三位老炮跟你聊些干货上》
   孟岩：人工智能的泡沫与啤酒

 人工智能产业有没有泡沫？
著名财经作家吴晓波最近发表了一篇文章，《为什么新科技的风口总火不过一年》，在文章中引用了技术发展曲线，他认为人工智能目前处在第一波峰的顶点，那么很显然，马上就会面临泡沫的崩溃。如果他的判断是正确的，那么这将是第三次人工智能的泡沫破灭。
作为财经作家，吴晓波非常的博学，而且也特别的聪明，他能够很快的从一个现象当中抓住足以引爆舆论的点。但从专业角度分析的话，这个判断有问点题。从这幅图上来看，无人机、机器人和物联网已经开始爬坡了。

那问题来了，如果无人机、机器人和物联网即将迈上迅速成长的阶梯，你怎么可能想象人工智能会崩溃呢？因为无人机，机器人本身就是人工智能的应用平台，而物联网则是大数据的最大来源，会有力的推动人工智能的发展。大家要理解，在无人机、机器人、物联网这样的技术浪潮当中，人工智能将扮演很重要的角色。
所以我直接说我的观点，人工智能目前没有泡沫。
具体的分析一下。
第一，本轮人工智能技术的红利还没有吃完。今天人工智能的热潮，是技术上主要是深度学习的突破引发的。深度学习理论上的突破是年，所以大家会问一个问题，年过去了，深度学习的红利是不是已经吃完了？
 我们来看，这张图是吴恩达在一本书叫   的书里面一幅著名的插图，纵坐标是算法的表现，横坐标数据量。从这个图中你可以看到，对于大规模的神经网络来说，数据量越大，它的性能就会越高，也可以说它的能力越强。我问过在这方面非常顶尖的专家，目前有没有看到顶点？他告诉我说，他们有人已经做到上万层的深度神经网络，还是没有看到这个顶点在哪里。深度学习它的红利是很厚的，目前还远远没有吃完。这是第一点。
 
第二件事情，最近公布了两分钟的，他们利用深度增强学习，教会虚拟空间的木偶走路、跳跃、跨越，甚至在漂浮的木条上保持平衡和跳跃。这些木偶并不知道什么叫走路，仅仅是给它目标，给他激励，他就自己学会了走路，自己学会了跨越障碍物，甚至可能在一些复杂情况下比人的表现要好得多。这充分展现了深度学习的潜力。
所以我们不需要看每天  上那么多的论文，就从这些新闻事件上来看，都可以得出结论，这一代技术的红利还远远没有被吃光。
另外，我们不能光看技术，还要看这个产业。

这个是来自麦肯锡的一个报告，年到年里面，这个领域获得的外部投资增加了倍，年的总规模达到了亿到亿美金之多。投资的效应是累积的，这些投资将会对  的发展产生很大的拉动。
一个重点的行业是自动驾驶。同样来自麦肯锡的报告，预测从年到年，自动驾驶和半自动驾驶车辆的数量将从万上升到万台。汽车这是一个几万亿美元的产业，单单只要考虑这一个产业的转型，对于  就足以产生巨大的牵引力。
所以我完全不担心这次  的泡沫会崩溃。
今天的  整体是什么水平呢？如果你反推，从现实需求出发来对  提要求，你会发现，它有很多事情确实做不到。但是如果你正推，从今天已经具备的能力出发，来看看我们能够解决什么问题，你会发现，在今天的的能力范围之内，已经可以解决很多问题，可以激发很多行业的变革。
所以如果你们认为有泡沫，我告诉你，泡沫只会来的更凶猛，这是第一个问题，是不是有泡沫？我的回答很明确，没有泡沫。
 人工智能人才薪资虚高吗？
第二个问题，人工智能的人才薪资是不是虚高。 最近发表了一篇文章，作者花了很大的功夫去做调研，写出来一篇强文，题目是《百万年薪的人的泡沫与人工智能的虚假繁荣》。文章写得很棒，我读了好几遍，也推荐所有人都去看。
这个文章的核心意思，是说现在很多  的人才在市场上拿到高薪，但是却没有为企业赚到钱。有些挂着高级学术头衔的人，跑到企业里先拿个高薪爽几年，然后可能拍拍屁股就回学术圈了。

我们怎么看待这个问题。
首先， 和数据科学人才的高薪是个全球现象，他们现在就是在享受薪资溢价，这个是事实。我接触的很多  界的人也是这么看。
我们看一下美国的情况。

在美国，、机器人，机器学习与数据科学人才薪资水平目前快速增长中。你如果是程序员，你的薪资平均水平是九万一千美金，不过图中代表众数的那根柱子靠左，说明更多的人是略低于这个水平的。这说明少数的超高薪的程序员把多数低工资的程序员给平均了。而算法工程师，尤其是数据科学家，他们整体收入水平很高，均值十三万美元，而且图中代表众数的那个柱字偏右，说明超过这个收入的人群在他们整个这个人群当中也是多数。在招聘网站上，把  方面人才的广告挂出去，天时间招不到人，显著高于其他职业。意味着什么？供不应求。这个是美国的情况。

英国是全球人工智能的另一个中心。从年开始，英国的人才需求迅速的直线的上升，就是需求量迅速的上扬。

然后看印度，他们对程序员和机器学习专家的收入做了一个对比。结果呢，机器学习专家的收入不仅始终高于开发者，而且差距还越拉越大。
我们再从另外一个侧面来看一下，我们知道这个开发者使用的主力语言主要是。

这是从年到年，这三个语言薪资水平之间的一个对比，排在上面的是遥遥领先的是，它在整个企业应用，电子商务开发的地位，很难被撼动，目前它的薪资是排名第一的。排名第二名的是世界上最好的语言，，这个语言跟一直是并驾齐驱，保持不是很大的一个差距，但是到年，年之后，出现了一个死亡交叉，语言在收入上开始超过，我相信开发者的薪资水平超过是是迟早的事情，在最近两三年之内就会发生。

中国会怎样呢？大家看这幅图，也来自麦肯锡，在世界地图上蓝色越深的地方，当前劳动力当中可以被机器和人工智能取代的比例越高。墨西哥、玻利维亚、秘鲁这些国家，它整个自动化程度很低，所以有大量的手工工作都是可以被机器所取代的，他们是深蓝色。然后呢，像美国、加拿大、澳洲这样的国家，他们的自动化程度很高，所以他能够被机器所取代的工作的比例并不是特别高，所以是浅色的。
你看我们中国呢，是比较深的，是到，就是在我们中国的话，和自动化取代人力是非常有潜力的。所以呢，我认为在未来的相当长的时间里面，中国的做的这帮人，都将参与到一场劳动力替代当中，而且是占据优势地位的一方，享受高薪是必然的。
但是刚才那篇文章里所说的薪资泡沫也很确凿，因为我们看到呢，很多的企业，现在花了很多的钱去雇了一些一流的博士硕士，但是  这个产业的规模还没有起来，这些高薪基本上是靠投资人撑着，这合理不合理？

我认为事情的本质是人才结构的问题。这张图是我和蒋总讨论了很久以后我们列出来，其实一个成熟的，在未来年以后真正赚到很多钱的人工智能企业，它的人才结构应该是这个样子的，应该是专家学者，机器学习的博士们，资深专家比较多；然后呢，应该有一大堆的机器学习工程师，的产品经理、架构师在这里。更重要的底下有大批的开发者，数据工程师，运维人员，行业人员，这是一个合理的结构。

但是实际情况，目前市场上独立的人工智能初创企业，普遍严重缺乏优秀的产品、工程和运维人才。有些公司非常得意的宣传说，你看我的团队里，一流名校博士占百分之多少，比 、、微软高多了。但其实这样的构成恰恰有问题，这种团队的工程化、产品化能力会成为瓶颈，从而制约他们赚钱的能力。很简单，用户只会为产品和服务买单，不会为论文、算法和你们的学位买单。正是这样的反差，让一部分人觉得这里头有泡沫。

那么怎么办呢？我主张不要着急，把这个事情交给市场。投资者不傻，他们很清楚，现在我们处在算法红利期，算法领域还不断的有突破，所以我们先把懂算法的人找来，花钱养着他，先把论文看懂，先突破，往前突破。
但是算法红利期还有个两三年可能就要结束了。这不是说算法不会有进步了，还是会有很大的进步，但是呢，从算法的突破，到工具化，这个转化路径现在变得很顺畅，两三年之后会更顺畅。如果你有一个算法突破，发表论文出来，很短的时间内，几个月，甚至几周内， 上会有实现出来，甚至你可能会看到百度、谷歌把新的算法放在自己的开放里面，这就意味着，企业竞争主要拼的就是工程能力和产品能力了。到那个时候，整个  产业里的薪资水平会有更合理的分布。
我说一下我的结论。所谓的人才泡沫问题，只是一个暂时性的现象，是发展的一个必然过程，不需要担心。
 数据科学向左，人工智能向右
我再说第三个问题，选择方向的问题。
我们现在叫广义 ，其实里面大致包含两个工作性质差别挺大的方向。一个是商业分析与优化，一个是智能产品与解决方案。
两者主要的不同是谁来做决策，人做决策还是算法做决策，这个决定了自动化程度的高低。

商业分析与优化技术的应用的周期当中，人仍然在里面扮演很重要的角色，数据分析是用来辅助人类决策的，自动化水平受到人的决策的制约，不会太高。
另外一个方向叫做智能产品和解决方案，自动驾驶、扫地机器人、自动广告投放系统，都是这类。整个产品的执行过程基本上是完整的，很少需要有人干预，决策主要由机器来完成，自动化程度接近 。
大家很快会面临方向上的选择，你是走左分支，还是走右分支，这件事情你们要好好的想一想。左边这一支走下去，你可能会成为数据分析师、数据科学家、。右边这一支走下去，你应该会成为  工程师、 产品经理，。
走左分支，你的关键是获得高质量的业务数据。在中国，这个事情难度很大。

这个是最近的一个全球数据开放度调查，美国排名第，中国排名第。如果你们想走左分支，尽可能加入到一些具有数据访问特权的机构，否则想在中国想低价拿到别人的数据是很难的。

那么怎样选择行业呢？麦肯锡给了六个原则，

第一，数字化高度成熟；
第二，业务规模巨大；
第三能够把用在自己的核心业务里边，而不是一些边缘业务；
第四，它能够同时的去接纳多项科技，不仅仅是，可能还有区块链，还有物联网，还有其他的科技，都能够去接纳；
第五，它更加注重增量，而不是存量；
第六，领导对的应用有强有力的支持。


选择方向的时候，用这六把尺子来量一量，就会有一个大致的判断。这是麦肯锡的一个行业分析，排在第一名的，叫做高科技和电信，就是它各个领域里面绿的比较多，如果你们在这个领域做比较容易。今天大部分在互联网领域里，你们可能在这个领域里面做比较容易，因为数据也比较全，各方面的支持也比较到位，人的意识到位。随后分别是汽车和生产线、金融、电力、娱乐传媒、零售等行业。我们现在很多人都在谈医疗的大数据，医疗的化，但是其实呢，这个行业的准备度是不足的，做这个方向，要克服很大的难度。
其他的行业不一一解释了，谢谢大家。

文章来源：科技大本营前言
近年来，云计算的概念席卷了整个  圈。抛开忽悠概念的因素，云计算的发展和应用极大地改变了  产业的研发、运营和管理。作为云计算最重要的核心技术之一，虚拟化技术的发展促成了这一巨大的变革，而容器技术作为最具有代表性的虚拟化技术革新，目前已经得到了业界的广泛关注，其中以  最具有代表性，最为火爆，鹅厂目前很多应用也或多或少使用到了 。本文目地主要是给大家简单安利一下目前最火的容器产品  及其所涉及的相关技术，并通过一个实际例子演示一下容器技术的典型应用场景。
简单扯扯容器
虚拟化技术的核心在于资源划分、隔离和管理。围绕着这个核心，在不同层次上发展出了多种虚拟化技术，如以虚拟机为代表的硬件级虚拟化 技术以及以容器为代表的操作系统级虚拟化   技术。容器并不是一个全新的技术体系，下图是从  摘录的容器实现全家福，可以看到此项技术可以追溯到  年，并且覆盖了多种操作系统。近年来，随着  的快速崛起，容器技术再次吸引了  业界的广泛关注。  

为什么要用再？这就需要聊聊容器的特点以及跟虚拟机的区别和联系。随着技术的发展， 基础设施的能力越来越大，原来需要多个硬件单元完成的任务现在仅用一个硬件单元的一部分就能够完成了，那么为了资源的合理分配，将资源集合划分为更细粒度的资源单元，就是虚拟化技术的意义。下图是虚拟机和容器技术的对比示意图。左图中，在宿主机操作系统 之上，通过  将资源划分为资源单元，每个单元有自己的操作系统 、工具和库，在其上运行各自的  互不干扰，每个资源单元就是一个虚拟机；右图中在宿主机操作系统之上，通过容器管理器 将一部分资源隔离出来形成资源单元，每个资源单元没有自己的操作系统，有自己的工具和库，在这之上运行自己的 ，这里每个资源单元就是一个容器。  

通过上图的分析可以看到，虚拟机和容器技术在隔离的层次上并不相同，虚拟机有从操作系统开始的完整的基础设施，而容器仅在工具、库这个层次及以上形成了自己的特有区域。这个特点决定了两者的属性，容器是比虚拟机更轻量的资源单元。轻量，意味着快速启停、迁移、分发等优良的性质，并且在资源总量一样的情况下，能够支持的容器单元数量将数倍于虚拟机。
下面扯点题外话，人类善于通过逻辑思维的手段从不同的事物中抽取出本质并加以推广。举个例子，运输业是一个很古老的行业，运输业的发展推动了人类的进步，当人类的运输需求变得越来越复杂，遇到了下面的问题，如何用标准的交通工具运输各种各样需求不同的物品？ 

为了解决这个问题，人们发明了集装箱，它将运输品所需满足的条件光照、冷藏、密封等限制在集装箱之内，对外而言它只是一个提供标准运输接口的单元，这样的单元可以通过各种使用标准运输接口的交通工具运输。
看到这里大家应该不难理解，通过类比， 攻城狮们再次发现虚拟化技术所蕴含的巨大潜力，虚拟化可以充当集装箱的角色，将  运行所需满足的条件依赖、工具、库等限制在资源单元之内，对外提供标准的接口，并且能够装载于各类服务器基础设施。并且在比较了各类虚拟化技术后，容器轻量的特点让它更适宜与成为集装箱。在重新审视了容器技术的巨大价值之后，各方势力纷纷开始占山头立门户，在这个过程中诸多新的容器技术相继发布，其中就以取名为码头工人的  最具代表性。  

， 来了！它是谁？能干嘛？
 是谁？ 是由  公司在  年开源的一款开源容器引擎，后来  火了干脆公司就改名为  了……  
 是一种基于  内核隔离技术的容器实现，用  语言编写，其功能特性归纳为：

资源隔离，包括文件系统、进程、网络等；
资源控制；
文件系统，具有写时复制、日志记录、版本管理等；
提供控制 ；
提供镜像分发、重用的生态系统。

 的实现依赖了以下技术：

，利用  内核提供的  机制，容器能够建立资源隔离单元，隔离内容包括进程、网络、进程交互、文件目录、 及用户和用户组等。
，利用  机制来处理不同容器之间竞争宿主机系统资源的问题，实现对资源的配额和度量。
，在  发展的过程中，早期使用  来共享内核，实现容器的快速启停以及减少内存的消耗，在后来的发展中， 主键用  替代并扩展了  的功能。
， 默认使用  构建容器的文件系统，提供写时复制  的特性，这是  镜像保存、修改及分发的基础。

基于  提供的基础功能和其开源的属性，业界巨头和初创公司纷纷以此为基础开发出各种框架和工具，在分布式特性、网络特性、存储特性以及管理特性等方面对  进行扩展和补充，鹅厂  内部使用的  管理平台以及  的  系统都是很好的例子。关于  技术原理的文章能够很容易搜索到，本文就不在这里展开了，下面将根据容器的特点介绍几个典型的应用场景，并给大家介绍如何从零开始写一个简单的基于  的负载均衡器。  
根据前述， 作为一种容器，能够快速启停、占用较少的系统资源，同时根据其自身实现技术特点，又具备写时复制、保存分发等特点。所以不难想到以下几种应用场景很适合使用  实现：

平台即服务，沙箱的完美替代品；
自动测试及持续集成，测试妹纸笑开了花；
构建标准化无状态运行环境及快速部署，你知道重装环境有多么烦么；
高可用和负载均衡系统，让故障和攻击陷入人民战争的汪洋大海，一会慢慢讲。

夸了那么多，难道  就没有缺点么？不是的，目前  正在快速发展过程中，在人们使用的过程中逐渐暴露了  的很多问题，其中不乏一些很严重的问题：

隔离性问题， 依赖  内核提供的隔离机制，相比虚拟机而言，级别和程度都有不少下降，这也是追求轻量带来的副作用
安全性问题，跟隔离性分不开，目前  存在诸如  权限提升，共享宿主信息等安全漏洞，这阻碍了其推广到企业级应用的脚步
性能问题，由于引入了 ，提供了很好的  特性，但是这也会对  性能造成一定影响，因此不建议用  负担有状态的任务
 提供用于镜像分发和重用的生态系统，全球开发者都能够通过这个平台进行交流，但随之而来的就是如何保证镜像的质量、可靠性和安全性，别人做的你敢用？

尽管存在诸多问题，但是这并不妨碍  前进的脚步。业界也在期盼  的快速成长。
别光看，动手做吧
感谢您能够看到这里，啰嗦结束之后，我们来动手做一个简单的基于  的负载均衡器实例。 
负载均衡，顾名思义就是对负载进行分流实现均衡的目的。在  网站以及   发展的过程中，负载和处理能力的矛盾使得负载均衡成为必须考虑的问题，如下图所示：  


当请求负载在单节点处理能力之下时，没有必要设置负载均衡器，所有的请求都由一台服务器搞定；
当请求达到一定数量，超过了单台服务器处理能力，那么现在就需要添加多台服务器，并且使用负载均衡器 进行流量分发，保证业务请求平均地分散到各  服务器；
业务的流量特点很多变，流量高峰何时到来谁也不知道，如果使用多台  服务器在后台值班，这样难免会造成资源的浪费，并且这样也有可能无法应对流量峰值，因此需要一个自动的负载均衡器，它能够实时检测当前到来的业务流量，并且能够控制后端资源池快速完成资源的申请、释放以及路由切换，这样就可以通过实时的流量检测数据完成  服务器的动态配置，在后端资源池能力足够的情况下，轻松应对多变的请求量。

为了实现  的目标，我们的系统需要以下几大功能模块，如下图所示：  


负载均衡器：负责分发流量请求，并且在节点数目变化时完成路由切换。在本实例中，我选取了开源的  作为负载均衡器的实现，它支持多种流量分发算法，本例采用了简单的轮询模式。
负载监控器：负责监控当前负载请求量，并且根据设定阈值决定下一步动作。本例中由  实现，配合  服务器实时上报的当前流量状况决定是否动态申请资源，实现 ，具体代码请移步微码：_
资源控制器：封装  的操作 ，根据监控器的指令完成添加或删除服务节点的具体操作，本例中由  实现，具体代码请移步微码：_
 服务器：发挥  的特点，将业务所需的  功能组件，负载获取上报模块等打包成为镜像并注册于镜像库中，根据控制器的指令启停。

 服务镜像的准备按照以下步骤进行： 


安装  及相关服务组件；
  拉取空白的实例；
安装所需的基础组件，部署业务代码；
将实例保存为镜像类比  中创建了一个类；
  可以将此镜像上传到公共、私有镜像库，完成分发或重用类比将  中创建的类发布，供其他人继承或是实例化对象并使用。

本例所使用的镜像已经上传至  官方镜像库，可以通过以下  命令下载使用：
  
运行效果
通过模拟  请求访问负载均衡器服务 ，控制访问量观察后端服务节点的数目和响应情况，最后将数据可视化输出如下图所示，可以看到，随着访问量的上升，监控器准确地反馈了流量的变化，并在短时间内通知后端资源池添加服务节点，从一个服最终增加到  个服务节点，在每一时刻都尽量保证每个服务节点都分布到平均的负载压力，并且在负载下降后及时减少服务节点以节省资源。需要解释一下的是，从图中可以看出每隔一一定时间访问量有突降的情况，这是由于需要在自动添加服务节点后重启负载均衡器  造成的，这里是一个简单的实现，如果换用能够动态加载配置的负载均衡器方案，就能做到流量的平滑过渡。

下图是总的访问量与平均访问量之间的对比，在总请求量暴涨的情况下，通过快速反馈调节后端  服务实例的数量，平均访问量快速收敛，实现负载均衡。作者： 程浩 
 本文为中国产品经理大会深圳站嘉宾分享整理总结未经许可，禁止转载。谢谢合作

导语
由人人都是产品经理与腾讯大讲堂联合主办的中国产品经理大会：解码未来产品经理在深圳宝立方国际博览中心如期举行。迅雷创始人、松禾远望基金创始合伙人程浩 老师结合自身经验，并从行业角度深度分析了人工智能创新时需要面对的六大核心问题，给智能时代下的产品经理带来了不同角度的思维方式。

分享嘉宾：迅雷创始人、松禾远望基金创始合伙人  程浩
大家好，我是迅雷创始人程浩，现在专注科技领域的投资。今天跟大家聊聊人工智能领域的创业和创新，包括如何选择赛道、团队的搭配、以及如何应对巨头的挑战。

为此我从投资人的视角，给大家总结了人工智能创业的大核心问题。
第一个问题互联网  人工智能

如果今天大家选择创业，我建议更应该关注人工智能，而非互联网。
为什么这么讲？
 互联网的流量红利已经消失
以来说，全球出货量连续年下滑；大家知道国内最后出现的一个互联网独角兽是谁吗？
是知乎，大概是年初推出，这么多年过去，再也没有互联网的独角兽出现。
做个类比，我们知道年移动互联网的渗透率和竞争程度和年的互联网类似；以此类推，年以后再做移动，也很难出独角兽了。
毕竟中国连续两年手机出货量都在亿多台，增长放缓，代表无线流量基本已走平，你多卖一台，我就少卖一台，是存量竞争。
今天创业者再做一个纯互联网的，投资人问的第一个问题就是你怎么获客。因为现阶段流量格局已定，首屏就那几个。
 互联网的机会同样有限
主要在于互联网最大的价值，是解决信息不对称和连接。所以对于电商特别有价值。
淘宝用皇冠、钻石等信用体系解决了信息不对称，同时又把全国有这么多买家和卖家连接在一起——这个是互联网的价值。
但很多行业信息和连接并不是痛点。
拿医疗举例，中国三甲医院的大夫就那么多，你把全国亿人民都和这些大夫连接上了也没用，因为一个医生一天还是只能看那么多病人。
互联网并没有提高医生看诊的效率；在诸如餐饮、医疗这些传统领域，互联网的帮助是很有限的。
也包括滴滴打车，互联网解决了打车难的问题，但是没解决打车价格的问题。事实上，补贴去掉之后，大家都发现了滴滴一点都不便宜，道理很简单——不管是专车还是出租车，还是需要由人来开，人工成本降不下来，就不可能便宜。
  真正能够提高社会生产力，解决供需关系不平衡的就是人工智能
人工智能将给社会生产力带来的提高，以及对人类带来的影响将远远超过互联网。
还是拿医疗来说，很多基层医院水平不高，那未来完全可以通过人工智能来辅助医生读、光等医疗影像。

像今年，对皮肤黑色素瘤的诊断，准确率已提高至，远远超过了人类专家的平均水平。

未来，人工智能无论是在无人车、机器人、医疗、金融、教育还是其他领域，都将爆发巨大的社会效益，这点毋庸置疑。我认为下一波大趋势和大的红利不是互联网，而是人工智能。我建议现在的创业者更应该关注人工智能领域的创业机会。
第二个问题人工智能  人工智能
人工智能主要分三层。最底层是基础架构，包括云计算、芯片以及这样的框架。
在基础层之上是中间层，叫通用技术，例如图像识别、语音识别、语义理解、机器翻译这些。

基础层和中间层，是互联网巨头的必争之地。
比如芯片领域，、英伟达、高通都投入巨资，竞争极其激烈。
云计算、框架也是一样，都不是小公司能够涉足的领地。
现在对于中间层的通用技术，也极其重视——因为大家都相信：人工智能是下一波工业革命浪潮。
对腾讯、阿里、百度这些巨头来讲，要想在大浪中屹立不倒，必须要构建出人工智能的生态系统——而核心就是要依靠这些 技术。
相比创业公司，的最大优势是什么呢？

不缺数据；
为了构建自己的生态系统，未来通用技术一定全部是免费的；
虽然通用技术免费，但有羊毛出在身上的猪机会。这是典型的互联网打法。

这里的猪是什么？猪就是云计算。
例如百度的策略，分别代表人工智能、大数据 和云计算 。我可以不赚钱，开放给大家，那么大家想享受我的服务，就来买我的云吧。
而对于创业企业来说，只做图像识别、语音识别、语义理解、机器翻译这些通用技术，指望通过卖钱，未来路会越来越窄，特别是都免费的压力下。
所以从这个角度讲，创业公司做下面两层风险比较大。我认为创业公司的机会在最上层，就是拿着下两层的成果去服务垂直行业，也就是我们所谓的人工智能。
第三个问题人工智能  人工智能
深入垂直行业的人工智能，又可细分为两类情况：即“人工智能行业”和“行业人工智能”，他们间有明显的区别。

“行业”简单讲就是在技术成熟之前，这个行业、产品从未存在过。比如自动驾驶，亚马逊的智能音箱、苹果的语音助手。在人工智能技术未突破前，不存在这样的产品。因为，创造出了一条全新的产业链。
“行业”就是行业本身一直存在，产业链条成熟，只是以前完全靠人工，效率比较低，现在加入元素后，使得行业效率有了明显提高。比如安防、医疗等领域。

客观讲，这两个类别都有创业机会。但“行业”，因为是一条新的产业链，创业公司与互联网巨头实际是处在同一起跑线上——而巨头们坐拥数据优势。
所以从这个角度，“行业”相对对创业公司更为友好，也更容易构建出壁垒。

我认为，未来行业壁垒才是人工智能创业最大的护城河。因为每个行业都有垂直纵深 尽管技术好一点、并不关键。
拿医疗举例，什么最重要？大量准确的被医生标注过的数据最重要；没有数据，再天才的科学家也无用武之地。
但在国内，这个医疗数据拿出来非常困难——所以做医疗一点优势都没有，因为他们要把这些数据，从各医院、各科室搞出来也很累。
相反，如果一个创业者在医疗行业耕耘很多年，也许拿起数据来比大公司更容易。
这要求创始团队的合伙人中，必须有懂行业、有行业资源的人才。
这与互联网一样，一旦细分到具体行业，并不是说你百度、腾讯有资金、有流量，投入人才就什么都能做，比拼的还有行业资源和人脉。
之所以跟大家聊这个话题，是因为前一段去百度大学跟大家交流，他们提到百度人工智能在无人车和的应用。同时又问我，人脸识别在国内安防领域的应用价值非常大。

像海康威视有近亿人民币的市值，每年光净利润就有近百亿。

百度在方面是不是该考虑进军这个领域，我回答说千万别，因为安防是典型的、有巨大壁垒的“行业”领域。 
即使百度技术好，在人脸识别率方面比海康威视高一个百分点实际不一定，海康背后有几百人的研发团队。但这并不代表百度就能替代海康。因为安防是“非关键性应用”，个犯人我识别了个，你比我多识别了一个做到了个，其实没那么重要。
而反过来，海康对比百度有什么优势？
首先海康是做摄像头的，用自己的硬件跑自己的算法，是很自然的事儿。就像苹果手机，软硬一体体验更好。
其次，海康做了这么多年的安防，积累了非常多的数据，人脸的数据、环境的数据……在安防领域有数据优势。
最后，海康给公安系统做了很多类似警务通、基站信息采集、视图档案管理等平台的东西，以及警用云系统——我们可以认为公安系统的化，其中有一部分就是海康威视参与的。
这些东西可能不赚钱，但却为海康构建了壁垒。因为底层的基础设施都是我建的，那前端的东西就只能用我的我可以有个理由，说竞品与我不兼容。
而且海康做了这么长时间，积累了大量的客户资源，特别是政府公安局的资源，开拓这些资源非常需要时间。
这些就是所谓的行业纵深。所以即使对而言，想进入“行业”领域，选择垂直赛道时，同样要非常谨慎。
在巨大的行业壁垒面前，真不是说我的算法比你好一些，市场就是我的，只有技术优势仍然差的很远。
回归 “行业”和“行业”，通常来讲前者的行业纵深会比较浅，而后者则有巨大的行业壁垒。而行业壁垒，则是创业公司最大的护城河，也是抵挡的关键。
第四个问题关键性应用  非关键性应用
谈到人工智能领域的创业，很多人都会有个误解，就是如果我团队没有个大牛的科学家，比如斯坦福、的博士坐镇，我都不好意思讲在人工智能方面创业。
其实这个认知是完全错的。
在人工智能领域，算法到底有多重要，完全取决于你要准备进入哪个行业。

根据行业和应用场景不同，我认人工智能的创业本质上有和之分。为了方便大家理解，我们简称为“关键性应用”和“非关键性应用”。
“关键性应用”要追求……后的多个，做不到就没法商业化。
比如：大家认为，可靠度的自动驾驶能上路吗？
肯定不能，意味着次就出次事故。也不行，次出一次事故。

千万记住：和的可靠度差距并不是，而是要反过来算，差距是倍——也包括手术机器人，听起来可靠度已经很高了，但意味着次出一次医疗事故；放在美国，医院还不得被巨额索赔搞得破产。
所以“关键性应用”领域，就是一丁点儿错都不能犯的人工智能领域，必须要有技术大牛、科学家或算法专家坐镇。
同时，这类项目研发周期都很长。

正如以色列做 高级驾驶辅助系统解决方案的公司，今年月被以亿美金收购。

大家知道这家公司研发周期有多长吗？成立于年，到他们推出首款产品、挣到第一桶金已是年。
长达年的研发周期，这在互联网创业里不可想象。

包括谷歌无人车从年开始研发，到现在一直没有商业化；达芬奇手术机器人从启动研发到年拿到美国食品药品管理局的认证，花了十年时间。

“关键性应用”的普遍特点就是这样：项目通常很贵，研发周期巨长，离钱非常远，需要持续的融资能力。
团队怎样才有持续融资？起码要有非常好的简历和非常好的背景。这个是能够持续融资的必要前提。
所以大家可以看到，今天做无人驾驶的创业团队都是高富帅——因为不是高富帅，你都熬不到产品真正商业化应用那天。
当然，如果在人工智能领域都是“关键性应用”，那就没大多数创业者什么事了。实际上，人工智能领域的创业，都是“非关键性应用”。
简单讲：对这些领域，的可靠度只要过了基础线，高一点低一点区别不大。
最简单的例子：现在很多公司的门禁开始用人脸识别。你今天带个帽子，明天戴个墨镜或口罩，识别率没法做到。
可即使没识别出来也没问题，因为所有带人脸识别的门禁都有地方让你按指纹；即使指纹也刷不进去，问题也不大，公司不还有前台吗？
这就是“非关键性应用“。
这类项目不追求后面的很多个，实际上，国内人工智能和机器人方向的创业，大部分领域都是“非关键性应用”。
当然并不是说，在这个领域算法不重要，你天天认不出来也不行，所以一定要过了基础的可用性门槛，偶尔出现问题可以容忍。“关键性应用”则不能容忍。
“非关键性应用“不追求高大上，简单、实用、性价比高更重要，这样的项目通常比拼综合实力。包括：


对行业的洞察理解。要熟知行业痛点；
产品和工程化能力。光在实验室里搞没意义；
成本控制。不光能做出来的产品，还得便宜的做出来；
供应链能力。不光能出货，还要能批量生产；
营销能力。产品出来了，你得把东西卖出去。团队里有没有营销高手，能不能搞定最好的渠道是关键。 

所以大家在创业组团队时，一定要想好你选择的赛道处于哪个领域，不同的赛道对于团队的要求是不一样。“关键性应用”必须有技术大牛坐镇，“非关键性应用”则要求团队更加综合和全面。
第五个问题技术提供商  全栈服务商
现在很多人工智能创业者都是技术背景出身，创业的第一个想法通常是做技术提供商。技术提供商作为创业的敲门砖可以。但如果只定位做技术提供商，未来路会非常窄。
纯粹的技术提供商，没有未来

为什么说未来只做技术提供商价值会越来越小？
原因有几点：
 通用技术一定是大公司的赛道，未来一定会开放免费。
人家大公司会免费提供人脸识别、语音识别、语义理解、机器翻译这类，你还打算怎么靠调用赚钱呢？
也许现在还可赚点小钱，但很难成为一个长久的生意。
 依托于算法的技术壁垒会越来越低。
未来随着基础计算平台和开源平台的丰富成熟，技术方面的壁垒会越来越不明显，整个人工智能的技术准入门槛会越降越低。
就像年你想找个开发者，很难；现在却很容易一样——所有技术的演进都遵循这一规律。
特别随着今天各大学的计算机专业，都纷纷开设机器学习课程，未来人才不缺，这会拉低整个行业的进入门槛。
同时随着谷歌等生态系统的成熟，很多领域都会有训练好的模型可以用来参考出会更快，创业者只要有足够的数据来训练参数就好了。
所以未来算法的壁垒会越来越低，如果这个公司的核心竞争力只是算法，那将非常危险。
 技术提供商如果不直接面向用户客户提供整体解决方案，则非常容易被上下游碾压：
对于技术提供商和算法类公司，如果你的技术壁垒不够高，上游很可能直接把你的事做了。
这样的例子比比皆是，比如给海康威视提供人脸识别算法的公司。
问题就在于：海康在用你算法的时候，人家也有庞大的研发团队在研究自己的算法；现在用你是人家还没准备好，一旦准备好立刻会把你替换掉。
即使在有一定技术门槛的行业，技术提供商的日子同样并不好过。

比如专注嵌入式的视觉处理芯片的，大疆无人机一直在用他们的芯片；但自从大疆统治了消费级无人机市场后，大疆现在也很自然地开始研发自己的芯片。

按说芯片的技术壁垒并不低，但只要行业集中度高，赢家就会选择通吃。
比如做手机的厂商，出货量到了一个阀值，都有动力自己做芯片。
像苹果、三星、华为还有现在的小米，都选择了自己做手机——所以联发科、高通这些技术提供商，其实是挺痛苦的。
这其实是一个产业链通用规律：产业链上的垄断者会吃掉所有利润，而且他们非常有动力往上游或下游扩展。
拿产业链举例，内存、硬盘、整机、显示器……都不赚钱。钱被谁赚走了？和却赚走了绝大部分利润。
“一横一纵”理论
既然做纯技术提供商没有出路，那怎么办？
前期做技术服务可以，但是不能一辈子做技术服务。

“一横”就是指你提供的技术服务。通常“一横”能服务很多行业，一定要找到、个，你认为最有市场机会，最适合你的垂直领域，深扎进去做“全栈”：把技术转化为产品，然后搞定用户卖出去，实现商业变现，再通过商业反馈更多的数据，更加夯实自己的技术。
一句话讲：要做技术、产品、商业和数据四位一体的“全栈”，这就是“一纵”。这才是健康的商业模式。

在垂直外的行业，因为没有利益冲突，你仍可老老实实的做技术服务。这样的话，商业上你能吃透一个垂直行业，技术上你还能通过横向合作，形成更多的数据回路，从而夯实你的技术。
这个就是“一横一纵”理论。
如何选择垂直领域？
那么对于技术创业公司，从“一横”走到“一纵”，要选哪个垂直领域，取决个关键因素：

 市场空间够不够大？
做垂直领域的全栈，还是做横向的技术提供商？取决市场空间哪个更大。找对垂直领域，即使只占一点点市场份额，也可能比做“一横”全归你的收益大。
拿美图公司举例，他们有美图秀秀、美拍、美颜相机等，同时还会跟很多手机厂商合作，提供相机拍摄的美颜效果，你可以理解这就是技术服务。
但研究财报后，大家知道美图秀秀选的“一纵”是什么吗？
就是美图手机。以上提到的技术服务都远没有垂直做美图手机赚钱。
美图手机占了公司全部营收的。虽然美图手机去年的销量大约在万台，仅仅只占国内手机市场全年销量亿多台的不足。
 行业集中度如何？
做“一横”技术提供商时，最担心的是你的上游或下游过于集中，或者说头部效应越明显，对技术提供商就越不利。
举个简单的例子：
时代，、等厂商卖服务器，都是直接卖给各公司，大家日子过的都很滋润。
但年之后就很难做了，因为云计算出现了。
提供云计算的厂商就那几个，两只手就能数出来。而且头部效应极其明显，仅阿里云一家占了以上份额。
如果你是一个技术提供商，在跟这么垄断的行业去谈判，你会发现没有任何筹码。
所以现在就很悲催，假设我是阿里云，会让你列出成本，我就给你或的利润，这个生意就很难做了。
在这种情况下，你当然有意愿也往上游走。
但带来的问题是什么？
如果上游集中度高，说明这事的壁垒很高，你作为技术提供商想往上走，同样很困难；如果这个上游集中度低或客户很零散，对你是件好事。
但是你也没有太大动力往上游走，因为这个市场本来就很零散，你即使杀进去，可能只有的市场份额，而且使得的人都变成你的竞争对手了。
这是个悖论。
 技术是改良还是革命？
如果你的技术创新对这个垂直领域是革命性的，就越有机会走到上游。如果只是改良性的，你就老老实实在下游赚个辛苦钱算了。
越是颠覆性的东西，越有机会往上游走——因为上游越离不开你，意味着你有机会做他的事。
打个异想天开的比方，如果你能提供一个“待机一礼拜”的电池，那你就可以考虑自己做手机，你的手机只打一点：一星期不用充电，而且是全球唯一！就这一点可能就够了，因为这个技术是革命性的。
相反，如果是改良性的技术，例如你的电池待机只是比以前多了，那你还是老老实实卖电池吧。
 双方壁垒谁更高？
技术提供商的壁垒和上游客户的壁垒哪个更高，也决定做“一纵”的成败。
拿比较火的直播平台而言，现在都有美颜功能，例如给女孩长出个耳朵那种，这个通常都是第三方提供的技术。
技术本身的壁垒并不高，很多公司都能提供——虽然效果有一些小的差异，但你没有明显优势。
可是直播的壁垒相当高，这事有网络效应，用户越多会吸引更多的美女主播，因为能赚到更多钱，美女主播越多，也会带来更多的用户；同时你舍得花钱，需要很多资金来买流量以及签约很的主播；所以这个事壁垒很高。
你做技术提供商壁垒不高。这种情况下，虽然技术提供商只能赚个辛苦钱，但是仍然完全没有机会往上游走。
 到底跟团队基因相符不相符？
能做得了技术服务，不代表能做垂直解决方案，做全栈，因为团队不一定有行业经验，这是很大的问题。
亚马逊的无人便利店 出来之后，国内不少技术团队也想提供类似的技术，甚至想做的便利店。
与他们聊完后，我都会劝他们再考虑一下，你的技术再好，对于用户而言，他买东西的时候，会看这个便利店有人还是无人的吗？
不会，这不是优先选项。
他首要考虑的还是——哪个便利店离我更近，以及我想买的东西这个便利店有没有。
从这个意义讲，这又回到了零售的本质。所以如果团队没有零售的基因，没有懂零售的人，就别考虑自己开便利店的事。
这时候，很多人可能会问“那我找个懂行业的高管不就行了么？”
这事没那么简单，如果不了解行业本质，其实是很难靠一个高管去弥补的。
我特别相信基因决定论，如果任何一个新的商业，找个懂行业的高管就能搞定了，那中国互联网的生意就全是的了，就没创业公司什么事了。
，一个做搜索，一个做电商，一个做社交。其实他们个都把对方的事情已尝试了一遍，最后都不成功。
所以大家能做什么，不能做什么，跟这个公司的基因是高度相关的。
第六个问题  
最后一个问题，简单说一下：科技成熟都需要一定的时间。因为从任何技术普及演进的角度，几乎都延续了先是从军工航天、到政府、到企业、到、再到这个规律。
不成熟的市场
人工智能也一样，目前人工智能在市场还不是很成熟。

简单说机器人，在个人消费者市场，出货量大的机器人只有类产品：扫地机器人、无人机、教育类机器人和亚马逊为代表的智能音箱。
为什么市场早期的普及有一定的困难，简单讲几个原因：
 产业链不成熟
我做一个创新的东西，成品有个部件。每一个部件都得自己做，而且因为出货量不大，每个部件都没有规模效应，这就导致每个部件都很贵，那你最后做出成品一定很贵。
这是非常大的问题。
 是额外花钱
这也是很重要的一个问题，端的用户因为自掏腰包、额外花钱，所以对价格通常比较敏感，产品很贵就是一个很大的门槛。
 产品的用户期待度高
用户买了这么贵的东西，自然对产品的期待度会更高很多。
大家觉得我买一个机器人回来，恨不得什么都能干：又能唱歌、又能跳舞、又能聊天、又能清洁、又能讲英语。
但这是不现实的，现在的技术成熟度离此还有些远。
机会更多
相对于端，这些问题在端却不是问题：

 端对价格承受能力更高
首先，企业对价格的承受能力显然比强很多。你说一个机器人万，消费者不可能买，但企业问题不大，企业对成本承受能力高。
 的核心目的是降成本
举例工业机器人，万块钱一个，听起来很贵；但一个工业机器人替代你个岗位，这个岗位一年也得万块钱，还不算四险一金。然后这机器人能工作年，这一下成本只有你原来的，甚至不到。那么企业一算账，觉得还是很便宜。
 可以采取人机混合模式
还有端的机器人应用更简单一些。一方面大多是单任务，机器人只要做好一件事就行了，实现起来简单。
另外，很多都是以”人机混合”模式在作业——也就是以前需要个人干活，现在我用机器人替代一半人。
简单重复的工作用机器人替代，复杂的用剩下的个人，这就是”人机混合”模式。
举个例子，现在国内外已有很多安保机器人，按固定路线去巡逻。你可以理解为移动的摄像头，当然算法上肯定加入了一些识别的东西。
固定绕路线巡逻，这个完全可以交给机器人来做；难的是：在巡逻的过程中，如果发现有老太太摔倒了，让机器人扶起来，这个目前还做不到。
但这不重要，你们后台不还有个人么？让他们过来就好了。
所以人机混合是比较主流的模式，这个大幅降低了机器人普及的难度。
最后再说一点：
目前大多数创业公司都是技术专家主导，这很容易理解——因为现在技术还有壁垒，技术专家主导起码保证产品能做出来。
不过未来随着技术门槛的降低，特别在“非关键应用”领域里，团队的核心主导，会慢慢过渡到产品经理和行业专家为主，因为他们离用户需求最近。
“非关键应用”领域，懂需求比技术实现更重要。长期来看，人工智能创业和任何其他领域的创业一样，一定是综合实力的比拼！
以上就是演讲的内容。什么是？
 是一个清晰而高效的深度学习框架，其作者是博士毕业于   的贾扬清，目前在  工作。 是纯粹的  架构，支持命令行、 和  接口，可以在  和  上直接无缝切换。
的特点
易上手
模型与相应优化都是以文本形式而非代码形式给出。 给出了模型的定义、最优化设置以及预训练的权重，方便立即上手。
速度快
能够运行最棒的模型与海量的数据。  与  结合使用，测试  模型，在  上处理每张图片只需要。
模块化
方便扩展到新的任务和设置上。可以使用  提供的各层类型来定义自己的模型。
开放性
公开的代码、可参考的模型和可再现性。
社区好
通过共同讨论和以  协议共同开发这个项目，学术研究、起步阶段的原型和工业应用可以共享各自的力量。
社区活跃度

以上统计来自  的 主页。
的安装
 需要预先安装比较多的依赖项，，，，，，，，，，，等等，下面仅介绍一下  下安装  的过程。
安装  
基本库安装

基本开发工具
     

添加 
   _

安装依赖的包
      \
   

安装


   ___ ___==_=

    ___
  ___
 
 
   
安装
           
  
  
  
  
  
   __= __= \
_= ___= \
__=
   
   
安装
   
编译
   
        
  
  
  
安装加速 
过程略显痛苦，如果有  再操这心吧。。。 官网写的很简单，但看网上的朋友都安装的很痛苦 ，这里也提供一份链接。
的基本概念和模型

 是  中处理和传递实际数据的数据封装包，并且在  与  之间具有同步处理能力。从数学意义上说， 是按  风格连续存储的  维数组。
 基于  存储和交换数据。为了便于优化， 提供统一的内存接口来存储某种类型的数据，例如批量图像数据、模型参数以及用来进行优化的导数。  可根据  主机到  设备的同步需要，屏蔽  混和运算在计算上的开销。主机和设备上的内存按需求分配，以提高内存的使用效率。
对于  中的数据，我们关心的是 值和 梯度，所以一个  单元存储了两块数据  和 。前者是在网络中传送的普通数据，后者是通过网络计算得到的梯度。而且，由于数据既可存储在  上，也可存储在  上，因而有两种数据访问方式 静态方式，不改变数值；动态方式，改变数值。

  _ 
 __
 和  的操作与之类似
之所以这么设计是因为  使用了一个  类来同步  和  上的数值，以隐藏同步的细节和最小化传送数据。一个经验准则是：如果不想改变数值，就一直使用常量调用，而且绝不要在自定义类中存储指针。每次操作  时，调用相应的函数来获取它的指针，因为  需要用这种方式来确定何时需要复制数据。实际上，使用  时， 中  代码先从磁盘中加载数据到，同时请求分配一个  设备核  以使用  进行计算，再将计算好的  数据送入下一层，这样既实现了高效运算，又忽略了底层细节。只要所有  均有  实现，这种情况下所有的中间数据和梯度都会保留在  上。 这里有一个示例，用以确定  何时会复制数据

 假设数据在上进行初始化，并且我们有一个
  
 
 = _  数据从复制到
 = _  没有数据复制，两者都有最新的内容
 = __  没有数据复制
  一些操作 
 = __  仍在，没有数据复制
 = _  由于  修改了数值数据从  复制到 
 = _  没有数据复制两者都有最新的内容
 = __  依旧没有数据复制
 = __  数据从复制到
 = __  数据从复制到

 是  模型的本质内容和执行计算的基本单元。 可以进行很多运算，如 卷积、池化、 内积， 和  等非线性运算，元素级的数据变换，归一化、 数据加载、 和  等损失计算。可在  官方文档的   中查看所有操作，其囊括了绝大部分目前最前沿的深度学习任务所需要的层类型。

一个  通过 底部连接层接收数据，通过 顶部连接层输出数据。每一个  都定义了  种重要的运算 初始化设置， 前向传播， 反向传播。

 在模型初始化时重置  及其相互之间的连接 
 从  层中接收数据，进行计算后将输出送入到  层中
 给定相对于  层输出的梯度，计算其相对于输入的梯度，并传递到  层。一个有参数的  需要计算相对于各个参数的梯度值并存储在内部。

特别地， 和  函数分别有  和  两种实现方式。如果没有实现  版本，那么  将转向作为备用选项的 方式。尽管这样会增加额外的数据传送成本输入数据由  上复制到 ，之后输出数据从  又复制回到 ，但是对于做一些快速实验这样操作还是很方便的。
总的来说， 承担了网络的两个核心操作：  前向传播 —— 接收输入并计算输出；  反向传播 —— 接收关于输出的梯度，计算相对于参数和输入的梯度并反向传播给在它前面的层。由此组成了每个  的前向和反向通道。
由于  网络的组合性和其代码的模块化，自定义  是很容易的。只要定义好  的  初始化设置、 前向通道和 反向通道，就可将  纳入到网络中。

通过合成和自动微分，网络同时定义了一个函数和其对应的梯度。通过合成各层的输出来计算这个函数，来执行给定的任务，并通过合成各层的后向传播过程来计算来自损失函数的梯度，从而学习任务。 模型是端到端的机器学习引擎。
准确的说， 是由一系列层组成的有向无环  计算图， 保留了计算图中所有的中间值以确保前向和反向迭代的准确性。一个典型的  开始于   ——从磁盘中加载数据，终止于   —— 计算如分类和重构这些任务的目标函数。
 由一系列层和它们之间的相互连接构成，用的是一种文本建模语言。一个简单的逻辑回归分类器的定义如下


 
 {
   
   
   
   
  _ {
     _
    _ 
  }
}
 {
   
   
   
   
  __ {
    _ 
  }
}
 {
   
   
   
   
   
}
进行模型的初始化。初始化主要实现两个操作：创建  和  以搭建整个网络  图，以及调用  的函数。初始化时也会做另一些记录，例如确认整个网络结构的正确与否等。另外，初始化期间， 会打印其初始化日志到 信息中。
 中网络的构建与设备无关，可回忆下我们之前的解释， 和  在模型定义时是隐藏了实现细节的。网络构建完之后，通过设置  函数中的 _ 即可实现在  或  上的运行。采用  或  计算得到的结果相同， 与  无缝切换并且独立于模型定义。对于研究和调用来说，将模型定义和实现分离开来是最好不过了。

模型是利用文本    语言定义的，学习好的模型会被序列化地存储在二进制    文件中。
模型格式用  语言定义在  文件中。大部分源文件中都带有解释。
 使用    有以下优势：按序排列时二进制字符串尺寸最小，高效序列化，易读的文本格式与二进制版本兼容，可用多种语言实现高效的接口，尤其是  和 。这些优势造就了  模型的灵活性与扩展性。


 过程为给定的待推断的输入计算输出。在 过程中， 组合每一层的计算以得到整个模型的计算“函数”。本过程自底向上进行。数据  通过一个内积层得到 ，然后通过  层得到 ，通过   得到 。

 过程根据损失来计算梯度从而进行学习。在 过程中， 通过自动求导并反向组合每一层的梯度来计算整个网络的梯度。这就是反传过程的本质。本过程自顶向下进行。

  和 的实现
只要定义好了模型，这些计算就可以立即进行： 已经准备好了  和  的实现方法。

和  方法实现网络的  和 ，而和计算每一层的  和 ；

每一层都有_{ } 和_{ }方法来适应不同的计算模式。由于条件限制或者为了使用便利，一个层可能仅实现了  或者  模式。


 
与大多数的机器学习模型一样，在  中，学习是由一个损失函数驱动的通常也被称为误差、代价或者目标函数。一个损失函数通过将参数集即当前的网络权值映射到一个可以标识这些参数 “不良程度” 的标量值来学习目标。因此，学习的目的是找到一个网络权重的集合，使得损失函数最小。
在  中，损失是通过网络的前向计算得到的。每一层由一系列的输入  ，然后产生一系列的输出  。这些层的某些输出可以用来作为损失函数。典型的一对多分类任务的损失函数是  函数，使用以下的网络定义，例如
 {
   
   
   
   
   
}
在  函数中，  是一个标量数值，该数值是整个  的损失平均值 由预测值  和真实值  计算得到。
 
对于含有多个损失层的网络 例如，一个网络使用一个  输入分类并使用  层进行重构，损失权值可以被用来指定它们之间的相对重要性。
按照惯例，有着  后缀的  层对损失函数有贡献，其他层被假定仅仅用于中间计算。然而，通过在层定义中添加一个_ 字段到由该层的  ，任何层都可以作为一个 。对于带后缀  的层来说，其对于该层的第一个  含有一个隐式的 _；其他层对应于所有   有一个隐式的 _。因此，上面的 层等价于
 {
   
   
   
   
   
  _ 
}
然而，任何可以  的层，可允许给予一个非  的 _，例如，如果需要，对网络的某些中间层所产生的激活进行正则化。对于具有相关非  损失的非单输出，损失函数可以通过对所有  求和来进行简单的计算。
那么，在  中最终的损失函数可以通过对整个网络中所有的权值损失进行求和计算获得，正如以下的伪代码
 = 
   
    _   _
     = _  

 通过协调  的前向推断计算和反向梯度计算     ，来对参数进行更新，从而达到减小 的目的。 模型的学习被分为两个部分：由  进行优化、更新参数，由  计算出  和 。
 支持的  包括有

    ，随机梯度下降
  
   ，自适应梯度
  
’     
  

各项  的具体说明可以参见这里。
 分类
为了创建一个  模型，我们需要在一个   文件中定义模型的结 构。 在  中，层和相应的参数都定义在 文件里。
视觉层  
头文件：_
视觉层的输入与输出均为图像。一个典型的图像通常为单通道的灰度图或三通道的  彩色图。但本文所指图像是一个广义的概念，明显特性来自于空间结构：高和宽通常均大于  而通道数不限，类似结构的数据均可理解为图像。这种结构可以帮助  的层决定如何处理输入数据，具体来说，大多数视觉层通常是在输入数据的某块区域执行特定操作来产生对应的输出。相反的，其它类型的层通常会忽略空间结构而把输入图像看作是一个维度为  的 “单个大向量”。
损失层  
 设置了一个损失函数用来比较网络的输出和目标值，通过最小化损失来驱动网络的训练。网络的损失通过前向操作计算，网络参数相对于损失函数的梯度则通过反向操作计算。
激活层    
一般来说，激活层执行逐个元素的操作，输入一个底层 ，输出一个尺寸相同的 顶层 。 在以下列出的这些层中，我们将忽略输入和输出  的尺寸，因为它们是相同的。
数据层 
数据能过数据层进入  网络：数据层处于网络的最底层，数据可以从高效率的数据库中读取 如  或 ，可以直接从内存中读取，若对读写效率要求不高也可以从硬盘上的  文件或者普通的图片文件读取。常见的数据预处理操作 减均值，尺度变换，随机裁剪或者镜像 可以通过设定参数  来实现。
普通层  
普通层主要负责做一些诸如：内积全连接、分裂、平摊 、变形 、连结 、切片 、计算均值等操作。
 提供的接口
 有命令行、 和  三种接口，来实现日常使用、研究代码的交互以及实现快速原型。 以  库为核心，其在开发中使用模块化接口，而不是每次都调用其定义的编译。， 与  接口都可供用户使用。
命令行
命令行接口  是  中用来训练模型，计算得分以及方法判断的工具。
训练模型
  命令可以从零开始学习模型，也可以从已保存的快照继续学习，或将已经训练好的模型应用在新的数据与任务上进行微调即 学习：

所有的训练都需要添加   参数完成  的配置
继续训练需要添加  __ 参数来加载  快照
 需要添加   参数完成模型初始化

例如，可以运行如下代码：
 训练 
   _
 在号上训练
   _  
 从中断点的  继续训练
   _  __
对于  的完整例子，可以参考 _，但是只调用训练命令如下：
 微调  模型的权值以完成风格识别任务 
  – ___ \
 ____
测试
  命令通过在   中运行模型得到分数，并且用这分数表示网络输出的最终结果。网络结构必须被适当定义，生成 或  作为其结果。测试过程中，终端会显示每个  的得分，最后输出全部  得分的平均值。
 对于网络结构文件 __ 所定义的网络
 用   得到已训练的  模型的分数
   __ \
 __    

  命令通过逐层计时与同步，执行模型检测。这是用来检测系统性能与测量模型相对执行时间。
 在  上  训练  的时间
   __   
 在  上默认的   训练  的时间
   __  
 在第一块  上  训练已给定权值的网络结构的时间
   __ \
 __    
诊断
 _ 命令对于多  机器上，在指定的  运行，输出  细节信息用来参考与检测设备序号。
 查询第一块 
 _  
并行模式
 工具的  标识，对于多  的模式下，允许使用逗号分开不同  的  号。  与  在每个  上都会实例化，因此   由于具有多个  而成倍增加，增加的倍数为使用的  块数。如果要重现单个  的训练，可以在网络定义中适当减小  。
 在序号为和的上训练  双倍的  
   _   
 在所有上训练  将 乘上数量
   _  
 接口
 接口  是  的一个模块，其脚本保存在 。通过   加载模型，实现  与 、、网络可视化以及求解模型等操作。所有的模型数据，导数与参数都可读取与写入。

 是加载、配置和运行模型的中心接口
 与  为一般任务实现了便捷的接口
 表示求解接口
 通过预处理与  ，处理输入输出
 实现数据结构可视化
  通过   实现易用性与有效性

  可编译 。通过  =  将模块目录添加到自己的  目录，或者相似的指令来实现  。
接口
 接口  是在  路径中的  软件包。在  的基础上，可将  整合进  代码中。
详情可参考官方接口文档。
数据相关
输入与输出
 中数据流以  进行传输。数据层将输入转换为  加载数据，将  转换为其他格式保存输出。均值消去、特征缩放等基本数据处理都在数据层进行配置。新的数据格式输入需要定义新的数据层，网络的其余部分遵循  中层目录的模块结构设定。
数据层的定义实例加载  数字数据
 {
     
     数据层加载  或  的数据库存储格式保证快速传输 
     
     第一个顶部是数据本身“”的命名只是方便使用 
     
     第二个顶部是数据标签“”的命名只是方便使用 
     
     数据层具体配置
    _ {
         数据库路径
         __
         数据库类型 或  支持并行读取 
         
         批量处理提高效率
        _ 
    }
     常用数据转换 
    _ {
         特征归一化系数将范围为 的  数据归一化为 
         
    }
}
顶部和底部 ：数据层从 的  向模型输出数据，但没有  的 ，因为数据层没有输入。
数据与标签   ：数据层至少要有一个  输出，规范化的命名为  第二个  输出，规范化地命名为 。这两个  只是简单地生成  它们的名称没有特殊含义。，映射关系对于分类模型更方便。
转换 ：在数据层的定义中，数据预处理通过转换参数来定义。
 {
   
   
  
  _ {
     
    __ 
     对  进行水平镜像处理或者随机裁剪处理
     可作为简单的数据增强处理
        =   = 
     裁剪块大小为 `_`  `_` 
      训练时随机处理
      测试时从中间开始
    _ 
  }
}
预获取 ：为了提高网络吞吐量，数据层在网络计算当前数据块的同时在后台获取并准备下一个数据块。
多个输入  ：网络可以有任意数量和类型的输入。可根据需要定义任意数量的数据层，只要保证它们有唯一的  和 。多输入对于非常见形式的   是十分有用的。例如一个数据层读取真实数据，另一个数据层读取  。在这种设计下， 和  可以是任意的  数组。多输入的更进一步的应用是多模型和序列模型。在这些情况下，您可能需要实现自己的数据准备程序或者构建一个特殊的数据层。
格式
参照数据层的章节，可以查看  中数据格式的具体细节。
部署输入
对于 “动态计算部署”    环境中，网络在输入域中定义其：这些网络直接接收数据来进行在线或交互式计算。
总结
 是一个高效实用的深度学习框架，拥有广泛的用户群体，代码灵活，模块化程度高，由于大量实用了  来描述和定义模型，并且支持在命令行工具下进行通常的模型训练和优化，所以也非常适合于编码能力不强的研究人员和学习者。但是，安装过程稍显繁琐，文档不太易读，好在社区和成熟，代码丰富，入手相对容易。
参考资料

贾扬清个人主页 
官方文档   
官方文档  
官方文档  