厂商安全领域分布：
厂商安全领域分布：
威胁情报定义 
对于威胁情报的定义暂时还没有一个定论，这里引用一下对于情报的定义情报是我们所处世界中的知识和预判。美国政策制定者决策和行动的先导。情报机构将这种信息以某种方式提供给消费者、国民领导或军队指挥官，以便让他们去思考可替换的选项和结果。在信息安全工业内，关于数字威胁的情报就是我们这里的讨论的威胁情报。对于业界内的定义，我们引用一段年《     》书中对威胁情报所下的定义：
“对敌方的情报，及其动机、企图和方法进行收集、分析和传播，帮助各个层面的安全和业务成员保护企业关键资产。”
威胁情报的本质是情报，是一把双刃剑，即可以帮助企业提高安全防护，也可以帮助黑客团伙获得攻击手段。情报在起什么作用在于谁在使用。
因为安全厂商众多无法面面俱到，这次仅谈谈威胁情报的相关厂家
厂商的类型
按照情报的来源看，所有能够发现恶意行为的厂商都可以作为情报来源。具体可以按照如下分类方式：

由传统杀软转型的情报厂商，比如，
由新型单机安全产生情报的厂商，比如，
厂商，比如，，
传统的基于数据进行风险分析的情报厂商，比
注重与数据关联分析的情报厂商，比如

厂商分析
、，和其他杀软厂商
杀软厂商是可以提供有效的威胁情报的，其道理就和当前在做的事情类似。单机部署的，深入系统底层的软件比如杀毒可以有效的读取主机上的任意内容，监听网络流量等等。缺点是对系统资源的消耗，对特征库的依赖。提供的情报主要包括外网的 信息，恶意文件的等等。
、和等新一代终端安全厂商
这俩家厂商在情报方面的做法比较类似，情报来自于自己所收集的用户的行为分析。他们的都是基于用户行为的检测，往往采取截取系统调用的方式来实现，而不是依赖传统的特征库。提供的情报主要包括外网的 信息，恶意文件的等等。解决方案类似传统杀软，但是厂商声称有更高的准确性。
、
情报概念定义之前，就专注于信用开交易的风险分析，常见的做法是和用户合作，通过快速调用的方式，在每个交易进行时就即时生成对应的风险分数，帮助用户决断交易的可信度。具体实现可以参考国内的邦盛。数据的来源主要是向其客户索取交易时刻用户通过向其提供和其系统内部的关联分析。大客户如，等。
、， 等新型反欺诈厂商
新型反欺诈厂商意在解决自动注册，撞库等问题，常见的做法是，通过页面植入和植入的方式在站点或者移动里埋点，然后生成每次登陆流程的可信度分数，供服务端来决定是否阻断当前操作，加入注册码，或者进行限速。生成的威胁情报包括及其可信度，设备水印等。
、 
 前高管创立的安全情报厂商。侧重于情报的质量，它的主要情报来源是其合作的第三方，主要的特点是提供情报的关联分析和可视化。用户可以关联来自不同信息源的数据，进行综合分析。特别适用于企业用户发现可疑行为后的调查流程。
、传统的／
传统的／厂商提供威胁情报是个很自然的行为，大型的管理的客户规模巨大，可以产生海量的数据，处理后可以作为情报输出。这部分的信息取决于所管理的设备和软件，可能和其他设备或者软件厂商的情报数据有重合。，，，都归入这个范畴。
、 
这个厂商的主营业务是在公网和暗网寻找数据泄漏痕迹，和用户相关的任何有价值信息。
当前的局限
● 价格    威胁情报普遍是以解决方案或者订阅的方式获取的，对中小型企业来说，企业的预算往往不足以涵盖情报的订阅。    威胁情报的价格的比例不能够过高。● 情报的作用点    情报和解决方案设备和服务的关系相当于子弹和枪。必须要有适当的设备，人力，情报才能发挥作用。常见的使用方式比如    ■ 基于情报的实时阻断    ■ 协助决断安全事件的严重性    ■ 后期的调查取证    ■ 与第三方的合作和情报交换    企业往往需要在安全解决方案完备之后才会考虑付费的情报。● 情报的价值    目前的情报源错综复杂，同一客户有往往不会订阅许多的情报源。很难交叉证明特定情报的可靠性    情报虽然可以定期更新，但其本质还是在一个时间内相对静态的列表，对更复杂更有针对性的攻击往往效果不佳    对企业来说证明有效性的难度相对较大，对未来预算来说是个难点
未来的发展

威胁数据的持有量和交叉验证
  从根本上来说，任何安全设备或者软件都可以产生大量的威胁数据，目前缺乏一个平台来统一化整合和处理来自个大厂商，各种设备的数据。  来自不同来源的数据可以提供交叉验证，从而证明数据的有效性，目前用户通常不见得会订阅多来源的情报，情报的可信性无法深度分析

威胁情报和云平台的深度整合  目前的威胁情报的价格偏高导致中小用户无法负担有效的情报。  云平台作为大型客户，本身可以承受威胁情报的价格。其本身可以通过规模化效应提供更有效的防护  云平台可以利用其用户量，分担威胁情报的成本，让其上的中小客户能够负担和使用。  同样的规律适用于，和基于的安全产品。

新的威胁数据源基于数据分析的反自动化工具可以提供非常有价值的威胁信息。传统的反自动化攻击数据倾向于采用更新静态列表的方式，新的反自动化解决方案采用动态植入和算法分析的方式进行来源分析，有更高的准确率和可靠性。作者 | 程丽萍编辑 | 顾乡

开心消消乐是乐元素开发的一款策略型的三消游戏，超亿玩家，在同类型游戏中处于领先位置。
客户挑战
 原服务提供商服务不稳定，在遇到大流量的时候，频繁出现故障，无法正常开展业务。部分地区时延严重，影响业务推广。服务响应时间慢。
为什么选择腾讯？
   、腾讯依托自建 边缘节点优势，在访问时延，系统稳定、安全防护等方面处于行业领先地位。 
   、腾讯依托自身丰富的经验，对游戏类业务支撑有独特的解决方案。如压缩、中间源减压、预拉热等，针对客户业务场景定制优化策略。
、腾讯专业技术团队打造全方位、快速解决客户问题能力提供小时支撑服务。制定业务保障机制，针对客户特殊事件实现快速响应保障。
为客户带来收益
 、依托于腾讯自身能力，加速效果比切换前提高以上，杜绝盲区。客户业务体验效果有明显提升。
 、为客户制定压缩优化方案，如使客户文件有压缩到，压缩比达，对对客户的流量成本和传输时延都有优化提升。下图为月日时切换后，时延明显下降。
 

相关推荐
快手  为什么选择腾讯云易企秀为什么选择腾讯云 为什么选择腾讯云概述
虚拟机在执行程序的过程中会把它所管理的内存划分为若干个不同数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。

程序计数器
程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。
如果线程正在执行的是一个方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是方法，这个计数器值则为空。此内存区域是唯一个在虚拟机规范中没有规定任何情况的区域。
虚拟机栈
与程序计数器一样，虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧 用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
局部变量表存放了编译期可知的各种基本数据类型、、、、、、、、对象引用 和字节码指令地址类型。
在虚拟机规范中，对于此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出异常。
对于位的，默认大小为 而位的 默认大小为可以通过设置虚拟机栈的最大值。不过如果设置过大，会影响到可创建的线程数量。
方法区
方法区与堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
根据虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出异常。
本地方法栈
本地方法栈  与虚拟机栈所发挥的作用非常类似，区别在于虚拟机栈为虚拟机执行方法服务，而本地方法栈则是为虚拟机使用到的方法服务。
堆
堆 是虚拟机所管理的内存中最大的一块，它是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
堆是垃圾收集管理的主要区域，因此很多时候也被称为  堆。
根据虚拟机规范的规定，堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的。通过和控制如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出异常。
文章出处：互联网综合症
最近三年，传统企业，都纷纷患上了互联网综合症，他们认为互联网是一股神秘的力量，随时可能消灭他们，甚至都不知道如何去抵挡。此时的心情，可以引用《三体》小说中的一句名言：消灭你，与你无关来形容，这句话折射除了三体文明派遣水滴探测器，摧毁人类所有的恒星级的飞船时，人类面临的同样的困惑与无助。

  流量革命
所以传统企业纷纷的向互联网化转型，期间最典型的就是  的模式。 这是传统世界和互联网世界的第一次联姻。但是很不幸，绝大多数都失败了。这个时代的联姻，双方共同的纽带是：流量，但是传统和互联网的业务流程，并没有去深度融合。导致失败是必然的。

新零售  数据革命
最近兴起的新零售，开始了传统和互联网联姻的第二次革命，这场革命的核心，是以数据为驱动，数据成了连接两者的纽带。但是两者并没有相融共生，长出新的东西，仍然只是在浅层面的一次融合。如果我们回到本质上看，对于线下的实体商业，他们关注的核心诉求点是什么？

所以，基于以上这些痛点，一个比较理想一点的数字化门店，应该具备下面这些功能：

技术，已经开始去提升零售也的管理效率，让他们和客户建立更好的连接，但是还是没有渗透到核心业务流程中。因此这一阶段的变革，是对传统商业的优化，而非变革。
互联网的第三次革命  技术革命
现在很多人都在谈论互联网的下半场，有一些在上半场落后的玩家，都希望在下班场一把翻盘。那什么是下半场呢？我们回过头来看互联网最近  年的发展历程，其实它和我们普通人所认知的大部分传统的行业其实在平行发展。互联网的高速发展，仅仅是在一个特定的领域在起作用，虽然不可否认，互联网已经渗透到我们的生活的方方面面。在产业链条的某些环节开始出现交融，譬如商品的传播和销售环节，但是他们依然是彼此平行的两条线。所以现在才会有互联网公司和传统公司的区别。那未来产业如何变化呢？
腾讯的创始人马化腾讲过一句话：未来的互联网是传统产业在云端通过人工智能去处理大数据，其实这一句话，就概括了未来互联网的发展的方向：两条平行线开始出现交融，合并成一条新的线条延生。
谈电气化工厂的消亡
如果我们仔细关注历史，我们或许能从历史上看到相同的答案。 年代出生的人，可能听说过曾经有一类工厂叫电气化工厂，因为这些工厂得益于先进的思维，率先使用电这样的新技术，所以极大的提升了其生产效率，所以当时的人们觉得他们非常酷，给他们冠以电气化工厂这样的称呼，以区别于传统的工厂。就像现在这个时代， 这类公司叫互联网公司，其他的叫传统产业。回到这个时代，大家再看看，从来没有哪家公司再称为电气化工厂，因为所有的工厂都用上了电，这个称呼自然就消失了。所以未来几年，互联网公司消失是必然的趋势。

商业竞争的本质  降低成本，提升效率
为什么出现这个变化呢？我们还是回到商业竞争本质来看待这个问题。其实商业竞争的本质，这几百年都是没有变化过的。其答案我们在高中的马克思政治经济学的课本上就学过。如果你需要在竞争中胜出，你需要比行业平均生产率更高的效率，这样才能获得超额利润，什么是超额利润：某一厂商由于采用新技术而获得高于正常行业水平的利润。行业的其他竞争对手当然不会坐以待毙，他们也会采用新技术，当行业所有的玩家都采用了新的技术时，整个行业的生产效率又会在一个新的层次达到平衡。社会就是这样不停的通过技术去推动变革的，从第一次工业革命到第二次工业革命，再到信息革命，都是如此。

所以现在的互联网，我们其实应该称之为互联网技术，它包含了云计算，大数据，人工智能这些新的技术要素。它最本质的作用，提升效率，降低成本。从  年开始，这两个平行线开始交汇，产业开始加速。从一个行业，开始扩散到所有的行业。
当以云计算，大数据，人工智能为代表的互联网技术，向传统行业去扩散时。带来的往往不是从我们通常看到到的层面去降低成本，提升效率，而是从新的维度去做，从模式的创新层面去变革。
我们先从血缘关系最近的传统  领域来看，曾几何，，， 这样的  巨头，叱咤风云。他们的技术朝着既定方向，一路向前，性能更强，存储空间更大，功能更强，似乎这个行业没有人能对他们构成威胁。但是想不到的是，一个卖书的小弟，拿着云计算这种商业模式突然闯入，短短的几年间，直接就颠覆掉了这些巨头。当云计算这样的新兴技术进入到传统  领域时，它不是从我们传统理解的观念去变革，而是直接从模式创新的角度去颠覆。这就是所谓的降维攻击。
如果说传统  产业和互联网技术是近亲，不具有代表性，那么再举一个制造业的例子。三一重工是一个非常典型的制造类企业。在以往，工程机械都是直接售卖给客户。随着云计算和物联网技术的兴起，三一重工开始探索一种新的模式，也就是租用工程机械。但是设备租用，需要对设备有非常完善的监控，随时采集任何一个设备的运行状态。所以三一重工新创办了一家叫树根互联的企业，结合腾讯云提供的底层的计算以及大数据能力，成功的由传统的工程机械的制造商转型成一家设备的运营商。

所以，互联网第三次革命的核心，互联网技术，已经开始往所有行业去扩散，不仅极大的降低了成本，提升了效率，而且开始和传统行业现有的模式产生化学反应，衍生出新的商业模式。
传统企业云化互联网转型
既然这场革命已经来到，那么传统企业如何向云化，互联网化转型呢？企业上云，是传统企业互联网化的一剂药引。但是真想治愈互联网焦虑症，还需要一个完整的药方。从自己的增量市场出发，建立和云业务相匹配的组织架构，首先让企业云化，自然后结出大数据的果实。最终通过云计算和大数据，让企业成功的实现互联网化转型。
创造增量市场，而非改造现有流程

罗辑思维有一期节目叫发现你的太平洋。这期节目，表达了一个非常重要的观点是：别跟存量较劲，寻找增量，边缘创新，发现新大陆。，很多传统企业，当他们想通过上云来试图拥抱新的业务模式时，会发现面临非常大的困难。这些困难，主要集中在四个方面：

原有的  架构，很难向云端迁移
找不到合适的人，去做这样的迁移
原有的  管理和维护人员，无法理解云端的业务模式
原有的数据格式，无法适配云的模式

曾经和一个银行业的朋友谈到金融业务上云的问题。当时他给出的结论是不要指望传统的大银行能够将业务搬迁到云上面。因为银行的这些系统，都是好多年累积建设起来的。所有的业务软件，数据，都是以传统的方式去设计的。没有人能够迁移的了。但是，由于互联网金融的冲击，很多银行开始试水一些新兴的互联网业务。云其实是可以驱动业务创新的。譬如，有些银行会定期做理财产品的限量抢购，做会员的运营，做小额支付，做远程开户。这些业务，都是银行业务最佳云上实践。
除了用于新的业务模式以外，云还可以用于流程的创新，以提升效率，降低成本。去年回老家，和农村信用社的朋友聊到征信的问题。在农村在贷款，其实非常困难，因为很多农民没有任何的征信记录。通常都要配备很多信贷员，去农民家里现场勘测。如果一笔贷款用途是购买生猪，甚至每个月都要去现场数，有多少头猪。其实，现在已经有一些机构，基于云上面做了一点点非常简单的创新。利用云上的音视频能力，开发一个 ，让贷款人实时直播一下现场场景，就可以不用信贷员亲自走乡串户了。节省了宝贵的人力资源。这种方式，虽然没有所谓的大数据征信那么高大上，但是确确实实是用技术手段提升了效率，降低了成本。
万科的郁亮在演讲中，提到了万科开发了一个 住这儿将业主和物业连接在了一起，这其实也是一种业务模式的创新。万科上云，并不是将其复杂的  的系统改造后搬上云端，而是利用云来创新新的业务模式。
顶级云计算战略家   在云 未来峰会里面降到，云的未来，不是一个成本中心，而是一个利润中心，它能创新很多新的业务模式，成为企业新的利润增长点。泰康人寿，之前是一个非常传统的保险公司。由于移动互联网的兴起，他们也尝试一些新的业务模式，探索向互联网去转型。 年春节的时候，他们率先尝试了微信红包的模式，吸引了超过  万的用户，通过对这  的用户运营，创造了平时  倍的业务量。其实，这背后是依靠了腾讯云超过  台云主机， 的  高速缓存的支撑。如果是传统的  基础设施下，是无法尝试这样的业务模式的。所以，既然传统的架构无法变革，我们更多的是通过云，去寻找自己的太平洋。
建立和云业务相匹配的组织架构

在互联网焦虑症的影响下，很多传统的企业，纷纷制定了互联网化转型的战略。于是乎，一夜之间，很多企业，都有了自己的网上商城，有了自己的公众号，有了自己的网站，开始去做红包营销，开始去做产品秒杀，开始去使用云计算。这的确是具有互联网形态的新兴业务。但是，实际运作这些业务的，可能还是公司的老的  部门，通过老的一些组织，一些老的人员，加上一些项目外包，开始尝试这些业务。传统企业互联网化，其实是分四个层次的：
第一层：传播互联网化公众号，微博，微信，网站第二层：营销互联网化网上商城第三层：业务流程互联网化互联网融入到生产流程第四层：组织架构互联网收购控制新的创业公司
从传统企业互联网化转型的路径来看，组织架构互联网化是最后最后一块拼图，也是最难的一块。 系统云化，其实是业务流程互联网化的底层基础。 部门 项目外包的模式，显然无法适应这种转型。技术领域有一个著名的康威定律，大概意思是：有什么样的业务架构，就有什么样的团队组织架构，康威定律提出  多年了，一直在  领域发挥的作用。云化转型非常成功的企业，一般都是有一套和自己的业务模式相匹配的组织架构。一个银行界的  管理人员说过，银行系统为什么无法向云端迁移，最难的并不在于系统架构，不在于数据格式，而在于，如果发生迁移，整个银行的组织架构都会随之调整。技术的问题都是可以解决的，但是人的问题，利益格局的问题，是更难解决的。
那什么样的一种组织架构，才是与云业务匹配的架构呢？传统的公司，最好不要让自己的  部门尝试去转变，因为思维模式是很难转变的。最好的方式，是去投资或者控股一个新的创业团队，让其独立去自由的发展。传统的公司可以导入资源，但是业务架构，组织架构以新创公司的模式去发展。小团队，敏捷开发，基于云去构建  的体系，逐步将原有公司的数据导入过去，以一个点去带动公司业务逐步朝云化去转型。
大数据是果实，云化是种子，应该先播种

最近，大数据非常的火，很多人都认为，是传统企业转型的战略支撑点。都希望通过大数据去实现自己企业向互联网化的转型。甚至很多企业，认为，云就是等于大数据。于是乎，主动的去收集各种的数据，然后希望从数据中寻找珠玑。但是，我想说的是，大数据，其实只是云化的果实，并不是种子。所有试图把大数据作为一粒种子播种下去，希望收获果实的，都是搞错了逻辑。当企业真正尝试更多的互联网的模式，开始去接触海量的用户，并且内部实现了云化的转型，才会产生并记录更多的数据，才有能力收集和处理数据。这个时候，大数据才真正开始发挥出作用。才开始去正向的促进业务去增长，创造更多的利润。并且大数据并不等于很多数据，而是很多维度的数据，只有当多个维度数据在一起了，才能起化学反应，产生真正的价值。
譬如，白酒行业是一个非常传统的行业。有的酒厂，尝试互联网化转型，在天猫，京东去开旗舰店，去卖酒，但是这只是很初级的营销互联网化，并不是真正的互联网化，也没有实现企业的云化。只能分享流量，但是无法沉淀和累积数据。茅台尝试自建网上商城。可以累积一些消费数据，但是流量又是瓶颈。洋河，做了一件事情，利用微信二维码实现了一瓶一码，每一瓶酒，都有唯一的二维码，微信扫码后，可以鉴别真伪，可以领取红包，还可以和更多的互联网场景连接起来。实现了商品和人的连接。这是一种生产流程互联网化，云化的必然结果。需要在生产流程，销售流程通过云计算去联通。但是正是由于这个结果，可以累积大量的数据，知道哪个用户，在什么时间，打开喝了这瓶酒。这是以往所收集不到的数据，但是，可以产生巨大的价值。洋河的模式，并不是一开始有意去通过收集数据去驱动营销，大数据只是在云化模式下自然结出的果实。
所以，传统企业互联网化转型，请首先忘记大数据，大数据，仅仅是成熟后结出的果实，首先需要的是播种。
【本文是腾讯云  特训营产品及商业模式主题的摘要，腾讯云  特训营是腾讯云推出的主要针对企业  的专项课程，主要培养云时代的具备技术思维，产品思维，商业思维的三维技术管理人才，目前已经在深圳，上海，苏州，合肥，西安，长沙，武汉，贵阳，成都等地开班】上篇： 技术细节笔记上
四、的故障恢复
我们知道，的相关信息保存在中，在启动的时候，会在中创建对应的临时节点。通过和建立会话，会周期性地向发送消息包，以此说明自己还处于存活状态。而收到包后，则会更新对应的超时时间。
当超过超时时间还未收到的包，则会认为该出现故障，会将该对应的临时节点删除，并通知，收到挂掉的信息后就会启动数据恢复的流程。
启动数据恢复流程后，其实主要的流程如下：
宕机》检测到异常》启动数据恢复》切分》重新分配》重放》恢复完成并提供服务
故障恢复有中模式，下面就一一来介绍。
、
在最开始的恢复流程中，的整个切分过程都由于来执行，如下图所示：

、将待切分的日志文件夹进行重命名，防止未真的宕机而持续写入、启动读取线程读取的数据，并将不同的日志写入到不通的内存中、针对每个，会启动对应的写线程将不同的数据写入到中，对应的路径为_。、重新将宕机的中的分配到正常的中，对应的读取的数据，会发现该目录下的目录以及相关的日志，然后重放对应的日志，从而实现对应数据的恢复。从上面的步骤中，我们可以看出的切分一直都是在干活，效率比较低。设想，如果集群中有多台在同一时间宕机，会是什么情况？串行修复，肯定异常慢，因为只有一个人在干切分的活。因此，为了提高效率，开发了  架构。
、  
顾名思义，  是的分布式实现，分布式就不是一个人在干活了，而是充分使用各个上的资源，利用多个来并行切分，提高切分的效率。如下图所示：

上图的操作顺序如下：
、将要切分的日志发布到节点上，每个日志一个任务，任务的初始状态为_、在发布任务后，会采用竞争方式认领对应的任务先查看任务的状态，如果是_，就将该任务状态修改为_、取得任务后会让对应的线程处理的切分，切分的时候读取出的对，然后写入不通的 的内存中。、启动对应写线程，将 的数据写入到中，路径为，是一个日志中该对应的最大，如果日志切分成功，而会将对应的节点的任务修改为_，如果切分失败，则会将任务修改为_。、如果任务是_状态，则会重新发布该任务，继续由竞争任务，并做切分处理。、重新将宕机的中的分配到正常的中，对应的读取的数据，将该目录下的一系列的进行从小到大进行重放，从而实现对应数据的恢复。
从上面的步骤中，我们可以看出  采用分布式的方式，使用多台做的切分工作，确实能提高效率。正常故障恢复可以降低到分钟级别。但是这种方式有个弊端是会产生很多小文件切分的数  宕机的上的数。比如一个有个，有个，那么产生的小文件数量为=个。如果集群中有多台宕机的情况，小文件更是会成倍增加，恢复的过程还是会比较慢。由次诞生了  模式。
、  
  和  的不同是先将宕机上的分配给正常的，并将该标记为。再使用  类似的方式进行切分，不同的是，将切分到对应 后，并不写，而是直接进行重放。这样可以减少将大量的文件写入中，大大减少了的消耗。如下图所示：

五、的拆分
、 的三种拆分策略
 的拆分策略有比较多，比如除了种默认过的策略，还有、、等策略，这里只介绍种默认的策略。分别是策略、策略和策略。
、
策略是版本之前的默认拆分策略，这个策略的拆分规则是：当大小达到默认后拆分。这种拆分策略对于小表不太友好，按照默认的设置，如果个表的小于就一直不会拆分。注意是压缩后的大小，如果使用了压缩的话。
如果个表一直不拆分，访问量小也不会有问题，但是如果这个表访问量比较大的话，就比较容易出现性能问题。这个时候只能手工进行拆分。还是很不方便。
、
策略是的版本默认的拆分策略，这个策略相较于策略做了一些优化，该策略的算法为：， ，最大为 。
从这个算是我们可以得出为、为的情况下，可以计算出的分裂情况如下：第一次拆分大小为：，=第二次拆分大小为：，=第三次拆分大小为：，=第四次拆分大小为：，=第五次拆分大小为：，=第五次拆分大小为：，=
从上面的计算我们可以看到这种策略能够自适应大表和小表，但是这种策略会导致小表产生比较多的小，对于小表还是不是很完美。
、
是在 版本后的默认策略，，拆分规则为： =       。
还是以为、为场景为列，计算出的分裂情况如下：第一次拆分大小为：=第二次拆分大小为：
从上面的计算我们可以看出，这种策略兼顾了策略和策略，对于小表也肯呢个比较好的适配。
、 拆分的详细流程
的详细拆分流程图如下：

备注图片来源  
从上图我们可以看出切分的详细流程如下：
第步会的下创建一个，并设置状态为
第步通过节点检测到状态的变化，并修改内存中状态的变化
第步在父的目录下创建一个名称为的子目录
第步关闭父，强制将数据刷新到磁盘，并这个标记为的状态。此时，落到这个的请求都会返回这个错误
第步在创建和，并在文件夹中创建对应的文件，指向父的文件
第步在中创建和的目录，并将文件移动到对应的目录中
第步在表中设置父为状态，不再提供服务，并将父的和的添加到表中，已表名父被拆分成了和两个
第步并行开启两个子，并正式提供对外写服务
第步将和添加到表中，这样就可以从找到子，并可以对子进行访问了
第步修改的的状态为
备注：为了减少对业务的影响，的拆分并不涉及到数据迁移的操作，而只是创建了对父的指向。只有在做大合并的时候，才会将数据进行迁移。
那么通过文件如何才能查找到对应的数据呢？如下图所示：


根据文件名来判断是否是文件

由于文件的命名规则为前半部分为父对应的的文件名，后半部分是父的名称，因此读取的时候也根据前半部分和后半部分来识别

根据文件的内容来确定扫描的范围，的内容包含两部分，一部分是切分点，另一部分是类型的变量或者。如果为则扫描文件的上半部分，则扫描文件的下半部分

接下来确定了扫描的文件，以及文件的扫描范围，那就按照正常的文件检索了


六、的合并
的合并分为小合并和大合并，下面就分别来做介绍：
、小合并
由前面的刷盘部分的介绍，我们知道当达到大小的时候会将数据刷到磁盘，生产，因此势必产生很多的小问题，对于的读取，如果要扫描大量的小文件，会导致性能很差，因此需要将这些小文件合并成大一点的文件。因此所谓的小合并，就是把多个小的组合在一起，形成一个较大的，通常是累积到个 后执行。通过参数配置。小合并的大致步骤为：

分别读取出待合并的文件的，并顺序地写入到位于目录下的临时文件中
将临时文件移动到对应的目录中
将合并的输入文件路径和输出路径封装成写入日志，并打上标记，最后强制自行
将对应数据目录下的合并的输入文件全部删除，合并完成

这种小合并一般速度很快，对业务的影响也比较小。本质上，小合并就是使用短时间的消耗以及带宽消耗换取后续查询的低延迟。
、大合并
所谓的大合并，就是将一个下的所有合并成一个文件，在大合并的过程中，之前删除的行和过期的版本都会被删除，拆分的母的数据也会迁移到拆分后的子上。大合并一般一周做一次，控制参数为。大合并的影响一般比较大，尽量避免统一时间多个进行合并，因此通过一些参数来进行控制，用于防止多个同时进行大合并。该参数为： 具体算法为：
参数的值乘于一个随机分数，这个随机分数不能超过的值。的值默认为。通过参数的值加上或减去参数的值乘于一个随机分数的值就确定下一次大合并的时间区间。
用户如果想禁用 ，只需要将参数设为。建议禁用。
七、参考资料参考了很多前人的资料，尤其是 ，博客写得很棒，罗列如下：作者：周大军孙大伟， 腾讯后台开发 高级工程师商业转载请联系腾讯获得授权，非商业转载请注明出处。原文链接：

导读
做好自动化测试从来不件容易的事情，更何况是手游的自动化测试，相比传统的，手游画面纯绘制无可识别控件，且界面动画多、随机性大。举个例子，拿新手引导来说，手游中新账号试玩会有一系列的新手引导，当新手引导过程通过之后，后面就不会再出现，但当账号升级到一定等级，又会出现新玩法的新手引导。且手游的版本迭代非常快，平均周就会出一个版本，界面也经常发生变化，这些都给自动化测试带来很多障碍。
为解决手游自动化测试的这一瓶颈，腾讯依托腾讯人工智能研究的技术优势，率先尝试将基于深度学习的人工智能应用于手游测试当中，开启手游自动化测试时代。  展台上火爆的贪吃蛇互动展示，正是这一探索的成果之一。
自动化测试系统，开启手游测试新风向
腾讯游戏的团队，对于更高质量手游的追求从未停歇过，如今大火，技术上也有比较大的进步以及成熟的框架，这也给手游的自动化测试带来很多新的可能性，目前腾讯内部也有不少团队在积极研究手游的自动化测试，大体上分为两种，一种是让模型可以测试绝大多数的手游；另一种则是基于特定的手游做更细更有针对性的测试模型。 
、自动化测试系统的处理过程
手游自动化测试最重要的核心，在于如何让电脑更智能的模拟真人的操作行为。一套基于深度学习的自动游戏系统，可以通过迭代训练，让机器自己做出动作决策，从而完成一系列的游戏操作。
自动游戏系统主要由部分组成，说明如下：● 处理模块：负责和手机交互，自动化操作，管理，结果记录和存储等；● 处理模块：负责游戏界面的识别；● 处理模块：负责识别一局游戏内的物体和数据等；● 处理模块：负责决策玩游戏的动作决策，采用深度强化学习算法；
自动游戏系统整体框架如下图：
以天天酷跑为例，看自动化测试实战演练
以天天酷跑游戏的自动化测试为例，整个测试过程主要分为前期训练、接入测试、性能与结构反馈三个步骤：
前期训练前期训练得到神经网络的权值文件，后面测试只需要让神经网络加载这个权值文件就可输出学习到的动作决策，达到自动玩游戏的目的。
系统采用特定算法对模型进行训练。训练结果如下图，横坐标是玩的游戏局数，纵坐标是一局跑的里程数。整个训练过程共进行了上万局游戏，随着训练的次数增多，每局的里程数也在上升。
接入测试天天酷跑游戏运行在云真机上，自动化进程和云真机交互，实时抓取游戏画面数据。
进入游戏后，检测进程识别游戏画面中的物体和数据，例如天天酷跑中的台阶、坑、柱子等物体信息以及距离等数值信息。游戏画面和识别出的物体和数据最终发给深度学习进程作为输入，深度学习进程的输出就是执行玩游戏的动作，例如天天酷跑中就是“下蹲”、“起身”、“跳跃”等。
一局游戏结束后，再重复上述的过程进行下一局测试。
性能和结果数据在玩游戏的同时，系统可以获取手机的性能数据和游戏的结果数据，并在网页端进行展示。
如下图所示，每一行对应天天酷跑一局游戏，分别展示了手机利用率，内存使用量，电池电量，温度，玩一局跑的里程数和游戏时间以及死亡前的游戏画面。
除了天天酷跑，自动游戏系统已接入腾讯多项精品游戏的测试工作。
腾讯携自动化手游测试，为游戏创造更大价值
使用自动游戏系统进行手游测试，游戏厂商可以借助的智能轻松实现类似于人工测试时在真机上玩游戏的过程，节省大量的测试人力成本。
随着人工智能技术的飞速发展，简单机械的游戏测试工作必将逐步向自动化、智能化转移。腾讯作为游戏质量的守护者，将为游戏开发者们提供操作更加便捷高效的自动化测试方案，让游戏开发者能更多地专注于游戏创意性、可玩性、操作习惯等更需要创意的环节，为游戏创造更大的价值。

关于腾讯 
腾讯是腾讯游戏官方推出的一站式游戏测试平台，用十年腾讯游戏测试经验帮助广大开发者对游戏开发全生命周期进行质量保障。腾讯提供：适配兼容测试；云端真机调试；安全测试；耗电量测试；服务器性能测试；舆情分析等服务。
点击地址：立即体验！从来没有一款产品，像微信一样这样深刻的改变了现代中国人的社交。
也从来没有一款产品，像小程序一样，还没有面世之前引发了大多数企业与开发者的关注。
微信订阅号的兴起使得很多中小企业和个人品牌得以兴起、获得融资，可以说微信之前为运营和写作方面有特长的个体赋能。小程序将会为程序员赋能，带来新一波程序员个体崛起的机会，身边的草根大号有个别创业者就先投了万来押小程序这波机会。
年的微信公开课，张小龙首次预告了他对于应用号的构想，引发业界的对于移动开发积极讨论。时隔一年，微信公开课，张小龙的开场个半小时时间都在讲对于小程序的具体产品规划，并预告小程序年月号上线。
笔者近期在知乎上写的一篇技术教程《无内测资格，如何用腾讯云小时开发小程序》在短短天内收获了超万的阅读。小程序的热度可见一斑，就在我写今天这篇文章的同时，我已经在群聊里看到了刚刚发布的几个小程序，不乏颇有创意的产品。

为什么你需要关心小程序？
首先，小程序是改善移动端用户体验的一次机会。
现在用户在移动端的内置浏览器打开比如滴滴打车这些，一般都会出现一个进度条，大概需要秒的时间才能够看到的界面。技术层面是因为的加载过程，需要从服务器端拉取数据，会有一定的白屏等待时间。
其次，对于企业而言，小程序会是帮你留住的低频用户的利器，也会是把线下服务数据化的最佳工具之一。以我自己为例，我现在既没有装京东又没有装滴滴，但我还是不时使用滴滴打车和用京东购物，原因在于我一般通过微信里的第三方服务入口使用它们，而不愿意安装额外的，占用手机里有限的空间。
对于媒体而言，微信订阅号提供了用内容触达线上用户的最佳平台，今时今日微信公众号吸引了不少品牌广告的投放；再次，小程序未来提供了媒体与效果广告结合的更多可能，一些媒体与企业的服务将可能以工具的方式触达用户。
最后，对于程序员而言，前端的语言我只需要用\\的语法一次开发，既可以跨和两大平台运行，大大降低需要招募两支开发团队的成本。
如何策划小程序，与与的产品逻辑差异
对于产品经理而言，小程序提供了一种更好借助扫一扫功能与线下服务互动，增强群组中的用户互动行为，或者是提供用完即走的全新服务，使得用户不时会想起你，来启动你的小程序。
结合微信公开课的官方分享，目前看起来小程序会比较适合以下类型的场景：
工具性的应用微信就是一种工具
占领心智，培养低频用户习惯 滴滴打车、京东购物
引导线下客户进行线上交易买车票、船票
有限度分享，对于用户社群的增强功能群投票
不太适合纯展示性的应用，因为毕竟订阅号已经提供了较强的用户交互功能，而且小程序在分享朋友圈等行为上有着诸多限制。
如何快速开发小程序
为了造福广大开发者，我尝试了现有主要的小程序开发解决方案和工具，记录了以下使用体验，尽可能让大家少踩坑。

腾讯云小程序解决方案：比较适合一定规模的互联网企业搭建一个较为完善、可扩展的小程序。
一键式购买小程序所需后端云主机、数据库、域名资源，并自动完成等配置。
提供登录接口使用示例：进行带会话的网络请求示例 信道服务使用示例提供图片对象自动上传功能，帮助解决小程序大小限制：

腾讯云和联合推出的：比较适合快速搭建一个小程序
演示了如何使用存储  对腾讯云端数据进行查询、增加、修改与删除查询结果为一个列表时，如何将其绑定到视图层进行展示以及如何在点击事件中得到对应的数组项如何自动登录  用户系统如何实现下拉刷新

青雀：实际服务的地址十方建站，提供的免费小程序模版太少，只有一个餐厅的小程序展示
：从拖拽式网页生成转到小程序自动生成，模版提供的不少，推荐体验。

阿拉丁统计 从接口来看收集的小程序信息不少，但是目前小程序官方也提供数据分析服务了，接入必要性一般。

结语：小程序带来的不是流量红利，是心智红利！
如同张小龙所言，我们要理解小程序，就要先理解时代的官网。官网对于时代的企业而言，没有不行，因为客户一般会去搜索你的官网，看你是不是一家靠谱的企业，但是一般官网不会是你全部收入的来源。
以我自己为例，因为工作关系经常往返珠海深圳两地，对于我而言船票只会在微信上买，因为方便我提前购票，到了现场扫描二维码即可取票，小程序对于汽车票等等这些还没有完全线上化的服务存在较大的机会，张小龙在年微信公开课上举例的基本都属于此类。
在我看来，小程序带来的不是流量红利，是心智红利。你能不能在用户心目中，实现让我们微信一下这样的产品即品类？我大胆的预测一下，未来用户在需要某类服务的时候，会不会在微信上第一时间搜你的小程序很重要，因为，这可能是你拉开与对手差距的关键。

相关推荐一起脱去小程序的外套和内衣  微信小程序架构解析【腾讯云的种玩法】元体验腾讯云小程序后端解决方案腾讯独家详解小程序，给你一份商业化场景应用指南一引言

“如果某个实体表现出以下任何一种特性，它就具备自主性：自我修复、自我保护、自我维护、对目标的自我控制、自我改进。” —— 凯文·凯利

  有时可能遇到启动必  的绝境：每次打开  都闪退，无法正常使用。
为了尝试解决这个问题，微信读书开发了  连续闪退保护工具：，检测连续闪退，在连续闪退出现时，尝试自修复 ：

本文探讨了连续闪退问题的产生原因、检测、修复机制，以及如何在你的项目中引入、测试和使用 。
二连续闪退检测
首先要检测用户  出现了连续闪退的情况，有两种检测方法，捕获异常和计时器。
捕获异常
检测连续闪退，可以通过捕获异常来实现，异常有以下种类：

 异常：_
 信号：
 异常：应用层，通过  捕获

在念茜的漫谈   收集框架一文中详细介绍了  异常和  信号捕获  的机制。简单来说，异常一般产生自  的微内核 ，然后在  层转换成   信号，以标准  信号的形式提供给用户。 是使用者在处理  逻辑时，用编程的方法抛出。
如何捕获异常
通过以下方法捕获异常：

利用   捕获  异常
通过   注册  来捕获  异常信号
注册  来捕获应用级异常

 上报工具如  通过注册  异常  信号 的  达到检测的目的，对用户提供了处理异常的接口。
如何检测
可以利用  这类工具来检测连续闪退：

首先维护一个计数变量，表示连续闪退次数
在  的   中加入逻辑：如果启动  内  使计数器加一
每次启动时，如果连续闪退计数  ，则检测到了连续闪退
启动后，执行一个定时任务，在  后重置计数如果  连续闪退则不会重置

流程图

优缺点
通过  异常、 信号、 异常来检测闪退，能获得更多的  上下文，但由于  收集框架多使用这些方法，可能会有这样的风险：与第三方  收集框架冲突导致漏检测。另外，可能会与  已有的异常处理代码产生耦合。
计时器方法
除了通过捕获异常的方式检测连续闪退，还可以通过计数器方法来检测：

维护一个计数变量，用于表示连续闪退的次数
在启动  后使计数加一
接着使用 _ 方法在  后清零计数，如果  活不过  秒计数就不会被清零
如果发现计数变量  ，表明  连续  次连续闪退，启动保护流程，重置计数。
当保护流程完成后，进入  正常启动流程

流程图

优缺点
而计数器方法逻辑简单，与原有的代码耦合小。虽然有误报可能在启动后立即被  掉，误认为 ，但是可以通过设置阈值来减小误报的误报率。
综上权衡，我们使用计时器方法检测连续闪退。
三连续闪退修复
检测到连续闪退后，接下来要尝试对闪退进行修复，这里先分析可能的闪退原因，再结合微信读书的例子说明修复流程。
闪退原因
连续闪退，可能是  启动关键路径中执行了必  的代码，原因可能有：

数据库损坏：在日常使用如异常退出、断电，或者错误的操作参考：  。
文件损坏：处理文件时如果没有 ，损坏文件会抛出  导致 
网络返回数据处理异常：比如预期返回数组，但实际返回了字典，对字典对象执行  方法会产生 ：     ；，或返回破损的  包，在解压失败导致 。
代码 ：当必  的代码出现在启动关键路径中，就会导致连续闪退。
针对 ，可以通过工具修复数据库，或者删除 。针对，可以删除文件来进行修复。对于  和 ，我们需要具体地分析  案例，通过  来进行修复。

微信读书的修复流程
为了应对上述导致连续闪退的原因，微信读书的修复流程为：

进入  时检查是否有连续闪退，无则执行 
弹  提示用户是否修复，轻触『修复』执行，否则执行 
尝试下载并执行  补丁
这里是为了解决上述第点  代码  导致的闪退，使用  可以进行热修复。在  时，会卡住界面发请求检查是否有可用的  脚本，如果有则加载执行，解决代码  导致的闪退。

尝试删除    目录下的所有文件

这里直接删除了所有用户数据，适用于微信读书这种所有数据都在云端，删除后可以完全从云端恢复。如果你的  不属于这种场景，那么应该在  中自定义修复逻辑，比如：
 不删除文件，只修复数据库 修复前把用户数据备份到云端 收集  样本，查明原因，定制  修复补丁并下发

退出微信读书登录状态

进入原 连续闪退检测  保护流程如图所示：



实现
检测和连续  并修复需要修改原 逻辑，有几种方法：
直接修改  方法。新建一个  类来继承 ，覆盖  方法，然后把  函数中的  替换为 新建一个  扩展，然后用   的方法替换  方法。上述三种方案，对现有项目改动代价是     。因此，我们使用对源码修改代价最小的方案  来替换。
检测的逻辑  已经处理好，修复的处理预留了接口，可以由用户自定义，把自定义的修复流程传入  即可。
使用
引入项目

下载  源码 ，将  目录下所有文件拖拽到你的  项目

在  的  方法中添加检测前需要执行的代码，比如设置上报：
 {
   {
     
    
}

   {
      
}
}

在  方法中添加修复逻辑，比如删除文件：
 {
  检查  更新
 
  删除    目录下所有文件
  
    
}
如需执行异步的修复逻辑，在  方法添加修复逻辑，并在完成修复后调用  ：
 {
        
     异步修复
         {
      正常启动流程
             
       }
}


测试

首先制造连续闪退场景：
启动后  秒内，双击  通过上划手势  掉 ，重复多次。也可以在代码里人为制造

当连续闪退超过  次时，会提示用户修复：

用户轻触修复， 重置初始状态，连续闪退问题解决：




源码


相关推荐
微信读书排版引擎自动化测试方案
手游兼容性测试  产品简介 的论文
年月，在上发表了一篇论文见附件：     。文章描述了如何让电脑自己学会打 电子游戏。
 是年代风靡美国的游戏机，总共包括个独立的游戏，其中不乏我们熟悉的打砖块， 小蜜蜂等经典游戏。算法的输入只有游戏屏幕的图像和游戏的得分，在没有人为干预的情况下，电脑自己学会了游戏的玩法，而且在个游戏中打破了人类玩家的记录。
给出的深度络架构图如下：

网络的左边是输入，右边是输出。 游戏屏幕的图像先经过两个卷积层论文中写的是三个，然后经过两个全连接层， 最后映射到游戏手柄所有可能的动作。各层之间使用激活函数。
 强化学习
根据维基百科的描述，强化学习定义如下强化学习是机器学习中的一个领域，强调如何基于环境而行动，以取得最大化的预期利益。其灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。

在强化学习的世界里， 算法称之为， 它与环境发生交互，从环境中获取状态，并决定自己要做出的动作环境会根据自身的逻辑给予以奖励。奖励有正向和反向之分。比如在游戏中，每击中一个敌人就是正向的奖励，掉血或者游戏结束就是反向的奖励。
 马尔可夫决策过程
现在的问题是，你如何公式化一个强化学习问题，然后进行推导呢？最常见的方法是通过马尔可夫决策过程。
假设你是一个代理，身处某个环境中例如《打砖块》游戏。这个环境处于某个特定的状态例如，牌子的位置、球的位置与方向，每个砖块存在与否。人工智能可以可以在这个环境中做出某些特定的动作例如，向左或向右移动拍子。
这些行为有时候会带来奖励分数的上升。行为改变环境，并带来新的状态，代理可以再执行另一个动作。你选择这些动作的规则叫做策略。通常来说，环境是随机的，这意味着下一状态也或多或少是随机的例如，当你漏掉了球，发射一个新的时候，它会去往随机的方向。
状态与动作的集合，加上改变状态的规则，组成了一个马尔可夫决策过程。这个过程例如一个游戏中的一个情节形成了状态、动作与奖励的有限序列。

其中  表示状态， 表示动作， 代表了执行这个动作后获得的奖励。情节以最终的状态  结束例如，「 」画面。一个马尔可夫决策过程基于马尔可夫假设 ，即下一状态  的概率取决于现在的状态  和动作 ，而不是之前的状态与动作。
 折扣未来奖励  
为了长期表现良好，我们不仅需要考虑即时奖励，还有我们将得到的未来奖励。我们该如何做呢？
对于给定的马尔可夫决策过程的一次运行，我们可以容易地计算一个情节的总奖励：

鉴于此，时间点  的总未来回报可以表达为：

但是由于我们的环境是随机的，我们永远无法确定如果我们在下一个相同的动作之后能否得到一样的奖励。时间愈往前，分歧也愈多。因此，这时候就要利用折扣未来奖励来代替：

在这里 γ 是数值在与之间的贴现因子——奖励在距离我们越远的未来，我们便考虑的越少。我们很容易看到，折扣未来奖励在时间步骤  的数值可以根据在时间步骤  的相同方式表示：

如果我们将贴现因子定义为 γ=，那么我们的策略将会过于短浅，即完全基于即时奖励。如果我们希望平衡即时与未来奖励，那么贴现因子应该近似于 γ=。如果我们的环境是确定的，相同的动作总是导致相同的奖励，那么我们可以将贴现因子定义为 γ=。
一个代理做出的好的策略应该是去选择一个能够最大化折扣后未来奖励的动作。
 算法描述：

算法中的 α 是指学习率，其控制前一个  值和新提出的  值之间被考虑到的差异程度。尤其是，当 α= 时，两个  互相抵消，结果刚好和贝尔曼方程一样。我们用来更新  的只是一个近似，而且在早期阶段的学习中它完全可能是错误的。但是随着每一次迭代，该近似会越来越准确；而且我们还发现如果我们执行这种更新足够长时间，那么  函数就将收敛并能代表真实的  值。
 卷积神经网络
在图像处理中，往往把图像表示为像素的向量，比如一个×的图像，可以表示为一个的向量。在上一节中提到的神经网络中，如果隐含层数目与输入层一样，即也是时，那么输入层到隐含层的参数数据为×=，这样就太多了，基本没法训练。所以图像处理要想练成神经网络大法，必先减少参数加快速度。
 局部感知
卷积神经网络有两种神器可以降低参数数目，第一种神器叫做局部感知野。一般认为人对外界的认知是从局部到全局的，而图像的空间联系也是局部的像素联系较为紧密，而距离较远的像素相关性则较弱。
因而，每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。网络部分连通的思想，也是受启发于生物学里面的视觉系统结构。视觉皮层的神经元就是局部接受信息的即这些神经元只响应某些特定区域的刺激。如下图所示：左图为全连接，右图为局部连接。

在上右图中，假如每个神经元只和×个像素值相连，那么权值数据为×个参数，减少为原来的万分之一。而那×个像素值对应的×个参数，其实就相当于卷积操作。
 参数共享
但其实这样的话参数仍然过多，那么就启动第二级神器，即权值共享。在上面的局部连接中，每个神经元都对应个参数，一共个神经元，如果这个神经元的个参数都是相等的，那么参数数目就变为了。
怎么理解权值共享呢？我们可以这个参数也就是卷积操作看成是提取特征的方式，该方式与位置无关。这其中隐含的原理则是：图像的一部分的统计特性与其他部分是一样的。这也意味着我们在这一部分学习的特征也能用在另一部分上，所以对于这个图像上的所有位置，我们都能使用同样的学习特征。
更直观一些，当从一个大尺寸图像中随机选取一小块，比如说  作为样本，并且从这个小块样本中学习到了一些特征，这时我们可以把从这个  样本中学习到的特征作为探测器，应用到这个图像的任意地方中去。特别是，我们可以用从  样本中所学习到的特征跟原本的大尺寸图像作卷积，从而对这个大尺寸图像上的任一位置获得一个不同特征的激活值。
如下图所示，展示了一个×的卷积核在×的图像上做卷积的过程。每个卷积都是一种特征提取方式，就像一个筛子，将图像中符合条件激活值越大越符合条件的部分筛选出来。

 多卷积核
上面所述只有个参数时，表明只有个×的卷积核，显然，特征提取是不充分的，我们可以添加多个卷积核，比如个卷积核，可以学习种特征。在有多个卷积核时，如下图所示：

上图右，不同颜色表明不同的卷积核。每个卷积核都会将图像生成为另一幅图像。比如两个卷积核就可以将生成两幅图像，这两幅图像可以看做是一张图像的不同的通道。如下图所示，下图有个小错误，即将改为，改为即可。下文中仍以和称呼它们。
下图展示了在四个通道上的卷积操作，有两个卷积核，生成两个通道。其中需要注意的是，四个通道上每个通道对应一个卷积核，先将忽略，只看，那么在的某位置处的值，是由四个通道上处的卷积结果相加然后再取激活函数值得到的。

所以，在上图由个通道卷积得到个通道的过程中，参数的数目为×××个，其中表示个通道，第一个表示生成个通道，最后的×表示卷积核大小。
 
在通过卷积获得了特征  之后，下一步我们希望利用这些特征去做分类。理论上讲，人们可以用所有提取得到的特征去训练分类器，例如  分类器，但这样做面临计算量的挑战。
例如：对于一个  像素的图像，假设我们已经学习得到了个定义在输入上的特征，每一个特征和图像卷积都会得到一个  −    ×  −    =  维的卷积特征，由于有  个特征，所以每个样例  都会得到一个  ×  =  维的卷积特征向量。学习一个拥有超过  百万特征输入的分类器十分不便，并且容易出现过拟合 。
为了解决这个问题，首先回忆一下，我们之所以决定使用卷积后的特征是因为图像具有一种“静态性”的属性，这也就意味着在一个图像区域有用的特征极有可能在另一个区域同样适用。
因此，为了描述大的图像，一个很自然的想法就是对不同位置的特征进行聚合统计，例如，人们可以计算图像一个区域上的某个特定特征的平均值 或最大值。这些概要统计特征不仅具有低得多的维度 相比使用所有提取得到的特征，同时还会改善结果不容易过拟合。这种聚合的操作就叫做池化 ，有时也称为平均池化或者最大池化 取决于计算池化的方法。

 多层卷积
在实际应用中，往往使用多层卷积，然后再使用全连接层进行训练，多层卷积的目的是一层卷积学到的特征往往是局部的，层数越高，学到的特征就越全局化。
 算法描述
单纯的算法使用表来保存状态，一个×图像的像素状态数基本接近与无穷，故有了 即算法，算法描述如下：

 使用训练“接砖块”游戏
深度学习的开源类库比较多，比较著名的有、等。此处我们使用来训练游戏“接砖块”。
游戏截图如下：

通过点击鼠标左键、右键控制滑块的左右移动来接住小球，如果球碰到底面，则游戏结束
主要代码如下游戏本身的代码省略，此处主要关注算法代码：

的定义类，此处是什么不重要，只要提供执行的方法，获取当前游戏区域像素的方法即可
 
     ____  初始化
     是_、_、_  
     控制棒子左右移动；返回游戏界面像素数和对应的奖励。像素奖励强化棒子往奖励高的方向移动  
      

 _
_ = 
 跟新梯度
_ = 
_ = 
 测试观测次数
 =  
 = 
 记忆经验大小
_ = 
 每次训练取出的记录数
 = 
 输出层神经元数。代表种操作_    _    _   
 =    _    _    _  
_ =        游戏像素
 =         操作
定义卷积神经网络
 ___
     = {_   
               _   
               _   
               _ 
               _ }

     = {_
              _
              _
              _
              _}

     = _ _  =      =   _
     =  _  =      =   _
     =  _  =      =   _
    _ =   
     = _ _  _

    _ =  _  _
     _

训练神经网络
 ___
    _ = ___

     =   
     =  

     = __  _ = 
     = _  
     = 

     = 
     = 

    _  = _
     =    _
      =    _
    __ =      = 
      __

       
        __

         = 

         = 
         = _
         
             __
            _ = __ = {_  __}

            _ =  =
             = _
                 = 
            
                 = _
            _ = 
               _
                 = _  _  

              = _

             =    _
              =    _
             =    
            __ =  __    = 

            __ _  __

               _
                

               
                 =  
                ___ =     
                _ =     
                _ =     
                ___ =     

                _ = 

                _ = __ = {_  ___}

                    
                    __  _  _

                _ _  _
                _ = {  _   _ _  ___}

            __ = __
             = 
                      

___
 总结
说到这里，相信你已经能对强化学习有了一个大致的了解。接下来的事情，应该是如何把这项技术应用到我们的工作中，让它发挥出应有的价值。小程序上线一月有余，有不少创业团队如朝夕日历、小睡眠、小密圈等工具性的应用享受了这一波产品红利，收获了数十万新用户。
笔者近期接触了不少从事后端开发的、程序员，纷纷表示了想要了解小程序开发技术的兴趣。下面，结合一个 的小程序示例，给大家简单讲解一下如何在腾讯云上开发一个简单的小程序，小程序示例的完成结果如下：

  小程序代码结构

定义了小程序的启动逻辑定义了小程序的页面结构目前我们的小程序只有一个页面定义了欢迎页面的有什么，目前我们放了一张、一个按钮和一个文字标签。 定义了欢迎页面的样式定义了欢迎页面的业务逻辑
小程序用到的组件与云服务
腾讯云：腾讯云
前端代码


{     {      =  ||   }  {      }}



{          {                    }}



获取应用实例  = {   {     点按钮让我说话     {}  }
      {      =         }     {  }}



   {{}} 
 {{}} 
 请说话 


  定义两个版本的 逻辑，是将标签文字替换为“ ”是将从腾讯云数据库拉取回的数据不同语言的 显示在标签里。

 _   {    { }}
 _   {
{}

{
      仅为示例，并非真实的接口地址
     { }
     {
         
    }
      {
        {}
    }
}
}
 = _

后端代码
链接腾讯云主机上的服务，把数据库中读取的信息显示在页面的 {{}}标签里。文件


 =     
    _ {      \ _    }
 =          = 
    = __
 _
    
   


相关推荐
简约而不简单——大众点评小程序开发经验谈
新增线下、、公众号多处入口，小程序会再火起来么？内有福利
小程序发布后最全解析！前言
昨天月日，谷歌发布了一个适用于和应用程序中文名 照片扫描仪，它可让您仅使用智能手机将照片打印数字化。 
的主要功能之一是能够从打印件中去除眩光，这些打印件通常具有光泽和反光性，它们的塑料相册页面或玻璃覆盖的相框也会造成反光。 为了创解决这个问题，我们开发了独特的计算机视觉和图像处理技术，可以仔细对齐和组合几个稍微不同的打印图片，以将眩光与图像分开。

 相册全新推出照片扫描仪应用，只要使用手机摄像头就能扫描并保存最心爱的冲印照片。
照片完美、无眩光
只能通过拍照修图已成为过去时。只要进行扫描，就能制作效果更佳的数字照片，无论照片在哪里都不成问题。

通过简单的分步流程进行扫描，轻松获取无眩光的扫描内容

根据边缘检测进行自动剪裁

透视校正功能可矫正扫描照片中歪斜扭曲的视角

无论扫描角度如何，智能旋转功能都摆正照片


数秒内完成扫描
轻松快捷地截取您最心爱的照片，节省修改照片的时间，好好回味一下青春年少时的非主流造型。
 相册能让照片安全无虞且便于搜索
通过免费的  相册应用备份您的扫描照片，不仅安全可靠、便于搜索，而且井井有条。借助影片、滤镜和高级修片控件，可以让扫描的照片愈发生动有趣。只需发送一个链接，就能与任何人分享照片。

左：物理打印的常规图片。右：的无眩光输出
正文
当拍摄照片的单张照片时，确定图片的哪些区域是实际照片，哪些区域是眩光，这是程序面临的主要挑战。 此外，眩光可能经常使图像中的区域饱和，使得那些区域无法看到或恢复其下面的照片的部分。 但如果在移动相机的同时拍摄照片的照片，眩光的位置往往会改变，覆盖照片的不同区域。 大多数情况下，照片的每个像素在至少一张照片中可能不会被眩光所覆盖。 我们可以组合多张照片拍摄的不同角度的照片去除眩光。 面临的挑战是，图像需要非常准确地对齐，以便正确地组合它们，并且该处理需要在手机上非常快速地运行以提供即时的体验。

左：捕获的输入图像共个右：如果我们稳定照片上的图像，我们可以看到只有眩光移动，覆盖照片的不同部分。注意：没有一个图像是无眩光的。
我们的技术灵感来自于我们早前在 上发表的作品，我们称之为“ 无障碍摄影”。 它使用的原理是从视野中去除障碍物。 然而，我们最初提出的算法是基于生成模型，其中主场景和障碍层的运动和外观被估计。 虽然该型号相当强大，可以清除各种障碍物，但是在智能手机上运行的计算的费用太贵了。 因此，我们建立了一种更简单的模型，将眩光视为异常值，只尝试注册底层的无眩光照片。 虽然这种模式更简单，但是由于注册需要高度准确和稳健，所以这个任务仍然是非常具有挑战性的。
工作原理
从用户移动相机拍摄的一系列照片开始。 第一张图片  “参考框架”  定义了所需的输出视点。 然后，用户被指示需要另外四个帧。 在每个附加帧中，我们检测稀疏特征点我们计算哈里斯角上的特征，并使用它们来建立将每个帧映射到参考帧的同位处。
左：检测到的特征在参考帧和每个其他帧左之间匹配根据估计的同形异义右匹配。
虽然这种技术可能听起来很直接，但是有一种捕捉同态性只能对齐平面图像。 但是打印的照片通常不是完全平坦的如上所示的例子。 因此，我们使用光流  运动的基本计算机视觉表示，其在两个图像之间建立像素点映射，以校正非平面。 我们从单体对齐的帧开始，并计算“流场”以扭曲图像并进一步优化注册。 在下面的示例中，请注意左边照片的角落在注册框架之后，只能使用同型字，缓慢地“移动”。 右侧显示如何使用光流优化注册后照片可以更好地对齐。

原图左和使用光流的细化之后右的比较
注册的差异是很微小的，但对最终结果有很大的影响。 请注意，结果中多少小的错位显示为重复的图像结构，以及如何通过额外的流程细化减轻这些工件。

原图左和使用光学流动细化去除眩光结果之间的比较。 在结果中，仅使用同位素左，注意人的眼睛，鼻子和牙齿周围的物品，以及织物上重复的茎和花瓣。
这也是一个难点，就是使光流成为一种自然而然的算法，在手机上工作非常快。 代替在传统上计算每个像素处的光流计算的流向量的数量等于输入像素的数量，我们通过较少数量的控制点表示流场，并且在 作为控制点运动的函数的图像。 具体来说，我们将每个图像划分成平铺的，不重叠的单元格，以形成网格，并将单元格中的像素的流程表示为包含单元格的四个角的流的双线性组合。
网格光流网格设置。 表示为封装它的单元格的四个角点的双线性插值。

左：在其中一个框架上计算的流场的图示。右：流色彩编码：分别由色相和饱和度表示的取向和幅度。
这使要解决的问题少了很多，因为现在计算的流向量的数量等于网格点的数量，其通常远小于像素数。 这个过程在本质上类似于和中描述的基于花键的图像配准。 通过这种算法，我们可以在手机上将光流计算时间减少约倍！
叠加在清洁参考系上的单色注册的帧和流动精化的扭曲帧使用上述流场之间的翻转示出了所计算的流场如何将图像部分“捕捉”到参考帧中的相应部分优化注册。
最后，为了组合无眩光输出，对于注册帧中的任何给定位置，我们检查像素值，并使用求最小值算法来获得最暗的观察值。 更具体地说，我们计算最小亮度超过注册帧的期望值，将较少的权重分配给靠近翘曲图像边界的像素。 我们使用这种方法，而不是直接在两帧之间计算最小值，因为每帧的相应像素可能具有略微不同的亮度。 因此，由于突出图像之间的边界处的突然强度变化，每像素最小值可能产生可见的接缝。
常规最小值左与软最小值右相比。
该算法可以支持各种扫描条件  无光泽和光泽打印，照片内部或外部相册，杂志封面。
          输入                       注册                     输出无眩光

为了获得最终的结果，谷歌照片团队开发了一种自动检测和裁剪照片区域的方法，并将其整理为正面。 由于透视失真，扫描的矩形照片通常在图像上看起来是四边形。 该方法分析图像信号，如颜色和边缘，以计算出扫描图像上原始照片的准确边界，然后应用几何变换将四边形区域修正为原始的矩形，产生高质量，无眩光数码版的照片。

总的来说，所有这些操作都在你的手机上几乎瞬间完成！ 要给一个尝试，请在或上下载该应用程序。

相关推荐
谷歌开源图片压缩算法实测体验报告谷歌论文抢鲜看：教机器画画导语
人与人之间最重要的是信任，但程序的世界里，可能信任越少越好；我越发觉得越是高性能高可用的系统里，不信任原则会体现得更加淋漓尽致。 为了少走弯路，写下这篇文章留给自己参考，其中一些是自己踩过的一些坑；一些是接手他人系统时触过的雷；还有一些是从别人分享的经验学习得来；能力有限，先记下自己的一些体会，错误的地方再慢慢改正。

一、编程的世界里十面埋伏
编程，是一件容易的事，也是一件不容易的事。说它容易，是因为掌握一些基本的数据类型和条件语句，就可以实现复杂的逻辑；说它不容易，是因为高性能高可用的代码，需要了解的知识有很多很多；编程的世界，也跟扫雷游戏的世界一样，充满雷区，十面埋伏，一不小心，随时都可能踩雷，随时都可能 。

而玩过扫雷的人都知道，避免踩雷的最好方法，就是提前识别雷区并做标记设防避免踩踏。

鉴于此，编程的世界里，从输入到输出同样需要处处设防，步步为营。
、对输入的不信任
对空指针的检查
不只是输入，只有是使用到指针的地方，都应该先判断指针是否为，而内存释放后，应当将指针设置为。
【真实案例】：注册系统某段逻辑，正常使用情况下，都有对指针做检查，在某个错误分支，打印日志时，没检查就使用了该字符串；结果可正常运行，但当访问某个依赖模块超时走到改分支，触发，导致。
对数据长度的检查
使用字符串或某段，特别是时，需要尽量对数据长度做下检查和截断。 
【真实案例】：接手系统后运行数月表现良好，突然有一天，发生了，经查，是某个业务不按规定请求包中填写了超长长度，导致时发生段错误，根本原因，还是没有做好长度检查。
对数据内容的检查
某些场景下，没有对数据内容做检查就直接使用，可能导致意想不到的结果。
【案例】：注入和攻击都是利用了服务端没有对数据内容做检查的漏洞。
、对输出变更的不信任
变更的影响一般体现在输出，有时候输出的结果并不能简单的判断是否正常，如输出是加密信息，或者输出的内容过于复杂。
所以，对于每次变更
修改代码时，采用不信任编码，正确的不一定是“对”的，再小的修改也应确认其对后续逻辑的影响，有些修正可能改变原来错误时的输出，而输出的改变，就会影响到依赖该改变字段的业务。
发布前，应该对涉及到的场景进行测试和验证，测试可以有效的发现潜在的问题，这是众所周知的。
发布过程，应该采用灰度发布策略，因为测试并非总是能发现问题，灰度发布，可以减少事故影响的范围。常见灰度发布的策略有机器灰度、灰度、用户灰度、按比例灰度等，各有优缺点，需要根据具体场景选择，甚至可以同时采用多种的组合。
发布后，全面监控是有效发现问题的一种方法。因为测试环境和正式环境可能存在不一致的地方，也可能测试不够完整，导致上线后有问题，所以需采取措施补救
：如使用监控请求量、成功量、失败量、关键节点等：使用告警监控成功率：发布完，在正式环境测试一遍
【案例】系统某次修改后编译时，发现有个修改不相关的局部变量未初始化的告警，出于习惯对变量进行了初始化初始化值和编译器默认赋值不一样，而包头某个字段采用了该未初始化的变量，但在测试用例中未能体现，监控也没细化到每个字段的值，导致测试正常，监控正常；但前端业务齐齐互动使用了该包头字段，导致发布后影响该业务。
二、服务程序的世界里防不胜防
一般的系统，都会有上下游的存在，正如下图所示

而上下游的整个链路中，每个点都是不能保证绝对可靠的，任何一个点都可能随时发生故障，让你措手不及。
因此，不能信任整个链路中的任何一个点，需进行设防。
、对服务本身的不信任
主要措施如下：
服务监控
前面所述的请求量、成功量、失败量、关键节点、成功率的监控，都是对服务环节的单点监控。
在此基础上，可以加上自动化测试，自动化测试可以模拟应用场景，实现对于流程的监控。
进程秒起
人可能在程序世界里是不可靠的因素大牛除外，前面的措施，多是依赖人来保证的；所以，还是有可能发生的，这时，进程秒起的实现，就可以有效减少的影响，继续对外提供服务。
、对依赖系统的不信任
可采用柔性可用策略，对于根据模块的不可或缺性，区分关键路径和非关键路径，并采取不同的策略
对于非关键路径，采用柔性放过策略
当访问非关键路径超时时，简单的可采取有限制一定数量、一定比重的重试，结果超时则跳过该逻辑，进行下一步；复杂一点的统计一下超时的比例，当比例过高时，则跳过该逻辑，进行下一步
对于关键路径，提供弱化服务的柔性策略
关键路径是不可或缺的服务，不能跳过；某些场景，可以根据目的，在关键路径严重不可用时，提供弱化版的服务。举例如派票系统访问票据存储信息严重不可用时，可提供不依赖于存储的纯算法票据，为弥补安全性的确实，可采取缩短票据有效期等措施。
、对请求的不信任
对请求来源的不信任
有利可图的地方，就会有黑产时刻盯着，伪造各种请求，对此，可采取如下措施
 ：权限控制  如鉴权、模块鉴权、白名单、用户登录态校验等 ：安全审计
权限控制仅能打击一下非正常流程的请求，但坏人经常能够成功模拟用户正常使用的场景；所以，对于一些重要场景，需要加入安全策略，打击如、号码等信息聚集，频率过快等机器行为，请求重放、劫持等请求
对请求量的不信任
前端的请求，不总是平稳的；有活动时，会暴涨；前端业务故障恢复后，也可能暴涨；前端遭到恶意攻击时，也可能暴涨；一旦请求量超过系统负载，将会发生雪崩，最终导致整个服务不可用，对此种种突发情况，后端服务需要有应对措施
：频率限制，控制各个业务的最大请求量业务根据正常请求峰值的倍申请，该值可修改，避免因一个业务暴涨影响所有业务的情况发生。
：过载保护，虽然有频率限制，但业务过多时，依然有可能某个时间点，所有的请求超过了系统负载，或者到某个，某台机器的请求超过负载，为避免这种情况下发生雪崩，将超过一定时间的请求丢弃，仅处理部分有效的请求，使得系统对外表现为部分可用，而非完全不可用。
三、运营的世界里不可预测

、对机器的不信任
机器故障时有发生，如果服务存在单点问题，故障时，则服务将完全不可用，而依赖人工的恢复是不可预期的，对此，可通过以下措施解决
容灾部署
 即至少有两台以上的机器可以随时对外提供服务。
心跳探测
用于监控机器是否可用，当机器不可用时，若涉及到主备机器的，应做好主备机器的自动切换；若不涉及到主备的，禁用故障机器对外提供服务即可。
、对机房的不信任
现实生活中，整个机房不可用也是有发生过的，如年的天津滨海新区爆炸事故，导致腾讯在天津的多个机房不能对外提供正常服务，对此采取的措施有：
异地部署
不同、不同城市、不同国家等部署，可用避免整个机房不可用时，有其他机房的机器可以对外提供服务
容量冗余
对于类似登陆这种入口型的系统，必须保持两倍以上的冗余；如此，可以保证当有一个机房故障时，所有请求迁移到其他机房不会引发系统过载。
、对电力的不信任
虽然我们越来越离不开电力，但电力却不能保证一直在为我们提供服务。断电时，其影响和机器故障、机房故障类似，机器会关机，数据会丢失，所以，需要对数据进行备份。
磁盘备份
来电后，机器重启，可以从磁盘中恢复数据，但可能会有部分数据丢失。
远程备份
机器磁盘坏了，磁盘的数据会丢失，使用对于重要系统，相关数据应当考虑采用远程备份。
、对网络的不信任
不同地方，网络时延不一样
 一般来说，本地就近的机器，时延要好于异地的机器 所以，比较简单的做法就是近寻址，如。
 也有部分情况，是异地服务的时延要好于本地服务的时延，所以，如果要做到较好的最优路径寻址，就需要先做网络探测，如调
常有网络有波动或不可用情况
 和机器故障一样处理，应当做到自动禁用；但网络故障和机器故障又不一样，经常存在某台机器不可用，但别的机器可以访问的情况，这时就不能在服务端禁用机器了，而应当采用本地回包统计策略，自动禁用服务差机器；同时需配合定时探测禁用机器策略，自动恢复可正常提供服务机器。
、对人的不信任
人的因素在运营的世界里其实是不稳定的因素大牛除外，所以，不能对人的操作有过多的信任。
操作备份
每一步操作都有记录，便于发生问题时的回溯重要的操作需要，避免个人考虑不周导致事故。
效果确认
实际环境往往和测试环境是存在一些差异，所有在正式环境做变更后，应通过视图和验证来确认是否符合预期。
变更可回滚
操作前需对旧程序、旧配置等做好备份，以便发生故障时，及时恢复服务。
自动化部署
机器的部署，可能有一堆复杂的流程，如各种权限申请，各种客户端安装等，仅靠文档流程操作加上测试验证时不够的，可能某次部署漏了某个步骤而测试又没测到，上线后就可能发生事故若能所有流程实现自动化，则可有效避免这类问题。
一致性检查
现网的发布可能因某个节点没同步导致漏发，也就是不同的机器服务不一样；对此，有版本号的，可通过版本号监控发现；没版本号的，则需借助进程、配置等的一致性检查来发现问题。
备注：以上提到的不信任策略，有的不能简单的单条使用，需要结合其他的措施一起使用的。
四、小结
好了，先写这么多。最重要的还是那句话，程序的世界里，应该坚持不信任原则，处处设防。一、业务场景
空间宠物业务需要实现一个定时消息触发组件，如在特定时刻给用户推送收集糖果通知、球功能定时回收用户丢弃的球等。可见，消息只有在特定时间到达才能被处理。同时，消息的产生是无序的，即后产生的消息被处理的时间可能早于先产生的消息。
二、为何选择
一些著名的消息队列组件，如  ，本身支持消息延迟投递，为何本文选择呢？一方面是引入新组建有学习、运维、接入成本，而组内已积累一定开发运维经验；另一方面则是基于实现这样一个组件难度也不大。所以决定采用。
三、原生能力探究
键空间通知
键空间通知可以在消息到达时插入一个，并给设置过期时间，键过期后会通过特定频道发布键过期通知，订阅方可收到通知并处理事件。但问题在于：

过期并不保证立即删除，只会每次执行时随机删除若干，大量同时过期无法保证时效；
机制不保证通知送达，若掉线则通知丢失；
若多个同时订阅，则都会收到通知，导致重复处理。

基于原生
可在消息插入时根据排序，从而使最早的消息排在最前面。但没有提供方法，取得第一个元素和删除需要执行两个命令。为保证原子性，可以采用事务，如：
 

     

    

 
  
    
  
或者使用，如：
      \\   \\   |   






但问题在于，虽然可顺序取出消息，但无法只在时间到达后取出消息。因此需要端实现逻辑等待时间到达再推送。同时，消息产生是无序的，如果取得了一个分钟后处理的消息，在此期间又产生了一个需要在分钟后处理的消息，逻辑将变得复杂。
由于使用原生无法满足需求，我们决定扩展命令。
四、多姿势命令扩展
官方势
脚本是利用版官方特性实现命令扩展的途径。以下脚本将读出首元素，并与当前时间戳以参数传入比较，如果消息处理时间到达则删除消息并返回；所有操作将是原子的。目前我们线上服务使用该方案。
脚本：
  =     
     
    
       
     

 {}
生成命令：
        _
缺点是：

使用脚本有额外学习成本
实现在客户端，无法很好的复用
使用后要做好运维工作，配置脚本超时，注意脚本缓存内存占用

暴力势
改源码，加一个命令。我们较早上线的一个服务使用了该方案。此处是微码传送门。
缺点是：后续官方更新都需要改代码。
时髦势
使用 模块实现。此处是微码传送门。
相比前两种方法，此方法逻辑收归在服务端，且不需要修改源码便于升级。但需要注意资源释放、复制机制等细节，谨防踩坑。
五、修改源码、实现模块后一些问题
  兼容性：要求所有从机、或加载的实例均实现了新的命令，即均为修改版或均加载了扩展模块。
  命令写入和从机的时机：

对于使用法，默认复制脚本本身，但可以使仅复 制导致变更的命令而非整个命令，参考脚本中有关”    ”和”   ”的内容。
对于版本修改源码法，在中，仅当有变更设置变量值大于时，才会触发命令传播，因此如果命令没有成功元素将不会产生命令传播。
对于 ，我们的实现中使用了低级，则需要实现中根据需要调用_复制命令。

  消息处理失败处理：中消息被后才被取得处理，若处理失败则需要在保证幂等的前提下自行重试。存储
在这里我们来看一下下的存储操作，在本节开始之前请确保你已经安装好了并启动了其服务，另外安装好了的库。
连接
连接我们需要使用库里面的，一般来说传入的及端口即可，第一个参数为地址，第二个参数为端口，端口如果不传默认是。
 
 = = =

这样我们就可以创建一个的连接对象了。
另外的第一个参数还可以直接传的连接字符串，以开头，例如：
 = 

可以达到同样的连接效果。
指定数据库
中还分为一个个数据库，我们接下来的一步就是指定要操作哪个数据库，在这里我以数据库为例进行说明，所以下一步我们需要在程序中指定要使用的数据库。
 = 

调用的属性即可返回数据库，当然也可以这样来指定：
 = 

两种方式是等价的。
指定集合
的每个数据库又包含了许多集合，也就类似与关系型数据库中的表，下一步我们需要指定要操作的集合，在这里我们指定一个集合名称为，学生集合。还是和指定数据库类似，指定集合也有两种方式。
 = 

 = 

插入数据
接下来我们便可以进行数据插入了，对于这个，我们新建一条学生数据，以字典的形式表示：
 = {
     
     
     
     
}

在这里我们指定了学生的学号、姓名、年龄和性别，然后接下来直接调用的方法即可插入数据。
 = 


在中，每条数据其实都有一个_属性来唯一标识，如果没有显式指明_，会自动产生一个类型的_属性。方法会在执行后返回的_值。
运行结果：


当然我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下：
 = {
     
     
     
     
}

 = {
     
     
     
     
}

 =  


返回的结果是对应的_的集合，运行结果：
 

实际上在 版本中，方法官方已经不推荐使用了，当然继续使用也没有什么问题，官方推荐使用_和_方法将插入单条和多条记录分开。
 = {
     
     
     
     
}

 = _

_

运行结果：
   


返回结果和方法不同，这次返回的是对象，我们可以调用其_属性获取_。
对于_方法，我们可以将数据以列表形式传递即可，示例如下：
 = {
     
     
     
     
}

 = {
     
     
     
     
}

 = _ 

_

_方法返回的类型是，调用_属性可以获取插入数据的_列表，运行结果：
   
 

查询
插入数据后我们可以利用_或方法进行查询，_查询得到是单个结果，则返回多个结果。
 = _{ }



在这里我们查询为的数据，它的返回结果是字典类型，运行结果：
 
{_         }

可以发现它多了一个_属性，这就是在插入的过程中自动添加的。
我们也可以直接根据来查询，这里需要使用库里面的。
   

 = _{_ }


其查询结果依然是字典类型，运行结果：
{_         }

当然如果查询结果不存在则会返回。
对于多条数据的查询，我们可以使用方法，例如在这里查找年龄为的数据，示例如下：
 = { }

   
    

运行结果：
   
{_         }
{_         }
{_         }

返回结果是类型，相当于一个生成器，我们需要遍历取到所有的结果，每一个结果都是字典类型。
如果要查询年龄大于的数据，则写法如下：
 = { { }}

在这里查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号，意思是大于，键值为，这样便可以查询出所有年龄大于的数据。
在这里将比较符号归纳如下表：



符号
含义
示例





小于
{ { }}



大于
{ { }}



小于等于
{ { }}



大于等于
{ { }}



不等于
{ { }}



在范围内
{ {  }}



不在范围内
{ {  }}



另外还可以进行正则匹配查询，例如查询名字以开头的学生数据，示例如下：
 = { { }}

在这里使用了来指定正则匹配，代表以开头的正则表达式，这样就可以查询所有符合该正则的结果。
在这里将一些功能符号再归类如下：



符号
含义
示例
示例含义





匹配正则
{ { }}
以开头



属性是否存在
{ { }}
属性存在



类型判断
{ { }}
的类型为



数字模操作
{ {  }}
年龄模余



文本查询
{ { }}
类型的属性中包含字符串



高级条件查询
{ _ == _}
自身粉丝数等于关注数



这些操作的更详细用法在可以在官方文档找到：
计数
要统计查询结果有多少条数据，可以调用方法，如统计所有数据条数：
 = 


或者统计符合某个条件的数据：
 = { }


排序
可以调用方法，传入排序的字段及升降序标志即可，示例如下：
 =  
    

运行结果：
    

偏移
在某些情况下我们可能想只取某几个元素，在这里可以利用方法偏移几个位置，比如偏移，就忽略前个元素，得到第三个及以后的元素。
 =  
    

运行结果：
  

另外还可以用方法指定要取的结果个数，示例如下：
 =  
    

运行结果：
 

如果不加原本会返回三个结果，加了限制之后，会截取个结果返回。

值得注意的是，在数据库数量非常庞大的时候，如千万、亿级别，最好不要使用大的偏移量来查询数据，很可能会导致内存溢出，可以使用类似{_ { }} 这样的方法来查询，记录好上次查询的_。

更新
对于数据更新可以使用方法，指定更新的条件和更新后的数据即可，例如：
 = { }
 = _
 = 
 =  


在这里我们将为的数据的年龄进行更新，首先指定查询条件，然后将数据查询出来，修改年龄，之后调用方法将原条件和修改后的数据传入，即可完成数据的更新。
运行结果：
{       }

返回结果是字典形式，即代表执行成功，代表影响的数据条数。
另外方法其实也是官方不推荐使用的方法，在这里也分了_方法和_方法，用法更加严格，第二个参数需要使用类型操作符作为字典的键名，我们用示例感受一下。
 = { }
 = _
 = 
 = _ { }

_ _

在这里调用了_方法，第二个参数不能再直接传入修改后的字典，而是需要使用{ }这样的形式，其返回结果是类型，然后调用_和_属性分别可以获得匹配的数据条数和影响的数据条数。
运行结果：
   
 

我们再看一个例子：
 = { { }}
 = _ { { }}

_ _

在这里我们指定查询条件为年龄大于，然后更新条件为{ { }}，也就是年龄加，执行之后会讲第一条符合条件的数据年龄加。
运行结果：
   
 

可以看到匹配条数为条，影响条数也为条。
如果调用_方法，则会将所有符合条件的数据都更新，示例如下：
 = { { }}
 = _ { { }}

_ _

这时候匹配条数就不再为条了，运行结果如下：
   
 

可以看到这时所有匹配到的数据都会被更新。
删除
删除操作比较简单，直接调用方法指定删除的条件即可，符合条件的所有数据均会被删除，示例如下：
 = { }


运行结果：
{   }

另外依然存在两个新的推荐方法，_和_方法，示例如下：
 = _{ }

_
 = _{ { }}
_

运行结果：
   



_即删除第一条符合条件的数据，_即删除所有符合条件的数据，返回结果是类型，可以调用_属性获取删除的数据条数。
更多
另外还提供了一些组合方法，如___、___、___，就是查找后删除、替换、更新操作，用法与上述方法基本一致。
另外还可以对索引进行操作，如_、_、_等。
详细用法可以参见官方文档：
另外还有对数据库、集合本身以及其他的一些操作，在这不再一一讲解，可以参见官方文档：导语
  上的人像模式展现了摄影深度的强大功能。 在 中，驱动此功能的深度数据现在开放使用。 了解如何利用深度信息为创意成像开辟新的可能性。 获得对高层次深度概念的更广泛的了解，并学习如何从相机中捕获流式传输和静态图像深度数据。
视频地址只能用观看
前言
是深度媒体相关的概念层面的内容。主要为下面个部分：

      
     
    
  

      

  有两个摄像头，毫米的广角摄像头，毫米的长焦镜头。它们都是万像素，分享同样的配置项、格式。可以单独使用它们，也可以用一个虚拟的第三方摄像头来共同使用它们，使它们配合。它以同步的方式运行，相同的帧速率，并且一起运行它们可以实现两个选框功能。
   双摄变焦

     
     
       

在缩放时，会自动切换广角与长焦；

适配曝光、对焦和帧速率；

对视差偏移进行补偿，使其在广角和长焦之间来回切换时平滑过渡。


 

人像模式锁定在长焦摄像头，但是会同时使用广角和长焦来生成一副浅景深效果的图像。聚焦的前景清晰，背景则会逐渐模糊。

 上改进了对焦区域的渲染。更准确的展现了一个自由度高的快速镜头，例如上图中清晰明亮的花束圈。还改进了前景和背景边缘的渲染。

为了生成这样效果的图片，就要有能力区分前景和背景，也就是需要。在，信息还只是包含在苹果自己相机的人像模式中。，苹果正在向第三方应用开放 。

上面这幅图中内嵌了下面这样一个灰度可视化的深度图：


深度信息有了对图像编辑更多的可能性，例如上图对前景和背景应用不同的滤光器；将黑白滤光器应用到背景， 应用到前景。

也可以像上图，将前景的范围缩小到手和花。

还可以对前景和背景应用不同的曝光
 
 
首先定义 。真实世界中 意思是你和观察物体之间的距离。深度图是将三维场景转化为二维表示，并将深度设置为恒定距离。
下面对针孔相机做一点研究：

针孔相机是一个没有镜头的简单的防光盒，观察物体通过一个孔映射到传感器上。

光线通过的孔被称为焦点，聚焦到成像平面的距离就是焦距，物体在成像平面上的缩放程度就取决于焦距。较短的焦距意味着更宽的视野；而更长的焦距，较长的盒子意味着较窄的视野。
简单来说，深度图是将深度转换为，单通道图像，其中每个像素值是不同的深度，如五米，四米，三米。

为了真正测量深度，需要一个专用的摄像头，比如飞行时间相机。例如，一个系统，它从物体反射光信号，然后测量返回到传感器所需的时间。
 双摄像头不是飞行时间相机。相反，它是一个基于的系统。

 是从两个不同的摄像机如眼球观测到的物体的偏移量的量度。 是视差的另一个名称。


你可以通过稳定头部并将目光固定在靠近的位置上观察此效果，然后不移动您的头部，闭上一只眼睛，然后闭上另一只眼睛。而且你可以看到彩色的铅笔看起来比后面的标记更多，因为它们更接近。这就是 效果，或者说视差效果。

现在我已经拍摄了两台被认为是立体纠正相机的鸟瞰图。意思是说，它们彼此平行，它们指向同一个方向，而且焦距是相同的，这个很重要。

每个相机将具有测量的光学中心或主要点，并且如果从针孔到图像平面绘制垂直线，则光学中心是其与图像平面相交的点。
基线

基线是指立体纠正系统中透镜的两个光学中心之间的距离。 下面是它的工作原理：

来自被观察物体的光穿过光学中心，或者说穿过两个照相机的图像平面上的不同点的孔径和平台。

是深度或者真实世界深度的规范术语

现在看看当观察点越远，图像平面上的点更加接近，同理观察点越近，图像平面上的点间隔越远。
所以当相机是立体纠正时，这些偏移只能在一个方向上移动。他们要么靠近要么远离彼此，要么在同一条线上，要么是对极线。

有了基线，可以沿着它们的光学中心排列相机，并减去图像平面上的观察点之间的距离来获得视差。一般用像素单位来表示。
但是现在对于编辑并不是很方便，如果将图像缩小，实际是改变了像素大小，然后必须在深度图中缩放每个值。
   
苹果选择使用对缩放操作有弹性的归一化值来表示。

这里有两个相似三角形，高亮：


现实世界的三角形边是，单位是米，而基线是两个光学中心之间的距离。在防光盒内，同一个三角形表示为像素中的焦距和以像素为单位的。



数学表示，并化简得到  。当物体移动得更远时，视差会缩小。基线现在绑定在中了，当处理深度图时，不需要单独携带该信息。
单位米，它可以承受缩放操作，并且从深度到的转换很简单，只需要 除以 这样一个操作。
  

  双摄像头系统是基于的
是深度的代理
归一化是深度的倒数

   
 是通用术语，对于任何，都可以叫 。可以指深度图或者视差图，因为都是深度相关的。
 

苹果的平台    对于深度的规范表示叫做。
它是框架中的一个类。
它代表深度或差异图。
它还提供了一些方法，可以在深度和差异之间进行转换。

  _  {  }   
  _  {  }   
  _  {  }   
  _  {  }   
像图像一样，除了是单通道，但它们仍然可以表示为像素缓冲区，现在  定义了在上一张幻灯片中看到类型的四个新像素格式。因为如果是在上，会要求位的值，而在上，就都是位的值。
的核心属性：
  
    {
        {  }
        {  }
        {  }
        {  }
}


由于光线，或者边缘难以分清等因素，可能会出现无法得到的点，这种点叫做。深度图也可能被处理来填补这些点。 可以通过基于周围深度数据进行内插，或者通过使用图像中存在的元数据来实现。  的  属性告诉是否以这种方式处理了。
  校准错误

比如基线计算错误。
相机不是针孔，有透镜，并且它的透镜都不是固定的。

  

 

如果使用，则透镜可以横向移动来抵消手抖动。重力可以发挥作用，因为它会导致镜头下垂。聚焦致动器实际上是施加电流的弹簧。所以这些原因可能会导致它横向移动一点，而光学中心位置的这些非常小的误差可能导致的巨大误差。当发生这种情况时，结果是中每个像素的误差是一个恒定的。  值相对于彼此仍然可用，但它们不再反映真实世界的距离。
  
  {
        {
         
          
    }
}
因此  有一个精度的概念。绝对值的精度值意味着单位确实反映了现实世界的距离，没有校准问题。相对精度意味着排序仍然保留，但是现实世界的尺度已经丢失。从第三方摄像机获取的深度数据可以报告为绝对或相对，但由于刚刚提到的校准错误，  总是报告相对精度。
相对精度并不是坏的精度。双摄像头的完全可以使用。



  

 

 框架相机捕获类分为三大部分。第一个是 ，仅仅是个控制对象。你可以告诉它开始或者停止运行，它不做任何事情，除非给它一个输入，比如  ，这里与双摄像头的设备关联，并且给提供输入。然后需要一个输出，这里是一个新的输出类型 ，它的功能类似于 ，除了提供  示例缓冲区之外，它提供了  对象。


只有双摄像头才能支持 。
将  附加到会话中时，双摄像机自动缩放到倍，即长焦的全部视野，这是因为为了计算视差，焦距必须相同，而在倍变焦下，广角摄像机的焦距与长焦相匹配。在计算深度时缩放是被禁用的。
苹果已经向  添加了一些新的访问器。在双摄像头上，您可以通过查询  属性来发现哪些视频格式支持深度。
还有一个新的  属性，可以让您看到  是什么或选择一个新的 。

    

第一个是受欢迎的照片预设。 在照片预设中，可以从  中获得屏幕尺寸的预览，还可以从中获得万像素的完整图像。所以在这里 提供了，这是屏幕尺寸。如果使用，可以获得 ，最大的。这么小的原因是每秒处理次视差图已经消耗很多性能了。也可以以较低的分辨率得到它，。
第二个是的格式，这是今年的新格式。去年有一个 的格式，帧率高达 。今年这个新格式只有 ，但是支持。同样支持两种分辨率。
最后，有一个非常小的大小的预设或活动格式，如果只是想要非常小非常快，可以使用它。
   

允许设置最小和最大视频帧速率，但不允许独立于视频帧速率设置深度帧速率。因为深度需要和视频帧率一致，或者小于视频帧率。例如，如果选择最大视频帧率为，深度可以跟上这一点，所以得到 的深度。但是，如果选择 视频，则深度跟不上，不过不会选择，而是，倍数是比较好的选择。
支持过滤深度数据。这样就可以填满空洞，并且随着你的移动也可以比较平滑，这样就不会看到从帧到帧的时间跳跃。
   
非同步数据输出

现在有四种数据输出：
第一个是  ，从 开始，它是以 或 的流媒体方式一次给出视频帧。 还有一个 ，通常会以的速度一次推送个帧。 还有一个  可以提供面部，检测到的面孔或条形码，并且这些都偶尔出现。 他们可能会有一些延迟，寻找面孔多达四帧延迟。
第四个就是  ，是以视频的帧速率或以视频均匀分割的速率传送。
如果关心同时处理所有这些数据，或者处理一定的演示时间。为了处理所有这些数据输出，您必须拥有一个非常复杂的缓冲机制，以便跟踪所有进入的时间，
  

在 中，苹果添加了一个名为  的新同步对象。它可以在单个统一回调中为给定呈现时间，提供所有可用数据，并传递一个称为 的集合对象。
所以这样就可以指定一个主输出，一个最重要的输出，一个希望所有其他东西要同步的输出，然后只要它需要，就可以做这个工作， 以确保给定演示时间的所有数据在可用之前提供给单独的统一回调。它将为你提供输出的所有数据，或者如果确保没有特定输出的数据，它将继续提供与它有关的集合。
下面一个代码示例：
 _      {
           
        {
           =    {
             
        }
    }
}
可以像数组一样使用它，也可以像字典那样使用它，具体取决于要做什么。
 _      {
            
       =    {
         
    }
}
  
 中还有一个新的流式传输功能，当使用  时，支持每个视频帧的相机内在功能。

上面讲到针孔相机，为了将空间中的点转换为空间，需要两个信息，光学中心和焦距。在计算机视觉中，可以使用这些属性通过使用逆变换将图像重新投影回空间，这在新的 中是重点。
 中的新功能，可以选择在每个视频帧中收到这样一组内在函数，通过调用  的  来选择。

相机内在函数是描述相机几何属性的矩阵。和是像素焦距。它们是分开的值和值，因为有时相机具有变形镜头或变形像素。
在设备上，我们的相机总是具有一致的像素，所以和总是相同的值。

和是透镜光学中心的像素坐标。
这些都是像素值，它们是以提供它们的视频缓冲区的分辨率给出的。

所以，一旦你选择了，可以期望以流式方式获取样本缓冲区，可以获得这个附件，有效载荷是一个数据，它包装一个矩阵浮点数，这是一个数据类型。
接《  摄影中的深度捕捉     下篇》作者简介：
王玉伟，年硕士毕业于华中科技大学，主要研究和实践方向是数据中心异构计算，项目在深度学习、高性能网络以及大数据加速等方向成功落地。现为架构平台部基础研发组成员，为向互联网数据中心提供优秀基础架构而不懈努力。

导语
基于的通用加速设计，可以大大缩短开发周期，支持业务深度学习算法快速迭代；提供与相媲美的计算性能，但拥有相较于数量级的延时优势，为业务构建最强劲的实时服务能力。
？深度学习异构计算现状
随着互联网用户的快速增长，数据体量的急剧膨胀，数据中心对计算的需求也在迅猛上涨。同时，人工智能、高性能数据分析和金融分析等计算密集型领域的兴起，对计算能力的需求已远远超出了传统处理器的能力所及。

异构计算被认为是现阶段解决此计算沟壑的关键技术，目前 “”以及“” 是最受业界关注的异构计算平台。它们具有比传统并行计算更高效率和更低延迟的计算性能优势。面对如此巨大的市场，科技行业大量企业投入了大量的资金和人力，异构编程的开发标准也在逐渐成熟，而主流的云服务商更是在积极布局。

？通用 加速
业界可以看到诸如微软等巨头公司已经部署大批量的来做 加速，相较于其他器件的优势是什么呢？
：可编程性天然适配正在快速演进的算法

、、、、 以及决策树等等
任意精度动态支持
模型压缩、稀疏网络、更快更好的网络

：构建实时性服务能力

相较于数量级提升的低延时预测能力
相较于数量级提升的单瓦特性能能力



板卡间高速互联
 构架

与此同时，的短板也非常的明显，使用硬件描述语言来进行开发，开发周期长，入门门槛高。以单独的经典模型如以及为例，针对一个模型进行定制的加速开发，往往需要数月的时间。业务方以及加速团队需要兼顾算法迭代以及适配硬件加速，十分痛苦。
一方面需要提供相较于有足够竞争力的低延时高性能服务，一方面需要的开发周期跟上深度学习算法的迭代周期，基于这两点我们设计开发了一款通用的加速器。兼顾主流模型算子的通用设计，以编译器产生指令的方式来驱动模型加速，可以短时间内支持模型切换；同时，对于新兴的深度学习算法，在此通用基础版本上进行相关算子的快速开发迭代，模型加速开发时间从之前的数月降低到现在的一到两周之内。
？通用 架构
基于的通用加速器整体框架如下，通过等框架训练出来的模型，通过编译器的一系列优化生成模型对应的指令；同时，图片数据和模型权重数据按照优化规则进行预处理以及压缩后通过下发到加速器中。加速器完全按照指令缓冲区中的指令集驱动工作，加速器执行一遍完整指令缓冲区中的指令则完成一张图片深度模型的计算加速工作。每个功能模块各自相对独立，只对每一次单独的模块计算请求负责。加速器与深度学习模型相抽离，各个的数据依赖以及前后执行关系均在指令集中进行控制。

简单而言，编译器的主要工作就是对模型结构进行分析优化，然后生成高效执行的指令集。编译器优化的指导思想是：更高的 计算效率以及更少的内存访问需求。
接下来我们以 模型为例，对加速器的设计优化思路做简单的分析。 的网络，将、、的和的 在一起，一方面增加了网络的，另一方面增加了网络对尺度的适应性。下图为模型中的基本结构。

数据依赖关系分析
此部分主要分析挖掘模型中可流水化以及可并行化的计算。流水化的设计可以提高加速器中的计算单元利用率，并行化的计算可以在同一时刻利用尽量多的计算单元。
关于流水，分析部分包括数据从加载到片上的操作与进行计算的流水，通过此项优化将内存访问的时间；计算整列的计算控制过程，保证利用率的提升。
关于并行，需要重点分析计算阵列与激活、以及归一化等“后处理”模块之间的并行关系，如何确定好数据依赖关系以及防止冲突是此处设计关键。在中，可以从其网络结构中看到， 的的卷积计算与 中的是可以并行计算的，两者之间并不存在数据依赖关系。通过此处优化，   的计算就可以被完全。
模型优化
在设计中主要考虑两个方面：寻找模型结构优化以及支持动态精度调整的定点化。
是支持大量计算并行的器件，从模型结构上寻找更高维度的并行性，对于计算效率以及减少内存访问都十分有意义。在 中，我们可以看到 \  \  的第一层卷积层，其输入数据完全一致，且卷积的以及均一致。那我们是否可以在  维度上对齐进行叠加？叠加后对 的访存需求就降低到了原来的。
另一方面，为了充分发挥硬件加速的特性，模型的过程需要对模型进行定点化操作。在中，的性能可以做到的倍，但是为了使公司内以及腾讯云上的客户可以无感知的部署其训练的浮点模型，而不需要 模型来控制精度损失，我们采用了支持动态精度调整的定点化方案。通过此种方法，用户训练好的模型可以直接通过编译器进行部署，而几乎无任何精度损失。
内存架构设计
带宽问题始终是计算机体系结构中制约性能的瓶颈之一，同时内存访问直接影响加速器件功耗效率。
为了最大化的减少模型计算过程中的访存，我们设计了如下的内存架构：

 以及  设计，最大化流水以及并行能力
支持 和 自身之间的操作
 和 之间的操作

通过这种架构，对于大多数目前主流模型，加速器可以做到将中间数据全部在片上，除了模型权重的加载外，中间无需消耗任何额外的内存操作。对于无法将中间层 完全存储在片上的模型，我们在设计上，在维度上引入了分片的概念，在 维度上引入了分片的概念。通过编译器将一次卷积或是\操作进行合理的拆分，将访存操作与加速计算进行流水化操作，在优先保证计算效率的前提下尽量减少了的访存需求。

计算单元设计
基于的通用加速器的核心是其计算单元，本加速器当前版本基于 芯片设计，计算单元由个工作在的 核心构成，理论峰值计算能力。其基本组织框架如下图所示。

芯片由两个对堆叠而成，加速器平行放置了两组处理单元。每个由组=的计算核心组成的构成，设计的关键在于提升设计中的数据复用降低带宽，实现模型权重复用和各  的复用，提升计算效率。
应用场景及性能对比
当前深度学习主流使用做深度学习中的过程，而线上部署时需综合考虑实时性、低成本以及低功耗特性选择加速平台。按深度学习落地场景分类，广告推荐、语音识别、图片视频内容实时监测等属于实时性服务以及智慧交通、智能音箱以及无人驾驶等终端实时低功耗的场景，相较于能够为业务提供强有力的实时高性能的支撑。
对于使用者而言，平台性能、开发周期以及易用性究竟如何呢？

加速性能以实际 模型为例，测试环境：个核，内存。

将整机打满，单张基于的加速器相较于性能提升倍，单张图片检测延时从降低到，成本降低。
同时，预测性能略强于的 ，但延时上有一个数量级的优化。


开发周期通用的 加速架构，能够支持业务快速迭代持续演进中的深度学习模型，包括等经典模型以及新的模型变种。

对于经典模型以及基于标准自研的算法变种，现有加速架构已经可以支持，可以在一天内通过编译器实现模型对应指令集，实现部署上线。
对于自研的特殊模型，例如不对称卷积算子和不对称操作等，需要根据实际模型结构在本平台上进行相关算子迭代开发，开发周期可缩短在一到两周之内进行支持。

易用性 加速器对底层加速过程进行封装，向上对加速平台的业务方提供易用。业务方调用简单的函数即可完成加速操作，对业务自身逻辑几乎无任何改动。

如果线上模型需要改动，只需调用模型初始化函数，将对应的模型指令集初始化即可，加速业务可以在几秒内进行切换。
结语
基于的通用加速设计，可以大大缩短开发周期，支持业务深度学习算法快速迭代；提供与相媲美的计算性能，但拥有相较于数量级的延时优势。通用的平台正在紧张研发过程中，加速器为业务构建最强劲的实时服务能力。
在云端，年初，我们在腾讯云首发了国内第一台公有云服务器，我们将会逐步把基础加速能力推出到公有云上。
异构加速的战场很大很精彩，为公司内及云上业务提供最优的解决方案是架平团队持续努力的方向。热点事件
腾讯将推出“去中心化”的智慧零售解决方案马化腾腾讯董事会主席兼月日在“腾讯全球合作伙伴大会”开幕前发表了致合作伙伴的公开信，用“深度融合”、“云化分享”、“智慧连接”、“全用户”、“大内容”、“新科技”、“宽平台”等七大关键词，分享了过去一年对数字经济发展的观察和思考。马化腾在信中呼吁行业从零和博弈的“窄平台”向共赢共生的“宽平台”转变，从而形成一个“数字生态共同体”。他还同时透露腾讯将推出“去中心化”的智慧零售解决方案，以帮助商家从“二选一”的困境中走出来。
艾伦脑科学研究所公布了首个活人脑细胞开放获取数据库艾伦脑科学研究所公布了首个活人脑细胞开放获取数据库。该数据库包含了  名捐献者的  个大脑皮层神经元电属性数据和其中  个细胞的  重建，以及来自另外  名患者的  个神经元的基因表达数据。这些活脑组织细胞数据有助于科学家更好地理解人脑。 报道
与火币网等区块链公司进入密集转型期币行虚拟货币交易所发布公告称，将逐步转型为区块链技术应用和开发的公司。同时其表示，通过投资、合作等方式拿到了世界多国数字资产交易的牌照，将进军海外市场，及合作方所有的海外业务都有当地的公司和团队负责经营。从月日时起，币行将停止人民币和比特币交易。与此同时，火币网创始人李林表示，火币中国将全面转型为区块链领域综合资讯及研究服务平台，火币韩国和火币全球美元站将提供基于韩元、美元的数字资产交易服务。火币将在月日时全面停止所有数字资产兑人民币的交易业务。
职业网站：比特币相关工作岗位增长了国际职业网站发布的信息显示，和比特币相关的工作岗位需求增长速度很快。平台上追踪的线上工作岗位发布信息最新趋势数据分析显示，今年三季度，和加密数字货币相关的工作岗位增长率达到了。据透露，企业还在寻求一些能够创造新加密数字货币的人才，并让他们编写部署区块链等技术的提案计划。新浪科技
京东到家智能柜已入驻腾讯等企业 覆盖主要一二线城市京东到家表示，战略业务智能货柜已经进驻了腾讯、平安金服、同城、、京东等知名企业，并覆盖了北上广深等主要一二线城市。新浪科技
顺丰、北汽等四家单位签署战略合作协议，推进无人机研发生产顺丰、陕西炼石有色资源有限公司、北京汽车集团有限公司、中国科学院工程热物理研究所月日在陕西蒲城县内府机场签署战略合作协议，推进在无人机领域的战略合作。合作领域为基于物流无人机为平台进行的物流无人机系统的研发设计、适航取证、生产制造、销售和运营。已于日完成首飞的，全长米、翼展米、高米、最大起飞重量吨，可谓国内外民用无人机领域个头最大的家伙，其货仓容积立方米，有效载荷达吨。最大飞行速度为公里时，续航时间长达小时、航程公里，实用升限可达米，即使在陆运交通不发达及多山的西部、高海拔地区，也可高效完成点对点的货运支线运输；此外，该型无人机在同级别的飞机中具有极高的起降能力，满载货物时米内即可完成起飞和着陆，能够在未铺筑的简易跑道甚至是土坡、草地上起降运行，解决了高海拔、山区等难以抵达地区的起降问题。氪
李开复评智能音箱：功能差还打价格战，应先做好产品李开复表示，之所以不投智能音箱领域，是因为今天我们看到的第一批智能音箱确实功能都很差。在功能慢慢做好的过程中，小米推出了元的产品，天猫推出元的，在还没有把产品做好就要开始抱大腿，打价格战，赔钱销售了。就像当初的千团大战，很多中国创业者急迫地想把一个东西滚动出来。所以还是要理性评估，这个市场的挑战性、重复性、技术性和他的电商系统，还有和京东的介入会带来什么变数，所以就避开了这个领域。新浪科技
四维图新推出了电动汽车智能出行解决方案“桩家”，从数据地图切入充电地图服务四维图新推出了电动汽车智能出行解决方案“桩家”，从数据地图切入充电地图服务，帮助用户快速找到充电服务站点并完成车辆充电，四维图新表示，“桩家”是采用了“云数据服务开放能力应用”组合的基础平台，目前，“桩家”已覆盖全国积累了万余个公共充电站和十五万余个可用充电桩信息，并且通过内容提供商合作与现场采集的方式，不断增加充电站可查数量。利用云数据服务，“桩家”可以为新能源车主查找到附近适合自己车型的充电站，并列出该充电站的详细信息以供用户参考，数据可精细到充电插口的占用状态及泊车位号码。
苹果 部件供应稳定，原深感摄像头明年无大更新郭明錤凯基证券知名分析师在周日发布最新投资者报告称，在年的新机型上，苹果很可能“不会重蹈”在 上遇到的供应和生产覆辙。郭明錤称，年的机型将按时上市，在第三季度末实现稳定供应。他表示，协助驱动 生物识别技术的原深感摄像头将不会进行“重大配置更新”，苹果将使用相同的点阵投射器和红外摄像头。
希捷发布全球首款视频人工智能监控硬盘“酷鹰人工智能” 希捷带来了全球首款人工智能视频监控硬盘“酷鹰人工智能” ，拥有空前的带宽和处理能力，支持管理全天候、数据密集型工作负载，可同时分析、记录来自多个高清摄像头的影像。随着网络录像机加入分析感应器，全球对视频监控硬件的需求正呈指数上升，估计视频监控硬件出货量将从年的万增长至年的亿，但希捷提出，只有在尤其是面部识别、违规行为分析等深度学习和机器学习应用飞速发展的情况下，这种增长才能实现。
投资事件
人工智能大数据公司「新译科技」完成万元  轮融资新译科技人工智能大数据公司获得了万人民币  轮融资。本轮融资中厦门市美亚梧桐投资管理有限公司，凯泰资本与博将资本合作投资，原天使轮投资机构清华力合继续跟进。新译科技天使轮融资于年月完成，截至目前  轮融资资金已全部到位。本轮融资引入的投资机构主要进行公司日后的资源整合和布局，资金主要用于市场拓展、高端人才引进、硬件资源的投入和研究院建设。氪
所问数据获百度风投领投万元轮融资所问数据对外宣布已获得万元轮融资，领投方为百度风投，跟投方为南天盈富泰克、首建投，安可资本担任独家财务顾问。本轮融资后，所问将通过百度风投的增值服务，建立与百度在技术上的合作。而此前，所问获得过九合创投数百万的天使轮融资，以及洪泰领投的千万级轮融资。“所问数据”定位企业级数据分析的预测引擎，通过人工智能技术给企业提供深度销售分析和销售预测。
易订货获得创新工场轮千万美元融资易订货是铱云科技旗舰产品，也是国内第一款移动客户订货系统。围绕品牌企业与下游客户的全渠道业务流程设计，以订单处理为核心，帮助企业快速构建渠道专属的营销互动平台。实现在商机管理、分销管控、商品促销、订单处理、库存采购、资金对账、支付物流、决策分析等业务环节的全程电子商务；实时数据决策，让生意更简单，近日，易订货获得创新工场轮千万美元融资，本轮融资资金将做两方面投入，一是加速研发具备搭建平台的能力，加大产品在大数据和方向的技术投入和应用落地，二是继续投入全国渠道分销布局，建设区域服务支持中心和市场营销中心，专门投资万元扶持家核心伙伴让他们持续盈利。
智能家居获得万人民币轮融资是一家智能生活和智能家居服务商，主打智能家居解决方案，每套智控家居组合内含个智慧中心、个环境感应器、个智能插座、个无线摄像头，据悉，智能家居获得万人民币轮融资，由华登国际领投，道合投资跟投。
兔小二获得千万级人民币战略投资兔小二是一家酒店运营服务平台，致力于提供酒店行业互联网运营服务，平台分为酒店管家和出行助手两大系统；酒店管家系统是一款为酒店主及管理人员提供酒店运营管理帮助的智慧系统，出行助手则为旅客提供旅行生活帮助，近日，兔小二获得千万级人民币战略投资，投资方为瑞丽洗涤。
复星宣布战略投资以色列人工智能创新债券投资平台复星集团宣布完成对以色列公司万美元战略投资，这也是复星在以色列领域的首个投资项目。该笔交易后，复星将成为的主要股东并可委派董事进董事会。
打印机供应商获得战略投资是一家供应一系列强大的打印机的供应商，最新款产品为 ，还提供了一些视频，讲诉产品的使用特性，近日，，获得战略投资，领投者是股权投资公司。日前宣布与中国万宝科技达成战略合作开拓中国市场。
获得万美元轮融资是旧金山自动认证初创公司，该公司推出的直接自动认证和移动身份验证标准，可以利用实时移动网络信号来创建安全身份验证。用户只需在自己的手机设备上输入信息，然后使用双重身份验证和生物识别信息，那么移动运营商就能判断出你的身份，据悉，获得万美元轮融资，投资方为 。
奇幻工房 获得万美元轮融资 成立于年，是一家儿童机器人公司，其机器人可以让孩子们通过程序用可视化编程的方式驱动 ，公司还设计相应的课程，近日，奇幻工房 获得万美元轮融资，投资方为、  、  、软银风投韩国、 、学而思、香港  、以及腾讯、创新工场和资本。
获得万美元轮融资是一款宠物类智能硬件，让用户可以通过手机远程和宠物玩耍，据悉，获得万美元轮融资，投资方为、 、 。

本文来源于 腾讯  加速器 微信公众号网址 一般情况下，为了获取函数之间的调用关系都是通过对源码进行静态分析得到。例如就是通过分析源码来获取函数调用关系链的，但是却存在一个缺点需要依赖于源码，而且在跨模块的调用关系的获取上存在缺陷。本文提出一种通过逆向二进制文件的方式，通过反汇编的指令获取函数之间的调用关系。
站在逆向二进制的角度观察函数的调用关系，可以将函数分为以下几种类型：
、普通函数的调用，分为两种一个是指令调用，另一个是跳转指令调用。
、函数指针的调用，指的是将函数作为参数进行传递，通过参数变量进行调用。
、类中虚函数的调用，通过虚表指针间接调用具体的子类函数。
先通过流程图描述核心思想，再一一详细介绍：

图
首先，来介绍一下普通函数调用的情况：
这里所谓的普通函数的调用，指的是可以直接通过函数的虚拟地址进行直接的调用。从语言的角度来看，这个函数可以是一个纯函数或者类成员非虚函数补充：对于宏，在编译时就已将其替换为其所代表的项，所以在逆向的角度而言，若要获取宏的调用关系还需要进一步的将替换者变为宏，这个。从文件的角度考虑这个函数可能存储在的代码区，导入表，导出表三个地方中。
对于普通函数而言，在汇编层面直接调用的使其所在的函数地址，所在的加载器会将这个调用的实际函数地址替换成对应的函数名称，如下图所示：

图
通过对逆向汇编的分析，代码中的函数调用在编译成二进制之后，逆向成汇编语言，从普通函数的角度观察，调用函数的指令有两类：一类是指令。另一类是跳转指令。如图所示：

图
汇编角度而言，普通函数的调用是最常用的一种形式，也最容易解析。
其次，介绍函数指针的具体情况：
函数指针一种使用形式就是回调函数把函数的指针地址作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。函数指针的主旨是：作为参数，不管是函数的参数，还是作为一个成员变量。如皮肤库中的消息传递：

从汇编的角度而言，参数的传递主要通过以下两个指令：指令。以函数作为参数变量进行传递的两种情况如图所示：

图
对于函数指针，我们只需要判断指令传递的地址是否是一个函数实际地址，若判断为真，就将其标明为一个函数指针的调用情况。
最后，介绍虚函数调用的具体情况：
虚函数基本概念的描述：作为面向对象最具特色的概念，对象的多态性需要通过虚表和虚表指针来完成，虚函数指针被定义在对象首地址的前个字节处，因此虚函数必须作为成员函数使用。由于非成员函数没有指针，因此无法获得虚函数表指针，进而无法获取虚表，也就无法访问虚函数。
在中，使用关键字声明函数为虚函数，当类中定义有虚函数时，编译器会将该类中所有虚函数的首地址保存在一张地址表中，这张表被称为虚函数地址表，简称虚表。同时，编译器还会在类中添加一个隐藏数据成员，称为虚表指针。该指针中保存着虚表的首地址，用于记录和查找虚函数。如图所示：包含虚函数的类的定义

图
  = 大小为字节数据，多出了字节数据，这字节数据用于保存虚表指针。在虚表指针所指向的函数指针数组中，保存了虚函数和的首地址。对于开发者而言，虚表和虚函数指针都是隐藏的，在常规的开发过程中感觉不到她们的存在。对象中的虚表和虚函数指针的关系如图所示：

图
虚表指针的初始化是通过编译器在构造函数内插入代码来完成的。在虚表指针初始化的过程中，对象执行了构造函数后，就得到了虚表指针，当其他代码访问这个对象的虚函数时，会根据对象的首地址，取出对应虚表元素。当函数被调用时，会间接访问虚表，得到对应的虚函数首地址，并执行调用。此种调用是一个间接调用的过程，需要多次寻址才可以完成。
这种通过虚表间接寻址访问的情况只有在使用对象的指针或者引用来调用虚函数的时候才会出现。当直接使用对象调用自身的虚函数时，没有必要查表访问。这是已经明确调用的是自身成员函数，根本没有构成多态性，查询虚表只会画蛇添足，降低程序执行效率。
在逆向静态分析中虚函数缺失父调用函数关系，那么为什么会缺失父函数呢？看图：

图
从图中我们可以知道子调用关系，却不知道父调用关系。那么为什么会产生这个问题呢？让我们一起看看一个有虚函数调用的函数的汇编实现：

图
从上图可以很明白的知道，为什么虚函数父调用的关系缺失了，因为在汇编中这其实是一个地址的调用，要建立寄存器与具体虚表的关系是很困难的或许本身就不可为。一个解决方案是对逆向伪码去获取虚函数名称数据流指令的分析，然后通过虚函数名称去补全父函数调用关系， 但是通过对管家不同模块使用逆向伪码的功能，发现在逆向虚函数的时候准确率只能达到多，并且对不同版本 的逆向虚函数伪码的功能进行的测试除了最新的未提供下载，发现准确率都很低。并且寻找了多个处理面向对象语言的插件效果也都不佳。在做了这么多年逆向虚函数的工作来看，这块工作耗时而且收效甚微。那么我们就退而求其次，做到现在可以确定做的事情：、对于普通的非虚函数变更可以精确到函数级别的调用关系链的影响。、对于虚函数当其发生了变更，因为影响不能精确到函数级别，但是可以做到类级别。类之间的调用关系可以通过构造函数去确定，因为构造函数不是虚函数，这个前提是肯定的。
那么对于类调用关系的获取在管家有大致两种情况需要处理：
第一种是没有经过封装的直接的类之间的调用包括模块内与模块间。另一种是类跨模块间的类调用关系的处理，用如下流程图来表述：

图
对于组件中数据的逆向处理因为比较复杂，这里不详细展开后面特别用一篇文章描述。
对于虚函数的处理，因为在静态逆向分析的情况下不能获取实际函数的调用，在万不得已的情况下，只能用类调用关系类弥补这方面数据的缺失。对于虚函数展示类调用关系，也可满足我们的业务需求。
下面是二进制变更调用链与的对比图：

图
上述整体描述了如何逆向分析获取函数调用关系链的方方面面，若是有讲的有误的地方，请大家指点改进，或者对虚函数的处理有更好的方法，要不吝赐教哦。导读：年月日“ 开放数据中心峰会”在北京国际会议中心召开，峰会由工信部、发改委指导，百度、腾讯、阿里巴巴、中国电信、中国移动、中国信息通信研究院和英特尔等均出席了此次论坛，旨在打造中国的数据中心开放平台，推动互联网产业发展和基础设施标准化、产业化进程。与会观众超过人。
会议公布了在数据中心领域的最新研究成果并分享了相关的热点话题。以下内容是来自腾讯技术工程事业群网络平台部在现场的主题分享。

本篇文章共字，读完大约需分钟
腾讯服务器实验室工作经验分享

演讲嘉宾：网络平台部 
本次腾讯服务器实验室分享的三个要点是建设、管理运营、成就。
首先说建设。肯定很多人会好奇我们为什么要建这么一个实验室？
功能一是承载基准测试。简单来说每种服务器引入，腾讯团队先摸个底，再进行投产。
功能二是质量保障。例如近期的一个项目。我们作为终端用户，在早期参与到英特尔新硬件平台研发当中。这个大项目中，我们把质量保障方面的测试项目引进到腾讯实验室里来。
以上两个功能在现有实验室已经满足的情况下，我们扩建实验室的目的实际上就是为了满足现在飞速发展的各种服务器技术和云平台技术的认证。
实验室怎么建？有三个“必须”原则。
一个是真，它必须是非常真实地模拟现网环境。真实的实验室环境是对现网高运营要求的非常有效的保障手段。
二是简，在保证真实的环境情况下我们必须要非常好的控制整个实验室的成本。
最后是全，我们必须尽可能把业界所有先进的技术都拿到实验室来认证，才能对行业有比较全面的了解；如果不全的话，实验室作为技术的前瞻预研机构，就会失去了领先性。

但对中小企业来说，可能接下来要讲的管理运营章节才是比较有价值的东西。
我为什么这么说？因为管理一个实验室就是在，管人，管物，管事，这三个管好了就能把一个很简单的数据中心管起来，这些经验对于在运营自己数据中心的企业会多少有帮助。管理这三个维度我们用了一套系统。这套系统开发者就在隔壁服务器分会场，我们腾讯的服务器管理平台组长王镇。他的演讲是关于现网海量运营系统的开发经验。
这套系统大致有三个部分。线上的资产管理系统、工单系统和测试平台。重点说一下测试平台。这一个我们正在做的项目，通过把自动化的测试用例集合到测试平台里，解决了测试效率的问题。因为整个服务器实验室都是联网的系统，如果有测试平台的话就可以远程进行工具下发并且进行数据回收，自动化流程可以保证用少量的人力来完成这个事情。

最后说一下，腾讯服务器实验室有什么成就。
在质量保障方面，我们有一个工厂预测试项目。所有服务器在服务器厂家出厂之前必须跑上腾讯的工厂预测试的程序，程序开发就是在实验室中进行的；最近英特尔新平台的整机质量认证，实验室部署了三个机柜的新平台机器进行长期压力测试；此外还有一些自研服务器设备也会在实验室里完成测试认证。关于技术孵化的成就，除了高性能虚拟化网卡应用之外，还有液冷服务器，新型存储介质应用等在业界领先的项目。在实验室完成了并且已经商用的案例，包括以太云主机、云存储池化、海量数据迁移装置等等。

类比云平台，在有限的计算网络存储资源里面要创造更多的服务，就是腾讯硬件实验室最大的价值。
海量服务器监管控最佳实践

演讲嘉宾：网络平台部 王镇
管控平台建设有那么长时间，总结了不少经验和系统设计理念，最想跟大家分享的是：管控平台要提供原子化的底层能力和统一开放的。所有接口都按照“相互独立，完全穷尽”的设计理念进行设计开发，希望能像微信的开放接口体系一样，定义出基础架构的原子服务接口。

在管控系统中，配置系统必须先行设计，数据在底层采集模块收集后，经过审计进入。功能模块包括基础管控引擎、集成监控和集成告警，通过统一的对外服务。除海量的业务系统外，针对云业务的个性化需求，开辟了单独的接口。
随着自动化程度的不断提高，数据的积累也越来越丰富，大数据智能化的时代也随之来临。从数据的生命周期来看，把数据分为数据生产、数据接入、数据分析和数据应用这四类。业务场景包括：利用率分析、部件审计、备件管理、运营指标、健康度管理等等。

以上是数据平台的模块示意图。数据采集上来之后集中到统一的消息队列，经过数据格式化和清洗，用于实时数据处理模块，数据批量处理模块和数据的出库和入库。数据结果有两个输出，第一个是数据上报的环节，还有一块是内部的应用，包括硬盘故障预测，批次问题分析，温度和能耗管理等。
讲到机器学习和，分享三个应用：故障告警原因分析。把非明确的告警原因分析出来，翻译成业务看得懂的工单说明，让业务对我们机器有更多的信心。硬件故障预测，在全网用得量最多的一款硬盘上，提前天预测的准确率达到，覆盖率达到以上。健康度管理，通过机器学习，把服务器分不同的维度来对其状态进行等级的划分。
在管控系统建设过程中，遇到不少数据无法采集和不全等问题，我们也跟各个服务器厂商一起推动了多个硬件和标准的落地，这个事情不是一蹴而就的，需要在座各位和业界上下游厂商共同努力。如果做成了，绝对是一件功在当代、利在千秋的大事。
如何共建服务器的新生态

演讲嘉宾：网络平台部 王伟
回顾历史，传统云计算的兴起其实是伴随着行业的衰落在同步进行的，没有谁前谁后、谁因谁果，是同步的。从年，亚马逊发布公有云业务，国内也有很多公有云产品相继进入市场，到了年已经明显看到发货量下滑，大量的企业对的诉求开始向云端迁移。现在我们给大家分享另外一个数据，年到年智能手机发货量将会在年出现新的拐点。可是，我们发现无论是的发展，还是个人对于生活、办公、家庭、设备管理的诉求，都意味着手机端的计算量还在一直增长。但是设备不可能无限增加，每个设备的计算量受限于智能终端的一些因素，比如它的电池，因此终端的计算量是有瓶颈的。再加上终端发货量下降，未来个人手机终端的计算量何去何从？ 

可以肯定的说是往云端迁移，毋庸置疑，往云端怎么走？可以走传统的的模式，一些计算量可以向传统的服务器端迁移，但是会遇到了一些问题。智能手机，无论是苹果、安卓，都是基于的处理器架构，上面运行的是或是安卓，让它的计算量向云端迁移会遇到什么问题呢？

我们熟知，现在传统的服务器都是的体系架构，上面运行的也好，也好，跟终端的软硬件环境是不同的。行业有些先行者尝试在上运行安卓的模拟器，再去跑智能终端的这些应用，遇到了性能问题。也有些尝试把软件重新编译、重新开发、重新调试，发现工作量更是不可接受的。

这个事情何去何从，我们在探索一个新的方向，使用服务器，运行安卓，再运行虚拟机，这样智能终端上的软件应用可以非常简单的向云端迁移。目前我们已经有了高性能的服务器，缺少的是在服务器上运行的原生安卓。腾讯云也在这个领域进行了很多尝试，并在腾讯内部业务、云客户做了一些探索。目前腾讯云已经推出了一款的服务器，为企业或个人的智能终端用户提供云计算能力，云端智能手机。现在生态还在建立中，希望行业中的合作伙伴在这方面共同投入。
腾讯在领域的探索和实践

演讲嘉宾：网络平台部 耿竞一
说到，它并不是指某一种具体的技术，而是一种方法，一种追求更高效、更灵活、更开放的解决在光层传输问题的思路。随着互联网应用和云计算时代的持续爆发，数据业务对数据中心间的互联带宽的诉求在极速增大。以腾讯为例，目前单一城市的城域网带宽总量已经达到了，且年增长率超过。这意味着城域网带宽建设成本在整个数据中心基础网络交付成本中的占比越来越高；同时，规模越来越庞大、结构越来越复杂的网络，对网络运营团队带来了很多困难与挑战。
所以我们需要一个成本更低、灵活度、开放度更高，可运维、可管理能力更强的传输方案，这就是今天要讨论的。

相较于传统的传输网络，网络架构中，将传输设备的电层处理部分直接转移到交换机侧处理，以太网设备通过相干光技术直接发出不同波长的彩光，经由中间的传统传输设备的光层，或者是未来的开放式线路系统，完成光层传输。这样带来几个好处，第一，整个网络结构变得更加简单，为后续基于思想的统一运营提供了可能。第二，由于减少了一次电层处理，所以端到端的转化时间有所降低。第三点是降低了成本。

交换机直出彩光方案目前有几种选择。第一种， 方案，将芯片集成在核心交换机的业务板卡上，所以该方案无法实现跨厂商交换机的互通。第二种是 方案，将芯片直接集成在光模块上，这样就解决了跨厂商交换机互通的问题。另外它的集成度更高，功耗更低，但板卡端口密度较低。第三种方案是 ，该方案可大幅提升单板卡容量，但其数据传输距离只能做到公里，且单光纤最大容量只有。所以综合几种方案的分析，我们现阶段选择的是第二种方案。并且交换机供应厂商为我们研发了×  的核心交换机板卡。
腾讯针对基于 的交换机直出彩光方案制定了相关规范，并在现网中部署了实验局测试环境。期望随着产业链的发展，后续会有性价比更高、开放性更强的方案可以选择，让我们拭目以待。近日，腾讯云提前完成了全国范围的资质测评，顺利获得工信部颁发的业务全国范围的经营许可证。
年月份，工信部发布《关于清理规范互联网网络接入服务市场的通知》，要求提供服务的云计算企业，必须在年月日前完成业务经营许可证的申请，否则将停止业务的经营。在工信部发布《通知》之前，腾讯云团队就已经启动了业务经营许可证的申请，并于月份获取了该资质。此次在短时间内顺利获取工信部业务的全国资质，是对腾讯云在领域多年深耕的肯定。
腾讯云服务源自于腾讯十几年来的技术实践沉淀和服务经验积累，目前带宽储备已增加到，全球节点，覆盖个国家；同时腾讯云国内节点数已经超过，海外布局加速节点，覆盖东南亚、北美、欧洲等三十多个国家和地区。
作为国内带宽储备最高的厂商之一，腾讯云应对突发的能力历经了多次高标准检验。今年月，王者荣耀版本更新，带来了某手机应用市场超过的带宽突发；新赛季直播提供超过万在线用户的高清直播体验；在刚刚结束的 全球总决赛半决赛中，轻松应对了超过的直播带宽突发。

随着移动互联网和固网网络建设的不断完善，丰富的媒体和资讯对传播载体的要求愈加严苛，而满足这些严格的要求，提供最优质的加速体验，做成功厂商的“基石”是腾讯云一直以来的目标。腾讯云正不断研发创新，用更纯熟的技术、更优质的服务来更好的服务客户，引领行业快速发展。作者：

背景
 开源至今已两个月有余，我们在不断迭代功能、完善文档的同时，也与来自世界各地的开发者进行交流，帮助他们更快地了解、掌握  。这其中，也不乏使用  的开发者。他们正准备将项目的数据库模块改为  。
对于一个已经上线运行的项目，数据库这类基础组件与业务的耦合通常较多，迁移有一定工作量的。因此，开发者通常会做很多预研，以确定是否进行迁移。
 在  的  上提供了专门的教程，帮助使用的开发者进行迁移。同时，也希望通过本文全面地介绍  和  在使用方式、性能等方面的差异，以及迁移中可能遇到的问题，帮助开发者决定是否进行迁移。
平滑迁移
文件格式
由于  和  都基于  ，因此两者在数据库的文件格式上一致。用  创建、操作的数据库，可以直接通过  打开、使用。因此开发者无需做额外的数据迁移。
表结构
 提供了  的功能，将类的属性绑定到数据库表的字段。在日常实践中，类的属性名和表的字段名通常不一致。因此， 提供了 __   宏，用于映射属性名。
对于

表：   _  _ 
类：


这里表字段都加了_的前缀，并且使用了不一样的字段名。通过  的 ，可以映射为

通过 __ 宏映射后， 同样能兼容  的表结构，开发者也不需要做数据迁移。
因此，开发者可以平滑地从  迁移到  。
性能比较
对于已经上线运行的项目，解决性能瓶颈会是一个常见的迁移理由。相较于  直白的封装，  上到  层的  ，下到  源码，都做了各类性能优化。
为了验证优化效果，我们提供了  ，并将性能测试结果和测试代码上传到了  。同时，  中也加入了  的测试代码，用于横向比较。
以下性能测试均为  模式、缓存大小字节、页大小  ：

 _=
 _=
 _=

测试数据均为含有一个整型和一个二进制数据的表：       ，二进制数据长度为  字节。
读操作性能测试

写操作性能测试

批量写操作性能测试 事务

对于读操作， 速度很快，因此封装层的消耗占比较多。  只做了最简单的封装， 而  还包括  、  等操作，因此执行的指令会比  多，从而导致  在读操作上性能劣于   。
而写操作通常是性能的瓶颈，我们重点对其做了许多针对性的优化，使得  写操作优于  、批量写操作优于   。
多线程读并发性能测试

多线程读写并发性能测试

多线程写并发性能测试

 多线程并发的优势，将读操作的性能劣势拉了回来，使得在读操作  的性能与  基本持平 ，而 多线程读写性能则优于   。
在多线程写操作的测试中，  直接返回错误 _，无法完成。
初始化性能测试

 连接的初始化速度会随着数据库内表的数量增加而逐渐上升，  也针对这个场景做了优化。相较于没有优化的  ，  的初始化速度有  的性能优势。
易用性比较
与已经上线运行项目不同，新项目更关注开发的效率。此时数据库的易用和便捷更重要。对于等价的功能，  所需的代码量往往会比  少很多。而更少的代码量通常意味着更快的开发效率和更少的错误。
基础操作
 是现代客户端数据库比较普遍的功能。  、  都支持  ，  也不例外。
 因其直白的封装，没有提供该功能。但在设计数据库表时，开发者通常会对数据进行建模。因此开发者只需将已有建模用  的  表达出来即可。
对于在  的一组定义：

表：             
索引：  _  


类：


需要对其建模，可以定义为

其中：

_ 用于定义进行绑定的类
_ 和 _  用于声明和定义字段。
___  用于定义主键且自增。
_   用于定义索引。

虽然  多了一步  的操作，但这是一劳永逸的，并且会给我们后续的使用带来很大的便利。经过  的类，大部分操作都只需要一行代码即可完成。   ，直接看代码对比：
查询操作


插入操作


可以看到，

对于查询操作，  需要进行很多拼装组合，而  只需要一行代码就能完成。
对于插入操作，  也只用了一行代码，但其需要将  逐个拆分为最基本的类型。而  所需要关注的只有  和表名两个参数。

数据库升级
 的数据库升级一直是一个比较繁杂的问题。
通常的做法是，开发者自行定义一个版本号，并保存下来。数据库创建时每次检查版本号，若版本号较低，则对其字段进行升级，并更新版本号。但在多个版本的增增减减之后，版本的处理逻辑会越来越复杂，甚至可能弄错表内哪些字段是新增的，哪些是废弃的。
 将数据库升级和  结合起来，对于需要增删改的字段，只需直接在  层面修改，并再次调用  接口即可自动升级。以下是一个数据库升级的例子。


删除字段
如例子中的  字段，删除字段只需直接将  中的定义删除即可。
增加字段
如例子中的  字段，增加字段只需直接添加  的定义即可。
修改字段类型
如例子中的  字段，字段类型可以直接修改，但需要确保新类型与旧类型兼容。
修改字段名称
如例子中的  ，字段名称可以通过 __   重新映射。
增加约束
如例子中的 _  ，新的约束只需直接在  中添加即可。
增加索引
如例子中的  ``  ，新的索引只需直接在  添加。
多线程操作
 与  都支持多线程操作。在  内，当开发者需要进行多线程操作时，需要使用另外一个类 来进行操作。而  基础的  接口都支持多线程，因此开发者不需要额外关心线程安全的问题。同样的，  多线程使用的代码量也比  少得多。


功能完整性比较
加密
 基于  提供了加密功能

统计
 内提供统计的接口注册获取数据库操作的  、性能、错误等，开发者可以将这些信息打印到日志或上报到后台，以调试或统计

修复
 提供了数据库修复工具，以应对数据库损坏无法使用的极端情况。

总结
与  对比，  使得开发者可以写更少的代码，但能获得更高的性能。开发者不需要额外关注数据库升级和多线程操作的问题。同时，  还提供了加密、统计、修复等功能。因此，对于新项目，我们推荐使用  ，以获得更好的性能和开发效率。对于已经上线、稳定运行的项目，如果遇到性能瓶颈，或者对加密、统计、修复等功能有需求，我们建议参考  上的文档进行迁移。后续我们还将加入更多的功能，欢迎来  关注我们。

本文来源于： 微信公众号导语 上篇说了，这篇开始讲下库，如果说是大而全，那就是小而美

简介
纯实现，不支持降级轮询，适用移动端开发
简单易懂，没有限制，可以用原生的
心跳检测，断线重连，多机多进程自由定制
 

说明：
因为没有降级使用轮询，也就没有一个连接由多次 组成，所以多机多进程很好实现，跟 一样
 不能独立存在，必须绑在 上，因为建立连接依赖的请求，如果你没有手动绑定，库里会自动创建一个 
应用
背景：
去年微信小程序出来的时候，提供了应用的，但是 端仍需要用户自己去搭建，门槛还是比较高的，鉴于此，腾讯云提供了一个打包方案，封装了技术细节包括，用户可以直接使用简单友好的开发自己的小程序，这个打包方案里的通道服务即由我负责开发实现。
选型：
因为小程序只在微信里打开，都是支持的，无需降级使用轮询，所以我放弃了繁琐的，选择
架构图：

说明：
因为是多机多进程实现，每个进程都会监听一个私有端口，上图中的，是为了实现广播功能，后面说明。
用户先调提供的拉取带唯一作为信道的 ，再通过该与建立连接，此时会在里存储该连接所在 以及监听的私有端口，并通过业务服务器提供的转发消息到业务服务器
如果要消息，业务服务器调用提供的消息发送，带上消息内容和要的信道，收到 请求，从中查询信道所在 和私有，将消息转发过去，  再调用对应 连接将消息到
心跳检测：
每隔发送心跳包给，即时发送响应包给，连续没有收到响应，则认为退出了，断开连接
连续没有收到心跳包，认为连接失效，发起重连
广播：
根据决定广播的信道
收到广播的根据通过私有端口转发广播内容到对应机器的进程
进程调用连接句柄发送广播内容
配置：
作为统一接入层，在转发请求时默认没有转发和 ，这样端接收到的就不是请求了，所以我们必须在配置时手动加上这两个，如下图：月日，麦当劳日本在欢乐餐中附送当红  手游 é 玩具，当天麦当劳日本股价飙升，触发熔断。 é 所引发的蝴蝶效应愈发明显，那么在游戏市场，又有哪些  成功借到了 é 的东风呢？
手游市场红海一片，面对主机市场的萎缩，老牌游戏厂商任天堂祭出了金字  é 又称《口袋妖怪》《宠物小精灵》，联手   曾开发话题  作品《  》，推出了第一款手游：《 é  》后简称《  》。  技术和抓取小精灵的主题完美结合，加上年  的影响力，  在美国推出首日就一举登上了应用商店的榜首，一时间风头无两，大量用户涌入以至于发行商不得不锁定特定区域的  ，以保证玩家体验。据美国知名调研网站“调查猴子”  的最新报告，《  》已成为美国史上用户最多的手机游戏。《  》在美国推出首日就一举登上苹果应用商店榜首，日均活跃用户数超过了今年《蛇蛇大作战》和《皇室战争》先后创下的纪录，峰值高达万，比《皇室战争》的峰值万翻了近四倍。

图片来自：   
中国大陆虽不在《  》的首发范围之列，也没有在正版渠道引入过 é 系列的游戏，但人们被朋友圈里的美澳朋友刷了两天屏，正在一脸懵逼时，月号到号这两天，一条新闻彻底引爆了这个话题：“ é 玩家抓小精灵坠桥身亡，捉妖师等职业诞生”。虽然这篇报道最终被辟谣是假新闻，但离奇的内容已成功吸引了年轻人的好奇心，恨不得马上一探究竟。

但当他们兴奋的拿出手机进行搜索时，却发现《  》在国内苹果应用商店里没有上架。至此，国内的玩家则分成了两派，一部分人通过自有渠道玩上了《  》，还有一部分人则投身于另一款游戏，因为在“ é  ”的搜索结果里，它排名第一。本文将主要针对苹果应用商店展开分析，部分安卓应用商店已经可以通过下载  ，并加上  软件来体验游戏了。
相似产品涌现——是无心插柳，还是有意为之
这另一款游戏叫《城市精灵  》，不只是名称接近，游戏玩法中也有利用    定位抓取精灵的元素，让人顿生“山寨”、“跟风”之感。但据这款游戏的发行商探娱互动说，这款游戏从年就开始制作，今年月就上线苹果应用商店，并非《  》热度爆发以后粗制滥造的跟风作品。可是事情真的是这样吗？
大部分玩家可能都不知道，《城市精灵  》的前身叫《萌宠联盟》，年就开始在安卓应用商店进行内测，今年月不删档内测之前，不知道是不是因为当时  发布测试相关消息带来的灵感，或是受到任天堂公布国内《精灵宝可梦：太阳月亮》发行计划的影响，总之当这款游戏正式上线苹果应用商店时，名字已摇身一变，改成了《城市精灵  》，并在月日将下载方式由付费改成了免费。讲道理，《城市精灵  》这个名字本身和《  》除了包含  以外，还是有较大差别的，能在搜索 é  的结果中排到第一，应该是做了不小的  优化。而心急如焚的玩家本身受到锁区和账号限制，没有玩过原作，下载时也不会细看，加上玩法本来就有一定的借鉴，很多人不小心便玩起了“李鬼”。
虽说是“无心插柳柳成荫”，但涌入的玩家数量非常惊人，达到了每日新增万，而与此同时，《城市精灵  》在苹果应用商店榜单上的排名也出现了爆发式增长，于月日荣登免费榜冠军。截自今日，虽然  的热度有所下降，但它仍然排在免费榜前五之内。要知道在  出来之前，即使改了名，免了费，它也不过是一个徘徊在免费榜名开外、名不见经传的游戏。

图片来源：腾讯  舆情监控
但榜单排名一路走高的同时，《城市精灵  》却没有和《  》一样，收获良好的口碑。当人们提起  提到的都是“纯粹的快乐”“让宅走出家”“童年回忆成真”这些积极的评价时，大量负面评论却出现在《城市精灵  》的玩家反馈中。

图片来源：腾讯  舆情监控
通过腾讯舆情监控的数据，其最近周的口碑指数在左右，与舆情里游戏平均口碑指数还是有一定差距的。而且从每天的评星分布上，也能清晰的看出好评很可能是发行商雇水军刷出来的。当一星评分增加时，就会有更多的五星出现，评论内容单一空洞，不像真实玩家的评价。


图片来源：腾讯  舆情监控
在负面评论中，抄袭赫然位于第三，可见上了当去发牢骚的玩家着实不少。如果我们把抄袭的其他说法，比如“山寨”“模仿”等都算上，会发现数量更多。最近的半个月内，光提到“山寨”的评论在各大渠道就有多条。

除了抄袭问题，游戏本身的质量也影响了玩家的评价，负面词语里面排第一的就是“闪退”，如果搜索一下其他手游常见问题的关键词，会发现玩家也遭遇了其他异常，而且毫不犹豫的给出了低评星。可见品质上的瑕疵也会极大的影响游戏口碑。

图片来源：腾讯舆情监控
从口碑趋势中也可以看出，虽然在月日至月日其口碑趋势在上升，但很快就逐步下降，无法维持。
不可否认，《  》效应让《城市精灵  》有了一个开门红，但它的未来会如何，取决于本身的游戏性和质量，只有真正让玩家感到有趣，才能把他们留住，否则也可能就是一个火一阵子的游戏而已。
回过头来看《城市精灵  》能有这样的成绩也与其改名有着密切关系，通过名字上的  优化确实给游戏本身带来了巨量的玩家，可以说这个机遇是把握的非常好的，我们也期待这款游戏能更符合中国玩家的需求，不断进行优化。
“翻墙”  爆红——你有张良计，我有过墙梯
《  》的开发团队来自  ，故游戏使用了  账号登录。千辛万苦通过自有渠道安装好《  》的国内玩家，还得跨过“长城”才能开始游戏。懂的人都知道，翻墙的方法千千万，但只一个应用抓住了这个时机，那就是  。 
 在月日时，还是一个位于总免费榜多名的一个普普通通的小工具，但随着《  》的上线，它的名次也被逐渐带了起来，而在月日， 在新版本中做了一个小改变，直接把自己带到了榜单位置的最高点：免费榜名。
这个改变就是在自己的副标题里加入了最近的热门话题《  》的元素，它之前的名字叫做《    又称  网络加速器，是无限流量的免费  》，修改后的名字则是《    体验 é  的必备神器，是无限流量的免费别名  网络加速》。

图片来源：腾讯  舆情监控
在进行这样简单的优化后，搜索 é  时，  在搜索结果中位于第二，仅次于《城市精灵   》。通过腾讯  舆情榜单功能可以看出  从月日起在各榜单上排名迅速上升，而其在商务畅销榜保持榜首位置也有一段时间了。虽然在达到顶点后，  的名次略有下降，但这个曲线和《  》的热度降低完全吻合。时至今日，  的榜单排名又掉到了左右，但比起月日的多名，还是高出不少。

图片来自：百度指数
借《  》的东风到底有多大的影响呢？参考一下另一款  软件便知。  快车在月日时位于免费榜的位，比  还高一些。和  一样，这款产品也受到了《  》的影响，在热潮来袭时排名迅速拔高，一样在月日达到了最高点免费榜名。

但由于没有进行  优化，不了解  产品的  玩家无法把游戏和  快车进行关联，很多后来者都在搜索结果里直接选择了  ，   快车的名次迅速下降，不到天，它已经落到了多名，不但被  抛在身后，甚至守不住《  》发布前的位置，不由得引人深思。
时刻关注市场舆情——做一只飞得好的“猪“
通过分析《城市精灵  》和  ，我们可以看出借势的力量，也不难理解为什么那么多产品都在上线前进行  优化了。敏锐观察市场，了解行业热点，及时调整策略，多命中一个关键词，可能就能增加成倍的曝光，省下几百万的宣传费。
但是，用户下载产品只是开始，真的能留住用户还是需要过硬的品质。如果惊人的流量后接踵而至的是排山倒海的差评，那再好的开局也逃不掉以失败告终的命运。
本文由腾讯  授权发布，如需转载请联系腾讯  获得授权。作者：

怎么复现这个问题

、首先随意的滑两次，每次滑长一些，不用滑重碎屏就不好了
、再点击一次，之后立刻停住 
  你肯定在我说停住之后再点了一下，你觉得你并没有点到
反复试几次仔细发现，原来是要点两次！
为什么会这样
 发出  的嚎叫可以用下面代码归纳
                                                                      
      {                                               
         打酱油                                                                
    }                                                                           
      {                                                
         =                                                            
         =                                                            
    }                                                                           
      {                                                 
                {                                                                                                                
                                                                          
                                                   
        }                                                                           
         =  =                                                                                                                               
    }                                                                           
      {                                                 
         打酱油                                                                   
    }

  事件
长距离的滑动：    仅一次  
短距离：     一次  
事情发展到了这里，去下载最新的发现也只在里做了这件重要的事情
 =  = 

哎
看破红尘，上面的都不重要
  长距离的滑动只发生一次是不是让充满爱的瞬间变得忧伤了 
哈，其实只需时
   仅一次  
就能变成
    多次   
 也不再是了

原文链接：


相关推荐【腾讯】不会做分析？套路走起移动端异常捕获手游兼容性测试做数据科学开发，目前最流行的语言之一是 ，这主要得益于其提供 、等强大的软件包，以及  这样便捷的开发环境。
本文将介绍如何在一台云服务器上配置   环境，从此只要有浏览器和网络，就是可以随时随地进行数据科学开发工作，不用担心家庭环境与办公环境多次配置的问题。

前提条件
如果想跟随本教程一起完成环境搭建工作，需要拥有一台云服务器，笔者使用的是腾讯云提供的 ，操作系统为  。如果不满足该条件，可以考虑通过笔者的推荐链接购买。
如果你打算长期使用该服务器，可以参考这篇文章：如何正确配置   云服务器？
购买服务器并完成配置之后，即可通过如下命令登录：
 
安装依赖
 是使用  编写的一个软件包。而且，我们希望在  中使用   和  等多个版本，因此先安装   和  。  默认安装了  
   
    
配置国内  源
后续使用  安装第三方库时，由于受国内网络限制，速度会比较慢。我们首先将  的源修改为国内源，这里使用的是中国科学技术大学提供的源。
编辑  ，在最上方加入如下内容：

 = 
 = 
配置好之后，即可享受风一般的安装速度。
虚拟环境
下面，为  创建一个独立的虚拟环境，与系统自带的  隔离开来。为此，先安装  库：
    
由于我们目前是以  用户，可能要以  执行命令，避免  安装时出现权限问题。
然后，创建一个专门的虚拟环境，并直接激活：
   
 
在创建虚拟环境时，指定的  版本为 ，方便后续的操作。
安装 
 的安装其实很简单，只需要执行一行命令即可：
    
由于会安装其他相关的依赖库，这一步所需的时间可能较长。
配置 
安装好  之后，我们需要对其进行简单的配置，比如设置访问密码，默认不自动打开浏览器等。 默认会使用  配置文件，我们在  目录下新建一个  文件作为自定义配置文件。
  
创建密码
为了方便，我们选择  作为访问密码。
需要在命令行依次执行如下命令，结束之后会得到一个密码的  值，后续要填写在配置文件中。
=      
  = {}

其他设置
此外，为了能够直接通过浏览器打开  地址，访问  ，我们还要做如下设置：
 = 
_ = 
 = 
 = {}  {} 替换为实际的  值
将上面两处设置，写入  文件，然后执行如下命令即可：
   

新建  系统服务
为了能够长时间访问  ，避免每次都需登陆服务器手动执行命令，我们需要让该命令一直在后台自动运行，最好是支持系统重启时自动启动。因此，我们可以将  变成一个系统服务。
创建  文件，写入如下内容：
   
   

 
 

 =
 
    
上面定义了该服务在  为 、、、 时启动，而在非这几个  时停止该服务。

运行级别：系统停机状态，系统默认运行级别不能设为，否则不能正常启动运行级别：单用户工作状态，权限，用于系统维护，禁止远程登陆运行级别：多用户状态没有运行级别：完全的多用户状态有，登陆后进入控制台命令行模式运行级别：系统未使用，保留运行级别：控制台，登陆后进入图形模式运行级别：系统正常关闭并重启，默认运行级别不能设为，否则不能正常启动

配置好了  文件之后，就能够通过如下命令启动、停止和重启   了：
    启动 
    停止重启 
    查看  的状态
这样，每次系统启动或者出错重启时，都会启动  。
配置  并创建系统服务
下一步，我们设置  作为  的反向代理服务器。首先，安装 ，并修改 设置：
   
  
修改其中的   部分，并注释掉某些行，具体见下面的示例：
 {
          _
          _ =

         
          

             
        _ 

          {
                        
                         
                 _   =
                _ 
                       
                  
        }
}
这一步需要注释掉 _ 一行，并新增 _ ，将对  的访问请求转发至该地址 。
保存并退出文件，然后重启  服务即可。
   
之后，再修改  文件：

 =   表示只接受来自本机的请求

并重启  服务：
  
现在我们访问云服务器的  地址时，就会进入   的登陆页面。

制作系统镜像
虽然说上面的整个过程并不太复杂，一步一步跟着教程做的话可能十分钟左右就可以搞定了。但是如果希望以后也能够快速复制同样的系统，将整个过程编写为一个脚本来自动安装、配置时比较好的选择。不过，最终安装、配置的时间还是会有的。
推荐一种更加快速的方法，即使用腾讯云等云服务商提供的制作镜像功能，将配置好的系统直接打包，以后可以直接使用镜像，只要分钟，就可以启动   服务器了。

相关推荐：

利用搭建数据科学博客
人人都可以做深度学习应用：入门篇上晚间的秦淮河畔。元宵灯会人流攒动，暗涌丛生。人多的地方就容易出事儿，在你看不到的地方，南京公安局和企鹅居然偷偷合体了。
其实，这是腾讯和南京市公安局的一项合作：利用了互联网高科技手段，结合了南京本地历史大数据与腾讯地图的大数据。通过腾讯地图的热力图，保障秦淮灯会的安保勤务。
这是怎么办到的？
一、如何保证秦淮灯会无？
年月日，秦淮河畔元宵灯会，腾讯地图热力图产品被南京市公安局应用于元宵节秦淮灯会安保勤务。

上图为年月日晚夫子庙灯会现场，十里秦淮灯火璀璨

腾讯公司将南京市历史数据与大数据平台结合，建立多维度数据模型，推导出南京本地密集区域内大流量人员行为特征，从而估算出勤务区域的人流区间。

和南京公安局勤务指挥平台完美合体，为现场调度、快速响应、管制措施调配提供决策依据。
 
腾讯大数据平台根据南京市公安局提供的大数据，建立模型后对现场人员流量提供不同时段的估算值。经过校验，估算值与其他计数系统提供的流量值保持高度一致。 
腾讯位置大数据服务–热力图等相关产品自年正式推出以来，腾讯互联网警务团队会同地图平台部，同各地市公安局紧密合作，热力图等相关产品多次应用与国内重点城市大型安保活动。
年月日腾讯公司与南京市公安局签署战略合作协议。秦淮灯会互联网警务安保勤务专项即为本次战略合作协议的落地项目。
二、还不知道区域热力图？
通过不同颜色来呈现地区人口密度，选择地区，时间，日期，粒度就可以清晰了解地区人口的流动，还可以用于突发事件的人口分析。
可以直观清楚地看到页面上每一个区域的访人口密度，流动趋势。
红色代表人口密集，蓝色代表人口稀少，通过颜色的过度可以清晰看出来哪些区域哪些时间吸引了大多人。这对人口分析非常有用。

独特的“框统计”，能够框出任意区域的详情；粒度则是时间值，粒度越小，时间统计的间隔就越短。

可以自主选择时间区域日期粒度来随时查看各个区域任何时间的人口流动
 
三、腾讯位置大数据的正确打开方式
依托腾讯系大量产品数据，采用精准高效算法，实时获取精准位置数据信息。
 
掌控海量历史数据，预警突发公共事件有备无患。

 监测顾客人流量高峰，发现人流汇集潜力地段，做最有效率的决策。

 了解时下热门去处，避开拥堵时段景区，让你的旅行游刃有余。

 国庆假期出行大数据分析之国内热门景区逗留时间排行与大家的出发时间。
 
腾讯位置大数据——有非常大的想象空间，它可以掌握过去的数据，为现在做决定，预测判断未来的趋势。作者：樊林

导读
对于的开发以及测试人员，对命令一定会很熟悉，工具可谓测试的入门神器，安装、卸载、抓、截图等等一应俱全。很多自动化以及性能工具都一定程度上要依赖工具。
刚开始接触时，一直希望有一套类似工具的东西，结果都被告知要用、类的图形化界面工具。后来经过研究，要在上实现一套类工具理论上是没有问题，有很多开源库可以使用，所以就做了一套出来目前适用于平台，作为的测试的基础工具，主要实现了两个功能。
、让用户可以使用对手机进行基础的操作，就如同使用操作手机；
、封装好了一键抓取网络包生成文件以及的方式，提高相应的效率。 
完整工具下载地址仅供交流学习： 。
原理
是如何连接手机的？
第一步：首先通过技术，和手机建立连接。是一种可以通过管道也就是一个端口建立多路复用连接的系统。这是一个类系统，通过这种系统，主机的端口号可以和手机中的特定端口号建立连接并通信。
第二步：连接手机的服务，对应的端口号为，然后通过和服务传输数据，实现相应的功能。这个服务通常只能通过端口建立相应的连接也就是第一步说的系统。服务可以用来做很多事情，安装应用、查看文件、重启等等。
通信协议从低到高如下：
、协议：通过端口传输多个连接的数据，类似于网络中的数据链路层；
、协议：打开设备上端口连接，类型于网络中的运输层；
、协议：用于和服务传输数据，类似于网络中的应用层。
原理介绍
了解到的原理后，很多人便开始自己开发一些库，实现一样的功能，最有名的就是是基于语言实现的，编译配置比较麻烦，学习成本也较高。后来也出了对应的库，即。就是基于这个库实现的。
架构设计上分为层：
、层：驱动层；
、层：连接建立层，调用层，完成连接的建立，示例代码如下：
 =  ；
、封装层：封装好基本的服务，并完成和手机的配对验证；
、功能实现层：通过实现对应的功能，核心示例代码如下：
实现安装功能_
实现文件相关功能_
、命令行工具封装层：工具的初衷是为了开发一套类似的的工具，这一层主要仿照，实现对应命令行参数的解析并调用功能实现层，完成对应的功能。
遇到的问题及解决方案
工具交互方式的选择以及如何实现？
、模仿的交互方式：的便利性以及高效已经得到了大家的广泛认可，所以的用法要和保持一致，做到在命令行中直接输入对应的命令即可实现对应的功能；
、具体的实现：工具使用的是语言开发实现的，而的运行方式最常见的是 脚本文件名，要做到在命令行中直接输入实现对应脚本脚本的运行并实现参数的传递； 
最初想到的方案：将打包成可执行的文件，这个操作比较重，而且之后改起来又比较麻烦，同时也不符合脚本语言的特性，最终抛弃了这种方案。
最终方案：简洁的封装是自带的批处理语言。
、新建一个文件，将文件所在目录加入环境变量后，命令行中输入，即可运行对应的文件；
、脚本路径设置：最终需要调用相应的脚本实现相应的功能，为了保证在任意目录下，都能正常运行。
在中设置对应脚本的绝对路径：目前脚本和脚本在同一个目录下，所以可以用“”来表示脚本的绝对路径，“”变量代表对应的脚本的名称。
、到的参数传递：脚本中可以用“”表示在命令行中收到的参数，可以用这种方式传递参数给。
具体的实现如下：

复杂功能的封装
在日常测试过程中，会有一些抓包、抓的需求，这些在测试中也比较麻烦，所以在开发过程中，希望能够将抓网络包、抓操作尽最大可能简化。
、交互设计：一条命令开始抓取、结束、当前目录生成文件以及文件 。
、具体实现：
、命令封装：  。
、网络包和的抓取实现通用的封装：核心实现和两个函数。
：启动工作线程实现对应的功能，并在工作线程中时刻检测对应的标志位，看是否要结束；
：修改标志位为结束，触发工作线程的停止；处理并存储生成的文件。
、入口函数对的捕获：当运行程序时，使用键盘输入，程序内部会抛出一个异常，我们可以通过捕获对应的异常实现相应的功能。
、为了方便查看，对应的文件统一以当前的时间命令，并存在在命令行所在的路径。
核心代码实现：

工具介绍
下载地址仅供交流学习： 。
目录结构：

下载对应的包，然后解压。
“”开头的是工程文件，不用管可以直接作为工程导入，仅供交流学习。
“”实现所有功能的脚本。
“”入口函数，方便在命令行中直接通过“”命令调用相应功能。
“_”调用的类库，所有需要的库都已经放在里面了。
主要功能：
、支持手机基本操作：重启、锁屏、休眠；
、支持应用的安装、卸载、查看；
、支持沙盒目录的查看以及基本的文件操作之后出现限制，暂无法完美支持；
、支持、网络包的一键抓取。
环境依赖
、安装位版，并设置环境变量。设置方法如下：
依次打开：计算机——》右键——》属性——》左上角高级系统设置——》右下角“环境变量”——》系统变量——》选中“”——》点击“编辑”——》将的目录加进去用；分割，其他不要变——》点击确定。
目录指的是的安装目录，默认安装在\目录下。目录需要包含的可执行文件，如下图：
、 ，安装驱动检验标准，各种手机助手能够识别并连接手机；
、下载完后可以将目录添加到的环境变量中，方便在任何地方调用。
用法详解
如果已经添加了环境变量，直接打开即可。
重启手机：输入命令  。后面输入的是调用脚本时打印出来的内容。
、关机： 。 
、让手机休眠：   这个命令会让手机进入深度睡眠，连接也会断掉；按电源键点亮屏幕，又会正常连接 。
安装文件：   “文件路径”。
、卸载：  “的”类似于中的包名。
、显示所有的：  默认显示所有的。
、显示用户安装的：  。
、显示系统自带的：  。
、查看系统级文件列表：     使用沙盒环境，默认进入的是系统的图片、书籍音乐，也只能显示这些文件：进入后支持简单的、、等命令。进入后可以使用命令退出。
、获取系统文件到本机：  手机目录 目录手机目录可以通过 命令来查看就是上一条命令。
示例：   
将手机中的目录抓到当前目录当前目录用“”表示。
可以单个文件，也可以整个目录。
、文件到系统目录  “文件路径”“手机目录”。
手机目录也是通过 来确定的图片后，手机无法识别，后续会继续优化。、获取沙盒中的文件：  “应用”  “ 手机目录”“目录”。
示例如下：
          将应用为 的应用的 目录，拉到当前目录用“”表示
、文件到沙盒中：  “应用” “文件路径”“手机目录”。
、  抓系统日志，也可以通过  重定向到文件。
、  截图，这个需要手机装了开发者功能，如果没装的话，可以考虑在手机上按电源键以及键，然后到电脑上。
、 抓包，开始抓包，按结束，会在当前的所在的目录生成对应的文件以及文件。
按结束抓取，提示总流量并在当前目录生成文件以及日志文件系统日志。


注意事项
、驱动一定要先装好，如果电脑识别不了手机，所有的命令都无法执行；
、有时候连接不上手机，可能是驱动加载问题，可以尝试启动重新安装驱动、重启电脑、重启手机；
、部分的沙盒环境是不能访问的，这个和设置有关。一般日常测试的非正式发布的都允许访问沙盒目录，方便获取相应的文件。但是增加了对沙盒目录的限制，无法完美支持；
、目前支持 位版，其他版本暂时无法支持因为有些引用类库的限制。
想知道更多测试相关干货 请关注我们的微信公众号——腾讯移动品质中心：一 缓存的划分
从由谁来维护缓存的角度去划分模式和模式。
 调用方自己维护缓存模式
调用方的伪代码：
 = __
  ==  {
     = ___
    _ 
}
业务调用方自己感知缓存的状态，如果命中则从缓存中取，不命中则从拉取数据，并更新缓存。
本地私有缓存：

本地缓存的模式下，__是本地函数调用无网络交互，尝试从本地中获取缓存数据；如果命中则返回数据，不命中则从拉取数据后，更新本地的缓存。
远端共享存储：

远端缓存的模式下，__是调用需网络交互，尝试从、等缓存中间件中拉取缓存数据；如果命中则返回数据，不命中则从拉区数据之后，更新远端的缓存。
  ：
模式，效率更高，少网络交互，但是容易出现数据不一致。如果和本地都缓存了相同的数据，那么更新之后，如果通知更新，就变成了一个比较复杂的问题。几个参考方案可。
● 和按照号段划分数据，各自缓存不同的数据，处理不同的请求。这样可以保证自己的缓存数据不会与别人的冲突，避免了复杂的一致性问题；
● 有些情况例如单号段的请求量非常大和必须缓存相同的数据，可以考虑引入一些简单的一致性策略。例如参考微信账号体系的缓存方式，引入远端版本号服务器解决问题等参考文献《微信账号体系的缓存解决方案》。
模式，需要网络交互，但是数据一致性相对容易实现当然仔细考虑下，如果要完美实现也不是很容易的。相对而言，访问的效率低一些；网络流量较大；需要考虑网络超时等异常和操作相同节点的并发情况。
委托缓存代理侧维护模式
调用方的伪代码简化为：
 = ___

也称之为，带来的好处如下：
● 对调用方隔离了操作。在调用方看来，访问就实现了访问的能力，不关心更新缓存的细节；● 调用方可以简化调用协议。通常更新缓存和请求的协议不同，而这个协议转换的工作，完全交给了去实现；● 各种缓存调整对调用方透明隔离。选择不同的淘汰策略算法、调整缓存大小、命中率等等。
 从读取和更新缓存的方式去划分：
：如果读不命中缓存，那么就从加载数据，并更新缓存；：更新缓存的同时去更新，每次更新都触发写类似写文件，每次都到磁盘；：更新缓存并不触发更新，而是延迟一段时间再写回类似写文件，累计一定的修改之后，一起写回磁盘。
  ：模式：没有脏数据，的数据始终与的数据一致。但由于写请求都直接透传到，所以的亚历山大！采用这个模式，要充分评估好侧的负载。模式：有脏数据，的数据与不一致。但是该模式可以很好的降低侧的写请求，平滑负载。但是如果侧宕机或者，造成的就是数据丢失。所以如何保证数据一致性，采用什么策略回写数据到，都是需要好好考虑的问题。
关于缓存的更新也有挺多细节可以好好考虑下，陈皓的《缓存更新套路》中，介绍了一些，可以参考下参考文献《缓存更新的套路》。
二 缓存的主从同步
以下针对模式讨论
缓存是否需要主从备份？
可以从两个因素来判断缓存是否需要同步：数据一致性。如果采用了模式，那么就会有脏数据，如果此时没有主从备份，那么所在进程或服务器出问题，就会造成脏数据丢失，数据回档。这种数据回档的情况业务是否容忍？可用性。即使采用模式，或者仅仅是用于读请求，如果侧挂掉，服务是否会受影响而中断？这种业务中断是否容忍？
缓存如何进行主从同步？
之前写过一篇关于主从同步的文章《主从同步中的关键技术解析》，对比介绍了、、的主从同步中用到的关键技术。
缓存主从同步的解决方案更加灵活：
全数据同步。这种可以参考、等组件的同步思路，切片数据增量的方式进行同步。例如就是采用类似方式实现；必要数据同步。作为存储，与纯存储的主从同步问题不同，见下图：

缓存数据一致性的问题，本质上是： 主、备、三者对外提供的数据一致性。所以有以下特点：
 中的脏数据，必须要有，否则切换会回档；
中与一致的干净数据，可以缺少；
这样在升级为的时候，不存在的数据会从拉取，所以就以为准，这样一来数据一致性可以保证。
不过，如果只同步的脏数据，很可能切换的瞬间，由于缓存命中率低，导致压力瞬间透传给后端，造成瞬间服务不可用。所以从可用性的角度讲，建议也把主机的热数据也同步过去。
所以，我们的存储缓存采用了分级同步的方式处理，优先保证数据一致性，其次是数据可用性，同步示意图如下：

优点：
分级同步，把危险期降到最低。脏数据同步完，就已经可以保证数据一致了，此时就具备最基本的切换能力。脏数据通常占比不高，从我们线上的业务看，峰值占总内存量的，所以脏数据的同步最重要，耗时也较短；
热数据可以选择性的同步。热点数据较多的业务，可以设置同步的量大一些，甚至是把主机的所有数据都同步过去，实现主备数据完全一致。这个过程耗时较长，不过即使同步过程中主机挂掉，也不影响数据一致性，所以热点数据的同步速度可以相对慢一些。
缺点：
和之间必须采用 方式同步，不可以使用 。
这里再简单介绍下这两种格式的差别： 就是一条操作语句，描述的是执行过程，例如：把某个数据记录中的字段执行操作。 描述的是操作执行的结果，例如：字段执行操作之后的结果是什么。
因为中的数据量会比要少，所以 如果在一个不存在的结果上执行，结果肯定是错误的。但是如果是 ，接收到的是执行后的结果，所以就可以直接存储下来。
三 空查询问题
什么是空查询？空查询简单理解就是：到缓存中查询连都不存在的数据的请求。
可以不夸张的说：空查询绝对是缓存的天敌。为什么？因为缓存不命中的时候，缓存侧以为是自己没有到这个数据，所以把请求透传到后端，而中也么有这个数据，所以最后缓存中也没被填充上，下次类似的请求过来的时候，同样会走一遍相同流程，很容易导致直接过载！
有人可能会问，能不能把不命中的请求也缓存下来，这样下次相同的请求过来，缓存侧就知道这个数据不存在，从而避免再到侧拉取数据了呢？答案是不可以！因为空查询的情况可能千差万别。
举个栗子：有一个好友查询系统负责查询玩家是不是玩家的好友，如果不是好友就会导致空查询。假设缓存下来和不是好友，那么如果前端请求就是各种查询好友关系呢？岂不是缓存系统就会一堆非好友关系？？这种消耗肯定是不值得而且得不偿失的。
解决上述问题的一种简单方法是业务方换一种方式拉取数据：好友查询系统一次把所有玩家的好友拉取回去，然后判断是否是好友关系，这样就不会造成空查询。
也遇到过类似的问题，=纯内存硬盘，支持一种模式是可以把热点数据缓存在，而把超过多少天没有访问的数据下沉到。所以中就会因为空查询把请求都透传到，导致过载的案例：《开空查询对的影响》，最后的解决方案就是在侧，引入 的方式，见参考文献《布隆过滤器 》。
四 总结
本文简单介绍了下分布式缓存的分类、同步和空查询等三个问题。

从分类看缓存，每个类型都有其自己的特点和优缺点，如何抉择和权衡数据一致性和可用性，是在设计缓存初就需要思考好的问题；

缓存同步方面，给出了另外一种缓存同步的思路，缓存的主从可以不完全一致，而且数据可以分级同步，效果可能更好；

空查询问题，这个问题我们在外网也遇到过的头痛问题，缓存也必须要考虑到这方面问题，才不至于因为空查询而失效。


个人经验，和大家一起分享下！
五 参考文献
  关于缓存设计模式的参考文献。
《缓存更新的套路》陈皓
《  》介绍了几种缓存模式
《 》微软云设计模式中缓存的介绍前言
信号量又叫信号灯，也有人把它叫做信号集，本文遵循《环境高级编程》的叫法，仍称其为信号量。它的英文是，本意是“旗语”“信号”的意思。由于其叫法中包含“信号”这个关键字，所以容易跟另一个信号搞混。在这里首先强调一下，系统中的信号量和信号是完全不同的两个概念。我们将在其它文章中详细讲解信号。本文可以帮你学会：

什么是信号量？
什么是操作及其应用。
什么是信号量？
信号量的操作方法及其实现。

我们已经知道文件锁对于多进程共享文件的必要性了，对一个文件加锁，可以防止多进程访问文件时的“竞争条件”。信号量提供了类似能力，可以处理不同状态下多进程甚至多线程对共享资源的竞争。它所起到的作用就像十字路口的信号灯或航船时的旗语，用来协调多个执行过程对临界区的访问。但是从本质上讲，信号量实际上是实现了一套可以实现类似锁功能的原语，我们不仅可以用它实现锁，还可以实现其它行为，比如经典的操作。
环境下主要实现的信号量有两种。根据标准的不同，它们跟共享内存类似，一套的信号量，一套的信号量。下面我们分别使用它们实现一套类似文件锁的方法，来简单看看它们的使用。
信号量
信号量就是内核实现的一个计数器，可以对计数器做甲减操作，并且操作时遵守一些基本操作原则，即：对计数器做加操作立即返回，做减操作要检查计数器当前值是否够减？减被减数之后是否小于如果够，则减操作不会被阻塞；如果不够，则阻塞等待到够减为止。在此先给出其相关操作方法的原型：
 

 _     
可以使用创建或者打开一个已经创建的信号量数组。根据共享内存中的讲解，我们应该已经知道第一个参数用来标识系统内的信号量。这里除了可以使用产生以外，还可以使用_创建一个没有的信号量。如果指定的已经存在，则意味着打开这个信号量，这时参数指定为，参数也指定为。参数表示在创建信号量数组的时候，这个数组中的信号量个数是几个。我们可以通过多个信号量的数组实现更复杂的信号量功能。最后一个参数用来指定标志位，主要有：_，_和权限。
 
 
 

      _ 

      _     
使用调用来对信号量数组进行操作。指定对数组中的几个元素进行操作，如数组中只有一个信号量就指定为。操作的所有参数都定义在一个结构体里，其内容如下：
  _     
          _      
          _     
_可以指定的参数包括_和_。当制定了_，进程退出的时候会自动它对信号量的操作。对信号量的操作会作用在指定的第_个信号量。一个信号量集合中的第个信号量的编号从开始。所以，对于只有一个信号量的信号集，这个_应指定为。_用来指定对信号量的操作，可以有的操作有三种：
正值操作：对信号量计数器的值进行加操作。
值操作：对计数器的值没有影响，而且要求对进程对信号量必须有读权限。实际上这个行为是一个“等待计数器为”的操作：如果计数器的值为，则操作可以立即返回。如果不是并且_被设置为_的情况下，值操作也不会阻塞，而是会立即返回，并且被设置为。如果不是，且没设置_时，操作会阻塞，直到计数器值变成为止，此时相关信号量的值会加，这个值用来记录有多少个进程线程在此信号量上等待。除了计数器变为会导致阻塞停止以外，还有其他情况也会导致停止等待：信号量被删除，操作会失败，并且被置为。进程被信号打断，会被置为，切会被正常做减处理。
负值操作：对计数器做减操作，且进程对信号量必须有写权限。如果当前计数器的值大于或等于指定负值的绝对值，则可以立即返回，并且计数器的值会被置为减操作的结果。如果_的绝对值大于计数器的值，则说明目前不够减，测试如果_设置了_，操作依然会立即返回并且被置为。如果没设置_，则会阻塞，直到以下几种情况发生为止：

的值大于或等于_的绝对值，这时表示有足够的值做减法了。
信号量被删除，返回。
进程线程被信号打断，返回。

这些行为基本与值操作类似。提供了一个带超时机制的结构，以便实现等待超时。观察的行为我们会发现，有必要在一个信号量创建之后对其默认的计数器进行赋值。所以，我们需要在之前，使用进行赋值操作。
       
这个调用是一个可变参实现，具体参数要根据的不同而变化。在一般的使用中，我们主要要学会使用它改变的值和查看、修改的属性。相关的为：、_、_。
一个简单的修改的例子：
   ；
这个调用可以将指定的的值设置为。更具体的参数解释大家可以参考  。
以上就是信号量定义的原语意义。如果用它实现类似互斥锁的操作，那么我们就可以初始化一个默认计数器值为的的信号量，当有人进行加锁操作的时候对其减，解锁操作对其加。于是对于一个已经被减的信号量计数器来说，再有人加锁会导致阻塞等待，直到加锁的人解锁后才能再被别人加锁。
我们结合例子来看一下它们的使用，我们用实现一套互斥锁，这套锁除了可以锁文件，也可以用来给共享内存加锁，我们可以用它来保护上面共享内存使用的时的临界区。我们使用共享内存的代码案例为例子：
   __
 
 
 
 
 
 
 
 
 
 
 
 
 

  
  

  

 _
{
     

     = _  _|
        {
        
         
    }
           {
        
         
    }
     
}

 _ 
{
      _
}

  
{
      

    _ = 
    _ = 
    _ = 

          {
          ==  {

            
        }
        
         
    }

     
}

  
{
      

    _ = 
    _ = 
    _ = 

          {
        
         
    }

     
}

 _ _
{
     
     _ _
    _ _

     _ =  _ ==  {
        
        
    }

    _ = _  
     _   {
        
        
    }

    _ =  _  
      _ ==   {
        
        
    }

       
      ==  {
        
    }
     = _
    
    
    _ = 
      ==  {
        
    }
       

     _   {
        
        
    }

    
}

 
{
    _ 
     
     _
     _ _
    _ _

     = _
      ==  {
        
    }

    _ = 
     _ =  _ ==  {
        
        
    }

    _ = _  _|_|
     _   {
        
        
    }

    _ =  _  
      _ ==   {
        
        
    }

    _ = 

     = {
         = 
            {
            
            
        }

          ==  {
            __
        }
    }

     = {
        
    }

    _ \ _

     _   {
        
        
    }

     _ _    {
        
        
    }

    _

    
}
此时可以得到正确的执行结果：
  __ 
_ 
大家可以自己思考一下，如何使用信号量来完善这个所有的锁的操作行为，并补充以下方法：

实现。
实现共享锁。
在共享锁的情况下，实现查看当前有多少人以共享方式加了同一把锁。

系统中对于信号量的限制都放在一个文件中，路径为：。文件中包涵个限制值，它们分别的含义是：
：一个信号量集 中，最多可以有多少个信号量。这个限制实际上就是调用的第二个参数的个数上限。
：系统中在所有信号量集中最多可以有多少个信号量。
：可以使用系统调用指定的操作数限制。这个实际上是调用中，第二个参数的结构体中的_的数字上限。
：系统中信号量的标示数限制。就是信号量集的个数上限。
操作原语
操作是操作系统原理中的重点内容之一，而根据上述的互斥锁功能的描述来看，实际上我们的互斥锁就是一个典型的操作。加锁行为就是操作，解锁就是操作。操作是计算机操作系统需要提供的基本功能之一。最开始它用来在只有个的计算机系统上实现多任务操作系统的功能原语。试想，多任务操作系统意味着系统中同时可以执行多个进程，但是只有一个，那就意味着某一个时刻实际上只能有一个进程占用，而其它进程此时都要等着。基于这个考虑，年狄克斯特拉在系统中提出了操作原语的设计，来实现多进程占用资源的控制原语。在理解了互斥锁之后，我们能够意识到，临界区代码段实际上跟多进程使用一个的环境类似，它们都是对竞争条件下的有限资源。对待这样的资源，就有必要使用操作原语进行控制。
根据这个思路，我们再扩展来看一个应用。我们都知道现在的计算机基本都是多核甚至多的场景，所以很多计算任务如果可以并发执行，那么无疑可以增加计算能力。假设我们使用多进程的方式进行并发运算，那么并发多少个进程合适呢？虽然说这个问题会根据不同的应用场景发生变化，但是如果假定是一个极度消耗的运算的话，那么无疑有几个就应该并发几个进程。此时并发个数如果过多，则会增加调度开销导致整体吞度量下降，而过少则无法利用多个核心。操作正好是一种可以实现类似方法的一种编程原语。我们假定一个应用模型，这个应用要找到从到数字范围内的质数。如果采用并发的方式，我们可以考虑给每一个要判断的数字都用一个进程去计算，但是这样无疑会使进程个数远远大于一般计算机的个数。于是我们就可以在产生进程的时候，使用操作原语来控制同时进行运算的进程个数。这套原语的实现其实跟上面的互斥锁区别不大，对于互斥锁，计数器的初值为，而对于这个操作，无非就是计数器的初值设置为当前计算机的核心个数，具体代码实现如下：
   __
 
 
 
 
 
 
 
 
 
 

  
  
  

  

 _ 
{
     

     = _  _|
        {
        
         
    }
           {
        
         
    }
     
}

 _ 
{
      _
}

  
{
      

    _ = 
    _ = 
    _ = 

          {
          ==  {
            
        }
        
         
    }

     
}

  
{
      

    _ = 
    _ = 
    _ = 

          {
        
         
    }
     
}

 _ 
{
       

     = 
     = {
          ==  {
             = 
            
        }
    }
      ==  {
           \ 
    }
     子进程判断完当前数字退出之前进行操作 
    
    
}

 _ _
{
         
}

 
{
    _ 
     

     当子进程退出的时候使用信号处理进行回收，以防止产生很多僵尸进程 

      _ == _ {
        
        
    }

     = _

     每个需要运算的数字都打开一个子进程进行判断 
     == {
         创建子进程的时候进行操作。 
        
         = 
            {
             如果创建失败则应该操作 
            
            
            
        }
          ==  {
             创建子进程进行这个数字的判断 
            _
        }
    }
     在此等待所有数都运算完，以防止运算到最后父进程先_，导致最后四个子进程进行操作时报错 
      {}
    _
    
}
整个进程组的执行逻辑可以描述为，父进程需要运算判断到数字范围内所有出现的质数，采用每算一个数打开一个子进程的方式。为控制同时进行运算的子进程个数不超过个数，所以申请了一个值为个数的信号量计数器，每创建一个子进程，就对计数器做操作，子进程运算完推出对计数器做操作。由于操作在计数器是的情况下会阻塞，直到有其他子进程退出时使用操作使计数器加，所以整个进程组不会产生大于个数的子进程进行任务的运算。
这段代码使用了信号处理的方式回收子进程，以防产生过多的僵尸进程，这种编程方法比较多用在中。使用这个方法引出的问题在于，如果父进程不在退出前等所有子进程回收完毕，那么父进程将在最后几个子进程执行完之前就将信号量删除了，导致最后几个子进程进行操作的时候会报错。当然，我们可以采用更优雅的方式进程处理，但是那并不是本文要突出讲解的内容，大家可以自行对相关方法进行完善。一般的进程正常情况下父进程不会主动退出，所以不会有类似问题。
信号量
提供了一套新的信号量原语，其原型定义如下：
  
 
 

_ _    
_ _     _    
使用_来创建或访问一个已经创建的信号量。创建时，可以使用参数对其直接赋值。
 __ 
 __ 
 __     _
_会对指定信号量进行减操作，如果信号量原值大于，则减操作立即返回。如果当前值为，则_会阻塞，直到能减为止。
 __ 
_用来对信号量做加操作。这会导致某个已经使用_等在这个信号量上的进程返回。
 __   _用来返回当前信号量的值到指向的内存地址中。如果当前有进程使用_等待此信号量，可以允许有两种返回，一种是返回，另一种是返回一个负值，这个负值的绝对值就是等待进程的个数。默认的实现是返回。
 _  

 __ 
使用_可以在进程内部关闭一个信号量，_可以在系统中删除信号量。
信号量实现的更清晰简洁，相比之下，信号量更加复杂，但是却更佳灵活，应用场景更加广泛。在信号量中，对计数器的加和减操作都是通过方法和一个的结构体来实现的，但是在中则给出了更清晰的定义：使用_函数可以增加信号量计数器的值，使用_可以减少计数器的值。如果计数器的值当前是，则_操作会阻塞到值大于。
信号量也提供了两种方式的实现，命名信号量和匿名信号量。这有点类似方式使用文件路径创建和_方式创建的区别。但是表现形式不太一样：
命名信号量：
命名信号量实际上就是有一个文件名的信号量。跟共享内存类似，信号量也会在目录下创建一个文件，如果有这个文件名就是一个命名信号量。其它进程可以通过这个文件名来通过_方法使用这个信号量。除了访问一个命名信号量以外，_方法还可以创建一个信号量。创建之后，就可以使用_、_等方法进行操作了。这里要注意的是，一个命名信号量在用_关闭之后，还要使用_删除其文件名，才算彻底被删除。
匿名信号量：
一个匿名信号量仅仅就是一段内存区，并没有一个文件名与之对应。匿名信号量使用_进行初始化，使用_销毁。操作方法跟命名信号量一样。匿名内存的初始化方法跟_不一样，_要求对一段已有内存进行初始化，而不是在下产生一个文件。这就要求：如果信号量是在一个进程中的多个线程中使用，那么它所在的内存区应该是这些线程应该都能访问到的全局变量或者分配到的内存。如果是在多个进程间共享，那么这段内存应该本身是一段共享内存使用、或_申请的内存。
共享内存所涉及到的其它方法应该也都比较简单，更详细的帮助参考相关的手册即可，下面我们分别给出使用命名和匿名信号量的两个代码例子：
命名信号量使用：
   __
 
 
 
 
 
 
 
 
 
 
 

  
  
  

 _ 

_ _
{
    _  
     = _ _|_  
      == _ {
        _
         
    }
     
}

 __ 
{
    _
    _
}

 _ 
{
     _   {
          ==  {
            
        }
        _
         
    }

     
}

 _ 
{
     _   {
        
         
    }
}

 _  
{
       
     _

     = _ _ 
        {
        _
        
    }

    _ =    _|_ _  
     _ == _ {
        
        
    }
       
    
     = _
    
    
    _ = 
    
       
    _ 
    

    
}

 
{
    _ 
       
     _

     = _
      ==  {
         _ \
        
    }

     = _ _|_|_ 
        {
        _
        
    }

     =  
        {
        
        
    }

    _ =    _|_ _  
     _ == _ {
        
        
    }

    _ = 

     = {
         = 
            {
            
            
        }

          ==  {
            _
        }
    }

     = {
        
    }

    _ \ _
    _ 
    
    _
    
    _
    
}
匿名信号量使用：
   ___
 
 
 
 
 
 
 
 
 
 
 

  
  

 _ 

 _
{
    _  
}

 __ 
{
    _
}

 _ 
{
     _   {
          ==  {
            
        }
        _
         
    }

     
}

 _ 
{
     _   {
        
         
    }
}

 _  
{
       
     _

     = _ _ 
        {
        _
        
    }

    _ =    _|_ _  
     _ == _ {
        
        
    }
       
    
     = _
    
    
    _ = 
    
       
    _ 
    

    
}

 
{
    _ 
       
     _

     = _  _ _|_ _|_  
       == _ {
        
        
    }

    _

     = _ _|_|_ 
        {
        _
        
    }

     =  
        {
        
        
    }

    _ =    _|_ _  
     _ == _ {
        
        
    }

    _ = 

     = {
         = 
            {
            
            
        }

          ==  {
            _
        }
    }

     = {
        
    }

    _ \ _
    _ 
    
    _
    
    _
    
}
以上程序没有仔细考究，只是简单列出了用法。另外要注意的是，这些程序在编译的时候需要加额外的编译参数和。
最后
希望这些内容对大家进一步深入了解的信号量。如果有相关问题，可以在我的微博、微信或者博客上联系我。

大家好，我是！
如果你喜欢本文，欢迎在微博上搜索“”关注我，地址是：
大家也可以在微信上搜索：系统技术 关注我的公众号。
我的所有文章都会沉淀在我的个人博客上，地址是：。
欢迎使用以上各种方式一起探讨学习，共同进步。最新腾讯云技术公开课直播，提问腾讯代表，如何从小白成为技术专家？点击了解活动详情。
作者 | 张耀琦编辑 | 顾乡

张耀琦，现腾讯即通应用部工程师一枚；数学出身，博客专家的专栏；目前爱好钻研机器学习。

| 导语 介绍机器学习的回归模型，举例介绍了操作步骤，损失函数的求解，结果的分析。

引用课程：_

先看这里，可能由于你正在查看这个平台行间公式不支持很多的渲染，所以最好在我的上查看，传送门：无奈脸

博客文章地址：

为什么要先进行案例研究？
没有比较好的数学基础，直接接触深度学习会非常抽象，所以这里我们先通过一个预测   的    值的案例，打开深度学习的大门。
 回归

应用举例预测  进化后的战斗力
比如估计一只神奇宝贝进化后的  值战斗力。
下面是一只妙蛙种子，可以进化为妙蛙草，现在的值是，我们想估计进化后的值是多少；进化需要糖果，好处就是如果它进化后值不满意，那就不用浪费糖果来进化它了，可以选择性价比高的神奇宝贝。

输入用了一些不同的  来代表不同的属性，比如战斗力用 {} 来表示，物种 {} 来表示…
输出就是进化后的值
三个步骤
上一篇提到了机器学习的三个步骤：
确定一组函数。
将训练集对函数集进行训练。
挑选出“最好”的函数 {}
然后就可以使用 {} 来对新的测试集进行检测。
 
这个 应该长什么样子呢，先写一个简单的：我们可以认为进化后的值  等于进化前的值 _{} 乘以一个参数  再加上一个参数  。

 和  是参数，可以是任何数值。
可以有
这个函数集中可以有无限多的 。所以我们用  =    \ {}  代表这些  所成的集合。还有比如上面的 {} ，明显是不正确的，因为值有个条件都是正的，那乘以  就变成负的了，所以我们接着就要根据训练集来找到，这个   里面，哪个是合理的 。
我们将式 称作  ，   形式为：

{} 就是神奇宝贝的各种不同的属性，身高、体重等等，我们将这些称之为 “特征”；{} 称为 权重， 称为 偏差。
 方程的好坏
现在就需要搜集训练集，这里的数据集是  的，所以需要  的输入和输出数值，举例抓了一只杰尼龟，进化前的值为，用 {} 代表这只杰尼龟进化前的值，即用上标标示一个完整对象的编号；进化后的值为 ，用 \{}{} 表示进化后的值，用 字母头顶的上尖符号来表示这是一个正确的值，是实际观察到该有的输出。
下面我们来看真正的数据集来源  =

来看只神奇宝贝的真实数据， 轴代表进化前的值， 轴代表进化后的值。
有了训练集，为了评价  的好坏，我们需要定义一个新的函数，称为   损失函数，定义如下：
   
       
 是比较特别的函数，是函数的函数，因为它的输入是一个函数，而输出是表示输入的函数有多不好。 可以写成下面这种形式：

损失函数是由一组参数 和决定的，所以可以说损失函数是在衡量一组参数的好坏。
这里用比较常见的定义形式：
 
将实际的数值 \{}{} 减去 估测的数值   \ _{}{}，然后再给平方，就是  估测误差，总偏差；最后将估测误差加起来就是我们定义的损失函数。
这里不取各个偏差的代数和\{=}{}\{}{}   \ {}{} 作为总偏差，这是因为这些偏差\{}{}   \ _{}{}本身有正有负，如果简单地取它们的代数和，就可能互相抵消，这是虽然偏差的代数和很小，却不能保证各个偏差都很小。所以按照式，是这些偏差的平方和最小，就可以保证每一个偏差都很小。
为了更加直观，来对损失函数进行作图：

图上每个点都代表一个方程，比如红色的那个点代表 =\ _{} 。颜色代表用这个点的方程得到的损失函数有多不好，颜色越偏红色，代表数值越大，越偏蓝色蓝色，代表方程越好。最好的方程就是图中叉叉标记的点。
：最好的方程
定好了损失函数，可以衡量每一个方程的好坏，接下来需要从函数集中挑选一个最好的方程。将这个过程数学化：
由于这里举例的特殊性，对于式，直接使用最小二乘法即可解出最优的  和 ，使得总偏差最小。

简单说一下最小二乘法，对于二元函数 ，函数的极值点必为 \{\ }{\ } 及\{\ }{\ } 同时为零或至少有一个偏导数不存在的点；这是极值的必要条件。用这个极值条件可以解出 和 。详情请参阅《数学分析，第三版下册，欧阳光中 等编》第十五章，第一节

但这里会使用另外一种做法， 最速下降法，最速下降法不光能解决式 这一种问题；实际上只要  是可微分的，都可以用最速下降法来处理。
 梯度下降法
简单来看一下梯度下降法的做法。

考虑只有一个参数  的损失函数，随机的选取一个初始点，计算  = {} 时  对  的微分，然后顺着切线下降的方向更改  的值因为这里是求极小值，即斜率为负，增加 ；斜率为正，减小 
那么每次更改  ，更改多大，用 \ \{\{}}{\{}} |_{={}} 表示，\ 被称为“ ”学习速率。
由于这里斜率是负的，所以是 {}  \ \{\{}}{\{}} |_{={}} ，得到 {}；接着就是重复上述步骤。

直到找到一个点，这个点的斜率为。但是例子中的情况会比较疑惑，这样的方法很可能找到的只是局部极值，并不是全局极值，但这是由于我们例子的原因，针对回归问题来说，是不存在局部极值的，只有全局极值。所以这个方法还是可以使用。
下面来看看两个参数的问题。

两个参数的区别就是每次需要对两个参数求偏微分，然后同理更新参数的值。
关于梯度可以参阅《数学分析，第三版下册，欧阳光中 等编》，第十四章第六节。也可以大概看看百度百科又或者
将上述做法可视化：

同理梯度下降的缺陷如下图：

可能只是找到了局部极值，但是对于线性回归，可以保证所选取的损失函数式是 凸的，即只存在唯一极值。上图右边就是损失函数的等高线图，可以看出是一圈一圈向内减小的。
结果怎么样呢？
将求出的结果绘图如下

可以计算出训练集上的偏差绝对值之和为 
但真正关心的并不是在训练集上的偏差，而是的情况，就是需要在新的数据集测试集上来计算偏差。如下图：

使用十个新的神奇宝贝的数据作为测试集计算出偏差绝对值之和为
接下来考虑是否能够做的更好，可能并不只是简单的直线，考虑其他的情况：

比如重新设计一个，多一个二次项，来求出参数，得到 为，在训练集上看起来更好了。在测试集上得出的 是，确实是更好的。
再考虑三次项：

得到的结果看起来和二次项时候的结果差别不大，稍微好一点点。也可以看到_{}已经非常小了，说明三次项影响已经不大了。
再考虑四次项：

此时在训练集上可以做的更好，但是测试集的结果变差了。
再考虑五次项：

可以看到测试集的结果非常差。
过拟合，过度学习
将训练集上的 变化进行作图：

可以看到训练集上的   逐渐变小。
上面的那些，高次项是包含低次项的。理论上确实次幂越高越复杂的方程，可以让训练集的结果越低。但加上测试集的结果：

观察得出结果：虽然越复杂的可以在训练集上得到更好的结果，但越复杂的并不一定在测试集上有好的结果。这个结论叫做“过拟合”。
如果此时要选的话，最好的选择就是三次项式子的。

实际生活中典型的学驾照，学驾照的时候在驾校的训练集上人们可以做的很好，但上路之后真正的测试集就完全无法驾驭。这里只是举个训练集很好，而测试集结果很差的例子_

如果数据更多会怎样？
考虑只神奇宝贝的数据
可以看出物种也是一个关键性的因素，只考虑进化前的值是太局限的，刚才的就设计的不太好。
新的如下

将这个写成 的形式：

来看做出来的结果：

不同种类的神奇宝贝用的参数不同，用颜色区分。此时在训练集上可以做的更好，在测试集上的结果也是比之前的更好。
还有其他因素的影响吗？
比如对身高，体重，生命值进行绘图：

重新设计：

考虑上生命值{}、高度{}、重量_{}
这么复杂的，理论上训练集上可以得到更好的结果，实际为，确实是更低。但是测试集的结果就过拟合了。
正则化
对于上面那么多参数结果并不理想的情况，这里进行正则化处理，将之前的损失函数进行修改：

式 中多加了一项： \ \ {}{} ，结论是{}越小，则方程式就越好。还可以说当 {} 越小，则方程越平滑。
平滑的意思是当输入变化时，输出对输入的变化不敏感。比如式 中输入增加了 \ {} 则输入就增加了 {}\ {} ，可以看出当{}越小，输出变化越不明显。还比如测试集的输入有一些噪音数据，越平滑的方程就会受到更小的影响。

上图是对 \进行调整得出的结果。当 \ 越大的时候， \ \ _{}{} 这一项的影响力越大，所以当\ 越大的时候，方程越平滑。
训练集上得到的结果是：当 \ 越大的时候，在训练集上得到的 是越大的。这是合理的现象，因为当 \ 越大的时候，就越倾向于考虑  本身值，减少考虑。但是测试集上得到的 是先减小又增大的。这里喜欢比较平滑的，因为上面讲到对于噪音数据有很好的鲁棒性，所以开始增加 \ 的时候性能是越来越好；但是又不喜欢太平滑的，最平滑的就是一条水平线了，那就相当于什么都没有做，所以太平滑的又会得到糟糕的结果。
所以最后这件事情就是找到最合适的 \ ，此时带进式 求出 和 {}，得到的就是最优的。
对于 的时候，多加的一项：\ \ {}{}，并没有考虑  ，是因为期望得到平滑的，但这项并不影响平滑程度，它只是将上下移动，跟的平滑程度是没有关系的。
总结

：原始的值极大程度的决定了进化后的值，但可能还有其他的一些因素。  ：梯度下降的做法；后面会讲到它的理论依据和要点。
和：过拟合和正则化，主要介绍了表象；后面会讲到更多这方面的理论


相关推荐
机器学习入门系列，简介机器学习从入门到出家效果广告点击率预估近期实践：深度学习在互联网时代，大数据、云计算、移动化、社交网络、物联网等新技术层出不穷，对教育信息化应用也产生了重大影响，大数据学习分析、教育云、、移动教育等应用逐渐成为教育行业的热点。
然而，教育系统对于信息化的认识仍然离互联网时代的创新还有很大差距，特别是校园网络一般基于传统  技术，仅仅只是对校园信息化起支撑作用，这是远远不够的。
以  为代表的云计算等新技术的深入应用，将实现优质资源的整合与共享。资源的整合与共享一直以来都是教育信息化的主旨，云计算从技术优势上提供了全方位资源运用、共享管理的基础环境。
云计算数据中心的构建使得教育主体更加专注于教育业务本身，减少信息系统选择、规划、建设等工作；云计算跨平台环境使得复杂的设备管理变得统一简单，个性化、异构的信息系统需求得以保证，知识的产生、加工、传输、缓存数据安全更具保障。
未来，教育信息化领域的大容量资源调度管理、网络设备运营管理、大规模服务器资源统一管理提出了全新的要求，以云计算、 为基础的大规模云管理平台、 级云存储的管理应用将成为各级别学校信息中心进行  建设的实施重点。
海云捷迅结合我国教育系统信息化所面临的挑战，通过多年在各学校内的实践积累并整合了现有  云计算架构的功能模型，针对我国教育系统开发了教育云解决方案，可为高等院校和区域内初中等教育机构及相关方的业务需求提供云化支撑。
海云捷迅武汉大学案例
 项目背景
在教育信息化平台建设中，武汉大学在基础设施的建设、软硬件设备的购置上，投入了大量的人力财力，在一定程度上促进了教育资源共享，提高了信息化教学环境和管理水平。而随着武汉大学教学改革的深入，越来越重视学生的个性化需求。完全学分制、创新教育、网络公开课等新的管理和教学形式的引入，对武汉大学的教育信息化平台建设提出了新的要求。“互联网”的提出，云计算、大数据、移动计算等技术的出现，为解决此问题提供了新的技术途径和模式，云计算又是其中的核心和基础。
云计算的一个重要特点就是面向服务。云计算安全联盟  曾指出了云计算的本质，云计算是一种服务提供模型，通过该模型用户可不受时空的限制，根据自身需要，通过网络选择资源池中的共享资源；同时这些资源的分配是动态的和弹性的，可以在不同用户之间灵活划分。
 项目需求
目前，武汉大学教育信息化平台建设取得了长足的进展。校园网、在线教育平台的普及等，提高了教育资源的共享和利用率，促进了高校管理手段和教学方式的变革。但这其中暴露出的一些问题也不容忽视，关系着武汉大学教育信息化平台的可持续发展。
一、软硬件设施分散，管理维护成本高
武汉大学的各二级院系在信息化平台的建设中，一般会自购硬件设备和相应的教学软件，比如服务器、在线教学平台等。为了保证兼容性和稳定性，一台服务器上通常只运行  到  个应用，硬件资源的利用率不高。有些教学软件在功能上具有通用性，但仅供院系内部使用，软件资源的共享性也不足。同时，机房为了满足不同的教学需求，在每台机器上都安装了大量的软件。为了维护软硬件资源的正常运行，每个院系都需要安排专门的人员进行管理，工作量较大，效率较低。
二、 信息化教学资源日新月异，现有设施更新速度慢
随着信息化教学的深入开展，数字化学习资源越来越丰富。网络公开课、微课等教学模式的涌现，对于软硬件水平提出了更高的要求。比如在网络公开课建设和运行中，会存储大量的教学视频和各类学习资源，学习者对服务器会产生大规模的并发数据访问，网络公开课平台会实时动态生成大量的学习和统计数据。
这就需要服务器等硬件设施具备更高数据处理能力，网络设备具备较高的数据吞吐量等。而二级院系现有的设备，通常已经运行多年，由于当初设计和自然损耗等原因，已不能跟上最新的需求。若独自更新相关软硬件，则需经历新一段规划与建设周期，耗时较长。
三、安全需求
随着教育信息化建设的推进，应用系统越建越多，但由于意识、技术和资金等方面的原因，网站被黑、应用瘫痪、数据泄露或被篡改等情况时有发生，安全问题较为突出。
四、并发需求
武汉大学全日制在校生超过  万人，其中本科生  万余人。这意味着每学期有  万余本科生进行网上选课；每年有  万余人报考研究生；同时，高考招生网上宣传与咨询量也非常大。这三个应用访问高峰的时间段也各不相同。
针对这些对并发量以及实时要求高的应用，提供应用的部门包括教务部、研究生院和招生就业处分别购买了性能较高的服务器，有的还使用了多台，通过  轮询解析的方式进行负载均衡，尝试保证请求的实时响应。但是， 轮询解析并不能真正做到负载均衡，应用效果不好。另一个方面，这些高性能服务器大部分时间处于空闲状态，只是在特定的时间段发挥作用，设备利用率极低。
五、管理水平参差不齐、专业化不足
在教育信息化平台管理中，有些高校的二级学院没有配备专门的技术管理人员，而是由相关行政人员或专业教师兼为管理。而这些非专门技术人员，对平台软硬件的日常维护，停留在服务器的启停、后台数据的备份等功能性维护上，而对于性能优化、运行安全、负载均衡等专业技术层面的维护往往不足，导致平台在长时间运行后，出现反应迟缓、系统宕机等问题。
为了解决以上问题，武汉大学网络中心在  年初，利用云计算技术，采用成熟的云计算软硬件产品，结合学校自身的特点和实际需求，搭建了共享服务器群武汉大学云平台，作为全校信息化基础设施共享平台的重要组成部分。武汉大学共享服务器群充分发挥了网络中心技术和机房条件的优势，提高设备利用率，实现资源共享，满足校内各学院和全校师生不同层次和不同角色的服务需求。
 解决方案
武汉大学云平台采用多集群架构设计，由  台  服务器构建的  云集群 、 台使用本地存储服务器构建  云集群 ，以及  台使用集中存储服务器所构建的开源云计算实验室。其中， 云集群  包含整个云平台的管理节点和高配云服务器节点采用  磁盘结合的方式，提供高速  存储池 ，用于承载武汉大学的核心业务； 集群  包含低配服务器节点使用  磁盘，提供低速  存储池 ，用于提供武汉大学部分学生的开发和测试环境； 集群  和  共同构建了武汉大学的核心业务云平台，通过集成学校现有的统一身份认证和短信平台，实现资源的统一调度和管理。通过将服务器和存储按照硬件性能进行分组，可为武汉大学不同类型的业务提供不同磁盘性能的资源，并可方便管理员在管理  上进行调配；可在云平台中部署  组件，用于对虚拟机和重要的业务数据进行备份。
图 武汉大学云平台架构 
武汉大学云平台架构分数据中心区、网络区、用户区三部分。

数据中心区数据中心区是云平台的核心区域，用于承载武汉大学各院系网站、选课系统、招生系统等核心业务，所有业务的数据文件均存放在此区域中。

数据中心区提供用户认证、用户数据管理、备份；以及各种安全措施的部署，如更新和修补程序等，并支持  运维人员进行统一部署和维护。
网络区用于连通前端师生的终端设备和数据中心，优质的网络带宽是使用云服务的基础，图形图像及各种应用的使用，均需要高质量网络带宽的保证。
用户区包括武汉大学内各院系师生集中办公和学习的区域、校外互联网访问用户等，用户可通过台式机、移动设备等多种终端以  方式访问云平台，以获取相关的资源。
武汉大学云平台具备以下特点和优势：

可随时随地访问凭学工号登录校园信息门户网站，即可直接访问云平台，无需二次输入用户名及密码。

短信提醒云平台的任何关键操作或重要信息，比如注册成功、续费提示、资源告警，能够自动发送给管理员或普通用户，短信内容支持自定义，保障云平台交互操作一目了然，云平台维护更及时。

快速部署云平台的计算、存储资源池需要按需快速扩展时，方案可满足资源使用者的需求能够被快速响应和满足。云平台通过自动化部署手段实现了  资源的快速交付，可实现云平台  小时内快速部署，大大提升快速扩展的能力且降低了因为长时间部署调试带来的隐性资本损耗。

数据安全武汉大学的所有业务数据完全驻留在云平台内，存储设备采用分布式架构，确保在单台存储设备意外崩溃时数据的零丢失，保证了所有业务数据的数据安全性。同时，可通过搭建  组件构建数据备份资源池，针对整个云平台中关键数据进行备份。

降低运维管理难度和成本传统云架构建设时包含：虚拟化服务器、光纤交换机、磁盘阵列、虚拟化软件、云管理套件等，往往选用不同厂家的软硬件设备，且硬件层次关系比较复杂，在维护时需要考虑的因素比较多，维护难度较大，而本方案中的云平台架构因为采用横向设计的分层架构，无太多的硬件依赖关系，因此后期的可维护性更强，可以大大降低武汉大学的运维成本。

比传统云架构更高的性能本方案推荐的基于  的云平台架构比传统云架构具有更高的性能。传统云架构仅仅是在计算层面实现虚拟化，虚拟机的性能难以保障，难以支撑更大的业务系统 ，所以无法满足客户对于资源多样化的需求以及保障客户云服务 。传统云架构的多台虚拟化服务器在底层还是对应于单点的  共享存储，因此系统的性能瓶颈在于底层存储无法提供足够的  能力。云平台通过完全分布式的存储架构实现数据多通路高并发；通过  和  自动分层存储机制实现数据访问  的大幅提升，单虚拟机读  可达  万，写  可达  万，是传统架构的十倍量级；而且通过针对于虚拟化设计的诸多软件定义的其他技术机制在多层面保障系统的高性能。

更好的扩展性本方案推荐的云平台架构具备更好的可扩展性。传统云架构底层采用共享存储设备，共享存储设备的扩展性受限于其控制单元，即主机头，主机头的主机接口和带宽是有限的，未来随着业务发展，数据量不断增加，存储单元的扩展必然伴随着存储性能的下降。云平台由于采用超融合架构，每个节点机里都包含数据控制单元和数据存储单元，且各节点机地位对等，需要扩展时仅仅需要添置节点机即可，新添置的节点机和原有节点机构成新的集群，在容量扩充的同时系统整体性能是线性增加的，因此本方案中的云平台可扩展性更强。

更高的可靠性和可用性传统云架构底层采用单点的共享存储 ，当存储系统出现故障时对于整个系统而言是巨大灾难。本方案中云平台架构的存储层面采用分布式架构，在数据保护层面采用多数据副本机制，因此，集群中任意一个节点损坏都不会对整体造成影响，这样可以保障系统的高可靠性，而且系统具备数据副本自动恢复的相关机制以保障数据安全可靠。整个系统在各个层面都充分考虑了高可用架构，包括网络链路、完全分布式架构、存储管理、云管理架构等，这样可以确保系统构成单元在单点出现故障时不会造成上层业务的中断而给用户带来不可用的体验，保障业务系统持续的可用性。


 客户收益
武汉大学云平台，能有效利用武汉大学现有软硬件设备，通过虚拟化技术统一建设和管理，充分发掘基础设施的潜能。使用者可按需申请服务，合理利用资源。云计算的大规模分布式计算能力，能为海量服务请求提供稳定高效的支持，能适应武汉大学信息网络部门、各二级学院、老师与学生等不同层次和不同角色的服务需求，在降低成本的基础上，充分提高资源的利用率和共享率，促进管理水平的专业化。

用户使用角度，共享服务器群具有用户自服务功能，用户自行注册，按需提交资源使用申请，系统管理员审核通过后，管理平台自动根据配置生成虚拟服务器。用户通过自服务门户实现资源的管理、使用及自运维，包括资源生命周期管理、网络管理、虚拟磁盘云硬盘等，无需要管理员的干预。
从高并发需求角度，共享服务器群利用同期规划的负载均衡设备，很好地支撑了学校的教学和管理工作。以本科生选课为例：武汉大学共有本科生  万余人，选课在网上进行，每次网上选课时间为两天，是很典型的高并发实时访问的活动之一。在实现共享服务器群之前，每次开放学生网上选课，教务部服务器最大能够承载的并发不到  人，导致学生无法正常选课；教务部选课系统部署到共享服务器群上以后，已承担多次全校本科生选课，最大选课并发访问接近一万人。
从运维管理角度，通过共享服务器群管理平台，实现了计算资源、存储资源、网络资源的集中管理和统一调度，实现了自动化的运维监控，极大的提升了运维效率。
从安全角度，共享服务器群提供了三重安全措施，一是网络硬件防火墙，提供物理级别的保护；二是软件防火墙，提供用户级别的隔离防护；三是应用防火墙，提供应用级别的防护，保证业务系统的安全。

武汉大学采用云平台后， 年 年大大降低了虚拟化及服务器采购成本  万元，降低了 人工成本  万元，提升资源池利用率 以上，提升运维管理效率 以上。导语
最近一段时间技术成为了时下热门，越来越多的应用开发者投身到这些技术中来。应用中出现了的场景，图形学也成为了必备的技术基础。在开发过程中，往往为了追求更好的效果而使用了更加高清的素材，使得本就内存吃紧的手机面对更加严峻的挑战，尤其是对开发者而言。 为了解决这个问题，我们使用了纹理压缩技术。使用这个技术可以大幅度的降低的内存共享显存占用，从而在有限的内存限制下，使用更丰富的素材。
    前言
最近一段时间技术成为了时下热门，越来越多的应用开发者投身到这些技术中来。应用中出现了的场景，图形学也成为了必备的技术基础。在开发过程中，往往为了追求更好的效果而使用了更加高清的素材，使得本就内存吃紧的手机面对更加严峻的挑战，尤其是对开发者而言。
为了解决这个问题，我们使用了纹理压缩技术。使用这个技术可以大幅度的降低的内存共享显存占用，从而在有限的内存限制下，使用更丰富的素材。
    什么是纹理压缩
常见的图片文件格式，比如，，等，是图像为了存储信息而使用的对信息的特殊编码方式。它存储在磁盘中，或者内存中，但是并不能被所识别。
这些文件格式当被读入后，还是需要经过解压成，再传送到端进行使用。
纹理格式是能被所识别的像素格式，能被快速寻址并采样。压缩纹理，是一种能直接读取并显示的格式，使得图像无需解压即可进行渲染，节约大量的内存。

    常见的压缩纹理格式
  
纹理压缩格式来源于   公司提出的  ，基本思想是把的像素块压缩成一个或位的数据块，是有损压缩方式。是算法的五种变化，用于各种设备。

压缩率：，，为，、为
主要支持平台及系列的的手机
支持：

  
  ，是由  支持的开放标准，在移动平台中广泛采用。它是一种为感知质量设计的有损算法，其依据是人眼对亮度改变的反应要高于色度改变。类似于，也是把的像素块压缩成一个或位的数据块，也是有损压缩。





压缩率
适用







 









这个系列，可以说是适用机型最广的格式。
支持几乎所有市面上的机，所有
支持大部分高端机， 及以上
  
  ，格式与基于块的压缩格式，比如、的不同之处是，它使用张双线性放大的低分辨率图，根据精度和每个像素的权重，融合到一起来呈现纹理，并且和都支持数据。格式压缩比较高，也是有损压缩。





压缩率
适用




 


 


 






这个系列，是支持最广的格式
只支持长宽相等且为的幂次方的纹理
支持部分机：系列，全系列机型
支持的

  
   ，自适应扩展纹理压缩，这是提出的，去年被组织认可，纳入到标准中来，不过并不是强制性的
有多种压缩方式可选，具有不同的压缩率



 
 
压缩率







































































　



这个系列，可以说是综合性能和使用便捷性最好的系列。
支持部分高端机型，及以上机型
    主要优缺点
在几乎不损害图片质量和显示性能的情况下，大幅度降低内存显存开销，纹理压缩就是这样的一个技术。
不过，任何的技术都有其适用范围和优缺点，需要仔细评估再决定。
  主要优点
占用内存显存大幅度降低
无额外性能开销
使用方便，只需少量代码
  主要缺点
硬件相关，要考虑兼容性
压缩纹理文件大小比常规和文件大
需要额外的制作工具，无法直接在移动端生成
    如何使用压缩纹理
  保存格式
压缩纹理是图片数据的一种编码方式，我们还缺少一个容器去承载。就像文件是的视频的容器一样。
我们选择了使用的格式。
是一个为和程序设计的纹理存储格式。它可以简单的辨别里面所存储的纹理格式和其他相关信息。
  文件结构

 
 
 
 
 
 
 
 
 
 
 
 
 
 

      
       
         
               


  _  
      
      _  
           
             _  
                   __  
                       __  
                        
                   

           
            
       
    
           

  使用格式
  ____
{
    _ 
    _ 
    _ 
    _ 
    _ 
    _ 
    _ 
    _ 
    _ 
    _ 
    _ 
    _ 
    _ 
    _ 
} 




  =   

  =  == 

 =     
 =     
 =     

_  =     
_  =     

 _  =      
_ =      

  =  

 _  = 
_  = 
_  =   = 
 
{
    _  = _   
     = _

      =   
    

     = 

     =    
     =    
}文 | 宋秉金
最近，开源项目  正式发布了   版本，包括了来自  位贡献者开发的特性和  修复。其中特别值得一提的一处  修复与   命令有关。 版本之前，对于自己部署  服务器的用户来说，可能会存在不受信任的  用户在远程主机上执行  命令的风险。
下面我们来介绍一下几个新增特性：
 冲突检测
前段时间有新闻报道说，研究人员找到了第一例  冲突，而  正是  用来识别对象的哈希函数。  版本会对对象进行检测，并拒绝可能存在冲突攻击的对象。新版本中，该检测已默认生效，用户不用再安装其他依赖。不过，这个实现的速度相对慢一些，但是实际上对于大多数  操作的时间不会产生可见影响。
更方便的 
以前，你可能会这样使用 ：
   
   _ 
其实， 和  这种参数实际上被称为 ，是  独有的匹配路径的模式。 可以是路径字面量、前缀或者通配符：
              
                        
新版本中，添加了  标记，支持根据文件的  属性值进行选择。例如，如果你使用了  ，可以这样获取文件列表：
  




   =

更多新特性，请查看导语
刚开始做前端的时候，一直以为切好页面是重构的全部职责，在切好页面的前提，增加页面交互，这样已经能到重构的顶峰。直到进入公司后发现参与的项目都有两个特点，项目复杂和参与人数的多，发现传统的方法已经不适用。主要介绍自己重构构建经历，如有问题欢迎指教！ 乀ˉεˉ乀
以往存在的问题
这里介绍自己以往传统重构的方法容易暴露的缺点。

编写风格不统一，导致代码可读性差，增加后期维护成本与沟通成本；
和代码冗余，增加了重构开发成本和页面打开速度；
项目开发周期长，缺少公共与私有框架的规划，同样会增加后期维护成本与开发成本，可复用性差；
项目文件部署杂乱，导致项目后期维护困难；
重构开发方法有优化提升空间；

重构构建的初步发展
在项目开始的时候，由于项目过大，支持重构的人越来越多了，这个时候大家讨论出的一些方法有：定义统一的代码规范、项目文件的合理部署、重构的方法优化、开发的自动化和重构架构的统一
实现方式：

重构文件的统一部署，区分开发环境和正式环境；
统一和代码的命名方式，增加代码的可读性，减少沟通成本；
使用抽离公共组件样式的模块，使得的开发变得简单可维护，使页面可组合；
使用，自动生成雪碧图并且同时生成背景坐标，提升重构效率；
编写公共方法，减少重复代码，提升重构效率包括自带方法函数；
结合构建工具，对雪碧图自动合并，生成，文件部署快速部署，项目的分类进行统一管理；

重构构建的深度扩展
主要是以项目版本为基础进行构建优化
第一个版本引出的问题：

因项目庞大，前期考虑不足，缺少颜色的配置方案，导致后期需要换肤功能无法支持，无法统一调整；
文件未做合并压缩，增加了页面的请求；
命名的统一虽然能解决代码的可读性，但是当代码过多时，查看起来仍然令人眼花缭乱，同开发之间的对接也变得困难；
上传不方便，强行增加联调和测试的门槛；

主要围绕在不提升架构的复杂度，结合构建工具使页面模块化和组件化，优化重构的工作流程，同时节省重构与前端或者开发之间的对接时间，搭建属于重构的管理系统增强重构对项目的管理能力
页面皮肤配置
在项目初期时候，提前与设计进行页面换肤的颜色探讨，重构的时候根据少数颜色结合的颜色函数，达到页面整体的颜色配置。

后续有扩展空间，可以将配置放入管理端中，通过管理端传入颜色的配置再进行编译生成文件。
实现浏览器自动刷新
对页面进行样式更改之后，往往会多次刷新页面查看效果，对页面进行联调的时候更能体现出自动刷新的重要性，往往一个细节会花很多时间
使用条件：

谷歌安装工具；
用配置静态服务器，打开网页
执行配置好的，并且打开谷歌工具

优化：
因为并不是特别好使用，所以用  来替代，的功能更全更方便。这里好处我不一一列举，可以查看 官方文档，有更详细的介绍。
其中也遇到了一些问题，因为是和都是编译生成，得需要去动态监听生成文件的改变，进行自动刷新。
静态页面的模块化、组件化
为什么重构也要模块化、组件化：

模块强调分离，对重构而言，我们不能每次只写自己的做好自己的事，重构是提供整张页面给前端或者后端，在庞大且复杂的项目中后续在开发页面时，每增加一个模块都需要和对接人员沟通清楚，可能还得指出具体位置；
组件强调复用，在重构新的页面时，对公共组件部分还得进行再重构，增加了重构的开发时间；


实现方式：

：

将静态进行模块化开发，当开发人员拿到重构页面时候看到模块， 清晰的知 道页面中引用了那些新模块，直接去进行快速开发，同时会生成完整的静态便于查看效果。同时也避免了重构对公共组件的再重构，节省了重构制作静态页面的时间。利用实现双向绑定，更改同时会更新完整静态，并且浏览器会检测更改自动刷新
 

：

模块通过进行组件化区分，避免引用多余的组件样式

搭建和图片管理系统
因为管理系统是自己独自处理，所以还有很多待改进的地方，在能够完成基础功能的前提，后续继续慢慢跟进。

为什么要搭建管理后台？

刚开始在项目初期的时候，我们在每次联调或者重构完页面时，都需要通过前端或者开发进行协助将及图片上传到对应环境中，最后因为实在太麻烦，重构也开始使用跳板机进行环境的上传。然后发现每次页面在后期联调维护的时候，因为上传环境复杂，需要花很多没必要的时间在跳板机上传上，增加了工作量。
管理后台有哪些功能？

文件上传整个管理后台是以图片和的上传与管理为基础围绕展开。

文件压缩包括文件的压缩，图片的上传进行自动压缩，并且会将颜色配置的和全局公共的合并在同一个文件中，压缩后文件命名以 项目名 组成，线上保证有一份源同时还会有一个压缩后


为什么不将合并与压缩功能做在中，却做到管理端上？
如果做到中，会不方便后期的改版维护，在发布时，因为都是压缩过的代码，不便和线上进行对比。虽然有，但是为了保证一切以线上为主的基础，还是会对线上的代码进行对比。

文件打印

用于打印文件代码，更方便的进行对比操作

最后
以上只是列举了我个人在项目中重构构建历程，主要是为了减轻重复劳动，提高效率。我们可以选择更加适合自己的方案，而不是在追寻技术的路上迷失了方向。
最后的最后
各位大佬求轻吐！！！作者：韩伟，个人公众号：韩大：， 以技术提升开发效率
远程对象调用的概念
要说“远程对象”，必先说“远程调用”，也就是。比较著名的框架有，最近很火的，也就是开源的。另外还有开源的等等……我厂内部也有很多框架，琳琅满目不暇接。在里面也支持   远程方法请求功能，也可以视为一种，但实际上这个更像我们现在要讨论的“远程对象调用”。
在诸多的中，我们都基本认为是通过网络，对运行在另外一个进程或者电脑里的某个函数，发起一次调用请求。既然是一次函数调用，那么我们自然要传入参数，然后期望获得返回值。在这个过程中，我们往往只需要输入：函数名参数，就能找到一个远程的进程，去执行对应的函数，然后传入目标参数。在这个过程里，执行这个函数的进程，会被认为是无状态的，所有的输出，都仅与输入的参数有关，除非有一部分状态是记录在数据库持久化设备上的。因此，计算的过程算法，和计算的数据，实际上分离的，这些计算所需的数据，要么来源于参数，要么是数据库设备。而被请求的函数，以及装载这个函数的容器——进程，是不保证任何的状态维护能力的。
而“远程对象调用”，正是在“状态”这个环节上，和不同——它是由框架去保证某种状态的。当我们发起一个远程对象调用的时候，是需要首先“找到”一个远程对象，然后再发起“方法”成员函数调用。这和就产生了两个明显的区别：
一、我们需要用某种手段定位到对象，而不是仅仅用一个函数名。对象是一个更复杂的远程概念，因为有可能同属于一个类，而存在多个状态一致或不一致的对象，在远程的机器上存在。我们就不能仅仅通过一个固定的路由标志比如类名去找一个这样的对象。远程对象的路由方式成为不同“远程对象调用”框架之间的一个显著区别。
二、我们并不需要把所有的数据，在每次请求时都通过参数发给远程对象，因为对于同一个远程对象来说，它是可以包含大量过程状态的。我们只要找到正确的远程对象，就能获得之前操作所造成的结果状态。有远程对象往往是生存在进程的内存中，所以对于访问自己的状态数据，会非常快速，这对于有延迟压力的程序来说，是非常有用的。

所以，远程对象调用，最大的特点，就是数据和计算是合并在一起的——这很好的提高了使用面向对象编程的便利性，也大大降低了远程调用中因为数据拉取产生的延迟。
远程对象的优点：压力、易用性
在传统的“请求响应”为基础的分布式服务器中，最常见的数据系统是：接入逻辑缓存数据库 这样一个四层结构。为了让承担计算压力的“逻辑”模块能分布到不同的进程上，我们往往会把“逻辑”模块做成“无状态”的，这样我们就可以随意的启动、停止任何一个逻辑模块的进程，而不需要担心因此丢失用户数据。但是这样做，逻辑模块是轻松了，承担状态存储的“缓存数据库”哥俩压力就大了。因为每一个数据操作，都需要去从他们这里读取数据，然后再回写结果如果有数据修改操作的话。

由于“缓存数据库”模块是有状态的，一般来说还很难简单的做分布式部署，因为如果随机分布数据的话，逻辑模块可能就会找不到状态所在的缓存进程。从理论可以知道，我们要让状态能分布，就一定要牺牲一些一致性或可用性。因此我们更倾向以的存储系统去充当“缓存数据库”模块。但是，即便是，还是会有两个缺点：一个是跨进程访问的延迟；一个是编程上的复杂性。
跨进程访问的延迟来源于两方面，一方面是本身跨进程通过之类的手段通讯，就会有比进程内存访问高的多的延迟，而且我们常常会把一个业务流程按数据的类型划分到不同的“逻辑模块”里，这样一个业务请求可能会需要多次的跨进程访问才能访问完所需的数据，这就大大加重了因为网络带来的延迟；另外一方面来源于路由查找，虽然我们可以用一致性哈希这类算法取代路由查找，但是基于数据的业务特性，我们却不太喜欢把所有数据都拆的七零八落，所以常常还是有一个查询、或探索数据所在地的过程。
编程的复杂性也是很严重的问题。不管是还是，这些数据都是以序列化的方式描述的，并且也按照数据的组织存放形式，要求使用者去准备好输入或者解析读出这些数据。这些数据和我们在编程中常用的结构体、对象往往完全是不一样的形式。这就造成了我们很多额外的编码和调试的工作。这些数据往往还是“结构敏感”的：如果我们修改了数据结构，往往需要重新配置数据表结构，修改访问代码等等。这让我们在快速开发业务逻辑的时候，背上沉重的开发效率包袱。——因此业界才有很多所谓对象关系映射的框架出现。
但是如果我们使用“远程对象调用”，就可以有效的缓解以上两个问题：
一、缓解跨进程延迟。由于远程对象本身已经包含了数据，所以对于所需的数据，都是从内存中直接读写，这方面的延迟是绝对最快的。另外，由于远程对象调用发起之前，已经需要先查找到目地对象，这样就把查找方法和查找数据的两个过程合二为一了，在路由层面也能有效降低延迟。
二、极好的易用性。由于面向对象编程的概念已经深入人心，所以对于“先找到一个对象”，然后“调用其方法”的过程，是非常自然的。复杂的负载均衡、容灾、扩容等问题，实际上都隐藏在“查找对象”这个环节底下，开发者几乎无需关心，所以用起来会非常方便。而编写一个远程对象，也非常简单，就是写一个类，实例化一个对象，然后登记到服务器里而已。这都是面向对象编程的传统做法。由于对象本身都是带数据的，所以编写这些远程方法也会比较简单，大部分的数据都直接在本地内存读写，比如从对象成员属性里。节省了大量编写或者定义和使用特别的存储设备协议的时间。
业界远程对象方案：
远程对象调用的框架，在业界也是常见的东西，这里大概说一下三家的     。这三家的框架大概的说明现在远程对象调用的主流用法。
一，
全称  ，是的企业分布式集群方案的核心规范。能部署在多个服务器上提供远程对象调用服务的对象，就称为对象。底层的网络是通过自带的功能实现。本身只是规范中的一部分，仅仅是一套接口。具体的实现由类似这样的“容器”软件提供。之所以不及  流行，很大原因就是因为这些容器软件都是商业软件，需要花很贵的价格购买。但这并不影响作为一个优秀的远程对象方案的技术地位。现在已经升级到版本以上了，摒弃了以前配置复杂，功能晦涩的特点，大胆的使用更简单的生命周期管理、简单的注解式配置、好用的能力，让 重新成为一流的技术。

一个客户端程序，想要访问一个对象，一般需要使用一个叫做的，来具体连接到对象上。的全称是    ，基本等于我们常说的名字、目录服务接口。通过一套规范，来统一各种目录服务器的使用方法。所有的容器，都必须提供一个服务，而客户端程序则通过使用容器提供的来访问容器内的对象。的使用方法，基本上就是输入一个字符串，然后会返回给你一个对象。在的环境里，这个对象就是对象的接口对象对应远程对象的一个映像，也叫桩对象。代码类似：
  =  
  = “”
  =     

输入函数的字符串，是用户可以自己定义的任何内容，只要在对应的容器里面登记了这个对应关系即可。从这个代码我们可以看到，如果想要做容灾、负载均衡等功能，是完全可以通过这个接口来实现的。另外，远程对象的接口桩代码是需要预先部署在客户端测，在上面的例子里是这个类。而对象的这个接口类，是由工具，自动通过来源的对象类定义生成的。对比，等技术，可以直接用源代码代替定义，然后自动生成桩代码，这确实是简便很多。
规范把远程对象定义为三种：无状态会话，有状态会话，消息驱动。这意味着容器对于对象的生命周期是有管理的。其中无状态会话和消息驱动的声明周期是类似的，都是来一个请求消息驱动的意思是每来一个消息，就可能一个对象。当然也可能不是每次请求都新建对象，总之容器不保证会保持对象的生存周期，这样容器可以根据负载压力，灵活的管理众多的对象。而最特别的是“有状态会话”，容器会根据客户端的会话状态和客户端的对象对应，来保持对象，也就是说，每个客户端对应一个有状态。如果你用这个客户端，发起多次查找，访问的那个对象都将会是同一个。这对于需要保持登录状态的服务，就非常方便了。客户无需自己去维持一个远程对象的生命周期，而能得到状态保存的功能。
最后说说的部署配置，以前的容器部署异常复杂。除了需要写一个继承于特定基类的业务类外，还要配置很多细节。而之后，通过注解功能，这些配置都可以和源代码写到一起，而业务类也无需集成特定的接口和类型，可以是任何一个普通的类，只是需要加上一些特定的注释即可。容器提供工具对这些加了注释的类进行处理，一方面把这个类自动部署到容器中，另一方面生成客户端的接口类文件，供用户发布拷贝到需要使用的客户方服务器上去。而一些容器如还提供了的图形界面工具，让整个过程几乎都不在需要编写额外的配置和命令行操作。
二， 
全称  ，是微软发布的用于构建面向服务的应用程序框架。这套框架的底层是的技术，而编程接口则更多的使用语言语言和平台。这和有一定的类似，差别就是中的远程对象，不需要一个像那样的虚拟机，而是结合在操作系统里。
无独有偶，的远程接口定义，也是直接使用代码，加上类似注解的“特性”功能注释，标注在一个定义好的接口上来组成的。具体的业务实现类，只要“实现”定义的这个接口就可以了，和一个普通的类没有任何差别。和的差别是，我们还是需要写一段配置，把这个远程对象的接口和查找字符串，注册到万能的服务器里面。一旦注册完成，就可以通过： 这样的字符串去访问了。同时，如果客户端想要访问这个远程对象，则需要使用这个工具，输入刚刚注册的那个，就可以生成对应的客户端桩代码库。客户端可以直接这个新建立的桩类型对象，然后直接调用其方法，就和调用本地对象的方法一样。
   
  =  

     
  = 
  = 
  =  
{}{} = {}   

当然，如果你想连接不同的服务器，还是有机会的，一位内生成的客户端代码，会使用一个配置文件。在里面可以修改远程服务器的地址还是那个注册的。

     
         = 
         = 
         =  


你除了可以通过来提供的远程对象服务外，还可以自己写一个单独的程序，通过定义来完全的控制这些远程对象，从而提供服务。另外，除了通过直接对应一个远程对象外，还可以通过编写“路由服务”，来对同一个的远程对象调用进行灵活的路由。虽然没有提供类似的远程对象生命周期管理功能，但是你完全可以通过的服务和路由服务，来自己编码实现任何形式的远程对象生命周期管理。
三， 
公司的服务，是以技术为基础的，但是又不同于的另外一套远程对象技术。这套技术更接近于以为基础实现的体系。这个技术的使用标准的 接口作为远程对象的接口，使用的序列化、反序列化能力作为编码能力。然后自己写一个 函数，建立一个对象来构造一个远程服务器。而客户端则是通过一个字符串来定位想要访问的远程对象。这个字符串类似： 。我们可以看到这里面有和端口，还有一个编写服务器远程对象时注册的字符串。我们通过 – 这样的命令行部署远程对象，然后用  启动服务器，用  启动客户机。这些命名，都是包含在      里面的。我们可以发现，是一个更加原始的远程对象方案，基本上就是一个的实现的组合。使用起来有点繁琐，但是好处是不需要学习和部署复杂的容器服务，可以完全自己编码去实现一套远程对象服务。这里没有限定你使用什么方法去定位查找远程对象，也没有限定你怎么管理远程对象的生命周期，一切都由开发者自己去编写实现。
总结



规范
远程对象定位
远程对象生命周期管理
服务器部署





路径字符串查找
自动管理，带会话状态对象
使用容器服务



、路由服务
无
部署到或自写



 定位
无
自写



在对象定位的选择上，通过字符串查找已经是标准，而复杂的自定义路由也可以隐藏在这个查找操作下面。远程对象的生命周期管理，实际上是对服务器资源的管理，除了有容器支持以外，其他的方案都比较少提供这样的能力，说明这一块是比较困难的。服务器部署方面，可以让用户以自己写去构建服务器，提供了极大的灵活性。
远程对象的挑战：生命周期管理、数据一致性
通过上面的分析，我们可以发现，远程对象的生命周期管理，是一个比较重大且复杂的课题。我们要保证这样的生命周期管理程序，能有一个通用的策略，来保持各种业务情况下的服务器资源稳定，是比较困难的。而且在分布式系统的情况下，为了负载均衡，还要把同样类型的远程对象，部署到不同的进程上，这就引入了一个新的问题：数据一致性。
远程对象的生命周期，除了占用服务器的内存资源外，还会占用记录其地址的路由空间，检查维护生命周期的运算时间。如果我们提供自动化的对象生命周期管理，势必就需要在客户使用的时候，提供这方面的教育，以及防止客户使用错误、过载等情况下对象管理失效的防御性策略。所以即便是容器，也仅仅提供了非常简单的生命周期管理策略：会话状态、无状态这两种。
对于一般的互联网应用，只有这两种生命周期管理的远程对象，基本上是够用的。因为一般的互联网应用，大部分数据都是持久化数据，需要读写数据库。临时状态数据一般来说不多，主要是用户登录后的产生的一些过程数据，有一个“会话”类型的生命周期就足够了。但是，如果我们的业务是网络游戏，那么这么简单的生命周期就是完全不够的，因为游戏中有大量的临时状态，比如组队的状态，玩家所在房间的状态，关卡副本的状态等等。这些临时状态，都是需要我们通过业务逻辑代码，来控制和管理所对应的对象生命周期的。所以一个适合游戏的远程对象系统，需要提供让客户端程序来选择，“新建初始化”和“销毁”远程对象的能力。
在对远程对象进行管理的时候，我们常常会用到一种叫“对象池”的技术，使用这种技术避免频繁的新建和销毁对象。但是如果这些对象的是带状态的，那么我们的“池”就必须带索引，并且对象也必须有一个。同时我们的对象还需要有一个“”的重置方法，用来让对象回归到初始化状态。
在分布式的系统下，我们的对象池因为是分别存放在不同的机器上，所以其一致性的维护往往是比较困难的。但是，我们可以把这个问题，转换成构建一个“分布式对象池”的问题。假如每个对象池，都按的某个规律，如一致性哈希，存放不同的对象。那么只要在远程调用发起的时候，也就是通过查找远程对象的时候，把请求导向到对象所在进程，那么就能很方便的从本地进程对象池中获得对象。远程对象的“定位”和“一致性”在查找对象这个环节结合起来，是一个非常好的想法。这样能让远程状态对象的使用进一步简化，用户完全无需关心远程对象在什么地方，又能快速的访问到正确的对象。
扩容下的远程对象迁移
当分布式的对象容器出现部分进程故障，或者需要动态扩容的时候，只要我们针对对象查找的数据做某种程度的数据搬迁，或者缓存清理，就能很容易的实现对象的重新分布。如果对象同时能够支持持久化，那么这种数据搬迁，只需要简单的让对象写入持久化。然后在新的机器上，通过缓存建立的策略，从持久化设备读取出对象即可。
总结
远程对象调用，是一种业界成熟的分布式服务器系统模型。这套模型提供了强大的分布式程序架构能力，并且能方便的置入统一的运维特性能力：容灾、扩容、负载均衡。
它比远程方法调用，增加了对数据位置的指向，能有效的提高系统的响应速度。同时面向对象的形态，也能显著降低复杂逻辑的开发成本。
远程对象的生命周期管理，实际上一种分布式缓存系统的管理。良好的远程对象系统，能提高丰富的生命周期管理功能，以适合网络游戏，这种需要处理丰富临时状态的行业需求。
如果我们把远程对象的寻址和数据一致性维护结合起来，并且提供对象的持久化支持，那么远程对象调用将是一个高度自动化，且具有自我维护能力的强大分布式计算系统。   
历史上看， 在  年就完成了在线索引接口的设计。而   、 都早在  版本中就支持在线索引添加，然而直到   用户才能真正享受到该功能虽然  团队有推出 ，这也导致在  出现之前 版本及之前版本， 数据库长期被吐槽的原因之一特别是  
 版本及之前版本的  实现方式：

上图不难看出， 及之前版本  实现的方式存在如下问题：

  的过程需要耗费额外的存储空间，并且耗时很长。

  的过程有写锁，无法持续对业务提供正常服务。


虽然在  版本中增加了  方式，但依然会阻塞 、、 操作
   
 中对添加索引操作引入了新特性    特性，在  中，开始支持更多的   类型操作来避免  ，同时支持了在线上  的过程中不阻塞  操作，真正意义上的实现了  。
但并不是所有的  操作都支持在线操作，这里附上  官方文档对于  操作的总结：


_____ 参数
虽然   支持了在线  操作，不过还是有些需要注意的问题，最为重要的就是参数 _____ 的配置。在进行  操作时会保存操作时间内产生的日志，这与   的临时表，但是其保存在内存中，而该内存的大小由参数 _____ 定义，默认大小为 。如果产生的日志超出该容量大小，则会抛出类似如下的异常提示：
_____

   _    _____       
根据测试经验， 通常在一个活跃的线上环境中是不够的，通常  是比较推荐的值。好在该参数是动态的，可以基于会话级别进行调整。另外个人的体会是，在进行在线索引添加操作时，数据库性能会有 ～的下降。
另一个小技巧是使用    = 来强制使用在线  操作，若操作不支持，则会抛出异常，如：
       =

   =                    =
   
那到了 ，在  的基础上又增加了以下的新特性：

增加了     的语法支持，同时继续支撑   特性。

修改  列的长度操作支持  特性


   =     

      _ ==
 子句用来指定执行  采用的方式，可取值为 、、
 = | | 
 子句描述持有的锁类型来控制  的并发，取值 、、、
 = |  |  | 
同样，也附上  官方文档对于  操作的总结：

中文翻译如下图：

 的   实现原理

 的   使用限制与问题
仍然存在排他锁，有锁等待的风险。
跟  一样，增量日志大小是有限制的由 _____ 参数决定大小
有可能造成主从延迟
无法暂停，只能中断
 工具     
首先简单说下  
 源自  和  工具，这两个工具是管理  的最有名的工具，但  已经不维护了，全部归并到 。  是一组高级的命令行工具，用来管理  和系统任务，主要包括：
验证主节点和复制数据的一致性 【、】有效的对记录行进行归档            【】分析索引使用情况                       【】总结  服务器                    【】从日志和  中分析查询    【】问题发生时收集重要的系统信息  【】 符合条件的            【】在线修改表结构                           【】
这里，主要介绍在线修改表结构工具：
该工具特点与优势：
支持并发  操作
经过多年生产环境验证，可靠稳定。
 原理如下图：

 使用限制
原表不能存在触发器。
原表必须存在主键   或者  
外键的处理需要指定  参数，存在风险
在  的执行过程中，如果有对主键的更新操作则会出现重复的数据见下面链接的  说明

 存在的风险

触发器是以解释型代码保存的，因此每次查询都需要对触发器的代码进行解释的开销。

触发器与原始查询共享相同的事务空间，原始查询在表上有锁竞争，触发器也会在另一张表上有锁竞争。同时，在触发器删除时同样会有元数据锁。

触发器无法暂停，当主库  变高，希望停止变更时，但触发器是不会停止。因此在整个操作过程中，触发器都会存在直到执行结束。


 使用示例
  =    \
  = \
= == =  \
 ___= =_=  \
==
这块各个参数的含义具体可以参见下官方文档，特别注意：
 


这几个较少用到的参数
 工具
’   意思是 的在线表定义转换器
 的优势：

无触发器的设计

切换方案的设计

最大限度的减少了对主机的影响

实现了增量数据的获取基本做到了原子性的切换


 原理分析

 工作模式探索
 工作时可以连上多个  实例，同时也把自己以从库的方式连上其中一个实例来获取二进制日志事件。根据你的配置、数据库集群架构和你想在哪里执行修改操作，可以有许多种不同的工作模式。

 连接到从库，在主库做迁移
这是  默认的工作方式。 将会检查从库状态，找到集群结构中的主库并连接，接下来进行迁移操作：

行数据在主库上读写

读取从库的二进制日志，将变更应用到主库

在从库收集表格式，字段索引，行数等信息

在从库上读取内部的变更事件如心跳事件

在主库切换表


如果你的主库的日志格式是 ，工具也可以正常工作。但从库必须启用二级制日志_ __ 并且设置 _=   是读取从库的二级制文件。
如果直接在主库上操作，当然也需要二进制日志格式是 。
 连接到主库
如果你没有从库，或者不想使用从库，你可以直接在主库上操作。 将会直接在主库上进行所有操作。你需要持续关注复制延迟问题。

你的主库的二进制日志必须是  格式。

在这个模式中你必须指定  参数


 在从库迁移测试
该模式会在从库执行迁移操作。 会简单的连接到主库，此后所有的操作都在从库执行，不会对主库进行任何的改动。整个操作过程中， 将控制速度保证从库可以及时的进行数据同步

 选项让  直接在从库上修改表。最终的切换过程也是在从库正常复制的状态下完成的。

 表明操作只是为了测试目的。在进行最终的切换操作之前，复制会被停止。原始表和临时表会相互切换，再切换回来，最终相当于原始表没被动过。主从复制暂停的状态下，你可以检查和对比这两张表中的数据


关于  数据时序的问题

对与  和  是没有问题的，因为无论    和   的先后顺序，如果   在后，会覆盖掉   ，如果   在前面，   因为使用  ，因此会被  掉； 的数据优先级是最高的
对与  数据，我们可以演算一下， 三个操作，可能存在三种情况 肯定在  的后面：

  
  
  

， 会将数据  到  表，最后  会把  表中的数据  掉；

， 空操作， 也是空操作；
， 空操作， 也是空操作；

  阶段
 阶段即  表阶段

对应用请求的影响：所有请求在  阶段直到临时表消失前会被阻塞，被释放后所有的请求都会在新表上执行，若  阶段失败，则所有的请求一定会在旧表上执行。

对主从复制的影响：备机只能看到  操作，锁的  不会写入 ，因此备机看到的是一个原子性的操作。


 使用限制：

不能对有外键关系及触发器的表进行  

要求所连接的获取增量数据的   为  格式会强制转换

若有同名但是字母大小写不同的表如： 和 ，则无法对这两张表进行修改

不支持   类型列的修改

不支持    的修改


使用案例：
 \
=_= \
= \
= \
= \
 \
 \
 \
 \
= \
= \
= \
= \
= \
= \
= \
 \
=   \
 \
 \
= \
= \
= \
= \

各个工具的总结对比

实际测试结果对比
  的测试：

 的测试：

另外，实际测试中还发现，如果使用  修改的表，该表的主键不是自增字段，可以获得比较高的一个性能。
但在实际生产环境中，主键几乎都是自增字段，如果在写入较大的线上环境，且同时表主键为自增字段的话，使用  可能会产生大量的自增锁，_=_
同时，这和  的参数___ 的配置也有关系：
这里简单介绍下：
从  版本开始， 存储引擎开始提供一种轻量级互斥量的自增长实现机制，这种机制大大提高了自增长值插入的性能。并且从该版本开始， 存储引擎提供了一个参数 ___ 来控制自增长的模式，该参数的默认值为 
在详细了解 ___ 之前，我们需要对自增长的插入进行类别划分：、   指所有的插入语句，如 、、、、  等
、    指能在插入前就确定插入行数的语句。这些语句包括 、 等。需要注意的是：  不包含      这类  语句
、    指在插入前不能确定得到插入行数的语句，如 、、 
、    指插入中有一部分的值是自增长的，有一部分是确定的。如    也可以是指     这类  语句
在了解了以上的分类后，我们接着来分析 ___ 参数的各个设置对自增锁的影响，总共就  个值可以设置即 、、
、___ =  这是  版本之前的自增长实现方式，即通过表锁的   方式。因为有了新的自增长方式， 这个选项不应该是新版用户的首选项。
、___ =  这是该参数的默认值。对于  ，该值会采用互斥量【】去对内存中的计数器进行累加的操作。对于  ，还是会使用传统表锁的   方式。在这种配置下，如果不考虑回滚操作，对于自增列的增长还是连续的。并且在这种方式下， 方式的  还是能很好的工作。需要注意的是，如果已经使用   方式去产生自增长的值，而这是需要再进行   的操作时，还是需要等待   的释放。
、___ =  在这个模式下，对于所有  自增长的产生都是通过互斥量，而不是   的方式。显然，这是性能最高的方式。然而，这会带来一定的问题，因为并发插入的存在，在每次插入时，自增长的值可能不是连续的。此外，最重要的是，基于   会出现问题。因此，使用这个模式，任何时候都应该使用  。这样才能保证最大的并发性能及  主从数据的一致。

 测试

测试结果， 的使用过程对性能影响是最小的，果然，无触发器的设计在性能上可以最大程度的避免  锁和  锁等待作者：郭林烁 

原文地址
最近在    分享了《使用构建流式前端应用》，会后在线上线下跟大家交流时发现对于  的态度呈现出两大类有用过的都表达了  带来的优雅编码体验，未用过的则反馈太难入门。所以，这里将结合自己对  理解，通过  的实现原理、基础实现及实例来一步步分析，提供  较为全面的指引，感受下使用  编码是怎样的体验。
目录

常规方式实现搜索功能
 · 流 
 实现原理简析
观察者模式
迭代器模式
 的观察者  迭代器模式


 基础实现




 · 
 ·入门
一系列的  操作


使用  一步步实现搜索功能
总结

常规方式实现搜索
做一个搜索功能在前端开发中其实并不陌生，一般的实现方式是：监听文本框的输入事件，将输入内容发送到后台，最终将后台返回的数据进行处理并展示成搜索结果。
 =

      = 
      ={
          = 
         发送输入内容到后台
        {
             `{}`
              = {
               拿到后台返回数据，并展示搜索结果
              
            }
        }
    }


上面代码实现我们要的功能，但存在两个较大的问题：

多余的请求当想搜索“爱迪生”时，输入框可能会存在三种情况，“爱”、“爱迪”、“爱迪生”。而这三种情况将会发起  次请求，存在  次多余的请求。

已无用的请求仍然执行一开始搜了“爱迪生”，然后马上改搜索“达尔文”。结果后台返回了“爱迪生”的搜索结果，执行渲染逻辑后结果框展示了“爱迪生”的结果，而不是当前正在搜索的“达尔文”，这是不正确的。


减少多余请求数，可以用  函数节流的方式来处理，核心代码如下
 =

      = 
         = 
      ={
         在  毫秒内进行其他输入，则清除上一个定时器
        
         定时器，在  毫秒后触发
         =  = {
            发起请求
        }
    }


已无用的请求仍然执行的解决方式，可以在发起请求前声明一个当前搜索的状态变量，后台将搜索的内容及结果一起返回，前端判断返回数据与当前搜索是否一致，一致才走到渲染逻辑。最终代码为
 =

      = 
         = 
         = 

      ={
        
         =  = {
             声明一个当前所搜的状态变量
             ＝ 书 

              = 
            {
                 `{}`
                  = {
                     判断后台返回的标志与我们存的当前搜索变量是否一致
                      ===  {
                         渲染展示
                        
                    }  {
                         
                    }
                }           
            }
        }
    }


上面代码基本满足需求，但代码开始显得乱糟糟。我们来使用  实现上面代码功能，如下
  = 
  =  
                    
                     
                     = 
                     = 

可以明显看出，基于  的实现，代码十分简洁！
 · 流 
 是     的缩写，起源于  ，是一个基于可观测数据流在异步编程应用中的库。 是   在  上的实现，而其他语言也有相应的实现，如 、、 等。学习 ，我们需要从可观测数据流说起，它是  中一个重要的数据类型。
流是在时间流逝的过程中产生的一系列事件。它具有时间与事件响应的概念。

下雨天时，雨滴随时间推移逐渐产生，下落时对水面产生了水波纹的影响，这跟  中的流是很类似的。而在  中，雨滴可能就是一系列的鼠标点击、键盘点击产生的事件或数据集合等等。
 基础实现原理简析
对流的概念有一定理解后，我们来讲讲  是怎么围绕着流的概念来实现的，讲讲  的基础实现原理。 是基于观察者模式和迭代器模式以函数式编程思维来实现的。
观察者模式
观察者模式在  中最常见的应该是  事件的监听和触发。

订阅：通过  订阅  的  事件。
发布：当  节点被点击时， 节点便会向订阅者发布这个消息。

   {
    
}

  模拟用户点击

将上述例子抽象模型，并对应通用的观察者模型

迭代器模式
迭代器模式可以用  提供了   可迭代协议来表示。  不是具体的变量类型，而是一种可实现协议。 中像 、 等都属于内置的可迭代类型，可以通过  方法来获取一个迭代对象，调用迭代对象的  方法将获取一个元素对象，如下示例。
  =  

  = 

  = {    }
  = {    }

  = {    }

元素对象中： 表示返回值， 表示是否已经到达最后。
遍历迭代器可以使用下面做法。
  =  
  = 

 {
     
     {
         =    = 获取下一个值
    }   {
           = 错误处理
    }
      {
           = 无更多值已完成
        
    }
    
}

主要对应三种情况：

获取下一个值调用  可以将元素一个个地返回，这样就支持了返回多次值。

无更多值已完成当无更多值时， 返回元素中  为 。

错误处理当  方法执行时报错，则会抛出  事件，所以可以用   包裹  方法处理可能出现的错误。


 的观察者  迭代器模式
 中含有两个基本概念： 与 。 作为被观察者，是一个值或事件的流集合；而  则作为观察者，根据  进行处理。 与  之间的订阅发布关系观察者模式 如下：

订阅： 通过  提供的  方法订阅 。
发布： 通过回调  方法向  发布事件。

下面为  与  的伪代码
 
  = {
     {
        `收到{}`
    }
}

 
   {
    ={
        
    }
}

 


上面实际也是观察者模式的表现，那么迭代器模式在  中如何体现呢？
在  中， 除了有  方法来接收  的事件外，还可以提供了另外的两个方法： 和 ，与迭代器模式一一对应。
  = {
     {  处理值 }
     {  处理异常  }
     {  处理已完成态  }
}

结合迭代器  进行理解：

 提供一个  方法来接收  流，是一种  形式；而  是通过调用  来拿到值，是一种  的形式。

当不再有新的值发出时，将触发  的  方法；而在  中，则需要在  的返回结果中，当返回元素  为  时，则表示 。

当在处理事件中出现异常报错时， 提供  方法来接收错误进行统一处理； 则需要进行   包裹来处理可能出现的错误。


下面是  与  实现观察者  迭代器模式的伪代码，数据的逐渐传递传递与影响其实就是流的表现。
 
  = {
     {
        `收到{}`
    }
     {
        `收到{}`
    }
     {
        
    }
}

 
   {
    ={
        
    }

    
      
}

 


 基础实现
有了上面的概念及伪代码，那么在  中是怎么创建  与  的呢
创建 
 提供  的方法来自定义创建一个 ，可以使用  来发出流。
  =  = {
    
    
       = 
}

创建 
 可以声明 、、 方法来处理流的不同状态。
  = 
     =  
     =  
     = 


最后将  与  通过  订阅结合起来。
  = 

 中流是可以被取消的，调用  将返回一个 ，可以通过调用  将流进行取消，让流不再产生。
看了起来挺复杂的？换一个实现形式：
  创建一个 
  = 

  
 = 

将上面代码改用链式写法，代码变得十分简洁：
 = 

 ·  操作
 操作·入门
 = 

上面代码相当于创建了一个流，最终打印出。那么如果想将打印结果翻倍，变成，应该怎么处理呢？
方案一： 改变事件源，让  值  
    =  = 

方案二： 改变响应方式，让  处理  
 =     = 

优雅方案：  提供了优雅的处理方式，可以在事件源与响应者之间增加操作流的方法。

              =     = 
              = 

 操作跟数组操作的作用是一致的，不同的这里是将流进行改变，然后将新的流传出去。在  中，把这类操作流的方式称之为 操作。提供了一系列 ，像、、 等等。操作流将产生新流，从而保持流的不可变性，这也是  中函数式编程的一点体现。关于函数式编程，这里暂不多讲，可以看看另外一篇文章 《谈谈函数式编程》
到这里，我们知道了，流从产生到最终处理，可能经过的一些操作。即  中  将经过一系列  操作后，到达 。
             
 || 

一系列的  操作
 提供了非常多的操作，像下面这些。
_      __

关于每一个操作的含义，可以查看官网进行了解。 具有静态方法和实例 方法，下面使用  和  来简单区分，举几个例子。
 可以将普通数据转换成流式数据 。如上面的 。
除了数值外， 还提供了关于事件的操作， 可以用来监听事件。当事件触发时，将事件  转成可流动的  进行传输。下面示例表示：监听文本框的  事件，触发  可以产生一系列的  。
  = 
 
              = 

 方法跟我们平常使用的方式是一样的，不同的只是这里是将流进行改变，然后将新的流传出去。上面示例已有涉及，这里不再多讲。 

              =   
              = 

 提供了许多的操作，为了更好的理解各个操作的作用，我们可以通过一个可视化的工具  图 来辅助理解。如  方法对应的  图如下

箭头可以理解为时间轴，上面的数据经过中间的操作，转变成下面的模样。
 也是  中常用的接口，我们来结合  图来理解它

上面的数据流中，产生了新的分支流流中流， 的作用则是将分支流调整回主干上，最终分支上的数据流都经过主干的其他操作，其实也是将流中流进行扁平化。
 与  都是将分支流疏通到主干上，而不同的地方在于  只会保留最后的流，而取消抛弃之前的流。
除了上面提到的 ，也可以  字符的方式来绘制可视化图表，下面将结合 、 和  进行对比来理解。
                         
                         ↗  ↗                 ↗  ↗
                               
                                 
                                         
                                    
                                      
                     
                     
 和  中， 和  是主干上产生的流，、 为  在分支上产生，、 为  在分支上产生，可看到，最终将归并到主干上。 只保留最后的流，所以将  的  抛弃掉。
 操作可以操作一个时间戳 ，表示经过  毫秒后，没有流入新值，那么才将值转入下一个操作。

 中的操作符是满足我们以前的开发思维的，像 、 这些。另外，无论是  图还是用  字符图这些可视化的方式，都对  的学习和理解有非常大的帮助。
使用  一步步实现搜索示例
 提供许多创建流或操作流的接口，应用这些接口，我们来一步步将搜索的示例进行  化。
使用  提供的  接口来监听我们输入框的  事件，触发  将产生 。
  = 
 
              = 

这里我们并不想输出事件，而想拿到文本输入值，请求搜索，最终渲染出结果。涉及到两个新的  操作，简单理解一下：

 将输入的 ，输出成 。

将请求搜索结果输出回给  上进行渲染。


  = 
 
                
              =   
              = 

上面代码实现了简单搜索呈现，但同样存在一开始提及的两个问题。那么如何减少请求数，以及取消已无用的请求呢？我们来了解  提供的其他  操作，来解决上述问题。

表示经过  毫秒后，没有流入新值，那么才将值转入下一个环节。这个与前面使用  来实现函数节流的方式有一致效果。

使用  替换 ，将能取消上一个已无用的请求，只保留最后的请求结果流，这样就确保处理展示的是最后的搜索的结果。


最终实现如下，与一开始的实现进行对比，可以明显看出  让代码变得十分简洁。
  = 
 
                 
              
              =       
              = 

总结
本篇作为  入门篇到这里就结束，关于  中的其他方面内容，后续再拎出来进一步分析学习。
 作为一个库，可以与众多框架结合使用，但并不是每一种场合都需要使用到 。复杂的数据来源，异步多的情况下才能更好凸显  作用，这一块可以看看民工叔写的《流动的数据——使用  构造复杂单页应用的数据逻辑》 相信会有更好的理解。
附    
 查看更多文章 大学的男生宿舍楼叫黑木崖，黑木崖里并没有圣女，圣女都在对面的女生宿舍楼移花宫。黑木崖里每天关灯夜谈，除了讨论对面的女孩，就是讨论金庸小说中哪种武功最厉害。
东方是葵花宝典的支持者，但他又觉得葵花宝典缺少男子汉的雄风，少那么一点点味道，于是大家都称呼他为：葵花两点，意思是比葵花宝典厉害一点。葵花两点学的是计算机，正规的名称是：计算机科学与技术。他向往互联网世界，所以毕业时，带着一本《深入浅出》和一张磨损严重的键盘去了北方的燕京，号称：一书一键闯天涯。

那一天细雨扬扬拨弄着葵花两点的心情，荡漾出落英缤纷的幻想，推动着心花怒放。他坐上一辆电驴预备去高铁站，对师傅说：得儿驾，跑起来。多有春风得意马蹄疾的范。
近二十年来，大量落魄浪人来到燕京昌平讨生活，他们群居在两块地方，其一是座道观，回龙观；还有一处地方，蜿蜒明澈的小溪流过叫清河，被称为清河剑派。
浪人们自称修士、剑客，或者苦行僧，而外界称他们为：马龙。恩，龙马精神的意思，的确是。
这是战国时代。青云帝国，九尾天猫为徽，白猫星河剑符；腾龙帝国，黑白天鹅为徽，混沌万象熔阳功；千寻帝国，以长河碧浪，落日凤凰为徽，帅气回眸功。各国相互攻仠，回龙观的道士与清河剑派的剑修，也就有了职业发展的机会。
道士与剑修，有着自己的高傲与门规：必须从童子身开始修持，才能勇猛精进。所以如葵花两点这样的羞涩青年大受欢迎。如您所料，葵花两点同学入住了回龙观，成为了一名修士。
燕京生活首先得合租房子。对于葵花两点而言，有一些特别：一同租房的是联通妹子，叫，二房东。起初葵花还担心人家女孩子不愿意，但女孩得知他是回龙观的马龙苦修后，警惕的眼神顿时消失，满不在乎的放松下来：月租  ，押一付三，晚上加班自带钥匙，咱喜欢干净，汝要记得才好。
葵花总觉得女孩的放松让他有轻微羞辱感，但又不知道为什么，这让他莫名沮丧。

合租生活进行了一周，他们便掌握了各自上厕所的规律。这是一样必须技能，关系到团队合作：和谐轮流使用厕所，让你们关系融洽。

葵花两点工作的地方叫西二旗。据说这是明朝的驻军之地：百户之下设总旗，领军人。但现在的西二旗，早晚高峰人山人海，有这么一种说法：如果你要在西二旗上下车，得掂量掂量膀胱的容量。
葵花两点对工作很负责。他每天都怀着忐忑的心情，在冯洛伊曼像前虔诚祷告：每一个程序都有原罪，愿主宽恕我写的，并让率降低。他惊奇的发现，祷告不但可以带来灵魂上的安宁，而且效果比代码更好。难怪有贤人说：积极主动的人生，不需要  的代码 。
清晨太阳刚刚升起，他如沙丁鱼插入地铁中，周围匆忙的人群面容疲惫，表情似乎在说：别惹我，今天分泌的多巴胺不够。
到了公司，领导拥有乔峰的气场，每一道眼神如六脉神剑，洞穿心灵，直达延误的需求！同事都是狮崽般的程序员，组合起来好比基纽特种部队，奋力拉着互联网的战车前行。
有的同事曾经在长江畔游荡，高冠巍峨的吟唱；有的是草原上套马的汉子；有的热爱手办，熟悉 妹妹；有的自己就是 妹妹。总之，他她们因互联网的感召而来，共襄盛举：秀发抚背随风飘散，不羁不荡的度仰望星辰大海是征途。
而葵花在工作中也学习到重要的知识：什么是优秀的程序员？

他们必须解除夜郎自大，保留巨人般的胸怀，面对需求，必须心平气和而不是暴戾乖张，必须勤劳少眠，还要忠贞不渝，潜心职守，绝不违逆。这就是程序员的菁华、荟萃、英杰！程序之花！如若不能如此，正义得不到捍卫，柔弱得不到领引，娇花得不到保护。
晨会后，葵花两点将与另外一个部门的同学合作。这让他稍微头疼。因为另一个部门的有着十万大山里座山雕的气质，每次发现问题，都腰缠两口赤铜键盘，腾出门来，拉一个群，点起名精壮马龙，擂鼓摇旗，厉声高叫道：何方鼠辈，拿出这样的代码来敷衍爷爷，欺吾手中的不利否？
简短的问题往往需要庞大的答复，然而人生又有很多事情是无法解释清楚的，例如对产品经理说清楚这个需求的实现难点，例如告诉老大“我觉得这个老板需求可能没那么有效果”。

到了晚上点，原本想下班，但旁人都还在努力，自己终于惭愧了。磨蹭到晚上点，吃了加班餐，羞愧而回。
他走出大楼，深呼吸，好一口泥土香啊。这是较为繁华的区域，色相喧嚣：穿着皮草的女孩子，鲜红的双唇弯弯翘起，笑盈盈的扭动腰肢与黑丝，粉裙飞扬着霓虹灯一片色彩斑斓。
远处理发店的黄毛小弟，嬉皮士般的招揽年轻女孩。一位老太太推着破旧的自行车，走到垃圾桶旁，伸手在里面掏弄着。然后紧紧衣领，再走向下一个垃圾桶。地铁口小平头紧身花裤，宽松黑恤的黑车司机叫喊：还差一位，还差一位，上车就走。
回到租房地，葵花两点会在网上浏览各种兔粮，作为纯良且被动贞洁的修士，他怀着复杂而深刻的感情：文艺青年的淫靡生活太令人……羡慕了。他叹了一口气，第次想起路上看到的昌平名媛们的黑丝袜与红亮高跟鞋。烦闷。

日升日落，清河的潮水涨涨跌跌。每天深夜，都有马龙疲惫拖拽着身体，带着自己的键盘来到清河清洗。很多年后，被后辈们称为“清河洗键录”。
白天无数的马龙努力的撬动键盘，风油精当酒，如鸡伏卵，如燕营巢的写着代码；谱写着互联网  亿进化合奏曲，轰隆隆的交响乐流淌在合租房，流淌在  块钱的煎饼果子，流淌在沙丁鱼地铁中，流淌在绿中介的签字笔中。这些人构成了燕京城的 ，他们是  上细密的针脚，日以继夜的工作，当天安门的白鸽迎着红彤彤的朝阳舞动时，翅膀悄无声息的划过  中的字符，马龙们的理想在碎梦中飞向亚特兰大、飞向阿拉斯加、飞向西伯利亚的育空河，那里有着一望无际的自由与洒脱。
如果有一天，你能站在中关村的创业大街上，你会发现：无数的马龙在奔跑，有多线程的，有多进程的，还有的开着加速，他们揣着西少爷肉夹馍当干粮，赶去约会一个叫流量的女孩，并献上赤道几内亚土著般的热吻；他们在春风中用语言写着情书当然还有  、、 、排名不分先后，然后塞进漫天的柳絮中，等待金黄秋天的发版。整个大街聒噪的如同乡村重金属摇滚。
代码需要爱，马龙苦行僧也需要爱；然而半年前  交了一位男朋友。对于葵花而言，这不仅仅是被动贞洁的延续，更重要的是粉红幻想的破灭：梦里寻她千百度，豁然回首却只有在灯火阑珊处。这段经历让羞涩的葵花两点长大了，以前他涉世未深，不喝酒，也不吃香菜，如今终于了然：酒的味道也不错。
买房议题不可避免的来到。房价是一把快刀，将社会阶层如嫩豆腐干净利落的划分出来；是快排算法，精准的对人群进行排序：套、套、套。。。。是对未来理想的高斯模糊；是对纷杂凌乱投资方法的傅里叶变换，统一成“买房致富”。的连环雷炸肿的炒房客的脸，一秒钟变猪头是一种怎么样的体验？然而终究还在担心，究竟会不会降。
找个男女朋友的话题，是过年回家餐桌上的白噪声，任你对音频了如指掌，在三姑大姨的面前也无法降噪；是情绪的率；是上延期的需求。每次相亲都如同答辩，美貌与智慧并重的只有一次展现的机会。然而你内心清楚：并不是躯体寻找最便捷的依偎就可以了的。

葵花两点终于意识到当年刚到燕京的想法多么的荒唐：幻想自己是新时代的开荒者，燕京如日本妻子一般温顺，人生的布朗运动会伴随着好运来一场阶级跨越。而实际上是这样的：个体只是大河中的一滴水，晶体中的一个原子，壁垒与趋势已经固定，责任感和努力跑不过房价的高铁。
但这也没什么大不了。 燕京的马龙苦修，嗷嗷鞭打灵魂的考验多了去了。习惯了满面风沙的追赶需求，也就有了迎风尿三丈的坚韧与习惯。酒照喝，肉照吃，随风混日月，管他东南西北中。如果他们出生在火影的忍者村，必然都是了不起的上忍，天天吃着小米椒烤猛犸肉。
越来越多的朋友离开燕京。越来越多的同事成为记忆。他们好像是清河中的波光，一点一滴的闪烁在浪花中，跳跳跃跃中渐行渐远，直至只出现在朋友圈中，甚至完全消失。为他们送行的只有月亮。
人生如秋风过，一生只见了这一回。

葵花有时候很焦虑，甚至是越来越焦虑，情绪激动，面色潮红，试图用力的拍打天上的云彩，大喊“开门开门”，想将遮挡星空的这一层大气撕开，想把时光撕开，想把记忆中越来越清晰，或越来越朦胧的面孔，从时光来拉出来。愿温暖的阳光洒在她他们洋溢着幸福的笑容的脸上，大家在华年中跳着蹒跚的大河之舞，踢踏踢踏的敲响全球最金贵的土地，也踏在假装坚强的心上。老中青的马龙们，阳光下银发反出来的光，不仅仅是自己的人生，也是昌平之光，西二旗之光，五道口、中关村之光。

十年过去，老了，头发白了。遇到喜欢的人，并结婚了。越来越喜欢以前的生活：梅雨中，老式居民楼的红砖墙头摆着几大盆盛放的胭脂色月季，雨水打在铁蓬上劈劈啪啪 又落在花上再弹开。 这样生动的寂静，此后再未遇见。
偶然在下班的人流中驻足，仰望夕阳，一道阳光将马路一劈为二，光柱下有点点碎尘，人群往来在这碎尘之中。燕京的人与事就在这晦暗与喧嚣中倏忽明灭，看了一天代码的眼睛微微酸涩。
想成为成为一朵花，与另外一朵花并立。我们一笑而过，再笑而落。

完。上结尾曲，背景是清河的水浪打浪，一大群红斑大闸蟹，蓝鳌皮皮虾伴舞：
开门见白水
清风入怀来
吹我罗黄衣
弄她青丝斜
明月生白露
碎光压碧水
生愿为莲子，
长居一处屋，
………………………………………
然则哟
水厚雨密 ，风卷白浪，何以遽行
水流融融，鱼交花影，何以忧思
水明颜丽，思惘殷怀，何以遂心
愿求来世为双桨
一系红绳不分离
流水为生船为家
桃花在侧云在天
浊酒行三行五列
红袖弄鱼绿裙摇
然则哟
船尾在后人在前
更有流光在前头
流光弄你青丝乱
流光弄你红变白
流船逐水亦逐年
催我青丝亦白雪
我上流船追流光
拉起青枝赶年来
长路悠悠无有尽
百结同心行行止
百结同心行行止
…………………………………………………
何日水卷光亦回
一系红绳永不离
他年红女来烹酒
不要走那三万丈长风路
不要随那九万里白水流
白水乌船对笑颜
愿得一生一瞬过
两人携手成翁妪
相关推荐
做开发十年，我总结出了这些开发经验导语： 本文描述了发布者和调用者这两在层是如何实现的。

作为的四大组件之一，作为进程之间静态数据传递的重要手段，其在系统级别的应用中起了重大的作用。毫无疑问，核心机制之一也是，但是和其它大组件又有区别。因为涉及数据的增删查改，当数据量比较大的时候，继续用做容器效率会比较低，因此它还使用了匿名共享内存的方式。
但是有一个问题是，的提供者进程不再存活时，其他进程通过读一个非常简单的数据时，都需要先把提供者进程启动起来除非指定=，这对用户是相当不友好的。又因为其是间接通过进行数据操作，所以效率也远不如直接操作。因此在用户中，不是很建议经常使用。不过对于系统级的，它统一了数据操作的规范，利是远大于弊的。
发布
当进程第一次启动时候会调用
  {
                  {
                     
                }
            }
 当中有时，进行的发布
   =
             
             {
              =   
                         
              =  {
                 = 
                
            }
        }
         {
            
                 
        }    {
        }
这个方法先简单过一下，后面会继续说
   = 
                 = 
                    
                 = 

     {
               =   
               = 
              =  {
            }  {
                 
            }
        }
这里两步把通过转换成的对象，并放于中。并根据的不同，把发布进程的保存在一个叫的成员变量中，方便第二次调用同一个时，无需重新到中去查询。  
 
   = 
               =      {
                  = 
                
                  = 
                  =  {
                      =   
                     
                      = 
                       =      {
                         
                    }
                      = 
                     
                      = 
                      =      {
                          ==  {
                            
                             = 
                            
                            
                        }
                    }
                      {
                        ____ 
                    }
                    
                }
            }
可以看到，会遍历所有的，然后调用把信息保存起来，这块接下来说。保存好之后，先去看看之前是不是已经有过的，如果已经有过的，不再重复。再说说这个，这个和中的不太一样，这个是一个成员实例，非真正的。看看和。


  {
             
        }  {
               = 
             
        }
 
  {
             
        }  {
               = 
             
        }
可以看到，发布的实际会根据或存在不同的中。如果是单例，则分别存到相应的 中，否则就根据存到相应的中。这样发布的过程就完成了，其他进程需要使用的时候将会在按需读取。
跨进程数据操作
当我们跨进程调用数据时候，会先调用获取用户进程的
 
    {
         
    }
而这个在每个进程中都存在有且唯一的实例，其在构造函数中就已经初始化了，其初始化的实际对象是。
 =    
这个是活在调用者进程中的，它是作为一个类似桥梁的作用。以插入为例：


  = 
          ==  {
                  
        }
         {
              = 
              =   
            
             
        }    {
             
        }  {
            
        }
 问题就转化成了，拿到其他进程的的对象，有了对象就可以跨进程调用其方法了。

 _ {
             
        }
           = 
          =  {
              
        }
 校验其，其必须为。

      {
             
                    
                     
        }
这里面有个特别的函数会传递一个的参数给，这意味本次连接是的。那和非的区别是什么呢？这么说吧：
 ：若使用过程中，要是挂了，你的进程也必挂。
 ：若使用过程中，要是挂了，你的进程不会挂。但你会收到一个的异常，可进行容错处理。
继续往下。

    =    
          =  {
             
        }

          = 
         {
             = 
                       
        }    {
        }
          ==  {
             
        }

         =   
                   
         
这里面分了三步，、寻找自身进程的缓存，有直接返回。 、缓存没有的话，寻找中的。、，又到了这个方法。怎么个法？还是一会儿再说。
 寻找自身缓存
  {
               =   
               = 
              ==  {
                 
            }
              = 
              = 
            
              = 
              =  {
                 
            }
             
 这一步就是读取我们发布时提到的中的缓存。当记录存在且进程存活的情况下则在引用计数不为空时则继续增加引用计数。
缓存不存在，则去中找

 
 =  
 {
     =    {
                      = 
                     = 
                     
                }
}
     {
          || 
                  == 
    }
 是提供保护数据的接入访问的。一般情况下，不同进程的访问只能通过来进行，但那是有些情况是可以允许访问者在自己的进程中创建本地来进行访问的。
这种情况是在必须相同的前提下，要么同一进程，要么设定了为。
  {
             = 
                    __ | ___ 
            
              =   
             =  
              =    {
                 
            }
              = 
                              

                      =    =  {
                          {
                             
                            
                        }
                    }  {
                         = 
                                    
                                 
                                           
                    }
                } 
            }
             
        }
 这块步骤比较多，挑重点就是，先从的对象中获取缓存。获得后如果没有，则通知其进程其。如果进程不存在，则新孵化一个进程。

回到第三步中的
   
               
                 
 可以看到，这个方法里面有个参数，其中包含、、，这几个很重要的参数。
：当参数为空的时候，说明缓存为空，也就意味着是进程启动的时候调用发布。当缓存不为空的时候，还得做一些处理。
：包含的一些信息，不能为空。
：为的时候对于自身进程来说或系统的，是永久的，也就是不会被的。
  = 
         
          ==  ||  ==  {
             {
                   = 
                 = 
                    
                 = 
                  ==  {
                     
                }
                 
            }    {
            }
        }  {
             = 
        }
 这部分在发布的时候已经说了，缓存为的时候，一个实例。
 
          {
              = 
              =  {
                  =   
                  = 
                  =  {
                     = 
                }  {
                     =  
                     = 
                     = 
                     =   
                     
                     
                }
                 = 
            }  {
                
            }
 如果不等于，则意味着是一个实例的情况，这时候还是先去获取缓存，没有的话再真正地一个实例，并把通过方法把相关信息存入中，这个就是对应发布提的那个方法。
 
          {
            
            }  {
                  = 
                  =  {
                      {
                         
                         {
                            
                                     
                        } 
                    }
                }  {
                      = 
                              
                      {
                         =     
                    }  {
                         = 
                                     
                                     
                    }
                     
                }
                 = 
            }
 如果等于空，也就意味着有缓存或者时候出现的异常。那先从计数中取缓存，如果缓存不为空之前有过计数了，这时候如果设置了，那就说明不需要计数。如果为，则把计数器数据转移到一个新引用上，同时销毁旧的。
如果缓存为空，说明之前没有计数过。那还是先通过把信息保存到中。这时候如果为，把和非的数据都瞎设置了一个，反正用不到。。。否则就相应的，并把计数器放入相应的缓存中。最后再把返回。
再回到方法中，我们拿到了的引用，就可以执行相应的方法了。在国内公有云厂商上搭建一套 的难度相信做的童鞋都会很清楚，并非它的搭建有多少难度，只是很多细节需要注意。
腾讯云，，为什么选择来做这个实验，除了是我的东家这里我没收任何广告费啊，其实对原生态保留得最好，所以很多种实验解决方案在都是支持的。
所以，今天我就来讲讲如何在构建 ，讲到这里，就有童鞋要问了，你们不是提供了级别的吗？为啥子还要自建这么麻烦呢？这位童鞋问得很好，级别的属于直接应用级别的，而大部分的传统过度到互联网目前很多企业正在处于这个阶段的公司需要的是半灵活半自动的架构，自已采购服务器搭建运维成本过于高，管理纬度相对多，风险也相对高点，所以折中的方案是把以下的架构交给我们的消防队员来做，以上的架构完全可以自已来搞嘛。
，话不多说，以下是今天需要的服务器信息本例中会开通外网流量主要为了方便，但是生产环境中不建议使用外网带宽：



编号
服务器名称

角色
计费方式
配置








包年
无外网





共享存储
包年
无外网





 
随量计费
 或  均可 无外网





 
随量计费
 或  均可 无外网



涉及架构如下：

，开始动手：
一创建实验内网：
 
：这里创建私有网络的好处就是在购买时可以选择这个私有网络作为机器内网网络，并且互相可以通讯，这样就可以组建起一个网络，解决了中所需要的、等问题。
二创建实验所用的项目组仅仅作为标记用，进入用户中心选择新建项目：

：这里是一个使用习惯问题，支持一个账户下多个开发商同时进行操作，这个项目组除了可以区分服务器类型、归属，同时也可以计算消耗。
三购买服务器：

：


选择自定义镜像，见槽点：




、选择自定义镜像，见槽点：



四    设置策略
好，现在开干，先设置策略这里是第一个需要注意的点，我们需要把本地管理员账户密码的复杂度提升上去，否则重启后无法登录至少字母、数字、特殊字符：
 
五改名后重启
接下来我们拿这台机子改名后重启请注意改名后，相当于这台机子已经不能在控制台进行操作了，大部分国内公有云并不支持从主机内改名、改密码操作：
 
六搭建域
，现在我们开始搭建域，在服务器管理器添加角色与功能，接着按截图指引进行安装：
 


勾选域服务

其他按照默认的来

七安装完成后，点击提升服务器为域控制器：
 
输入域名
 
输入恢复模式密码非域管理员密码：
 
正式环境这里的文件请选择备份目录
 
确认设置并开始安装
 
域搭建完成
 
八将三个节点加入到域中
首先把内网改为的地址，修改完成后尝试下，如果能通，则加域可以成功：
 
由于采用了私有网络，所以开机后会提示需要更改为以内网为名字的主机名，这里直接进行更改主机名即可
 
重启后加域完成
 
附录，本篇槽点：

高的本地盘大小是随配置的增加而增加，对于存储要求高的数据库来说，这明显设计不合理

国内大部分公有云为了提升生产速度，所以一般会把这一步给忽略，内置是相同的



所以同一批产生的虚拟机是无法加入域，关于这一点提供了解决方案目测适用于所有平台：
所以在这一块，在国内公有云的标准操作其实是：
先生产一台虚拟机————提交为自定义镜像——然后再以该镜像作为基础镜像去生产
 
完成后关机并提交为自定义镜像记得点击“执行制作镜像”：
 
然后把之前用公共镜像生产的虚拟机重新用自定义镜像生产：
 

相关推荐
 【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群 【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群 【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群背景
消息队列，在业务解耦、削峰填谷、流量控制、广播消息等场景下都有很好的应用，已经成为很多企业系统内部通信重要手段。
现有常用的开源消息中间件有、、等，但各自有着不同的应用场景和特点，例如，注重的是消息的吞吐量，不保证消息存储的可靠性以及一致性，因此多用于日志系统数据的上报；能保证消息可靠存储投递，但性能较差。
  是腾讯云开发的一款高可靠、高可用、高性能的分布式消息队列服务，具有低耦合、消息可靠、强一致性、可扩展性等特点，支持消费模型、消息回溯、延时消息、发布订阅、路由广播、消息加密等一系列功能，以满足更多的应用场景。
相对，更多注重消息高可靠的应用场景，例如金融、交易、订单等业务；相比，在可用性和性能上做了很大的优化和提升。更详细的对比，请参考官网介绍。
本文先简单介绍底层的架构实现，然后着重结合的功能特点来介绍的实践案例，让大家快速理解和上手的开发。
底层架构


整体架构如上图所示，每个由三个节点副本组成，保证消息的可靠存储以及高可用性，且基于算法保证数据的一致性。单个 在理论中优先保证了，当中过半数节点都正常工作时，才能进行消息的生产消费。
更详细介绍可参考这里。
实践案例
一、广播拉取消息模型
支持队列和主题两种模型，如下所示：


其中，模型是一对一的消息拉取模式，端主动消息；而模型，也称发布订阅模型，是一对多的消息推送模式，服务端广播消息时，根据各个订阅地址主动推送消息给。两种模型基本能满足大部分应用场景了，对比如下：

模型，端可以灵活根据自身能力去消费消息，消息实时性依赖的消费速度，如果消费速度比生产速度慢，会引起大量消息堆积。

模型，服务端主动推送消息，消息实时性比较高，但要求性能上能及时处理大量推送过来的消息，并且在发生故障的时候可能会导致丢消息有消息重发策略做基本保障。


对于模型，有以下特殊场景需求：

端想根据自身能力去消息

创建订阅的时候需要暴露端的接收消息的地址，但在一些企业内网、网络等特殊情况下，无法推送到，只能用方式获取消息。


针对以上特殊场景，结合和两种模型实现了一对多的广播拉取消息模型，如下所示：

的订阅者可以是一个实例，发布消息后，会自动将消息推送到，然后和使用模型一样去消费消息即可。
         
_ = ___ _
_ = 
_ = 
_ = 
__
二、长轮询
对于模型，消费者需要获取消息，但问题是：消费者不知道队列什么时候有消息，只能不停轮询请求去，如果轮询间隔时间短，在队列长时间没有消息时会耗费消费者请求资源且效率低，如果轮询间隔时间长，则消费速度慢，消息实时性低，且造成消息大量堆积。
针对以上问题，解决方案是设计了长轮询功能。例如，假设设置队列长轮询时间为

当消费者消息时，如果队列中有消息则马上返回

如果队列暂时没有消息，消费者请求不会马上返回，而是会等待阻塞：当内有新的生产消息到达队列，会马上将消息投递给正在阻塞等待的消费者，消费者端感知就是阻塞的请求被唤醒并且收到消息返回；当内队列都没有消息，则请求返回告诉消费者当前队列没有消息。


         
 = 
_ = __
三、延时消息
提供延时消息功能：消息发送到队列后，从入队时间算起，消息在设置的延时时间后才对消费者可见，即才能被消费者消费到。延时消息功能可以很轻松实现一些定时任务的应用场景。

如上图所示，根据延迟消息功能实现的定时任务检查告警系统。
       
_ =    
 = _
 = 
__ 
四、消息回溯
提供类似于的消息回溯能力，已经消费删除的消息是可以通过回溯来重新消费的。目前支持指定回溯时间点，在这个时间点开始被删除的消息可以重新消费到。此功能在一些金融业务对账、业务系统重试等场景下有很好的实用性。
最大可回溯时间点 = 当前时间  设置的可回溯时长。消息生产时间在这个值之前的不可回溯，之后的可回溯，如下图所示：

详细介绍参考官网说明。
       
   
 =   
_
五、路由匹配
 模型提供类似于的消息路由匹配功能，在消息广播基础上实现了消息的自动分发。

订阅者可以指定，即路由规则，如上所示，星号可以匹配一个单词，井号可以匹配一个或多个单词。例如，生产者发布一个消息，且消息的路由键是””，那么该消息只会推送给消费者；如果=””，则消息会推送给和；如果=””，则消息只会推送给。
详细介绍参考官网说明。
        
_ = ___ _
_ = 
_ = 
_ = 
_ = 
__

 = 
 =   
__ 
六、超大消息传输
目前的队列消息大小最大限制为，而当消息大小不超过时，收发消息的最大限制分别为正常的有特殊需求可调整，当消息大小超过而小于时，不保证收发消息的性能。因此，支持大于的消息只是为了考虑业务偶尔传输少量大消息且不想做消息分片的应用场景。
一般来说，的消息限制大小基本能满足大部分业务场景需求了，但在某些特殊场景下，消息数据大于甚至大于时，业务和如何支持这种超大消息的传输呢？这里有两种解决方案：
消息分片。类似数据包分片传输原理，生产者对消息分片标记后分别发送到队列，消费者从队列取出所有分片消息进行组装。个人方案如下：

每个消息分为和两部分。其中，就是原消息分片后的内容，包含三个标记：业务指定消息的号，唯一记录一个消息的值，具有同一个号的消息分片才会在消费端重新组装；分片序号从开始，记录一个消息分片的次序编号，消费端依据分片序号依次组装消息；下一分片是否存在的标记，如果是，说明消息包还不完整，否则消息组装完毕。



由于可能存在多个消费者，不同分片可能被不同接收到，为了能够组装分片，需要一个集中式的地方存储所有分片并最终组装成完整的消息包，但无疑大大增加了系统设计的复杂度。

代理存储是腾讯云的对象存储服务。类似编程中的指针原理，方案如下具体代码实现参考附件：

生产者先把超大消息的数据以文件形式上传到，并返回消息文件的 地址；
生产者将地址作为消息发送到队列中；
消费者从队列中读取消息，判断消息内容是否是的地址信息，如果是，则根据地址从下载相应的消息文件，并从文件中读取出超大消息的数据。


七、消息加密传输
腾讯云提供秘钥管理服务，能对数据进行安全加密。消息加密功能有以下两种方案：
 客户端加密方案。客户端发送消息时，根据设置的的秘钥调用生成数据秘钥接口，会返回数据秘钥的明文以及加密后的密文，使用明文对消息进行本地加密，然后将加密的数据和密文作为消息 发送给；消费者接收消息时，先获取消息中的密文，调用接口解密不必每次均调用，可做缓存得到对应的明文，最后根据明文本地解密密文数据即可。具体代码实现参考附件。

服务端加密方案。该方案，由服务端和服务打通，自动对消息加解密，用户无感知，例如，用户通过接口发送消息，由自动加密后存储，通过接口接收消息时，对消息自动解密后返回给用户。此功能正在开发中。
结语
更多功能正在开发中，例如，死信队列、顺序消息等，欢迎体验：作者简介： 英正明， 腾讯专家工程师。

在鹅厂，面试总是必不可少的。
在面试的时候，我常常用下面的方法考查代码和算法的能力。
发送面试通知时，会通知面试者会需要在白纸上手写或者笔记本上不借助编写代码。当对面试者能力一无所知的时候，我最常问的第一个问题是：如何计算两个日期年月日之间相差多少天，需要在纸上或者文本编辑器上编写代码。允许面试者使用任何他最擅长的语言。
这个问题问完，有一些想半天还没动笔的，我会把问题简化为如何计算同一年两个日期月日之间相差多少天。减分。
有些人会问年的范围。加分。并限定从年开始。
有些会问结果是否存在负数。加分。
然后开始写函数声明，函数声明都写不出来的，直接。有些会用个结构体表示日期，有些直接在函数声明中使用整数分别表示年月日，都一样。
写实现的时候就五花八门了。
不能写出使用数组表示每月天数的，减分。
能把相差多少天首先抽象成计算某一天比如开始的天数，然后两个数字相减。大加分。
有些没有使用上面的方法，而是使用天数直接相减。只要能正确实现，大加分。
能把闰年函数抽象出来的，加分。我不要求写出闰年函数实现，只要能抽象，我会告诉面试者不需要写这个函数实现。
实现写完，看函数的实现，如果整体逻辑混乱的基本都是面试者尝试直接通过日期加减获得间隔的天数，大减分。
如果整体逻辑清楚，但是有小问题的例如月份下标出错，有泄漏的，小减分。
另外，整个面试过程中，如果碰到不清晰的，能主动及时沟通的，加分。
然后根据这个题目的答题情况，选择后面的题目。

相关推荐
腾讯云总监手把手教你，如何成为工程师？
分析份招聘需求，如何成为工程师？作者介绍：黄日成，手游戏中心后台开发，腾讯高级工程师。从事服务后台开发年多，主要负责手游戏中心后台基础系统、复杂业务系统开发，主导过手游戏公会、企鹅电竞对战系统等项目的后台系统设计，有丰富的后台架构经验。

引言
作为文章”《从三次握手说起  浅析协议中的疑难杂症》”的姊妹篇，很早就计划写篇关于的文章，尽管协议远没协议那么庞大、复杂，但是，要想将描述清楚，用好却要比难不少，于是文章从下笔写，到最终写成，断断续续拖了好几个月。
说起网络 ，大家自然会想到  ，用的最多也是 ， 在大家的印象中是作为  的补充而存在，是无连接、不可靠、无序、无流量控制的传输层协议。的无连接性已经深入人心，协议上的无连接性指的是一个  的 ，可以向多个  的    ，  发送数据包，也可以接收来自多个  的  的数据包。实现上，考虑这样一个特殊情况：  在 _只往   的 _ 发送数据包，并且只接收来自 _ 的数据包，把  通信双方都固定下来，这样不就形成一条单向的虚”连接”了么？
 的”连接性”
估计很多同学认为的连接性只是将通信双方都固定下来了，一对一只是多对多的一个特例而已，这样连接不连接到无所谓了。果真如此吗？其实不然，的连接性可以带来以下两个好处：
 高效率、低消耗
我们知道系统有用户空间用户态和内核空间内核态之分，对于处理器以及大多数其它处理器，用户空间和内核空间之前的切换是比较耗时涉及到上下文的保存和恢复，一般种情况下会发生用户态到内核态的切换：发生系统调用时、产生异常时、中断时。那么对于一个高性能的服务应该减少频繁不必要的上下文切换，如果切换无法避免，那么尽量减少用户空间和内核空间的数据交换，减少数据拷贝。熟悉编程的同学对下面几个系统调用应该比较熟悉了，由于是基于用户数据报的，只要数据包准备好就应该调用一次或进行发包，当然包的大小完全由应用层逻辑决定的。
细看两个系统调用的参数便知道，比的参数多个，这就意味着每次系统调用都要多拷贝一些数据到内核空间，同时，参数到内核空间后，内核还需要初始化一些临时的数据结构来存储这些参数值主要是对端_的地址信息，在数据包发出去后，内核还需要在合适的时候释放这些临时的数据结构。进行通信的时候，如果首先调用绑定对端_的后，那么就可以直接调用来给对端_发送数据包了。用户在之后，内核会永久维护一个存储对端_的地址信息的数据结构，内核不再需要分配删除这些数据结构，只需要查找就可以了，从而减少了数据的拷贝。这样对于方而言，该通信在内核已经维护这一个“连接”了，那么在通信的整个过程中，内核都能随时追踪到这个“连接”。
      
              _ _             
_      _  
               
_      
              _               
     _
              _ _
_     _ 
               
_      
              _               
     
              _  _
 错误提示
相信大家写   程序的时候，有时候在第一次调用  给一个    发送  数据包时，接下来调用  或继续调的时候会返回一个  错误。对于一个无连接的  是不会返回这个错误的，之所以会返回这个错误，是因为你明确调用了  去连接远端的 _ 了。那么这个错误是怎么产生的呢？没有调用  的   为什么无法返回这个错误呢？
当一个   去  一个远端 _ 时，并没有发送任何的数据包，其效果仅仅是在本地建立了一个五元组映射，对应到一个对端，该映射的作用正是为了和  带外的  控制通道捆绑在一起，使得   的接口含义更加丰满。这样内核协议栈就维护了一个从源到目的地的单向连接，当下层有对于非协议，可以是其它机制错误信息返回时，内核协议栈就能够准确知道该错误是由哪个用户产生的，这样就能准确将错误转发给上层应用了。对于下层是协议的时候， 错误信息返回时， 的包内容就是出错的那个原始数据包，根据这个原始数据包可以找出一个五元组，根据该五元组就可以对应到一个本地的过的 ，进而把错误消息传输给该 ，应用程序在调用接口函数的时候，就可以得到该错误消息了。
对于一个无“连接”的，系统调用后，内核在将数据包发送出去后，就释放了存储对端_的地址等信息的数据结构了，这样在下层的协议有错误返回的时候，内核已经无法追踪到源了。
这里有个注意点要说明一下，由于和下层协议都是不可靠的协议，所以，不能总是指望能够收到远端回复的包，例如：中间的一个节点或本机禁掉了， 调用就无法捕获这些错误了。
 的负载均衡
在多核多的服务器中，为了充分利用机器资源，服务器大多采用模式，服务的机制  ，不管是预先建立进程池，还是每到一个连接创建新线程进程，总体都是源于的变体。然而对于却无法很好的采用机制，由于的无连接性、无序性，它没有通信对端的信息，不知道一个数据包的前置和后续，它没有很好的办法知道，还有没后续的数据包以及如果有的话，过多久才会来，会来多久，因此无法为其预先分配资源。
 端口重用_、_
要进行多处理，就免不了要在相同的地址端口上处理数据，_允许端口的重用，只要确保四元组的唯一性即可。对于，在的时候所有可能产生四元组不唯一的都会被禁止于是，相同的情况下，套接字处于_状态下的，才可以重复绑定使用；对于，由于通信两端中的本端已经明确了，那么只允许从来没过的对端在明确不会破坏四元组唯一性的才允许发送包；对于监听端，四元组的唯一性油端保证就了。
通过连接来保证四元组的唯一性，一个请求过来，进程完这个请求后当然不一定要单独进程，就可以分配资源来标识这个连接，接着就可以分发给相应的进程去处理该连接后续的事情了。这样就可以在多核服务器中，同时有多个进程来同时处理多个并发请求，从而达到负载均衡，资源能够被充分利用。
的无连接状态没有已有对端的信息，使得没有一个有效的办法来判断四元组是否冲突，于是对于新来的请求，无法进行资源的预分配，于是多处理模式难以进行，最终只能“守株待兔“，按照固定的算法查找目标 ，这样每次查到的都是 列表固定位置的。只是简单基于目的和目的端口来进行查找，这样在一个服务器上多个进程内创建多个绑定相同地址_，相同端口的 ，那么你会发现，只有最后一个创建的会接收到数据，其它的都是默默地等待，孤独地等待永远也收不到数据。这种只能单进程、单处理的方式将要破灭高效的神话，你在一个多核的服务器上运行这样的程序，会发现只有一个核在忙，其他核心处于空闲的状态。创建多个绑定相同地址，相同端口的程序，只会起到容灾备份的作用，不会起到负载均衡的作用。
要实现多处理，那么就要改变 查找的考虑因素，对于调用了的 而言，由于其具有了“连接”性，通信双方都固定下来了，那么内核就可以根据元组完全匹配的原则来匹配。于是对于不同的通信对端，可以查找到不同的 从而实现多处理。而对于端，在使用_选项 以上内核，这样在进行 查找的时候，源地址和源端口也参与进来了，内核查找算法可以保证：

 固定的四元组的数据包总是查找到同一个 ；

 不同的四元组的数据包可能会查找到不同的 。


这样对于不同发来的数据包就能查找到不同的 从而实现多处理。这样看来，似乎采用_、_这两个选项并利用内核的查找算法，我们在多核服务器上多个进程内创建多个绑定相同端口，相同地址的 就能做到负载均衡充分利用多核资源了。然而事情远没这么顺利、简单。
  列表变化问题
通过上面我们知道，在采用_、_这两个选项后，内核会根据数据包的元组来查找本机上的所有相同目的地址，相同目的端口的中的一个的位置，然后以这个位置上的作为接收数据的。那么要确保来至同一个 的数据包总是被同一个来处理，就需要保证整个链表的所处的位置不能改变，然而，如果链表中间的某个挂了的话，就会造成链表重新排序，这样会引发问题。于是基本的解决方案是在整个服务过程中不能关闭 当然也可以全部 都掉，从新创建一批新的。要保证这一点，我们需要所有的 的创建和关闭都由一个进行来管理，进程只是负责处理对于的网络任务，为此我们需要在创建的时候要带有标志_。
 和结合  的模型
到此，为了充分利用多核资源，进行的多处理，我们会预先创建多个进程，每个进程都创建一个或多个绑定相同端口，相同地址_、_的 ，这样利用内核的 查找算法来达到的多进程负载均衡。然而，这完全依赖于内核处理 查找时的一个算法，我们不能保证其它的系统或者未来的内核不会改变算法的行为；同时，算法的查找能否做到比较好的均匀分布到不同的 ，每个处理进程只处理自己初始化时候创建的那些 负载是否均衡是个问题。于是，我们多么想给建立一个模型，按需分配 来处理。
在高性能编程中，对于 而已有比较成熟的解决方案，天然的连接性可以充分利用等高性能机制，采用多路复用、异步处理的方式，哪个进程空闲就去连接请求来处理，这样就可以达到比较高的并发，可以极限利用资源。然而对于 而言，由于整个就一个 ，接收并响应所有的请求，于是也就不存在什么多路复用的问题了。 无法充分利用的高性能机制的主要原因是， 只有一个 来接收和响应所有的请求。然而如果能够为每个都创建一个并虚拟一个“连接”与之对应，这样不就可以充分利用内核层的查找结果和的通知机制了么。端具体过程如下：

 创建  设置为和、同时本地地址__ = _ _ _ _ _ _ _ _  _     _  

创建 ，并将_放到中 并监听其可读事件_ = __ = |_ = ___  __ _ __ = __ _  

_返回时，如果_返回的事件是_，调用接收第一个包并根据返回的地址 创建一个新的_与之对应，设置_为和、同时本地地址_，然后上返回的地址_       _ __ = _ _ _  _ _ _  _ _  _      _  _      _  

将新创建的_加入到中并监听其可读等事件_ = _ = _ __ __ _  _

当_返回时，如果_返回的事件是_ 那么就可以调用来接收特定的包了_        _ _


通过上面的步骤，这样   就能充分利用  的事件通知机制了。第一次收到一个新的  的  数据包，就创建一个新的 和这个对应，这样接下来的数据交互和事件通知都能准确投递到这个新的  了。
这里的和结合方案，有以下几个注意点：

 要使用固定的和端口和端通信，也就是需要本地 。  如果没有本地 ，那么在发送数据包的时候，可能是不同的了，这样如果 端的_ 的是的_端口，那么当的_端口的数据包来到时，内核不会投递到_，相反是投递到_。由于需要和 一样的地址和端口，因此_和_是必须的。

 要小心处理上面步骤中返回前，已经有多个包到达端的情况。  如果没处理好这个情况，在返回前，有个包到达端了，这样会出两个_和_分别到，那么后续的的到达的时候，内核会投递包给_和_中的一个


上面的和结合的模型有个不好处理的小尾巴也就是上面的注意点，这个小尾巴的存在其本质是和元组没有必然的对应关系，也就是的无连接性。
   模型   模型之按需建立处理进程
为了充分利用多核  为简化讨论，不妨假设为核，理想情况下，同时有个工作进程在同时工作处理请求。于是我们会初始化个绑定相同端口，相同地址_、_的   ，接下来就靠内核的查找算法来达到请求的负载均衡了。由于内核查找算法是固定的，于是，无形中所有的被划分为类，类型的所有请求全部被路由到工作进程的 由工作进程来处理，同样类型的的请求也全部被工作进程来处理。这样的缺陷是明显的，比较容易造成短时间的负载极端不均衡。
一般情况下，如果一个  包能够标识一个请求，那么简单的解决方案是每个    的工作进程 ，自行  出多个子进程来处理类型的  的请求。这样每个子进程都直接  就  了，拿到  请求包就处理，拿不到就阻塞。
然而，如果一个请求需要多个  包来标识的情况下，事情就没那么简单了，我们需要将同一个  的所有  包都路由到同一个工作子进程。为了简化讨论，我们将注意力集中在都是类型的多个请求数据包到来的时候，我们怎么处理的问题，不同类型的数据包路由问题交给内核了。这样，我们需要一个进程来监听 的可读事件，进程监听到可读事件，就采用_选项来数据包，如果发现是新的、的包，那么就一个新的进行来处理该的请求。具体如下：

 进程监听__的可读事件： = __ =    当可读事件到来，   为。探测一下到来的包是否是新的的包   _    查找一下_是否为该创建过进程了。

 如果没有查找到，就处理进程来处理该请求，并将该信息记录到_中。查找到，那么，回到步骤

 每个子进程，保存自己需要处理的信息。进程同样也监听__的可读事件。  当可读事件到来，   为。探测一下到来的包是否是本进程需要处理的的包   _    _  比较一下和_是否一致。


该模型很别扭，过多的探测行为，一个数据包来了，会”惊群”唤醒所有子进程，大家都去一把，最后只有一个进程能够取出包来处理。同时到来的数据包只能排队被取出。更为严重的是，由于的排他唤醒，可能会造成死锁。考虑下面一个场景：
假设有 、、、和  共四个进程都阻塞在  调用上， 的一个新的  包过来，这个时候，四个进程会被同时唤醒，比较神速，赶在其他进程前将  包取走了 可以处理 的  包，于是其他三个进程的  扑空，它们 、、和  按序全部阻塞在  上睡眠 、 排在  前面先睡眠的。这个时候，一个新  的  包到来，由于的排他唤醒这个时候只有会从的睡眠中醒来，然而而却不能处理该请求包。如果没有新包到来，那么一直留在内核中，死锁了。之所以是排他的，是为了避免“承诺给一个进程”的数据被其他进程取走了。
通过上面的讨论，不管采用什么手段，的模型总是那么别扭，总有一些无法自然处理的小尾巴。的多路负载均衡方案不通用，不自然，其本因在于的无连接性、无序性无法标识数据的前续后继。我们不知道  还在不在，于是难于决策虚拟的”连接”何时终止，以及何时结束掉出来的子进程我们不能无限  吧。于是，在没有好的决策因素的时候，超时似乎是一个比较好选择，毕竟当所有的裁决手段都失效的时候，一切都要靠时间来冲淡。

文章来源公众号 小时光茶社  里存储的结构化数据导出到  体系做离线计算是一种常见数据处置手段。近期有场景需要做  到  体系的实时导入，这里以此案例做以介绍。
 作为商业化的数据库解决方案，自发性的获取数据库事务日志等比较困难，故选择官方提供的同步工具     来解决。
安装与基本配置
环境说明
软件配置



角色
数据存储服务及版本
版本





源服务器

       



目标服务器
 
        




以上源服务器上安装在用户下，目标服务器上安装在用户下。
注意
导出到异构的存储系统，如，，等以及对应的不同平台，如，，等官方都有提供对应的 版本，可在这里或者在旧版本查询下载安装。
 源端基础配置
将下载到的对应版本放在方便的位置并解压，本示例源端最终的解压目录为。

配置环境变量
这里的环境变量主要是对执行的用户添加相关的环境变量，本示例为用户添加的环境变量如下：_文件
 _=
 __=__
 =___

打开归档模式使用如下命令查看当前是否为归档模式
    
                 
              
             _
        
       
             
如非以上状态，手动调整即可
    以身份连接数据库 
  立即关闭数据库
  启动实例并加载数据库，但不打开
   更改数据库为归档模式
   打开数据库
     启用自动归档

打开日志相关基于辅助日志等进行实时传输，故需要打开相关日志确保可获取事务内容。通过一下命令查看当前状态：
  _ ___  
  
 
如果以上查询结果非，可通过以下命令修改状态：
    
      

创建复制用户为了使里用户的复制权限更加单纯，故专门创建复制用户，并赋予权限
       
        
 
    
 
最终这个帐号的权限如下所示：
    __  =
                                                        
                                                     
                                                        
                                                         
                                                  
                                                   
                                                    
                                                    
                                                       
                                                       
                                                          
                                                       
                                                        
                                                  
                                                        
                                                       

初始化进入的主目录执行，进入命令行
___   
     
   ____
          
          
 ___ 
执行 进行目录创建
 ___   
     
                   
                      
                  
               
                   
         
                 
                   
                      

创建模拟复制库表模拟建一个用户叫，密码，同时基于这个用户建一张表，叫_。
          
 
    
 
  

   _  _  
 


目标端基础配置
将下载到的对应版本放在方便的位置并解压，本示例目标端最终的解压目录为。

配置环境变量这里需要用到相关的库，故需要配置环境变量以及相关，并引入的相关库文件，参考配置如下：
 _=_
 __=_____
 _=

初始化目标端的初始化和源端类似进入的主目录执行，进入命令行
    
     
                   
                      
                  
               
                   
         
                 
                   
             
             
                        


 源配置
实时传输到集群，，等的基本原理如图：根据如上原理，配置大概分为如下步骤：源端目标端配置管理器；源端配置进程进行日志抓取；源端配置进程传输抓取内容到目标端；目标端配置进程复制日志到集群或者复制到用户自定义的解析器将最终结果落入到集群。
配置全局变量
在源端服务器主目录下，执行到命令行下，执行如下命令：
 ___      
   
 ___    
 

其中变量没有的话可以用  来编辑添加即可编辑器默认使用的
配置管理器 
在命令行下执行如下命令：
 ___    
 
 
    
   
说明：即的默认监听端口；动态端口列表，当指定的端口不可用时，会在这个端口列表中选择一个，最大指定范围为个；重启参数设置表示重启所有进程，最多次，每次间隔分钟；即文件的定期清理在命令行下执行 即可启动管理进程，通过 可查看状态
 ___   
     ___
添加复制表
在命令行下执行添加需要复制的表的操作，如下：
 ___    _
        _
 ___    _
          _
     _ 
配置  进程
配置进程命令行下执行如下命令：
 ___    
 

 _ = 
 _ = _
  
 
 _
说明：第一行指定进程名称；动态解析；设置环境变量，这里分别设置了数据库以及字符集；  即连接数据库的帐号密码，这里使用中特意创建的复制帐号；定义文件的保存位置以及文件名，注意这里文件名只能是个字母，其余部分会补齐；即复制表的表明，支持通配，必须以结尾接下来在命令行执行如下命令添加进程：
 ___     
 
最后添加文件的定义与进程绑定：
 ___     
 
可在命令行下通过命令查看状态：
 ___   
                
           
      
                           
                       
配置  进程
进程本质上来说也是一个，只不过他的作用仅仅是把文件传递到目标端，配置过程和进程类似，只是逻辑上称之为进程在命令行下执行：
 ___    
 


  
   
 
 _
说明：第一行指定进程名称；即禁止与交互，我们这里使用逻辑传输，故禁止即可；动态解析；  即连接数据库的帐号密码，这里使用中特意创建的复制帐号；和即目标端的服务的地址以及监听端口；即目标端文件存储位置以及名称分别将本地文件和目标端的文件绑定到进程：
 ___     
 
 ___     
 
同样可以在命令行下使用查看进程状态：
 ___   

               
           
     
                         
配置  文件
与，集群，，等等之间数据传输可以定义为异构数据类型的传输，故需要定义表之间的关系映射，在命令行执行：
 ___    
 _
  
 _
在主目录下执行：  完成之后会生成这样的文件_，将这个文件拷贝到目标端的主目录下的目录即可。
目标端的配置
创建目标表目录
这里主要是当目标端为目录或者表或者数据库时需要手动先在目标端创建好目录或者表，创建方法都类似，这里我们模拟实时传入到目录，故手动创建一个接收目录即可 –  
配置管理器
目标端的管理器和源端的配置类似，在命令行下执行：
     
 
 
    
   
配置 
即复制可追溯的一个偏移量记录，在全局配置里添加表即可
       
 
保存即可
配置  进程
在的命令行下执行：
     
 
 _
    =
     
 
 _  _
说明： 定义进程名称；即在中在源服务器上做的表映射文件； 即定义一些适配性的库文件以及配置文件，配置文件位于主目录下的；即复制任务的报告生成频率；为以事务传输时，事务合并的单位，减少操作；即源端与目标端的映射关系其中=的配置中，最主要的几项配置及注释如下：
=    中类型
=    中目标
=    中存储主目录
=    中传输模式，即为一次传输一次，为一次事务传输一次
=    中文件传输格式
=    中使用到的库的定义
具体的   支持参数以及定义可参考地址
最后在的命令行下执行：
        
 
将文件与复制进程绑定即可
测试
启动进程
在源端和目标端的命令行下使用 进程名的形式启动所有进程。
启动顺序按照源——目标——源——源——目标来完成。
检查进程状态
以上启动完成之后，可在源端与目标端的命令行下使用 进程名来查看所有进程状态，如下：源端：
 ___   
     ___
 ___   
               
           
      
                           
                       
 ___   
              
           
     
                         
目标端：
     
        

    
              
           
            
     
                         
所有的状态均是即可。当然也可以使用 来查看所有进程状态
测试同步更新效果
测试方法比较简单，直接在源端的数据表中，，操作即可。由于到集群的同步是异构形式，目前尚不支持操作。源端进行操作
  

    _
  
  _
                                           
   
                                           
 _                                          
   _ 
  
 
 
查看源端文件状态
___    
         
查看目标端文件状态
          
         
查看中是否有写入
   _
               
____
注意：从写入到的文件内容看，文件的格式如下：
_ _
很明显的数据已准实时导入到了。导入的内容实际是一条条的类似流水日志具体日志格式不同的传输格式，内容略有差异，本例使用的。格式为操作符 数据库表名 操作时间戳 当前时间戳 偏移量 字段名称 字段内容 字段名称 字段内容，如果要和的表内容完全一致，需要客户手动实现解析日志并写入到的功能，这里官方并没有提供适配器。目前腾讯侧已实现该功能的开发。当然你可以直接把这个的路径通过的方式在上建外表 达到实时导入的目的。
总结
   实现了实时同步到体系的接口，但得到的日志目前仍需应用层来解析关系型数据库如时对应版本已实现应用层的解析，无需人工解析。的几个主要进程，，，配置方便，可快速配置与异构关系存储结构的实时同步。后续如果有新增表，修改对应的，和进程即可，当然如果是一整个库，在配置上述个进程时，使用通配的方式即可。
附录
到体系的实时同步时，可在源端和进程配置不变的情况下，直接在目标端增加进程的方式，增加同步目标，以下简单介绍本示例中增加同步到的配置方法。本示例中，进程都是现成的，无需再添加。只需要在目标端增加同步到的进程即可。
在的命令行下执行：
     
 
 _
    =
    
 
 _  _
进程和导入到的配置类似，差异是调用不同的配置。这个配置的主要配置如下：
 =  类型
 = 
=__ 相关配置
 = 的名称，无需手动创建
 = 传输文件的格式，支持，等
 =     中传输模式，即为一次传输一次，为一次事务传输一次
= 相关库文件的引用
引用的__定义了的相关配置如下：
= 的地址
=
= 压缩类型
= 重连延时

=
=
=
=
以上配置以及其他可配置项可参考地址：
以上配置完成后，在命令行下添加文件到进程并启动导入到的进程
      
 
 
    
     
  
    

             
           
            
     
                         
检查实时同步到的效果，在源端更新表的同时，使用客户端自带的脚本去查看这里配置的这个下的消息：
   _ 
  
 
 
目标端的同步情况：
       
  
{___
_

{_}}
{___ 
_

{_}}
显然，的数据已准实时同步到。从头开始消费这个发现之前的同步信息也存在。架构上可以直接接，等直接消费消息进行业务逻辑的处理。从实时同步到其他的集群中，官方最新版本提供了，，和，相关配置可参考官网给出的例子配置即可。

参考文档：更多数据库文章，请关注腾讯云数据库公众号 


相关推荐 【腾讯云的种玩法】伪分布式搭建基于腾讯云大数据套件的异常问题排查过程作为一名程序员，业余时间你会写个爬虫 抓数据？抓图片？或者是自己搭个应用号，玩的不亦乐乎。也许做为一名的你，可以在云上施展你的项目。
抽出一些业余时间，把你在腾讯云上研究的玩法写下来吧，我们会选择最优秀的玩法给予奖品和云计算资源奖励，你将有机会获得、、机械键盘等奖励。
只要你有好的想法，我们就敢满足你的愿望！

目前第期腾讯云的种玩法征集文章已全部评审完毕，有位参与者，总共篇文章参与玩法比拼
一等奖：李斯达《在腾讯云上创建您的 》系列二等奖：焦远东《激发云力量打造我的云端工具集》三等奖：屈政斌《 部署  实践》等系列文章
主要按照以下维度评分，有腾讯技术专家黄希彤等评定一、二、三等奖

产品创新性
实用性
可借鉴性
教程详细程度
与云计算能力的结合

虽然活动结束了但是大家想要获得云资源或腾讯云布道师积分，可以在腾云阁发布有关腾讯云的文章并且发链接至邮箱_即可获得奖励喔

腾讯云布道师积分：仅腾讯内部作者可获得。本文作者： 
该库是应对当前  提出的  概念而写的，以链式  来完成  相关的操作。

安装
  
 或者使用 
  

首先说明一下，我们要完成的目标：

注册 
添加  的缓存
实现推送，并在用户点击后关闭，然后聚焦当前页面

整个代码如下：
  {}  

 = {
    
      = 
    
    ={
          成功
    }
      请求推送权限
    ={
         用户同意
         
        ={
              关闭当前 
              聚焦窗口
        }
    }
}
使用
基本使用可以分为三块：

 主要处理主线程    的相关行为。例如：注册，发送消息等
 用来处理  缓存的相关操作。
 根据  来完成主线程  的消息推送 {}  
重点推荐使用  在内部细节中，处理了兼容性和权限请求的问题，这里我们具体落实到场景当中。



 原意是  。如果大家还不熟悉，推荐可以参考：  全面进阶。
权限申请

={

}
 它返回的是  对象。
销毁  
={
     
}
 它返回的是  对象。
  更新
 
消息通信
我们了解   是继承  。在   中，我们可以使用 进行通信，那么在  中同样是可以的。       
 如果你想接受此次  回复的信息，可以直接加上  的写法。
  接收  回复的信息
      
={
     
}

  回复信息

 {
         
       
}
 另外， 还可以通过  挂载的  向  发送信息。如果有这种需求，可以直接监听  事件。
={
     接收  发送的消息
     
}
推送订阅
当你想要使用  相关的内容时，可以调用  方法。如果，你不是很理解   的概念，可以参考  讲解 
 下面的  根据自己生成进行替换
__

首先这里有两个概念，一个是 表，一个是 行。每一个网站缓存可以有多个表，这完全取决于你自己的结构。该库是形式，即，不能使用变量名来缓存表。例如：
   = 
  正常执行没问题

  第二次使用无效
 后面会介绍一种简便的方法进行简写。
缓存处理主要分为两块：

 
 添加行记录
 删除表
 复制整个表
 重命名整个表
 打开表

 

 查询行
 删除行
 更新行


 本身就是一个函数，构造格式为：

 打开某个具体的表
  具体打开的表名

打开表
构造函数为：

 执行打开操作 
 


={}


添加行
向表中添加具体的缓存行，添加方式有三种：

 
  可以为  或者通过  实例化得来的。

 

  里面就是  的数组。 

 

  和上面一样，没啥区别
  需要存储的结构。一般是通过  生成，或者直接通过 ={} 获得的。

重命名复制表
重命名的格式为：


  表的新名字
 


={
     
}
={
     
}
 复制表的格式为：

 
  指定的表名
 

 将  表复制给 

={
     
}
={
     
}
删除表
格式为：


 
={
  
}
={
  
}



 本身也是一个函数

 
 || 该参数可以为 ，或者 注意不能带上 。当为  时，是直接匹配对应的行记录，而为 时，则是使用  的格式，可以匹配多个或者模糊匹配。

 只匹配  文件


={
  
  }
 通过  匹配：
  =  


    ={
      
    }
简写
如果每次都  这样调用，会让人觉得比较冗长，那么有没有什么好的办法解决呢？这里提供了一个工具函数  用来生成可重复使用的对象。
  提取 
 _ = 
_  

_  
 然后，可以提取 
  _ = 

_   

_   
删除行
  删除所有  文件


={
     
}
={
     
}
更新行
 
={
 更新根目录文件
  
  
  ={
    
    
  }
}

 提供了  相关的 。其主打的是链式调用，不需要过多的关注  内部细节。
权限申请

={
      === 
      === 
      === 
}
消息推送
使用消息推送的时候，可以不用嵌套在 里面，它内部已经做了权限的处理。
  纯文字版
   

 带 
   
推送后自动关闭
   
   后自动关闭
推送点击
   
={
    
}
  还提供了其它的事件监听






上面这些方法都可以进行链式调用。
    
={}
={}
={}
 用户点击推送这一行为，我们可以加上额外的处理，例如，打开页面，聚焦页面等。
   
={
    
     聚焦页面
    
     打开新的页面
    
}




 
 


原文链接作者：郑小辉
团队：腾讯移动品质中心

引言
白盒测试覆盖率低的最主要原因，是大部分人都没有测到层，只测试了层部分，导致覆盖率低。因为大部分代码都在层。
亲，你是不是认为层的都测试不了尼，下面来看看吧
一 、层 可测性预研
、可测性
级 是全局共享的，通常用作数据传递，数据共享，数据缓存等。
因此级也是需要测试的，也是可测的。
样例代码如下：

验证版本号等等。

结论：级可测。
、可测性
可测性，主要预研，里的：
方法是否可测不管被层调用的；
 方法是否可测；
 方法是否可测；
相关依赖是否可；
接收参数的是否可测。
方法是否可测不管是否被层调用的。
业务代码中， 方法通常被层调用，如下，被按键时调用，如果按一般的测试层是测试不到的。
如果你又想通过反射来测试：
要么你要得到当前业务的该实例，这个一般人是得不到的；
要么又想自己创建一个来反射，但因机制，即使你能创建出来，那这个实例也不是业务的该实例。方法依赖其他逻辑照样测试不了。
 
可测性预研结果：可测。
测试样例代码如下：
先创建的，然后通过获得实例。再获取该。
 
有了对象，再反射调用就可以了，最后验证结果。

结论：里的 方法可测。
 方法是否可测。
 方法是否可测。
得到了实例，和均可以直接调用。 
 
结论：里的 返回和返回 可测。
相关依赖是否可。
如下，业务中，有第三方库的调用，这个调用里存在异步线程的处理。如果不，将不能得到正确的验证结果。

后的测试样例代码如下：  

结论： 可。
接收参数的是否可测。
如下，业务代码中，启动时含有对启动是否有参数的逻辑。如含有对应参数，则上报一个统计点。
那么这个逻辑是否可测呢？  

测试样例代码如下： 

结论：接收参数的可测。
至此，里大部分逻辑都可测。
、可测性
进程是的一个单独进程，里面的不少逻辑，同样很多人人为不可测，那实际尼？
测试样例代码如下：

结论：可测。
、广播可测性
假设有一业务广播如下： 

同样的，广播测试样例代码如下：  
 
结论：可测。
二、层单元和接口测试
纯的逻辑测试，是大部分人做的，但这里所要说的，还包含一些依赖环境的测试，比如，一个方法依赖了 的，等，可能有人就又认为这些测不了了。
单元测试：包含类的测试，主要测试多条件入参的测试，比如一个类方法 不同参数的传入测试。
接口测试：包含调用链路的测试，包括不同层次的链路调用。主要测试集成路径，不同参数的路径。
单元测试和接口测试，大部分做过白盒的都懂，这里就不细说。
主要说说 ，涉及部分的如何测试。
如下业务代码：
被测方法 调用了 ，而该方法用了环境。 

思路还是：掉，然后塞进去，最后验证。
测试样例代码如下：

三、异步线程可测性
被测方法调用了异步代码时，测试代码将无法正确的验证结果。导致用例失败或不可测。
因此，如何能让异步代码可测，也是如何让现有代码更可测的一部分。
异步线程的可测性思路。
思路一：通过来实现，这个需要改业务代码，一般不怎么用。
思路二：掉异步对象，反射进去，当执行异步时，通过调用拦截获得对象，立即调用。
思路三： 的方式，一般都和回调一起，先掉父调用，拦截回调，直接调用回调。
下面说下使用较多的 异步和的测试样例：异步的测试样例。
业务有如下图异步线程：
 
测试样例如下：      

 样例：
如下，业务代码使用了内部来处理消息，当执行到 因为是异步，测试用例无法获取正常结果。
 
然而 有如下多个方法，难道每个都要针对性处理么？那这样比较麻烦。

翻看 源码部分，发现如下调用关系： 

各方法最终都调用了 ，因此只要这个就可以了。
测试样例代码如下：  

四、函数回调可测性
思路：依然是通过，并拦截函数调用，获取对象直接调用。
、参数传入回调方式可测性
如下业务代码：原始回调被包装了次回调，最后以参数方式传入。
 
测试样例代码：

五、简单举例
 白盒测试，支持多种框架，常用的用和。
其中静态方法的只能用。
   ：可用和。
  ：只能用。
、环境
 的：                   

、   

、普通和 
普通对象的调用：                                   

普通的：
 
、静态和 
静态要的，需用。网上很多资料。这里就不细说了。
六、反射调用与执行
但遇到  标示的逻辑时，不能直接调用。但又想把他测试覆盖，可用反射来执行。
一般主要在：
、不好从上层介入的地方： 标示的逻辑，被层调用，比如被事件调用，你不好从上层介入。
、多参数或分支较多：标示的逻辑，入参较复杂，内部分支和逻辑较多，想以单测函数来先保证正确性。
业务代码的反射和 库代码的反射，用法差不多。就写在一起了： 是已经封装好的反射工具类。

七、业务代码直接调用
在模式和方案选型时，是否能直接调用业务代码，也是一个衡量项。最好是能直接调用。能省事省力。
、业务代码直接调用

未完待续
搜索微信公众号：腾讯移动品质中心，获取更多测试干货！作者 | 张宏顺编辑 | 京露

张宏顺，年硕士毕业后在桑达电子集团工作，负责车牌自动识别系统及车辆自动检测系统设计；年加入华为，主要负责图像处理及视频压缩相关算法工作；年月加入腾讯，现主要从事视频和图片压缩相关工作。擅长图像处理、模式识别及视频压缩、、等。

背景与目标
当前视频编码中应用最广泛的是而作为下一代的视频编码算法，在压缩性能上可以再节省的码率，优势很明显，但对转码机器性能要求较高，实时编码场景时，其高压缩性能不能被充分利用。
在中有、、、、、、等配置，其中，对应复杂度最高，压缩性能也最好，不同配置下，对视频测试，编码速度如下表

由上可见，对于视频的实时转码大于帧，高配也只能做配置，但相对于还有的压缩空间可用。因此，我们期待在保证压缩比少量下降情况下，显著提高视频编码的处理能力。
问题分析
一个标准的编码框架如下：

一帧图像送入到编码器，先经过帧内或帧间预测之后，得到预测值，预测值与输入数据相减，得到残差，然后进行变化和量化，得到残差系数，然后送入熵编码模块输出码流，同时，残差系数经反量化反变换之后，得到重构图像的残差值，然后和帧内或者帧间的预测值相加，从而得到了重构图像，重构图像再经环内滤波之后，进入参考帧队列，作为下一帧的参考图像，从而一帧帧向后编码。
其中，帧内或帧间预测从最大编码单元，  开始，每层按照叉树，一层层向下划分，做递归计算。对于每一个，由 到， 到，及到，总共三个层次的递归过程，然后再逐层比较，选出最优模式的划分情况。
下图是所有划分情况计算之后，选出的最优结果：

从上图示例来看，有些块做了第一层划分之后，就找到了最优的模式，不必再向下计算。
下图是个常见场景的大小划分情况：


由图可见，的情况不需要做，及后面、的计算；的情况不需要做，及后面的的计算；的情况不用再做的计算，因此可以看出，划分这块有很大的优化空间。
但是，如果不计算，没有比较又怎知道当前计算是不是有用呢？因此，问题就转化为怎么找出一个能根据周围已计算块的信息，来预测当前块划分的方法。
解决方案
我们采用了支持向量机和算法相结合来预测当前块的划分情况。流程如下：

如上图所示，当前开始做深度划分计算时，先对当前块做 和 的计算，然后判断当前最优模式的残差是否为，如果为，说明当前块是 块，直接结束深度计算，如果非，则需要深度划分计算。接着，判断当前块的深度是否为，如果非，则执行算法，再根据的结果进一步判断当前块是否做层的计算；如果当前块为，则根据当前块和相邻块来提取特征向量，然后根据当前块的类型，分别调用对应帧或者帧的预测模型；最后预测，并根据预测结果来决定是否做层的计算。
． 算法
结合周围块的划分情况，来推测当前块的划分情况
首先，要计算相邻块对应深度的平均代价，然后计算当前块对应深度的已编码的平均代价，最后判断当前块是否要做的深度划分。
第一步：计算相邻块对应深度的平均代价，深度为时记作__。
取当前 的相邻位置的，如下图所示，左边、上边、左上角，及右上角个的划分信息，每个的所有深度对应的代价。

计算周围相邻块的平均代价，相邻块按照左边上边左上右上=的权重计算。
第二步：计算当前内，已经确定的，相同深度代价的平均值，深度为时记作__。
如果已确定的个数为，则代价=，否则为所有块代价的平均值。
其他深度的计算类似，不再累述。
第三步：预测当前是否做进一步分割。
定义阈值_ =  __   ___
当前做完和计算之后，其最优模式对应的代价，记作__，如果__  _则认为当前不需要再做进一步深度划分，否则需要作进一步划分。
= 和 = 的判断过程与等于相同，均取相同深度的代价进行判断。
． 支持向量机预测模型
支持向量机  ，是一种监督式学习的方法，可广泛地应用于统计分类以及回归分析。

基本原理是将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边，建有两个互相平行的超平面。建立方向合适的分隔超平面使两个与之平行的超平面间的距离最大化。其假定为，平行超平面间的距离越大，分类器的总误差越小。
的关键在于核函数。低维空间向量集通常难于划分，解决的方法是将它们映射到高维空间。但这个办法带来的困难就是计算复杂度的增加，而核函数正好巧妙地解决了这个问题。  
预测的准确度与用于训练和预测的特征向量关系很大，由于整个编码过程中帧占得比值较小，因此只对帧间深度划分进行预测，特征向量由个特征值组成，即当前块的代价，的失真，当前块的方差及量化系数，左边块的代价和深度信息，及上边块的代价和深度信息组成。
模型训练之前，要将训练样本映射到 区间，然后采用内核，对帧、帧分开训练，最后分别得到帧、帧的预测模型。这里我们采用开源软件 可从 获取来实现。
模型训练好后，就可以在编码时使用。首先，创建编码器的同时，将预测模型加载到编码器中；然后，在计算当前块时，提取上述个特征值，组成预测样本，归一化后，送给预测模型，经简单计算，会输出或两种情况。如果为表示当前需要做层的计算，否则，当前块不再做进一步划分，直接进入划分模式。
效果
我们在上采用        ，对每层做快速选择。多序列测试结果表明，相比于 模式，采用此方案，编码速度提升了，压缩性能下降了，因此视频编码的处理能力得到显著提升。
将机器学习引入到编码器优化上，是个较大胆的尝试，而且从效果来看，编码速度提升显著，且压缩性能下降不多，说明该方法是可取的，这也为后面编码器优化拓宽一个好的思路。

相关推荐
榨干运营成本：一亿之后再省两亿实现效果基于  的跨平台播放器实现搭建公众号后台
以腾讯云自带的为例：
安装以及需要的扩展；由于默认软件库为，需要加入第三方库，来方式安装；当然，也可以直接在官网下载源码包编译；上述过程可以使用一键安装脚本来完成，运行前，记得修改的密码；
     _

安装包管理工具：官方步骤：
       
       _  ===  {    }  {     }  _
     
      

为了方便，做以下几个设置：
       
      
         
       

同时将需要将软件库改到中文镜像：
    全局修改方式
         

借助第三方开源，较快搭建基础框架：以为例： 文档：官方文档使用管理，进入第一步安装的根目录： 
       

此时即可初始化工程，生成：调试可以按照上述结构组织代码，但是生产环境中，建议库还是放到非目录下；
编写：直接见示例代码可以和 等框架集成：

申请微信公众号
目前个人只能申请订阅号：微信公众平台官方链接： 微信公众平台申请过程就不一一描述了需要完成个人身份认证，以及绑定管理微信号；申请好公众号之后，设置公众号后台响应入口，以及得到之类的信息：
修改配置和测试：
根据上述申请到的公众号_写入对应的变量中：
关注公众号，开始调试：

调试通过之后，即可按照需求实现功能了。
善用腾讯云其他功能：
本次入门教程使用腾讯云提供的云服务器，还有一些额外的工具可以使用：
使用：为了安全考虑，微信后台和我们自己公众号后台交互请求，建议是使用
申请页面
请记住，腾讯云的证书时免费的，免费的，免费的重要的事情说三遍
平台提供的安全工具：购买云主机时，可以勾选对应的安全功能，开通后，可以在这里管理入口进行管理。
 
好了，本次入门便介绍到这里，后续更精彩。。。文中涉及的脚本可到这里下载

相关推荐
如何正确配置   服务器？
如何使用腾讯云服务器作为微信公众号的开发空间
零基础微信机器人实践云技术对个人开发者的影响的视频相关的开发，大概一直是整个生态，以及 中，最为分裂以及兼容性问题最为突出的一部分。摄像头，以及视频编码相关的，一直对这方面的控制力非常差，导致不同厂商对这两个的实现有不少差异，而且从的设计来看，一直以来优化也相当有限，甚至有人认为这是“上最难用的之一”
以微信为例，我们录制一个的文件，对于来说，大体上是遵循这么一个流程：

大体上就是从摄像头输出的帧经过预处理之后，送入编码器，获得编码好的视频流。
上面只是针对视频流的编码，另外还需要对音频流单独录制，最后再将视频流和音频流进行合成出最终视频。
这篇文章主要将会对视频流的编码中两个常见问题进行分析：

视频编码器的选择硬编  软编？
如何对摄像头输出的帧进行快速预处理镜像，缩放，旋转？

视频编码器的选择
对于录制视频的需求，不少都需要对每一帧数据进行单独处理，因此很少会直接用到来直接录取视频，一般来说，会有这么两个选择




我们来逐个解析一下

是 之后推出的用于音视频编解码的一套偏底层的，可以直接利用硬件加速进行视频的编解码。调用的时候需要先初始化作为视频的编码器，然后只需要不停传入原始的数据进入编码器就可以直接输出编码好的流，整个设计模型来看，就是同时包含了输入端和输出端的两条队列：

因此，作为编码器，输入端队列存放的就是原始数据，输出端队列输出的就是编码好的流，作为解码器则对应相反。在调用的时候，提供了同步和异步两种调用方式，但是异步使用的方式是在 之后才加入的，以同步调用为例，一般来说调用方式大概是这样摘自官方例子：

简单解释一下，通过获取输入队列，然后调用获取输入队列空闲数组下标，注意会有几个特殊的返回值表示当前编解码状态的变化，然后再通过把原始数据送入编码器，而在输出队列端同样通过和获取输出的流，处理完输出数据之后，需要通过把输出还给系统，重新放到输出队列中。
关于更复杂的使用例子，可以参照下测试里面的使用方式：
从上面例子来看的确是非常原始的，由于底层是直接调用了手机平台硬件的编解码能力，所以速度非常快，但是因为对整个硬件生态的掌控力非常弱，所以这个有很多问题：
 颜色格式问题
在初始化的时候，在的时候，需要传入一个对象，当作为编码器使用的时候，我们一般需要在中指定视频的宽高，帧率，码率，帧间隔等基本信息，除此之外，还有一个重要的信息就是，指定编码器接受的帧的颜色格式。这个是因为由于根据其采样比例，分量的排列顺序有很多种不同的颜色格式，而对于的摄像头在输出的帧格式，如果没有配置任何参数的情况下，基本上都是格式，但对的在设计和规范的时候，显得很不厚道，过于贴近的层了，导致了格式并不是所有机器的都支持这种格式作为编码器的输入格式！
因此，在初始化的时候，我们需要通过来查询机器上的实现具体支持哪些格式作为输入格式，一般来说，起码在的系统上，这两种格式在大部分机器都有支持：

两种格式分别是和，如果机器上只支持格式的情况下，则需要先将摄像头输出的格式先转换成，才能送入编码器进行编码，否则最终出来的视频就会花屏，或者颜色出现错乱
这个算是一个不大不小的坑，基本上用上了进行视频编码都会遇上这个问题
 编码器支持特性相当有限
如果使用来编码视频流，对于格式来说，会有一些针对压缩率以及码率相关的视频质量设置，典型的诸如  ，     ，合理配置这些参数可以让我们在同等的码率下，获得更高的压缩率，从而提升视频的质量，也提供了对应的进行设置，可以设置到中这些设置项

但问题是，对于，  这些设置，在大部分手机上都是不支持的，即使是设置了最终也不会生效，例如设置了为，最后出来的视频依然还会是
这个问题，在以下的机器几乎是必现的，其中一个可能的原因是，在源码层级了的的设置：

直到之后才取消了这段地方的

这个问题可以说间接导致了编码出来的视频质量偏低，同等码率下，难以获得跟软编码甚至那样的视频质量。    
 位对齐要求
前面说到，这个在设计的时候，过于贴近层，这在很多的实现上，是直接把传入的，在不经过任何前置处理的情况下就直接送入了中。而在编码视频流的时候，由于的编码块大小一般是，于是乎在一开始设置视频的宽高的时候，如果设置了一个没有对齐的大小，例如，在某些上，最终编码出来的视频就会直接花屏！
很明显这还是因为厂商在实现这个的时候，对传入的数据缺少校验以及前置处理导致的，目前来看，华为，三星的出现这个问题会比较频繁，其他厂商的一些早期也有这种问题，一般来说解决方法还是在设置视频宽高的时候，统一设置成对齐位之后的大小就好了。

除了使用进行编码之外，另外一种比较流行的方案就是使用进行软编码，是用于一些视频帧的预处理。这里主要是使用作为视频的编码器。

基本上被认为是当今市面上最快的商用视频编码器，而且基本上所有的特性都支持，通过合理配置各种参数还是能够得到较好的压缩率和编码速度的，限于篇幅，这里不再阐述的参数配置，有兴趣可以看下这两篇文章对编码参数的调优：
==


则是由思科开源的另外一个编码器，项目在年开源，对比起来说略显年轻，不过由于思科支付满了的年度专利费，所以对于外部用户来说，相当于可以直接免费使用了，另外，直接内置了，作为其在中的视频的编解码器使用。


但对比起，在高级特性的支持比较差：

只支持到  
多线程编码只支持 ，不支持 的多线程编码

从编码效率上来看，的速度也并不会比快，不过其最大的好处，还是能够直接免费使用吧。
软硬编对比
从上面的分析来看，硬编的好处主要在于速度快，而且系统自带不需要引入外部的库，但是特性支持有限，而且硬编的压缩率一般偏低，而对于软编码来说，虽然速度较慢，但是压缩率比较高，而且支持的特性也会比硬编码多很多，相对来说比较可控。就可用性而言，在的系统上，的可用性是能够基本保证的，但是不同等级的机器的编码器能力会有不少差别，建议可以根据机器的配置，选择不同的编码器配置。
帧的预处理
根据最开始给出的流程，在送入编码器之前，我们需要先对摄像头输出的帧进行一些前置处理
缩放
如果设置了的预览大小为的情况下，在中输出的帧直接就是的大小，如果需要编码跟这个大小不一样的视频，我们就需要在录制的过程中，实时的对帧进行缩放。
以微信为例，摄像头预览的数据，需要编码大小的视频。
最为常见的做法是使用这种的_函数进行直接缩放，效果性能比较好的一般是选择__算法：

在 上，直接使用来进行缩放的时间基本上都需要，对于我们需要录制的来说，每帧处理时间最多就左右，如果光是缩放就消耗了如此多的时间，基本上录制出来的视频只能在上下了。
很明显，直接使用进行缩放是在是太慢了，不得不说简直就是里面的渣渣，在对比了几种业界常用的算之后，我们最后考虑实现使用这种快速缩放的算法：

我们选择一种叫做的局部均值算法，前后两行四个临近点算出最终图片的四个像素点，对于源图片的每行像素，我们可以使用直接实现，以缩放分量为例：

上面使用的指令每次只能读取和存储或者位的数据，对于多出来的数据，只需要用同样的算法改成用语言实现即可。
在使用上述的算法优化之后，进行每帧缩放，在 上，只需要不到就能完成了，而对于缩放质量来说，的__算法和上述算法缩放出来的图片进行对比，峰值信噪比在大部分场景下大概在左右，质量也足够好了。
旋转
在机器上，由于摄像头安装角度不同，出来的帧一般都是旋转了或者度，如果最终视频是要竖拍的，那一般来说需要把帧进行旋转。
对于旋转的算法，如果是纯实现的代码，一般来说是个  复杂度的算法，如果是旋转的帧数据，在 上，每帧旋转也需要，这显然也是不能接受的。
在这里我们换个思路，能不能不对帧进行旋转？
事实上在文件格式的头部，我们可以指定一个旋转矩阵，具体来说是在 里面指定，视频播放器在播放视频的时候，会在读取这里矩阵信息，从而决定视频本身的旋转角度，位移，缩放等，具体可以参考下苹果的文档_
通过，我们可以很轻松的给合成之后的文件打上这个旋转角度：

于是可以在录制的时候省下一大笔旋转的开销了，
镜像
在使用前置摄像头拍摄的时候，如果不对帧进行处理，那么直接拍出来的视频是会镜像翻转的，这里原理就跟照镜子一样，从前置摄像头方向拿出来的帧刚好是反的，但有些时候拍出来的镜像视频可能不合我们的需求，因此这个时候我们就需要对帧进行镜像翻转。
但由于摄像头安装角度一般是或者度，所以实际上原生的帧是水平翻转过来的，因此做镜像翻转的时候，只需要刚好以中间为中轴，分别上下交换每行数据即可，注意跟要分开处理，这种算法用实现相当简单：

同样，剩余的数据用纯代码实现就好了， 在上，这种镜像翻转一帧 数据大概只要不到
在编码好视频流之后，最终处理就是把音频流跟视频流合流然后包装到文件，这部分我们可以通过系统的  或者来实现，这部分比较简单，在这里就不再阐述了


雷霄骅的专栏大名鼎鼎雷神的博客，里面有非常多关于音视频编码相关的学习资料，入门必备。也祝愿他能够在天堂安息吧
  包含了一些使用的示例代码，初次使用可以参考下这里
  一个系列教程，讲述了一些常用指令使用方法。上面在介绍缩放的时候使用到了，事实上大部分音视频处理过程都会使用到，以帧处理为例，缩放，旋转，镜像翻转都可以使用来做优化
开源的一个处理库，上面只针对视频帧缩放的算法，而对于通用的压缩处理，可以直接使用这里的实现，对比起的速度快上不少上一篇文章介绍了  的原型，这篇会简单地介绍下  容灾架构的演变。我们知道，后台系统绝大部分情况下并没有一种唯一的、完美的解决方案，同样的需求在不同的环境背景下甚至有可能演化出两种截然不同的架构。既然架构是多变的，那纯粹讲架构的意义并不是特别大，这里也会讲下  容灾设计时的一些思考和权衡，希望对大家有所帮助。
容灾设计
接下来我们会介绍  的容灾架构。我们知道，后台系统绝大部分情况下并没有一种唯一的、完美的解决方案，同样的需求在不同的环境背景下甚至有可能演化出两种截然不同的架构。既然架构是多变的，那纯粹讲架构的意义并不是特别大，期间也会讲下  容灾设计时的一些思考和权衡，希望对大家有所帮助。
 的容灾模型在五年中进行过一次比较大的重构，提升了可用性、机器利用率等方面。其中不管是重构前还是重构后的架构， 一直遵循着两条架构设计原则：

保持自身架构简单

避免对外部模块的强依赖


这两点都是基于  可靠性考虑的，毕竟  是一个与整个微信服务端正常运行息息相关的模块。按照我们对这个世界的认识，系统的复杂度往往是跟可靠性成反比的，想得到一个可靠的系统一个关键点就是要把它做简单。相信大家身边都有一些这样的例子，设计方案里有很多高大上、复杂的东西，同时也总能看到他们在默默地填一些高大上的坑。当然简单的系统不意味着粗制滥造，我们要做的是理出最核心的点，然后在满足这些核心点的基础上，针对性地提出一个足够简单的解决方案。
那么， 最核心的点是什么呢？每个  的  申请要递增不回退。这里我们发现，如果  满足这么一个约束：任意时刻任意  有且仅有一台  提供服务，就可以比较容易地实现  递增不回退的要求。
图 两台  服务同个  造成  回退。 读取到的  序列为、、
但也由于这个约束，多台同时服务同一个号段的多主机模型在这里就不适用了。我们只能采用单点服务的模式，当某台  发生服务不可用时，将该机服务的  段切换到其它机器来实现容灾。这里需要引入一个仲裁服务，探测  的服务状态，决定每个  段由哪台  加载。出于可靠性的考虑，仲裁模块并不直接操作  ，而是将加载配置写到  持久化，然后  定期访问  读取最新的加载配置，决定自己的加载状态。
图 号段迁移示意。通过更新加载配置把号段从  迁移到 
同时，为了避免失联提供错误的服务，返回脏数据，需要跟保持租约。这个租约机制由以下两个条件组成：

租约失效： 秒内无法从读取加载配置时，停止服务。

租约生效：读取到新的加载配置后，立即卸载需要卸载的号段，需要加载的新号段等待秒后提供服务。


图 租约机制。严格保证在停止服务后提供服务
这两个条件保证了切换时，新  肯定在旧  下线后才开始提供服务。但这种租约机制也会造成切换的号段存在小段时间的不可服务，不过由于微信后台逻辑层存在重试机制及异步重试队列，小段时间的不可服务是用户无感知的，而且出现租约失效、切换是小概率事件，整体上是可以接受的。
到此讲了  容灾切换的基本原理，接下来会介绍整个  架构容灾架构的演变。
容灾架构：主备容灾
初版本的  采用了主机冷备机容灾模式：全量的  空间均匀分成个 ，连续的若干个  组成了一个 ，每个  都有一主一备两台  。正常情况下只有主机提供服务；在主机出故障时，仲裁服务切换主备，原来的主机下线变成备机，原备机变成主机后加载  号段提供服务。
图 容灾架构：主备容灾
可能看到前文的叙述，有些同学已经想到这种容灾架构。一主机一备机的模型设计简单，并且具有不错的可用性——毕竟主备两台机器同时不可用的概率极低，相信很多后台系统也采用了类似的容灾策略。
设计权衡
主备容灾存在一些明显的缺陷，比如备机闲置导致有一半的空闲机器；比如主备切换的时候，备机在瞬间要接受主机所有的请求，容易导致备机过载。既然一主一备容灾存在这样的问题，为什么一开始还要采用这种容灾模型？事实上，架构的选择往往跟当时的背景有关， 诞生于微信发展初期，也正是微信快速扩张的时候，选择一主一备容灾模型是出于以下的考虑：

架构简单，可以快速开发

机器数少，机器冗余不是主要问题

 端更新  的路由状态很容易实现


前两点好懂，人力、机器都不如时间宝贵。而第三点比较有意思，下面展开讲下：
微信后台绝大部分模块使用了一个自研的框架，也不例外。在这个框架里，调用端读取本地机器的配置文件，决定去哪台服务端调用。这种模型对于无状态的服务端，是很好用的，也很方便实现容灾。我们可以在配置文件里面写“对于号段，可以去、、三台机器的任意一台访问”，实现三主机容灾。
但在里，是预分配中间层，并不是无状态的。而前面我们提到，加载哪些号段，是由保存在的加载配置决定的。那么这时候就尴尬了，业务想要申请某个的，端其实并不清楚具体去哪台访问，配置文件只会跟它说“、…这堆机器的某一台会有你想要的”。换句话讲，原来负责提供服务的故障，仲裁服务决定由来替代提供服务，要如何获知这个路由信息的变更？
这时候假如我们的采用了主备容灾模型的话，事情就变得简单多了。我们可以在配置文件里写：对于某个号段，要么是加载，要么是加载。端发起请求时，尽管端并不清楚和哪一台真正加载了目标号段，但是端可以先尝试给其中任意一台发请求，就算这次请求了错误的，那么就知道另外一台是正确的，再发起一次请求即可。
也就是说，对于主备容灾模型，最多也只会浪费一次的试探请求来确定的服务状态，额外消耗少，编码也简单。可是，如果端采用了其它复杂的容灾策略，那么基于静态配置的框架就很难去确定端的服务状态：发生状态变更，端无法确定应该向哪台发起请求。这也是为什么一开始选择了主备容灾的原因之一。
主备容灾的缺陷
在我们的实际运营中，容灾架构存在两个重大的不足：

扩容、缩容非常麻烦

一个  的主备机都过载，无法使用其他  的机器进行容灾


在主备容灾中， 和  需要使用完全一致的配置文件。变更这个配置文件的时候，由于无法实现在同一时间更新给所有的  和  ，因此需要非常复杂的人工操作来保证变更的正确性包括需要使用来做请求转发，具体的详情这里不做展开。
对于第二个问题，常见的方法是用一致性  算法替代主备，一个  有多台机器，过载机器的请求被分摊到多台机器，容灾效果会更好。在  中使用类似一致性  的容灾策略也是可行的，只要  端与仲裁服务都使用完全一样的一致性  算法，这样  端可以启发式地去尝试，直到找到正确的 。
例如对于某个 ，仲裁服务会优先把它分配到  ，如果  挂掉则分配到  ，再不行分配到 。那么  在访问  时，按照      的顺序去访问，也能实现容灾的目的。但这种方法仍然没有克服前面主备容灾面临的配置文件变更的问题，运营起来也很麻烦。
容灾架构：嵌入式路由表容灾
最后我们另辟蹊径，采用了一种不同的思路：既然  端与  存在路由状态不一致的问题，那么让  把当前的路由状态传递给  端，打破之前只能根据本地  配置文件做路由决策的限制，从根本上解决这个问题。
所以在架构中，我们把  的路由状态嵌入到  请求  的响应包中，在不带来额外的资源消耗的情况下，实现了  端与  之间的路由状态一致。具体实现方案如下：
 所有模块使用了统一的路由表，描述了  号段到  的全映射。这份路由表由仲裁服务根据  的服务状态生成，写到  中，由  当作租约读出，最后在业务返回包里旁路给  端。
图 容灾架构：动态号段迁移容灾
把路由表嵌入到请求响应包看似很简单的架构变动，却是整个  容灾架构的技术奇点。利用它解决了路由状态不一致的问题后，可以实现一些以前不容易实现的特性。例如灵活的容灾策略，让所有机器都互为备机，在机器故障时，把故障机上的号段均匀地迁移到其它可用的  上；还可以根据  的负载情况，进行负载均衡，有效缓解  请求不均的问题，大幅提升机器使用率。
另外在运营上也得到了大幅简化。之前对机器进行运维操作有着繁杂的操作步骤，而新架构只需要更新路由即可轻松实现上线、下线、替换机器，不需要关心配置文件不一致的问题，避免了一些由于人工误操作引发的故障。
图 机器故障号段迁移
路由同步优化
把路由表嵌入到取  的请求响应包中，那么会引入一个类似“先有鸡还是先有蛋”的哲学命题：没有路由表，怎么知道去哪台  取路由表？另外，取  是一个超高频的请求，如何避免嵌入路由表带来的带宽消耗？
这里通过在  端内存缓存路由表以及路由版本号来解决，请求步骤如下：

 根据本地共享内存缓存的路由表，选择对应的；如果路由表不存在，随机选择一台；

对选中的  发起请求，请求带上本地路由表的版本号；

 收到请求，除了处理  逻辑外，判断  带上版本号是否最新，如果是旧版则在响应包中附上最新的路由表；

收到响应包，除了处理  逻辑外，判断响应包是否带有新路由表。如果有，更新本地路由表，并决策是否返回第步重试。


基于以上的请求步骤，在本地路由表失效的时候，使用少量的重试便可以拉到正确的路由，正常提供服务。
总结
到此把  的架构设计和演变基本讲完了，正是如此简单优雅的模型，为微信的其它模块提供了一种简单可靠的一致性解决方案，支撑着微信五年来的高速发展，相信在可预见的未来仍然会发挥着重要的作用。
相关推荐万亿级调用下的优雅：微信序列号生成器架构设计及演变上微信开源：简单易用高性能的协程库自选股微信小程序深度漫游指南感谢阅读腾讯 微信号第四篇文章，我们将从技术角度解析近期发布的技术案例。同步发送的头条文章则深度解析了刚结束的顶级学术会议上的三大前沿研究及重点论文解析，敬请关注。

昨天，腾讯发布了首款医学影像产品——腾讯觅影，使用腾讯 技术的食管癌早期筛查也成为首个进入临床预试验的项目，实现了筛查一个内镜检查用时不到秒，对早期食管癌的发现准确率高达  。
同时，腾讯还宣布发起成立了人工智能医学影像联合实验室，中山大学附属肿瘤医院广东省食管癌研究所、广东省第二人民医院、深圳市南山区人民医院成为首批加入联合实验室的合作医院。
食管癌是常见恶性肿瘤之一，治疗时机非常关键，如果在癌症早期发现，只需通过微创手术切除病变区域，治疗成本低、基本无并发症、治愈的概率非常高。但我国早期食管癌检出率低于，因为早癌病变特征非常细微，在检查时人的肉眼很容易忽略，可能错过最佳治疗时机。同时，食管的炎症与癌症特征有很多相似性，经验不足的医生，有可能把炎症误诊为癌症，从而选择错误的治疗方案，导致不必要的身体损伤。
中国食管癌现状

早期食管癌检出率低于
年新发现肿瘤病理排名第三
新发现肿瘤病例男性排名第四、女性排名第五

在食管癌筛查中，医生要做的第一步是用内镜筛查判断病变特征，从而决定是否进行进一步病理检查。这里的内镜图像里包含大量像素数据，在非常有限的筛查时间里，机器能很快区分病灶之间的细微差别，提升早癌筛查识别率，同时更好辨识出炎症与癌症之间差异性，将两者区分开来，帮助医生进行更好的治疗。
中山大学医院管理处处长、广东省食管癌研究所所长傅剑华教授介绍，在医疗上的应用越来越广泛。国外开发主要聚焦影像识别系统，应用在皮肤科和眼科等。这次合作属于内镜图像识别系统，可能在全球属于首创。中山大学附属肿瘤医院胸外科医师罗孔嘉补充解释，与内镜结合少，原因包括内镜图像的拍摄非常困难。而且，比起有无病灶的诊断，病情严重程度的诊断技术含量更高。
腾讯 提出的技术流程历经三个环节：首先通过食管判别模型，从包含非食管的大数据中辨别并留存食管数据；第二步，将食管数据送到第二个模型，把正常食管和病变食管区别开；第三步，将病变食管数据送到第三个模型，判断是癌症还是炎症。

食道癌识别  整体流程及相关技术
在这个技术中，我们研究了如何将深度学习技术应用到食管癌识别的问题中，通过构建自动识别算法辅助医生，提升其诊断效率和准确性。在研究中，这是一个典型的分类问题，目前有和等比较成熟的算法。而成熟分类算法的效果并不理想，因为能知道一张图像是否包含癌症，但缺乏定位到具体病变位置的表示数据。因此我们将一张食管图像化整为零，采用思路，在 中加入医生经验和医学知识作为约束，提升了模型学习性能。在模型迭代过程中，我们也会积累少量精准标注数据，通过多任务方式，把这些数据的精准特征强化到前面的判别模型中，从而进一步提升模型识别效果。通过不断将模型识别结果与医生标注结果对比，精准标注数据不断积累，模型也越加成熟。在历时半年、多次迭代以后，判断准确率和召回率的综合指标最终达到了。
腾讯 于年月成立以后，专注于基础研究和应用探索的结合，提出了「学术有影响，工业有产出」的发展目标，目前技术已支持腾讯上百个产品，包括微信、、音乐、天天快报和应用宝等。
年月，斩获计算机围棋大赛“杯”冠军的围棋产品「绝艺」，背靠机器学习与强化学习等热门研究，并在腾讯围棋平台应用、游戏研发领域具有较高价值。近日在手机版本上线的「实时视频滤镜技术」，其相关论文也入选计算机视觉顶级学术会议，是研发向应用快速转化的又一例证。
和中的准确率指，是信息检索领域的常用评价标准，一般用于评价分类模型的好坏。是准确率与召回率的加权调和平均，当数值较高时，能说明检验方法比较有效。
关于腾讯觅影：月日在广州举办的 “互联网”数字经济中国行广东峰会上，腾讯正式发布 医学影像产品「觅影」，并与多家合作医院建立联合实验室。在腾讯公司内部，由腾讯互联网合作事业部牵头，腾讯觅影聚合了包括腾讯 、优图实验室、架构平台部等多个技术团队能力，把图像识别、深度学习等技术充分发挥。与医学的跨界融合，可以有效辅助医生发现癌变征兆，将病魔遏制在摇篮里。导语
年，企业部开始搭建私有云环境，目的是面向企业内部环境提供云计算资源。企业云主要承载着腾讯内部业务系统、职能部门业务，以及大部分的开发测试业务。于此同时，团队也积极协助业务部门将腾讯企业云平台以及运营服务经验推广到中国政企市场，目前已经在政府、公安、电力等多个政府企业落地。
企业云在私有云领域的拓荒之路
企业部作为腾讯内部的基础服务部门，服务着内部众多业务，包括内部业务系统、职能部门业务以及大部分的开发测试业务。而腾讯作为互联网公司，其业务变化非常快，种类非常复杂，不同的团队对于环境的要求、建设、维护和交付等都有着不同的需求。每一次环境的交付都需要付出许多的时间和人力，所以提高交付效率成为我们当时亟待解决的事情。
年，我们开始着手搭建私有云环境，目的是面向企业内部环境提供云计算资源。当时我们通过自研底层技术平台构建了云平台，纳管着虚拟机，在一定程度上提高了我们的交付效率。但我们也清楚它并不是一个异构虚拟化的云管理平台，仍有其他异构虚拟机、上千台物理服务器和许多第三方厂商的存储设备未被纳管，导致这些资源未能够被充分利用。我们也一直在寻找解决方案，希望可以优化底层架构，从而降低运营成本。
企业云的演进之路
年，开始迅速发展，来自全球十多个国家的几十家领军企业都参与到的项目中，并且在全球开始落地上线很多项目，逐步成为云计算领域的一支强有力的力量， 也逐渐成为开源云计算平台的首选。
经过腾讯内部运营团队详细的调研和测试，也为了迎合公司的互联网战略，满足政企服务市场对的强需求，综合评估之后，决定引入作为企业云平台的组成部分。
同时我们结合内部业务的特性，在基础上做了大量的优化，包括：
、异构平台的管理技术；
、在线资源限制技术；
、根据业务类型定制基于业务类型的虚拟机调度策略；
、自动化容灾设计；
、虚拟机迁移植入动态自适应压缩迁移技术；
、底层开启压缩存储。
由此，我们基于构建了一个符合主流技术的、易于扩展的、高可用的、具备国产自主可控的云计算基础设施管理方案，这个方案向上提供了计算资源管理、存储管理、网络管理、镜像管理、认证管理、计量管理服务接口，向下兼容异构虚拟化软件、服务器设备、存储设备和网络设备，同时还结合了分布式存储计算融合的架构。
新的云平台在产品功能的完善度，架构设计的优越性，新功能开发的工作量方面，都要比原来的云平台更具有优势，还能通过云平台的一体化管理，对异构云进行统一管理、统一调度。
截至目前为止，腾讯企业云管理着企业部个地区、个机房、个集群的，除了服务腾讯内部认证、、邮件、内部安全等多个需保证小时在线的业务，还承载着微信、、游戏等各产品线的开发测试服务，可用性超过，成为国内最大的私有云平台。
从企业云到的未来之路
腾讯企业云通过内部多年的实践，积累了非常丰厚的运营经验。在服务腾讯内部的同时，我们也积极响应公司的互联网战略，协助业务部门将腾讯企业云的优秀实践经验推广至全国的政府部门和企业。
年落地腾讯第一朵政务云四川省级政务云，完成了个厅级单位、个业务系统的迁移入云工作，支撑包括人社厅、财政厅、教育局等多家单位线上服务系统。年落地全国第一朵警务云云南省警务云，完成了个单位和个业务系统入云工作，对内连接指挥中心、刑侦、技侦、交警、反恐等警务业务，对外连接出入境、治安、交通、消防、网警等业务。年，落地厦门政务云，为“金砖会议”保驾护航……
与此同时，我们在对外部项目的不断交付中，逐渐积累了 市场的经验，也通过不断的摸索，形成了一套科学的、完善的、可复制的私有云整体服务体系，包括售前、实施、部署、产品设计、开发、运维等一系列能力。这就意味着，我们具备了协助业务部门将腾讯企业云大规模推向市场的能力。
年月日，腾讯“云未来”峰会政企专场在深圳隆重举行，企业部总经理刘若潇应邀参加此次峰会，并发布了私有云产品，旨在帮助用户构建自己的专属腾讯云服务，意味着企业云有了正式对外发布的产品。

 ▲腾讯技术工程事业群企业部总经理刘若潇
作为腾讯 战略中重要的一环，也时刻秉承着四个理念为用户服务：

支撑

提供集计算、存储、网络、安全、监控、运营等能力为一体的私有云整体解决方案，帮助业务平滑入云，让用户能聚焦于挖掘自身业务的价值。

赋能

坚持“赋能于人”的理念，开放腾讯基础能力，提供经过腾讯海量业务验证的产品与服务，如、支付、地图等，助力业务高效运作。

创新

基于腾讯广泛的产品能力，致力于向政企用户共享腾讯互联网海量运营经验，助力政企进行业务创新。

连接

依托腾讯产品的覆盖能力，帮助政企快速连接内部员工和外部民众，助力政企高效行政。
 未来，期望与企业用户探讨，与公司优秀产品合作，与业界同行，在飞速发展的云计算浪潮中能够把握住时代的命脉。

写在最后的话
腾讯企业云今天的成绩离不开背后一群可爱的人儿，我们以实力为盾、自信为矛、团结为勇气，在企业云的发展历程中不离不弃，乘风破浪，勇敢起航。我们也深知自己每一个决定的重要性，不管前方的路有多艰苦、坎坷和荆棘密布，都会时刻铭记自己的责任和使命。
既然选择了远方，便只顾风雨兼程。

文章来源：云端专业号 导语 目前生产环境中主从延迟常见于实例及备库中，由于历史原因目前部分用户的备库开启了只读服务，后续这块我们会逐步推荐客户使用实例。

背景：
接一线同时反馈，用户的实例延迟很大，达到多秒。
问题排查：
登上客户实例，通过执行    查看确认是否有执行时长比较久的查询。
     
     

   

|  |  |  |  |  |  |  |  |

|  |   | |  |  |  |       |  |
|  |   | |  |  |  |       |  |
|  |  |  |  |  |  |  |   |

     

   

|  |  |  |  |  |  |  |  |

|  |   | |  |  |  |       |  |
|  |   | |  |  |  |       |  |
|  |  |  |  |  |  |  |   |

     
这里看并没有发现执行时长的。
执行  \ ，查看当前 ，_执行到哪里
    \
   
__      
_ 
_ 
_ 
_ 
__ 
___ 
__ 
__ 
___  当前 _ 执行事件所对应主库日志的名称
__ 
__ 
__ 
__ 
__ 
__ 
___ 
___ 
_ 
_ 
_ 
___ 当前 _ 执行事件所对应主库日志的位置偏移量
__ 
_ 
__ 
__ 
__ 
___ 
___ 
__ 
__ 
__ 
__ 
____ 
__ 
__ 
__ 
__ 
___ 
__ 
_ 
__ _
_ 
__ 
___      

此时保存记录，在 上获取的主库日志名  和位置偏移量。
登录主库，根据步骤中获取的信息，查看用户业务当时执行的什么操作。
                   

| _ |  | _ | _ | __ |  |

|  |  |  |  |  |  _=  |
|  |  |  |  |  |  |
|  |  | _ |  |  | _  ___ |
|  |  | _ |  |  | _  |
|  |  | _ |  |  | _  |
|  |  | _ |  |  | _  |
|  |  | _ |  |  | _  |
|  |  | _ |  |  | _  |
|  |  | _ |  |  | _  |
|  |  | _ |  |  | _  |
|  |  | _ |  |  | _  |
|  |  | _ |  |  | _  |
|  |  | _ |  |  | _  |
|  |  | _ |  |  | _  


这里看执行是一个操作。
     查看表信息 


      ___\
   
 ___
 
 
_ 
 
__ 
_ 
__ 
_ 
_ 
_ 
_  
_ 
_ 
 __
 
_ 
 
     
这里看到该表的数据量已经亿多。
  `___` 
``      
``     
``    
``    
``   
``   
``   
``   
``   
``   
``   
``   
 `` ``
 `` ``
 `` ``
 `` ``
 =  =

     ___

|  | _ | _ | __ | _ |  |  | _ |  |  | _ |  | _ |

| ___ |  |  |  |  |  |  |  |  | |  | | |
| ___ |  |  |  |  |  |  |  |  | |  | | |
| ___ |  |  |  |  |  |  |  |  | |  | | |
| ___ |  |  |  |  |  |  |  |  | |  | | |


     
这里看表只有普通木有主键和唯一，且的 也不高，表的数据量已经在亿多， 效率会很差。由于 _是串行执行，再加上效率问题， 不能够及时将接收的日志执行完毕，故引发主从延迟。
总结：
反馈用户此种业务基于主键或唯一性较高的删除。
主从环境中，、 操作时一定要留意当前表中是否有主键或唯一索引。若无，             可将自增列做为主键。如果没有主键的话，、将会全表扫描，特别是在                模式的时候，延迟将会很大。本文中  中以模作者：晋中望 

相信很多做或是研发的同学对应该都早有耳闻了，尤其是在开发的圈子里，渐渐开始广为流行。同样有很多同学已经开始在自己的项目中使用。它能够帮助我们在处理异步事件时能够省去那些复杂而繁琐的代码，尤其是当某些场景逻辑中回调中嵌入回调时，使用依旧能够让我们的代码保持极高的可读性与简洁性。不仅如此，这种基于异步数据流概念的编程模式事实上同样也能广泛运用在移动端这种包括网络调用、用户触摸输入和系统弹框等在内的多种响应驱动的场景。那么现在，就让我们一起分析一下的响应流程吧。本文基于
一用法
首先来看一个简单的例子
运行结果为：从结果中我们不难看出整体的调用流程：
首先通过调用方法生成一个被观察者，紧接着在这里我们又调用了方法对原被观察者进行数据流的变换操作，生成一个新的被观察者为何是新的被观察者后文会讲，最后调用方法，传入我们的观察者，这里观察者订阅的则是调用之后生成的新被观察者。
在整个过程中我们会注意到三个主角：、、，所有的操作都是围绕它们进行的。不难看出这里三个角色的分工：

：被观察者的来源，亦或说是被观察者本身
：用来通知观察者的不同行为
：观察者，通过实现对应方法来产生具体的处理。

所以接下来我们以这三个角色为中心来分析具体的流程。
二分析
订阅过程
首先我们进入看看：这里调用构造函数生成了一个对象并将传入的赋给自己的成员变量，等等，这个是从哪里冒出来的？我们向上找：这个抽象类默认对对象不做任何处理，不过通过继承该类并重写等方法我们可以对这些方法对应的时机做一些额外处理比如打或者一些数据收集方面的工作。
到目前最初始的被观察者已经生成了，我们再来看看观察者这边。我们知道通过调用方法传入一个观察者即构成了观察者与被观察者之间的订阅关系，那么这内部又是如何实现的呢？看代码：
这里我们略去部分无关代码看主要部分，默认空实现我们暂且不用管它，对于传进来的要包装成，这个对原来的的一系列方法做了更完善的处理，包括：与只会有一个被执行；保证一旦或者被执行，将不再能再执等情况。这里封装为之后，调用，并将传入，这样就完成了一次订阅。 显而易见，作为观察者，在订阅行为完成后，其具体行为在整个链式调用中起着至关重要的作用，我们来看看它内部的构成的主要部分：
每个都持有一个，这个保存的是所有该观察者的订阅事件，同时也对应实现了接口，当这个取消订阅的时候会将持有事件列表中的所有取消订阅，并且从此不再接受任何订阅事件。同时，通过可以去限定该所接收的数据流的总量，这个限制量其实是加在方法上的，、则不会受到其影响。因为是底层抽象类，、、统一不在这里处理。
变换过程
在收到的消息之前我们有可能会对数据流进行处理，例如、、、等方法，本例中我们用了方法，它接收了原被观察者发射的数据并将通过该方法返回的结果作为新的数据发射出去，相当于做了一层中间转化：
我们接着看这个转化过程：
这里是通过一个方法实现的，再查看其他的转化方法发现内部也都使用实现的，看来这个就是关键所在了，不过不急，我们先来看看这个是什么：实现了接口的方法，该方法接受外部传入的观察者，并将其作为参数构造出了一个新的观察者，我们不难发现这一句起了至关重要的作用，这里的接口将泛型转化为泛型：这样之后，再将转换后的数据传回至原观察者的方法，就完成了观察数据流的转化，但是你应该也注意到了，我们用来做转换的这个新的观察者并没有实现订阅被观察者的操作，这个订阅操作又是在哪里实现的呢？答案就是接下来的：
在这里我们新生成了一个对象，在这个新对象的成员的方法中我们通过拿到之前生成的未产生订阅的观察者，之后将它作为参数传入一开始的中，即完成了这个中间订阅的过程。现在我们将整个流程梳理一下：

一次变换

根据实例生成新的

通过生成新的

原订阅新的

新的中通知新订阅原

新将消息传给原。

为了便于理解，这里借用一下扔物线的图：
以上就是一次变换的流程，事实上多次也是同样道理：最外层的目标发生订阅行为后，会逐层嵌套调用，直至初始被最底层的订阅，通过的一层层变化将消息传到目标。再次祭出扔物线的图：
至于其他的多种变化的实现流程也都很类似，借助于的不同实现来达到变换数据流的目的。例如其中的，它需要进行两次，其中第二次是，将转换成的每一个数据流通过这个纽带订阅后，在的中拿到，再通过传入的也就是原将它们全部发射出去，由最外层我们传入的统一接收，这样就完成了  =  =  的转化：
除此之外，还有许多各式各样的操作符，如果它们还不能满足你的需要，你也可以通过实现接口定制新的操作符。灵活运用它们往往能达到事半功倍的效果，比如通过使用、等操作符有效避免的需要等等，这里就不一一介绍了。
下篇将继续从线程切换过程开始分析
文章来源公众号：空间终端开发团队

相关推荐
下一篇：   从源码简要分析基本调用流程通过本篇文章可以对的常用算法有个常识性的认识，没有代码，没有复杂的理论推导，就是图解一下，知道这些算法是什么，它们是怎么应用的，例子主要是分类问题。
每个算法都看了好几个视频，挑出讲的最清晰明了有趣的，便于科普。以后有时间再对单个算法做深入地解析。
今天的算法如下：

 决策树
 随机森林算法
 逻辑回归
 
 朴素贝叶斯
 最近邻算法
 均值算法
  算法
 神经网络
 马尔可夫
 决策树
根据一些  进行分类，每个节点提一个问题，通过判断，将数据分为两类，再继续提问。这些问题是根据已有数据学习出来的，再投入新数据的时候，就可以根据这棵树上的问题，将数据划分到合适的叶子上。

 随机森林
视频
在源数据中随机选取数据，组成几个子集

 矩阵是源数据，有  条数据，   是，最后一列是类别

由  随机生成  个子矩阵

这  个子集得到  个决策树
将新数据投入到这  个树中，得到  个分类结果，计数看预测成哪一类的数目最多，就将此类别作为最后的预测结果

 逻辑回归
视频
当预测目标是概率这样的，值域需要满足大于等于，小于等于的，这个时候单纯的线性模型是做不到的，因为在定义域不在某个范围之内时，值域也超出了规定区间。

所以此时需要这样的形状的模型会比较好

那么怎么得到这样的模型呢？
这个模型需要满足两个条件 大于等于，小于等于
大于等于 的模型可以选择 绝对值，平方值，这里用 指数函数，一定大于
小于等于 用除法，分子是自己，分母是自身加上，那一定是小于的了

再做一下变形，就得到了   模型

通过源数据计算可以得到相应的系数了

最后得到  的图形

 
视频
  
要将两类分开，想要得到一个超平面，最优的超平面是到两类的  达到最大，就是超平面与离它最近一点的距离，如下图，，所以绿色的超平面比较好

将这个超平面表示成一个线性方程，在线上方的一类，都大于等于，另一类小于等于－

点到面的距离根据图中的公式计算

所以得到   的表达式如下，目标是最大化这个 ，就需要最小化分母，于是变成了一个优化问题

举个栗子，三个点，找到最优的超平面，定义了  ＝，－，

得到   为，，将两个点代入方程，代入，另其值＝，代入，另其值＝，求解出  和 截矩  的值，进而得到超平面的表达式。

 求出来后，代入，得到的就是  
 和  代入超平面的方程就是   
 朴素贝叶斯
视频
举个在  的应用
给一段文字，返回情感分类，这段文字的态度是，还是

为了解决这个问题，可以只看其中的一些单词

这段文字，将仅由一些单词和它们的计数代表

原始问题是：给你一句话，它属于哪一类通过   变成一个比较简单容易求得的问题

问题变成，这一类中这句话出现的概率是多少，当然，别忘了公式里的另外两个概率
栗子：单词  在  的情况下出现的概率是 ，在  的情况下出现的概率是 

 最近邻
视频
  
给一个新的数据时，离它最近的  个点中，哪个类别多，这个数据就属于哪一类
栗子：要区分 猫 和 狗，通过  和  两个来判断的话，圆形和三角形是已知分类的了，那么这个  代表的是哪一类呢

＝时，这三条线链接的点就是最近的三个点，那么圆形多一些，所以这个就是属于猫

 均值
视频
想要将一组数据，分为三类，粉色数值大，黄色数值小最开心先初始化，这里面选了最简单的 ，， 作为各类的初始值剩下的数据里，每个都与三个初始值计算距离，然后归类到离它最近的初始值所在类别

分好类后，计算每一类的平均值，作为新一轮的中心点

几轮之后，分组不再变化了，就可以停止了


 
视频
 是  的方法之一
就是把若干个分类效果并不好的分类器综合起来考虑，会得到一个效果比较好的分类器。
下图，左右两个决策树，单个看是效果不怎么好的，但是把同样的数据投入进去，把两个结果加起来考虑，就会增加可信度

 的栗子，手写识别中，在画板上可以抓取到很多 ，例如 始点的方向，始点和终点的距离等等

 的时候，会得到每个  的 ，例如  和  的开头部分很像，这个  对分类起到的作用很小，它的权重也就会较小

而这个  角 就具有很强的识别性，这个  的权重就会较大，最后的预测结果是综合考虑这些  的结果

 神经网络
视频
  适合一个可能落入至少两个类别里
 由若干层神经元，和它们之间的联系组成第一层是  层，最后一层是  层
在  层 和  层都有自己的 

 输入到网络中，被激活，计算的分数被传递到下一层，激活后面的神经层，最后 层的节点上的分数代表属于各类的分数，下图例子得到分类结果为  
同样的  被传输到不同的节点上，之所以会得到不同的结果是因为各自节点有不同的 和 
这也就是  

 马尔可夫
视频
  由  和  组成
栗子，根据这一句话 ‘        ’，要得到  
步骤，先给每一个单词设定成一个状态，然后计算状态间转换的概率

这是一句话计算出来的概率，当你用大量文本去做统计的时候，会得到更大的状态转移矩阵，例如  后面可以连接的单词，及相应的概率

生活中，键盘输入法的备选结果也是一样的原理，模型会更高级导语：作为生态的一部分，在越来越多的大数据方面得到了应用，但是如何用好它是一个比较考究的过程，本文暂时先研究了部分的代码，作为调用的入口，先从入口处明白原理以及内部实际控制参数进行调整来满足自己的以为需要

 采用了和  相同的  机制，作为它的主要通信手段这是一个轻量的，不同于  标准的  的一种方式，  有明显的客户端和服务端之分。由  ，    三者组成了三个信道。最右边的一列是通信两端之间约定的通信接口。客户端调用这个接口，而服务端实现这个接口。所以最基本的工作流程就是： 
客户端取得一个服务端通信接口的实例
客户端调用这个实例中的方法 
客户端向服务端传输调用请求 
服务端接口实现被调用 
服务端向客户端传输结果
 结构如下：

 的协议文件位于源码的  模块下， 版本的协议文件如下：

 服务端处理流程
 服务端  服务接口为类 ，其具体实现类为 ，其服务端  总体架构如下图


 线程以  模式负责接受网络请求，其核心源码如下
  {

          = 

         {

             __

            = 

           {

             = 

            

            {

                {

                 

                  

              }

            }    {

                 

            }

             = 

          }

        }



      {

       

        =  



       

        =  =  {

        {

          

          

          

        }    {

          

           

        }



          = 

        {

          

            = 

           =  __

          

            {

             

             

          }

           

                  

                     

        }  {

          

        }

      }

    }
从源码中可以看出，其主要职责就是负责接受网络请求并把链接转给 

 主要职责是从网络链接里读取数据并把数据封装成  交给  进行调度，
其调用链路如下：

 方法会依次调用  对象的 、、、 方法完成协议的解析以及需要调用服务端的那个方法，因为传输协议为  因此服务端提供服务的  都必须实现  接口，如果是调用  那么对应的实现类为 ，在查找到要调用的方法后把服务封装为一个  对象交给  进行调度。

 实现了对接受到的  请求进行调度， 的  调度器有两个分别是  和 ，区别是  是先进先出调度，而  是按照优先级进行调度的， 默认使用了  调度器，可以通过参数  进行修改。

 真正负责调度执行  对象，其调用链路如下图

如上图， 的  分为  和 ，分别是平衡队列调度和读写因子调度队列，在  请求加入到  后  会按照规则进行调度，请求最终会调用  即调用业务方法，最后把响应通过  返回给客户端。 在最外层分为  个 ，每种  都有一定的线程数来处理队里里的请求，调度器中的  个  分别是


 
 

 具体是那种类型取决与参数 ，默认是 ，如设置该值后为  否则为 ， 和  为 ，如果其封装的请求是基于  表格的操作，将其划分到  组里；如果其封装的请求是基于用户表格的操作，将其划分到  组里；如果其封装的是  请求，将其划分到  组里。每个调度池分一到多个队列，默认都是一个队列，这样产品组中的所有  都会去竞争该队列中的资源，为了防止竞争惨烈的情况发生，可将每一个产品组划分成多个产品队列，让每个  只去抢占指定队列中的资源。在  中，可通过如下方法来计算  组可以划分成多少个产品队列：

其中  属性值默认为 ，即在默认情况下只将该产品组划分成一个产品队列，单个产品队列的容量并不是按需使用无限增长的， 对其长度及空间大小都做了相应的阀值控制，其中： 用于限制产品队列的长度默认为  数乘以 ， 用于限制产品队列的空间大小默认为 ，成功将  产品分配给  之后，该  开始对其进行消费处理，消费过程主要是通过调用  的  方法来执行指定服务的相应方法，并通过  将方法的执行结果返回给客户端。
如果  为 ，那么  池 ，如果  大于 ，那么池的  为 ，该  中分为  个队列：， 和 ，分别通过参数  和参数  进行控制，其中  用来控制队列个数
 比较重要的参数

默认值 ， 网络  个数， 的个数决定了从网络  里读取数据的速度也就是网络吞吐量

默认值值 

默认值 

 的  请求队列处理线程数，默认为 

 操作系统表  请求处理线程数，默认为 

 队列最大长度，默认值为  的个数

改值决定了  的  的类型，如果大于 ，那么  为读写分别调度，改值为厚点数，该值要配合参数  联合使用其中还需要设置参数 ，含义是  支持 、、 分开调度，可以结合自己的业务场景来控制读写

客户端  调用超时时间，默认为  分钟一、前言
北京时间年月日晚，勒索软件感染事件爆发，全球范围内个国家遭到大规模网络攻击，被攻击者电脑中的文件被加密，被要求支付比特币以解密文件；众多行业受到影响，比如英国的服务，导致至少家医疗机构内网被攻陷，电脑被加密勒索；而我国众多行业的也是如此，其中又以教育网最为显著，导致部分教学系统无法正常运行，相关学子毕业论文被加密等。截止到北京时间月日点，目前事件趋势已经蔓延到更多行业，包含金融、能源、医疗、交通等行业均受到影响。
今年月日黑客组织 影子经纪人公布了 方程式组织使用的网络军火，其中包含了一些漏洞微软编号为和利用工具，这些漏洞利用中以永恒之蓝最为方便利用，并且网上出现的相关攻击脚本和利用教程也以该漏洞为主，而在月日后我们监控捕获的多起主机入侵事件均是以利用进行入侵；可以远程攻击的端口，该端口主要用于基于协议的文件共享和打印机共享服务。在以往捕获的利用进行入侵攻击的事件，黑客主要进行挖矿、等行为，而本次事件则是利用该漏洞进行勒索病毒的植入和传播。
本次事件影响范围广泛，腾讯安全云鼎实验室发布本处理指南意在指导云上用户在遭受攻击前后进行相关处理，个人用户也可参考部分章节。
 
二、事前预防
    关闭漏洞端口，安装系统补丁

可以采用一些免疫工具进行自动化的补丁安装和端口屏蔽，比如电脑管家勒索病毒免疫工具下载地址：

手动关闭端口，下载安装补丁，为确保补丁安装，请一定要手工安装补丁。
补丁下载地址：
          =、
                  

利用防火墙添加规则屏蔽端口

开始菜单打开控制面板选择防火墙   
 

如果防火墙没有开启，点击启动或关闭 防火墙启用防火墙后点击 确定
 

点击 高级设置，然后左侧点击入站规则，再点击右侧 新建规则
 
 

在打开窗口选择选择要创建的规则类型为端口，并点击下一步
 



在特定本地端口处填入并点击下一步，选择阻止连接，然后一直下一步，并给规则随意命名后点击完成即可。
 
 
 
注：不同系统可能有些差异，不过操作类似



腾讯云机器也可以通过配置安全组规则屏蔽端口

选择需要操作机器所属的安全组，点击编辑规则


直接点击快捷配置按钮封堵安全漏洞就可以自动添加规则
 



该快捷按钮将会添加、、三个端口的屏蔽规则，如果只想添加本次所影响的端口，可以在保存前进行调整如非业务需要，不建议调整



    备份数据，安装安全软件，开启防护

对相关重要文件采用离线备份即使用盘等方式等方式进行备份

部分电脑带有系统还原功能，可以在未遭受攻击之前设置系统还原点，这样即使遭受攻击之后可以还原系统，找回被加密的原文件，不过还原点时间到遭受攻击期间的文件和设置将会丢失

目前，大部分安全软件已经具有该勒索软件的防护能力或者其他免疫能力等，可以安装这些安全软件，如腾讯电脑管家，开启实时防护，避免遭受攻击

对于个人用户，可以采用一些文件防护工具，进行文件的备份、防护，如电脑管家的文档守护者电脑管家工具箱内可下载使用


    建立灭活域名实现免疫
根据对已有样本分析，勒索软件存在触发机制，如果可以成功访问，则电脑在中了勒索病毒后不会进行文件加密而直接退出。目前该域名已被安全人员注册，可以正常访问。

普通用户在可以联网状态下，保证对该网址的可访问，则可以避免在遭受攻击后避免被加密仅限于已知勒索病毒

企业用户可以通过在内网搭建 ，然后通过内网的方式将域名解析到  的方式来实现免疫；通过该域名的访问情况也可以监控内网病毒感染的情况


三、事后病毒清理
     首先可以拔掉网线等方式隔离已遭受攻击电脑，避免感染其他机器
     病毒清理
相关安全软件如电脑管家的杀毒功能能直接查杀勒索软件，可以直接进行扫描清理已隔离的机器可以通过盘等方式下载离线包安装
     也可以在备份了相关数据后直接进行系统重装，并在重装后参考事前预防进行预防操作
四、事后文件恢复
基于目前已知的情况，当前没有完美的文件恢复方案，可以通过以下的方式恢复部分文件：
  勒索软件带有恢复部分加密文件的功能，可以直接通过勒索软件恢复部分文件，不过该恢复有限；直接点击勒索软件界面上的可弹出恢复窗口，显示可免费恢复的文件列表，然后点击即可恢复列表中文件 

  根据对勒索病毒分析，勒索软件在加密文件后会删除源文件，所以通过数据恢复软件可以有一定概率恢复已被加密的部分文件，可以使用第三方数据恢复工具尝试数据恢复，云上用户请直接联系我们协助处理。
 
五、参考链接
 微软漏洞公告及补丁下载 微软 补丁下载 腾讯云事件预警 勒索病毒”爆发 腾讯云安全专家教你来防范 电脑管家下载及事件专题页面 腾讯电脑管家对于蠕虫的详细分析 腾讯云针对方程式工具包预警及修复建议 腾讯安全反病毒实验室解读“”勒索软件作者：熊节

云计算正在毫无疑问地成为企业的主流。据麦肯锡调查，六成以上的企业计划在两年内将某种形式的云作为主要平台。在国内银行业，中国银行业信息科技“十三五”发展规划监管指导意见中明确提出：到年，国内银行业面向互联网场景的重要信息系统应全部迁移至云计算架构平台，其他系统迁移比例不低于。其他行业也有同样的趋势。信息系统云化的大背景给软件系统的研发流程带来了什么挑战，作为软件研发组织的领导者应该如何应对这些挑战？这是本文试图回答的问题。
首先，有必要回顾云计算给企业带来的收益。认为云计算有三大优势：

更灵活。用户可以根据需要，“弹性地”获得服务。

更高效。减少团队管理和维护底层基础设施的工作量，服务可以更快推向市场。

战略价值。通过灵活组合现有资产与新兴数字渠道，支撑企业业务创新。


云计算与虚拟化的区别
 有很多企业已经采用了虚拟化技术：将企业的计算资源服务器、存储等集中管理，以虚拟机的形式分配给使用者。虚拟化与云计算的区别在于：虚拟化是指“用软件管理硬件资源”，而云计算是指以虚拟化方式管理硬件资源之后能够对外提供的服务。
除去这个概念上的差异，我们注意到一些企业在谈论“虚拟化”的时候，背后隐含着一个自动化程度不高的、需要人工参与的虚拟机申请和开通的流程。在这样的流程下，获得一台虚拟主机需要的时间通常以天计。因此，虚拟机的使用者倾向于预先申请虚拟主机并长期占用。在这种情况下，“虚拟化”往往意味着缺乏弹性的计算资源分配——尽管虚拟化技术本身并不妨碍弹性。
可以看出，为了兑现云计算的三大优势，企业系统必须云化：软件的形态由从前需要在本地安装的软件包，转变为透过网络在线使用的服务，让使用者随时能够获得；原来体型巨大的单体应用，需要转变为细粒度的服务，从而支持灵活的组合与复用。
原来习惯了开发本地安装的软件包和或巨大的单体应用的研发团队，现在要转为开发云化的软件服务，这个转变并非总是无痛的。首先，研发交付物的形态应该是对云环境友好的。从前研发交付物通常是以软件包的形式提供给用户或是运维团队，例如平台特定的、、等软件包，或是、、等操作系统特定的软件包。软件包是一种对云环境不友好的交付形式，因为它没有包含软件运行的环境。例如一个软件需要用到数据库和作为监控工具，平台特定的软件包无法确保这些软件依赖的存在；某些操作系统特定的软件包可以描述软件依赖，但也无法确保依赖软件被正确地配置。过去一段时间里，自动化的配置工具例如被用于解决运行时环境的问题。而在今天的技术背景下，理想的研发交付物应该是容器镜像很可能是一组彼此连接的容器镜像，可以在云上直接运行。
对研发交付物的要求随即会影响到研发过程。为了在研发流程的出口得到服务化友好的交付物，最好是在整个开发过程中一直使用与生产环境近似的环境。例如开发人员应该使用全套环境随时验证，自动化测试和手工测试都基于全套环境开展。在这种情况下，环境的设置、管理、更新不可能由每个开发人员和测试人员自己进行，所以环境的管理更新必定是集中进行的，环境的设置必定是自动化的。而且，如果环境固定分配、长期使用，对计算资源的占用可能很大，所以环境应该是云化的、弹性的、按需获得的。
云计算的大背景还会影响研发实践。为了降低搭建研发环境的技术难度，云化的研发环境应该内建研发工具链包含开发工具、质量保障工具、持续集成持续交付工具、工具、项目管理工具等。为了规范团队研发质量水平，良好的研发实践例如代码静态检查、自动化测试等和流程要求应该固化在工具的日常操作中。理想的情况下，研发团队应该只聚焦关注业务功能开发。开发工具的组合、生产环境的配置、持续集成和持续交付流水线的搭建等工作都应该被标准化和自动化。
综上所述，在云计算的大背景下，组织需要将更多的软件应用部署在云上。云化的系统对软件研发的交付物、研发过程、研发实践都提出了新的要求。我们认为：现代组织应该从研发环节开始，以原生支持云计算的方式提供、管理和维护研发环境，从而在研发过程中利用云环境的弹性，确保研发交付物对云环境友好，并把优秀的研发实践和流程要求内嵌到研发环境之中。组织可以通过以下方式管理其研发环境：

将标准的研发环境封装为虚拟化、云化的技术栈，由技术专家管理维护；

核心业务价值与技术支撑解耦，工程师专注于业务系统的开发；

自动化研发流程，降低研发管理成本。


在下一篇文章里，我将介绍如何具体实现技术栈的云化管理，把研发技术栈以的形式提供给开发人员。近期由于工作原因，需要一些数据来辅助业务决策，又无法通过外部合作获取，所以使用到了爬虫抓取相关的数据后，进行分析统计。在这个过程中，也看到很多同学爬虫相关的文章，对基础知识和所用到的技术分析得很到位，只是缺乏快速的实战系统搭建指导。
本文将简单归纳网页爬虫所需要的基础知识，着重于实现一套完整可用的小型网页爬取、分析系统，方便大家在有需要时，能够快速搭建系统，以用到实践中去。
关于网页爬虫的定义和用途，想必做技术的都有所了解，这里就不再赘述。目前， 大家使用爬虫的目的除搜索引擎属于无差别爬取外，其他多用于垂直领域或特定网站内容的爬取，本文以特定网站内容爬取作为切入点，当然，也可以应用于垂直领域。
一套合格的网页爬取、分析系统，大致分为：网页抓取、网页分析与链接发现、任务去重与调度、数据预处理与存储、防反爬虫策略、进度展示等几个重要方面。下边逐一做简单归纳介绍。
一、基础知识
网页爬取
网页读取，即读取给定网页的完整内容，包含异步加载的内容，也就是完整地呈现到浏览器窗口的内容。
随着智能手机的普及，网页普遍分为  端 和 移动设备端，由于不同端的网速、流量、设备速度、屏幕大小等原因，移动设备端多采用异步加载的方式来优化用户体验， 类型的无缝翻页就是最佳的例子。这导致常用的       等获取到的网页内容不完整，只有网页的骨架而无内容，内容需要等待  异步加载。
这种问题的解决，我们一般使用带  执行引擎的浏览器驱动来执行网页内的异步加载 ，解决异步加载问题。常见的解决方案是  自动化浏览器测试组件配合  或  这些有界面浏览器来使用，如果是  服务器命令行下，则可配合  这款无界面浏览器。
  安装：  
 下载地址：
这里附上简单的应用示例代码：
   

 =   使用 ，需要安装



____

___ 

    查看所有属性和方法

 _  网页源码


 网页分析与链接发现
网页分析，即将爬取到的网页内容进行分析，提取需要的内容。链接发现，即提取该网页中需要进一步爬取的  地址，或者利用网页内信息构建  地址。
网页分析所针对的内容，大致分为：结构化内容如  和 、半结构化内容如一条含  的  语句，非结构化内容如纯 。严格意义上说，结构化内容为固定的类似数据库二维表一样的内容，这里仅针对网页内容做适当的分类调整
针对  ，推荐使用  进行分析。 的使用非常简单，用于爬虫时也无需用到高级特性，常用方法如下例所示：
      
 =   

   打印标题

   打印  =   标签区域的文本

   打印  = 腾讯网  标签区域的文本

   打印  = = 腾讯网  的连接内容
针对 ，可使用  原生的  模块进行分析。
针对半结构化的内容，则需要特定的分析，一般格式固定，如添加定长的前缀和后缀，但此处无法通用，针对性强，比如含有  内容，只能固定暴力地将其提取出来再分析。
任务去重与调度
主要是防止网页的重复抓取，比如  中包含了  的地址， 中又包含了返回  的地址，如果不做去重，则容易造成爬虫在  和  间死循环的问题。但同时也要注意去重的时间窗口，无限期的去重将导致网页内容无法重新爬取被更新。调度是从系统特性的角度出发，网页爬取的主要耗时是在 网络交互，等待一个网址进行  解析、请求、返回数据、异步加载完成等，需要几秒甚至更长的时间。小批量任务情况下，简单地使用多线程、多进程都可以解决问题， ，也可以使用  开源的  框架内的  模块做协程，  本身也提供了异步  关键字。
数据存储与预处理、防反爬虫策略、进度展示
数据预处理，即筛掉无用的内容，并格式化有用数据，降低存储的压力和数据大小，也方便后期分析处理。一般网页抓取时，需要的是展现在用户面前的文字和图片信息，而网页内的  样式表、 代码等则不那么关心，这时，同样推荐使用  进行数据提取，简直方便好用不过  存在一些小 ，标签解析在特定情况下易被  打断。防反爬虫则可以搜索下防爬虫反爬虫等关键字，看下实现原理，如果目标网站有，进行针对性破解即可，一般采用随机  和  降频等策略都可以绕过，挂代理换  就会麻烦一些，不过大多数浏览器驱动也都支持。
数据展示
这是额外的说明，爬取到数据后，进行数据统计分析之后，是要用来辅助决策的，要展示给老板或产品看的，如何直观地将成果展示出来呢？这时推荐使用  的  组件进行数据展示。 上有  的  封装，但使用起来比较麻烦，学习还需要耗费不少时间，这里封装了几个常用图表形式的简易  接口，如果需要其他类型的图，按照  的文档进行和已有代码稍加扩展即可扩充，简单易用。代码整理上传后贴链接
二、常见爬虫实现
基础知识介绍完后，我们来搭建实际的系统。不管是自己动手，还是使用做好的框架或者产品，都需要知道自己的目的是什么，要达到什么样的目的，如果想加深知识学习，那无疑自己动手做一套是最合适的，如果是需要快速完成工作，最好是使用现成的框架或产品。
自己动手
如果想自己开发一个的话，作者也是支持的，简单开发将基础组件联动起来，也可以完成任务，虽然坑比较多，尤其是异常环节处理以及编码问题的解决。但话说回来，经验不就是从踩过的坑中学习的吗？如果想在这方面有所作为，自己写或仿写都是必不可少的学习途径。
由于自己开发的起点层次有很多，最底层的可以从自己建  链接解析  协议开始，也可以从利用已有  开发库开始求别说最底层应该从写操作系统或协议栈开始。。。。
常见的使用  开发爬虫的套路：
 做多进程任务分发  网页抓取  网页分析加链接生成  或  做结果存储 自定义数据统计分析  做报表图。
其中，网页获取可以用  来替代， 也可以用  或正则来替代，但这两者都不推荐，用起来比   麻烦。
 常用的就是 ， 可以用来存储  对象，如果你的数据分析也是  脚本实现， 无疑可以降低不少解析时间。
 做报表图是画报表后生成图片格式。这里也建议使用  来做报表，只是  生成的结果是展示成网页形式，动态渲染。
在常见的报表知会场景中大致分为两种：、发定期邮件看走势；、网页展示。如果需要定期邮件，公司内部有提供从  发送邮件 的工具，可以找运维要一下。但是该工具限制无法直接发送图片，通过将邮件做成  格式，将图片转为  内嵌进  即可。
那么如何将  生成的报表导出图片呢？新版本的  有提供接口，但并不是很好用，因为你的报表也不仅仅是一个图，多个图还要手工拼装，根据邮件客户端的不同，有可能展示的样式也会有变化。 这里我们仍然可以使用  来完成，原理就是使用浏览器对渲染后的页面进行整页截图。实现的原理也比较简单，使用  代码，控制浏览器直接以图片形式渲染网页，之后保存。由于该需求反响强烈， 官网也提供了解决方案：，即下载 ，按照下面命令来执行截图。
这个命令的含义是使用  运行  渲染 _ 并将结果保存到  中。
   _ 
生成截图的过程中有可能遇到的坑，在这里也提一下，希望后来的同学不会再因为这个问题浪费时间：首先，控制  进行截图的时候，有可能截图不完整，这是因为网页有一个动画绘制的过程如  图表页，可以修改  内设置的默认  的超时渲染时间到  甚至更长，保证网页加载完后再截图。另外，在公司环境下，爬虫多部署在  端的  系统下，服务器系统很少安装字体文件，如果截图出的内容中文字缺失或跟本地预览样式不符，一般就是这个问题了。 
 
如果到百度或者谷歌上搜  爬虫关键字的话，你肯定会看到有不少人推荐使用 。 是不错的爬虫库，或者说是爬虫框架，着重实现了上述的 网页爬取、任务去重调度功能，也提供网页内容分析，不过是  的形式。其他方面，如 结果存储 和 进度展示 需要开发者自己完成，也没有提供简便的频控防反爬虫策略的功能。
这个框架历史悠久，文档相当的齐全，社区也活跃，不再花大篇幅介绍，使用方面可以看 
 
，是近几年国人开发的一款爬虫产品，之所以提升到产品级别，是因为该框架提供了相当完善的爬虫全流程的功能。从网页爬取，到内容分析，再到频控，定时刷新，数据存储，分布式部署等，做得可圈可点，且相当易用，也是本文重点推荐的系统。
 简单的二次开发接口，同时自带了一个页面开发调试器。在实际的应用中，配合  进行页面渲染获取动态加载数据非常方便。
这里的我们先看使用方法，体验一下  的强大和易用，再来介绍该框架的架构和实现方法。
 
安装：
   
运行： 
 
如果已安装 ，则可使用     来配合使用。
访问、开发：

  后，直接点击  ，即可进入页面式的开发调试环境，非常方便。

我们以  的一个简单例子来介绍下二次开发代码的含义

之后点击右上角  后，返回首页，修改   和  后， 点击  即可执行：

关于 ，这里是采用令牌桶做的频控，这里设置  的含义是： =  每秒发起  个请求，即  一个请求，耗费一个令牌； = ，最多并发发起  个请求，即耗费  个令牌，那么也意味着并发后，第  个请求，要等待 。
另外， 安装完即可用，默认采用  作为数据库，单机部署，使用本机的  和 。单机性能不足以支撑时，也可以支持各模块的分布式部署。如果需要分布式部署，就需要了解下  的架构情况，和基本的实现原理。
下面来简要地看一下 的架构：
 
从图中可以看出， 主要的构成模块为 调度器 ，网页爬取 ，数据预处理与链接发现 ， 到数据库，还有  页面的进度监控、运营。
结合上述谈到的爬虫几大块，浅显地看一下  的实现：
 部分，使用  模块实现。
 部分使用  的  模块内的  做协程，当 _ =  的时候则链接  进行数据的爬取，否则直接异步爬取。
 处理阶段，提供了  解析对象 ，也可以直接访问页面源码进行解析，链接发现需要用户自己完成， 也提供了方便的接口  即可筛选出所有的  标签对象。
任务调度， 采用数据库来存储需要的任务， =    为   保存每个任务链接上次执行的时间以及更新时间，以此方式去重和筛选出可执行的任务，放入内部执行队列中，由  提取执行。表结构如下：
  `__` 

                  

                

                 

                   

                 

                

  `____`  `__` 
数据存储，也是可配置的，但几十万链接的小量，还是可以用  来存储。表结构如下：
  `__` 

                  

                

                

                

                
三、一些遗留的问题及小技巧
、 使用  抓取页面时发现，当请求量较大，会存在  有大量链接未关闭，从而停止响应。没有深入定位具体原因，采用暴力定时重启  的方式来解决了，有遇到的同学可以深入定位一下。
、另外，  是可以通过执行  代码来操作浏览器动作的，所以遇到翻页自动加载的情况，可以寻找页内的  元素传送  事件。
、如果目标网站量较少，不妨试一下手机端的站点，一般手机端站点为了优化用户体验，都提供了异步加载功能，提供异步加载，则很大可能是使用  进行  明文形式的查询和结果返回，可以通过  的  或  的响应式设计模式，记录请求 ，直接定位到网站自身提供的  查询接口，要比解析网页事半功倍了。导语
 埋点是数据运营中很重要的一个环节。之前我们讨论过用户分群的方式、漏斗转化的改进，但所有数据的来源是数据采集，很多时候就是的埋点。

数据只有采集了才能做分析，分析了才能实现价值。
——托马斯·维尼


图 数据运营微笑模型
上图是数据运营解决问题的思路，但相对的，数据运营分析的需求，也驱动着数据埋点的优化。
有时候，我们可能会遇到这样的尴尬：
数到用时方恨少！木有结论肿么破！
其实，数据埋点比我们想象得有更多挖掘的空间，有针对性的有条理的埋点能够帮助我们理清用户行为轨迹、抓住用户特征、解析关键路径。
但过多的埋点，可能会给带来负担，也可能对用户的流量、网速体验有影响，这都是我们需要考虑的因素。全埋点、多采集，并不是数据分析体系构建的办法，反而是把分析挖掘的工作量后移，给数据分析带来很多负担。
较好的做法是：带着我们的分析目标与数据解读思路去埋点。腾讯移动分析在数据埋点上做过多次优化，能确保多次采集一次上传的数据传输过程，减少对用户流量的影响，优化用户体验。
下面我们分几个层次来讨论埋点问题：
、用户行为分析
通过埋点可以追踪用户的行为，即对内的关键路径进行监测，这无疑是最常见也是最重要的应用场景。
不同的可能关注的埋点事件有很大不同。
例如，电商类多关注的是订单成交；社区类可能关注内容的产生；阅读类则需要关注内容的阅读。
用户埋点的场景很灵活，埋点可以统计的事件数据能和业务数据进行打通。
比如在新闻阅读的中，将阅读新闻作为自定义事件，每一篇报道都带有不同的参数，可以得到阅读的大盘整合数据，也可以分析每篇报道的价值，甚至可以方便的实现阅读量排行榜等功能。
埋点是因业务场景需要而定的。
比如第二篇时讲到的漏斗细分中，有一个金融用户案例。在绑卡流程转化流失率过高的时候，需要定位每一个输入框的填写方式是否存在问题，这时埋点的密度会比一般情况要高很多。

图 定位问题时的埋点示意
上述埋点是基于我们想要定位“为什么绑卡页面转化率低”的需求。埋点之后，在绑卡流程漏斗中，会生成一个详细填写页面的漏斗，从中我们或许能知道用户是在哪一步停止操作的，是否有改进的空间。

图漏斗拆解由于业务数据敏感性，以上数据已做模糊处理但如果之后我们修复了问题，我们可能就不需要这么细致的埋点了，或者我们只需要对可能出问题的地方进行埋点监控。

图稳定后的埋点示意图
因此，业界所说的全埋点是一种未充分理解自身业务时采用的策略，很多时候也无法满足详细漏斗的追溯要求。而不必要的埋点带来了过量的数据上报，一方面加重了用户的流量负担，另一方面也不利于后期的复盘分析。
当然如果真的是业务上线了，点还没埋上，腾讯移动分析新近推出了可视化埋点功能，可以由产品、运营同学通过端配置埋点，云端下发至中，随时调整内的埋点策略，也是机智而有效的救急措施。
开发再也不用担心我漏埋点啦
、用户人群分析
根据用户事件、来源渠道、同期群，甚至年龄、性别、地域等，我们可以把自己的用户切割为很多小群体。
比如在订单购买的业务中，将订单金额作为参数上报，能够更好的分析用户的价值。下图是一种消费用户分群的方式，以消费金额、消费频率和最近一次消费时间，得到个象限的用户，可以对不同的用户进行不同的运营推广策略。

图 消费用户分群模型
还是看这个电商，当用于活动运营分析的时候，可能数据分析的视角和方式就不太一样了。
举个例子：活动时间新注册同期群且完成过一次订单的这群用户，他们在活动期结束之后，会有哪些表现？

购买会员的转化率高于平均活动水平→某个新的广告渠道带来了优质的新客户，该渠道可以继续投入，持续关注效果；
继续参与七夕节的活动→人群可能对活动信息比较敏感，适合推荐促销信息；
流失曲线再次开启时间的关系是：周内不再开启的客户，都流失了→我们如果在新用户注册后周左右的时间通过、短信、邮箱等手段唤醒用户，能够大幅提高留存。

通过把人群切分，去分析业务特性，能够加深对用户的理解，结合你的触达手段，能够让你更好的与用户交流互动，实现业务运营的目标。
而这里的人群切分方式，就需要通过埋点定义出自定义事件，通过事件与其他条件的叠加、筛选，与不同事件、报表做交叉分析，就能够凸显核心用户群体的价值，精细化运营不同用户群体。
点击不同按钮、关注不同板块、甚至不同注册时间的人群都有不同的特性。
精细化的分析运营需要对业务的深入理解，需要学会切入分析的角度，解析你的用户的特征，了解你的用户，再由数据的需求去驱动埋点的配置。
、解析核心路径
第三点是基于第二点的应用。通过切割用户人群，再回到业务关键路径上，去发现吸引用户、留住用户的奥秘。
举一个比较知名的例子。

在某知名社交的数据分析运营分享中，通过不同的事件对比，可以发现天内添加个好友的留存率大大提高。

我们回溯一下，如果我们想要分析什么才是这个留存率的关键，我们需要罗列很多的可能性，比如在平台上浏览条新闻、引荐名新用户加入、产生内容或者是上传张照片、玩过平台游戏。那么，我们需要对比这些人群，寻找在这些事件中哪些才是与留存率强相关的？
如果是添加好友的这件事，那么这个时间限是，注册时关注人，还是一周内关注人？
或者如果我们发现，引荐名新用户，留存率非常高，但实际上，真的能引荐名新用户的人群少之又少，那么这件事也不适宜我们去重点关注，因为给我们带来的成本太高了。

图自定义事件与留存相关度的分析示例
从这些关键事件中，我们要通过数据分析找到其中的核心路径，然后倾斜我们的资源去支持它。
好啦，今天的分享就到这里了。总的来说，埋点与数据统计，都是为业务服务的。关注哪些事件、为他们埋点是由于自身的业务特性所决定。
埋点需要有的放矢，分析才能得到结论，迭代增长也将有迹可循。作者：成一鹏
导语： 在云计算资源管理中，热迁移是实现资源配置的重要手段，常常会因为多种场景需要发起热迁移：例如资源调配，母机负载均衡以及运维人工热迁移等场景。 而在当前热迁移任务中，热迁移在经过多次条件过滤后还是会不时遇到迁移超时失败的情况，在不恰当时机发起迁移任务，不仅影响了客户了体验，也影响了热迁移效率。

简要
主要解决热迁移对象在内存利用变化快，磁盘读写速率快等状态的情况下无法判断其是否适合发起热迁移。
本次任务方案选择了多集成学习算法的投票选举，这是一个基于业界主流算法的混合预测模型。真实数据集作为验证，预测精度，实现对热迁移发起任务的成功率预测，对于超时迁移识别的样本识别率实现，也就是说可以减少原来热迁移超时失败情况数量的。
  需求背景
在云计算资源管理中，热迁移是实现资源配置的重要手段，常常会因为多种场景需要发起热迁移：例如资源调配，母机负载均衡以及运维人工热迁移等场景。
而在当前热迁移任务中，热迁移在经过多次条件过滤后还是会经常遇到迁移超时失败的情况，发起不合适的热迁移任务，不仅影响了客户了体验，也影响了热迁移效率。
按以往人工经验去进行判断是否适合热迁移，例如内存变化率高会影响热迁移，使用率 过高也会影响热迁移，
在这之前尽管我们知道内存变化率过高，使用率过高，乃至内外网吞吐量过高都会影响到热迁移的成功， 但我们无法去构建一个衡量标准。并且如果频繁去监控获取子机的这些数据，也会对虚拟机性能造成影响，并且人工也无法去判断什么时间点哪些情况下哪个指标更重要，因此无法形成一个综合而客观稳定的判别标准。
  实现目标
所以我们引入了机器学习深度学习，希望能够拟合一个复杂模型去计算并量化出一个适合热迁移的状态标准，实现对热迁移发起后是否会超时失败进行预测。
  实现简介
特征空间

特征处理
考虑到每列数据的差异有个数量级差别，所以需要对大数量级的列数据 进行缩放。常用的做法有 ，。
 特征相关性分析
热力图是最直观的展示特征之间的线性相关性，从图中我们可以看到和呈强相关性，这是显然的结果，高性能往往伴随大内存；其次呈现中等相关的是出入流量。由此简单可以看出各个特征参数都是相对独立的，从线性相关角度看。

算法简介：为什么选择随机森林与
随机森林
如果从深度学习的角度去理解，可以认为随机森林的决策树随机分裂，隐含地创造了多个联合特征，并能够解决非线性问题，
可以相对离散地自动提取特征与权重学习。某种意义上实现的卷积池化提取作用。
并行计算，对于个别特征缺失不敏感。
当构建决策树时，每次分裂时，都从全特征候选集中选取个进行分裂，一般=。
随机森林不会出现过拟合，只要树的个数足够大时会使得错误率降低。

在比赛中的必备算法，属于 的高效实现。并且有以下三处的改进：
 在目标函数中显示的加上了正则化项，基学习为时，正则化项与树的叶子节点的数量和叶子节点的值有关。 中使用 对的一阶导数计算出伪残差用于学习生成，不仅使用到了一阶导数，还使用二阶导数。 回归树中寻找最佳分割点的衡量标准是最小化均方差，寻找分割点的标准是最大化，，与正则化项相关。

通过迭代实现把弱分类器训练成强分类器，每一次迭代后会对错误数据的关注度更高策略为最小化分类误差率，使得下一个基学习器会对上次迭代数据更有更多的针对性，最终构建成附带权重的线性组合集成学习。
在数据清洗干净的情况下，效果会更好。
模型性能
 召回率

：
把模糊的行业经验变得更科学，更精准：
根据模型预测结果计算出影响热迁移的重要指标
使用率对热迁移成功最关键，其次是包的进出流量，磁盘读取速率反而影响力很低。
 
由图我们可以看到使用率对热迁移成功与否的影响力占比去到，显著高于其他特征参数，这也是符合人的经验逻辑的，
当一台子机使用率占用达到一定比例之后，如果后台再发起热迁移必然会占用部分系统资源，
而形成热迁移超时往往也是因为没有足够资源进行响应。
其次我们可以看到进出包量的影响力是同等 ，再然后是内存使用率以及磁盘使用率。
可以注意到的是进出包量的影响力比我们想象的要高很多，而磁盘读取速率磁盘写入速率的重要性却要比我们想象的低，
这样的反馈结果根据我们的直观经验是无法获得的。
再往后热迁移发起任务中，我们也可以依据以上的分析结果，
如果迁移策略能够提前分配额外资源进出带宽给到迁移对象，相信会大大减少热迁移超时失败的情况。
后续改进
经验总结
在实际工程实施中，除了模型的构建 特征处理以外，第一步的数据收集，输入参数空间的构造都是至关重要的，数据集的大小以及质量直接决定了模型性能的上限。一方面除了收集实践经验判断相关的重要参数，另一方面也不能去简单排除其他看起来似乎不相干的特征参数，因为往往判断结果有可能与人的直觉相左右，总之尽可能的收集所有相关参数，然后再通过特征工程进行筛选去重是比较合理的做法。
在本次预测模型构造中，数据预处理去除脏数据，缺失数据后剩下的负样本数量还处在级别，一般而言对于一个机器学习任务 样本数量级别达到万个是比较合适的，
另外目前正负样本比例不均衡也给模型性能的提升和预测带来很大困难，这个问题相信伴随数据量的增长以及改善采集数据缺失情况后会得到较大改善。
 后期展望
部署优化
在后期优化中，会联通我们的数据仓库实现数据自动采集，模型自动训练以及自动部署。
功能扩展
在后续热迁移技术改进中：我们会根据在不同的资源约束和工作负载下去预测不同实时迁移算法的关键参数。对基于实时迁移算法的迁移任务，构建机器学习模型预测迁移任务的总迁移时间，停机时间以及传输的总数据量。
技术框架
主要包含服务框架，仓库，服务层，后期的所有预测服务数据挖掘分析都将在这个框架下运行，不限于数据采集 模型训练 版本管理以及部署发布。
 
是一个工业级可用于机器学习模型  的高性能开源库。它可以将训练好的机器学习模型部署到线上，使用  作为接口接受外部调用。将训练出来的模型更好的应用在生产环境中通过等等支持的方式来方便对外提供稳定可靠的服务服务器结构
： 负责任务调度，负载转发，
目前已实现台机器容灾部署，统一接入实现负载均衡。

主要负责与通信和调用模型，通过调用  的   和  的 _ 从而构建一个 。
接入流程：最近天，互联网圈和技术圈的热点话题非微信“小程序”莫属。有些文章从产品角度探讨哪些类型的服务适合做成应用号，也有直接发布内应用号的开发教程的。做为腾讯云的技术布道师，我想换个不一样的角度，从我熟悉和关注的移动开发技术栈的演进角度，讲讲移动开发技术下来可能会发生的变化，以及对于移动应用开发者可能带来的三点重大影响。
在国内的流行与微信息息相关，一个小小的创业团队用业余时间开发的“围住神经猫”这样一个轻游戏轻松就获得了上亿次访问，做为一款现象级的产品直接拉动了国内企业与市场对于开发者的需求。核心的优势在于开发过程的足够轻量，但同时这样轻的技术语言本身也不是完美无缺，“围住神经猫” 这款游戏本身没有建立自己的用户体系，带来的实际问题就是上亿次的用户访问并未沉淀在这个创业团队手上，成为他们真正的用户资产。
做为开源的移动开发语言，基本的理念是能不能类的语法做移动端的开发，开发者只要去写一次代码，就能同时在和两类手机操作系统上运行，减少移动开发的工作量。
我们可以看到应用号应该是通过的方式将部分系统级的权限和微信独有的社交和支付接口开放给了应用号，同时实现了设计的初衷，一次开发，两端运行。应用号所提供缓存、文件操作和等接口，让腾讯云上的移动开发者有机会把自己的“小程序”做的比游戏更重一些，这也意味着开发者可以更好地在微信应用号的平台上沉淀属于自己的用户资产。 图 移动开发技术栈的演进
微信应用号的开发语言是标签语言的子集，而且语言设计上有着的影子，有这两种语言基础的开发者学习应用号开发会更容易
今天，我在国内主流搜索引擎搜索“应用号开发“结果 个，搜索”“ 结果 个。结果也可以看出，已经流行了年的技术在热度上比不上新出的应用号开发。我的预期是会有不少学 的人开始转向应用号开发学习，没有内测资格的会先学习微信服务号开发。
图 应用号开发语言三种语言接口、功能对比注：以上应用号信息来自于腾讯科技报道 
微信应用号所开放的手机、文件处理、重力感应等“系统级接口” 加上微信自身的社交、支付接口，将会为移动开发者极大赋能，开发者可以更轻量级地开发出更多新的玩法
通过上表开发语言的对比看出，语言里面虽然设计了一定的地理定位、系统信息获取等涉及手机客户端的底层能力，但实际上由于手机操作系统的权限设计限制，这些接口的访问都是需要系统授权的。下图是我分别在浏览器和微信内置浏览器中运行的 获取地理位置方法的结果：
 浏览器中的系统授权请求被屏蔽了，没有提示，也无法返回结果。 微信中能够弹出的系统授权请求，在点击“同意”后，可以反馈出手机对应的经度纬度。图【位置读取】浏览器  微信内置浏览器
 小程序应用号可以让你的应用火，而云计算可以让你在火了之后不会宕机
下图是我个人预计大部分应用号的前后台技术架构，应用号的前端的开发语言基本上应该是应用号扩展的标签语言，后台服务的开发其实不论是用或者是应该都是可以的。
但是对于预计访问量较大，需要实现高可用的应用号而言，就需要考虑使用负载均衡，内加速，云缓存等服务来保证应用的访问体验；如果涉及电商秒杀场景还可以考虑使用腾讯云的消息队列；对于安全性要求较强的金融与游戏类应用，则需要考虑接入大禹服务来抗攻击、接入天御防刷服务来抵御恶意用户。
图 预期的应用号技术架构
小结：
微信小程序应用号的出现，伴随着更开放的手机“系统级”接口和微信社交支付接口，让创业者有机会和时代一样，打造出下一批现象级的互联网应用。但云计算能够给这些受欢迎的应用号，提供高可用、高扩展与安全性。
一句话总结，“小程序可以让你火，云计算可以让你在火了之后，不会宕机”。
附：我们这边写的一个小程序，小时就可以快速搭建。

相关推荐
如何个小时快速搭建一个应用号演示与框架
如何个小时快速搭建一个应用号搭建流程
如何个小时快速搭建一个应用号组件与
腾讯云小程序解决方案系列推荐
机器学习概念总结笔记一机器学习概念总结笔记二机器学习概念总结笔记三

聚类分析是一种静态数据分析方法，常被用于机器学习，模式识别，数据挖掘等领域。通常认为，聚类是一种无监督式的机器学习方法，它的过程是这样的：在未知样本类别的情况下，通过计算样本彼此间的距离欧式距离马式距离，汉明距离，余弦距离等来估计样本所属类别。从结构性来划分，聚类方法分为自上而下和自下而上两种方法，前者的算法是先把所有样本视为一类，然后不断从这个大类中分离出小类，直到不能再分为止；后者则相反，首先所有样本自成一类，然后不断两两合并，直到最终形成几个大类。
常用的聚类方法主要有以下四种：  如  层次聚类法。  如。  ；  。
是最经典的聚类算法。算法接受参数  ；然后将事先输入的个数据对象划分为 个聚类以便使得所获得的聚类满足：同一聚类中的对象相似度较高；而不同聚类中的对象相似度较小。聚类相似度是利用各聚类中对象的均值所获得一个“中心对象”引力中心来进行计算的。
算法的基本思想是：以空间中个点为中心进行聚类，对最靠近他们的对象归类。通过迭代的方法，逐次更新各聚类中心的值，直至得到最好的聚类结果。
假设要把样本集分为个类别，算法描述如下：适当选择个类的初始中心；在第次迭代中，对任意一个样本，求其到个中心的距离，将该样本归到距离最短的中心所在的类；利用均值等方法更新该类的中心值；对于所有的个聚类中心，如果利用的迭代法更新后，值保持不变，则迭代结束，否则继续迭代。该算法的最大优势在于简洁和快速。算法的关键在于初始中心的选择和距离公式。
聚类是一种自下而上的聚类方法，它的优点是简单、速度快；缺点是聚类结果与初始中心的选择有关系，且必须提供聚类的数目。的第二个缺点是致命的，因为在有些时候，我们不知道样本集将要聚成多少个类别，这种时候是不适合的，推荐使用 或来聚类。第一个缺点可以通过多次聚类取最佳结果来解决。
混合高斯模型
高斯模型就是用高斯概率密度函数正态分布曲线精确地量化事物，将一个事物分解为若干的基于高斯概率密度函数正态分布曲线形成的模型。对图像背景建立高斯模型的原理及过程：图像灰度直方图反映的是图像中某个灰度值出现的频次，也可以以为是图像灰度概率密度的估计。高斯模型常用于运动检测。 高斯模型有单高斯模型和混合高斯模型两种。
高斯混合模型，顾名思义，就是数据可以看作是从数个高斯分布中生成出来的。虽然我们可以用不同的分布来随意地构造    ，但是 是 最为流行。另外，  本身其实也是可以变得任意复杂的，通过增加  的个数，我们可以任意地逼近任何连续的概率密分布。
每个  由  个  分布组成，每个  称为一个“”，这些  线性加成在一起就组成了  的概率密度函数：

其中，π表示选中这个部分的概率，我们也称其为加权系数。根据上面的式子，如果我们要从  的分布中随机地取一个点的话，实际上可以分为两步：首先随机地在这  个  之中选一个，每个  被选中的概率实际上就是它的系数 π，选中了  之后，再单独地考虑从这个  的分布中选取一个点就可以了──这里已经回到了普通的  分布，转化为了已知的问题。假设现在有  个数据点，我们认为这些数据点由某个模型产生，现在我们要需要确定 πμσ 这些参数。很自然的，我们想到利用最大似然估计来确定这些参数，的似然函数如下：

如何用  来做  呢？其实很简单，现在我们有了数据，假定它们是由  生成出来的，那么我们只要根据数据推出  的概率分布来就可以了，然后  的  个  实际上就对应了  个  了。根据数据来推算概率密度通常被称作   ，特别地，当我们在已知或假定了概率密度函数的形式，而要估计其中的参数的过程被称作“参数估计”。
现在假设我们有  个数据点，并假设它们服从某个分布记作  ，现在要确定里面的一些参数的值，例如，在  中，我们就需要确定 影响因子、各类均值 和 各类协方差 这些参数。 我们的想法是，找到这样一组参数，它所确定的概率分布生成这些给定的数据点的概率最大，而这个概率实际上就等于  ，我们把这个乘积称作似然函数  。通常单个点的概率都很小，许多很小的数字相乘起来在计算机里很容易造成浮点数下溢，因此我们通常会对其取对数，把乘积变成加和 ，得到   。接下来我们只要将这个函数最大化通常的做法是求导并令导数等于零，然后解方程，亦即找到这样一组参数值，它让似然函数取得最大值，我们就认为这是最合适的参数，这样就完成了参数估计的过程。
下面让我们来看一看  的   ：

由于在对数函数里面又有加和，我们没法直接用求导解方程的办法直接求得最大值。为了解决这个问题，我们采取之前从  中随机选点的办法：分成两步，实际上也就类似于 的两步。
算法流程分为以下步：  估计数据由每个  生成的概率并不是每个  被选中的概率：对于每个数据 _ 来说，它由第  个  生成的概率为


通过极大似然估计可以通过求到令参数=得到参数，的值。



重复迭代前面两步，直到似然函数的值收敛为止。


传统判断两个文档相似性的方法是通过查看两个文档共同出现的单词的多少，如等，这种方法没有考虑到文字背后的语义关联，可能在两个文档共同出现的单词很少甚至没有，但两个文档是相似的。
举个例子，有两个句子分别如下：
“乔布斯离我们而去了。”“苹果价格会不会降？”
可以看到上面这两个句子没有共同出现的单词，但这两个句子是相似的，如果按传统的方法判断这两个句子肯定不相似，所以在判断文档相关性的时候需要考虑到文档的语义，而语义挖掘的利器是主题模型，就是其中一种比较有效的模型。
在主题模型中，主题表示一个概念、一个方面，表现为一系列相关的单词，是这些单词的条件概率。形象来说，主题就是一个桶，里面装了出现概率较高的单词，这些单词与这个主题有很强的相关性。
怎样才能生成主题？对文章的主题应该怎么分析？这是主题模型要解决的问题。首先，可以用生成模型来看文档和主题这两件事。所谓生成模型，就是说，我们认为一篇文章的每个词都是通过“以一定概率选择了某个主题，并从这个主题中以一定概率选择某个词语”这样一个过程得到的。那么，如果我们要生成一篇文档，它里面的每个词语出现的概率为：
这个概率公式可以用矩阵表示：
其中”文档词语”矩阵表示每个文档中每个单词的词频，即出现的概率；”主题词语”矩阵表示每个主题中每个单词的出现概率；”文档主题”矩阵表示每个文档中每个主题出现的概率。给定一系列文档，通过对文档进行分词，计算各个文档中每个单词的词频就可以得到左边这边”文档词语”矩阵。主题模型就是通过左边这个矩阵进行训练，学习出右边两个矩阵。
主题模型有两种：  和  。
  是一种文档主题生成模型，也称为一个三层贝叶斯概率模型，包含词、主题和文档三层结构。所谓生成模型，就是说，我们认为一篇文章的每个词都是通过“以一定概率选择了某个主题，并从这个主题中以一定概率选择某个词语”这样一个过程得到。文档到主题服从多项式分布，主题到词服从多项式分布。
是一种非监督机器学习技术，可以用来识别大规模文档集 或语料库中潜藏的主题信息。它采用了词袋  的方法，这种方法将每一篇文档视为一个词频向量，从而将文本信息转化为了易于建模的数字信息。但是词袋方法没有考虑词与词之间的顺序，这简化了问题的复杂性，同时也为模型的改进提供了契机。每一篇文档代表了一些主题所构成的一个概率分布，而每一个主题又代表了很多单词所构成的一个概率分布。
对于语料库中的每篇文档，定义了如下生成过程：对每一篇文档，从主题分布中抽取一个主题；从上述被抽到的主题所对应的单词分布中抽取一个单词；重复上述过程直至遍历文档中的每一个单词。语料库中的每一篇文档与通过反复试验等方法事先给定个主题的一个多项分布 相对应，将该多项分布记为θ。每个主题又与词汇表中的个单词的一个多项分布相对应，将这个多项分布记为φ。

   标准潜在语义分析，的基本思想就是，将从稀疏的高维空间映射到一个低维的向量空间，我们称之为隐含语义空间  
如何得到这个低维空间呢，和采用特征值分解的思想类似，作者采用了奇异值分解  的方式来求解  。的优点在于：低维空间表示可以刻画同义词，同义词会对应着相同或相似的主题；降维可去除部分噪声，是特征更鲁棒；充分利用冗余数据；无监督完全自动化；与语言无关；的不足在于：没有刻画出现次数的概率模型；无法解决多义词的问题；的优化目标基于  或者是  的，这相当于隐含了对数据的高斯噪声假设。而出现的次数是非负的，这明显不符合假设，而更接近分布；对于  而言，欧式距离表达是不合适的重建时会产生负数；特征向量的方向没有对应的物理解释；的计算复杂度很高，而且当有新的文档来到时，若要更新模型需重新训练；维数的选择是的；
  概率潜在语义分析是基于双模式和共现的数据分析方法延伸的经典的统计学方法。概率潜在语义分析应用于信息检索，过滤，自然语言处理，文本的机器学习或者其他相关领域。概率潜在语义分析与标准潜在语义分析的不同是，标准潜在语义分析是以共现表就是共现的矩阵的奇异值分解的形式表现的，而概率潜在语义分析却是基于派生自的混合矩阵分解。考虑到和共现形式，概率潜在语义分析基于多项式分布和条件分布的混合来建模共现的概率。所谓共现其实就是和的一个矩阵，所谓双模式就是在和上同时进行考虑。

从大规模数据集中寻找物品间的隐含关系被称作关联分析 或者关联规则学习  。
关联分析是在大规模数据集中寻找有趣关系的任务。这些关系可以有两种形式：频繁项集；关联规则。频繁项集  是经常出现在一块儿的物品的集合，关联规则 暗示两种物品之间可能存在很强的关系。
我们用支持度和可信度来度量这些有趣的关系。一个项集的支持度被定义数据集中包含该项集的记录所占的比例。如上图中，{豆奶}的支持度为，{豆奶尿布}的支持度为。支持度是针对项集来说的，因此可以定义一个最小支持度，而只保留满足最小值尺度的项集。可信度或置信度是针对关联规则来定义的。规则{尿布}➞{啤酒}的可信度被定义为支持度{尿布啤酒}支持度{尿布}，由于{尿布啤酒}的支持度为，尿布的支持度为，所以尿布➞啤酒的可信度为。这意味着对于包含尿布的所有记录，我们的规则对其中的记录都适用。
假设我们有一家经营着种商品商品，商品，商品和商品的杂货店，图显示了所有商品之间所有的可能组合：

对于单个项集的支持度，我们可以通过遍历每条记录并检查该记录是否包含该项集来计算。对于包含中物品的数据集共有  −种项集组合，重复上述计算过程是不现实的。
研究人员发现一种所谓的原理，可以帮助我们减少计算量。原理是说如果某个项集是频繁的，那么它的所有子集也是频繁的。更常用的是它的逆否命题，即如果一个项集是非频繁的，那么它的所有超集也是非频繁的。
在图中，已知阴影项集{}是非频繁的。利用这个知识，我们就知道项集{}，{}以及{}也是非频繁的。也就是说，一旦计算出了{}的支持度，知道它是非频繁的后，就可以紧接着排除{}、{}和{}。

关联分析的目标包括两项：发现频繁项集和发现关联规则。首先需要找到频繁项集，然后才能获得关联规则正如前文所讲，计算关联规则的可信度需要用到频繁项集的支持度。
算法是发现频繁项集的一种方法。算法的两个输入参数分别是最小支持度和数据集。该算法首先会生成所有单个元素的项集列表。接着扫描数据集来查看哪些项集满足最小支持度要求，那些不满足最小支持度的集合会被去掉。然后，对剩下来的集合进行组合以生成包含两个元素的项集。接下来，再重新扫描交易记录，去掉不满足最小支持度的项集。该过程重复进行直到所有项集都被去掉。

算法基于构建，但采用了高级的数据结构减少扫描次数，大大加快了算法速度。算法只需要对数据库进行两次扫描，而算法对于每个潜在的频繁项集都会扫描数据集判定给定模式是否频繁，因此算法的速度要比算法快。
算法发现频繁项集的基本过程如下：构建树；从树中挖掘频繁项集。算法优点：一般要快于。缺点：实现比较困难，在某些数据集上性能会下降。适用数据类型：离散型数据。
构建树的过程如下：
输入：数据集、最小值尺度
输出：树、头指针表

遍历数据集，统计各元素项出现次数，创建头指针表

移除头指针表中不满足最小值尺度的元素项

第二次遍历数据集，创建树。对每个数据集中的项集：
  初始化空树
  对每个项集进行过滤和重排序
  使用这个项集更新树，从树的根节点开始：


 如果当前项集的第一个元素项存在于树当前节点的子节点中，则更新这个子节点的计数值
 否则，创建新的子节点，更新头指针表
 对当前项集的其余元素项和当前元素项的对应子节点递归的过程
相关阅读
机器学习概念总结笔记一机器学习概念总结笔记二机器学习概念总结笔记三索引基础
索引用途
索引有很多用途，并不仅仅是优化查询性能，这些用途包括：

保持数据完整性主键和唯一索引
优化数据检索性能使用索引进行条件匹配和模式匹配
改进表的连接操作使用索引连接表
优化结果排序操作 
优化聚合数据操作 

创建索引
创建表时指定索引主键索引：   非主键索引： |  下面的示例创建了一个主键索引和两个非主键索引，创建非主键索引时和可以互换。
  __ 
    _   
    _   
    _   
    _   
    _   
    _   
      _
     _ _
     ___
 =
在已有表上添加索引
主键索引：       非主键索引：     |  
查看索引
可以用 命令查看索引的信息，该命令输出包括索引的类型和当前报告的索引基数等信息。
    _

  | _ | __ | _ |  |  | _ |

  |   |             | _    |         |      |       |
  | _ |             | _  |         |      |       |
  | _   |             | _ |          |   |       |
  | _   |             | _ |          |   |       |

选定索引
索引有一些时间和空间上的缺点。首先，索引加快了检索速度，但却降低了许多写入操作的速度，包括插入、删除，以及包含索引列的更新。其次，索引要占用磁盘空间，索引越多，它所占用的磁盘空间也就越大。因此，索引并不是越多越好，我们应该有选择地使用索引。
筛选索引
通过阅读上节中的索引用途，我们不难得出，适合作为索引的是以下这些数据列：

子句中的列
 子句中的列
 子句中的列
用于表连接的列

上面只是数据列作为表索引的入选条件，满足这些条件的列可能有很多，我们还需要结合考虑以下因素进一步筛选。

考虑列在查询中覆盖的广度。
考虑数据列的区分度维度，选择区分度高的列作为索引。
优先考虑短小的列作为索引。越小的数据类型通常在磁盘、内存和缓存中都需要更少的空间，处理起来更快，整型有余字符串。
考虑为字符串前缀编制索引。
考虑为关联度高的字段编制复合索引，并将它们按区分度的高低从左到右排序。

单列索引复合索引
多个单列索引和一个包含这些列的符合索引，在时间和空间上孰优孰劣？下面是两者对比的一些结论，仅供参考。

复合索引中最左边的列可以当作单列索引高效地使用单列索引对它的优势并不明显。

复合索引中最左边之外的列单独作为索引时，相比单列索引有明显的劣势。

作为两个用连接的条件，单列索引有一定优势，因为复合索引将导致全表扫描。

作为两个用连接的条件：

如果两个列之间的关联度较低，复合索引有一定的优势。

如果两个列之间的关联度较高，复合索引有明显的优势。

单列索引占用的空间更多，对写入操作的性能影响更大。


两者的对比数据可以参考这个的文档：     。
避免冗余索引
没有限制索引的数量，用户甚至可以在一个表上创建完全相同的多个索引。如上所述，添加索引会影响写操作的性能，我们应该尽量控制索引的数量，避免创建重复的索引。本文第一节，我们为_创建了一个名字为_的索引： ___如果我们再为_增加一个名字为_的索引： __新增的_实际上是一个重复的索引，因为_已经为_创建了索引。
正确使用索引
定制了正确的索引还不够，我们还要正确使用它。
规则：不能将索引放在表达式中，必须是独立的列，否则无法启用索引带来的高效。
例如，下面这个查询无法使用_列的索引。
 _  _  _=
凭肉眼很容易看出中的表达式其实等价于 _=，但是无法自动解析这个方程式。我们应该养成习惯，将索引列单独放在比较操作符的一侧。同样，也不能将索引放在函数的参数中，本文不再赘述。
规则：避免隐式类型转换。
这个规则不仅适用于索引字段，也适用于其它所有字段。有些隐式类型转换会导致索引失效，例如：
 _  _  _=
 注意，_是类型的，而上述语句中的查询条件是 _=。将数值类型隐式转换成字符串类型来匹配表。
我们来看一下这条语句的执行计划：
     _  _=\  
   
            
  _ 
         _
    
          
_ 
           
      _ 
           
          
      
          
       
 看以看到，查询并没有使用索引，我们再看一下告警信息：
  \
   
   
    
                _
   
   
    
                _
   
   
    
     `_``_``_`  `_``_``_``_`  `_``_``_``_`  `_``_``_``_`  `_``_``_``_`  `_``_``_``_`  `_`  `_``_`  `_``_``_` = 
     
 隐式类型转换使_上的索引失效，这将导致全表扫描。我们应该养成习惯，让索引的类型与你打算进行比较操作的值类型保持匹配。
规则：验证索引的有效性。
要确定一条语句能否按照我们的预期使用特定索引高效地执行，命令是必不可少的工具。命令用于查看语句的执行计划。我们可以借助这条命令深入了解基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节_，被评估的索引，以及当运行语句时哪种策略会被优化器采用。理想情况下，我们应该对系统中的每条语句都执行命令。所有语句前都可以直接加上关键字。而对于和语句，需要把查询改写成语句，以确保有效地使用索引。
总结
索引是对查询性能优化最有效的手段之一。正确地使用索引能够轻易地将查询性能提高几个数量级。编写查询语句时，应尽可能地选择合适的索引，以避免全表遍历。如果一个查询无法从现有的索引中获益，则应看看是否可以创建一个更合适的索引来提升性能。如果不行，也可以看看是否可以重写查询语句，将其转化成一个能够利用现有索引或者新创建索引的查询。导语：   是由    在  年提出的二进制向量数据结构，它具有很好的空间和时间效率，被用来检测一个元素是不是集合中的一个成员。

前言
  是由    在  年提出的二进制向量数据结构，它具有很好的空间和时间效率，被用来检测一个元素是不是集合中的一个成员。
  最初的论文发表在，名为《       》，感兴趣可以下载阅读。本篇主要分享   的基本原理、代码实现以及误判率的计算，看过  那篇文章的童鞋再看这一篇会十分简单。
  也就是常说的布隆过滤器，后面就统一称为 。
一、原理
 可以高效地表示集合数据，它使用长度为  的位数组来存储集合信息，同时使用  个相互独立的哈希函数将数据映射到位数组空间。
直接上图，根据图来大致梳理一下算法流程。

初始化一个长度为的位数组，并将所有元素置为；

对于集合 ={ …} 中的任一元素，分别使用个哈希函数对其计算： ，并将位数组中的第  位置为；

对中所有的成员执行同样的操作。



基本的原理就是这么多，看一下图中的例子就能明白了。比如现在要  用  表示，我们会用两个哈希函数分别对  计算，计算结果分别是和， 然后对位数组中的第位和第位分别置即可。
当查询  是否在集合的时候，只需使用同样的哈希函数计算，如果对应位数组的位都为，则说明存在。只要有任意一位为， 则说明不存在。
二、实现
具体的实现可以直接看代码，用  写的一个简单的版本，总共也就行左右。代码和  的代码实现很接近，不同的是，哈希函数变成了多个。

三、误判率
 的基本原理说起来也很简单的，但是还有一些知识点需要关注一下。比如在  中，会出现误判，就是某个成员本来不在集合中，但是会被判断成在集合中。为了把误判率控制在一个可以接受的范围，我们就需要适当地调配能够影响误判率的几个因素：集合大小、哈希函数个数和位数组大小。
这三个影响因素中，和对于误判率的影响比较直观。
集合大小：当其它条件固定的时候，集合大小越大，则位数组中就会更多比例的位置被置为，因此误判率会更大。
位数组大小：同理，当其它条件固定时，位数组大小的值越大，那么数组中剩余为的位就会更多，因此误判率就会更小。
哈希函数的个数：比较难分析，比如将和固定，使用的哈希函数越多，则位数组中会有更多比例的位置会被置为，即增大的误判率，但是在查询时，如果哈希函数个数越多，则被误判的可能就越小。
然后该怎么找到个因素的最佳取值呢？这里省略推导过程，直接给出结论。
如果给定  和 ，当  取以下值时，误判率  的值最小：

此时误判率  等于：

在实际应用中，更常见的需求是，已知集合大小，并设定好误判率，需要计算出该给  分配多大内存合适，也就是要确认的大小，可使用如下公式解决问题：

有了这三个公式，可以在实际应用中灵活地设置各种参数来合理使用。
四、 总结
传统  只能添加元素，不能对元素计数，也无法删除元素。如果把底层数组的  换成 ，就可以支持计数和删除动作。每次插入元素时，将对应的  个  加一；查询时，返回  个  的最小值；删除时，将对应的  个  减一。这就是的改进版：  ，后面再来专门分享。作者：

术语事务指的是构成单一逻辑工作单元的操作的集合。比如：将钱从一个账户转到另一个账户就是一个事务，该事务包括分别针对每个账户的两个更新。
英文中又是交易的意思，我想应该是因为事务管理的场景首先是出现在利用银行账户进行交易的过程中，所以计算机科学家们把数据库的这一特性称为事务。
事务有以下几个属性：

原子性：事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。
一致性：隔离执行事务时换言之，在没有其他事务并发执行的情况下保持数据库的一致性。
隔离性： 尽管多个事务可能并发执行，但系统保证，对于任何一对事务和，在看来，或者在开始之前已经执行完成，或者在完成之后开始执行。因此，每一个事务都感觉不到系统中有其他事务在并发执行。
持久性：一旦事务执行成功，它对数据库的改变必须是永久的——即一个可能出现的系统故障不应该导致数据库忽略成功完成的事务。

这些性质通常成为特性，这一缩写来自四条性质的首字母。
在中我们可以借助框架来方便地实现事务操作，这里用来举例说明。
是一个基于的 框架，支持，和
简单来说，是一个优秀的代码库，它易于阅读、理解、可扩展。它不强制你使用任何特定的校验，而是提供灵活有效的关系或嵌套关系加载策略，一级类支持事务。它是一个精益的对象关系映射器   ，允许你使用原始的接口，因为当你需要自定义查询时，它有时并不能完全满足老一套的惯例。
遵从和一样棒的和思想，使用相同的模式、命名惯例和哲学构建轻量、易于操控的。如果你已经了解，你就知道如何使用
使用管理异步操作。
下面来演示如何使用进行事务管理
_
{
   
   {
          
          
          __
      __
      _
       
  }
}


 


    
   {}
 
  = 
     = _
 =  {
     

      {
         
    }

      = 

     = 

    
                
          
     
    

     
}


 

  = 

 一般情况下后台或者的同学会帮我们把数据库和表建好，我们直接操作就好。所以我们只需要利用已有的表结构初始化一个的实例来进行操作。
  = {
     
}

 = 


 

  = 

 一般情况下后台或者的同学会帮我们把数据库和表建好，我们直接操作就好。所以我们只需要利用已有的表结构初始化一个的实例来进行操作。
  = {
     
}

 = 


 

  = 
  = 
  = 

  {
       需要存入表的数据
     {   }
     {
         {   }  将新增的同时存入表中
         {   }
         {
               返回表的
        }
    }
} = {
     
} = {
     
}

关于的更多信息可以参考他们的官网：

原文链接：

相关推荐

在中玩转 
中错误捕获的一些最佳实践导语： “不需要人类知识” 得以实现是因为模型  提升器 的训练方法。在利用模型的基础上， 提升器总是强于模型本身，从而为模型提升指明了方向；模型的提升又进一步增强了  提升器的能力；这就形成了正向循环。一个总是比模型强的提升器，是正向循环能够建立的关键。

   已经出来一段时间了。本来   一出来就应该写科普的，但自己实在懒。等到现在才更新。

  最大的亮点是：完全没有利用人类知识，就能够获得比之前版本更强大的棋力。主要的做法是  利用蒙特卡洛树搜索建立一个模型提升器， 在自我对弈过程中，利用提升器指导模型提升，模型提升又进一步提高了提升器的能力。
 蒙特卡洛树搜索简介
蒙特卡洛树搜索      是一种树型搜索技术，具有如下所示的树型结构。

树中每一个节点  代表了一个围棋盘面，并带有两个数字。一个是访问次数，另一个质量度。访问次数 表示在搜索中节点被访问的次数。面对一个盘面， 会进行重复搜索，所以一个节点可能会被反复访问，这个下面细说。质量度表示这个节点下  的优势程度，其计算公式如下所示。

这个公式的意思是：对于非叶子节点，质量度等于该节点所有树中已有子节点的质量度均值。对于叶子节点，质量度跟价值网络估计的获胜概率θ有关，还跟快速走子模拟后续比赛得到的胜负结果有关。叶子节点的质量度等于这两者的加权混合，其中混合参数λ介于和之间。
有了  的结构，我们就可以继续介绍  怎么做搜索的。当对手落了一子， 迅速读入当前盘面，将之当作搜索的根节点，展开搜索。 搜索的流程如下图所示，一共分为四个步骤：


选择：从根节点  开始，递归选择某个子节点直到达到叶子节点 。当在一个节点，我们怎么选择子节点呢？我们选择子节点不应该乱选，而是应该选择那些优质的子节点。 中的选择子节点的方式如下所示。


其中|是策略网络的输出。一个有意思的点在于一个节点被访问次数越多，选择它作为子节点的可能性越小，这是为了搜索多样性考虑。

扩展：如果  节点上围棋对弈没有结束，那么可能创建一个节点 。

模拟：计算节点  的质量度。

反向传播：根据  的质量度，更新它爸爸爷爷祖先的质量度。


上述搜索步骤反复进行，直到达到某个终止条件。搜索结束后， 选择根节点的质量度最高的子节点作为  的着法。
 网络结构和训练方法
  的网络结构和之前的版本不同。  的网络结构采用了  网络，而之前的版本则采用了传统的  网络。同时   将  网络和  网络结合在一起，一个网络同时输出不同动作概率和预估胜率，如下所示。

网络结构定义好了，我们来看下   是怎么自我对弈  进行训练的。将上面的模型接入   就能有策略地进行搜索，搜索结果是当前盘面不同动作的概率。由于  经过了搜索，输出的动作概率肯定要好于模型自身输出的动作概率，因此可以将  视作模型的提升器。自我对弈是从初始围棋盘面开始； 输入当前盘面  输出不同动作概率 ，按照该概率采样一个动作作为玩家落子； 作为对手输入当前盘面  输出不同动作的概率 ，按照该概率采样一个动作作为对手的落子；不停执行，直到分出胜负 。收集数据 作为训练数据训练模型。整个训练流程如下所示。

在这里，我个人有点疑问。这种训练方法明显地和我们认知的基于马尔科夫决策过程     的强化学习有区别，但论文还是称之为强化学习。难度强化学习有更广义的定义嘛？
 实验效果
 不同网络结构的比较
  网络结构有两个改动 用  替代了传统   合并了  网络和  网络。下图可以看出这两个改动能提高   的效果 表示和分开， 表示合在一起  表示  网络， 表示传统的。

 不同版本  的比较
从下图可以看出，不用人类知识的   超过之前的版本。另外从下图能看出来的是，训练完成之后， 提升器  模型的能力还是要比模型要强。

 总结
大家以为围棋都做到头了，其他做围棋的团队在极力用旧方法提高棋力。没有想到  以 “不需要人类知识” 为最大亮点，搞出这么一个重磅研究工作。“不需要人类知识” 得以实现是因为模型  提升器的训练方法。在利用模型的基础上， 提升器总是强于模型本身，从而为模型提升指明了方向；模型的提升又进一步增强了  提升器的能力；这就形成了正向循环。一个总是比模型强的提升器，是正向循环能够建立的关键。
很多自媒体已经开始鼓吹，这是迈向通用智能的重要一步。这个是不对的。围棋因为规则明确和完全信息，我们找到了  这个总是比模型强的模型提升器。但在更多通用领域，这样的模型提升器还是比较难找到的。
本文首发于博客 和微信公众号 ，欢迎大家关注要说现在市面上最火爆的手游，莫非拥有两亿注册用户的王者荣耀了。据悉，王者荣耀的渗透率高达，这意味着每个中国人中就有一位是王者荣耀注册用户。众所周知，手游对推送实时性和精准性要求非常高，而王者荣耀这种日活跃千万级的应用对推送的要求就更高了，下面我们来看看王者荣耀背后的信鸽推送是怎么应对挑战，做到海量、实时和精准推送的。
年月日日，全球架构师峰会在深圳召开。全球架构师峰会是中国团队推出的面向高端技术管理者、架构师的技术大会，展示新技术在行业应用中的最新实践，其中超过上百位技术专家，千名技术人共同参与，包括海外的、、，国内的、、京东等，群英荟萃，精彩纷呈。
腾讯移动推送信鸽高级工程师甘恒通在本场架构师峰会上分享了《腾讯移动推送信鸽百亿级实时消息推送的实战经验》，解析了信鸽实时精准推送系统的演进与实践。
信鸽的挑战
应用的用户的生命周期来说分个阶段，即用户的获取、激活、留存、传播和收入，信鸽的消息推送是触达用户，提升留存的重要途径。

信鸽平台现已服务于数万的开发者，日推送消息数亿，推送支撑能力超过百亿；而精准推送是有效提高消息打开率的手段。信鸽的实践中案例数据表明，精准推送的平均是全量推送的倍！
那么，如何实现海量数据的压力下，满足实时、精准的推送要求，这里有很大的挑战。
这里我们主要讨论的是对于信鸽后台的挑战，主要有这三个关键字：海量、实时和精准。
海量是指，信鸽终端并发长连接是数千万，日推送量也有百亿的量级，服务于很多大客户，如王者荣耀，日活跃数千万，其推送量可想而知。
另外一些特殊行业的，也有特别的推送诉求。比如资讯类的应用，时效性要求非常高，需要每秒千万级的推送速度。
而另一些应用则需要在达到运营目标的前提下，希望尽量减少对用户的骚扰，即精准推送。
信鸽的应对之道
对于信鸽面临的挑战，我们做了哪些解决方案？首先信鸽是一个免费的运营工具，成本是我们这边一个很大的需要考量的点：一方面，需要提高设备资源的利用率，可以通过一些虚拟化的方式来解决；第二方面，我们要深入挖掘单机的性能。
对于单机性能的优化，有个方面，从下往上看是硬件、操作系统、协议栈、架构。

、    操作系统优化先看一下在操作系统这个层级是如何对海量并发长连接的接入进行优化的。这里主要挑战是在内存，通过命令可以看到当前系统内存分配的情况。从这一栏可以看到，当我们构建了大概万长连接的时候，整个系统的内存基本上已经满了。对于长连接的内存使用，会消耗在这个数据结构上。
我们深入分析这个来自模型和内核协议栈的数据结构。对于模型，底层实现是一个特殊的文件系统，文件的内容主要是保存了一棵红黑树和就绪的被侦听文件列表，红黑树的节点是被侦听文件对象。主要提供了三个：_、_、_。当我们通过_把一个文件加入到的时候，会创建两个数据结构、_，关联到被侦听的文件，_保存了事件就绪时设置的回调函数__。我们从另外一个链路看一下网卡的收包流程，当数据包过来的时候，网卡接收完数据会产生一个硬中断，数据通过拷贝到内存。系统通过软中断守护进程，调用网卡的驱动来完成数据包的解析并最终调用方法。方法会回调设置好的__，即把挂到中，当调用的_时候，即可获取到就绪的集合。
对于海量的并发连接，主要通过调整操作系统的配置来解决。信鸽使用了公司自研的 ，系统对于内存这一块也做了比较多的优化，具体的配置参数如下，可以看到，主要也是一些的限制和的内存的限制。

、    框架优化看完操作系统层级的优化，我们再来看一下另一个主要性能优化的点——框架。信鸽对于关键的接入层使用语言进行开发。好的框架主要有两个要点，是对底层通信的良好封装，使得开发只需要关注业务逻辑代码的开发，是高性能，框架对消息处理消耗尽可能少。通过® ™ 这个工具我们可以对框架进行性能评测，这里列了两个框架。左边这个框架可以看到把很多都浪费在消息的内存拷贝，同时对消息的处理进行了过多的封装。对于右边的框架就做得比较好，对于框架的问题就不存在了，主要是操作系统本身的消耗，还有协议栈的消耗。这部分对于有更高的要求来说，还可以进行深度优化。这是我们后台选用的框架，主要实现的要点有三个，第一是池化技术、第二是协程模型、第三是无锁框架。这里的主要用于接入网络的请求，具体的业务逻辑代码是放在进程里面处理。整个框架做了一个通用的抽象，将一次数据请求主要分为数据接收、数据路由、最后是具体的数据处理。数据接入进程和具体数据处理进程，通过无锁的共享内存来通信，这样就避免了很多不必要内存拷贝和消息编解码操作。
对于处理业务逻辑的工作进程，比较常见的有三种模型，第一种是进程同步模型，数据进来以后，由独立的线程进行处理，优点是代码实现比较直观，缺点是处理海量并发用户请求的时候，操作系统对多线程的切换会成为一个主要的瓶颈。第二种用得比较多的是异步事件驱动模型，由进行事件的侦听，通过一些状态机来驱动业务逻辑代码的执行，优点是性能较高，缺点是当业务逻辑分支多的时候，代码非常难维护。我们这边是采用协程模型，协程和线程和类似，它跟线程不同的是，线程的切换和调度需要自己来实现，协程模型可以采用同步的思维进行代码开发，又具有异步模型的高性能，协程切换优化的点是，通过汇编的方式，直接把相关寄存器中的值保存在内存，来进行上下文的切换。

、    协议栈优化下面我们看一下协议栈的优化。这里的协议栈主要是指内核协议栈。内核的协议栈主要问题是相关的方法都是系统调用，需要从用户态切换到内核态，数据从内核空间到用户空间也需要进行额外的内存拷贝操作。业界有一些开源的用户态协议栈，可以解决这两个问题。使用用户态的协议栈需要优化的点是相关的接口和系统自带的接口命名不一致，直接使用涉及到大量代码的修改，我们怎么样做到在不修改代码的情况下用协议栈呢？这里是通过机制，拦截相关系统调用，符号解析返回自定义的方法。、    硬件性能挖掘
下面我们再看一下单机性能优化的最后一个点——对于硬件性能的挖掘。硬件性能的挖掘，主要是善于利用 的指令集。可以拿我们经常使用的操作来举例。一般的实现是根据算法定义来执行字节转码操作，而提供了一套的指令集，它里面包含的方法。我们可以看一下次计算两者的耗时对比，直接用的指令集比一般的实现方法快倍。
小结：性能好，推送才能顶住海量信息的压力，支撑公司内外业务核心，提供强有力的通道支持。
实时方案的构建
对海量设备进行实时推送主要的解决方案是针对推送的场景优化存储结构，同时将单个推送的节点间调用转换成分布式的批量位图运算，优化终端长连接，接入集群分多地部署，做最近接入，和的交互使用协议，对无效的自动做数据清理。
我们这里举一个具体的场景来说一下倒排索引是如何应用到实时推送中的。比如一个应用对在广东的男性用户进行一次推送，会经过一个这样通用的推送流程：一个推送的任务到达一个调度的节点，决定是否下发推送任务，如果下发，则会经过目标人群的检索，筛选出男且是广东的用户，接下来进行通道检索，信鸽这边既有自建的通道，也有厂商的通道，用户在推送的时候，他可能觉得厂商的通道更加稳定、更加高效，这个时候他可以选择对于华为设备走华为通道、小米设备就走小米通道，对于其它的设备就走信鸽自建的通道。下一步就是地域检索，信鸽这边的设备是就近接入的，我们在全国部署有这几个集群，分别是深圳集群、上海集群、天津集群和海外的集群。这里选择了广东的用户，所以选择深圳集群。对于一个传统的系统来说，一次推送可以这样实现，一个应用下的个用户的推送，转换成次节点间调用，人群信息、通道信息、地域信息分别保存在或者数据库中，每个调用，需要到数据库里面检查一下他是否是男的，是否是广东的用户，再看一下是不是华为的设备或者小米的设备，判定完之后要进行地域的检索，看看接入的是哪个集群。整个流程下来之后，要经过大量的数据库操作，才能完成一次推送。
但是经过倒排索引的构建之后，所有的数据都可以放到内存中。比如男性人群，可以构建一个，小米的通道也是一个，华为的通道也是一个，不同的地域分别是不同的。当一次任务下发的时候，对进行一些操作，就可以把最终需要推送的人群下发到相应的接入机中，整个过程可以做到级别。对于推送下发整个流程，检索是一方面，另一方面还需要查询路由信息找到终端长连接的接入机，这些路由信息包含接入机的编号、进程的编号、长连接 的编号，用一个数据类型即可保存，所有的路由信息保存在分布式的内存数据库中，整个推送流程只有接入机的路由需要进行数据库的查询，结合本地的缓存，可以做到的推送下发速度。
精准推送的构建
信鸽的推送系统主要分为三部分，第一部分是数据、第二部分是具体的系统实现、第三部分是具体的应用。
具体的应用有这三个：实时推送、推送助手、。推送助手和的作用是更好地帮助用户使用消息推送来进行产品的运营。比如推送助手，对于很多运营人员来说，可能没有相关的运营经验，对内容的管理，他可能只大概知道需要推送的目标群体，但是他对推送文案不知道如果编写会更好，这个时候我们后台会对历史的推送进行数据的收集，对文案和推送的效果进行关联性的分析，当他选择一个推送场景的时候，我们就会把一些文案的样式和关键词给到他，让他自己组织出一个更好的推送的文案。另外一个是，用户自己手里有几个文案或者目标推送人群，当他不确定的哪个更合适的时候，我们给他提供的能力，从目标推送人群中抽取部分测试用户，多个文案经过实时推送，在几分钟的时间里，把推送的效果即点击率反馈给用户，系统自动或者由用户选择一个最佳的推送文案或者是一个最佳的目标人群对剩下的用户进行推送。

下面看一下系统的实现，主要分实时和离线。离线部分主要是用来进行人群的挖掘。对于精准推送来说，它的核心是根据应用运营的目标将消息推送给匹配的目标人群。应用的运营的目标一般有提升用户活跃度，潜在流失用户挽回，提升应用收入等，不同人群的挖掘方法可能不尽相同，但流程基本一致，一般会分为数据的准备、模型的构建、预测结果、输出。
我们这里举一个实际的潜在流失用户人群挖掘的例子。我们想预测一下这个应用里面可能有哪些人是会流失的，这样应用可以针对这部分人群做一些挽留的推送。原始数据保存在或者里面，经过数据加工以后，把用户可能流失的一些特征给提取出来，比如说有首次注册的时间、每日启动的次数、每日的活跃状态和最近登录的时间。特征提取后有两条路径，一是要构建一个潜在流失用户预测的模型，二是在模型的基础上进行潜在流失用户的预测。对于模型构建部分，需要结合真实的流失情况和特征，作为训练的样本，经过算法模型的训练之后，我们就得到了一个潜在流失用户预测的模型。对于每天新增的数据，我们也是经过特征提取之后，把数据输入这个模型里面，就会得到一个具体的预测结果即可能会流失的人群集合。对于算法模型，我们这边主要用了一些机器学习里面的统计学习的方法，没有用到一些现在比较火的深度学习的方法。因为我们在实际进行训练的时候发现当我们的数据样本非常大的时候，用一般的比如决策树模型，通过一些判定规则，就能够知道用户是否流失，或者是贝叶斯，通过特征类别的条件概率分布预测是否会流失，采用这些模型召回率可以达到和的水平，已经满足我们的应用场景，所以没有采用计算复杂度更高的深度学习的模型。

实时效果评估
信鸽最新更新的实时效果功能，为用户提供了推送效果的实时统计。面对百亿级推送的压力，实时统计也会占用很大的计算资源，那么信鸽是如何实现这一功能的呢？一般推送的效果评估主要看，但是可能对于一些用户来说，不能反映他的运营目标，他可能更关注的效果是我做了一次推送，用户有没有到达我的目标页面或者说推送了正在进行促销的通知，有没有更多人进行下单购买。这些场景可以通过在前台给用户管理推送效果跟踪配置的方式来实现。用户每次推送之前，可以指定推送效果如何评估，这里可能是一些目标页面集合的浏览或者自定义事件的，系统把它转化成一个配置文件。当他进行推送的时候，我们就会把配置文件下发到统计系统里去。当执行推送完之后，应用的用户就会产生点击、注册、浏览的行为。这些数据到进入到系统的时候，主要会做两部分的操作，第一部分是根据推送文件指定的方法进行数据的抽取、过滤、转换、加载并更新相关的倒排索引数据，当真正需要指标输出的时候，我们会有一个管理的节点，进行计算规则的下发，比如说点击的用户里面有多少是男的，检索以后进行一次的操作，就能统计出有多少用户了。数据会实时刷新到存储中，应用开发者在前台查询结果的时候，我们就会把这个结果反馈给用户。

能看到这里的都是真爱！今天的干货分享就先到这里
联系我们：
如果您希望试用或者体验信鸽推送，请访问信鸽官网接入试用。
如果您对该功能有疑问、或者在使用中遇到了困难，欢迎您联系信鸽官网在线客服，或者发送您的问题邮件至：
商务合作或业务咨询，请联系以下邮箱：作者 | 王拥军

王拥军，毕业于天津大学计算机系，拥有从计算机硬件到操作系统安全、从后台服务器到客户端的全平台工作经历。目前在腾讯自选股从事互联网证券软件研发管理。对上市公司及创业团队的产品、文化、经营等具有独到的见解。
个人公众号“水滴的声音”，专注企业文化、团队管理。

免责声明：本文不负责探究华为如何对待大龄员工，更不负责探究各种报道的真实性。本文只负责探究企业管理制度考核制度、激励制度、股权制度对员工短期以及长期的影响。
核心观点

大龄员工的问题，是长期以来高新技术企业粗放式人力管理造成的“积弊”，解决的方式在于更加精细化的人力资源管理。

年龄没有错，有没有激情跟年龄无关，跟“缺钱”有关；

大龄员工只是缺“加班时间”，并不缺工作激情；

员工没有错，每个人都有价值，就看企业如何用。


引言
华为到底对大龄员工做了什么，这里不去探究，毫无疑问的是，一大堆老板、媒体，比较倾向于认可下列“事实”：
、年纪大的人破事儿太多，缺乏激情；
、缺乏激情影响了个人业绩；
、年纪大的人收入高，对公司的成本高；
、业绩差，成本高，必然会影响公司发展；
、因此，采用具有奋斗精神的新员工取代老员工，对于企业来说，很正常。
年纪大的人缺乏激情
二十来岁的年轻人，尤其是从家乡漂泊到大城市奋斗的年轻人，孤家寡人，一人吃饱全家不愁，所以一心一意提升自己，不分白天黑夜奋斗在公司办公室。
 许多年轻人，尤其是工科毕业生，生活及其简单，社交圈子很窄，就算下班回家，也是跟陌生人合租的房子，不如在公司里跟彼此熟悉的同事们多呆一会儿。
三十多岁尤其是三十五岁，大部分都有了老婆孩子，漂泊在外，有老人来带孩子的还好，如果没有老人带孩子，势必要在家事上耗费大笔时间和精力。
所以，下班后，二十五岁不在公司加班的不多，三十五岁留在公司加班的才稀罕。
两者对比之下，老板当然喜欢年轻人了，拼劲十足，家务事也少，周末就算不加班都愿意在公司待着。
三十五岁，周末加个班还得向老婆请示，还得向吃奶的娃娃请示，更不用说走远门出个差了。
如果说：激情指的就是加班，就是占用员工生活时间作为工作时间，那么，三十五岁的人确实比二十五岁的人缺乏激情。
那么，占用员工生活时间进行工作，这是正常的现象么？
也许，以前是，现在也是，但是，将来，绝不会是！
因为，任何一个人都会长大，都会有老婆有孩子，即便是二十多岁的年轻人，也会有自己的生活，有自己的兴趣爱好。
、中国丰富的劳动力资源，丰富的漂泊到大城市工作的年轻人，不仅仅为建筑业提供了低廉的人口红利，也为高科技产业提供了随意压榨的人口红利。伴随着中国整体人口拐点，这些人口红利逐渐消失，体力劳动的薪资水平逐步提高，脑力劳动的时间成本也逐步提高，这是整个中国社会的趋势。
一个企业可以把三十五岁的人全都或者大部分换成二十五岁的，所有企业都可以么？今天可以，未来也可以么？
 、伴随着入学率、录取率、就业率的不断提升，素质教育逐渐普及，年轻人的个人爱好会越来越广泛，缺乏个人生活爱好的人会越来越少，下班后找不到好的娱乐项目而只得待在公司里加班的年轻人也会越来越少。
后确实很苦逼，入学率低，录取率低，就业率低，没有兴趣，没有爱好，大多待在公司里提升个人能力。
后呢？后呢？下班之后他们也愿意待在公司里加班么？
、伴随着城镇化的稳定，第二代城镇人口不再像第一代城镇人口那么“举目无亲”，他们有更多的家庭生活来填充个人生活时间。
后刚刚进城，最稳固的关系就是“同事关系”，所以他们愿意待在公司。
后的后代呢？他们的父母、同学都在同一个城市，他们有的是各种活动来填充个人生活。
总结以上三点，中国许多企业，沾了人口红利的便宜，沾了城镇化的便宜，但是，如果把这种“便宜”作为企业长久依赖的竞争力，那么，当这种便宜消失的时候，企业自然会受到严重冲击！
以工作时间作为激情的评价标准，只能说，目前中国大部分的企业制度，都处于极为低级的阶段。这种制度，对于后可以，对于后也还凑合，等到了后成为劳动主力军的时候，就彻底终结了。
影响激情的不是年龄，而是“钱”
上节表明：年纪大的人，只是缺时间，至于缺不缺激情，还不好说。
华为的股权分红制度天下闻名，十年前苦逼的工程师，今天，个个分红百万。
对于员工，分红百万，当然是好事情。但是对于企业，就不一定了。
缺钱的人为了赚钱，为了生活，甚至为了生存，脏活累活都愿意干，充满激情。二十五岁饿肚子不舒服，三十五岁饿肚子也不舒服，甚至，三十五岁为了还房贷，为了奶粉钱，不是不能更拼！
不缺钱的人，相对就难于管理了。比如说北京上海拆迁户，各个怀揣上千万，月工资也就是个烟钱，工作就是为了有个寄托。
所以了，当初在华为苦逼干活的二十五岁，也就是十年后今天的三十五岁，各个手里一大笔分红，就算不卖力，也有百万收入，干嘛要那么卖力呢？
华为还好，是分红权。其他上市公司，直接可以卖股票，原始股一卖，瞬间千万甚至亿万富豪，这帮人，指望他们像创业阶段苦逼加班，难！
所以，大龄员工的问题，跟年龄没有直接关系，真正有直接关系的，是“收入”，是“钱”！
股权变现的问题表明：企业管理的问题，尤其是员工激励的问题，是个非常复杂的问题，任何一个决策，有利必有弊。
当初不给股权，留不住人；给了股权，多年之后，发财了，如何保证激情？
十多年前，中国企业大都刚刚开始发展，手里没多少钱，为了调动大家的激情，尽情的使用股权激励；十多年后，当初的股权激励反倒为今天带来了弊端。
所以，如何制定更加全面完善的既保证企业目前利益又保证企业长远利益的员工薪酬激励体系尤其是股权激励，才是当前成功的大企业尤其是上市大企业需要认真思考的。
股权是为了留住激情，而不是为了留住人
为了招揽优秀的人才，可是公司又给不起钱，所以用大笔股权来引诱优秀人才，是不得已而为之，也是行之有效的手段。
既然这种创业阶段的“股权”属于“公司拖欠的薪酬”，那么，当公司有能力支付当初拖欠的薪酬时比如上市之后，员工要求一次性兑现，当然是非常正常的诉求。
然而，为了更加长期的留住员工，通常公司的股权会分成很长的时间分批支付。
这个出发点是好的，然而，弊端也是鲜明的：员工想一次性变现，可是公司却不答应，于是乎，员工只好在公司耗着，每过一年拿回一笔股票。
结果，员工的人是留下来了，心却没有留下，激情更加没有留下。
公平点讲，既然当初的股权是公司“欠下的债”，等公司有能力偿还的时候，自然要一次性偿还，这种分期支付，算怎么回事儿？
当然了，问题如果仅仅这么简单就好了。股权的复杂之初在于：一部分是公司当初欠下员工的薪酬，还有一部分属于公司对员工未来长期留在公司的奖励。讲道理，后一部分既然属于未来的奖励，当然要在未来才能给。
问题麻烦就麻烦在：一个公司在分发股权的时候，往往希望得到前后两种效果，即作为欠下员工的早期薪酬，以降低公司早期薪酬开支，又作为员工长期服务的奖励，以留住员工更长的时间在公司内。
更麻烦的是：因为两种因素混合在一起，一旦员工消极怠工，什么都不做，坐等着时间流逝，领取股票，公司却不能够因为员工激情和业绩问题而中止员工的股权。
因为，如果是后者“股权是对未来的奖励”，既然员工业绩差，自然要取消股权；如果是前者“股权是对之前薪酬的拖欠”，即便员工今天的业绩再差，有什么理由取消之前的薪酬欠款？
如果公司以员工当前业绩没有达到公司要求而对之前拖欠的薪酬强制中止偿还，将如何说服新的员工加入？
所以，应对老员工股权过多的问题，公司应该更加规范自己的股权激励制度，真正做到：不仅要留住人，而且要留住激情！
年纪大的人工资高，成本高
对于许多行业，尤其是新兴行业，“工龄越高，工资越高”貌似已经成为共识。
然而，许多共识的合理性，是值得质疑的。因为，还有许多行业，比如建筑业，岁和岁甚至岁，拿的工资都是一样的。
差别在何处？
建筑工，搬砖有搬砖的价格，砌墙有砌墙的价格，工种不同，工资不同，但相同工种内部不同工龄的差别，并不大。因为岁的人和岁的人，搬砖也好，砌墙也好，业绩差别不大。
软件工程师，为什么工资要伴随着工龄而逐年递增呢？因为工作效果差别巨大。刚刚毕业的人，工作两三年的人，工作五六年的人，无论是代码的速度还是质量，都还是差别巨大的。
然而，伴随着编译器的进步，伴随着软件工程学的发展，尽管工作两三年的人与工作五六年的人依然有明显差别，但差别已经没有那么巨大了，尤其是工作五六年的人与工作十来年的人相比，作为单纯软件工程师的差别就更加微小了。
从三十岁到三十五岁，如果工作依然只是写代码，差别其实是不大的。然而，工资却差别巨大。
为什么会发生这种现象？
 、新科技公司伴随着规模扩大，市场扩大，盈利能力提升，为工资的每年上浮提供了保障以及理由；
尤其是以软件为例，市场越大，用户越广，软件的价值越高，而开发成本却变化不大。
由于员工产出的商业价值更多的与市场规模成正比，导致很难对一个软件工程师的具体价格作出评估。
因而，公司业绩提升，员工待遇随之提升，似乎是理所当然的。
、国家的上涨，的上涨，为工资的上涨提供了理由；
房价那么贵，不给那么多钱，谁会愿意来北京上班啊！
大家全都涨了，你一分不涨，我们干嘛要来？
、团队业绩的快速上涨，掩盖了某些员工贡献停滞的问题。
当公司业绩上涨时，尤其是当小部门业绩提升时，从财务统计的角度，很难区分具体是哪些员工的贡献提升了，哪些员工的贡献丝毫未变甚至下降了。
直到公司业绩下滑，哪怕仅仅是业绩增长率下滑，管理层才突然发现：公司的运营成本竟然如此之高！
这个问题说明什么？说明许多公司把关注点放在营业收入或者营业利润增长的同时，对于运营成本的增长重视不足，只看到了大概的变化，没有细分哪些成本的上浮是必须的，而哪些成本的上浮是毫无理由的。
手里积累了一大堆高收入低产出的员工，自然会对这些员工产生抱怨，而导致这种结果的，恰恰是公司长期以来的“粗放式管理”。
如果三十五岁的员工工作产出与三十岁的员工完全等同，薪酬也完全相同，那么，公司会做出何种选择？
这个问题，在某些发达国家已经不是问题，因为他们二十五岁的工程师实在是不够用，只能用三十五岁甚至四十五岁的工程师来补充。
中国企业，迟早也会面临同样的问题，企业要做的，是顺应潮流，用更加精细化的人力管理来解决企业人力成本和不同年龄员工激励的问题。
今天，尚且可以用二十五岁的年轻人来取代三十五岁的中年人，再过十年，二十五岁的年轻人不够用，甚至比三十五岁的中年人更加难于管理，那个时候，企业又将如何发展呢？
大龄员工的问题，不仅仅是一家企业的问题，而是整个中国社会所有企业的问题，谁能解决的好，谁就赢得了未来。

注：本文为作者原创，同时发布至本人个人公众号【水滴的声音】关注企业文化、团队管理。作者：

本文内容大部分来自   ，原文比较长，感觉也有点啰嗦，所以根据个人理解猜测梳理出本文，如果有错误欢迎指出，谢谢！
很多人其实不是很重视错误处理，但对于构建一个健壮的应用，错误处理是非常重要的一件事情，希望本文可以给你一些启发。
先抛出几个问题：

应该用哪种方式暴露错误？、 、 或者其他方式？

如何假设函数的参数？是否应该检测类型正确？非，，号码？

函数参数不符合预期该怎么处理？

应该如何区分不同类型的错误？例如 、  。

应该如何提供有用的错误信息？

应该如何捕获错误？使用，还是或者其他方式？


一些基础知识
关于、、的一些基础知识链接
_
  、
模块   
抛出错误的几种方式：
  =  
  {
           直接
          使用，中常见的异步处理方式
          事件
}
捕获错误
{
      = 
}{
     捕获错误
}
分类错误
一般来说，我们将错误简单的分为两种类型：操作错误、编码错误。
对于有经验的人来说，写代码的时候都会处理一些常见的操作错误，例如总是会和一起，例如网络故障、远程服务器返回等。这些错误并非。
对于程序来说，另外一种错误属于编码错误，这是程序的，解决的方式应该是修改代码，避免发生。例如   、调用一个异步函数但没有传入、函数参数预期是但是传了一个等等。
人们在谈论错误时，总是将这两种错误混在一起，实际上这两种错误是完全不同的。例如  是一种操作错误，但这不能说明哪里出错了，这可能仅仅表示程序应该先创建文件。
有些时候，同一个问题可能会导致多种错误。例如应用因为一个变量导致，这是编码错误，客户端则会接收到错误，这属于操作错误，对于客户端来说应该可以预期到服务器的这个错误。
如何处理 操作错误

对于明确的操作错误类型，直接处理掉。
例如尝试打开一个文件可能会导致  ，那么创建这个文件即可。

对于预料之外你不知道如何处理的错误，比较好的方式是记录并，传递合适的错误信息给客户端。


如何处理 代码错误
最好的方式是立即。
这种错误是程序的，一般来说写再多的代码也避免不了。因为在应用中，我们一般会监控挂掉的进程并自动重启，所以立即是比较好的方式。
调试这类问题的最佳方式，是在捕获到 的时候，记录相关信息。
总之记住，的代码错误传递到时会成为一个操作错误，例如捕获到 则返回一个，客户端来处理这个操作错误。
如何传递错误？
首先，最重要的是文档，描述这个函数做了些什么，接收什么类型的参数返回什么，可能会触发什么错误。
一些基本原则：

同步的函数里，使用。使用者使用即可捕获错误。
异步函数里，更常用的方式是使用 的方式。
在更复杂的场景里，可以返回一个对象，代替使用。使用者可以监听对象的 事件。 例如读取一个数据流，我们可能会同时使用 、、 。

所以，使用还是、，取决于：

该错误是操作错误还是编码错误？
该函数是同步还是异步？

此外，不管是同步使用或者异步使用或，只使用一种方式传递错误，避免同时使用两种方式。这样的话，使用者就只需要使用一种方式来捕获错误，例如或者，不需要考虑更多的场景。
下面用一个特例来说明这一点：
 异步函数，是操作错误，使用传递
不存在的文件{} 
 异步函数，参数错误，会立即抛出异常
{}

在上例的第二种情况，会立即返回       ，也就是说内部使用了，这种情况是不是和上面提到的有矛盾？
其实并不是，第二种情况属于编码错误只接收路径作为参数但我们给了他一个，并不是操作错误。编码错误永远不应该被处理。
所以在使用的时，使用者仍然只需要处理传递的错误，不需要使用。
错误的输入属于哪种情况？编码错误还是操作错误？
这一点取决于函数申明的可以允许的类型，以及你如何来解释它们：

如果得到的参数和申明的类型不一定是指数据类型，也可能是地址、号等类型不一致，那么属于编码错误使用者应该使用符合要求的参数
如果得到的参数和申明的类型一致，但函数不能处理这种情况，那属于操作错误。

你必须决定限制类型的严格程度。
例如需要连接到一个服务器，函数接收一个地址作为参数，那么有几种做法：

函数只接收地址格式的参数，如果不符合格式，则立即抛出异常。
函数接收任意字符串参数，如果参数不是地址格式，则使用发出一个异步错误，提示无法连接该地址。

这两种做法决定了同样的输入会导致编码错误或操作错误。对于大多数功能，我们强烈建议更严格，因为更宽松的限制会更容易导致使用错误以及浪费时间。
什么时候使用和 
操作错误一般都可以使用明确的机制来处理根据具体的错误对应处理，使用、、等。
和全局的异常捕获主要是为了发现和处理未预料到的编码错误。
编写的具体建议

清楚的功能

必须明确几点：期待的参数、参数类型、额外约束地址、号码等。
如果任意一点不匹配，则立即抛出异常。
此外，还应该有：
使用方可以预料到的操作错误、如何捕获这些错误、返回值。

所有的都使用对象或者基于类的扩展所有的都应该提供和属性，并且也应该准确可用。

使用属性来区分错误类型


例如、。
不要为每种错误取个名字，例如定义、这种来表示具体的错误，对于这种错误可以统一用表示错误类型，然后在详细描述里补充更多信息。

增加解释错误细节的属性

例如无法连接到服务器，可以增加一个 属性表示试图连接的。

如果传递一个较低级别的错误，考虑重新包装错误。

如果函数调用顺序如下：    ，返回一个加载配置失败的错误，连接服务器失败。
那么，在中，更希望得到包含这个错误的信息。所以在中捕获到的错误时，包装并传递这些错误是有价值的。
包装底层的错误信息时，尽可能保留原始的信息，除了名称，但不要改写原始的对象。
一个组合多个错误的示例：
 
        
            
                  
                       
                     
这里有一个库可以帮我们做这件事：

总结

区分错误类型，是可预见的还是不可避免的，是操作错误还是。

操作错误应该被处理。编码错误不应该被处理全局处理并记录。

一个函数可能产生的操作错误，只应该使用同步或者异步一种方式。一般来说，在中，同步函数导致的操作错误是比较少见的，使用会很少，常见的是用户输入验证如、解析等。

一个函数的参数、类型、预期错误、如何捕获都应该是明确的。

缺少参数、参数无效都属于编码错误，应该直接抛出异常。

使用标准的类和标准属性。使用独立的属性，添加尽可能多的附加信息，尽可能使用通用的属性名称。


例如一些常见的属性名称：
、、、、、、、、、、、、、、
最后

不要尝试用去捕获一个异步函数的错误，这样会什么也得不到。
如果不是产生错误，不要使用。
之前就已经有操作错误、编码错误的概念，参考这里 _____


原文链接：


相关推荐在中利用进行事务管理一次  内存溢出作者：，腾讯高级工程师 

导语
互联网产品中的检索功能随处可见。当你的项目规模是百度大搜|商搜或者微信公众号搜索这种体量的时候，自己开发一个搜索引擎，加入各种定制的需求和优化，是非常自然的事情。但如果只是普通的中小型项目甚至创业团队|创业项目，直接拿轮子则是更合理的选择。
就是这样一个搜索引擎的轮子。更重要的是，除去常规的全文检索功能之外，它还具有基础的统计分析功能最常见的就是聚合，这也让它变得更加强大和实用。
还在用数据库的来实现产品的全文检索吗？抛弃她，用吧！
下简称是基于的一个开源搜索引擎产品。是编写的一套开源文档检索的基础库，包括词、文档、域、倒排索引、段、相关性得分等基本功能，而则是使用了这些库，搭建的一个可以直接拿来使用的搜索引擎产品。直观地理解，提供汽车零部件，而直接卖车。

说起的诞生，也是个很有意思的故事。的作者 ——“几年前他还是一个待业工程师，跟随自己的新婚妻子来到伦敦。妻子想在伦敦学习做一名厨师，而自己则想为妻子开发一个方便搜索菜谱的应用，所以才接触到。直接使用构建搜索有很多问题，包含大量重复性的工作，所以便在的基础上不断地进行抽象，让程序嵌入搜索变得更容易，经过一段时间的打磨便诞生了他的第一个开源作品，中文即指南针的意思。之后，找到了一份面对高性能分布式开发环境的新工作，在工作中他渐渐发现越来越需要一个易用的、高性能、实时、分布式搜索服务，于是他决定重写，将它从一个库打造成了一个独立的，并将其改名为。“

可见鼓捣起来的程序员是多么有爱，虽然据说 承诺给妻子的菜谱搜索还没问世
本文大概地介绍了的原理，以及在使用中的一些经验总结。因为本身涉及的功能和知识点非常广泛，所以这里重点挑出了实际项目中可能会用到，也可能会踩坑的一些关键点进行了阐述。
重要概念
集群： 是一个分布式的搜索引擎，一般由多台物理机组成。这些物理机，通过配置一个相同的 ，互相发现，把自己组织成一个集群。
节点：同一个集群中的一个 主机。
主分片 ：索引下文介绍的一个物理子集。同一个索引在物理上可以切多个分片，分布到不同的节点上。分片的实现是 中的索引。
注意：中一个索引的分片个数是建立索引时就要指定的，建立后不可再改变。所以开始建一个索引时，就要预计数据规模，将分片的个数分配在一个合理的范围。
副本分片 ：每个主分片可以有一个或者多个副本，个数是用户自己配置的。会尽量将同一索引的不同分片分布到不同的节点上，提高容错性。对一个索引，只要不是所有所在的机器都挂了，就还能用。主、副本、节点的概念如下图：

索引：逻辑概念，一个可检索的文档对象的集合。类似与中的概念。同一个集群中可建立多个索引。比如，生产环境常见的一种方法，对每个月产生的数据建索引，以保证单个索引的量级可控。索引类型文档，中的文档以这样的逻辑关系组织了起来。
类型：索引的下一级概念，大概相当于数据库中的。同一个索引里可以包含多个 。 个人感觉在实际使用中这一级常常用的不多，直接就在一个索引中建一个，在这个下去建立文档集合和进行搜索了。
文档：即搜索引擎中的文档概念，也是中一个可以被检索的基本单位，相当于数据库中的，一条记录。
字段：相当于数据库中的。中，每个文档，其实是以形式存储的。而一个文档可以被视为多个字段的集合。比如一篇文章，可能包括了主题、摘要、正文、作者、时间等信息，每个信息都是一个字段，最后被整合成一个串，落地到磁盘。
映射：
相当于数据库中的，用来约束字段的类型，不过  的  可以不显示地指定、自动根据文档数据创建。
很友好地提供了的，可以通过请求直接完成所有操作。比如下面官方的一个例子，往索引添加文档，是，文档的是：

相应地，根据字段检索文档：

关键配置项
、索引的个数
的个数，最好是和节点数相关的。理论上对同一个索引，单机上的个数最好不要超过两个，这样每个查询尽可能并行。但因为中的个数是确定了就没办法再调整的，所以如果考虑到数据会高速增长，一开始分配多些也可以。另一个常见思路是按时间纬度如月去定义索引——因为可以动态调整新加的索引的个数。其他的一些情况，比如下面举到的聚合的例子，因为需要数据尽量地按照渠道切分开，所以定义了很多个个，但太多的通常是不推荐的，管理起来也有开销。
、内存
官方建议是可用内存的一半，是通过启动的环境中，定义环境变量的方式完成的。如 __=
、
集群的逻辑名称。只有 相同的机器，才会在逻辑上组成一个集群。比如，内网中有台机器的实例，是可以构成几个互不干扰的集群的。
、__
这个是用于集群的分布式决策的最少机器个数。和常见的分布式协调算法一样，为了避免脑裂现象，建议超过一半的机器，
、
集群的机器列表。注意单点不用配置集群中的所有机器列表，像一个连通图一样，只要每台机器配置了其他机器，而这些配置又是互相可以连接的，那最终就会发现所有机器，构成集群。如

类似于数据库里的表结构，定义个就意味着创建了一个索引。与数据库不同的是，一个索引并不需要显示地建立，比如，上面那个在索引插入文档数据的例子，如果执行的时候还没有定义索引，便会根据文档的字段和内容，自动创建索引和。然而，这样创建的索引字段，往往可能不是我们所需要的。所以，还是自己预先通过手动定义来创建索引比较好。
下面是创建的例子，这个例子在_这个目录下，为、这些创建了。其中下面是各种字段的定义，包括了、数值、日期等类型的定义。
如图中的红框部分，这个例子中有两个需要注意的地方：
、_是类型的，但它的被定义为了“_，这个需要搞清其中的意义：通常，搜索引擎中全文检索的功能简单说是这样实现的：对原始文档进行分词后用这些词去建立倒排索引，在线上检索时，再将用户的查询词进行分词，用分词结果去拉取多个倒排索引的拉链结果、归并、相关性排序等，得到最终结果。
但是，对于有些类型的字段，其实并不想建倒排，就只想精确匹配，比如用户的名字，只想查到字段精确为“张三”的人，而不是分词后得到的“张四”和“李三”两个人，这个时候，就需要定义类型字段。这个字段有、、_三种类型，是压根儿不给这字段建索引，是分析和按全文检索的方式建，_是完全匹配的关键词查询方式。
、类型，创建时需要通过“”指定录入的多种可能时间格式。这样创建文档的时候，会根据输入文档的字段自动去确定是哪一种。不过直观地想象下，在创建文档时，指定明确的时间格式，省去动态判断的开销，应该会提升些微小的性能。此外，要注意，_秒单位时间戳和_毫秒单位尽量不要混用，如果非要混用也要在插入的时候明确指明是哪个。曾经踩过坑，插入_的是秒级时间戳，但优先认为是毫秒，导致时间被缩小倍，最近的时间变成了年当年的某个时间。

下图列出了当前版本中可以进行的数据类型、内置的字段、操作可以携带的参数。因为篇幅原因这里就不详细解释了：


这里要详细介绍的，是上图中红框标出的，我们创建时实际用到的比较关键的两个内置类型，和两个参数。这几个都会直接影响最后索引访问的性能：
_： 会把所有字段拼成一个原始的落入磁盘，所以这个可以理解为全量原始数据，他不能用来索引，却可以在需要的时候返回。注意尽量不要禁用，比如禁用后，用去就不支持了。
_：一个“伪”字段，用来实现模糊的全文索引。可以这样理解：在建索引的时候，把所有字段拼成一个字符串，然后对这个“大”字段进行切词，建倒排，然后这个字段就被丢弃了，没有真正落入磁盘。当全文检索时，如果没有指明查询的域，比如标题、正文这种是很常见的，就从这个大的倒排中拉取文档拉链。可以想象，一些标记或值类型的字段，如日期、得分，这种在全文检索时是没意义的，就可以不包含在_内，而文本域，如、，就包含在_之中。这些都是在建时可以、而且最好指定的。
_： _和下面的_都是在聚合后面会介绍、排序这些统计时用的参数，默认都是开启的。排序、聚合，这种在文档全局进行的工作，用倒排索引肯定不合适。所以，对_即不建倒排的字段，_用一种列模式的方式可以参考来存储文档的正排，方便在文档全局做统计。_是存储在磁盘的，如果你明确有些字段只是展示，不用于统计的话，可以把这个禁用掉。_一定不会对域建索引都切词了，想想也不合适，怎么建列索引嘛，而是用下面的 。
_：对的文本域，比如正文，其实也会有统计的需求比如也支持按一些关键词对文档进行聚合统计，但这种任务常用的方法是通过离线工具，如或者单机的分析，做好了后推送到在线索引，直接在去算其实感觉有些奇怪。虽然并不适合在搜索引擎中做，但你真的做了，也会把这个数据动态地内存的一个 中进行运算。所以，想想就知道，这是个非常耗内存的操作，很可能把 吃完了！！默认是只打开，但不，只是在你需要进行域的排序和聚合的时候，才去动态这个内存的方式。所以，尽量不要在查询的时候去打开这个潘多拉魔盒，或者干脆就把这个选项关掉吧。
聚合
谁说搜索引擎只能用来搜索？不仅能搜索，还能在搜索的结果集合上直接进行统计，很强大吧。目前稳定的非实验阶段聚合主要分两种： 指标聚合和 桶聚合。
指标聚合主要指常规的集合数学统计类运算，如官方的这个例子：找到交易的所有红色的车，然后求它们的平均价格：

结果大概是这样的：

神奇吧指标运算还包括其他，如最大、最小、求和、个数、地理坐标运算等。然而我们今天要进行实例讲解的则主要是 ，桶聚合。桶聚合是指把文档，按照某个给定字段分成不同的组，然后在组内进行进一步聚合运算，并返回桶级的结果。比较直观的理解，如：直方图、分时间段统计等等。如下面这个例子，是桶聚合中的聚合，即按照这个字段，精确匹配后进行分桶，然后桶内还进一步嵌套了平均价格聚合、和按制造商进一步的分桶聚合。

统计的结果类似下面这样，红色的车共有辆，平均价格是，并且又包含了辆本田和辆宝马：

上面是简单的例子。在我们的舆情中，有论坛热帖这样一个功能，即，实时统计某个数据源中如百度贴吧，某个论坛里如王者荣耀吧，一段时间内如个月，回复数最多的个帖子。

这个功能现在在线上的实现方法就不详细介绍了，大致是从数据库和中扫描对应的数据，维持一个堆，获取出 的思路。一方面是稍微有些耗时，另一方面是请求量很大时可能对和的访问带来压力，所以也想找一种备选的方案，我们想到了用。
为了用的桶聚合，我们首先设计如何存储文档即所有用户评论的方案。由于数据量非常大十亿级，所以我们首先想到了把文档按时间分成不同的索引如按月，然后在指定月份如个月的索引上，聚合出评论最多的帖子。然而这样是有问题的：当在多个索引上聚合时，不会把所有索引的结果放在一起聚合，而是单独在每个索引求得后，再放在一起聚合。这是个使用时要注意的小坑。这样导致的结果是，直接在多个索引上聚合出的，并不是真正的比如个月中，每个月都是不是 ，但三个月加起来就是了 。局部最优不等于全局最优。
所以，从时间上切分，这条路基本被堵死了。那只能从空间上切分了您问能不能不切分？十亿级的数据量，上百个，不切分的话，乖乖，每次都要从这几百的文件里找东西，想想也知道有多慢了。从空间切分，同样需要考虑两个问题：
如何将数据到。
切分多少个。对于第一个问题，因为我们的聚合统计是在每个渠道可以理解为论坛下的，不会跨渠道，所以，按照渠道进行分配，把相同论坛的数据到一个即可。这样，每次请求某个渠道的聚合结果，把请求按渠道 到对应的去运算。对于第二个问题，要看具体的规模了。我们的数据量有上百，数据源上千个，所以我们希望每个上的内容尽量少，保证在单个上聚合的时候会更快，当然个数又不能太多，否则会给引入非常大的管理开销。综合下来，我们选择的个数是个。
遗憾的是，只能根据你指定的论坛去做后进行路由，这就导致了不同的上数据不是完全平均的，最多的能超过，最少的只有几十。如果哪一天，如果开放自定义规则或者对数据进行均衡的方法，那就好了。
经常为人诟病的一个地方是建索引比较慢，亿数据的索引构建时间要花几天。这也容易理解，天下没有免费的午餐，读写的性能往往是互斥的，快速读取和检索意味着大量索引和辅助数据的预先建立，那写入时势必会慢。如何取舍，需要看实际的业务场景而定了。下面就是建好索引后，去聚合某论坛内指定时间段内帖子的接口调用方式。

然后，我们按连续统计最热的为不同的个数个渠道内的热帖结果的方式分别对和线上已有的服务进行了测试：






上面的五个结果图直观地反应了用现在舆情线上的常规统计方式和聚合统计的方式获取结果的耗时。
从结果中，我们大概推断出了统计聚合运算的做法：先把所有符合过滤条件的数据全部检索出来，然后在内存中进行排序和聚合运算。也就是说，符合条件的数据量级越大，聚合运算越慢。本着这个原则，结果图也就比较好理解了：
在连续对最热的个渠道去进行热帖聚合时，的表现大部分都优于现有实现。这是因为的渠道中，大部分渠道被分在了非常小的上，有的只有几，数据量很小，在这样的中聚合，是很快的。
时间纬度上，统计个月的数据，大部分情况下都比现有方法慢，而个月或天的情况下，都要快。这是因为个月的条件下，符合条件的数据量级增大最大的一个话题下有万跟帖，的运算效率下降比较厉害。
从到，的总时间逐渐变差于现有方法。这是因为，空间纬度上，渠道符合条件的数据量级非常大，所以的运算效率下降比较厉害。
做了这个实验后，在头部数据源上的聚合速度并不比现在快，但在中部和长尾上的效果更优，这说明的聚合受候选集数据量的影响非常大，所以是否切换这种方式也还没最终决定。不过，这个实验证明了聚合的强大能力，至少，不用自己写什么代码，只通过接口调用就能把这样海量数据的统计运算完成了，还是很方便的一件事情，同时性能也不错。如果自行实现的统计运算中会增大的压力，那么通过聚合分离这部分请求，也是一个非常好的选择。
原文链接：用搭建自己的搜索和分析引擎

产品舆情，一站式了解你的产品口碑和用户喜好。
点击  立即体验！
亲爱的读者，为了能够提供更好的网站内容，希望您填写我们的问卷，我们会随机抽取读者回馈币以示感谢！问卷入口：臭名昭著的方程式组织工具包再次被公开， 在 博客上提供了相关消息。
本次被公开的工具包大小为，包含 个黑客工具，其中部分文件显示  曾入侵中东  银行系统，工具包下载接见文后参考信息。
解密后的工具包：
 
其中  目录包括  利用工具和相关攻击代码， 目录中是银行攻击的一些证据， 目录是植入后门等相关文档。
 目录：
目录下包含了各种漏洞利用工具，在中包含了丰富的漏洞利用工具，可影响多个平台。

其中有三个目录较为重要：
、：
包含了很多漏洞利用工具，这里摘取一些进行简要介绍：

经过初步梳理，重点关注对 有影响的几个工具，更多工具展示见参考。

             漏洞利用工具只对  有影响

           和  漏洞利用工具，影响端口 和 

           通过 漏洞攻击，攻击的默认端口为

      通过  漏洞攻击，默认端口

         通过  漏洞攻击，端口为

           通过  漏洞进行攻击，默认攻击端口

            漏洞利用工具

        漏洞利用工具

          和  漏洞利用工具，使用 端口和 端口

               漏洞利用工具，默认端口

           漏洞利用工具，默认端口

           漏洞利用工具，默认攻击端口为


、：
是一个类似 的漏洞利用平台工具，编写。
 
、：
 ：利用  漏洞，攻击开放 端口的  机器。
影响范围如图：
 
 ：利用漏洞，攻击开放端口的机器。
影响范围如图：

可以看出，其中多个工具，对于 系统均有覆盖。
目录：

支持向如下系统中植入后门代码，可以对抗  和  的检测。

工具包中提供了一个常见反病毒引擎的检测结论。

文件夹：
存放一些金融信息系统被攻击的一些信息。部分被入侵的机器信息如下：

下面文件表明，方程式组织可能对埃及、迪拜、比利时的银行有入侵的行为。

其中一个入侵日志：
 
对我们的警示：
本次公开的工具包中，包含多个  漏洞的利用工具，只要  服务器开了、、、、 等端口之一，就有可能被黑客攻击，其中影响尤为严重的是 和 端口。在未来的一段时间内，互联网上利用这些公开的工具进行攻击的情况会比较多，除了提醒用户，发布预警外，需要加强入侵监控和攻击防范。
临时缓解措施：
、升级系统补丁，确保补丁更新到最新版本。
、使用防火墙、或者安全组配置安全策略，屏蔽对包括 、 在内的系统端口访问。
参考附录：
         方程式又一波大规模  攻击泄漏，微软这次要血崩

相关推荐天御安全防护泄露资料分析黑客工具技术—篇裴泽良，年加入架构平台部，一直从事运营系统相关的建设工作，历经了腾讯海量存储及服务的运营体系从入门到初级再到较为完善的各个阶段，目前专注于提升腾讯云上业务的运营质量，以及建设新一代高效与安全的自动化运维体系。

关于级存储运营体系相关的核心内容，已在《海量存储第一弹  自动化运维》中做了详尽的介绍，本文主要讲海量设备、海量业务服务场景下的质量监控。
深入海量业务特性的监控
一、我们业务对监控的诉求

图存储系统层级结构
架平主要服务了公司内部的胖子业务，主要提供了其中的海量存储、海量相关的服务，这些服务最终都体现在业务多、机器数量多、区域及运营商分布广泛国内海外都有、使用了多家外部厂商等这些特点上面。
各种类型的海量存储服务、文件型、热数据、冷数据等应用场景后面都对应了复杂的软件架构，最终都体现在软件模块多、调用层级深、且大多以后台模块的形式运行等特点上面。
我们对业务监控的需求，从业务视角来看，表现为能够实时掌握到每个业务在各个区域、运营商、各个软件模块等的运行状态数据，且当有任何一个点出现异常时，都能够及时有效的告警出来，从系统设计视角来说，表现为要能够把复杂的业务调用场景进行抽象化，要有足够的性能以便能够实时处理海量的监控数据，且要让人工在这整个过程中并不需要做太多参与，提升系统可持续运行能力。
二、开源监控产品能否应对

图形形色色的开源监控产品
目前市面上已有不少开源的监控产品，譬如、、等，这些开源的监控系统功能不少，能否满足我们的需求呢？
开源的监控产品本身提供的功能更聚焦于系统自身的特性监控，譬如主机是否存活、网卡流量等，而像业务特性，譬如业务请求失败数、延时等特性数据就需要单独开发插件，且当生产机位于全球各地、跨越不同运营商的时候，开源的监控在代理、上报接入点自动选优等功能上也不足以应对需求。这些还只是功能需求性的短板，当系统每分钟需要处理上十亿级别的数据量时，这些开源监控产品的性能、可扩展性等不满足的话会对业务的运营质量带来严重的影响。
三、我们业务监控的体系建设

图监控需解决问题的形象描述
关于单台机器自身相关的各种特性的监控，譬如、网卡、硬盘故障、单机不可用等，这部分与业务监控相关性不大，统一采用公司的系统做监控，这里面就不再描述。
如上图，可以把我们的监控系统描述为对大量原始数据的实时处理，把数据从单台机器的低层次维度实时合并汇聚为符合业务、用户需要的高层次维度的数据，并在此数据基础上做展示、告警、业务质量分析、实时故障分析等。
 譬如微信朋友圈图片上传与下载业务，假设总共有个节点组成，按用户访问量分布在电信、联通、移动、机房，以及分布在上海、深圳、天津、香港等地，则每台机器单独上报各自的上传、下载的请求数、失败数、延时等多个指标的数据，人需要查看的常常是朋友圈图片上传总请求数是多少、失败率是多少，监控系统要做的就是实时对这些原始数据做汇聚合并成用户需要的样式。

图业务监控模型的建立
如何建立业务的监控模型呢？这里的业务指的是一个业务的某方面功能，譬如微信朋友圈图片上传下载、微信聊天图片上传下载、微信双人语音通话等。
 如上图，我们可以先把业务分解为由多个不同的软件组成，每个软件需监控的内容分解为“多维度多指标”，指标是指延时、请求数、失败数等这类，也即一个业务需监控的内容就可以由“多软件多维度多指标”来描述，譬如微信朋友圈图片上传下载这个业务，要监控的内容为“下载模块，图片类型为的下载每分钟请求数是多少，失败数是多少，总延时是多少”等，业务上报数据的格式也就是这种结构化的描述方式，也即“_=|维度=|维度=|维度=|指标=”。
采用了上述模型之后，后续业务模块增加新的功能，可以直接上报新的维度、指标，不需要人工重新配置监控系统，监控系统会自动识别上报的内容并应用到系统上面，大大降低人工的参与度。当然如果系统监测到业务模块同一时间上报了过多的维度、指标，则会自动禁用新的上报，并通知人工处理，以免业务模块有导致误上报。
采用了上述模型之后，告警配置就可以采用更加人性化的规则化来描述，譬如用户可以配置“微信朋友圈图片上传所有运营商所有地区失败率持续达到就电话通知到负责人”，这样随着业务的发展以后再增加新的运营商或新的地区，业务模块是自动上报，告警都也是自动应用上去，不需要人的持续性维护，降低漏告的可能性。
用户需要关注的、需要加告警的数据常常都是高维度的数据，而不是单台机器上报的某个细粒度的数据，低维度的单机数据如何做到每分钟高效率的汇聚为高维度的复合数据呢？这里面涉及到我们的实时计算模型。  

图维度指标与特性的对应关系
如上图，我们会把业务上报的“维度指标”最细粒度的所有组合一一对应到系统内部维护的一个称之为特性的唯一数据上面，譬如“业务下载软件深圳移动小图流量”ó，我们把称之为简单特性。多台机器可以同时上报同一个简单特性，我们把位于具体某台机器上面上报的该简单特性称之为单机特性，譬如“”就是一个单机特性。多个简单特性按某种关系的复合计算称之为复合特性，譬如业务就分布在深圳与天津，深圳与天津的流量每一个都可认为是简单特性，这两个简单特性的求和就是复合特性总流量，当然了计算方式还可能为求平均、求最大值、求商等，视不同场景决定。

图特性的实时计算模型
在把“维度指标”转化为特性之后，低维度的数据到高维度的数据的结构其实就相当于一颗树，业务上报的低维度数据就是树的叶子结点，用户需要的高维度数据就是这颗树中间或顶层结点，问题就转化为这颗树的叶子结点的值已知、向上汇聚的计算规划已知，需要每分钟高效率的计算出中间及顶层结点的值，这可以通过如上图的实时计算方法来解决，即每分钟从树的底层开始向上计算出每个结点的值并保存。

图即时计算模型
实时计算只能把单机数据实时高效的汇聚为简单数据或提前定义好结构的复合数据，实际上不可能提前把“维度指标”的所有组合都加到上面的这颗树里面做实时计算，因为这种组合数会太多，且大多数的组合在大部分时间都不会有用户查看，但用户的行为却是不固定的，很有可能某一时刻用户就想查看到某种没有提前定义好的组合数据，这种情况下可以使用如上图的即时计算方法来解决，即时查询出所有简单特性，根据计算规则把简单特性的值立即计算出用户需要的数据。

图业务全路径布控
在业务监控方面，我们对业务的全路径进行布控，监控点部署在用户访问路径的各个层，以保证任何一个层的异常都能及时有效的发现，通过高效的监控系统，以及全路径的布控，我们目前的异常主动发现率已可达到。
四、移动化
在当今移动化时代，监控必然也要提供移动端的支持，目前我们通过腾讯内部的企业号来实现移动端的能力。告警的发送分析处理、业务质量视图曲线的查看等功能都已经下放到移动端，甚至春节等特别节假日我们也会提供专项的移动端支持。

文章来源公众号：腾讯架构师引言
谈到冗余资源清理，我们不妨先来看看的资源组织方式和访问方式。
一、资源组织方式及访问方式
新建一个工程后，默认资源路径下生成对应的、、等子目录，分别对应以下几类常见的非代码资源：

，，等，代表资源的顶层使用者，通过的方式组合控件，渐变动画等资源，给等组件提供视图，通过这些脚本取代代码实现的布局动效，解耦视图和界面逻辑，提升开发效率；
，，等，这一类代表中的文本资源，都是格式资源，主要存放，，，，，，，等基础资源，支持比较丰富的语言扩展；主要存放返回资源的资源；没有明确归属目录的资源，都可以放到目录下；
，，等，这一类代表中的多媒体资源，有比较丰富分辨率扩展，其中目录主要存放返回格式的，带标签主要存放一些与分辨率无关的资源，其他带等目录对应相应的分辨率机型，没有明确归属的非资源都可以放到目录下。
在资源目录中分类组织资源后，我们就可以通过引用资源  来引用资源，所有资源的 都在项目中工具自动生成的类中定义，该文件不能被手动修改，当资源发生变动时，它会相应更新。
访问资源的方法主要有两种：

在代码中：__ 引用自定义资源  或者  __引用系统标准资源，比如， 是资源类型， 是资源名称，可以通过这种语法来访问定义的资源，如：  

在  中：使用对应的 语法，，例如， 是资源类型， 是资源名称，可以在  资源通过该语法来访问定义的资源，如：= 。


二、冗余资源的清理
随着长时间的版本迭代，工程中会冗余许多资源文件，手动查找删除效率太低难免有漏网之鱼，代码扫描工具可以方便的查找出未被引用的图片、等资源，本文主要应用  的规则进行冗余资源查找清理。
 是针对的静态代码分析工具，能够对项目中潜在的、可优化的代码、安全性、性能、可用性、可访问性、国际化等进行检查。
在  及更高的版本中，工具会自动安装。通过对工程源代码等进行扫描检查，可发现潜在的问题，更好的提升代码质量。
通过进行冗余资源清理主要有以下几种方式：
、我们可以通过 – 查找冗余资源列表然后手工或者通过其他删除工具加以清理。
、如果工程使用的是打包，可以在中打开开关，这样打包的时候不会把冗余资源打包进来：   移除无用的文件 
、也可以在 中使用项查找出所有未被引用的资源列表：

 在结果上右键选择’   ’，可以直接删除所有无用的资源：

可能存在的误删除与白名单配置扫描工具无法判断出通过反射方式来获取的资源，可能会产生误删除，如：

此时资源被清理后界面上会找不到图片，如果工程中有该用法可以通过以下几种方式对资源添加白名单配置：
、局部配置：在文件中通过=属性配置忽略：
在文件开头声明命名空间，并为对应的加上= ，属性对其节点的所有子节点都生效：
 ==我知道了
、 全局配置：在工程的根目录下创建一个名叫的文件，如非资源可以通过这种方式添加白名单，会读取根目录下的配置，命令行下可以通过—指定具体配置，需要注意的是，如果工程根目录下存在时，命令指定的参数无效：

配置文件中支持几个维度的自定义配置：
规则级别调整，置为则该规则不生效，如：

路径忽略，如：

正则表达式忽略，如：

三、冗余资源清理原理解析
扫描工具是如何扫描出冗余资源的呢，我们先来认识下扫描规则，从源码中规则的定义可以看到，继承自和 ，查找范围包括，资源文件，源文件及测试代码：

、根据获取资源列表：
类中接口定义的需要与配合使用，返回我们感兴趣的列表，然后在返回的中去处理这些。
定义一个的子类，并在中返回它的一个实例，那么当扫描到符合定义语句对应的就会触发中对应的回调函数：


、查找代码中的引用：
类中接口定义的需要与函数配合使用，返回，那么代码中的资源引用会触发处理函数：

、同样的，查找文件中的引用：

、从收集到的资源声明列表中删除被引用的资源列表并去除中声明不做处理如=或配置了白名单的资源，剩余的资源列表可认为是冗余资源：

、最终未被引用的资源列表：

四、手管的冗余资源清理应用
清楚了冗余资源的清理规则，我们可以放小心心地开始删删删了，谨慎起见，提供本地工具由开发童鞋本地清理确认，同时在持续集成平台自动监控冗余资源清理情况，形成一键清理自动监控的灵活处理模式：
、一键清理：在扫描结果的基础上提供命令行清理还原工具，支持本地一键清理：

清理： 调用 扫描规则生成冗余资源的文件，解析该结果文件区分文件格式和属性格式的资源资源格式见本文第一节，批量删除两种不同格式的资源，并在执行路径下生成备份路径按原路径结构备份删除的内容，支持多次循环调用直至冗余资源结果为。



还原：将备份路径下的文件或属性资源还原到原路径，并自动添加到白名单。


、自动监控：在持续集成平台上集成清理工具，输出冗余资源清理前后两个安装包及清理资源集，及时监控项目中的冗余资源情况，也可以直观看到清理带来的优化效果，推动项目组在发布前清理冗余资源。
也附上在手管版本代码的清理结果：删除文件资源个，其他各类型属性个，包大小缩小，预计在页面改版可以达到更好的应用效果。

冗余资源清理是借助静态代码分析工具的一个小应用，大家在项目过程中是否有其他静态分析工具应用的场景呢？欢迎大家一起探讨。
参考资源：
   ；
   资源管理篇；
   ；
   ；
   微桌面资源清理工具。

相关推荐测试管理平台大比拼从到：打造移动端性能测试平台视频通话是微信的基础功能之一，在实际应用中受光照条件及视频采集设备能力所限，视频发暗是影响主观体验的重要因素。我们尝试改进这个问题，欢迎留言交流该项工作的主要成果发表在 国际会议上。            ：    

应用背景
目前绝大多数智能手机具有了视频拍摄功能，但由于受镜头尺寸和成本的限制，采集的视频图像的单像素上的光通量较小。尤其室内场景光照不足或者低照度的情况下，部分手机由于曝光不足导致视频明显偏暗，限制了其实时的移动视频通话的应用。低照度视频增强技术，是一种通过修改视频图像的像素值来有效的改善此类场景下的视频效果，提升客户的主观感受的视频图像处理技术。通过该技术来弥补低照度下手机拍摄的视频图像，可以扩大视频通话的应用场景，提升用户的产品体验。
相关技术
现有的低照度视频图像增强技术主要借鉴低照度图像增强的一些方法，具体举几个例子：例如，直方图均衡 ：增强曲线为图像的概率累积分布函数，该方法能最大程度地拉伸整个图像的对比度。由于暗场景的图像其直方图存在高峰，经过直方图均衡处理后，导致图像过度增强，从而使得图像失真，同时容易放大噪声。例如，对比度拉伸 ：通过设计合适的映射曲线，控制全局各个灰阶增强幅度。但映射曲线不具备自适应性，对不同图像要设计专门的增强曲线，才可以达到增强图像的效果。校正是对比度拉伸的一种。例如，同态滤波 ：是一种频域增强算法。像素值由光照分量和反射分量决定。其中光照分量位于低频段，反射分量位于高频段。将图像映射到频域后，将光照分量和反射分量在频域分开，再分别进行增强处理。该方法适合光照不均匀情况下的增强，如同时包含室内和室外场景。因此不适应于视频通话中的增强。其他的增强算法，如色调映射 和等方法，存在计算量过大或者容易在边缘处产生光晕等缺点，都不能直接用于实时视频增强的场合。
设计动机
在实时的移动视频通话的应用条件下，我们简要说明现有技术的缺点及要解决的问题：
现有的视频增强方案主要是借鉴单幅图像的增强方法，因此只考虑单帧信息，没有考虑相邻帧之间的相关性。导致各帧间增强幅度不一致，从而出现闪烁或者颗粒现象，降低了主观效果。且对于亮度正常的图像，其增强算法往往过渡处理。
在实时视频聊天的场景中，对计算量及存储空间非常敏感。实用算法都必须在较小的计算量和存储需求，达到最佳的增强效果。而类似色调映射和的计算量过大，即便经过优化也无法适应手机端的实时视频处理。
通过分析已有技术的技术特点和应用条件的限制因素，我们希望设计的算法具有以下几个特点：其一，增强低照度的视频图像。其二，连续的视频图像不产生闪烁。其三，对亮度正常的图像不做夸张的再增强。其四，算法的计算复杂度能够满足实时移动视频通话的限制。这样的设计思路，为后续的算法设计和实验验证提供了方向和标准。
时空域联合约束的低照度视频增强技术
本文提出了一种实时移动通信中基于时空域联合约束的低照度视频增强技术。在该技术中我们设计了图像空域的亮度增强约束和对比度增强约束，以及视频帧时域的亮度一致性约束，并对提出的联合约束框架给出了凸优化的闭合解。下面详细对每一个约束的设计进行详尽介绍，最后给出问题的优化解。该方法在空间进行，将亮度分量和色度分量分开，只对分量进行处理，保持颜色信息。图像灰度的取值范围为。
首先，低照度视频图像增强的最重要的处理就是亮度增强。一种最为直接的方式就是使用一族增强函数来定义亮度值增强，如图所示：
图 亮度值的增强函数族横轴为低照度亮度值，纵轴为增强后的亮度值。
在我们的设计中，通过采集同一场景下低照度和正常照度的视频数据对，通过离线训练的方式，得到了基于训练样本的亮度增强函数族。
然而，由于单纯的提升整体像素的亮度值，会使得图像整体的对比度不均衡，仍然不能提供好的人眼主观视觉感受。我们提出了自适应的视频图像亮度值域调整的算法，进而通过新的值域范围来对图像进行直方图的均衡化调整。我们统计图像的像素点的值域范围时，排除掉最小的个像素和最大的个像素的干扰，将中间范围内的像素最大值和最小值进行调整，调整策略为自适应软阈值的方法。从而生成数据自适应的对比度增强函数。
只从单一的图像维度来考虑增强的问题，往往会产生相邻图像帧之间的亮度跳变，即闪烁现象。为此我们将当前帧和相邻多帧的平均亮度的差异代价，构造出代价函数，来约束由亮度增强和对比度增强函数可能带来的闪烁现象。
综上我们设计的优化问题为：

易知三个约束项均为二次项，问题可以通过最小二乘法求解，如下：

本文算法的创新性和贡献：
通过离线的方法训练亮度增强函数，用以合理的提升亮度。根据当前低照度视频图像自适应的生成对比度增强函数，用以重新调整图像对比度。根据已处理帧的信息，自适应的调整临近帧间的亮度一致性，抑制闪烁现象。
有效的将上述的影响因素，统一成正则化的最优化框架下，来同时约束满足上文前三点项设计要求增强低照度的视频图像，连续的视频图像不产生闪烁以及对亮度正常的图像不做夸张的再增强，并给出满足实时应用需求的求解方式。
该算法具有较低的计算复杂度和极强的鲁棒性，实验证明其大量测试和线上的视频图像的增强效果中没有过度增强和失真增强的差质量样例。
实验结果
我们通过实验数据来验证我们的方法的性能。首先我们给出不同场景下不同暗图像增强算法的主观性能比较。

图 图片上的主观实验结果，表示原始暗视频图像，分别表示文献的方法，表示我们提出的方法处理的视频图像。

图 图片上的主观实验结果，表示原始暗视频图像，分别表示文献的方法，表示我们提出的方法处理的视频图像。
图和图分别给出了低照度条件下景物和人物的增强效果。从图中可以看出我们的方法具有相对较好的主观效果。

图 视频上连续两帧的主观实验结果，表示原始暗视频图像，分别表示文献的方法，表示我们提出的方法处理的视频图像。
图给出了连续的视频帧中抑制闪烁效果的主观结果。如图可以看出一些方法存在着视频图像亮度闪烁的现象，我们的方法在增强亮度的同时不存在闪烁的现象。

图 视频图像的主观实验结果，表示原始暗视频图像，分别表示文献的方法，表示我们提出的方法处理的视频图像。
图给出了常规亮度的视频帧，我们的方法能够尽可能的不影响已经足够明亮的视频图像，避免了过度的增强。
进而我们通过一系列的客观的数据来从另一个侧面评估我们的算法。表中，我们通过将算法统一到平台上进行公平的比较，分析各个算法的时间复杂度，可以看出我们的方法具有最好的实时性能，且在实际应用中该算法仅仅需要非常少的计算代价，且具有良好的汇编优化效果，并不需要大规模的等其他复杂计算资源。

表中，我们通过利用无参考的质量评价方法，分析各个算法的客观质量，可以看出我们的方法具有最好的视觉性能。值得注意的是，在常规亮度的视频图像中，我们方法处理的得分最接近于原视频图像的打分，即我们没有夸张的过度增强。

参考文献
        “       ”            
          “        ”           
                “        ”          
            “       ”           
              “          ”           
结语
本文针对低照度视频序列，为了增强视频图像的主观视觉质量，设计了正则化的最优化框架其中包含：亮度增强代价函数，对比度增强代价函数和亮度一致性代价函数，并给出满足实时应用需求的求解方式。该算法具有较低的计算复杂度和极强的鲁棒性，实验证明其大量测试和线上的视频图像的增强效果中没有过度增强和失真增强的差质量样例。相关技术全部为组内自研，已获中国专利授权一项且中稿国际视频编码领域的重要会议文章一篇。

本文来源于： 微信公众号接《  技术快报》：图形篇 上
【摘要】
模拟各向异性的布料或者长的毛发，在动画中始终是个热点难题，、连续年没有相关的论文或者大的进展。之前的方法多是基于粒子的拉格朗日方法，但是计算量巨大。本文试图用最新的  来解算，基本思想是将模拟的元素视为流体或连续体，避免了显示的解算碰撞和摩擦，从而揭示出一种统一的物理模拟框架。



　
　













【问题】

如何快速模拟真实的各向异性布料始终是个热点，因为存在元素间的碰撞和摩擦计算量很大；

长发的模拟同样是个难题。


【解决方法】
本文是综合之前的三篇论文做出的改进，分别是迪斯尼在做冰雪奇缘时为雪的模拟开发的算法、算法，以及为模拟沙子开发的算法，第一篇解决将拉格朗日方法和欧几里得方法做了整合，提出了一个变形梯度投射的思想，将动力学解算放在网格空间处理，从而可以处理颗粒之间的压缩、弹性和断裂等效果；算法则解决了中从网格向粒子传递时的耗散问题相当于低通滤波；沙子模拟算法则是利用  来简化建模连续体内的摩擦力，将应力张量分解为粘稠流体内的耗散和摩擦两种因素，并且考虑了网格内部元素的填充率。本文的贡献是提出了在垂直于表面或线的切线方向上的形变梯度，从而间接阻止元素之间的穿插，也解决了之前方法存在的精度问题。以下是三篇相关文献。
、           
、      
、   
【结果分析】
优势：可用于模拟毛衣、长的头发等的动画效果，部分解决了元素之间的自碰撞和摩擦和撕裂等问题。对于万个面的布料模拟，每帧耗时２分钟运行在上，常规网格。
不足：１实现在上，未来可能会迁移到上实现更快的模拟速度；２目前使用的不是自适应网格，随着模拟的物体尺寸增大，网格数会三次方增加；３不能完全保证元素之间不会穿插，这是算法本身决定的，不过作者测试，在时间步长比较小的时候，能基本避免；４网格的尺寸需要设定为与材质元素的尺寸一致，否则模拟中会出现瑕疵。
【应用落地】
毛衣、长头发等的动画效果，以及和其他元素之间的交互这些元素也可以用算法模拟
渲染
渲染是从几何体和材质信息生成最终呈现在屏幕上的画面的过程，分为和两种类型，后者包括游戏中常见的和管线，因为场景复杂、光效复杂和对计算时间的要求，主要的研究方向可分为：
●               光线追踪中采样算法的研究，比如蒙特卡洛的优化、等；
●               针对各种复杂光效的优化，比如景深、运动模糊、高光反射、效果等；
●               实时渲染算法的研究，比如实时的多边形光源的照明、实时的算法等；
●               渲染中去除噪点、减少采样的方法；
●               物体材质的参数模型和参数获取等。
     
原文链接：
演示视频：=
【摘要】
模拟爆炸、烟雾或者位置动画很多盏点光源的光照和阴影效果是个难题，因为渲染时间往往随光源的数量成倍增加。本文的基本思想是，将烟雾或多盏点光源的位置作为输入，得到各级粗分网格中的点光源的亮度和位置，用这些点光源的融合来计算光照信息，减少了计算量。

【问题】

游戏中爆炸后烟雾的动画中往往很难模拟烟雾对环境的光照效果，因为光源的增加会造成计算量激增；

在多盏点光源情况下，动态阴影和半透明效果也是问题；

方法将众多点光源转换为层级树的方法，存在问题。


【解决方法】
本文将烟雾或多盏点光源的位置作为输入，然后逐步变成网格中格点的点光源，使用了传统的线性融合的方法来做不同层级的格点光源的光照融合，在每帧点光源变化时，更新所有层级格点的光照，使用来模拟阴影，对于层级较高的格点就是粗略模拟的光照使用体积光源模拟，对于烟雾中存在的间接光照效果，本文使用了增加虚拟光源的方法来模拟。


【结果分析】
优势：１在渲染下图中的爆炸效果时，使用了百万的点光源，计算网格耗时秒，光照计算耗时秒；在渲染下图中的多个点光源和半透明的字体时，使用了万盏点光源，计算网格耗时秒，光照计算耗时秒。测试平台为          内存。效果很好，速度也比较快。２没有方法中存在的帧与帧之间的闪烁问题；并且速度快了几个量级，在爆炸烟雾渲染中，方法需要２个小时来渲染。使用的都是传统的算法和方法，比较可靠。
不足：１仍然无法避免算法本身存在的漏光问题；２如何在上或者实时渲染中利用该技术，本文没有提及，但是方法上并没有限制，估计阴影贴图的贴图量的生成会比较耗时和消耗带宽，不过在实时渲染中可能也不需要用这么多盏点光源来模拟，值得尝试。
【应用落地】
用于游戏动画中篝火、爆炸等动态体积光源的模拟，或者飞舞着很多萤火虫的洞里的光照效果。
           
原文链接：__
演示视频：_
【摘要】
渲染中如何在不增加采样的情况下降低噪点一直是研究的热点，本文采用机器学习的方法，使用网络来编码信息，然后用网络来降低连续帧之间的噪点，在间接光上取得了不错的效果


【问题】

最简单的降噪方法是增加采样数，缺点是造成渲染时间成倍增加；

传统机器学习比如线性回归方法来降噪，但是因为噪音来源比较多，比如有材质高频信号、复杂几何体比如头发、间接光照全局光，，以及景深和运动模糊等，所以很难有一个统一的方法或者统一大小的宽度来对数据进行处理。


【解决方法】
在框架基础上尝试使用深度学习的方法实时的对图像去噪点，对于仅考虑单次间接反射折射的渲染画面，保持了等高频信号，同时在连续的渲染画面中取得了较好的降噪效果。技术上使用＋ 来做，然后再，中间使用结构抑制连续画面中的闪烁。
【结果分析】
优势：达到左右的实时渲染速度，仅使用１的间接光照采样，在保持边和阴影等高频信号的同时，去除了噪点且没有引入叠影等，做到了较为不错的全局光照和阴影效果。
不足：１为考虑复杂几何体，景深和运动模糊的情况，２输入画面本身是每像素一个采样点的噪音较大的渲染画面，没有演示对于噪点较小的渲染画面的处理结果，３训练中使用的是的画面，网络较小，时是采用上采样来做到的，所以最后输出画面尺寸也是，后续也许扩展到了更大的网络；４不能处理光线的多次反射折射，场景中有镜子，杯子等时，会有问题。是开发的一套运行在上的光线追踪渲染框架，所以本文使用的环境，并不是游戏中所用的或管线。
【应用落地】
在将来也许可以用于提升游戏的画质，但是对于电影等要求较高的渲染可能还不行。
       　   
原文链接：
演示视频：暂时没有
【摘要】
 在一直在做材质方面的工作，国内该领域做的最好的组，去年他做的工作仍然是使用传统的基于多张照片或视频的受约束的二次规划优化方法，这是他们组第一次尝试使用深度学习的方法来做。
【问题】

为了获取真实物体的材质信息，往往需要使用的巨大的球形照相机群，不能广泛采用；

用数据拟合的方法，需要从多个角度拍摄多张照片，或者拍摄一段物体旋转下视频信息，光照需要保持恒定，比较费时。


【解决方法】
本文试图从单张照片估计出物体的信息，作者使用了两个深度神经学习网络，分别用来估计统一的高光模型参数模型，也可以改做其他的，比如游戏中常用的，左图和随空间位置变化的漫反射模型参数和表面法线右图。

为了增加样本数量，作者使用了一种称为的训练方法。对于输入的无标记照片，首先使用监督方法训练好的模型估计出参数，然后使用该参数，在软件中变换光照和视角，渲染出一张新的图片，然后再次利用深度网络估计出新的参数，以两个之间的偏差作为。

【结果分析】
优势：仅需要一张照片就可以获得物体的信息，算是目前最为简化的获取方式了。
不足：１对于每一种材质，需要一个对应的神经网络，不同材质间无法通用，神经网络的泛化性比较低；２对于照片有不少限制，比如物体需要是平面的，且光源需要离物体较远，认为类似于平行光源；３如果高光变化较大，那么估计出的参数会不准确；４在实际生产中，一般很少考虑随空间位置变化的情况，所以模型上应该可以进一步简化。
【应用落地】
他们组的一些论文，不限于这篇，可以用于使用手机等设备快速获取物体的信息，从而在游戏中创建出更加真实的基于物理的渲染效果。
虚拟现实增强现实
虚拟现实或增强现实领域是目前的产业和研究热点，包括以下细分领域：
●               周围环境的三维重建以及用户在环境中姿态的实时定位
●               减少眼镜造成的眩晕感
●               三维物体或角色本身的识别、扫描、重建和传输
●               针对全景图的渲染优化和传输优化
●               从环境照片中获取环境中的光照分布等
         
原文链接：
演示视频：=　
【摘要】
作者使用常见的深度摄像头，采用层级结构进行构建，做到了环境模型的实时重建和修正，以及摄像机姿态的准确恢复和实时的闭环修正，基本思想是在连续的帧内做跟踪，并筛选出稳定的特征，然后在以帧为单位的整个序列帧上做闭环修正，降低了闭环修正发生的频率，并去除不稳定的特征信息。

【问题】

之前的方法多采用 来修正轨迹，确保摄像机能够回到原点，修正摄像机位置估计中的漂移误差，但是这种方法往往需要消耗较多的计算时间，无法用于实时的任务；

因为摄像机动的太快，或者被遮挡，会造成跟丢的情况，摄像机恢复后的位置不易确定。


【解决方法】
作者使用常见的深度摄像头，采用层级结构进行构建：连续的帧组成一个块，在这个块上，作者使用特征点来做摄像机姿态跟踪，并辅助以特征点的分布、缩略图中的点位置信息，完成该帧时间范围内的姿态修正，并将新的深度信息及时更新到三维重建的模型中，将连续稳定的特征点整合在一起；在之间不是每帧都执行，再对一些关键帧进行全局优化，同时考虑稳定特征点、的位置信息和法线信息在不同摄像机姿态下的对比，使用方法做大规模稀疏矩阵行，列的方程求解，并根据全局优化前后的摄像机姿态差异，来决定是否将该帧数据从三维重建模型中去除，最后进行修正更新三维模型。
【结果分析】
优势：使用单个普通的摄像机做到了实时、稳定、闭环的大场景三维重建和摄像机姿态位置定位，并且模型的准确率和之前的方法差别不大，而且不像之前的闭环处理方法，需要中断或者在做 时有延迟。
不足：使用了 ，一个   来做场景重建，一个  来特征点的匹配和全局优化等，计算资源要求比较高；在重建过程中，稳定特征点的差异会在全局优化过程中传播到多个帧，所以场景模型会存在细微的不断变化，同时作者在文中提到使用权重来更新三维场景模型，但是并没有详细叙述权重的算法，考虑到本文属于中的方法，而不是的方法，所以没法获得每个的位置信息的准确率或概率，所以更新的权重可能是人为设定的，这也导致新的数据不太可能和之前数据完全一致，因为深度摄像机本身也存在噪点会不断更新之前的场景模型，尽管比较细微；作者在闭环处理上，仍然沿用了传统的优化方法，虽然算法上进行了改进，但是存在优化中矩阵规模随时间增加二次方增长的问题，虽然作者在中没有提及，但是在文中提到在做了分钟的后，优化矩阵有行，所以怀疑该方法在连续运行时间上存在限制。最新的基于的方法，使用树结构和概率做闭环处理，避免了这个问题，可以考虑和该方法的结合。因为使用结构光，所以不大可能在户外使用；已经有用于影视制作的摄像头位置姿态跟踪解决方案，比如，使用的方法，非常准确稳定，但是缺少本文对环境的三维重建。
【应用落地】
可以用于领域，可以快速完成室内场景环境的扫描建模，且同时不受空间限制的获取当前位置和姿态信息 限制在的范围内
          
原文链接：
演示视频：
【摘要】
本文的基本思想是，运动物体的三维模型信息和材质信息可以互相辅助，轮流优化，从而在使用单一深度摄像头的情况下完成动态物体的三维重建和材质扫描。

【问题】

有些方法依赖于一些预备工作或假设，比如人体的骨骼或身体的扫描；

有些方法依赖于多个摄像头的融合处理，无法做到实时；

多数方法没有做到同时恢复被跟踪物体的三维模型和颜色信息。


【解决方法】
作者使用来表示非刚体，利用论文 中的节点来控制物体的形变，先根据物体表面的颜色和光照信息用来表示低频变化的光源来估计的运动，然后再根据前后几帧的运动信息来更新物体表面的颜色信息，在优化求解中使用了改进的方法，并且对于发生碰撞的比如在衣服或袋子口合上的时候不做更新，从而获得不错的跟踪效果，并能得到物体静态时的形状和颜色，能到帧左右。
【结果分析】
优势：不需要任何事先的准备工作，使用一个普通的深度摄像头，就可以做到非刚体的动态的捕捉和建模，并且包含了物体的颜色信息，比如穿裙子的人物，或者书包等任意形状的物体。速度在  和  上做到了，精度在厘米级别动态。
不足：该方法假设物体表面是一致的漫反射，对于有高光反射的物体会存在问题；物体的重建精度受限于深度摄像头的精度；因为深度摄像头的帧率限制，所以对于快速运动的物体，因为帧与帧之间变化大，以及存在动态模糊，会造成瑕疵；对于拓扑结构发生变化的物体，会存在建模上的问题；因为本文使用了来表示物体，所以在网络传输时带宽要求比较高。
【应用落地】
可以用于领域的交互，比如类似微软传送门的效果，让远在千里之外的亲人和家人互动。
     
原文链接：_
演示视频：=
【摘要】
体验中会出现眩晕感，部分是由视觉辐辏调节冲突造成的。作者结合自动曲光计和可调节焦距的镜片，来测量人眼对不同远近的物体的刺激反应，得出目前解决冲突的三种方案哪种更为舒适。
【问题】

目前提出的解决方案有，景深渲染，可调焦镜片，。但是缺乏数据去验证哪种方案更舒适。的原理介绍

【解决方法】
下图分别为硬件原理图，使用自动曲光计测量人眼的对焦点，用可调节焦距的眼镜去匹配人眼对不同远近物体的刺激响应。
 














【结果分析】
优势：作者经过实际测量发现可调节镜片能比另外两种方法得到更为准确、也更舒适的呈现效果，为将来发展更好的显示设备提供了方向。值得进一步关注。
不足：目前假设眼球是不动的，如何配合眼球追踪技术，可以得到更好的效果。
【应用落地】
更为舒适，眩晕感更少的显示设备。
        
原文链接：_演示视频：暂时没有
【摘要】
本文使用了类似的思路，对三维信息进行压缩，并且使用平均的法线来表示中三维特征，在三维物体识别、、形状提取等方面有应用价值。

【问题】

现在获得物体的三维立体扫描数据越来越方便，比如摄像头、结构光扫描设备，三维模型数据越来越多，但是如何从数据中提取物体特征信息尚无定论；

三维信息的内存占用和计算量随三维物体尺寸的三次方增加。


【解决方法】
使用了类似的思路，对三维信息进行压缩，仅存储非空的信息。使用 来编码的序号，使用数组来存储当前层中哪些是被物体表面占据的，然后采样物体表面的点的法线平均值作为当前的特征，最后进行的计算。
【结果分析】
优势：１在计算时间和内存占用上，相对不压缩的方法有近倍的提升，且在物体识别和上和之前的方法准确度基本一致。２对于将来如何利用处理巨大的高精度的三维信息提供了更好的基础，比如去噪点、相似性比较或场景分析。
不足：１如果针对物体的不同部分的几何特征，采用不同的尺寸，可能会进一步提高效率；２本文仅考察了网络，对于深度学习中的其他重要网络，比如，的结合应用还没有研究，可能会有新的突破。
【应用落地】
大场景或高精度模型的去噪点、识别或者。


技术快报：快速扫描学术／技术前沿进展，做出必要的分析归纳，寻找它们在产品中落地的可能性。希望能帮助大家了解前沿，拓宽视野，提高决策效率。如今数据库的操作越来越成为整个应用的性能瓶颈了。对于数据库性能，并不仅仅是  关注的事情，也是开发和测试人员需要关注的事情。在设计数据库表结构时，在操作数据库时特别是查询  语句，都需要我们考虑数据库的性能问题。本文主要由一个案例引发对  性能问题的思考，主要讲述  慢查询和  工具这两个定位  性能瓶颈的方法。索引和查询优化部分后续将放在《 索引及查询优化总结》中。
一个低效查询引发的思考
上次在做银行对账，上传对账单后，出现对账超时的情况。查看日志发现，最后一条日志记录停在了对 ___ 的查询  上。使用   命令来查看当前  的执行情况，如下：
由上图可知，原来是发生锁表了     。
引发锁表的  语句就是上图中  为  的语句为：
 ___  =   =_招商银行   =
该条  语句还未执行完，给表 ___ 加的写锁还没释放，又执行  读操作， 语句会等待表级锁，导致阻塞而使银行对账超时。
为什么这条  语句执行了如此久还没执行完呢？这个语句不够高效，当在数据量很大的情况下，执行效率更慢。
定位  性能瓶颈的方法很多，主要为这两种：慢查询与  命令。
一 慢查询
慢查询，顾名思义，就是查询超过指定时间 __ 的  语句查询称为慢查询。 慢查询帮我们找到执行慢的 ，方便我们对这些  进行优化。  
慢查询开启方法
__ 是用来定义慢于多少秒的才算慢查询。查询 __ 的值如下：

我们可以将其设置设置 __=，如下。

开启慢查询的方法，一是可以通过在配置文件  或  中设置配置参数，二是可以通过命令行设置变量来即时启动慢查询日志，个人比较喜欢第二种即时性的。由下图可知，记录慢查询日志已开启，__=。

__ 是否打开记录慢查询日志
___ 日志存放位置
命令
接下来看看慢查询日志的格式是怎么样。例如，在  中运行  

打开慢查询日志文件  的信息格式如下，说明这条  语句执行用时 ，锁了 ，查询返回  行，一共查了  行。

随着  数据库服务器运行时间的增加，可能会有越来越多的  查询被记录到了慢查询日志文件中，这时要分析慢查询日志就显得不是很容易了。 提供的  命令，可以很好地解决这个问题。
 的主要功能是统计不同慢  的：

执行次数

执行最长时间

累计总耗费时间

等待锁的时间

发送给客户端的行总数

扫描的行总数


进入  目录，输入   或 可以看到这个工具的参数。

，是表示按照何种方式排序，、、、 分别是按照执行次数、执行时间、等待锁时间、返回的记录数来排序，、、、 表示相应的平均值；

，是前面排序的逆序；

，是   的意思，即为返回排序后前面多少条的数据；

，后边可以写一个正则匹配模式，大小写不敏感的；


比如，执行    ，得到执行次数最多的前  个查询，如下图所示。

执行     ，得到返回记录数最多的前  个查询。
使用  命令可以非常明确的得到各种我们需要的查询语句，对  查询语句的监控、分析、优化是  优化的第一步，也是非常重要的一步。
二  分析查询
在分析查询性能时， 关键字同样很管用。 关键字一般放在  查询语句的前面，使用  关键字可以模拟优化器执行  查询语句，从而知道  是如何处理  语句的。这可以帮助分析查询语句效率低下的原因或是表结构的性能瓶颈。通过  命令可以得到：
– 表的读取顺序
– 数据读取操作的操作类型
– 哪些索引可以使用
– 哪些索引被实际使用
– 表之间的引用
– 每张表有多少行被优化器查询
的用法
  或
   _
前者可以得出一个表的字段结构等等，后者主要是给出相关的一些索引信息，本文要讲述的重点是后者。
首先看看  的输出参数：

这些参数中，各个参数的含义如下
：本次  的标识符。在查询中每个  都有一个顺序的数值。
_： 类型，主要是区别普通查询和联合查询、子查询之类的复杂查询。主要有这几种：

：这个是简单的  查询，不使用  或者子查询。

：子查询中最外层的 。

： 中的第二个或后面的  语句。

 ： 中的第二个或后面的  语句，取决于外面的查询。

 ： 的结果。

：子查询中的第一个 。

 ：子查询中的第一个 ，取决于外面的查询。

：派生表的  子句的子查询。


：输出行所引用的表。　
：联合查询所使用的类型。
 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：  
    _      __  _  _  _        
一般来说，得保证查询至少达到  级别，最好能达到 。
_：指出  能使用哪个索引在该表中找到行。如果是空的，没有相关的索引。这时要提高性能，可通过检验  子句，看是否引用某些字段，或者检查字段不是适合索引。
：显示  实际决定使用的键。如果没有索引被选择，键是 。
_：显示  决定使用的键长度。如果键是 ，长度就是 。文档提示特别注意这个值可以得出一个多重主键里  实际使用了哪一部分。  
：显示哪个字段或常数与  一起被使用。
：这个数表示  要遍历多少数据才能找到，在  上是不准确的。：如果是  ，这意味着信息只用索引树中的信息检索出的，这比扫描整个表要快。
如果是  ，就是使用上了  限制。
如果是   表示用不着 ，一般就是没查出来啥。
如果此信息显示   或者   的话会很吃力， 和   的索引经常无法兼顾，如果按照  来确定索引，那么在   时，就必然会引起  ，这就要看是先过滤再排序划算，还是先排序再过滤划算。
 现在我们再用  来看看前面案例的  执行情况。首先，先看看 __ 的表结构如下，该表的索引是 。

未执行完的  语句是  ___  =   =_招商银行   =
将其转换为  语句，   ___  =_招商银行   =。执行命令如下：

由上图可见，=，=，该  未使用索引，是一个效率非常低的全表扫描，在数据量很大的情况下，性能情况可想而知。
上述讲的几种方法是用来定位  的性能瓶颈，那定位出性能问题后，接下来就是对这些低效的  语句进行优化。问题是怎么优化？根据什么原理来优化？这涉及到索引问题，这一部分将会后续放在《 索引及查询优化总结》中讲述，本文主要讲述定位  性能瓶颈的两种方法：慢查询和  工具， 命令。作者 |蒋专编辑 | 顾乡

| 导语  已经成为广告、报表以及推荐系统等大数据计算场景中首选系统，因效率高，易用以及通用性越来越得到大家的青睐，我自己最近半年在接触以及 之后，对技术的使用有一些自己的经验积累以及心得体会，在此分享给大家。本文依次从生态，原理，基本概念， 原理及实践，还有调优以及环境搭建等方面进行介绍，希望对大家有所帮助。

 生态及运行原理
 
 特点

运行速度快 = 拥有执行引擎，支持在内存中对数据进行迭代计算。官方提供的数据表明，如果数据由磁盘读取，速度是 的倍以上，如果数据从内存中读取，速度可以高达多倍。

适用场景广泛 = 大数据分析统计，实时数据处理，图计算及机器学习

易用性 = 编写简单，支持种以上的高级算子，支持多种语言，数据源丰富，可部署在多种集群中

容错性高。引进了弹性分布式数据集    的抽象，它是分布在一组节点中的只读对象集合，这些集合是弹性的，如果数据集一部分丢失，则可以根据“血统”即充许基于数据衍生过程对它们进行重建。另外在计算时可以通过来实现容错，而有两种方式： ，和  ，用户可以控制采用哪种方式来实现容错。


的适用场景
目前大数据处理场景有以下几个类型：

复杂的批量处理  ，偏重点在于处理海量数据的能力，至于处理速度可忍受，通常的时间可能是在数十分钟到数小时；

基于历史数据的交互式查询 ，通常的时间在数十秒到数十分钟之间

基于实时数据流的数据处理  ，通常在数百毫秒到数秒之间


成功案例目前大数据在互联网公司主要应用在广告、报表、推荐系统等业务上。在广告业务方面需要大数据做应用分析、效果分析、定向优化等，在推荐系统方面则需要大数据优化相关排名、个性化推荐以及热点点击分析等。这些应用场景的普遍特点是计算量大、效率要求高。腾讯    淘宝  优酷土豆
运行架构
基础运行架构如下所示：
结合集群背后的运行流程如下所示：

 运行流程：
架构采用了分布式计算中的模型。是对应集群中的含有进程的节点，是集群中含有进程的节点。作为整个集群的控制器，负责整个集群的正常运行；相当于计算节点，接收主节点命令与进行状态汇报；负责任务的执行；作为用户的客户端负责提交应用，负责控制一个应用的执行。集群部署后，需要在主节点和从节点分别启动进程和进程，对整个集群进行控制。在一个应用的执行过程中，和是两个重要角色。 程序是应用逻辑执行的起点，负责作业的调度，即任务的分发，而多个用来管理计算节点和创建并行处理任务。在执行阶段，会将和所依赖的和序列化后传递给对应的机器，同时对相应数据分区的任务进行处理。

  每个程序自有，不同程序互相隔离，多线程并行，

集群对透明，只要能获取相关节点和进程

 与保持通信，协作处理


三种集群模式：
 独立集群
  
  
基本概念：
 =的应用程序，包含一个 和若干
 = 应用程序的入口，负责调度各个运算资源，协调各个 上的
  = 运行的函数并且创建
 = 是为运行在 上的一个进程，该进程负责运行，并且负责将数据存在内存或者磁盘上。每个都会申请各自的来处理任务
  =在集群上获取资源的外部服务 例如：、、
  = 集群中任何可以运行代码的节点，运行一个或多个进程
 = 运行在上的工作单元
 = 提交的具体操作，常和对应
 = 每个会被拆分很多组，每组任务被称为，也称
 = 是  的简称，中文为弹性分布式数据集是最核心的模块和类
 = 根据构建基于的，并提交给
 = 将提交给 集群运行并返回结果
 = 是 的一种类型，返回值还是一个，所有的采用的都是懒策略，如果只是将提交是不会执行计算的
 = 是 的一种类型，返回值不是一个，而是一个集合；计算只有在被提交的时候计算才被触发。
核心概念之

核心概念之  

返回值还是一个。它使用了链式调用的设计模式，对一个进行计算后，变换成另外一个，然后这个又可以进行另外一次转换。这个过程是分布式的。 返回值不是一个。它要么是一个的普通集合，要么是一个值，要么是空，最终或返回到程序，或把写入到文件系统中。
是返回值返回给或者存储到文件，是到的变换，是到的变换。
只有执行时，才会被计算生成，这是懒惰执行的根本所在。
核心概念之  
 = 包含多个的并行计算，一个触发一个
 = 一个会被拆为多组，每组任务称为一个，以进行划分

核心概念之
以为例解释过程。

在没有的文件分片合并下的过程如下：=

 来的数据存放到哪里？
刚  来的  存放在  缓冲区，经过处理后的数据放在内存  磁盘上。这里我们主要讨论处理后的数据，可以灵活设置这些数据是“只用内存”还是“内存＋磁盘”。如果 = 就只用内存。由于不要求数据有序，  的任务很简单：将数据  好，并持久化。之所以要持久化，一方面是要减少内存存储空间压力，另一方面也是为了 。
之所以需要把中间结果放到磁盘文件中，是因为虽然上一批结束了，下一批还需要使用内存。如果全部放在内存中，内存会不够。另外一方面为了容错，防止任务挂掉。
存在问题如下：

产生的  过多。每个  产生  个数个 ， 个  就会产生    个文件。一般   的  和  都很大，因此磁盘上会存在大量的数据文件。

缓冲区占用内存空间大。每个  需要开  个 ， 个  就会产生  个 。虽然一个  结束后，对应的缓冲区可以被回收，但一个   上同时存在的  个数可以达到   个一般  同时可以运行  个 ，占用的内存空间也就达到了     。对于  核  个  来说，占用内存就是 。


为了解决上述问题，我们可以使用文件合并的功能。
在进行的文件分片合并下的过程如下：=
可以明显看出，在一个  上连续执行的  可以共用一个输出文件 。先执行完的  形成  ，后执行的  可以将输出数据直接追加到   后面，形成  ，每个  被称为 。下一个  的  只需要  整个  就行了。这样，每个  持有的文件数降为   。 功能可以通过=来开启。
核心概念之
  =   读取数据，加载成


  = 
  = 





和两个操作比较特殊，他们既不是也不是。会将标记需要缓存的，真正缓存是在第一次被相关调用后才缓存；是抹掉该标记，并且立刻释放内存。只有执行时，才会开始创建并进行后续的变换计算。
其实也是调用的持久化函数，只是选择的持久化级别为_。
支持的持久化级别如下：
需要注意的问题：或场景序列化时， 序列化不支持 ，需要 可以的对象。一旦在序列化用到不支持 的对象就会出现上述错误。只要写磁盘，就会用到序列化。除了阶段和会序列化，其他时候处理都在内存中，不会用到序列化。
 运行原理
程序是使用一个应用实例一次性对一批历史数据进行处理， 是将持续不断输入的数据流转换成多个分片，使用一批应用实例进行处理。

从原理上看，把传统的批处理程序变成程序，需要构建什么？

需要构建个东西：

一个静态的   的模板，来表示处理逻辑；

一个动态的工作控制器，将连续的   切分数据片段，并按照模板复制出新的    的实例，对数据片段进行处理

进行原始数据的产生和导入；将接收到的数据合并为数据块并存到内存或硬盘中，供后续 进行消费

对长时运行任务的保障，包括输入数据的失效后的重构，处理任务的失败后的重调。


具体的详细原理可以参考广点通出品的源码解析文章：

对于 需要注意以下三点：

尽量保证每个节点中的数据不要落盘，以提升执行效率。



保证每个的数据能够在 时间内处理完毕，以免造成数据堆积。


使用提供的框架进行数据接收时的预处理，减少不必要数据的存储和传输。从中接收后转储前进行过滤，而不是在具体处理时才进行过滤。


 资源调优
内存管理：
的内存主要分为三块：
第一块是让执行我们自己编写的代码时使用，默认是占总内存的；
第二块是让通过过程拉取了上一个的的输出后，进行聚合等操作时使用，默认也是占总内存的；
第三块是让持久化时使用，默认占总内存的。
每个以及每个占用的内存需要分析一下。每个处理一个的数据，分片太少，会造成内存不够。
其他资源配置：

具体调优可以参考美团点评出品的调优文章：


 环境搭建
 以及 文档：


相关推荐踩坑记—— 应用及调优踩坑记：初试【教程】核心概念引言
和是在两种典型的有状态的集群服务。首先和都需要存储盘来保存有状态信息，其次和每一个实例都需要有对应的实例需要需要来作为集群内部每个成员的标识，集群内节点之间进行内部通信时需要用到这些标识。
对于这类服务的部署，需要解决两个大的问题，一个是状态保存，另一个是集群管理多服务实例管理。中提的版本之前称为方便了有状态集群服务在上的部署和管理。具体来说是通过 来做集群的初始化工 作，用  来维持集群成员的稳定关系，用 和  提供网络存储来持久化数据，从而支持有状态集群服务的部署。
本文将尝试根据社区提供的方案，对和服务进行部署。具体的部署过程包括以下几个部署：   存储的创建 
 资源的创建
 服务的创建 
 存储的创建
是集群之中的一块网络存储。跟  一样，也是集群的资源，并且不属于特定的。 跟  卷 类似，不过会有独立于  的生命周期。
在有状态服务创建之前，需要先创建对应的存储。为了便于环境的搭建，本文存储的后端采用。服务的容器化部署，可以参考腾讯云容器服务帮助文档搭建服务器。
   
                                         
                                      
                  
                   
                 
                 
                  
                 

基于的创建示例如下：
   
   
  
     
    
         
  
    
       
    
       
     
    
       
       

其中为对应的服务的。对应创建多个，服务和服务各个。
   
                        
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 

上面通过手动的方式创建了一个 ，这在管理很多的时候很方便。还提供了来动态创建，可以大大节省了管理员的时间。作者在这里就不做对应的测试了。
中资源和服务的创建
是为了解决有状态服务的问题对应和是为无状态服务而设计，其应用场景包括

稳定的持久化存储，即重新调度后还是能访问到相同的持久化数据，基于来实现
稳定的网络标志，即重新调度后其和不变，基于 即没有 的来实现
有序部署，有序扩展，即是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依序进行即从到，在下一个运行之前所有之前的必须都是和状态，基于 来实现
有序收缩，有序删除即从到

在创建好对应的后，需要创建对应的资源。由于本文使用的为版本，所以示例中采用的名称仍然为。具体的创建的的示例如下：
       
 
 

  
     
   
  
     

  
    
     
    
     
   
   
  
     

 
 

   

   
   
  
    
      
         
      
         
         
            {
                 
                 _
                 
                 = = =
                 
                    {
                         
                         
                    }
                    {
                         
                         
                    }
                
            }
            {
                 
                 
                 
                 =\\ =
                 
                  {
                       _
                       {
                           {
                               
                               
                          }
                      }
                   }
                
                 
                    {
                         
                         
                    }
                    {
                         
                         
                    }
                    {
                         
                         
                    }
                
            }
        
    
      
        
         
        
          
           
          
           
        
         
        
         
        
          
            
             
             
               
           
           
        
          
           
          
           
      
        
         {}
        
         {}
  
   
       
      
         
    
         
      
        
           

描述文件中包括以下几个重要部分： 容器初始化环境信息和对应的配置文件信息
 容器通过启动
 通过  进行健康检测
 声明对应的  
 创建对应的 
创建过程中查看具体的资源信息：
创建服务
    
  
  

查看服务实例状态从服务状态中可以看出，服务实例依次启动
    
                         
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        

查看   信息
   
                          
                              
                              
                              

查看  信息
   
                               
                                      
                                                       
                                      
                                      
                                                       
                                                       

查看服务信息
    
                         
                            

查看的状态信息
     =   
                                    
                                   
                                   
                                   

查看中的域名信息
    
  
          
          
          

    
  
       

    
  
       

    
  
       

查看服务实例内部状态
查看配置信息
   
=
=
=

   


查看集群状态
  

    


中资源和服务的创建
在创建好服务后，我们接下来创建服务。服务的创建过程和服务类似。对应的示例文件如下：

 
 

   
  
     

  
    
     
   
  
     

 
 

   

   
   
  
    
      
         
      
         
    
       
       
       
       
      
        
         
         _
        
          
             
             
        
          
           
        
         
         
             ={} \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = \
           = 
        
          __
             
          _
           =
        
          
           
        
          
            
              
              
              =
  
   
       
      
         
    
         
      
        
           

创建服务
    
  
  

查看的状态信息
     =   
                                    
                                  
                                  
                                  

其他信息的变化和服务创建过程类似，限于篇幅关系，这里不再展示。
进行集群可用性测试
创建测试
   \
   \
   \
   \
  

  

创建生产消费测试
     

                                                                  
  
 

在消费者侧显示为：
  
 

进行扩容测试
创建新的和
     =
                                       
                 

     
                     
                                             

由于创建过程在前文已经描述过，这里不再进行详述创建过程。
副本数修改
      =
  

      =   
                                    
                                  
                                  
                                  
                                  

总结
本文详细的介绍了基于 的方式，部署有状态的集群服务和。总体上看，基于的方式很好的解决了和服务需要存储盘来保存信息，同时每个实例需要特定的标记的问题。但目前的创建过程，以及的启动过程，相对于来说还是比较复杂。另外基于的扩容和升级对于实例的变更顺序依然有比较大的依赖，社区也在做进一步探索。
相关推荐： 中  和  有状态集群服务部署实践 二问题描述
近期根据   的报道，以及国际  厂商  的公告，我们注意到了一起敏感信息、 密钥被  泄露给了随机的  请求，同时相关敏感数据也被搜索引擎给收录的问题。
这一问题持续了 至 近半年时间，最为严重的阶段是至 每   请求就有可能泄露一份内存数据近总请求量的预计是 页面涉嫌数据泄露。包括  在内的一系列知名互联网企业可能受到影响。
以下是可能受到这一问题影响的网站清单：
信息泄露问题原因
  服务 会对  标签进行重新解析，比如将   的标签插入到  中 安全地重写  链接成为  ， 模糊  邮箱地址等等。但是由于  模块中的  解析功能存在指针问题，导致在用户之间共享的反向代理存在信息泄露问题，最早是由  ’   的研究员   发现。
之前  的  解析一直使用标准的  有限状态机编译器  ，但是前段时间为了提升代码效率对解析器进行了升级，将其升级为   并测试了其对  的解析是没有问题的。但是问题出在了开发团队错误的使用了  的编码规范， 的代码会被自动编译为  语言的代码，而  语言允许更加灵活的使用指针。
   
   ==  
  
以上自动生成的代码会导致指针越界，也就是常见的内存泄露问题。但是之前实现的 解析模块单独使用并不会触发信息泄露问题，而是仅当基于  解析器与  升级后的  解析器一起工作的时候才会触发这一问题。
解决方案
迁移至腾讯云
腾讯云提供基于角色的权限控制，并且支持以接口方式调用。同时新用户开通即连续个月，每月赠送流量包。
 财务管理员
 超级管理员
 云资源管理员
超级管理员拥有创建者的所有权限，可以进行其他子用户的分配；而云资源管理员拥有对所有云资源的管理权限，但不可以创建其他子用户。部分功能仅能够供预设管理员使用，具体如下：
 使用云  获取账户下所有域名详细信息；
 使用云  或在 控制台 进行域名所属项目的切换；
项目管理员除了预设管理员外，还可以按照项目维度划分权限，即项目管理员。项目管理员可以管理指定项目中所有的云资源。
项目管理员可以通过自定义策略 中服务类型为项目管理的策略进行指派，该策略拥有两个功能：
 管理  业务项目内云资源
 管理其他业务项目内云资源
考虑在你的应用中实现  无密钥加载架构
对证书稍微熟悉的朋友都知道， 密钥和证书都是成对使用的，一个证书一定唯一对应一个私钥。整个  最重要的一个数据就是  的私钥了，如果私钥泄露，整个握手过程就可以被劫持，签名可以被伪造，对称密钥也可以被破解。整个  就毫无安全可言。
传统的私钥使用方案和风险传统的私钥方案就是将私钥和应用程序绑定在一起。比如大家熟知的  ，如果想使用 ，必须在部署  的接入机器上部署相关的证书和私钥。

这种方案会有如下安全上的问题：私钥部署在云端或者 ，如果泄露了怎么办？
无秘钥方式虽然腾讯云的内网非常安全，但是出于对客户的安全负责，彻底打消用户对私钥泄露的顾 虑，确保用户对私钥的绝对控制，腾讯云提供一种无私钥的加载方案。这个方案核心是「不需要把私钥存储在腾讯云，允许用户使用自己的服务器保管私钥，完成  的接入」。 腾讯云完全接触不到私钥，客户甚至可以把私钥保存在自己家里的服务器上。
它的接入过程如下：
 用户发起  握手请求。
 在涉及到私钥计算的时候，腾讯云  会将这个私钥计算请求通过加密的自定义协议，转发给用户自己的  服务器上。
  服务调用用户的私钥完成计算。
  服务将计算结果返回给腾讯云 。
  继续进行  请求的处理。
整个过程，腾讯云接触不到  私钥，需要注意一点的，  是腾讯云提供一个服务端程序，代码开源，用户自主部署，服务端行为用户掌握得一清二楚。

总结来说无密钥加载架构可以更好的实现用户的私钥安全性，但是会对于开发者而言增加一次网络交互，一般来说的网络延时，除非是对于安全性有非常高要求的应用，才会考虑这一方式，是用腾讯云的这一架构需要和我们的技术人员单独沟通以明确需求。
参考资料


《      》
《  》
《         》

相关推荐借助腾讯云开启全站及问题解决分享泄露资料分析黑客工具技术—篇导语
和是目前开发  的两门主要语言。自年发布到目前为止其行业现状如何？经过岁月的洗礼其稳定性、性能和开发特性支持度都是比较成熟的，在这些方面是否已经比较完善，开发者是否可以开始着手大面积使用进行项目开发？和在性能方面运行效率是否更好？具体分析请看下文展开。
和是目前开发  的两门主要语言。自年发布到目前为止其行业现状如何？经过岁月的洗礼其稳定性、性能和开发特性支持度都是比较成熟的，在这些方面是否已经比较完善，开发者是否可以开始着手大面积使用进行项目开发？和在性能方面运行效率是否更好？具体分析请看下文展开。 
一、的背景
 于年月启动开发，苹果开发者大会上正式发布问世，年月正式开源。 
谈起，不得说说它的作者。

的作者克里斯·拉特纳 ， 在年之前，是美国大学的博士，在博士期间于年启动和开始主持项目，年月加盟 ，之后整个研发团队全部加入，致力于在开发体系中的应用，目前已经被苹果开发工具、 、、等各大公司采用。也是项目的主要资助者。
  加入后，成为的主要负责人同时也是的主管，之后发起了项目，于年月启动开发，之后年发布年开源，于年月从离职，随后这位在工作了年的技术大牛正式加入，个月后从主动辞职。
  作为一名后程序员，发明了 、、，同时还是的，可以说是牛逼轰轰，大神中的大神，一个不可一世的人才。
的版本迭代历史

 版本属于刚开始阶段，版本添加了很多新特性，版本在生涯中属于革命性的一步，其中改动了很多，语法和版本也有较大差异。到版本主要是优化和保持稳定性，改动较小。文章后续内容主要针对版本。
的开发模式及目标
设计的目标也是初衷是在程序运行角度要比系语言   更快速，开发角度写法越简单越高效越好，让程序员在编程语言语法角度浪费的功夫越少越好，能把更多的时间和精力用于思考和开发应用程序逻辑。同时原始设计为不仅可以用来开发 这样的小程序，也可以用来开发一套完整的操作系统。的出台至少奠定了未来十年的发展方向，具有重大的战略意义。
的官方说明：、、，更安全、更快速、更易表达。安全角度取消了很多兼容的语法，只取其一，因为不再是的超级，所以那些在语言上存在的历史诟病，在上不复存在。
集成了很多高级语言的优秀特性，借鉴了很多高级语言的优秀语法，开发角度写法类似等脚本语言，但是本身又属编译性质语言，是一门真正的编译语言，而非解释型。
 结合了和 的优点并且不受  兼容性的限制。采用安全的编程模式并添加了很多新特性，比如范型、闭包、函数式编程等，使编程更简单，更灵活，也更有趣。
开发模式方面，在开源之前主要依赖苹果 及所带领的开发团队，同时随着的问世，开发者社区也同步建立， 及所带领的开发团队非常关注社区建议和邮件列表，针对社区的建议，在新特性支持上团队并非单纯的建议的新特性就会加上，而往往是后退一步，思考更多，理解开发者真正需要的特性，此后考虑着手开发。
随着的开源，开源社区开发力量的加入，开发者社区更加活跃，也在更加趋于完善。
二、的行业现状
编程语言排行榜
看近三年三月份的编程语言排名数据，由年的名上升至年的名，在年上升至第名；再看看，由年的第名下降至年的第名，在今年下降至名。编程语言日趋上升。
 
开发社区生态
正如 在离开前的近几年已不怎么过问自身的事，而主要投入精力到的研发上一样，彼时已建立起成熟的开发者社区，彼时的已是社区的， 在将主要精力转向的研发上时，项目自身的存活与否已经不会有什么影响。
也一样， 离开前，也已经建立起成熟的开发者社区，此时的也不再只是的，此时的已是社区的， 的离开并不会对的发展造成大的影响。加上开源的力量，相信会继续勇往前行。
开源库占比
目前上语言的开源项日大约是语言的开源项目的倍还多。


本身成熟度、库成熟度、集成环境支持程度
经过版本的改进，语法和性能上已开始趋于稳定，后期版本主要是优化提高性能和稳定性，改动不多，本身成熟度已开始趋于完善。
库的成熟度，经过的努力，相信也有不少提升，很多在版本还没有版本的库，版本到版本已经有很多库用进行了改写。库的性能和稳定性目前还不好说，还需要经过海量的线上验证，需要经过一段时间的洗礼才能得出结论。既然已经转向，相信即使有些大大小小的问题苹果也会积极处理和解决。这方面不用太过担心。
 就开始支持，目前 已经同时支持 和  版本，可在工程设置里面设定。

三、的优秀语法
和简单语法对比： 
简单值定义
 取消了和非的区分，所有的简单值定义改为：通过定义常量，通过定义变量。不再有宏定义，在里面要实现宏定义，直接用定义全局常量。如下：



类型推断特性

和定义简单值如果指定初始值则不再需要指定类型，不指定初始值则需要明确指定类型。初始化时指定初始值时编译器会自动推断变量类型。


字符串插值参数打印

参数打印不再需要通过加固定字符来指定打印格式，直接\反斜杠一对圆括号里面包含常量、变量、字面量和表达式即可。


使用方括号  来创建数组和字典，并使用下标或者键来访问元素。

数组成员和字典可以直接是、等基础类型，不用再像里面需要转成对象。


两类可选值

使用  和  来处理值缺失的情况。一个可选的值是一个具体的值或者是  以表示值缺失。在类型后面加一个问号来标记这个变量的值是可选的。

如果变量的可选值是 ，条件会判断为 ，大括号中的代码会被跳过。如果不是 ，会将值解包并赋给 后面的常量，这样代码块中就可以使用这个值了。
另一种处理可选值的方法是通过使用  操作符来提供一个默认值。如果可选值缺失的话，可以使用默认值来代替。一个即搞定，不再需要像里面需要写判断或是问号表达式，变得更加简洁。


布尔值

在中，、、之后的判断式并不需要一定传入布尔类型。也可以传入整型、指针等类型，只要非就为真，并且赋值是有副作用的。比如：

上面的代码返回的数值，这样就有可能出现将判断：

错写成：

为避免这个问题，有种变通写法：

这种写法被称为表达式，因为《星球大战》中的大师喜欢使用这样奇特的倒装句子。
 强制要求、、后面判断式子一定需要传入布尔类型。因此写成以下这种判断就会编译错误，因为 = 的结果是是型而非布尔型。表达式这种变通写法再也没有必要。

 里面的常量值是和。


中语句可以直接比较，在以往中则要通过很多 来实现：



中的实现

中一个语句执行完成后就不再向下执行。里面没有语句，不会再偶然地出现！
区间运算符
闭区间运算符
 闭区间运算符…定义一个包含从到包括和的所有值的区间。的值不能超过。在循环中非常有用。

半开区间运算符
半开区间运算符定义一个从到但不包含的区间。之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。
强制使用大括号
在中，、、之后的语句假如只有一行，是可以省略掉大括号的 。比如：

当后面的人修改代码，或多人修改同一代码再合并时，可能会在后面直接插入一行，这样就一定会了。

里面必须要有大括号。

语句

里面语句简化了函数实现里面参数有效性的。像语句一样，语句的执行取决于一个表达式的布尔值。
可以使用  语句来要求条件必须为真时，以执行语句后的代码。不同于  语句，一个  语句总是有一个  从句，如果条件不为真则执行  从句中的代码。




 中的  类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。


元组

中的元组把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。

元组的最大用途在函数可以返回多个值


闭包

里面定义一个闭包，闭包 = {形参  返回值  代码实现}， 用于区分函数定义和代码实现：

最简单的闭包，如果没有参数返回值，则参数返回值 统统都可以省略


范型

范型的应用场景：

、 和  的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是  、  和  。
在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，里面通过范型来解决。如下：


字符串拼接和比较

里面字符串可以直接拼接：

也可以直接比较
 
的语法设计使一些常见错误不可能再出现，比如：字符串插值参数打印；、、之后的判断式强制是类型；中语句取消；、、之后的语句强制使用大括号。
同时更多的是让语法更简单，编程语言的语法进行简洁化和优化，让程序员省掉关注语法的时间，将更多的时间和精力放在应用程序逻辑开发上。比如：省略分号；可选值；中可以直接对类型进行判断；区间运算符；语句；初始化中的；元组；闭包；范型；字符串拼接和直接比较。
四、 性能对比
以下从开发中常用的基础语句运行效率方面进行对比，对比和两个版本和两者的性能差异。
 对比维度：循环、自增 以前有自增运算，后取消了、赋值、添加字符串到数组、添加整数到数组、添加字符串到字典、添加整数到字典、拼接字符串。
 每项操作运行次的耗时对比。
 模拟器：    真机：   
 模式下优化级别设为

代码：见附件
模拟器对比结果：
 

 



真机对比结果：
 

 



结论：
在设定的几项对比维度内：  到 ，性能运行效率提升不明显，基本没有提升； 循环、自增、赋值、字符串数组处理、为字符串或数值的字典处理操作，性能不如； 整型数组处理，优于； 字符串拼接处理，性能较优势明显。
整体来看，和相比，除了字符串处理优势明显外，其它基础操作方面性能稍逊色。
是一门静态编译语言，是一门运行时动态绑定语言，因为的动态特性，导致编译器能做的优化工作是很有限的，很多工作只能放到运行时处理，所以从这方面看在编译时能做的优化能做的更多，从而性能提升空间也较的大，但目前来看只有字符串处理方面优化的比较不错，其它方面并不明显。
五、和混用
和互调需要新建一个文件做桥接，具体请参看稍后将会发的另外一篇文章后续 
六、最近更新点
版本更新频繁，比如到去掉了””、””自增自减运算。时网上有很多同行验证的自增自减运算相对有严重的性能问题，到去掉了不知是不是当前尚未解决此问题或是有其它的替代方案。
到一个典型的改动点是关于 ，在 时，函数定义前不需要添加修饰。 中则必须要加修饰。其它的改动这里不再详述，请参阅苹果官方文档。
七、的当前缺陷
所面临的问题，也即到目前为止大多数程序员吐槽和诟病的关于动态特性或叫“反射特性”类似中的反射。
是一门动态语言，对开发者来说即运行时编程，可以在进行类和方法的增删修改，甚至是对无源码的和类库进行 改变原有库接口的功能等，给开发者提供了足够大的权限和便利，因为权力够大，因而容易过度使用，然而也正是这种动态特性的过度使用，导致这门语言是不安全的。 
并非在或基础上进行开发，而是重新设计和布局，的目标在于具备处理广泛问题的能力，包括服务器端开发和系统编程。因为要求更高的安全性，而动态特性本身容易导致过度使用，动态特性本身是一把双刃剑，所以苹果开发工程师整个团队也正在思考一种更合理的解决方案。
八、给开发者的建议
 依据前面“四”的对比，和相比在字符串处理方面优势明显，其它方面和差不多，实际项目中可以根据项目性质合理选择两者之一做为开发语言，甚至不同情境下应用各自语言的各自的优势，不同模块采用不同的语言做开发。
九、未来展望
融合了至目前为止大多数高级语言的优秀特性，可谓是站在所有语言的肩膀上，汲取所有语言的精华，是目前行业内最优秀的语言，期待未来在稳定性、性能上的改善能取得更多质的突破。 简介
是下一款堆栈跟踪工具，可以打印一个在跑程序的实时堆栈信息，其用法非常简单，只需要给定进程号即可：
  
 举例如下：
   
   ___   
      
    
 的实现
其实是个脚本，核心原理是的   命令，基本逻辑是通过进程号来分析是否使用了多线程，同时使用 到在跑进程上，最后调用子命令后简单格式化输出，代码如下：
   

    


     
      `  `  
     


     
         
     


           
             
     

=
     
          
      `  |  `     
    =   
    
     
           
             
    =   
    


={}

      
       _    
        | 
  
  
  


  \
     \ \ \
      \
     
 里的
 基本命令的使用

 ，检查目录是否存在
 ，检查文件是否存在
 ，用  更好一些
  ，的替换命令

  
 也是一种重定向，结束时会发给。
 里的
的东西内容非常多，这里不展开，里最核心的就是调用，到对应进程，然后执行命令，如果程序是多线程就执行   命令，最后退出。
附带文档的两个说明，第一个是关于的：

               

看了这个应该就很容易明白为什么不能随便在生产环境中去一个正在运行的程序，如果上以后待着不动，程序就暂停了。
那为什么用没啥事儿呢，原因是执行了一个的子命令后立即退出了，可是源代码里面没有执行，它是怎么退出的呢，看这个文档说明：

                

  重定向结束的标志是，读到了自动退出了。
 里
里面检查进程是否支持多线程的方法是检查进程对应的目录，方法没什么可说的，其中 下是通过检查是否加载来搞的，这种是动态的，类似于静态的。这种方法其实不太严谨，但由于的   对多线程的支持也不是特别完美，所以也无可厚非。这里简单说说的。
虽然并不是所有的操作系统都支持，也不是首创了这种虚拟文件系统，但绝对是将其发扬光大的，早起内核中甚至达到了滥用的程度，内核开发者喊了好多年，说即将被淘汰，但依然很火，主要是因为太方便了，比如可以很容易的进行应用层与内核态进行通信。
在中的应用不止是进程信息导出，详细的应用与内核模块联动，后续会写专门的文章介绍，如有兴趣，可以参考《深入理解内核架构》和《设备驱动程序》，关于进程的，以下信息可以了解一下：

 启动该进程的命令行
 当前工作目录的符号链接
 影响进程的环境变量的名字和值
 最初的可执行文件的符号链接 如果它还存在的话。
 一个目录，包含每个打开的文件描述符的符号链接
 一个目录，包含每个打开的文件描述符的位置和标记
 一个文本文件包含内存映射文件与块的信息。
 一个二进制图像表示进程的虚拟内存 只能通过化进程访问
 该进程所能看到的根路径的符号链接。如果没有监狱，那么进程的根路径是
包含了进程的基本信息，包括运行状态、内存使用。 一个目录包含了硬链接到该进程启动的任何任务这是我们部门前端同学的学习笔记，笔者编辑了一下并分享给大家。

在使用  之前，项目静态文件几乎没进行压缩合并便直接放到线上，部分文件手动复制粘贴到某压缩网站进行压缩。没压缩合并的文件显然耗资源，手动压缩的文件后期不易维护，每修改一次便要重复复制粘贴，很不方便。 的加入帮忙解决了以上问题，让开发人员更加专注于开发。这里有一篇「教程——安装」很好地教会我们如何搭建  环境。
「官网」的入门文档写得很详细，建议阅读并动手一遍。 网上有人会纠结该用  还是 。个人认为，其实无论是  还是  都是构建工具，基本的功能都差不多，与其浪费时间纠结该使用哪个，还不如先开始选择一个使用，等过段时间熟悉后再考虑是否接触另一个，最后再比较出哪个更适合自己岂不更好。
合并压缩静态资源
我开始使用  的时候只是用来对 ， 文件进行合并压缩，使用到的插件分别如下：
 {
   
   
   
   
   
   
}
我先通过  监控静态文件，一旦文件有改动并保存，便用  把  或  目录下的文件进行了合并，再用  或  把刚刚合并的文件压缩，最后用  把合并但未压缩的文件删除掉。部分代码以  为例如下：
 文件合并
 {
   {
     {
       
    }
  }
}

 压缩代码
 {
   {
     
     
      
     
     
  }
}

 删除多余的文件
 {
    
}

 文件监控
 {
   {
     
       
  }
}
 
后来发现  和  其实已包含了合并的功能，于是乎把  和  给移除掉，因为它们功能重复了。代码如下：
 合并压缩代码
 {
   {
     {
       
    }
  }
}
是的，用了  和  后在浏览器的调试工具下便无法定位到源代码处，这是有办法解决的。办法就是使用  ， 和  的调试工具都支持，具体详情请移步「   详解」。

使用了  和  之初项目还不算大的时候，你也许已经发现了一个现象。那就是我们每次一修改保存文件的时候， 插件便会立马调用  和 。而它们在配置里是对所有的  和  文件进行操作，虽然只对其中一个文件修改，但是目录下的所有文件都会大动干戈地进行合并压缩。配置高的电脑还行，配置低的电脑就悲剧了，至少我试过每次一保存文件都要等待个两三秒钟后合并压缩完成才能去刷新浏览器。一旦静态文件多起来，那这等待的时候只会增多不会减少。后来我找到了「」这个插件来缓解燃眉之急。 只会对改动的文件进行操作，这样至少不会每次保存都对全部文件进行操作。它的使用方法很简单：
 监控
 {
   {
     
     
  }
}
引入资源
以上便是我目前用于项目的阶段，而此时我做进行开发的项目中主要用了类似于  的框架，于是添加  或  外部文件是在  代码里添加，如下：

  
  

这样虽然开发使用到的文件跟上线的文件一致，但也有一些弊端，比如每次改动保存静态文件便会去执行合并压缩代码，我们每天都在时时刻刻地用 ，这是没有必要的。我们应该只在准备发版上线的时候才去合并压缩。但这时如果在开发时使用原始文件则会是这样：

  
  
  
  
  

上面一段代码在上线时是需要注释掉的，那在修复时又要重新打开这份代码，注释掉上面上线使用的代码。如果涉及到多个页面的修改，那得手动打开很多份类似这样的代码，而在修复完成后又得重新重复地进行注释和打开上线代码。万一有哪一段代码没看见忘了就不好了。
接下来
所以接下来我打算在  中使用「」和「」，这样在  函数都只需要引入一个入口文件，然后  通过 ， 通过  便可去加载它们需要的文件。具体结果得等我实践后才知道，但我相信如果  的话我便可以移除  和  两个插件，因为  和  也有合并压缩的功能。

   开发
  
  

   上线
  
  

添加版本号
为了上线之后用户能使用到最新的静态资源，大部分人会使用添加时间戳来清掉缓存，类似于下面这样的代码。读过张云龙的「大公司里怎样开发和部署前端代码」，意识这种方法有几个弊端。一则是每次修改一下时间戳全部的静态资源都会重新被下载一次，没有修改过的文件又重新下载一遍明显是一种浪费。二则是这种方法是一种覆盖式发布，无论先部署页面还是先部署静态资源，期间都可能有用户访问到页面，都有可能造成了页面显示错乱问题，所以需要一种非覆盖式的发布方法来避免这种情况。
  
 = = == 

  
 = ==
总结上诉理论，此刻我们需要一种非覆盖式发布的方法，而此时这种方法就是将静态资源的内容后修改其文件名，做到文件名不同从而起到类似于时间戳的作用。如以下静态资源后的文件名发生的变化：
    
     
接下要怎么实现以上方法呢？要用的工具是 ，使用到的插件如下：
 {
   
   
   
   
   
}
这里暂时不涉及到  文件，处理  文件跟处理  文件类似。使用了「」便可以很轻松地生成  戳后的静态文件。
 静态文件
 {
   {
     
     
  }
   {
     
     
  }
}
静态文件生成后便可以使用「」对使用到这些静态文件的文件里进行文件名替换，改成后的静态文件名。
 替换
 {
   {
     
      
      
      
    
  }
   
   
}
以下的步骤都会避免修改到源文件。具体步骤则是先将图片  后放置于  目录发布目录。然后将  代码都复制到一个目录临时目录，替换里面变更的图片名字，再将  文件  后放置于  目录。接着将  代码复制到  目录，替换里面引用到的图片和  文件名。最后将  目录删除。具体代码实现如下：
 步骤一：对图片进行处理
 
  


 步骤二：对进行处理
 
  
  
  


 步骤三：对进行处理
 
  
  
  

未解决的问题：如上代码，我把它分成了三份分别按步骤运行，但是放在一个任务里却会遇到问题，比如里的图片名称没有被替换等。如哪位朋友有解决办法，不妨传授我一下，感激！
基于  的前端构建
继续对  进行探索研究，例子参考「」。这一次不再使用  进行  静态文件，而是在  里面进行 。然后主要将  用于两个大的方向，一个是用于开发期间，一个用于上线前期打包。使用到的插件可能有些更换。具体目录如下， 目录用于开发与维护， 目录是打包后的项目，用于上线：
├─ 
    ├─ 
    ├─ 
    ├─ 
    └─ 
└─ 
    ├─ 
    ├─ 
    ├─ 
    ├─ 
    └─ 
在开发期间，使用到的  插件如下， 插件用了监听文件，一旦文件被修改，可以让它触发浏览器自动刷新：
 {
   
   
   
   
}
图片不需要压缩， 使用  编译， 使用了 ，并使用  进行检错。其中  编译好后会在同一目录下生成对应的  目录与文件。 的具体配置参考「例子」。
 {
   {
     {
       
    }
     {
       
       
       
       
       
    }
  }
}

 {
   {
     
     
     
     
  }
   {
      
  }
}
在开发结束后，接下来就是让项目上线了，于是就有了打包项目的过程。看过张云龙博客里讲的「大公司里怎样开发和部署前端代码？」，于是便有了非覆盖式发布和静态文件，用到了「」和「」这两个插件。网上有很多教程都是图片、、 文件同一时间进行 ，但我觉得这样不妥，毕竟 代码里引用到了图片，得先图片进行  后替换了 里引用的路径，然后再对 进行才能保证哪些文件是修改过的。
打包分四个步骤。按顺序分别是图片的打包、 文件的打包、 文件的打包、 文件的打包。使用到的插件如下：
 {
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
}
首先得将  目录给删除掉，因为是非覆盖式部署，所以删掉一些过期用不到的静态文件。第一个步骤是图片打包，将需要合并的图片合并了并修改对应的  文件放置于临时目录，不需要合并的图片则复制粘贴到临时目录。然后对临时目录里的图片进行压缩，最后  后放置于  生产环境目录。
 步骤一：对图片进行打包
 
  
  
  
  
  

第二个步骤是  文件的打包，先用  将  压缩到临时目录中，接着用  替换掉里面的已经  的图片资源，最后将  文件进行  后放置于  生产环境目录。
 步骤二：对进行打包
 
  
  
  

第三个步骤是  文件的打包，用的是  插件将  文件合并压缩到临时目录，然后替换掉文件里的图片资源路径，最后  到生产环境目录，并把不需要  的第三方库复制到  生产环境目录。
 步骤三：对进行打包
 
  
  
  
  

第四个步骤则是  文件的打包，先用  把里面的   替换成特定的模式放置于临时目录，然后再用  把  依赖的  片段复制粘贴到一个  中，紧接着替换到  中的已  的静态文件包括，，，最后将  压缩至  目录下。
 步骤四：对进行打包
 
  
  
  
  
  
  

如果你想问我为什么上面的四个步骤不直接写成一个  呢，这是我一直解不开的问题。我试过写成一个 ，后果则是文件里的图片资源路径没能够替换成功，可能是在一个  内  插件无法执行多次，于是我就分类写成四个了。 最后总结一下，以上的方式的好处就在于开发时期不需要去合并压缩文件，方便调试。而生产环境则是尽可能去合并压缩，减少用户的请求时间。抓取页面的方式和库类似，都是直接模拟请求，因此如果遇到渲染的页面同样是无法抓取的，而在前文中我们抓取渲染的页面有两种方式，一种是分析请求，找到其对应的接口抓取，中同样可以用此种方式抓取；另一种是直接用或模拟浏览器进行抓取，这种方式我们不需要关心页面后台发生了怎样的请求，也不需要分析渲染过程，我们只需要关心页面最终结果即可，可见即可爬，所以如果在中可以对接话就可以处理任何网站的抓取了。
本节我们来看一下  框架中如何对接 ，这次我们依然是抓取淘宝商品信息，抓取逻辑和前文中用  抓取淘宝商品一节完全相同。
首先新建项目，名称叫做，命令如下：
  
随后新建一个，命令如下：
   
接下来把_修改一下，修改为。
_ = 

接下来首先定义对象，叫做，代码如下：
    

 

     = 
     = 
     = 
     = 
     = 
     = 
     = 

在这里我们定义了个，也就是个字段，跟之前的案例完全相同，然后定义了一个属性，即此保存的的名称。
接下来我们初步实现的_方法，实现如下：
    
   
   

 
     = 
    _ = 
    _ = =

     _
           
                _  
                 = _  
                 = = ={ } _=

首先我们定义了一个_，即商品列表的，其后拼接一个搜索关键字就是该关键字在淘宝的搜索结果商品列表页面。
在这里关键字我们用标识，定义为一个列表，最大翻页页码用_表示，统一定义在里面，定义如下：
 = 
_ = 

在_方法里我们首先遍历了关键字，随后遍历了分页页码，构造并生成，由于每次搜索的是相同的，所以在这里分页页码我们用参数来传递，同时设置_不去重，这样爬虫启动的时候就会生成每个关键字对应的商品列表的每一页的请求了。
接下来我们就需要处理这些请求的抓取了，这次抓取不同，我们要对接进行抓取，在这里采用 来实现，在里面的_方法里面对每个抓取请求进行处理，启动浏览器并进行页面渲染，再将渲染后的结果构造一个返回即可。
代码实现如下：
   
   
   
   
   _  
   
   

 
     ____ = _=
         = ____
         = 
         = _=_
        __ 
        ___
         =  

     ____
        

     _  
        
        用抓取页面
          对象
          对象
         
        
          
         =  
        
            
               
                 = 
                    ____    
                 = 
                    ____    _
                
                _
                
            ______     
            ____   
             = =_ = = =
         
             = = =

    
     _ 
         =_
                   _=__

首先我们在里面对一些对象进行初始化，包括、等对象，同时设置了页面大小和页面加载超时时间，随后在_方法中我们首先通过的属性获取当前需要爬取的页码，然后调用对象的方法访问的对应的，这也就相当于从对象里面获取了请求链接然后再用去加载，而不再使用里的。随后的处理等待和翻页的方法在此不再赘述，和前文的原理完全相同。最后等待页面加载完成之后，我们调用的_属性即可获取当前页面的源代码，然后用它来直接构造了一个对象并返回，构造它的时候需要传入多个参数，如、等，这些参数实际上就是它的一些基础属性，可以查看官方文档看下它的结构：，这样我们就成功利用来代替完成了页面的加载，最后将即可。
这里可能我们有人可能会纳闷了，为什么通过实现这么一个 就可以了呢？之前的对象怎么办？不再处理了吗？返回后又传递给了谁来处理？
是的，对象到这里就不会再处理了，也不会再像以前一样交给下载了，会直接传给进行解析。
这究竟是为什么？这时我们需要回顾一下 的_方法的处理逻辑，在前面我们也提到过，内容如下：
当_方法返回对象的时候，接下来更低优先级的 的_和_方法就不会被继续调用了，转而依次开始执行每个 的_方法，调用完毕之后直接将对象发送给来处理。
在这里我们直接返回了一个对象，它是的子类，同样满足此条件，返回之后便会顺次调用每个 的_方法，而在_中我们没有对其做特殊处理，接着他就会被发送给，传给的回调函数进行解析。
到现在我们应该就能了解 实现对接的原理了。
在里面开启它的调用：
_ = {
     
}

接下来对象就会回传给内的回调函数进行解析了，所以下一步我们就实现其回调函数，对网页来进行解析，代码如下：
  
     = 
        == 
       
         = 
         =  
         =  
         =  
         = = 
         =  _
         =  _
         

在这里我们使用进行解析，调用变量的方法即可，首先我们传递了选取所有商品对应的，可以匹配到所有的商品，随后对结果进行遍历，依次选取每个商品的名称、价格、图片等内容，构造一个对象，然后返回即可。
最后我们再实现一个 ，将结果保存到，实现如下：
 

 
     ____ _ _
        _ = _
        _ = _

    
     _ 
         _=_ _=_

     _ 
         = _
         = _

     _  
        
         

     _ 
        

此实现和前文中存储到的方法完全一致，原理不再赘述，记得在中开启它的调用：
_ = {
     
}

其中_和_的定义如下：
_ = 
_ = 

这样整个项目就完成了，执行如下命令启动抓取即可：
  
运行结果如下：

再查看一下，结果如下：

这样我们便成功在中对接并实现了淘宝商品的抓取，本节代码：。提示：本文从几个创过业的同事提到的问题，延伸到影响创业团队成败的几个关键因素：创始人、合伙人、团队构成、分工协作、团队目标、决策方式、执行力、钱、时间、等。从而证实一个结论：之所以的创业公司注定倒闭，是因为的创业团队本就不该创业。
引言
 有几个同事，都是从创业公司过来的，我问他们为什么不继续下去，他们的缘由各不相同，目前我了解到的，有下边几种。
、老板不靠谱。自己不行还听不进大家的劝；自己处处花钱却不舍得给大家股权。大家看不到希望，就散了。
、大家全都是搞技术的，没有人负责市场，虽然产品看着挺牛逼，但就是没有用户用，所以拉不到投资，也赚不到钱，大家忍了大半年，就散了。
、大家各有各的想法，都认为自己是对的，谁也说服不了谁，吵着吵着就慢慢散伙了。
、当初承诺的待遇没有给到，说要上市却迟迟上不去，两年下来赚的钱还不如去大公司上班，感觉受到了忽悠。
、本想创业过轻松的日子，没想到比上班还累，明明我是老板，一堆人竟然敢跟我抬杠，骂他们几句竟然全都辞职了，算了，还是在大公司上班安稳。
、正当我们疯狂扩张的时候，行业遭遇寒冬，钱花光了，投资人不愿意继续投，没办法，命不好。
、业务做得挺好，就是一直爆发不起来，撑了两年，实在是撑不下去了。
 、我们一直做得挺好，突然冒出个大公司跟我们竞争，不是我们不努力，实在是拼不过人家。
合伙人或者老板不靠谱
 许多人创业，自己并不是一把手，而是跟着别人去的。
 、别人有个好的创意，朋友圈问谁有兴趣赌一把，于是，不少人想赌一把大的，就跟着去了。
 、别人有钱，想搞一个公司，需要帮手，朋友圈找人帮忙，不少人觉得是个好机会，就跟着去了。
 、别人的公司搞了一段时间了，缺人，于是自己就跟着去了。
除了上边的明显属于被动从属地位的状况，还有一些比较主动加入的自己一直想创业，于是有人说起，一拍即合，以及完全平级的合伙人，或者说自己本就是第一个发起人。
如果自己属于完全被动从属的地位，那么，一旦跟主导者的理念产生冲突，或者是利益没有谈拢，中途退出是极有可能的。这种状况，只能说是自己放弃了，算不得失败。
如果自己属于主导的地位，那么，一旦没能搞定下边的人，团队散了，自己心气儿也没了，于是就此打住，从新开始找工作。这种状况，确实是属于“失败了”。
最常见的一种，则是：几个合伙人，因为理念冲突，或者思路冲突，或者职位冲突，或者利益冲突，导致合伙关系破裂，从而不得不散伙甚至关门大吉。
所以，创业团队，想要成功，首先合伙人或者老板得是靠谱的。
如果自己是后加入的，或者被人忽悠过来的，那么，一定要搞清楚：老板行不行。
如果自己是创始人之一，那么，就一定要找靠谱的人充当合伙人。
如果自己是一把手，那么，一定要找靠谱的帮手。    
团队不靠谱
其实这是第一个问题的延伸。
许多技术人员创业的时候，合伙人都是非常要好的朋友，彼此也都聊得来，大家觉得搞出一个牛逼的网站非常容易。然而，做着做着，发现团队有很大问题：
 、大家全都是做技术的，没有人负责市场营销，没有人负责运营推广，于是，网站做出来，然而，却一直没人用，用户量迟迟上不去，更糟糕的是，搞了小一年，一分钱没赚，大家还得拿家庭收入倒贴公司。
、没有专业的人士负责团队管理、财务管理、法律咨询、等等。其实这是第一条的扩展，只不过第一条是许多创业团队遇到的第一个问题，因此单独拿出来讲。
、大家全都有追求极致的技术精神，从而导致完全掉入技术的坑里，而搞出的技术却没有解决任何社会问题或用户问题，从而徒然浪费资源。这种状况一般大公司比较容易发生，比如曾经辉煌无比的。连这样的大公司都会因此而没落，更不要说创业公司了。当然了，如果外界的投资环境很好，或者被大的企业看中，也不是完全不可能。只是，将主动权和命运交到他人手中，实为不智之举。
 、当合伙人产生意见分歧的时候，不能够有效解决争议，从而导致方向越来越分散，甚至各搞各的，谁也不服谁。大家觉得创业就是为了实现“自己的想法”，如果不能按照自己的想法做事，干脆回到大公司上班得了，何必要冒着风险出来创业呢！
 、除了“实现自己的想法”，许多人创业是为了“过上自由的日子”，如果跟之前一样朝九暮五那般压抑，自己何必要出来创业呢？所以，这样的想法，尤其是创始团队核心成员抱持这样的想法，必然导致团队执行力严重不足。
以上几条分别对应：
人员构成、分工协作、团队目标、决策方式、执行力。
一个靠谱的团队，一定是具有不同专业、互补互助、商业目标、有效决策、有力执行的团队。
如果创业团队所有人都是做技术的，也不引入市场、推广等决定企业命运的关键角色，那么，这个创业团队八成是走不到最后的。
 如果创业团队找不到自己信任的财务、人事、管理、法律等专业化人才，那么，这个创业团队，发展不大的。
如果创业团队没有清晰的商业化目标，只有个人的“梦想和追求”，那么，这样的团队，只适合作为大公司的某个部门，而不适合作为一个独立的商业公司。
如果创业团队每天吵吵闹闹却迟迟没有人愿意妥协，或者尽管一堆人有意见却不愿提到台面上反而在私下默默抗拒，那么，这样的团队，早晚要分裂。
如果创业团队每天构想着自己理想中的安逸生活甚至将公司有限的资金花费在这个上面，那么，这样的团队，很难获得投资人的青睐。更何况，上行下效，有什么样的老板，就会有什么样的下属。
钱的问题
其实，如果以上两个问题搞定了，创业团队一定会做出一定的业绩，以此吸引到所需的投资，甚至完全靠自身利润供血，是没有太大问题的。
创业公司倒闭，许多创始人的通常说法是：我们遭遇了资本寒冬，没能融到生存所需的资金，因此，不得不放弃。这确实很遗憾，但是我们已经尽力了。
笔者相信确实有些非常倒霉的创业公司，该做的全都做好了，突然遇到不可预料的事情，比如地震、火灾、车祸、等，最后公司没能坚持下来。
然而，笔者坚信：大部分的创业公司之所以倒闭，不是因为天灾，而是因为人祸，或者说：团队自身没能把事情做好，没能把风险把控好。
由于国内的创业融资环境尤其是互联网创业公司的融资环境越来越好，许多创业公司，凭着几个技术人员的一腔热血倒不如说靠着一夜暴富的赌博心理，几个人一商量，弄个差不多的，忽悠一下完全不懂行业的暴发户，公司就注册成立了。
然而，能够融到钱，不代表这个公司是有价值的，因为，大部分的投资人，是外行的，甚至完全是赌博的。赌徒遇到赌徒，当然什么事情都有可能发生。
这种状况，一旦进入资本寒冬，不倒闭才算是奇葩呢！
还有一种状况，团队是有价值的，在融资环境好的时候获得一大笔资金，于是大刀阔斧的前进、扩张。突然资本寒冬来临，虽然也有投资人继续投资，但由于前期的超高速扩张，导致资金压力过大，而新的融资无法满足超高规模的资金需求，因而团队不得不降速调整，甚至，逐步进入没落通道。
大家都很清楚，困难是暂时的，道路是曲折的。然而，一个大的团队内，大部分人无法面对哪怕是暂时的下滑。这就像是龟兔赛跑，乌龟虽然走的慢，但一直在往前走，兔子虽然跑的快，但总要停下来歇一歇，甚至往回倒退几步，这就让人非常不爽了。于是，团队士气受到极大打击，单只重新聚合人气，都需要耗费巨大的精力。
不要说在小的创业公司，就是在众多知名的大公司，都有不少类似的案例。
比如凡客、滴滴、乐视，由于企业前期在资金充裕的情况下疯狂扩张，拉高了所有团队成员的心理预期以及公司运营成本，一旦企业资金遭遇短期困境，整个团队士气受到重创，甚至导致关键成员离职，进而影响企业后续发展甚至一蹶不振。
作为员工，你周围的办公区每个月都进来几个员工，一直持续，你会如何感觉？
作为员工，你周围的办公区每个月都进来几十号甚至上百号员工，突然有一天，自己周围的同事一拨一拨离职了，你会如何感觉？
所以，钱的问题，创业团队一定要有风险意识。
有钱就可以疯狂扩展，但是，一家公司，不是为了占据媒体的头版头条仅仅几个月或者几年，而是为了存活十年甚至几十年、上百年。
风总会停的，如果仅仅是为了在起风的时候闪耀一下，就要做好在风停的时候被摔死的心理准备。
时间和机
如果上述三个问题都搞定了，那么，成功的几率基本在以上。
如果依然没有起来的，那说明：时间还没到，火候还没到，机会还没到。
商业的价值，需要获得用户客户的认可，而这个过程，需要的时间是无法确定的。
即便国产汽车现在已经做得非常好了，然而，由于消费者的心理惯性，许多人依然不愿意花钱冒风险。
抱怨用户有眼无珠不识货，这是没有意义的。因为，企业为用户提供的不是后世才得以认可的艺术品，企业赖以生存的基础是获得足够的当前市场和利润。
艺术家可以不管不顾任何人的意见，坚持自己的风格，以待百年甚至千年之后获得认可；而企业，必须要兼顾长期利益和短期收益，除非投资人或股东有充足的耐心等到长期获利的那一天。
的创业团队本就不该创业
为什么会有的创业企业注定倒闭？因为，的创业团队，要么是合伙人不靠谱，要么是团队不靠谱，要么是风险意识不够，要么是耐心不够，他们本就不该创业！
那么，想创业或者想加入创业团队的各位，你们瞅准了么？
预告
下一期，讨论一下：如何寻找靠谱的合伙人。靠谱的合伙人很难找，但也不能坐那里死等啊，总是可以主动做点什么的。
以上内容来自作者本人公众号【水滴的声音】关注企业文化、团队管理。欢迎关注。  介绍
之所以在机器学习方面具有得天独厚的优势，有以下几点原因：
机器学习算法一般都有很多个步骤迭代计算的过程，机器学习的计算需要在多次迭代后获得足够小的误差或者足够收敛才会停止，迭代时如果使用  的  计算框架，每次计算都要读写磁盘以及任务的启动等工作，这回导致非常大的  和  消耗。而  基于内存的计算模型天生就擅长迭代计算，多个步骤计算直接在内存中完成，只有在必要时才会操作磁盘和网络，所以说  正是机器学习的理想的平台。
从通信的角度讲，如果使用  的  计算框架， 和  之间由于是通过  的方式来进行的通信和传递数据，会导致非常慢的执行速度，而  具有出色而高效的  和  通信系统，通信效率极高。
   是  对常用的机器学习算法的实现库，同时包括相关的测试和数据生成器。 的设计初衷就是为了支持一些迭代的 ，这正好符合很多机器学习算法的特点。 目前支持种常见的机器学习问题 分类、回归、聚类和协同过滤， 在  整个生态系统中的位置如图下图所示。

笔者希望将上述几类算法进行整理，完成   一个系列的算法介绍，供大家一起分享参考，作者才疏学浅，资料里难免出现错误，如有发现请不吝指正，谢谢！作者介绍：黄辉，年毕业于电子科技大学并加入腾讯。目前在腾讯云存储产品团队从事云数据库开发工作，喜欢研究分布式数据库相关技术如：分布式事务，高可用性等。

之前对  与  进行了  类的对比测试，发现同等资源配比条件下， 的性能远好于  ，有部分原因是得益于  本身采用了更高效的算法，比如说做多表  时，采用的是   方式。如果采用同样高效的算法，两者的性能又如何？由于  是由  演变而来，完全采用了  的优化算法，这次，我们将  与  进行对比测试，在同等资源配比条件下，查看  分布式  和单机版  的性能表现。
一目的

比较在同等资源条件下具有分布式属性的  与  在进行  类测试的性能区别。

分析和总结两种  造成性能区别的原因。


二测试环境与配置信息
测试环境：腾讯云
测试对象：、，两者的配置信息统计如下：
表  集群服务器




 
 
 




操作系统
  位
  位
  位



      核
      核
      核


内存





公网带宽











数量





版本
_
_
_



表  服务器



指标
参数




操作系统
  位



      核


内存



公网带宽







版本
 



三测试结果与分析
总测试数据量为时
结果统计信息如下：
表  总量为时各测试表数据量统计



表名称
数据条数





































表  总量为时条执行时间统计



执行的
执行时间单位：秒
执行时间单位：秒



















































































































分析：从以上的表可以看出， 在条  中有条  的执行时间比  少，接近一半的比例，我们直接放大倍的测试数据量进行下一步测试。
总测试数据量为时
结果统计如下：
表  总量为时各测试表数据量统计



表名称
数据条数





































表  总量为时条执行时间统计



执行的
执行时间单位：秒
执行时间单位：秒



















































































































分析：放大数据量到后可以明显看出， 执行测试  的时间大幅度增多，性能下降比较厉害，但仍有条测试  快于  ，我们选取其中一条对比查看下两者的性能区别原因。
这里我们以  为例， 的执行时间大约是  的两倍， 如下：
 图 表示的语句
 在上执行 ，得到结果如下如果看不清楚可以右键另存为图片查看：
图 数据量为时上执行 的结果
对执行进行分析，可以看出，整个过程最耗时的部分如上图红色框部分标识对应的条件查询操作分别是：
在表上对_字段按条件查询，因为在字段有索引，采用了高效的索引查询索引查询分两步：建位图；扫表。详细了解可看的秘密。
和表 操作。
为了方便进一步分析，我们加上参数，获取详细的执行时间，由于内容过多，这里只截取部分重要信息如下：

图 数据量为时上执行  的部分结果
根据以上信息，我们可以得出这两部分操作的具体执行时间，但由于采取多任务并行，因此，我们需要对每步操作计算出一个滞留时间该时间段内系统只执行该步操作，缩短滞留时间可直接提升执行速度，每步的滞留时间为前步的结束时间与该步结束时间之差。两部分的滞留时间分别为：
  =
 =
执行的总时间为，因此，可以印证系统的耗时主要集中在上述两步操作上。
接下来，我们在上执行 ，结果如下：
图 数据量为时上执行 的结果
与不同的是，的耗时多了数据重分布部分。同样，我们通过参数得到详细的执行时间如下：
图 数据量为时上执行  的部分结果
根据执行计划信息，选出耗时最长的三步操作，计算出在一个耗时最长的上这三部分的滞留时间为：
  
 
  
执行的总时间为，可见数据重分布的时间占据了整个执行时间的一半，进行 操作的时间占比也较多，主要是的内存不足，引起了磁盘的。
小结：对比和在的执行计划，的耗时较多的原因主要是数据重分布的大量时间消耗和 时超出内存引起磁盘。虽然各并行扫表节省了时间，但占比较小，对总时间的消耗影响较小。
基于此，是否可以减少数据重分布操作的耗时占比？我们尝试进一步增加测试的数据量，比较的测试数据对于真实的场景还是过少，扩大倍的测试量，继续查看耗时情况是否有所改变。
    总测试数据量为时
表  总量为时各测试表数据量统计



表名称
数据条数





































表  总量为时条执行时间统计



执行的
执行时间单位：秒
执行时间单位：秒



















































































































分析：从结果表可明显看出，在条中，的执行效率都比高出很多，我们还是以为例，查看两种数据量下执行效率不一致的直接原因。
经过对执行计划的分析，发现区别还是集中在步骤提到的几个部分，这里就不再重复给出整体的查询计划，直接查看耗时较多的部分如下：
图 数据量为时上执行  的部分结果
图 数据量为时上执行  的部分结果
的主要滞留时间有：
     
总执行时间为，可见主要的耗时集中在  上
的主要滞留时间有：     
总的执行时间为，相比步骤的测试数据量，数据重分布的耗时占比明显下降，主要耗时已集中在 操作上。
和在执行同样的条件时，扫表的方式不一样，原因在于里的表为列存储，直接扫表更方便更快。
对比两次的测试结果，发现  操作的性能下降比较明显，第一次扫 行用时秒，而第二次扫行用时秒。
小结：增大数据量，会减少数据重分布耗时对整体执行时间的影响比重，主要耗时集中在内部数据的计算上。由于扫表涉及到磁盘，将扫表任务分割给多个同时进行，减少了单个节点要执行的扫表量，相当于并行操作，对整体的性能提升较大。
四总结
通过对不同数据量，，的测试对比以及分析，可以看出，在  类的测试时，数据量越大，  性能越好于单机版的  。由于  采用分布式架构，为了实现各节点并行计算能力，需要在节点间进行广播或者数据重分布，对整体的性能有一定影响，当数据量较小时，计算量小，广播或者重分布耗时占总耗时比例大，影响整体的执行效率，可能会出现  不如单机版  效率高；当数据量较大时，整体计算的量很大，广播或者重分布耗时不再是影响性能的关键因素，分布式属性的在关于复杂语句执行查询效率较高，原因在于，一是多节点同时进行计算 、等，提升计算速度，且可以充分利用系统  资源；二是扫表时，将任务分派到多节点，减少了单个节点的  次数，达到并行  的目的，更适用于  场景。
五其他事项

由于原生的的测试用例不直接支持和，因此需要修改测试脚本，生成新的建表语句如附件中附录一：建表语句 所示，测试如附录二：查询语句。

的数据导入可以使用自带的工具，搭建多个文件服务器并行导入，的个数最好是服务器的倍数，因为是轮询连接到。



相关推荐 简单性能测试与分析是如何做浏览器的性能测试的？：雅虎推出的云数据库基准测试套件刘金明，年硕士毕业加入腾讯，一直在架构平台部从事文件存储服务平台的建设和运营，专注于成本、体验和功能的持续优化。文件存储服务平台目前已接入微云、邮件、腾讯视频、群以及腾讯云对象存储等数万个业务，存储量数百。

腾讯架构平台部研发的分布式文件存储系统自年诞生至今已超过年，存储量突破级别。随着业务的不断发展和演化，针对业务不同的使用场景，定制化开发了多个业务支撑平台。文件存储服务平台就是基于研发的高可用，高稳定，强安全的云端存储服务系统。目前已接入、微云、邮箱、腾讯视频等腾讯内部数百个业务以及腾讯云对象存储服务的数万个客户，存储量数百。
有别于图片平台和视频点播平台对数据格式的深入理解，文件存储服务平台更关注数据的存储和全局分布调度，同时支持全局排重和跨业务转存能力，在保证数据足够安全可靠的情况下做到成本收益最大化，另外平台可支撑任意数量、任意大小和任意格式的数据存入，满足用户丰富的应用场景。

一、全局分布调度
 为了支持海量的存储规模，并解决一些如地震、洪水等不可抗力因素造成的数据安全隐患，平台将数百数据分布在国内外多个机房，任何一个机房都不会成为资源瓶颈。同时平台实现了用户索引和数据的分离存储，用户可根据段来申请上传服务，平台通过直通车将请求定位到路由最近的可服务的机房，并返回给用户匹配的运营商来实际上传上传数据，达到就近上传的效果。其次用户可选择接入分布在全球节点的服务，将极热文件分发到，极大的提升下载体验。

二、秒传、跨业务转存
当我们上传一个电影或者安装包到微云的时候，当我们用邮箱给不同的朋友发送一些材料的时候，当我们想把家人用传送的文件保存到微云的时候，我们发现不管文件有多大，我们都可以在秒级内传完，这是因为平台构建了全局文件信息摘要索引，平台下所有业务可以根据文件摘要信息相互排重和互转，极大提升用户体验且降低存储成本。

三、成本收益最大化
 多级存储：平台提供多种存储级别供用户选择，并提供了配套的级别调整能力。通过家族中的标准存储引擎，低频存储引擎和近线存储引擎，分别实现了线上实时存储的高频存储服务，低频存储服务，以及近线存储服务。高频存储拥有低访问时延和较高的吞吐量，因而适用于有大量热点文件，需要频繁访问数据的业务场景，例如热点视频，移动应用，游戏程序，动态网站等。低频存储拥有较低存储成本和较低访问时延，适用于较低访问频率的业务场景，例如网盘数据，低频档案等。近线存储是拥有极低存储成本的在线存储服务，相比离线存储，近线存储在访问时，无需用户等待，适用于数据访问频率极低但是必要时仍需要在线读取的业务场景，例如较冷的媒体资源，灾难备份数据等。用户可以根据自身的业务场景选择存储级别，同时在使用过程中可以自动或者手动的调整存储级别以适应当前业务场景。
冷热智能调度：往往一个业务的文件可能不只适应一个存储系统，比如邮箱中的附件会随着时间的推移逐渐变冷，腾讯微云中的文件大多数用户备份的文件都极冷，但是也有一些热门电影等热文件存在，通过对各个业务的深入理解，以及大量的数据分析，平台对每种业务采用了不同的调度策略。像微云这种冷数据居多的业务，上传直接选用近线存储，通过平台记录的文件访问次数，当访问频率超出近线存储阈值时，实时调度到低频或者高频存储，同时在数据逐渐变冷后，再调度到近线存储，实现了文件在各个存储引擎之间的智能调度，大大节省了存储成本。

四、多种手段保证数据的安全可靠
数据存储的持久性和可用性：平台分别从磁盘、服务器、集群、机房、跨地域等五个方面进行容灾，使得小到磁盘的某个扇区异常，大到某个机房网络中断甚至遭受如地震等不可抗力因素造成机房销毁时都可以保证用户数据的安全，数据持久性高达个，服务可用性。
保证数据的可销毁性：用户要求删除对象数据时，数据将从内存以及磁盘中删除，并且原磁盘使用空间将会被新的对象数据覆盖，从而实现彻底删除，无法复原。下线的存储服务器报废时，磁盘通过消磁销毁里面的数据。
 保护数据私密性：外部客户接入可通过腾讯云安全平台提供的统一鉴权服务来保证数据的私密性。鉴权服务平台的每条权限记录由用户、操作、条件、资源四部分组成，即说明在什么条件下，谁是否可以对哪条资源做什么类型的操作都由鉴权服务统一控制，从而保证用户数据的私密性，方便用户更智能地分配资源的权限。
 保护数据抵抗攻击：平台提供防盗链功能，用以屏蔽恶意来源的访问，攻击防护和攻击防护，可以过滤恶意攻击数据包，清洗出正常流量。
五、丰富的应用场景
 海量业务存储场场景：平台能够随着用户数据量的增多自动扩容，满足客户海量存储的场景，并且自动选择用户就近节点上传、下载，大幅度缩短了终端上传文件的时间，同时也提高了文件上传的成功率，在腾讯微云业务已经得到了很好的应用。
 大数据计算场景：平台比传统的设备有更充足的带宽支持，避免了访问时延长或者服务不可用的情况出现，并且可根据用户对计算时间的要求，对存储和带宽的规模进行调整，使客户成本收益最大化。
数据备份的场景：前文已经提到，平台提供了一套分级存储的方案，对冷数据存储的场景，客户可选择将数据保存在低频或近线存储中，如此可以在不降低数据持久性的前提之下，为客户提供一个海量低价的空间。
 热点资源的分发下载场景：面对视频点播源，游戏资源等热点文件下发的场景，平台可结合使用，使客户灵活应对大流量和高并发的业务场景，目前已支撑包括腾讯视频、全民歌以及快手、等大流量客户。
视频、图片等云端数据处理场景：用户保存在文件存储服务平台中的视频、图片、文档等数据如需视频转码，图片缩放、识别鉴黄、文档预览等高级处理服务，可通过配套的数据处理服务，同时可选择卡等硬件加速，使得数据无需再下载到用户本地就可以快速、稳定的在云端处理完成。
未来
 架构平台部会继续在家族中追求存储成本的降低，以及功能的极致，体验。近期会推出成本极低的归档存储服务，适用于访问极低的归档类存储场景，如视频监控，医疗档案、数据备份等，进一步丰富存储产品线，使得客户可选择更低的成本存储海量数据，同时更进一步的丰富产品功能，继续加强上传、下载等核心体验，为客户提供更优质的服务。

文章来源公众号：腾讯架构师导语
我将发表一系列关于微服务的文章 从探讨微服务的架构开始 到打造微服务软件架构的工程实践。 期望 能激发起大家对微服务的兴趣与重视。 更期待大家的交流。
前言
经过了半个多世纪的软件开发 所积累到的知识与经验 我们终于构造了可扩展的系统架构 云平台。
然而 在这可扩展的云平台上 我们又该如何打造我们自身的产品软件架构 使得我们的产品软件架构 可充份的运用云平台 而使得我们自身的产品 也能随著外部世界的变化 而扩展、而适应变化。
微服务 提供了一个 架构模式 使得我们得以参考这一架构模式 而去设计一可扩展、可适应变化的产品软件架构。
微服务设计是架构设计。
微服务设计不应是一个讲求标准答案 简单粗暴的设计过程。而应该是一个考量各方因素下的一个决策的过程。
本文
在探讨微服务架构前 我们先来探讨下 所谓的微服务具体应包含哪些核心的概念
   分布式 
微服务与微服务间分布式调用最主要的概念便是    各微服务可各自拥有自身的  ＃ …等等 但 各微服务间却只能藉由单一共同的协议  如  进行分布式的调用。
   分别部署  
微服务架构的产品或许会有数百甚至数千个微服务所构成。所以 部署微服务时 便很难经由手工来完成 而必须相当程度的依赖自动化的  工具。

    服务组件  
微服务是以服务组件 而不是以类或模块的方式体现 每个服务组件会包含一个或多个类或组件。
微服务共分为两大类
         主要是为产品中其他的微服务提供服务 被产品中其他的微服务直接的调用。
如   便是一  的例子 主要是为产品中其他的微服务提供产品登入的服务。
所以   对产品外部的使用者界面、系统、设备都是不可见的 也就是说 产品外部的使用者界面、系统、设备是无法经由   来找到   的。
        主要是为产品外部的使用者界面、系统、设备提供某一端到端业务场景的服务。
所以 相对于     对产品外部的使用者界面、系统、设备而言 都是可见的。也就是说 产品外部的使用者界面、系统、设备是经由   来找到   的。
    边界上下文  
微服务的边界上下文包含
   某一端到端业务场景 功能 。
   数据 数据库 。
微服务的边界上下文 使得每一个微服务拥有各自的某一端到端业务场景 功能与数据 数据库 。
更重要的是 当微服务需调用微服务 则微服务 与微服务的边界上下文 将可避免或降低发生 当微服务 运作失败时 会影响到微服务 。
所以 微服务的边界上下文提供了一个很重要的微服务概念：微服务应能独立各自的开发、测试 并且当发布、部署后 亦不致影响到其他微服务的功能或运作。
      不共享任何事物  
因为 微服务间共享任何的事物 将会造成微服务间的依赖。
所以 微服务间应避免共享任何的事物 如继承结构下的抽象接口 服务 模块  类 数据 数据库…等等。
     
  主要是在微服务与微服务外部的使用者界面、系统或设备之间构建
        隐藏各微服务的 。
当某个新增的场景在某个新的微服务上开发完后 这个新的微服务便会有了新的 。而  便可将此微服务外部的使用者界面、系统或设备导向此新的微服务上的 。使得微服务外部的使用者界面、系统或设备可在不需要有任何修改的情况下 便可以使用此新的微服务。而当微服务外部的使用者界面、系统或设备发现此新的微服务不适用时   便可将微服务外部的使用者界面、系统或设备导向旧的微服务上的  而使得新的微服务 对微服务外部的使用者界面、系统或设备而言 变得不可见。
        多节点间的负载均衡。
  开发新的微服务优于在既有的微服务上不断的加新的场景或功能
当某个微服务开发完后 便应避免不要再在此微服务上 不断的加新的场景或功能 新的场景或功能应该是属于另一个新的微服务。项目简介
通过使用腾讯云多种产品、、、、证书并配合使用知名  系统 ，从无到有打造一个自己在互联网空间中的自留地。
项目架构

内容分发网络、对象存储、云数据库、证书为非必选功能，下文演示环境中将分别讲解完整拓扑模式的配置以及最基础模式的配置仅云服务器。
战前准备

拥有一个已经在腾讯云备案成功的域名

开通一台  机器，并且将、账号、密码记录在一个文档中


战斗开始
教程所使用的机器为腾讯云公共镜像中的   位 版本镜像，并且购买了云硬盘来单独存储业务网站程序，搭建生产环境则使用了  的一键             工具。
首先登录我们的云服务器，更新并添加依赖以及开发者工具
        

 挂载并使用云硬盘作为数据盘使用
 
  


注意：  中需要填入需要自动挂载的云硬盘，  中需要填入需要挂载的位置，因为  默认的数据位置为  所以这里填入  等待脚本执行完毕即可。
下载并使用  的一键  工具搭建生产服务器
      
 
  
 
  



说明：为了安全起见第一步中我把默认的  端口修改为  ，第二步中我选择只安装  服务这里选择的是  的编译版本，第三步中选择安装数据库版本我这里选择的  的稳定版本，如果使用云数据库则不用选择安装数据库服务，第四步中选择安装  的版本这里我选择的是最新的版本，大家可以选择  工具来代替  工具，配置结束之后会有一个重启服务器的选项。
新建并配置虚拟机


说明：使用  命令运行新建虚拟机脚本，第一步选择是否启用  协议如果不需要则输入 ，第二步填入已经备案好的域名，第三步选择是否强制跳转  如果第一步输入了  则此时不会出现这一步，第四步开启  伪静态功能，等待配置完成即可。
新建数据库如果使用云数据库将不用进行此步
使用搭建  环境时选择安装  工具的  账号登录，登录地址为外网例子：，新建一个名为  的数据库，然后再新建一个普通用户  并且把  库的权限赋给他，这里也可以使用  命令操作这一部也是为了让你的数据能更安全，当然最安全的方案还是使用站库分离的方法以及读写分离的方法，站库分离将使用到云数据库。
    ``     

配置并导入使用证书非必须


在控制台的云产品分类中找到 证书管理 ，点击申请证书即可申请一张免费一年的       证书，身份验证选择自助验证，根据给出的提示绑定  记录并等待后台自动验证，申请成功会得到一套证书文件，这里我们选择  环境使用的证书，并且把得到的证书改名为 域名 和 域名 的格式，例如： 和 ，然后再将改名后的证书上传到服务器   中并替换原有文件，最后在终端执行重启  服务命令即可。
  
 配置使用云数据库非必须
云数据库会免费为大家提供一个从库，从而达到主从同步的不间断服务，并且支持  天内任意时间段的回档以及  天内的冷备数据下载，高配版还可以开通只读实例从而实现读写分离，简直是亲民的良心产品，省去了不少维护时间。同样在购买数据库实例之后初始化创建默认  账号的密码，进入控制台建议大家跟自建数据库一样新建一个普通账号来管理单独的数据库文件这个过程在云数据库控制台都可以按照产品说明文档完成。


注意：云服务器要和云数据库选到同一个地域同一可用区下，否则数据是不能互通的哦，但是目前广州一区与广州二区是可以互通的。
下载并安装  程序
 
 
  
 
    
 
  
  
    
    
在浏览器中打开站点  即可进入  安装界面，第一步配置数据库信息，其中  数据库主机 为数据库地址，如果使用本地自建数据库则使用默认  即可，如果使用云数据库则填写数据库的内网点击提交即可。

在下一步中将配置站点信息，密码建议使用自动生成的密码，然后点击安装即可。

说明：第一个  命令进入新建的域名目录这里我用的是 ，  和  命令为修改文件或目录所属的用户和组。

 开启  内容分发功能非必须
由于我们的站点搭建在一台服务器上，他的物理位置是固定的，比如我选购的是北京机房的机器，然而用户在南方深圳访问，那么在这个访问过程中就会有一定的延迟，这时我们就可以选择使用  服务来优化这个过程，同时也可以使用  服务来抵抗源站被  从而造成的网络瘫痪和服务不可用的问题。

说明：缓存配置可参考上图的配置设置，关于强力抵抗  可以参考下图的配置设置阀值的设置可以根据正常访问量调整，如果开启了  则需要在证书管理中添加证书并绑定到域名。

正确合理配置安全组，不给黑客留机会

说明：根据我们之前配置的  端口 ，以及  的  和  端口来配置安全组，同时我们在搭建  环境时，系统默认新建了测试页面在  中的 、、、我们需要删除掉，如果需要使用  切记不要删除  中的  文件夹。
战斗胜利
此时已经完成了从无到有并且安全配置了自己的自留地，剩下的就留给大家自己折腾了，比如书写个人心得、学习笔记等等，大家还可以在  上获取  主题为自己的博客增色。

写在最后
如果您在尝试过程中对文章中有任何不懂的问题可以在文章的底部留言，我会一一回复大家，  ！作者：杨锡坤

消息队列是服务架构中常见的组件，可用于服务间解耦、事件广播、任务异步延迟处理等，本文对于消息队列的实现如何满足几种消费语义进行了阐述。
消息队列组成
● 生产者：负责产生消息
● 消息代理 ：负责存储转发消息转发分为推和拉两种，拉是指主动从 获取消息，推是指 主动将感兴趣的消息推送给
● 消费者：负责消费消息

消息队列的消费语义

消息至多被消费一次

消息至少被消费一次

消息仅被消费一次


为了支持上面种消费语义，可以分个阶段考虑消息队列系统中  、   、  需要满足的条件：
、消息至多被消费一次
该语义是最容易满足的，特点是整个消息队列吞吐量大，实现简单。适合能容忍丢消息，消息重复消费的任务。
●  发送消息到   阶段：  发消息给   ，不要求   对接收到的消息响应确认，  也不用关心   是否收到消息了。
●   存储转发阶段：对   的存储不要求持久性，转发消息时也不用关心  是否真的收到了。
●  消费阶段：  从   中获取到消息后，可以从   删除消息，或   在消息被  拿去消费时删除消息，不用关心  最后对消息的消费情况如何。
、消息至少被消费一次
适合不能容忍丢消息，允许重复消费的任务。
●  发送消息到   阶段： 发消息给   ，   必须响应对消息的确认。
●   存储转发阶段：   必须提供持久性保障，转发消息时，  需要  通知删除消息，才能将消息删除。
●  消费阶段：  从   中获取到消息，必须在消费完成后，  上的消息才能被删除。
、消息仅被消费一次
适合对消息消费情况要求非常高的任务，实现较为复杂。
在这里需要考虑一个问题，就是这里的“仅被消费一次”指的是如下哪种场景：
●   上存储的消息被  仅消费一次
●  上产生的消息被  仅消费一次
  上存储的消息被  仅消费一次场景要求：
●  发送消息到   阶段： 发消息给   ，不要求   对接收到的消息响应确认，  也不用关心   是否收到消息了。
●   存储转发阶段：  必须提供持久性保障，并且每条消息在其消费队列里有唯一标识这个唯一标识可以由  产生，也可以由   产生。
●  消费阶段：  从   中获取到消息后，需要记录下消费的消息标识，以便在后续消费中防止对某个消息重复消费比如  获取到消息，消费完后，还没来得及从   删除消息，就挂了，这样   如果把消息重新加入待消费队列的话，那么这条消息就会被重复消费了。
 上产生的消息被  仅消费一次场景要求：
●  发送消息到   阶段： 发消息给   ，   必须响应对消息的确认，并且  负责为该消息产生唯一标识，以防止  重复消费因为  发消息给   后，由于网络问题没收到   的响应，可能会重发消息给到   。
●  存储转发阶段： 必须提供持久性保障，并且每条消息在其消费队列里有唯一标识这个唯一标识需要由产生。
● 消费阶段： 从   中获取到消息后，需要记录下消费的消息标识，以便在后续消费中防止对某个消息重复消费比如  获取到消息，消费完后，还没来得及从   删除消息，就挂了，这样   如果把消息重新加入待消费队列的话，那么这条消息就会被重复消费了。
结语
现在业内已经有许多成熟的消息队列的实现了，对于选择用哪一个实现，可以先根据业务需要支持的消费语义进行初步筛选，之后再根据运维难度、社区活跃度、性能、可用性等综合考虑选择合适的消息队列系统，如何判断一个消息队列实现是否支持某个消费语义，根据本文中阐述的个阶段去判断即可。

相关推荐腾讯云分布式高可靠消息队列架构腾讯云消息队列在环境下的使用腾讯云消息队列在环境下的使用作者：曹建峰 腾讯研究院高级研究员
 导语： 经过三十多年的发展，在超强运算能力、大数据和持续改进的算法的影响下，人工智能对法律以及法律行业的影响正在加深、加快，未来年法律行业将可能迎来一场巨变。作为法律人工智能最直接的目标客户，法律人需要调整心态，积极拥抱新技术和新模式，并在这个过程中坚持对法律的理念和信仰，防止法律人工智能削弱、损害法律共同体所秉持的以及法律系统所坚持的观念和价值，让法律人工智能来促进司法正义，而非带来偏见和歧视，或者背道而驰、贬损正义。

引言
年月日，在高瞻远瞩的国家人工智能战略《新一代人工智能发展规划》中，国务院向法律行业释放了一些信号。首先，新规划在对人工智能理论、技术和应用作出前瞻布局的同时，还呼吁加强人工智能相关法律、伦理和社会问题研究，建立人工智能法律法规、伦理规范和政策体系。其次，新规划力挺智慧法庭建设，提出促进人工智能在证据收集、案例分析、法律文件阅读与分析中的应用，实现法院审判体系和审判能力智能化。最后，更为前瞻的是，新规划提出“人工智能”复合专业培养新模式，法学赫然在列，法学教育的变革已然箭在弦上。
其实，在年谷歌公司的围棋机器人之后，法律人工智能就被带火了，人工智能和机器人取代律师的报道不绝于报端。以“   ”为检索关键词，谷歌搜索结果超过万条；以“法律人工智能”为检索关键词，百度搜索结果超过万条。但如果追溯起来，人工智能与法律的结合已经有年历史了，始于年在美国波士顿的东北大学举办的首届国际人工智能与法律会议，并最终促成了国际人工智能与法律协会 在年的成立，旨在推动人工智能与法律这一跨学科领域的研究和应用。包括十大主要议题：

法律推理的形式模型；
论证和决策的计算模型；
证据推理的计算模型；
多智能体系统中的法律推理；
自动化的法律文本分类和概括；
从法律数据库和文本中自动提取信息；
针对电子取证和其他法律应用的机器学习和数据挖掘；
概念上的或者基于模型的法律信息检索；
自动化次要、重复性的法律任务的法律机器人；
立法的可执行模型。

在这样的背景下，当前，法律科技正在持续兴起。在人工智能技术的加持下，法律科技更是有望给法律行业带来更深、更彻底的变革。笔者在此前的文章《人工智能法律服务的前景与挑战》中，曾援引法律科技研究报告《文明：不久将来的律所》的观点称，“经过长期的孵化和实验，技术突然可以以惊人的速度向前行进了；在年内，机器人和人工智能将会主导法律实践，也许将给律所带来‘结构性坍塌’，法律服务市场的面貌将大为改观。”研究科技与法律长达多年的英国学者在其著作《明天的律师：预见你的未来》’      中持类似观点，认为法律行业过去年之变化，不及未来年之变化。法律人需要做好迎接未来的准备。
此言并非虚言。法律行业并非对技术具有完全的免疫力。面对技术发展和外在压力，法律行业在教育模式、组织结构、收费模式等诸多方面的不适应性已经显现出来。这让人们开始对人工智能技术支撑下的法律科技寄予厚望。全球来看，虽然从年到年，全球法律科技公司总融资额度仅有亿美元，显著低于金融科技、医疗科技等新兴领域；但是全球法律科技上市公司的数量呈爆发式增长，从年的家增长到了年的家，主要集中在在线法律服务、电子取证、从业管理软件、知识产权商标软件服务、人工智能法律科技、诉讼金融、法律检索、律师推荐、公证工具等九大领域。在这样的国际趋势下，国内法律科技市场开始从“互联网法律”向“人工智能法律”转变，法律人工智能创业成为人工智能创业的重要组成部分，面向端或者端的法律人工智能产品逐步进入公众视野。
不仅如此，法律行业如律所、公司法务部门、法院等也开始积极布局人工智能法律科技，部分原因是在线法律服务、客户成本压力比如公司法务部门日益希望以更低的成本获得更多的法律服务等因素迫使律所投资创新。国际律所是典型代表，其在年月率先启动法律科技创新加速器项目 ，目前已经孵化了包括大名鼎鼎的机器人律师在内的多个法律科技项目。其他越来越多的国际律所如、 、等亦开始研发、部署法律人工智能系统，帮助提高工作效率，或者以低成本模式提供法律服务。
一言以蔽之，从最早的基于规则的的专家法律系统将法律专家的法律知识、经验等以规则的形式转变成为计算机语言，到以深度学习、机器学习、大数据等为支撑的自主系统，人工智能对法律以及法律行业的更深更广的影响才刚刚开始。可以说，人工智能技术已经在开始改造整个法律行业，而改造的规模和速度将不仅仅取决于技术发展和进步的步伐，而且取决于整个法律共同体对于新技术和新模式的接纳程度，而这需要政策支持和发展导向。笔者在过去一些观察和研究的基础上，尝试对人工智能在法律行业中的应用和影响总结出以下十大趋势。
一、智能化、自动化的法律检索将深刻影响法律人进行法律研究检索的方式
在人工智能技术的加持下，法律研究检索正向智能化、自动化的方向迈进。法律研究 对于法律人的价值不言而喻，无论你是法学院学生，还是从业律师、公司法务，抑或司法人员，甚至普通民众有时候也需要进行法律检索。其实，信息化已经对法律检索进行过了一次改造，法律文本、裁判文书等法律资料的数字化，支撑起了市场规模巨大的法律数据库市场。但、北大法宝等法律数据库服务一般基于传统的关键词检索，利用这些数据库进行法律检索，是一件费时费力的苦差事。然而，基于自然语言处理和深度学习的语义检索和法律问答已经在开始改造传统的法律检索服务。比如，号称世界首个机器人律师的就是基于的系统的智能检索工具，利用强大的自然语言处理和机器学习技术向律师呈现最相关、最有价值的法律回答，而非像传统法律数据库那样，仅仅呈现一大堆检索结果。此外，语义技术，文本分析和自然语言处理，以及图像和视频技术已经为商标和专利检索以及版权监测等知识产权法律工作的自动化提供了可能性，比如。
新形式的、基于语音交互的智能法律检索将经历两个阶段。第一个阶段是智能化；在这个阶段，依然需要人类律师明确需要解决或者回答的法律问题是什么，法律搜索引擎识别相关案例并评估其价值，形成专业回答。是这一阶段智能法律检索的典型代表。第二个阶段是自动化，意味着不需要人类律师指明法律问题是什么，系统自身可以理解一段事实陈述并自动识别其中的法律问题，然后完成检索并提供最佳法律信息，整个过程几乎不需要人类律师的深度参与。这几乎是将人类律师从繁琐的法律检索工作中解脱了出来。
二、人工智能将持续推动法律文件自动化
就像新闻写作机器人的崛起将给新闻业带来一场巨变一样，法律文件自动化趋势将可能给法律行业带来规模相当甚至更深远的变化。主要包含两个层次。
第一个层次是法律文件审阅自动化。无论是调查取证、尽职调查，还是合同分析、合规审查，都需要对法律文件进行审查、分析和研究。自动化这一工作将能够显著提升法律人的工作效率。以电子取证为例，在并购、反垄断、大型劳动纠纷等越来越多的案件中，庞大的电子材料给证据和法律材料的搜集和整理提出巨大挑战，律所往往需要投入大量的人力和物力，而且需要耗费大量时间。但基于、技术辅助审阅、机器学习、预测性编程 等技术的电子取证程序可以显著提高这一工作的效率，大大节约审阅文书的时间，而且准确性不输人类律师，因此成为了法律科技市场的一大细分领域，微软等公司都已介入。电子取证的步骤一般包括训练过程人类律师从小量样本中确认相关的证据材料以供机器学习和取证过程意味着机器代替人类律师进行资料审阅以发现证据材料。由于涉及到用机器替代律师，可能触及政策障碍，因此英国、 美国、澳大利亚等国家的法院已经明确表示在诉讼和案件中整理、搜集证据材料时可以利用预测性编程技术。
法律文件审阅自动化的另一个主要领域是合同分析。合同分析在风控、尽职调查、取证、诉讼等诸多场合具有重大意义，但是一项耗时耗力的工作。然而，德勤借助机器学习合同分析系统 ，只要分钟就可以读完原本需要人类律师花费个小时才能审阅完的合同。在国际社会，人工智能合同分析服务已经蔚然成风，、、 、、等提供智能合同服务的法律科技公司越来越多，在人工智能技术的驱动下，依然在蓬勃发展，带来效率的提高、成本的降低以及流程的改善。
第二个层次是法律文件生成自动化。新闻业正在被互联网和机器写作改造，过去年，新闻业收入减少了，就业岗位减少了万个，报纸的市场价值和支配力大减，代之以网络媒体的不断兴起。法律行业正面临着同样的情况，智能机器辅助甚至独立起草法律文件的时代将会到来。如今，法律人使用法律格式的方式正从模板向法律格式文件自动生成转变；也许未来年，人工智能系统将可能起草大部分的交易文件和法律文件甚至起诉书、备忘录和判决书，律师的角色将从起草者变成审校者。比如，硅谷一家律所  开发的一个程序可以为准备上市的创业公司自动生成所需文件，这将律师的账单时间从小时减少到了几个小时，当需要准备大量文件的时候，这一程序可以使所需时间从数天、数周减少到数小时，大大提高了工作效率。机器智能的优势在于随着数据的积累，可以不断自我学习和改进，并且由于数据的互相关联性，计算机可以将特定合同与所有与之相关的法院判决关联起来，形成持续改进法律格式的动态关系。未来，随着软硬件能以及算法的持续提高，起诉书、备忘录、判决书等高级法律文件也可以自动生成，但依然需要人类律师或者法官审阅，形成人机协作的关系。
三、在线法律服务、机器人法律服务等替代性商业模式  不断涌现，使得法律服务的提供日益标准化、商品化、自动化、民主化
在互联网时代和人工智能时代，律所和人类律师并非普通公众获取法律服务的唯一渠道。在线法律服务、机器人法律服务等替代性商业模式正在兴起，可以直接向终端用户提供一般法律咨询服务，比如遗嘱、婚姻咨询、交通事故咨询，等等。面向终端消费者的法律机器人就可以协助用户自主完成对交通罚单的申诉材料准备和提交工作。
美国法官波斯纳曾将法律行业形容为“涉及社会的法律的服务提供者的一个卡特尔”，意即是一个垄断的行业。高昂的律师费用导致社会中存在大量未被满足的法律需求，低收入以及中等收入人群中的大部分人的法律需求没有被满足。然而，在线法律服务、机器人法律服务等替代性商业模式可以以更低廉的价格向终端用户提供法律服务，有望使法律服务标准化、商品化、自动化、民主化。商品化意味着法律服务的提供不再主要依赖于特定的人类律师的专业素养，而可以以自动化的方式提供；民主化意味着大部分人将可以以较低成本获得一般的法律服务。英国学者认为，法律服务的提供的演进方向从定制化到标准化到系统化再到一揽子最后到商品化，意味着法律服务定价的由高而低，即从按小时计费到固定收费再到商品化定价最后趋于零。在这个层面上，国外有专家预言律师将走向没落。
无论如何，法律机器人都将对法律服务的提供产生深远影响，将持续推动法律服务走向标准化、系统化、商品化、自动化，使人人都可以获得法律服务，帮助消除法律资源不对称的问题，实现更为广泛的司法正义。如今，在美国，最知名的法律品牌不是哪一家知名律所，而是之类的在线法律服务提供商，这些新型的技术派的法律服务商代表着法律服务提供的未来趋势。它们对于律所而言并非替代者的角色，而是在律所之外，满足其他未被满足的法律需求或者通过律所就会十分昂贵的法律需求。而英国早在年就通过了《法律服务法案》，旨在自由化法律市场，革新法律行业组织模式，并引入竞争，促进法律服务的可负担性。在此背景下，一些国际律所已经设立了低廉的法律服务中心，在按小时计费、固定收费等模式之外，借助技术以更低价格提供法律服务。
四、基于人工智能和大数据的案件预测将深刻影响当事人的诉讼行为和法律纠纷的解决
从案件结果预测到犯罪预测，基于人工智能和大数据的预测性技术在司法领域的应用越来越广泛。一方面，案件预测技术在研究上取得进展。年，研究人员利用欧洲人权法院公开的判决书训练算法系统，构建了模型，来预测案件判决结果，预测准确性达到了；这一实证研究表明，案件事实是最重要的预测因素，这一结论与法律形式主义的观点一致，即司法裁判主要受案件事实的陈述影响。另一方面，案件预测已经用在了诸多实务领域。比如，  公司提供的服务，通过对成千上万份判决书进行自然语言处理，来预测案件结果，比如，其软件可以确定哪位法官倾向于支持原告，基于对方律师过去处理的案件来形成相应的诉讼策略，针对某个特定法院或者法官形成最有效的法律论证，等等。 的技术已经用在了专利案件中。
案件预测的价值主要体现在两个方面，一方面可以帮助当事人形成最佳的诉讼策略，从而节约诉讼成本；另一方面，可以帮助法官实现同案同判，也即所谓的大数据司法确保公平正义。诉讼中可能的高昂成本可能给当事人带来沉重经济负担，所以当事人一般都会在案件起诉前或者上诉前对案件胜诉可能性进行评估。但即使是最专业的律师，由于受限于人脑自身的信息处理能力，在预测上远不如计算机，因为计算机在强大算法的支持下，可以以超强的运算能力，处理几乎可以获取的所有数据。计算机的全数据处理，相比人类的样本数据分析，使得案件预测结果更为可靠。如果事先可以较为可靠地预知案件结果，意味着当事人不会冒着极大的败诉风险继续推进诉讼或者上诉，而是会选择和解、放弃诉讼等其他纠纷解决方式。但案件预测的弊端在于可能扭曲当事人的诉讼行为，带来新的偏见比如算法歧视，参见拙文《人工智能——机器歧视及应对之策》和滥用。
五、在线法院 ，以及人工智能法律援助，将促进司法可得性  ，帮助消除司法鸿沟 
俗话说，法院大门朝南开，有理没钱别进来。司法审判系统的低效率、程序拖沓、成本高昂等问题历来为人们所诟病。但问题是，人们为了解决彼此之间的法律纠纷，一定得去有实体场所的法院吗？技术的发展已经给出了否定的回答。比如，伴随着电子商务的兴起和繁荣，在线争议解决机制  ，简称开始流行，在电子商务上，大量买卖纠纷通过这一服务商在线解决，当事人通过系统在线提交事实陈述和证据，使纠纷在线得到处理，甚至不需要人类律师介入，很多案件也根本不会进入法院审判阶段。
在模式的影响下，在线法院的实践在国外已经出现。比如，英格兰和威尔士上诉法院大法官在呼吁“提高民事司法的效率”时表示，“可以借助使用人工智能来在线裁决英格兰和威尔士的民事法律案件，在这方面，人工智能可以辅助法官，甚至作出判决。”据悉，英国已经投入亿英镑现代化、数字化其法院系统。根据英国学者的观点，英国的在线法院包括三个阶段：第一阶段是在线法律援助系统，向当事人提供法律咨询和建议等；第二阶段是审判前争议解决，法官通过邮电、电话等方式和当事人沟通，以解决纠纷；第三阶段即在线法庭，只适用于小额案件，以在线的方式审判案件，包括立案、提交证据、举证质证、裁判等。这类似于简易诉讼程序。英国当前的在线法院建设并没有利用人工智能系统来裁判案件，因此并非代替法官，而是以更好的方式解决纠纷。在交往场景日益数字化的背景下，在线身份识别、音视频技术以及人工智能技术等已经为在线法院的建设提供了技术支持。
中国正在大力推动的智慧法院与国外的在线法院类似。年月发布的《国家信息化发展战略纲要》将建设“智慧法院”列入国家信息化发展战略，明确提出：“建设智慧法院，提高案件受理、审判、执行、监督等各环节信息化水平，推动执法司法信息公开，促进司法公平正义。”年月发布的《“十三五”国家信息化规划》，明确指出，支持“智慧法院”建设，推行电子诉讼，建设完善公正司法信息化工程。在年月日举行的全国法院第四次信息化工作会议上，最高法院院长周强提出，智慧法院是建立在信息化基础上人民法院工作的一种形态。中国各地的法院都在探索某种形式的智慧法院建设，但以浙江智慧法院浙江法院电子商务网上法庭建设最为出名；据浙江高院信息中心副主任刘克勤介绍，浙江智慧法院每年处理的交易、著作权等纠纷多达万件，可以直接对接淘宝、天猫等多个平台，提供在线矛盾纠纷多元化解决平台，其他辅助措施包括案件结果预判、网上司法拍卖、智能语音识别、类案推送、当事人信用画像，等等。年月日，中央深改小组审议通过《关于设立杭州互联网法院的方案》，该互联网法院主要审理网络购物合同纠纷、网络购物产品责任纠纷、网络服务合同纠纷、在互联网上签订、履行的金融借款合同纠纷和小额贷款合同纠纷、网络著作纠纷等五类案件。未来，在线法院的进一步建设和普及将促进公共法律服务的供给，帮助消除司法鸿沟。
此外，公共法律服务中的法律援助不足也是司法体系的一大问题，尤其是在刑事案件中，很多被告人得不到法律咨询和辩护。一些民事案件同样是在没有律师介入的情况下进行的。未来，法律机器人可以向当事人提供基本的法律援助，而法律援助律师仅在必要时才介入，这可以显著提高司法援助的效率和质量，实现公平正义。而且，法律机器人法律援助同样可以融入在线法院的建设当中。
接《法律人工智能十大趋势下》前言
通常情况下我们是用的都是的路径，对于的使用也很少，但是随着的普及越来越多的域名访问需要用到的，现在给大家一个教程关于对一个的网站进行访问时候自动跳转至。
项目简介
通过使用腾讯云产品、证书给网站部署安全证书并实现全站安全访问。
准备
购买一台腾讯云拥有一个已经在腾讯云备案成功的域名。
演示环境
系统：软件：，的 重写模块
操作步骤：
、给已备案的域名申请证书并下载到服务器

这里我们使用环境，所以选择文件夹中的证书文件

、打开信息服务管理器部署证书并绑定域名、开放并绑定端口
首先导入证书


接下来绑定的端口

、我们需要下载并在中安装 重写模块
下载地址：=

下载安装后我们重启，再打开后会发现在功能视图中又多出了个重写的功能

、对站点进行域名绑定
我们需要将和绑定在需要的站点上

、进程设置
在要求的选择前取消勾选

、在中新建规则
新建一个空白规则，让的访问跳转到上


起一个名字例如   
模式：
添加条件：{} 模式： 或 

在操作设置中选择重定向：{_}{}重定向类型：已找到 或 参阅其它

、测试


相关推荐
【腾讯云的种玩法】个人网站如何开启？
浅析与原理
【腾讯】从抓包开始学习排行榜满足了人的攀比、炫耀心理，几乎每个产品都会涉及。增值产品部的会员、动漫、企鹅电竞、游戏赛事等大量业务都对排行榜有强烈需求，特别是企鹅电竞等业务的发展壮大对我们排行榜系统提出了更多要求和挑战。在过去的一年中，排行榜系统从无到有，接入的业务从单一的会员到企鹅电竞动漫等几个各类业务，接入的排行榜数实现了从几个到数万的突破，单个排行榜用户数最大万 排行榜存储集群活跃用户量数亿，而在这过程中，排行榜系统也遇到了以下挑战：

如何支持业务就近接入？低延时

如何支撑数万乃至几十万级排行榜自动化申请调度？

如何降低机器成本？选择合适存储引擎？

如何避免各业务资源抢占，相互影响？


接下来的各小节会详细讨论目前我们在实践中是如何解决这些挑战的。

一排行榜系统基本架构
在讨论我们如何解决面对的挑战之前，先简单了解下排行榜系统基本架构、以及业务是如何接入、使用排行榜系统的。排行榜系统基本架构如图三所示，当前的排行榜系统架构不是设计出来的，而是根据我们业务场景、需求、发展等不断演化，不断优化而形成，其主要由以下几个服务组成：

接入服务无状态，提供访问修改排行榜数据的所有接口给业务使用，如查询名次、等

存储服务有状态，主备部署，排行榜数据存储

服务提供申请排行榜、业务接入、排行榜配置信息、存储机容量等接口

调度服务从存储机中筛选满足业务申请条件的存储机，并择优分配

上报存储机容量信息、存储服务监控数据等

排行榜路由数据存储、存储机容量数据存储等，为什么我们选择将在第三部分说明

业务接入信息、各排行榜配置、用户量、存储服务核心参数监控等存储


业务接入排行榜系统时，首先会为每个业务分配一个，其次需要申请排行榜，业务排行榜通过调用排行榜系统的接入服务，接入服务每个接口都包含业务、排行榜，接入服务通过业务、排行榜查询获取该业务排行榜的存储服务实例，最终通过存储服务操作排行榜数据，返回结果给业务。
上面提到的是什么呢  ，代指，即的可用性是一套兼具负载均衡和过载保护的容错系统 业务服务接入时，会分配一个标识、，此标识映射若干业务服务器，业务机器需要部署  最大的缺点是业务服务若要通过调用被调 就必须修改代码，每次网络调用之前都需要通过  获取被调调用结束之后上报调用延时、返回码等。

二如何支持业务就近接入？低延时
因部门产品业务较多服务部署区域也各异，有的业务部署在深圳地区、有的业务部署在上海地区。深圳、上海内网机房延时约 这么高的延时是部分业务无法容忍的，作为平台支撑方，我们也希望提供的各接口平均延时应在内，所以要尽量避免跨城访问。如何避免跨城访问呢 当然是各区域自治，早期因接入业务、排行榜数都较少只有接入服务、存储服务机器是按地区部署的，排行榜路由数据存储只部署在深圳，排行榜路由也只会在没命中的情况下才会跨城查询深圳的路由数据存储集群，当时延时也能满足业务需求 因此我们并未完全支持业务就近接入。但是后面随着各类业务快速接入、排行榜的快速增加，特别是当失效时，上海地区服务质量、延时波动较大，频繁告警，于是我们不得不推进各区域全面自治方案。
业务场景决定着我们选择什么存储方案来解决跨城访问导致的高延时问题。
简单分析下我们的业务场景业务核心链路请求

存储的是什么数据 数据量多大  路由、存储节点容量数据预计几十万条、长度较小当然也可以采用表结构存储

读写比例 读为主极少量写每分钟几个申请排行榜时才会添加路由配置

如何取舍 尽量保证各区域数据一致性不丢失数据，高可用性如其中一节点宕机不影响服务读，在出现网络分区时如深圳、上海网络中断，集群少数成员一方上海地区，能够降级提供只读模式。


常用的开源解决方案，以及各方案的优势、不足如下



存储
原理
优势
不足





 
稳定性、友好的接口、可根据业务场景需要配置复制模式
系统可用性不如、




强一致性、高可用、
较成熟等大型项目应用广泛，但是目前还处在快速发展中，团队内暂未在生产环境应用




高可用、高性能读、团队已在生产环境应用多年、有配套的配置系统
部署维护、 使用等相比不够友好



结合以上各解决方案优缺点，再根据我们的业务场景需求，我们选择了作为核心的路由、存储节点容量数据存储，然后我们还面临着深圳、上海各部署一套还是只部署一套的选择。若深圳、上海各部署一套，我们的方案是深圳集群为主写，主写成功后，  可以写入，需支持 语义 由消费者异步写入上海集群，因为都是幂等性接口，对于网络波动、中断等消费者写入上海集群失败的情况下，可以无限重试，确保两集群数据最终一致性。但是鉴于我们业务场景极低的写请求，以及当出现网络分区时，上海地区集群可以开启   同时我们还有   等，我们最终选择了部署一套 在生产环境中我们部署了台节点分布在深圳、上海个，通过本身的算法实现深圳、上海地区数据同步，各区域实现完全自治，整体部署方案见图四，部署之后业务调用延时见图五低于。


三如何支撑数万乃至百万级排行榜申请
和区域自治的低延时部署方案类似 当前的调度系统也是排行榜的申请流程的不断优化衍变而来，排行榜的申请可分为以下三个时期

石器时代 系统刚上线时，几个排行榜，手动配置。

青铜时代 几十个排行榜，通过界面人工审批排行榜。

铁器时代 数万个排行榜，通过调度服务筛选、打分选择最优的存储机，自动化容量规划，无需人工干预


如上所述，排行榜系统提供了两种申请排行榜方法，一种是在管理平台提交申请单，一种是通过 提供的实时申请排行榜，前者试用于排行榜数申请不频繁的业务场景，后者适用于需要大量排行榜的业务场景。
那么我们又是如何设计实现调度服务的呢？ 通过分析我们的业务场景，业务在申请排行榜时一般需要填写部署地区深圳、上海、预计用户量、请求量、排行榜类型、是否容器部署、存储引擎类型等条件参数，因此排行榜调度服务的核心职责就是从有效的存储节点中筛选出满足业务申请条件的候选节点，并按某种策略对候选节点进行评分，选择最优分数节点分配。
基于以上业务场景，我们设计实现了调度服务，调度服务流程如图六所示，由两部分组成，筛选和打分，筛选模块会根据配置运行一系列模块，比如健康检查模块、标签匹配模块、容量检查匹配模块。健康检查模块会检查所有候选节点的存活性，存活性通过的临时节点来判断，当一台机器挂掉时，临时节点会自动删除。标签匹配模块非常灵活，提供了强大的筛选能力，比如筛选部署地区、实体机部署还是容器部署、存储引擎类型等等。容量匹配模块检查候选节点是否容量满、剩余容量是否能支撑当前排行榜等，那么一个若干内存的容器能支撑多少排行榜呢？
首先一个容器总容量能支撑多少用户量，我们可以根据线上数据，计算出一个经验值作为上限，其次，容量规划目前我们采用两种策略一种是  适合业务能较精准预测排行榜的用户量，若业务指定这种资源分配就会实际预分配指定的用户量， 另外一种是 业务无法预测排行榜用户量调度服务会根据此业务历史排行榜用户量计算一个平均值，若平均值低于该业务配置的最低用户量阀值，就预分配阀值，默认我们采用这种策略。通过以上过滤模块筛选后的候选节点就会进入下一轮的评分模块，评分模块支持多种调度算法，如最小资源调度选择内存资源剩余最多的节点、多权重混合调度根据用户申请参数，、赋予不同的权重，排行榜最终被调度到节点将是评分最高的节点。调度数据存储保存在各个存储机都部署了 定时上报存储机容量信息到集群。


四如何降低机器成本？选择合适存储引擎？
 选择什么样的存储引擎来存储排行榜数据 我们分析下排行榜的基本操作查询用户名次分数更新用户名次，查询前若干名删除用户等，有些业务需要用到全部这些接口，有些业务只需要用到其中部分接口比如更新用户分数、获取前若干名。我们可选的存储引擎有内存型存储磁盘型存储等，提供了多种丰富的数据结构，其中的 能完全满足我们各接口需求 的核心数据结构是哈希表跳跃表，其中哈希表保存各个用户的分数，跳跃表维护各个分数对应的排名，增加用户分数和查询用户排名的时间复杂度都是，因此适合对性能要求较高的业务使用。而、只提供了、型接口，为什么也可以在部分业务场景无需查询用户名次也可以使用呢 图八是架构，从图中可知 是都是有序存储的，就是通过将分数通过一定规则编码也作为一个写入以支持 数据结构，不过的查询排名时间复杂度是在生产环境中仅适合不查询用户排名的业务使用，但可以支持查询整个排行榜前名一般小于等于。

因此降低成本第一个方法就是根据各业务特点、类型按需选择合适的存储引擎！ 不需要查询名次的业务可以使用磁盘性存储引擎！
再看降低成本第二个方法，随着排行榜数越来越多，排行榜存储机也逐渐增多，存储机器资源紧张，申请周期长，成本也较高，通过分析线上存量排行榜，发现部分业务具有明显的周期性，如各类业务的活动、赛事排行榜等上线推广时流量较大，活动结束时几乎无流量访问但是又不能清空整个排行榜，对于这类业务，排行榜系统提供了冷热分离机制，将冷数据从内存中迁移到的硬盘中，从而释放宝贵的内存资源，提高机器资源使用率，节省成本。
数据冷热分离方案如图九所示，通过采集现网所有排行榜流量，每日定时分析是否有排行榜满足迁移策略如排行榜用户数大于万，近两周流量小于某阀值等，若满足策略，就生成迁移任务，记录迁移的排行榜一系列元数据信息，写入。迁移服务轮询若发现有迁移任务就开始迁移工作，将全量排行榜数据备份到存储节点，缩容或清空现网排行榜数据，释放内存资源，图十是冷数据、热数据占比分析，冷数据占比高达。


五如何避免各业务资源抢占，相互影响？
越来越多的业务接入同时，各业务排行榜之前资源争夺、相互影响成了一个不可忽视的问题，比如上海地区某业务排行榜申请了大量排行榜，触发上海地区存储机资源容量限制，所有业务申请上海地区的排行榜都失败。为了解决各业务之间相互影响，排行榜系统实现了业务资源配额、资源隔离方案。排行榜资源隔离容器方案如图十一所示，容器引擎使用了 网络模式使用了模式，没有性能损失，简单可控，数据卷使用主机映射，容器重启、宕机数据都不丢失，后续也将测试使用分布式文件系统 镜像存储驱动选择公司操作系统自带的 不适合对容器内的文件进行频繁写操作首次写需要 和多层检索开销 而我们的业务场景对容器镜像文件读写操作都极少，也将最大程度避免存储镜像的潜在的内核，各种镜像存储驱动优缺点对比见图十二。
使用公司内部的通用仓库 使用内部团队维护的 使用内部维护版本的好处是经过了公司大量其他业务的应用，相比最新版本而言比较稳定，同时对于我们遇到的一些、需求功能，反馈给团队之后，他们也会较快修复、合并新版本中我们需要的功能。比如我们之前遇到的两个  ，在内部版本中都较快解决或避免了。
        
     


图十二 存储镜像驱动优缺点引用官方
相比之前的混合部署，容器方案推出后，各业务接入时需要简单估算此业务未来排行榜总用户量数，预计需要的资源量，调度服务通过一定的策略从容器存储节点中，筛选一个最优的节点，动态创建一个若干的容器分配给此业务使用，后续此业务下所有排行榜将调度到该容器，若容器资源不够，一方面可以在线提高容器资源大小，另一方面可以新增容器，一业务对应多容器。
最后总结下 资源隔离方案的优缺点。
优点

各业务资源隔离，通过限制各业务使用的内存、等资源，同时可以根据业务最终数据量、请求量在线动态调整资源大小。

简化部署，一个镜像，任意一台存储机器，简单快速起多个容器，充分利用多核机器的资源，各业务相互隔离。

提高机器资源利用率。之前实体机一主一备模式，备机负载很低，容器化部署后，各容器主备可混合部署在一台机器上，调度时只需保证主备容器不在同一台机器。


缺点

所有容器进程共享同一个内核空间若某容器触发内核，将导致内核崩溃，影响机器上所有容器进程，因此在生产环境实践上应吸收业界的最佳实践经验，主备容器数据热同步，定时备份数据，加强监控、容灾能力。

低版本的  退出后将导致所有容器进程死亡，版本增加了参数，若指定此参数， 关闭后容器进程将继续运行，  。


六总结
 在解决以上问题的过程中，排行榜系统逐步实现了一套较高可用性、低延迟、低成本的排行榜解决方案涵盖自动接入、调度、容灾、资源隔离、监控、扩缩容、数据冷热分离等，后续将加强系统自愈能力的建设，比如对于写流量不大的主备实例的全自动切换对于写流量较大的实例因是异步复制__与 存在几十万的差异，还有数据卷使用 即便出现主备容器都挂，通过系统监控探测到后，可以动态创建新容器、挂载数据卷，重建实例等，更重要的是要支持实现排行榜级别的在线迁移。

文章来自公众号：小时光茶社 


相关推荐系统架构评审方法和思路总结微信支付商户系统架构背后的故事技术体系
技术体系整理

其中绿色底色的代表中表现出的能力比较成熟，可以直接应用。
脑图地址：=
 兼容性
 的兼容性，可以认为是其用到两大核心技术的兼容性：


：

案例分析
公司的王者荣耀貂蝉广告， 《前端也能做的互动》
实际上就是一个基于渲染模型，并自行基于实现空间定位的一个应用。效果类似的是的空间定位功能，下面的中有提供。
其开发模式为：
开发  

开发导出貂蝉游戏人物模型

开发人物皮肤贴图纹理

开发模型动画

使用软件导出支持的模型格式这里看似简单，实际有大坑，不同的模型、骨骼、贴图、动画，导出时会有不同问题，还要控制模型资源大小，不能过大


前端开发

·         全景场景不支持设备柔性降级

·         空间定位开发

·         模型渲染

·         交互与动画控制

·         终端适配


业界相关的库及
整理了部分：

的版本，支持 和 的识别与跟踪，配合可渲染模型，目前的问题是 跟踪的帧率不高。
的项目地址为：
识别
___
效果较好：

识别
__
 
基于实现了图片识别，并封装了空间定位能力，提供了设备体验版本的。
的项目地址为：
识别
_

空间定位
此需要在手机中打开
_

结合 
暂未调研
结合体验仪器的体验 、体感外设
暂未调研
 
亮点功能在人脸和手势识别跟踪方面的表现，且能识别、跟踪人脸五官。
的项目地址：
人脸、五官识别
该提供了人脸识别能力嘴巴、眼睛、鼻子，从图片识别：
_
 
识别跟踪
_
从效果来看，该库是 中少有的人脸识别跟踪效果较好，且帧率较高的库。下面的中可以选择一款眼镜，识别到人脸后把眼镜放在眼部并跟踪。

另外，  这是一个基于的人脸识别插件，可以识别图片和视频中的人脸，没有提供摄像头帧实时识别的，估计是此插件计算性能应该跟不上，帧率不会高。
性能
自称人脸识别方面能力和效果秒杀其他库：



    
  







  
  
  



  
  
  



  
  
  


  
  
  
  



  
  
  



手势控制模型
用手势控制 模型的姿态，可以控制，但是效果不佳，有点莫名其妙的意思。
__

手势翻页
用手势控制网页翻页，手在镜头下部时向下翻页，在镜头上部时向上翻页，点红框内链接开始。
__

 
提供了人脸识别的能力，但是在浏览器里边表现不佳。另外，这个库还提供了显示识别特征点等能力。
的项目地址为：
的 列表：_
__
人脸姿态  帧率不高  

 
支持在中运行神经网络功能，该项目提供了一些示例模型的演示。
如果能有一套成熟的方案把这个库包装一下用起来，意义还是挺大的：将图片识别的工作放在浏览器中完成，可以节省大量的网络流量和服务器资源。
但是目前浏览器中做识别由于性能原因，识别耗时较长，不能太过频繁的识别。
项目地址：
 其他


基于的人脸识别

帧率并不高，没有深入看

暂未研究
  
暂未研究
总结
目前 业界已经有了一定的技术积累，但是还没有达到成熟可用的地步，用一句话概括一下：底层识别能力弱，上层渲染能力强。
底层能力
识别方面，的模式识别跟踪效果不错，但是识别速度慢，且卡顿，无法达到可以应用的地步。
人脸识别方面，的表现还算不错，可以识别、跟踪人脸以及五官位置，据观察应该是只支持坐标的识别，不支持姿态的识别。
手势识别方面，支持手势识别能力，根据其提供的来看，识别是可以识别，但是不够稳定，经常识别丢，难以在现实项目中应用。
图像识别方面，之前经哥介绍看了下这个神经网络的项目，目前是官方的可以跑起来，但是我们自己训练的模型跑出来结果不对。
上层渲染
模型渲染，目前看到的中主流模型渲染方式是，做 方面的开发，无论底层能力采用何种方案，都是必须系统学习一下的。
模型开发，需要专业的开发工程师来开发模型、贴图以及动画，涉及到、等软件的学习。
模型导出，模型要让能够使用，需要导出成特定格式，导出的过程中因模型、动画的不同，会有一些坑。另外资源大小的优化、压缩也是一个问题。今天你敏捷了没有？“敏捷”在互联网和软件开发领域从涓涓细流逐渐演变为行业潮流，往小了说是改进了开发方法，往大了说是革了瀑布流式的命——把产品开发引向了快速迭代、小步快跑的路线上。
我们使用  写 ，流转、跟踪任务，言必谈敏捷，然而我们是否真的走对了敏捷？注： 是腾讯内部的敏捷项目管理系统 。
朋友，你听说过敏捷么？
离开敏捷工具，我们怎么敏？
设计也要介入敏捷流程？
敏捷跟文档是对立的？
我这有个几百亿的大项目，怎么敏？
尽信书，不如无书。
一、朋友，你听说过敏捷么？
程序员说，要有敏捷
从敏捷的滥觞看去，比起方法，这玩意貌似更像一个宗教笑。
千禧之初，美国在计算机行业已经走了几十年，瀑布流、螺旋模型、快速迭代各种各样的软件开发流程雨后春笋各领风骚一段时间。虽然不断变化和完善，但互联网的加速发展让传统方法显得笨重，难以快速适应变化。有十七个程序员程序员改变世界在美国犹他州的一个风景区开了个碰头会，找到了一个团队耦合度高，流程极其灵活的方法，他们把它称为  。

这十七个人如同开宗立派的长老，在会议之后给自己起了个名字“敏捷联盟”，他们不仅赋予了新方法名字，还有宣言，甚至纲领。

盐湖城 敏捷联盟成立地——雪鸟滑雪场

中文版的“敏捷宣言”。在建立于年月的 《    》里你可以找到几十种语言的“敏捷宣言”。
另外，长老们还制定了原则，作为福音传播。

显而易见，敏捷是绝对的结果导向，去文档化，去流程化，高效沟通和合作是究极奥义。
看起来是个很不错的方法，文档不重要了，流程不重要了，大家聚在一起说一说就可以了不是吗？太棒了，感觉可以从繁重的文书工作中解脱出来了呢。
失之东隅收之桑榆。一处的方便一定意味着另外什么地方以其他方式运行着简化掉的部分。
去文档，敏捷管理者需要维护更为精细的需求池；去流程，口头沟通成为常态，对团队的耦合度要求更高。
胖友，这里有一份教义，你要不要听一下。
初识敏捷，有一些概念需要了解，如果你是老司机，跳过这部分，阿敏。
：迅速，敏捷。这是敏捷的理念也是精髓：迅速响应需求，快速反馈结果。 的引入像一股活水冲击着老气横秋的瀑布流模型，速度上跑赢几条街。

：字面意思是短跑冲刺，一个开发阶段被认为是一次冲刺，一个个  首位相连，构成一个项目。
指的是英式橄榄球中一股脑争球这一战术或行为。
 即为这样一种方式，大家一拥而上，团队是球员，球是产品目标，人员环环相扣，围绕着产品目标进行工作。这里面多少有点“统筹法”的影子，人员深入协作以达到最优化效果。
 
 
 即需求池。待办事项列表。
 里面写什么：
待开发任务。
任务优先级。
敏捷需要维护一份详尽的需求列表。这份列表常常要求  持有人一般是产品经理对所有待开发事项有深入了解，并且能够把待开发事项分解成更为细致的任务或者跟敏捷教练一起，后面我们会再次提到敏捷教练
 
很多领域都有故事板的概念，交互领域里，用故事板表述用户场景、电影领域里故事板用来更具体地描述分镜。在开发领域，故事版是任务流转的可视化窗口，一般有“待开发”“开发中”“待测试”“返工”“待发布”几个区块，所有任务由任务操作者负责流转至于下一个步骤，这样任何一个人项目成员都能看到任务的完成情况。

一个使用情景故事版
  
在开发中，故事板展现所有需求的工作流
  ：
燃尽图
一个  内，人时是一个比较固定的值。在这个时间框架充分安排开发任务，每天进行时间结算，绘制时间燃尽图。项目成员通过燃尽图获知时间进展，若项目燃尽所用时间与预期时间契合，则需求时间预估和安排合理，若不契合则需要在下一个  进行调整。
名词听起来都玄乎乎的，很符合开宗立派的气质。这些概念定义了敏捷各个环节的工作，这些流程和节点是敏捷开展的基础和保障。
二、离开敏捷工具，我们怎么敏？
一个误区：我们用了敏捷管理工具，就敏捷了
随着敏捷在行业内的不断融入，各种工具产品层出不穷。国外、， ，国内的 、禅道，三大家则都有自研的工具，百度的，阿里的，我鹅自研。

数据来源：“中国开发者白皮书”
我们在  上建迭代，建需求，研发、测试等着收到需求流转的邮件之后开始干活任务在测试和研发之间流转， 提给研发，研发解决  我们宣称：我们敏捷化了！
我们习惯于敏捷软件的便利，拉群解决一切，然而却丧失了敏捷的初衷， 的本意。

的名字来自于哥斯拉
假设我们没有任何项目协同软件，敏捷怎么实施？
设定一个环境，现在没有任何协同工具可用，但是所有人都坐在一起。有人站起来说，既然这样，我们不如敏捷吧！

敏捷工具消失了
敏捷路径里必须有一个项目持有者，制定规划并把握项目走向。这位产品汪我看你骨骼惊奇，你就担负起这个责任吧。

另外还有一个关键人物 别想歪。 全称  ，中文称敏捷教练。一般说来， 需要由对技术开发以及当前项目明晰的技术经理担任。

虽然缺少线上工具，但至少要准备一些简单材料：一卷双面胶白纸或一沓便利贴；笔，一面平坦的墙或一块黑板。

如果还有电脑可用， 或者 ，甚至写字板都可以，没有电脑那就白纸好了，总之你得找个地方写下你的需求池

需求池示例任务名称、平台、详细描述、优先级按照逐渐递减
确定一个  周期的自然天。可以用月旬周等时间概念作为周期，我们选择一周五个工作日作为一个  周期。
按照优先级，从需求池中拉出你认为应该加入你们一穷二白的第一个  里面去的需求，别太贪心，大概觉得差不多一周左右的开发量就够了。拉上桑单独开一次小会。

当然不是让你俩傻站着，你俩要开会
你们一起通览需求， 桑根据经验对需求先行分解一遍，比如某需求在开发层面需要分解为  三部分，这三部分就形成三个开发任务。

分解完成后，你得到了一个比较详细的待开发列表。

正式开始一个  开始之前，产品、研发、测试需要一同开一次  会议，共同讨论本次  的功能点。
会上讨论什么：
需求讨论或技术讨论；
成员预估需求所需开发时间；
需求是否人力时间，需求排入；
交流一下感情。

每个任务的预估时间在最后由敏捷教练综合判定
 会后你的工作：
整理这个  内的需求列表；
整理每个需求的预期开发时间；
撰写故事版上的小纸条；
把小纸条贴到故事版上；
制作一个燃尽图。

一个改良版的小纸条，写明开发者、任务描述、预估时间和每日燃尽时间
 故事版布局如下：
 
 一个标准的故事版：最开始所有的小纸条都在“待开发”一栏
到此为止，你可以开始  起一个  。
以为这就完事了？天真。
接下来你必须来参加每日举行的项目短会。这个环节在  中非常关键，是  的日常修炼。为了缩减会议时间，我们一般站着开——所以也叫“站会”，早上上班后或晚上下班前，抽出十到十五分钟时间，完成它。

每日站会
站会都有什么人参加：
你项目持有者

其他  成员
站会干什么：
昨天大家分别做了什么事，遇到了什么问题，如何解决或寻求解决方案；
昨天任务的完成状态，剩余多少时间，是否需要进行时间修正增加时间或减少时间，把已完成的任务流转到下一环节把纸条从一个内撕下，贴到下一个里去；

任务进行中，小纸条的示例
功能测试后是否有返工；
交流一下感情。
站会之后你的工作：
绘制燃尽图。

一个燃尽图的示例：正常的  的任务时间是随着  的进程逐渐减少的
周而复始，完成了一个  后，你们开了第二次  会。这时议题多了一项复盘上一个 。
任务未能燃尽；研发返工过多；测试需求淤积
针对问题讨论解决方案，根据实际情况进行下一个  的任务安排。
自此，我们在没有任何敏捷工具的帮助下，开始了敏捷的旅程。
说起来  本来就是排斥文档的作业方式，为一个小轻快的方法制作一套严谨庞大的工具，基本也算违背了元老们的初衷了吧，科科。
三、设计师在敏捷中如何介入？
 我们正在使用或者听过的一些流程方法——不单敏捷，瀑布流，迭代式，结对开发，精益开发似乎都不关设计师什么事。既然开发团队抱团敏捷了，设计，这个在产品流程中必不可少而工作内容相对独立的角色，要怎么介入敏捷呢？
一种思路是，设计拥有自己的敏捷流程。设计师作为一个  存在，以从上游获取的需求进行  。
另一种思路，是把设计和测试完全纳入到团队中来，一起进行  的合作。
这样的话，工作至少要比开发工作前移至少半个  。
有请产品经理项目持有者出场。

很好，我们有了一个设计师
项目持有者将需求分为“  支持”和“非  支持”两类。我们将小纸条扩展一下。

多出来  前置部分的小纸条
 设计师参与到  会中。对于需要  支持的需求，设计师给出一个  制作的时间预估。项目持有者将这部分时间加到扩展小纸条上去。在一个  中，设计师的工作跟研发的工作分别进行。
当设计师将某一需求完成时，将小纸条的  部分撕下，汇入到“”待开发”中去。

一个已经完成了  设计的小纸条示例
四、敏捷不需要文档吗？
 一切为快服务的敏捷特别适合初创团队使用。它能把团队人员紧密结合在一起，高效而有序地输出产能。而常规高效的版本输出往往是初创团队高速发展的第一要务。
敏捷了一段时间之后，产品进入正轨，项目拿到拨款，公司拿到投资，你们要扩大团队规模，新入职的同事想了解下产品和技术细节，你告诉：
你要不翻下  看看？这个实现你要不看一下代码？这个字段我也不记得有没有了你抓包看下？
新同事一脸懵逼，难道咱们没有文档吗？你自豪地指出：
“我们是敏捷团队。”
十几个人八九条枪的阶段之后，产品趋于稳定，团队逐步扩大。无论从内部协调还是外部沟通上对产品流程的正规化和文档化要求与日俱增。
 从短期收益上看，文档对于敏捷开发是非必须品，并且很有可能会拖慢进度。在一个  中，口头沟通显然效率更高，每个人都有精确到工时的任务，没人有等待文档更新的时间。强调文档就等于放弃灵活性。
从长期和宏观上看，文档对于敏捷团队和敏捷的实施利大于弊——节省在一些常规问题上的沟通成本，同时降低错误的发生概率。对于一个将要长期实施敏捷的 团队来讲，文档让后续的工作效率更高。

一个以讹传讹的过程
这样一个功在当代利在千秋的好事，当然要做。那么——
谁来维护文档，怎么维护？
我们挑选几个重要的文档：产品文档、概要设计、接口文档
产品文档：不好意思内个产品经理你过来下。虽然你要维护  、跟  分解需求、开  会、写小纸条、开站会、画燃尽图、还有什么外部沟通啊，写  啊，绞尽脑汁想规划啊你还得认真把这个文档维护好。

对又是你
产品文档包括：
需求；
加入日期；
开发版本；
呈现和详细方案
在非敏捷开发流程中，文档在评审会后完善并更新，形成一个给研发参考的实现目标。在敏捷中，需求本身在  周期内不断完善，你可以在一个  之后将文档补全。
概要设计：敏捷的常规迭代中，概要设计不是一个必须的文档。但全新项目、重构以及重大新功能则必须输出概要设计文档。研发  责无旁贷，这个落你身上了。
接口文档：必要且重要。包括接口说明、字段定义、字段类型、值定义、数据上报、错误码等。一般来说约定之后由接口开发者更新文档，如果你们没有云端存储的能力，至少咱们人手一份，定期更新。
长久来看，文档是提高效率的一大利器
虽然《宣言》中明确地放低了文档的地位“工作的软件大于详尽的文档”，敏捷强调互动和变化，以及对变化的及时响应。诚然文档恰恰做不到如此灵活。但敏捷真的完全排斥文档吗？
文档的时效性和灵活性远低于口头沟通，但却有它实在的好处。
空间上，文档传播范围更广。规范化和常规化的内容形成文档可以大大减少沟通成本。尤其在多个系统协作的情况下，跨  、跨团队甚至跨部门的沟通时有发生，文档的重要性和便捷性不言而喻。
时间上，文档流传性更好。团队不是一成不变的，有人离开有人加入。更新换代中，新人快速了解系统，老兵传承研发理念；在更大的时间跨度上，团队可能成为忒修斯之船，文档的存在就是对产品历程的完整追溯，你将不用他人帮助就可以了解到产品的大部分面貌甚至全貌。
五、大项目怎么引入敏捷？
看起来敏捷方法特别适合产品常规迭代。有一种可能性是，你的产品需要插入一个巨无霸模块，与其说是模块倒不如说它几乎可以成为一个产品了。你想了想，这么大个项目怎么说产品、设计、研发、测试全情投入也得个一两个月。
还能走敏捷吗？
注意你的项目时间。有  的  是带着镣铐跳迪斯科，时间节点关乎  的大小。
大项目敏捷之前，先得不敏捷几步。
可能会发生一到多次需求讨论会。
团队必须不厌其烦地理解需求或修正产品经理“天真的幻想”，产品经理使用不断完善的原型同团队进行  沟  通  。在最后的产品评审之前，至少敲定产品框架和大部分细节。这次评审邀请项目成员和所有协同团队，除了敲定的产品功能，技术上需要得到一些初步结论比如“能不能做”。事实上，产品经理应该在产品规划阶段就知会协同团队将要做什么。接下来进行概要设计新产品、重构、重大新功能必须进行概要设计。技术评审邀请除设计以外的项目成员和协同团队参会。
大项目敏捷中：
将  之前的时间分解为多个  。 之前必须留出一定“出血时间”用以解决时间预估不足的任务、返工任务以及  
将所有需求分解成任务，开一次全局  会。预估时间之后，分散任务到各个  中。在时间较紧的情况下， 的容量就要相应增加。

一个需要加班的 
进入敏捷流程，常规  会、站会，燃尽图，故事版。未完成任务在  会上重新预估时间，滚入新  内，以此类推按时完成  内的任务是目标。实在不行我们还有“出血时间”呢
别忘了文档。
虽然被推崇备至，但敏捷并不是完美的开发方法。敏捷的最大的优势是灵活，而造成敏捷问题的根源也正是灵活。
文末再总结本文重点：
敏捷是一种流程、方法、理念，甚至信仰。
 用了敏捷管理软件不一定就是敏捷。敏捷的初衷是团队成员能够更加紧密地配合完成工作，线上的的流转如果削弱了这种配合性，反倒背离了敏捷的本意。实际上只要有白板纸张和笔，你的团队就能开始敏捷。
我们敏捷了，不是不要文档了。在外部交流多、世代跨度长的情况下，文档的必要性显而易见。长期的面对面沟通最终会导致低效，这也是敏捷缺陷的根源。
设计师可以完全介入到敏捷流程中，只需要做一些细心的安排。
大项目开发中可以走敏捷，具体问题具体分析，需要根据项目特点制定敏捷计划。
文章所有插图为笔者手绘，版权所有导语
简要介绍机器学习研究的内容，机器学习的三大步骤；不同的  类型举例
引用课程：_
先看这里，可能由于你正在查看这个平台行间公式不支持很多的渲染，所以最好在我的  上 查看，传送门：无奈脸
 博客文章地址：
我们将要学习什么东东？
什么是机器学习？

有右边这样非常大的音频数据集，写程序来进行学习，然后可以输出音频“”
 
有右边这样非常大的图片数据集，写程序来进行学习，然后可以识别左边这样图，识别为正确的物种。
机器学习 \ 寻找一个函数

 框架

  图像识别

函数集{}{}\ ，通常将一个函数称为 模型

为了找到最好的函数  ，将训练集图像放入函数集的输入中，函数集输出识别结果。

下面来看具体步骤

确定一组函数，函数集怎么找后面会再介绍。
将训练集对函数集进行训练。
挑选出“最好”的函数 {}
然后就可以使用 {} 来对新的测试集进行检测。
整体都学习哪些知识 

回归是什么
 意思是，我们要找到这样一个函数 ，使得输出为 标量，数值

这里说法当然是比较不严谨，数学上简单的线性，一元或多元回归的知识可以在概率论与数理统计课本中进行学习。《概率论与数理统计》，浙江大学，第九章，。

举个例子，比如预测

输入就是之前每一天的数值，输出是明天的，是个标量。具体做法：

分类

分类比较容易理解，比如二元分类或者多元分类。

 二元分类
比如垃圾邮件过滤，就是要找到一个，输入为一封邮件，输出是二元的，是或者不是垃圾邮件。训练集就是很多封邮件，每一封邮件知道它是否是垃圾邮件，让进行学习。

 多元分类
多元分类；例如下面的新闻分类系统，找一个，输入就是新闻的内容，输出则是新闻的类型政治，经济，体育等等

 深度学习

上面讲过，机器学习的第一个步骤就是确定一个函数集，可以选择 线性模型，但是   比较有限。更多的则是  非线性模型。比如深度学习就是   。
举个例子，比如图像识别：

这里举例深度学习中的一种，  ，卷积神经网络，输入就是很多的图像，输出为图像的类型，这里将每个对象都当作一个类别。训练集就是很多张图片，并告诉机器每张图片对应的是什么类型。深度学习的非常复杂。
再举一个例子，下围棋：

输入就是黑白子在棋盘上的位置，输出就是下一步应该下在哪里。这也就是一个选择题，可能的选项有个。

训练集就是一堆棋谱，每一步是怎么走的。

 有监督学习
  不只  ，后面还会接触到 ，  等。上面提到这些我们都叫做 有监督学习，所谓   就是说训练集的输入和输出对于目标函数是成对的，目标函数看到一个输入，就应该对应有一个输出。也把这样的输出叫做 。见到说需要   的情况，就是指我们要告诉机器看到一个输入，要有一个输出。

其他的比如还有 半监督学习
 半监督学习
比如图像识别一些猫和狗，  就是训练集中每个图片知道它对应的是什么类型。而  就是不知道图片对应的类型。这种其实也是可以让机器学习的比较好的，后面也会介绍。

 迁移学习
举例说一下迁移学习：

比如有   ，但我们还有一些 或者  数据，这些数据和   中识别猫和狗都没有关系，但它也是怎么帮助  更好的识别。这就是   要做的事情。
 无监督学习
举一个  的例子：让机器阅读非常多的文章，然后机器就可以学习单词的含义。

这个  的例子中，训练集只有输入很多的文章，没有输出。假设通过 神经网络学习之后，给一个单词，就可以输出一个向量。

再举一个例子：比如想要让机器绘制一下自己的内心世界。

具体说就是给机器一堆数字，他就能自己绘制一张图片，此时训练集只有输出很多的图片，没有输入。

 结构化学习
比如看下面例子：第一个是语音识别，假设我们想要找的是输入一段语音，然后输出语音的文字。如果把世界上不同的句子当作一个类别，这样是没有办法穷举所有类型的，所以这种超越分类的问题，就需要另外一套完整的思想来解决。还有例子就是机器翻译，将中文翻译成英文，也是没有办法穷举所有的句子。再或者人脸识别，没有办法穷举所有人脸框。

 增强学习
举个  的例子：。举例来比较  和 ：比如学习对话， 训练集每句话，都有对应的输出；但是就只是不断的对话，机器只能知道它做的好或者不好，没有其他更多的信息。

再举一个围棋的例子，比如  情况就是机器看到一个棋局，告诉它下一步应该走什么。 的情况就是走了很多步，输了或者赢了，就是知道一个结果。 就是两个都用到了，先看棋谱学习，但是棋谱的数量是有限的，然后再进行增强型学习。所以  第一轮和世界高手对局时还捉襟见肘，第二轮就基本横扫了。

理解 颜色的意义

蓝色的都是代表方案，红色部分指的是你要找的的样子，可以在  的情况下做红色的，也可以在  下做红色，就是右上角的个虽然是小方块，但是   里面的  都可以在其他蓝色  中做。绿色的部分就是方法或者说模型，绿色的内容虽然写在  里面，但是可以放在  或者   中。
相关推荐人人都可以做深度学习应用：入门篇上人人都可以做深度学习应用：入门篇下机智机器学习 月  日，腾讯云在 「云未来」峰会上推出了战略新品——智能云，宣布将腾讯积累近  年的  能力向政府、企业和开发者开放，其中首批开放计算机视觉、智能语音识别、自然语言处理的三大核心能力。腾讯云技术社区陆续推出了系列文章，向普通开发者分享如何快速接入并使用这三大  能力，节省自身的开发成本，同时极大提升开发效率和用户体验。
本文将为广大云开发者介绍如何接入腾讯开放的计算机视觉能力，即万象优图。
 基本架构及业务流程
基本架构
数据安全是云存储的重中之重，为了保护开发者的数据安全，腾讯云·万象优图的上传、复制、删除和下载如果设置了防盗链服务需要鉴权签名；鉴权签名的生成需要用到，所以签名的生成需要在可信任的环境中进行，绝不能在客户端进行，否则会带来密钥泄漏的风险，危害开发者数据。腾讯云·万象优图推荐使用以下的服务器架构设计：

主要包括三个部分：
 腾讯云·万象优图
提供高成功率、高可靠、高速的图片存储服务，以及强大的图像处理技术；
 开发者服务器
开发者服务器至少提供如下个功能：
、生成签名。签名的生成不能在终端上进行，否则会产生极大的安全隐患；、使用数据库管理用户信息、图片资源信息；、响应终端的业务请求；
另外，开发者服务器还可以直接与腾讯云·万象优图通信对图片进行管理操作。
 终端
通常既上传图片也下载图片。在展示图片前，通常先从开发者服务器获取要展示的图片信息，比如图片的；在上传图片前，通常先从开发者服务器获取签名，然后带着签名请求腾讯云·万象优图。
 业务流程
 图片上传
终端上传图片前先请求开发者服务器获取上传签名，然后再请求腾讯云·万象优图，腾讯云·万象优图会对上传签名进行验证，无效的签名会返回签名认证错误等信息。图片上传流程根据开发者是否设置回调可分为两种方案。
方案一：无回调设置

上传流程主要包括三个步骤：

终端访问开发者服务器，获取签名注意：签名的创建不能在终端上进行，否则可能会导致用户信息泄露等安全隐患；
终端上传图片，腾讯云·万象优图验证签名、存储图片，生成文件，等信息返回给终端；
终端将图片信息和用户信息反馈给开发者服务器。

方案二：有回调设置
如果有设置回调，则上传完成时腾讯云·万象优图会自动向开发者服务器发起设置的回调请求。

上传流程主要包括四个步骤：

终端访问开发者服务器，获取签名注意：签名的创建不能在终端上进行，否则可能会导致用户信息泄露等安全隐患；
终端上传图片，腾讯云·万象优图验证签名、存储图片，生成文件，等信息通过回调传给开发者服务器；
业务服务存储相应的图片信息，并将处理结果返还给腾讯云·万象优图；
腾讯云·万象优图根据开发者服务器返回的处理信息返还给终端结果。

 图片下载
图片下载使用图片上传成功后返回的的下载直接访问，即直接访问_。
如果设置了防盗链，则使用下载加签名的方式直接访问，即：_=签名
 接入服务
根据开发者业务的现有情况可将服务接入分为两种类型：回源镜像和一般接入。其中回源镜像适用于开发者的历史图片没有存储在腾讯云·万象优图，而要使用腾讯云·万象优图的下载和其他服务，如果开发者希望接入服务；一般接入是指开发者没有或者不考虑历史图片，使用腾讯云·万象优图对图片进行上传、下载和其他操作。

注：回源镜像可以用作开发者图片数据的灾备；也可以让开发者一键试用服务，方便快捷。

 回源镜像
 注册账号
前往腾讯云·万象优图控制台注册账号。

注：以下称图片空间为。

 场景接入
腾讯云·万象优图根据开发者的源站类型和所需服务，将回源镜像划分为四个场景。

注意： 腾讯云·万象优图针对四个场景分别进行了优化，请根据自身的情况选择合适场景接入，获取最优的服务体验。

场景一：使用万象优图下载，回源到其他云存储厂商
场景二：使用万象优图下载，回源到自己站点
场景三：使用万象优图上传和下载，历史图片回源到其他云存储厂商
场景四：使用万象优图上传和下载，历史图片回源到自己站点
 一般接入
由 基本架构章节可知，开发者如需接入腾讯云·万象优图服务，为了保护数据的安全，开发者需要在自己开发者服务器上面部署鉴权服务；终端需要向开发者服务器请求的签名，然后进行相应的服务操作，例如进行图片的上传，复制，删除，下载等。
 接入流程
接入腾讯云·万象优图只需以下三步：
 注册腾讯云·万象优图；
 终端部署示例；
 鉴权服务部署示例。
下面分别介绍终端部署简单示例，鉴权服务部署简单示例，以及终端和开发者服务器交互签名的过程。

说明：

文档中终端和开发者服务器的签名交互过程只是一个简单的例子，开发者需要根据自己业务需求开发交互过程。

如果开发者想使用本文档提供的例子进行简单测试，请确保终端和服务端的项目信息一致，如项目，空间名称，和等。



 注册腾讯云·万象优图

前往腾讯云·万象优图控制台注册账号；如果已经注册账号，请跳过此步骤；

在腾讯云·万象优图控制台创建一个图片空间，获取空间名称和项目；如果已创建过图片空间，请跳过此步骤；

在腾讯云·万象优图控制台项目设置中添加密钥，获取和；如果已经添加过密钥，请跳过此步骤。


 终端部署示例
腾讯云·万象优图提供了丰富的 接口，开发者可以参考 部署和开发终端。
同时腾讯云·万象优图还为开发者提供了功能丰富的移动端，以及端部署示例。开发者也可是使用移动端开发自己的服务，下面简单介绍使用终端部署服务的简单示例，开发者需要根据自身业务情况开发相应的代码：
终端部署示例
终端部署示例
端部署示例
移动端的详细文档说明请参见移动端文档。
 鉴权服务部署示例
以下为鉴权服务部署的简单示例使用了服务端，开发者可以简单参考，开发自身业务鉴权服务，并集成到自身服务器中：

注意：下面的文档只是简单的示例，展示了服务端为终端提供签名的简单用法，开发者务必根据自身业务开发相应的鉴权服务逻辑，并集成到自身服务器中。

鉴权服务部署示例
鉴权服务部署示例
鉴权服务部署示例
鉴权服务部署示例
鉴权服务部署示例
如需使用服务端更多功能，请参见服务端文档。作者：张亚舒

我们是一个深圳的创业团队，最近做了一款图书的  应用，利用了腾讯云的相关平台和  功能。
总体来说做一款手机或  运行的  应用主要有以下几个关键技术：

图像识别利用摄像头采集的实时图像信息，一桢一桢传给识别模块去处理，识别出来后返回图片标识；

读取图片绑定的增强内容这一步通常利用  远程服务器读取或者  本地存储读取；

展示在摄像头开启的情况下，新建图层展示相关内容，在视觉效果上形成一个内容合并；

另一大块就是增强内容的制作可以是普通的计算机素材，例如图片、音频、视频、网页、或者  原生组件，也可以是  动画或  模型，可利用  、  制作模型再导入  中加动作和其它效果。


产品架构图

如何利用腾讯云的相关服务





演示视频，还没学会嵌入视频，把地址放这里，大家自己下载观看哈

演示截图

谢谢，欢迎一起参与  的开发和应用交流。

相关推荐从é  谈游戏开发图像识别匹配图片接口