是微信终端的第三个开源项目。至此，微信分享出去的代码包括了热更新、网络基础组件和数据库，可以说是压箱底的东西都拿了出来。
说起，它是在应用程序中使用的高效，完整，易于使用的移动数据库框架。它目前在，和上可用。
地址：数量：
依托微信的用户量和对数据库的重度依赖，直击移动端数据库在和平台存在的不同问题。在上，由于  提供的支持尚可，而且使用  开发不便，自然选择系统  接口进行开发，提供加密接口、数据迁移、日志重定向和各种跟踪设置等功能。  情况则有不同。系统提供的 学习成本很高、性能一般，并不那么好用，因此提升易用性、保持高效和完整，则是适用于的设计的重点。
客户端数据库并不是什么“性感”的技术。比起前段时间备受关注的热更新或去年以来的、等等，数据库的热度并不高，不过…

这篇文章收录了关于微信移动端数据库的到目前为止一切细节，如果你有足够的耐心读完以下内容，相信你便会爱上这套微信开源的解决方案。

 面对五花八门的数据库技术，为什么自己造了个轮子？
对于开发者来说，数据库的技术选型一直是个令人头痛的问题。
由于提供的框架差强人意，使得开发者们纷纷将目光投向开源社区，寻找更好的存储方案。 
对于微信也是如此。数据库是微信内最基础的组件之一，消息收发、联系人、朋友圈等等业务都离不开数据库的支持。为了满足需求，我们也对现有方案做了对比研究后发现，发现已有方案都不能满足微信的要求。于是应运而生。
点击下方标题即可阅读全文↓
《微信移动端数据库组件系列一基础篇》 
 数据库损坏问题，都提供了哪些方案？
长久以来 都有损坏问题，从、等移动系统，到、 等桌面系统都会出现。由于微信所有消息都保存在，服务端不保留备份，一旦损坏将导致用户消息被清空，显然不能接受。
  ，致力于解决  损坏导致数据丢失的问题，提供修复工具组合套拳。
 点击下方标题即可阅读全文↓
《微信移动端数据库组件系列二 — 数据库修复三板斧》 《微信数据库修复实践》 
 即便是很复杂的查询，也可以通过一行代码完成。如何保证易用性？
通过抽象语法规则，使得开发者可以告别字符串拼接的胶水代码。通过和接口层的结合，使得即便是很复杂的查询，也可以通过一行代码完成。并借助的代码提示和编译检查的特性，大大提升了开发效率。同时还内建了反注入的保护。
虽然在实现上使用了特性和模版等，但在使用过程并不需要涉及。对于熟悉的开发，只需按照本能即可写出对应的语句。最终达到提高易用性的目的。同时，基于的实现也使得在性能可以期待。
点击下方标题即可阅读全文↓
《微信移动端数据库组件系列三 — 原理篇》
  有哪些的特色功能？
 由于接口跟系统几乎一样，相信大家都比较熟悉，不熟悉用法也可以到   官网看一下。但是，我们也有一些特色功能和优化大家可能不容易注意到， 例如加密接口、数据迁移、全文搜索分词器与动态加载、日志重定向与性能监控、优化实现，现在就单独拿出来说说。
点击下方标题即可阅读全文↓
《微信移动数据库组件四 —  特性篇》《微信客户端会话速度提升的背后》
 为了让开发者更快上手，为开源做了哪些改变？
 和  的数据库在有了跨平台组件的想法和实践经验，思考问题更多从方案通用性的方向考量。为了更好地共享成果， 与  数据库组件  经过重构后脱离各自的业务逻辑，变成一个独立的，专注的，可推广的组件，最终以开源的形式与大家相见。
点击下方标题即可阅读全文↓
《微信进化之路  开源与开始》
最新版本更新日期

版本

性能优化

将内置  或    更改为原始数据格式。要兼容早期版本，请调用   = 

增加        语句和  相关的编译指示

移除  的自动增量

将  重命名为  并将  重命名为 

一些小的  修复


版本

性能优化

将  规则  给  包。修复  在  启用时崩溃的问题。



读到这儿，相信你已经能够感受微信团队的用心和专业：“希望能够持续优化，将这个问题解决到极致。多年后再提起客户端数据库，不需要引起任何热度和讨论，用就解决了。”
目前微信开源的项目已实现内外部同步，上的改进最终也会原封不动的在微信开发中使用。因此，希望你可以提出和，微信会因你更好。

转载自【腾讯开源】公众号，腾讯官方开源资讯，期待您的关注。提到、、相信大家都耳熟能详了，三个都是多路复用的机制，可以监视多个描述符的读写等事件，一旦某个描述符就绪一般是读或者写事件发生了，就能够将发生的事件通知给关心的应用程序去处理该事件。本质上，、、本质上都是同步，相信大家都读过 的经典书籍  ，书中给出了种模型：
    阻塞    非阻塞    多路复用     信号驱动    异步
其中前面种都可以归类为   同步，在介绍、、之前，首先介绍一下这几种模型，  平时用的比较少，这里就不介绍了。
   同步、异步、阻塞、非阻塞
下面以 中的读操作为切入点，来讲述同步 和异步 、阻塞 和非阻塞的异同。一般情况下，一次网络读操作会涉及两个系统对象： 用户进程线程；内核对象，两个处理阶段：
         等待数据准备好
           将数据从内核空间的拷贝到用户空间进程的
模型的异同点就是区分在这两个系统对象、两个处理阶段的不同上。
 同步 之  

如上图所示，用户进程在 读操作的两个阶段都是等待的。在数据没准备好的时候，原地等待准备数据。准备好数据后，继续等待将数据到自己的。在完成数据的后才会从系统调用中返回。
 同步 之  

从图中可以看出，在 读操作的第一个阶段是不会等待的，如果数据还没准备好，那么会立刻返回一个错误。当准备好数据后，进入处理的第二阶段的时候，会等待将数据到自己的，在完成数据的后才会从系统调用中返回。
 同步 之  

多路复用，就是我们熟知的、、模型。从图上可见，在多路复用的时候，在两个处理阶段都是住等待的。初看好像多路复用没什么用，其实、、的优势在于可以以较少的代价来同时监听处理多个。
 异步

从上图看出，异步要求在操作的两个处理阶段上都不能等待，也就是调用后立刻返回，自行去准备好数据并将数据从的中到的在通知读操作完成了，然后在去处理。遗憾的是，的网络中是不存在异步的，的网络处理的第二阶段总是阻塞等待数据完成的。真正意义上的网络异步是下的完成端口模型。

很多时候，我们比较容易混淆 和 ，认为是一样的。但是通过上图，几种模型的比较，会发现 和 的区别还是很明显的， 仅仅要求处理的第一阶段不即可，而 要求两个阶段都不能住。
 的 事件 机制
言归正传，在介绍、、前，有必要说说内核的事件 机制，这是多路复用机制存在的本质。通过睡眠队列来管理所有等待的某个事件的，同时通过机制来异步唤醒整个睡眠队列上等待事件的，通知相关事件发生。通常情况，的事件发生的时候，其会顺序遍历睡眠队列上的每个节点，调用每个节点挂载的函数。在遍历的过程中，如果遇到某个节点是排他的，那么就终止遍历，总体上会涉及两大逻辑：睡眠等待逻辑；唤醒逻辑。
睡眠等待逻辑：涉及、、_的阻塞等待逻辑
、、_陷入内核，判断监控的是否有关心的事件发生了，如果没，则为当前构建一个_节点，然后插入到监控的_
进入循环的直到关心的事件发生了
关心的事件发生后，将当前的_节点从的_中删除。
唤醒逻辑：
的事件发生了，然后顺序遍历其睡眠队列，依次调用每个_节点的函数
直到完成队列的遍历或遇到某个_节点是排他的才停止。
一般情况下包含两个逻辑：_自定义的私有逻辑；唤醒的公共逻辑，主要用于将该_的放入的就绪队列，让随后可以调度其执行。
下面就上面的两大逻辑，分别阐述、、的异同，为什么能够比、高效。
 大话—
在一个高性能的网络服务上，大多情况下一个服务进程线程需要同时处理多个，我们需要公平对待所有，对于而言，那个有数据可读，就去读取该的数据来处理。于是对于，一个朴素的需求就是关心的个是否有数据”可读”，也就是我们期待”可读”事件的通知，而不是盲目地对每个调用来尝试接收数据。我们应该在等待事件的发生上，这个事件简单点就是”关心的个中一个或多个有数据可读了”，当解除的时候，就意味着，我们一定可以找到一个或多个上有可读的数据。另一方面，根据上面的  机制，我们不知道什么时候，哪个会有读事件发生，于是，需要同时插入到这个的_上等待任意一个可读事件发生而被唤醒，当时被唤醒的时候，其里面应该有个逻辑去检查具体那些可读了。
于是，的多路复用逻辑就清晰了，为每个引入一个逻辑，该逻辑用于收集发生的事件，对于可读事件来说，简单伪码如下：

{
    其他逻辑
         
    {
        _ |= _；
    }
   其他逻辑
}
接下来就到的逻辑了，下面是的函数原型：个参数，后面个参数都是类型值可能会被修改返回
   _  _  _    
当用户调用的时候，会将需要监控的集合拷贝到内核空间假设监控的仅仅是可读，然后遍历自己监控的 ，挨个调用的逻辑以便检查该是否有可读事件，遍历完所有的后，如果没有任何一个可读，那么会调用_进入循环，使得进入睡眠。如果在时间内某个上有数据可读了，或者等待了，则调用的会被唤醒，接下来就是遍历监控的集合，挨个收集可读事件并返回给用户了，相应的伪码如下：
   
{
    _ = 
    _ = 
    ___
}
通过上面的逻辑过程分析，相信大家都意识到，存在两个问题：
 被监控的需要从用户空间拷贝到内核空间
    为了减少数据拷贝带来的性能损坏，内核对被监控的集合大小做了限制，并且这个是通过宏控制的，大小不可改变限制为。
 被监控的集合中，只要有一个有数据可读，整个集合就会被遍历一次调用的函数收集可读事件
    由于当初的需求是朴素，仅仅关心是否有数据可读这样一个事件，当事件通知来的时候，由于数据的到来是异步的，我们不知道事件来的时候，有多少个被监控的有数据可读了，于是，只能挨个遍历每个来收集可读事件。
到这里，我们有三个问题需要解决：
被监控的集合限制为，太小了，我们希望能够有个比较大的可监控集合集合需要从用户空间拷贝到内核空间的问题，我们希望不需要拷贝当被监控的中某些有数据可读的时候，我们希望通知更加精细一点，就是我们希望能够从通知中得到有可读事件的列表，而不是需要遍历整个来收集。
 大话—鸡肋
遗留的三个问题中，问题是用法限制问题，问题和则是性能问题。和非常相似，并没着手解决性能问题，只是解决了的问题集合大小限制问题。下面是的函数原型，改变了集合的描述方式，使用了结构而不是的_结构，使得支持的集合限制远大于的。虽然解决了集合大小的限制问题，但是，它并没改变大量描述符数组被整体复制于用户态和内核态的地址空间之间，以及个别描述符就绪触发整体描述符集合的遍历的低效问题。随着监控的集合的增加性能线性下降，不适合用于大并发场景。
    _   
 大话—终极武功
遗留的三个问题，问题是比较好解决，简单两三下就解决掉了，但是的解决有点鸡肋。要解决问题和似乎比较棘手，要怎么解决呢？我们知道，在计算机行业中，有两种解决问题的思想：
 计算机科学领域的任何问题 都可以通过添加一个中间层来解决
 变集中中央处理为分散分布式处理
下面，我们看看，在解决的遗留问题和的时候，怎么运用这两个思想的。
 集合拷贝问题的解决
对于多路复用，有两件事是必须要做的对于监控可读事件而言： 准备好需要监控的集合； 探测并返回集合中哪些可读了。细看或的函数原型，我们会发现，每次调用或都在重复地准备集中处理整个需要监控的集合。然而对于频繁调用的或而言，集合的变化频率要低得多，我们没必要每次都重新准备集中处理整个集合。
于是，引入了_系统调用，将高频调用的_和低频的_隔离开。同时，_通过__、__、__三个操作来分散对需要监控的集合的修改，做到了有变化才变更，将或高频、大块内存拷贝集中处理变成_的低频、小块内存的拷贝分散处理，避免了大量的内存拷贝。同时，对于高频_的可读就绪的集合返回的拷贝问题，通过内核与用户空间内存映射同一块内存来解决。将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址，使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。
另外，通过_来对监控的集合来进行增、删、改，那么必须涉及到的快速查找问题，于是，一个低时间复杂度的增、删、改、查的数据结构来组织被监控的集合是必不可少的了。在 之前的内核，使用来组织集合，于是在创建 的时候，需要初始化的大小。于是_ 有一个参数，以便内核根据的大小来分配的大小。在 以后的内核中，使用红黑树来组织监控的集合，于是_ 的参数实际上已经没有意义了。
 按需遍历就绪的集合
通过上面的的睡眠队列唤醒逻辑我们知道，唤醒睡眠在其睡眠队列的_的时候会调用_的回调函数，并且，我们可以在中做任何事情。为了做到只遍历就绪的，我们需要有个地方来组织那些已经就绪的。为此，引入了一个中间层，一个双向链表_，一个单独的睡眠队列___，并且，与或不同的是，的不需要同时插入到多路复用的集合的所有睡眠队列中，相反只是插入到中间层的的单独睡眠队列中，睡眠在的单独队列上，等待事件的发生。同时，引入一个中间的__，它与某个 密切相关，__睡眠在的睡眠队列上，其函数逻辑是将当前排入到的_中，并唤醒的___。而___上睡眠的的回调函数就明朗了：遍历_上的所有，挨个调用的函数收集事件，然后唤醒从_返回。于是，整个过来可以分为以下几个逻辑：
_ __逻辑
 构建睡眠实体__，将当前 关联给__，并设置__的回调函数为__
 将__排入当前 的睡眠队列上
回调函数__的逻辑如下：
 将之前关联的排入的_
 然后唤醒的单独睡眠队列___
_逻辑
 构建睡眠实体__，将当前关联给__，并设置回调函数为__
 判断的_是否为空，如果为空，则将__排入的___中，随后进入循环，这会导致调用_的睡眠。
 __被事件唤醒或超时醒来，__将被从___移除掉，然后__执行回调函数__
回调函数__的逻辑如下：
 遍历的_，挨个调用每个的逻辑收集发生的事件，对于监控可读事件而已，_上的每个都是有数据可读的，这里的遍历必要的不同于的遍历，它不管有没数据可读都需要遍历一些来判断，这样就做了很多无用功。
 将每个收集到的事件，通过_传入的数组回传并唤醒相应的。
唤醒逻辑整个的协议栈唤醒逻辑如下对于可读事件而言：
 协议数据包到达网卡并被排入 的接收队列
 睡眠在的睡眠队列_被唤醒，__的回调函数__被执行
 __将当前插入的_中
 唤醒睡眠在的单独睡眠队列___的_，__被唤醒执行回调函数__
 遍历的_，挨个调用每个的逻辑收集发生的事件
 将每个收集到的事件，通过_传入的数组回传并唤醒相应的。
巧妙的引入一个中间层解决了大量监控的无效遍历问题。细心的同学会发现，在中间层上为每个监控的准备了一个单独的回调函数__，而对于，所有的都公用一个相同的回调函数。正是这个单独的回调__使得每个都能单独处理自身，当自己就绪的时候将自身挂入的_。同时，引入了一个睡眠队列___，分割了两类睡眠等待。不再睡眠在所有的的睡眠队列上，而是睡眠在的睡眠队列上，在等待”任意一个可读就绪”事件。而中间__则代替睡眠在具体的上，当就绪的时候，它就可以处理自身了。
   边沿触发    水平触发
     概念
说到就不能不说说事件的两种模式了，下面是两个模式的基本概念

   边沿触发

的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件
的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出空间时触发读事件
仅在缓冲区状态变化时触发事件，比如数据缓冲去从无到有的时候不可读可读

   水平触发

接收缓冲区不为空，有数据可读，则读事件一直触发
发送缓冲区不满可以继续写入数据，则写事件一直触发
符合思维习惯，_返回的事件就是的状态
通常情况下，大家都认为模式更为高效，实际上是不是呢？下面我们来说说两种模式的本质：
我们来回顾一下，节唤醒逻辑 的第五个步骤

 遍历的_，挨个调用每个的逻辑收集发生的事件
大家是不是有个疑问呢：挂在_上的什么时候会被移除掉呢？其实，从_移除的时机正是区分两种事件模式的本质。因为，通过上面的介绍，我们知道_是否为空是_是否返回的条件。于是，在两种事件模式下，步骤如下：
对于   边沿触发：
 遍历的_，将从_中移除，然后调用该的逻辑收集发生的事件
对于   水平触发：
 遍历的_，将从_中移除，然后调用该的逻辑收集发生的事件
 如果该的函数返回了关心的事件对于可读事件来说，就是_事件，那么该被重新加入到的_中。
对于可读事件而言，在模式下，如果某个有新的数据到达，那么该就会被排入的_，从而_就一定能收到可读事件的通知调用的逻辑一定能收集到可读事件。于是，我们通常理解的缓冲区状态变化从无到有的理解是不准确的，准确的理解应该是是否有新的数据达到缓冲区。
而在模式下，某个被探测到有数据可读，那么该会被重新加入到_，那么在该的数据被全部取走前，下次调用_就一定能够收到该的可读事件调用的逻辑一定能收集到可读事件，从而_就能返回。
     性能
通过上面的概念介绍，我们知道对于可读事件而言，比多了两个操作：对_的遍历的时候，对于收集到可读事件的会重新放入_；下次_的时候会再次遍历上次重新放入的，如果本身没有数据可读了，那么这次遍历就变得多余了。在服务端有海量活跃的时候，模式下，_返回的时候，会有海量的 重新放入_。如果，用户在第一次_返回的时候，将有数据的都处理掉了，那么下次_的时候，上次_重新入_的被再次遍历就有点多余，这个时候确实会带来一些性能损失。然而，实际上会存在很多多余的遍历么？
先不说第一次_返回的时候，用户进程能否都将有数据返回的处理掉。在用户处理的过程中，如果该有新的数据上来，那么协议栈发现已经在_中了，那么就不需要再次放入_，也就是在模式下，对该的再次遍历不是多余的，是有效的。同时，我们回归高效的场景在于，服务器有海量，但是活跃较少的情况下才会体现出的高效、高性能。因此，在实际的应用场合，绝大多数情况下，模式在性能上并不会比模式具有压倒性的优势，至少，目前还没有实际应用场合的测试表面比性能更好。
     复杂度
我们知道，对于可读事件而言，在阻塞模式下，是无法识别队列空的事件的，并且，事件通知机制，仅仅是通知有数据，并不会通知有多少数据。于是，在阻塞模式下，在_返回的时候，我们对某个_调用或读取并返回了一些数据的时候，我们不能再次直接调用或，因为，如果_已经无数据可读的时候，进程就会阻塞在该_的或调用上，这样就影响了多路复用的逻辑我们希望是阻塞在所有被监控的_调用上，而不是单独某个_上，造成其他饿死，即使有数据来了，也无法处理。
接下来，我们只能再次调用_来探测一些_，看是否还有数据可读。在模式下，如果_还有数据可读，那么_就一定能够返回，接着，我们就可以对该_调用或读取数据。然而，在模式下，尽管_还是数据可读，但是如果没有新的数据上来，那么_是不会通知可读事件的。这个时候，_阻塞住了，这下子坑爹了，明明有数据你不处理，非要等新的数据来了在处理，那么我们就死扛咯，看谁先忍不住。
等等，在阻塞模式下，不是不能用的么？是的，正是因为有这样的缺点，强制需要在非阻塞模式下使用。在模式下，_返回_有数据可读，我们必须要读完所有数据才能离开。因为，如果不读完，不会在通知你了，虽然有新的数据到来的时候，会再次通知，但是我们并不知道新数据会不会来，以及什么时候会来。由于在阻塞模式下，我们是无法通过来探测空数据事件，于是，我们必须采用非阻塞模式，一直直到。因此，要求_非阻塞也就不难理解了。
另外，_原本的语意是：监控并探测是否有数据可读对于读事件而言。模式保留了其原本的语意，只要还有数据可读，它就能不断反馈，于是，我们想什么时候读取处理都可以，我们永远有再次的机会去探测是否有数据可以处理，这样带来了编程上的很大方便，不容易死锁造成某些饿死。相反，模式修改了_原本的语意，变成了：监控并探测是否有新的数据可读。
于是，在_返回_可读的时候，我们需要小心处理，要不然会造成死锁和饿死现象。典型如_返回可读的时候，我们需要不断的直到。假设同时有三个请求到达，_返回_可读，这个时候，如果仅仅一次拿走一个请求去处理，那么就会留下两个请求，如果这个时候一直没有新的请求到达，那么再次调用_是不会通知_可读的，于是_只能睡眠到超时才返回，遗留下来的两个请求一直得不到处理，处于饿死状态。
     总结
最后总结一下，和模式下_返回的条件

  对于读操作

 当接收缓冲内待读数据增加的时候时候由空变为不空的时候、或者有新的数据进入缓冲
 调用___来改变_的监控事件，也就是重新 _的事件，并且接收缓冲内还有数据没读取。这里不能是__的原因是，不允许重复的，除非先了，再因为_或会调用的逻辑来检查是否有关心的事件，如果有，就会将该加入到的_中，下次调用_的时候，就会遍历到该，然后会重新收集到关心的事件返回。

  对于写操作

 发送缓冲内待发送的数据减少的时候由满状态变为不满状态的时候、或者有部分数据被发出去的时候 调用___来改变_的监控事件，也就是重新 _的事件，并且发送缓冲还没满的时候。

  对于读操作就简单多了，唯一的条件就是，接收缓冲内有可读数据的时候

  对于写操作就简单多了，唯一的条件就是，发送缓冲还没满的时候


在绝大多少情况下，模式并不会比模式更为高效，同时，模式带来了不好理解的语意，这样容易造成编程上面的复杂逻辑和坑点。因此，建议还是采用模式来编程更为舒爽。
参考资料
当前浏览器不能支持视频播放，请采用或以上浏览器
大家好，在第一节课我们介绍了云端最简架构，本节课程是【十分钟轻松搞定云架构】课程第二节，更好的网络。
在这一节课，我们将要讨论以下几个内容：

为什么我们需要更好的网络？

什么是内容分发网络？

内容分发网络能够为我们带来什么？


为什么我们需要更好的网络

 用户的不断增加
用户的不断增加会导致我们的带宽需求不断增加。我们需要为用户提供更好的网络，来让他们更好的使用我们的产品。如果你不提升网络的性能，用户量的提升会导致应用的网络跟不上，变得非常慢、非常卡，反而会导致你的用户离开你的产品，选择其他产品。
 用户遍布全国甚至全球
如果不提升网络性能，会出现部分用户访问比较快，部分用户访问比较慢。
 用户端带宽的不断提升
用户端带宽的不断提升让用户的浏览速度不断的加快，体验变的更好。同样的，我们也需要提升我们自己的网络性能，来为用户提供一个更好的体验。以免用户因为应用的卡慢选择了其他产品。
 各种基础网络运营商网络环境不同
国内大大小小的宽带运营商有数十家，有的能够给用户提供优质的网络，有的无法提供优质的网络。如果不提供更好的网络，用户可能无法很好的使用我们的产品。
一个好的网络能够为我们带来什么样的好处
网页加载的大部分时间花在网络加载和渲染上。一个好的网络，可以让你的网站无须优化就达到秒开。而一个好的渲染模式，更是可以让你的网站在秒开的基础上，变的更快。

为什么不提升主机的带宽？
不选择提升主机带宽的最大的原因还是目前国内主机带宽的成本较高。以内 元／月， 元／月， 元／月，随着带宽不断提升，单价也在不断提升。如果从带宽的角度来提升的话，我们的成本将会非常高。

什么是内容分发网络

内容分发网络可以借助其海量的节点，帮助我们将文件缓存到其各个节点，来让我们的文件加载速度更快。
其关键就在于借助智能分发，将用户引导到最近的节点去访问文件，用户访问最近的节点，肯定要比回到我们自己的服务器的速度要快一些。
除此之外，内容分发网络的节点大多是带宽较大、响应较快的节点，能够让用户更好更快的加载出需要的文件。
内容分发网络的工作原理

内容分发网络的原理就是将我们的文件都缓存到各个节点，用户通过智能分发，导流到距离最近的节点。同时由于文件被缓存到了节点上，同样的内容，在同一个节点，只会回源一次。即使用户多次访问了同一个文件，也是只回源一次。
加入内容分发网络后的架构

在加入内容分发网络后。用户就不再直接访问云主机了。而是访问距离自己最近的一个内容分发网络节点。其对应的请求的流程如下：

用户在的作用下，直接访问最近的节点。

如果请求的文件不存在，节点就向云主机源站发送请求，获取文件内容，并返回给用户。

如果请求的文件存在重复访问，节点就直接将文件返回给用户。


从右侧的架构图我们可以看到。原本的三个请求，经过 的缓存，可能只有一个请求需要返回源站。这样就大大的降低了我们的云主机的访问压力。
新的架构为我们带来了什么？

用户的高速访问用户访问距离自己最近的节点

云主机带宽占用的下降大量请求被节点承载，不再回源

网站对不同网络环境的高度适应内容分发网络的节点较多，可以覆盖绝大多数运营商



相关推荐
【腾讯云的种玩法】 服务器网络测试哪家强？ 帮你忙【腾讯云的种玩法】 整合  对象存储服务，享受无限容量存储服务 概述
 全局事务 是指用户客户端连接到 分布式数据库系统后发起和执行的事务，也就是 处理的分布式事务。一个全局事务可能会写入数据到多个后端 数据库实例，每个实例上面的本地事务都是这个全局事务的事务分支 。客户端发起全局事务提交时，运行在 的网关模块中的全局事务管理器会控制该事务访问的所有后端数据库实例完成两阶段提交。
 的全局事务的隔离级别最高可以达到级别，条件是网关与后端连接中设置隔离级别为。在 语句总是使用事务锁做并发控制的情况下本文全部内容均假设使用存储引擎，后文不再赘述，网关与后端的连接中设置的隔离级别就是全局事务的隔离级别。 根据用户在数据库会话中设定的隔离级别的不同， 的全局事务可以达到    或者隔离级别。
一个 集群中可以有任意多个网关实例，并且连接到每个网关上的客户端连接都可以发起分布式事务。并且我们为了避免网关实例之间的通信开销和因此导致的脆弱性，网关被设计成不做任何实例间通信。但即便如此，只要所有连接都是用隔离级别那么 执行的事务仍然可以达到可串行化隔离级别。
 全局可串行化
为什么本地事务以隔离级别运行就可以确保全局事务的隔离级别？在介绍如何做到这一点之前，先介绍一下 的网关的两点重要的内部设计：
  独立的后端连接
对于连接到网关的每个客户端连接，网关会向这个连接当中的语句访问的每一个后端发起一个独立的连接。并且每一个变量设置会传播到后端的所有连接中。比如，如果你在客户端设置了 _=”” 那么这个设置会被网关设置到你的客户端连接对应的每一个网关与后端的连接当中。
 语句串行执行
网关解析一条语句后如果决定发送处理后的语句到多个后端，那么这个发送操作是并行的，也就是不需要等待每个返回结果就会发到下一个。但是，只有收到全部本条语句的执行结果并且汇集后，才返回结果给客户端。然后，网关才会接收和处理下一条客户端发过来的语句。
上面两点看似简单平常，但是它们是网关能够保障每个后端的局部事务调度结果产生相同的全局事务调度结果的关键。
举例来说，假设有并发执行的全局事务和，它们的隔离级别都被设置为，根据，网关与后端的连接上面隔离级别也都设置为了。和在上面更新同一行，并且在上各自插入不同的插入一行，事务分支  { }，{ }。

由于与并发更新同一行，如果先更新，那么会拿到=的那行标注为的事务锁直到结束提交才释放，然后才能拿到的行事务锁开始执行，然后执行。所以执行顺序就是 ；类似地，假如是先拿到了的行锁，那么执行顺序就将是 。也就是说，运行在每个实例上的事务锁调度机制可以确保全局事务的串行执行。
我们可以得出这个推论：全局事务的本地事务分支的依赖关系也是全局事务的依赖关系。这里的依赖关系就是事务锁的等待关系。按照上例来说，先拿到的事务锁，那么就依赖于，于是也能够导致依赖于。也就是说这点是成立的：
   ==   
网关内部设计“ 语句串行执行”正是确保这点的关键。
根据数据库事务处理的基本理论，如果某个并发事务调度机制可以让具有依赖关系的事务构成一个有向无环图，那么这个调度就是可串行化的调度。由于每个后端都在使用隔离级别，所以每个后端上面并发执行的事务分支构成的依赖关系图一定是。使用上面的推论，每个后端上面并发执行的事务分支的依赖关系图通过图的合并操作就自然形成了 所处理的并发执行的全局事务的依赖关系图；如果这个图是一个有向无环图，那么这些全局事务一定是在可串行化隔离级别下运行的；如果有环，那么在隔离级别下一定则会发生死锁，并且很可能是全局死锁，那么死锁处理机制和 的全局死锁处理机制就会解除这些死锁。我会另外撰文讲解 的全局死锁处理机制。
如果一个事务在隔离级别下运行，它的读锁在当前语句结束后就释放；在隔离级别下，其读锁在事务结束时刻才释放。根据上面的推论，可以轻易得出：对 来说，其本地事务在隔离级别下运行时， 的全局事务也是在隔离级别下运行。
 假想基于的全局可串行化机制
使用隔离级别时就不再使用做查询了，而是基于锁，即使你不在语句中加上    。如果要基于实现  的可串行化隔离级别是有巨大代价的，这个代价主要是集群的性能损失以及可靠性损失。因此我们并没有这样做。不过出于技术探索的兴趣，我们可以想想假如要做到这一点应该怎么做，有什么问题。
为了实现可串行化隔离级别，我们就需要一个全局事务分发机制或者队列产生全局顺序。比如的就是全局事务生成器，而这个实例就是一个单点故障源。即使再为它实现容灾，它也仍然是一个性能和可扩展性瓶颈。
同时，由于 使用做除了和    子句，还需要将这个全局事务给予做事务，同时，还需要 集群的多个的 共享各自的本地事务状态给所有其他这也是 所做的，任何一个的本地事务的启动，，，都需要通知给所有其他实例。只有这样做，集群中的每个实例才能够建立全局完全有一致的、当前集群中正在处理的所有事务的状态，以便做多版本并发控制。这本身都会造成极大的性能开销，并且导致之间的严重依赖，降低系统可靠性。这些都是我们要极力避免的。
 语句的数据一致性
如果 的连接上面隔离级别不是并且 语句不使用    子句的话，其实使用的是多版本并发控制 。但是在使用分布式事务的情况下，使用是有问题的。
这是因为 的只针对同一个进程内的事务有效，并不能知道一个本地事务分支所属的全局事务在其他实例当中的事务分支的状态   ，因此有可能查询到一个未完全提交的全局事务的改动只有本地事务分支完成了提交，其他实例上面还没有完成提交。归根到底的原因是无法得到全局一致性快照，但是如上节所述，全局一致性快照的维护代价极其昂贵，并不适合系统。
举例来说，假设有并发执行的全局事务和，它们在和的分支分别是 { }，{ }，并且在和上面查询的行和更新的行都有交集。 做跨 的时，正在提交。如果使用的话，网关发送的语句到上面时，的快照包含的改动，因为在上面启动的时候此刻已经完成本地提交；网关发送的语句到上面时，的快照不包含的改动，因为在完成提交之前就已经启动了。这样的话，的这个语句就会查询到的的更新，而还没有提交完成因为的还未完成提交，所以的这个语句不包含的的更新。也就是说读取到了的一部分更新但是本应该读到的另外一部分更新结果却因为尚未提交而没有读取到。这就是一个一致性问题。在使用事务锁做的情况下，这个问题就不会出现了。
本例中如果的语句本来也只会访问到上面的数据，那么尽管并未完成提交，那么对于 来说也不算是一致性问题，这是因为在 中，只要 中记录好了要提交的事务就一定会完成提交，所以尽管读取到的改动时还没有完成提交，但是一定会提交，并且也并不需要不可能读取到当中未完成提交的事务分支的更新，也就是说读取到的是完整的稳定的可靠的结果。在使用事务锁做的情况下这个现象仍然会出现，无论使用的是哪个隔离级别，但是这是完全没问题的。以本例具体来说，如果只在上面运行，并且与有事务锁冲突，那么只要完成提交，那么就可以继续执行，即使此刻还没有完成提交。由于必然会完成提交并且所使用的的更新是稳定可靠的并且时完整的，所以可以正确地执行。
在使用做查询的情况下，做两阶段提交的全局事务只能做到最终一致性，有可能读取到没有完全提交在所有参与的上都完成提交的的部分改动。一般情况下，这个不一致的时间窗口很小；需要提交时会时间窗口会比较长。对一致性要求高的话，就是用隔离级别。
 解决方案
为了解决上述问题，事务做就不能使用。这需要每一个语句使用锁来做并发控制，具体由两种办法，最简单的就是在网关与后端的连接当中设置隔离级别是，这样所有的自动都是加共享锁的。或者客户端对每个语句都显示使用加锁子句：       也可以。这样就可以读取一致性的数据，并且这样的好处是你可以在  或者 隔离级别下对使用事务锁以便确保的数据一致性，缺点是对于现有应用来说需要修改所有的查询语句。对上面的例子来说，这么做以后，到上面做查询时候会被阻塞，直到也完成提交，也就是完成提交。这样查询到的结果就是已经提交的事务的结果。如果只会查询到上面的数据也就是说不存在，那么尽管在提交完成之前就有可能读取到它在上面的改动，但是如前所述这是没问题的。
 结论
在 语句总是使用事务锁做并发控制的情况下，网关与后端的连接中设置的隔离级别就是全局事务的隔离级别。 的全局事务可以达到    或者隔离级别。
如果使用的话那么可能会有查询结果的数据一致性问题，这些问题可以通过让获取事务锁来避免；如果使用事务锁会更多地增加死锁的发送几率，并且一定程度上降低事务并发性能。这些都是为了数据一致性必须付出的代价。导语： 腾讯云上每天产生大量回源日志，回源日志通常用在问题定位的时候比较有用。这里使用的方案收集、存储日志数据并提供查询。当前的使用场景里，每天有亿条日志需要存储，属于写多读少的场景。本文整理了在搭建集群的时候需要注意的配置项，通过对这些配置项的调整，期望提高写入的性能。

一、集群基本信息
 每天日志量亿
 版本： 
 机器部署

 ： 台
 ： 
 ： 台

二、 写入优化措施及说明
未进行配置优化之前，集群负载非常高，主要表现在磁盘上，写入的在万左右为了提高写入的性能，笔者搜集了官方文档以及一些资料，有如下优化措施。
  _ 

优化点： 减少刷新频率，降低潜在的写磁盘性能损耗
官网解释：                            

 优化

优化点： 减少写磁盘的频率

{
   {
       {
          __ 
          _ 
           
      }
  }
}

只有在的时候才会把之前的变更持久化存储到磁盘每次操作都写到磁盘的话，代价太大，在之前如果出现故障，上一次之后的变更都会丢失

为了防止数据丢失，会把变更操作都记录在里，在出现故障的时候，从上次起记录在里的变更都可以恢复，尽量保证数据不丢失

的操作就是执行一次，同时开始记录一个新的，所以是用来记录从上次到下一次之间的操作的

操作的频率是通过的大小控制的，当大小达到一定值的时候就执行一次，对应参数为__，默认值是，这里调整为，减少的次数

本身是文件，也需要存储到磁盘，它的存储方式通过和_设定。默认情况下，=，意为每次请求都会把写到磁盘。这种设定可以降低数据丢失的风险，但是磁盘开销会较大

这里采用异步方式持久化，每隔秒写一次磁盘


  

优化点： 放开操作，加快合并，防止因为滞后导致操作被限速

的文档关于这个参数的解释：操作首先会生成很多小的，会有异步逻辑合并这些操作比较消耗，当系统性能比较差的时候，会影响查询和索引的性能。和___可以在节点级或者级限制操作消耗的磁盘带宽，防止因为导致磁盘高负载，影响其他操作

另一篇关于 调优的文章里讲到，如果不关心查询的性能，可以把设为，意为不对操作限速这个参数默认配置是针对操作限制使用磁盘带宽


 __ 

优化点： 减少并发并发对磁盘的消耗

由多个组成，每个又分成很多，是数据存储的最小单位

执行索引操作时，会先生成小的

比较多的时候会影响搜索性能要查询很多，有离线的逻辑对小的进行合并，优化查询性能。但是合并过程中会消耗较多磁盘，会影响查询性能

__控制并发的线程数，如果存储是并发性能较好的，可以用系统默认的    ，普通磁盘的话设为


 __ 

优化点： 降低被动写磁盘的可能性

该配置项指定了用于索引操作的内存大小，索引的结果先存在内存中，缓存空间满了的话，缓存的内容会以为单位写到磁盘。显然，增大缓存空间大小可以降低被动写磁盘的频率


三、 优化思路梳理
 目标： 优化性能
 主要降低性能的因素： 磁盘基于观察，负载非常高
 哪些操作在消耗磁盘

 不确定有没有写磁盘，待确认
 
 
 不足导致被动写磁盘
 

关于 有两个调整，减少并发的线程数，放开的磁盘带宽限制。这里猜测是因为，操作是要做的，但是并发的比较耗磁盘，折中的方案是减少并发，加强单线程
四、 测试
以上配置全部用上之后，集群负载瞬间降低了，但是不清楚是哪个配置，或者哪些配置的影响比较大，下面通过测试确认了这些配置的影响
 测试方法
使用现网流量进行测试将上述全部优化项启用的时候作为基准，分别禁用单个优化项，观察写入性能和集群负载
 测试日期：
 测试数据



对比组
时间

负载
说明




基准






并发线程数设为默认



刚修改配置有个小凸尖，随后平稳


禁用优化



暴跌，负载猛增


 使用默认值



比基准微降，负载微曾


开启限流



和基准持平



 压测
按照所有优化项开启的设定，使用 开启多线程向集群发起 请求，同时观察 界面，发现 达到，随后集群很快挂掉。
五、结论
以上测试可以看到

优化禁用的时候集群负载最高，写入性能最差
 操作对写入的性能略有影响
 对写入性能影响非常小

附录
 存储节点完整配置
 
__ 
   
__ 
 {}
__ 
 
    _
    _
    _
    _
    _
    _
    _
    _
    _
    _
    _
    _
 
 
__ 
_ 
 
 
 
___ 
 
___ 
 __
 
__ 
___ 
__ 

  配置
{
   
   
   {
     {
      _ 
      __ 
       {
        __ 
        _ 
         
      }
      __ 
    }
  }
   {
    __ {
      _ 
        {
          __ {
             {
               _
            }
            __ 
          }
        }
      
    }
  }
   {}
}

结语
以上欢迎各位交流，有不合理的地方欢迎指正抱拳作者：冯博渊

一、写在前面的话
互联网产品的迭代速度之快，各位都深有体会。做为产品质量的保障者，测试人员经常为测试时间不足而烦恼，如何打破现状来让现在变得更好一些，这是我们一直在思考的问题。软件工程中有提到测试人员越早的介入到研发的流程当中，就可以越早的发现问题，从而降低发现问题的成本。因此左移变得非常的有必要了起来，当然左移的方式有很多，例如前几天拜读到的《聊聊测试“左移”那些事》这里面主要讲测试人员通过把控需求来达到左移的效果，而我今天要谈的是自动化的左移。
二、我眼中的自动化左移
想想之前我们做的自动化是怎么做的呢？在版本提测之后，我们开始写自动化，这样自动化的主要功能就变成了回归和冒烟。我这里我想说的是在开发写代码的时候，我们也开始写用例级别代码，在开发定义了界面布局后，我们就可以完善具体代码，待开发提测时，我们就可以运行我们的用例来进行测试了。如何才能做到这一点呢？那你就需要让你的自动化用例高度的抽象出来，这里呢，我的同事建议我们使用一种基于关键字驱动的用例方法，我们首先来看看类图：

稍微解释一下这些模块
 
所有类的基类，也就是测试用例的基类，里面实现来启动，如果有需要的情况下可以实现和，这两个在整个命令的运行周期内只在开始和结束的地方执行一次。
用例
具体的测试用例的实现类，这个可以理解为一个测试集，每个类中有若干函数，每个函数就代表一个测试用例，用例的写法采用关键字驱动的方法。

用枚举定义着所有的关键字。

接口类，供实现的方法。

基类，供层来继承，里面只封装了一个 ，主要用在中调用的实现；这里需要注意和接口中的区别。
层
即图中、等，需要实现接口中的函数，同时继承自，解释为什么是层，这里需要把这些实现抽象成简称、简称，而这两者的区别就是，中实现可复用的一些场景，中可以包含，实现一些很少被复用的场景。

将中关键字和具体的实现的函数进行关联，构造一个，使得直接通过关键字就能调用起对应的函数。
具体实现的代码我先不详细解释，我们先来看看使用这套框架后，之前实现同样功能代码写成了什么样子。
老代码

新代码

可以看到，测试用例这里认为一个函数就是一个测试用例这一层我们做了高度的抽象，在这个函数中没有任何与开发源代码或者是资源有关的信息了，这里的就是我们的关键字，具体的实现在这个的函数中。
三、封装框架
当然为了保证自动化的稳定性，我这里也对框架进行了再封装。这里我使用了谷歌推荐使用这两款框架和，有兴趣可以看看谷歌的这两篇原文：

那么两个框架同时加入到我们的测试工程应该如何去整合代码结构内，这里我自己使用这样的结构，觉得不错的可以稍微看看，首先先看下类图：

看完类图后可能有些人已经看出来啦，没错这里使用了简单工厂模式，具体的层来使用工程加工出来的对象，具体的工具封装内容包装在和里。
这里主要说下针对的封装，如果之前读过我写的《手把手教你搭建安卓自动化框架之》的“如何更高效”章节，那么里面的一些思想应该比较清楚了。
主要优点
、页面跳转或者异步加载延迟出现的界面，无需再单独使用；

、对于系统随机出现的可能会影响界面的一些因素例如的授权弹框、电话呼入，无需再单独处理；

、对于中随机出现的可能会遮挡正常界面的一些弹框，无需再单独处理；

、所有调用封装后框架的操作，都会记录日志；

、框架本身有断言能力，如果在框架处理异常情况后还找不到指定控件，这时候会截图并且断言；

、如果需要替换框架或者框架升级，可以使用最小的成本来框架层进行改动，而不需要改动用例层和层。
当然和之前的不同就是里面也借鉴了关键字驱动的思路，有兴趣可以看看代码。
四、结果展示
上面主要讲的是自动化的一些行为操作，关于断言的问题，我这里不想说太多，做到界面上的元素的检查，以及整个流程是否可以完整的走下来就可以了，如果需要验证数据正确性等一些复杂的内容，可以使用的这个组件去验证，具有参考： 。我这里说说自动化如果失败了，我们怎么排查问题？其实很简单我这里做的就是日志截图。
日志系统最关键的是打日志的时机，这里我把它埋到了的中，这样每一次的用例调用或者中调用，都可以记录下来，同时也埋到了框架的具体实现函数中，这样框架只要操作就会记录下日志。这里有个小的技巧，我在打印日志的地方调用了下面的函数：

这样就可以记录下当时调用函数的当前的类的名称了，这里可以看下我输出的的样子：

是不是比较齐全了，基本上所有你想知道的信息都可以通过内容来获得了。下面说说截图，截图和的整体思路一样，会在一些关键节点埋点同时也支持手动调用。因为我的工具框架是支持自身断言的，因此我在工具框架这一层断言的时候会加入截图，其他地方如果你需要特别关注的时候，也可以手动调用截图触发。

上面的图是不是非常直观，当我们的用例出现异常错误的时候，直接通过和日志即可定位到问题的所在。测试结果最终对接了内部的持续集成平台和结果展示平台后是这个样子：

保证了编译器中的结果和结果展示平台中显示的情况一致。
五、实践应用
我们来看看针对新老需求如何应对。
如果是新需求的情况下，我们在需求确定的情况下就可以先组织自己的用例了，具体实现依赖开发的层的代码可以先空着，待开发确定之后，我们就可以及时的完善我们的层，这样不用等到开发提测之后，我们才开始设计我们的自动化测试用例。
对于老的需求变更，同样也是，首先可以看之前的用例中的关键字是否有可复用的东西，如果可以直接复用，那就继续用，如果有新的步骤加进来，那么只需要加入对应的关键字即可，和新需求的做法一样，同样在开发提测之前完成用例的编写。这里闲贝在版本迭代中，有一个发布页面的变更，由两个页面合并为一个页面，部分小地方也有所修改，如下图所示：

改成了：

然而在新版改版后，用例根本不需要变化，还是保持之前的样子，只是把对应的层中的一些代码进行了一些细微的调整。
六、会有收益吗？
在整个方案启动之前，我就在思考这个问题。那么这个做出来后究竟会有收益吗？究竟有没有收益，需要分析后才能知道，于是针对最近的一次版本做了一个简单的分析：

从数据中可以看到，的确有一部分的是可以在左移阶段被发现的。这里分为级别的用例和详细模块的用例。级别用例来限制开发的提测，提测前开发自己去运动这部分用例，通过才可以提测；具体功能级别的详细模块的内容用专门针对这个版本修改或者新增的新功能。
整个方案在实现后，只勉勉强强在一个版本中进行了实践，因为某些因素，项目被叫停了，唯一的这次实践也是在一个相对不正规的不完整的版本上做的，即便如此左移实践以来共发现个有效，这也是我在标题中打了一个问号的原因。虽然最终有些可惜，但是整个过程中还是学到了不少东西，拿出来和大家进行分享，希望能帮助到其他人。

原文链接：__


相关推荐【腾讯】敏捷测试快速俘虏产品  开发如何快速从学生党变身云计算达人【腾讯】测试分析？就这么简单！前段时间做了一个基于  和  对比的粒子效果丢在学习  的  群里，技术上没有多作讲解，有同学反馈看不太懂  版本，干脆开一篇文章，重点讲解基于  开发的版本。
一、概况

废话不多说，先丢上，用移动设备更能明显感觉性能差异。
维护粒子位移、颜色、尺寸：









版本
版本



维护粒子位移：









版本
版本



结论：
同时需要维护多种粒子特征变化时，有明显优势。只是维护粒子位移时，版本稍流畅，但优势并不明显。当然，这还得具体到设备，一些中低端机器，太渣，不如计算。
二、技术实现
中，粒子效果的实现方式大概分为三种：
、直接计算粒子的状态变化，即基于实现；、通知顶点着色器粒子的生命周期，由顶点着色器运行，即基于实现；、粒子生成与状态维护全部由片元着色器负责，即屏幕特效，同样是基于中实现。第种方式本文暂不介绍。
、基于实现
护位移、颜色、尺寸：
维护位移：

步骤：
首先加载由三维软件制作的几何体，然后生成粒子系统 。
  =  { }
  =    
从代码中可以看出，材质是针对整介粒子系统设置的，所以只能维护粒子位移。
如果要维护粒子颜色、尺寸呢？
我们必须为每个粒子设置不同的材质，由此也造成不小的性能损耗 。
步骤：
使用修改所有顶点位置。
 =  { } 
 {
      = 
      = 
      =      {
          = 
         =       
         =       
         =       
    }
     = 
}
从代码中可以看出，粒子的状态都是通过，由来计算。
、基于实现
维护粒子位移、颜色、尺寸：

对比实现流程图，我们会发现，并不直接计算所有顶点位置，而是只通知动画运行时间，由顶点着色器来完成具体运算。
既然运算部分在顶点着色器，那么，需要我们自己书写着色器 ，所以我们选用中的。
步骤：
首先生成粒子系统：
  = {
    {   }
     { }
}
  =  {
         
       
     
           
          
        
}
 =   
是连接与着色器的通道。
 即由来维护的动画运行值。
和，即我们要定义的顶点着色器，和片元着色器，它们负责具体的粒子状态的运算，我们定义在网页中。
步骤：
定义顶点着色器：
    粒子尺寸
    目标顶点位置
    动画运行时间
    将顶点位置传输给片元着色器

  {
     计算粒子位置
     =       
     =      
     =      
     坐标转换
      =      
    _ =       
    _ =   

}
内置，自动传递给顶点着色器的变量：   顶点坐标   模型视图矩阵   投影矩阵
定义片元着色器：
  
  

  {
     计算粒子颜色，通过位置
      =   
     = 
     = 
     = 

    _ =   
     顶点贴图
    _ = _    _ 

}
 步骤：
负责维护粒子运行时间：
 =  { } 
 {
     = 
}
三、延伸阅读

类做了什么？

其实真没干什么，主要是申明它的是。当我们执行渲染时，会绘制，即调用…而通常，比如为时，会调用…

类做了什么？

同样，点材质也是最简单的类之一，相对于基类，它多做的事情只是传递了，即点的尺寸这个值。 月  日，腾讯“云未来”峰会进入到各专场的环节。来自珍爱网的技术副总裁范成涛参加了“互联网专场”，并向与会的其它行业朋友介绍了珍爱网背后的技术支撑以及腾讯云在珍爱网发展过程中在技术方面功不可没的襄助。
以下是来自范成涛先生在互联网专场的演讲内容整理未经分享者本人审校。

范成涛：大家好，我是珍爱网的技术副总裁范成涛，讲点我自己的感悟，技术细节就不展开了。

“珍爱网”业务介绍
今天我分享的演讲题目是用云助力亿万用户寻找幸福。珍爱是一个专注于婚恋服务的公司，现在有一亿的高诚意会员，就是定向投放年龄到岁以上，想去结婚，且经济能力比较强的人。从年开直营店，目前已经有家，珍爱网的直营店的面积都比较大，每个直营店投入也都比较大。目前有超四千位专业红娘，提供专业一对一的红娘服务，每个渴望爱的人都值得珍爱。

婚恋现在有的三个业务：

线上自助服务
线下直营店人工红娘服务
电话红娘服务


业务急速发展下的四大技术难题

海量信息的存储
跨运营商访问导致速度不一，影响效率
信息安全机制
业务弹性更好

近两年业务发展非常快，每年都有甚至是翻倍增长，我作为技术负责人就会面对到一些困难，主要困难是几个点：一个是海量信息的存储，因为每个人相亲都要充分展示自己，介绍自己，每个人上传很多图片甚至视频，我们有很多用户的图片、视频以及门店的销售和红娘见面的信息，信息量的激增非常快，当信息量激增的时候就有海量存储的问题，因为信息存储跟社交不一样，数据复杂量很大。
第二就是跨运营商访问，开店越来越快之后，每个门店混淆不一样，用的运营商也不一样，而我们的员工工作的时候效率很重要，像北京的机房，有时候速度不一样，很影响效率。
第三就是信息安全机制，我们作为一个高端的严肃的婚恋，怎么保证用户的信息是安全的，这是第一。第二，大家很信任，把资料传到我们这，因为婚恋比较特别，用户在我们这注册以后，在我们服务过程中，他会告诉我们非常详细的信息，家里几头牛，几亩地，房子是贷款五十万还是贷款一百万都会告诉我们，因为他要找老婆。信息一旦详细，我们责任就更大了，所以怎么保证信息安全。同时，既然是婚恋，就永远免不了在网上有一些图谋不轨的人，有一些婚托婚骗，怎么把他们挡在门外。
第四个是业务弹性更好，因为自己业务发展很快，也在做一些创新业务，当我们这样做的时候，我们要机器扩容、上架下架，而我们的反应没有那么快，这些都是我的困惑。后来跟腾讯云的同事交流吃饭的时候，他们说可以帮助我解决这个问题，所以我们就开始用了，后来真的解决了。

腾讯云的四大助益

微服务化
图片存储
释放更多运维成本
性能的提升

因为珍爱是一个进行了十年的公司，说服公司往云上迁的时候没有那么简单，我讲几个持续在用的时候解决的场景：
现在用腾讯云用到了微服务化，比如说智能、负载均衡、云缓存等等，在之前我一直忙数据的同步、冷备、热备、访问性能，现在我们把业务迁到云上以后，腾讯云的确实比我们的性能高很多，其他的事情他们帮我们忙活，我们不浪费任何一个子弹，都交给了腾讯云，包括用他们的，异地访问基础，现在的效率、性能、投入都变得很好。
第二是图片存储，因为我们有上亿的用户，每人都有八到十张甚至更多的图片，因为刚刚开始做这个事情的时候，涨到了一组图片，后来要维护，要更新，我们就迁到了云上，它解决了小文件备份问题，小文件的备份拷贝是很痛苦的，这个我不管了，让他们操心去了。
第三就是释放更多运维成本，服务可用性满足个。
第四个是性能的提升，我们自己测了一下，比我们自己在全国各地访问的速度更高，用户的感觉也好了，体验好了，收入就上升，所以我们就把子弹花在了让收入上升的事上了。

语音质检对服务的改善

简化人力成本
实现、服务质检标准化

有一个智能语音质检，因为珍爱是一个高端婚恋服务公司，我们的高端婚恋服务有一对一的红娘服务、对话，几千个红娘怎么保证每一个红娘的服务是规范的？我们跟腾讯合资，上了一套语音质检，以前是人质检，语音质检有个特色，我那有三四千个人打电话，我这里必须有三四千个人听电话，这个人力成本支出相当直达，以前有一个一百人团队听电话抽检，抽检的概率是分之一，我们的员工就撞大运，反正四十个人才抽一个，不一定抽中我，现在通过机器的方式就是全检，一组服务器加一个人就实现了全检。第二，以前的一百个人是有情绪的，今天质检员他开不开心，开心就好一点，不开心就差一点，这是有非标的，现在有标准了，系统是进步的，质检是在积累的东西，现在量提升了几十倍，违约也一直在下降，整个服务变得更好了。

“云安全”对高端体验环境的保障
这个案例是安全，因为我们是一个的生意，线上我们要注册，就会有一些图谋不轨的人，当他来的时候，对高端用户体验是非常大的伤害，以前是靠网警能力去查，靠我们的销售，因为我们的红娘会见面，见面的时候甄别，怎么去防止这样的用户有这样的技巧，这样的人力成本支出也很大，也是非标，后来跟腾讯云合作，跟云安全进行合作，现在已经做到了的恶意用户注册就别来了，第二有了他的行为和信息以后，很快就能识别，把绝大部分图谋不轨的恶意用户挡在了门外，让这个环境变得更简单，我们的用户也不会被伤害，这对我们的价值也非常非常大。

期待与“腾讯云”更深远的合作

三个问题消除老板疑虑
需求推动下的技术创新

前面我主要讲了几个我们在用的几个案例，其实目前在跟腾讯云的合作是远远不止这些，在很多方面我们都在探讨合作，因为好多服务是十年以前写的，所以迁移过程会慢一点，我们计划在年把所有服务都迁到云上来。接下来我们计划跟他们在更多方面用他们的业务，比如说在图片上，比如说在视频上，比如在人工智能上，让我们的四千人干出八千人的活，我们在这方面都会做一些合作和探讨，我相信这里面有很多的机会，会让我们的业务做得更好，这里面我们也分享我们在用云的过程中的感受：
第一个感受：相信是这件事情的基石，我们一开始是怎么说服我们的老板上腾讯云，一开始公司有很多反对的声音，因为我是三年前加盟这个公司的，他们说，我们干了十来年，如果一下子出现安全问题，各种声音，不太相信。后来我问了老板三个问题，第一个问题，你现在不想用云，你目前托管在别的运营商的机房，就一定安全吗？老板说不一定，我说第二个问题，万一出了安全问题，我们去跟腾讯打一场官司，你吃亏吗？他说不吃亏。第三，数据会加密，你不相信吗？他说相信，这三个问题都解决了，用了一年之后我们发现确实是很顺畅，往往是所谓的不相信，是我们自己很难去跨越的门槛，当我们一旦跨越，相信以后，是很大的天空，因为相信所以简单，因为简单所以有成果。
第二个感受，我们在用的过程中不仅仅是用，还会有创新，我们在用的过程中，腾讯经常上门拜访，我们有很多的交流，每次跟他们交流的时候，我们想干什么，而不是他们有什么，这是很创新的地方。比如说刚才的语音质检，这就是我们开始提了需求以后，他们觉得腾讯有语音识别技术，他们就去研究了，后来他们还推出了产品，对他们有帮助，对我们也有帮助。在四五月份的时候，出现了一次南北网络的断网，这对我的业务很大伤害，既然运营商网络断网了，我在腾讯云上马上搭了两层代理，从腾讯的链路上让别人能够访问我们的业务，很快就解决了，因为我们不断创新，不断思考他能给我们带来什么帮助，这对我们有帮助，对腾讯也是有帮助的，所以创新是我们一起能走得更远，走得更好，产生更大价值的动力。
为什么选择“腾讯云”

专业
服务的意识
永不停息的“一股劲”

再说为什么选择腾讯云，我觉得腾讯云跟珍爱有相同的一些基因。第一个是专业，腾讯积累了年的技术，有亿万用户的管理后台技术，而珍爱也一直在婚恋上积累自己的经验，一直坚持人工服务，我们相信专业。第二个就是服务的意识，当我们开始使用腾讯云的时候，他们小时支持，经常上门问我们有什么困难。第三个就是我们都有永不停息的一股劲。我相信接下来腾讯云的功能会越来越我，业务越来越强，对我们的支持和帮助也会越来越大，我也相信珍爱在云的支持下，业务会越走越好，谢谢大家。作者： 

背景
当一个发布之后，突然发现了一个严重需要进行紧急修复，这时候公司各方就会忙得焦头烂额：重新打包、测试、向各个应用市场和渠道换包、提示用户升级、用户下载、覆盖安装。有时候仅仅是为了修改了一行代码，也要付出巨大的成本进行换包和重新发布。这时候就提出一个问题：有没有办法以补丁的方式动态修复紧急，不再需要重新发布，不再需要用户重新下载，覆盖安装？虽然系统并没有提供这个技术，但是很幸运的告诉大家，答案是：可以，我们空间提出了热补丁动态修复技术来解决以上这些问题。
实际案例
空间独立版发布后，收到用户反馈，结合版无法跳转到独立版的访客界面，每天都较大的反馈。在以前只能紧急换包，重新发布。成本非常高，也影响用户的口碑。最终决定使用热补丁动态修复技术，向用户下发，在用户无感知的情况下，修复了外网问题，取得非常好的效果。
解决方案
该方案基于的是 分包方案的，关于分包方案，网上有几篇解释了，所以这里就不再赘述，具体可以看这里简单的概括一下，就是把多个文件塞入到的之中，但是 拆包方案中的类是没有重复的，如果和中有重复的类，当用到这个重复的类的时候，系统会选择哪个类进行加载呢？让我们来看看类加载的代码：一个可以包含多个文件，每个文件是一个，多个文件排列成一个有序的数组，当找类的时候，会按顺序遍历文件，然后从当前遍历的文件中找类，如果找类则返回，如果找不到从下一个文件继续查找。理论上，如果在不同的中有相同的类存在，那么会优先选择排在前面的文件的类，如下图：在此基础上，我们构想了热补丁的方案，把有问题的类打包到一个中去，然后把这个插入到的最前面，如下图：好，该方案基于第二个拆分的方案，方案实现如果懂拆分的原理的话，大家应该很快就会实现该方案，如果没有拆分的项目的话，可以参考一下谷歌的方案实现。然后在插入数组的时候，把补丁包插入到最前面去。好，看似问题很简单，轻松的搞定了，让我们来试验一下，修改某个类，然后打包成，插入到，当加载类的时候出现了本例中是要被替换：为什么会出现以上问题呢？从的意思上来讲，引用了，但是发现这这两个类所在的不在一起，其中：

在中
在中结果发生了错误。这里有个问题拆分的很多类都不是在同一个内的怎么没有问题

让我们搜索一下抛出错误的代码所在，嘿咻嘿咻，找到了一下代码：从代码上来看，如果两个相关联的类在不同的中就会报错，但是拆分没有报错这是为什么，原来这个校验的前提是：
如果引用者也就是这个类被打上了_标志，那么就会进行的校验。那么这个标志是什么时候被打上去的？让我们在继续搜索一下代码，嘿咻嘿咻，在找到了一下代码：这段代码是转化成的代码中的一段，我们知道当一个在安装的时候，中的会被虚拟机优化成文件，然后才会拿去执行。虚拟机在启动的时候，会有许多的启动参数，其中一项就是选项，当选项被打开的时候，上面变量为，那么就会执行进行类的校验，如果校验类成功，那么这个类会被打上_的标志，那么具体的校验过程是什么样子的呢？此代码在中，如下：

验证方法，包含了以下方法：
方法
方法
构造函数





虚函数=方法



概括一下就是如果以上方法中直接引用到的类第一层级关系，不会进行递归搜索和都在同一个中的话，那么这个类就会被打上_：所以为了实现补丁方案，所以必须从这些方法中入手，防止类被打上_标志。最终空间的方案是往所有类的构造函数里面插入了一段代码，代码如下： _ {
    
}

其中类会被打包成单独的，这样当安装的时候，内的类都会引用一个在不相同中的类，这样就防止了类被打上_的标志了，只要没被打上这个标志的类都可以进行打补丁操作。然后在应用启动的时候加载进来类所在的包必须被先加载进来不然类会被标记为不存在，即使后续加载了包，那么他也是不存在的，这样屏幕就会出现茫茫多的类找不到的。所以作为应用的入口不能插入这段代码。因为载入的代码是在中中执行的，如果在的构造函数里面插入了这段代码，那么就是在加载之前就使用该类，该类一次找不到，会被永远的打上找不到的标志其中之所以选择构造函数是因为他不增加方法数，一个类即使没有显式的构造函数，也会有一个隐式的默认构造函数。空间使用的是在字节码插入代码而不是源代码插入，使用的是库来进行字节码插入的。隐患        虚拟机在安装期间为类打上_标志是为了提高性能的，我们强制防止类被打上标志是否会影响性能？这里我们会做一下更加详细的性能测试．但是在大项目中拆分的问题已经比较严重，很多类都没有被打上这个标志。如何打包补丁包：

空间在正式版本发布的时候，会生成一份缓存文件，里面记录了所有文件的，还有一份混淆文件。
在后续的版本中使用选项，应用正式版本的文件，然后计算编译完成后的文件的和正式版本进行比较，把不相同的文件打包成补丁包。备注该方案现在也应用到我们的编译过程当中编译不需要重新打包只需要把修改过的类的文件打包成 然后放到下那么就会让改变的代码生效。


文章来源公众号：空间终端开发团队


相关推荐
微信热补丁实践演进之路
【腾讯】不会做分析？套路走起作者介绍：熊训德 腾讯云工程师

 的  机制是保证  使用  树存储模型把随机写转化成顺序写，并从内存  数据，从而提高大规模读写效率的关键一环。 的多生产者单消费者的线程模型让的写入变得安全而高效。
在文章《在调用过程》中从代码层面阐述了一个  的“写”操作是如何到达的，又是如何真正地写入到  文件，再写入到  。但是  是支持  机制的存储系统，本文档将说明  是如何把多个客户端的“写”操作安全有序地落地日志文件，又如何让  端优雅地感知到已经真正的落地。
 为了高效安全有序的写入，笔者认为最关键的两个机制是  中使用的线程模型和多生产者单消费者模型。
线程模型
其线程模型主要实现实在中，是接口的实现类，实现了最关键的和方法，其模型如图所示：

这个图主要描述了中调用和后的线程流转模型。最左边是有多个提交到的和操作。
当调用后和会被封装成类进而再封装成类放入一个线程安全的  中。
当调用后会生成一个进而封装成类同样放入这个中，然后工作线程此时会被阻塞等待被唤醒。在最右边会有一个且只有一个线程专门去处理这些，如果是则写入 文件。因为文件缓存的存在，这时候很可能数据并没有落盘。所以进一步如果是会被批量的放到一个线程池中，异步的批量去刷盘刷盘成功后唤醒工作线程完成。
源码分析
下面将从源码角度分析其中具体实现过程和细节。
工作线程中当准备好一个行事务“写”操作的，，后就会调用的方法：

的方法首先会从  中拿到一个序号作为，然后把和等构建一个实例，并把放到中。而以，实际存储类型通过和一一对应。

如果设置的持久化等级是_，_或_，那么工作线程的还将调用的方法：




追踪代码可以分析出方法会往中放入一个对象，并阻塞等待完成唤醒。
像模型图中所展示的多个工作线程封装后拿到由生成的后作为生产者放入中。在中有一个私有内部类类实现了 的接口，也即是实现了方法的的消费者。通过  提供的线程来触发  的事件处理，可以看到的中只启了一个线程，从源码注释中也可以看到在运行中只有单个线程。由于消费者是按照的顺序刷数据，这样就能保证日志并发写入时只有一个线程在真正的写入日志文件的可感知的全局唯一顺序。
 
类的一个回调方法是具体处理和的方法。在前面说明过使用来封装和如下图源码，在消费线程的实际执行方法中就是被通知一个个的从取出，如果是则使用当前文件写入文件此时很可能写的是文件缓存，如果是则简单的轮询处理放入线程异步去把文件缓存中数据刷到磁盘。
这里再加一个异步操作去真正刷文件缓存的原因源码中有解释：刷磁盘是很费时的操作，如果每次都同步的去刷的回应比较快，但是写效率不高，如果异步刷文件缓存，写效率提高但是友好性降低，在考虑了写吞吐率和对友好回应平衡后，选择了后者，积累了一定量通过的的缓存再刷磁盘以此提高写效率和吞吐率。这个决策从存储机制最初采用树把随机写转换成顺序写以提高写吞吐率，可以看出是目标一致的。

这部分源码可以看到类的结构，从注释可以看到选择和一个放入中。
这部分源码可以看到的最终归属就是根据有序的把实例写入文件。这里有序的原因是多工作线程写之前通过线程安全的得到一个递增的，会根据取出并落盘。这样做其实只有在得到递增的的时候需要保证线程安全，而的通过轮询并不用加锁，所以效率很高。具体有关说明和实现可以参考 文档。
 
这部分源码是说明操作的会被提交到中，这里可以注意实例其实并不是一个个提交到中执行的，而是以数组多个实例方式提交的。下面这部分源码是注释中说明批量刷盘的决策。

是一个线程，实际有一个的线程组，专门负责之前到文件缓存的刷盘工作。


的线程方法负责具体的刷写文件缓存到磁盘的工作。首先去之前提交的中拿到其中最大的实例，并拿到它对应的。再去比对当前最大的，如果发现比当前最大的则去调用方法释放，实际就是通知正被阻塞的操作，让工作线程可以继续往下继续。
前面解释了是根据提交顺序过来的，并且解释了到文件缓存的时候也是全局有序的，所以这里取最大的去刷盘，只要最大已经刷盘，那么比这个的也就已经刷盘成功。最后调用当前文件刷盘，并对应的。这样整个写入也完成了。

小结
的机制是保证使用树存储模型把随机写转化成顺序写，并从内存数据，从而提高大规模读写效率的关键一环。的多生产者单消费者的线程模型让的写入变得安全而高效，本文档从源码入手分析了其线程模型为以后更好开发和研究其他相关知识奠定基础。

相关推荐
 的在基本调用过程跨版本数据迁移总结 写入源码分析监控简介

概述 是一个高度集成的网络监控解决方案可以提供 企业级的开源分布式监控解决方案由一个国外的团队持续维护更新软件可以自由下载使用。
工作模式  通过  模式采集数据。通过  模式在  端展示和配置。
监控原理被监控端：主机通过安装方式进行采集本机的数据，网络设备通过协议方式采集数据 监控服务端：通过收集和所采集到的数据，并将数据写在数据库服务器里，最终通过在前端显示出来。
功能具备常见的商业软件所具备的功能，例如：本机的私有数据，内存，硬盘使用情况，本机的公有数据服务，服务，数据库服务等支持自动发现网络设备和服务器可以通过配置自动发现服务器规则来实现支持自动发现  实现动态监控项的批量监控需写脚本支持分布式能集中展示、管理分布式的监控点扩展性强 提供通用接口 功能可以自己开发完善各类监控根据相关接口编写程序实现编写插件容易可以自定义监控项报警级别的设置。数据收集具备实时将监控项绘图的功能

部署平台
之所以部署平台，是因为服务是脚本开发。并且需要将收集到的数据保存在数据库里，和将收集到的数据实时的展示在前端上。因此，我们全部使用源码包构建平台。

安装          安装依赖包
     创建进程属主
      解包   
   
   = =  = __    配置
         编译和安装
    启动服务
          配置网站主页
   
 

安装    _  解包
   _
   
   _  
     _   安装依赖包
   
  __ =  = =       装包
       赋予进程属主权限
     
      =   
   
   
    
    
     
   
   
        创建存放监控系统信息的数据库
           授权登陆创建数据库的用户

安装     _    
     
   
   =     = = =_         配置
            编译和安装
     
        修改
  = 
 __ = 
 __ = 
 __ = 
 _ = 
 ____ = 
    
        生成主配置文件
          启动服务

安装                      添加用户           
         解包
   
     =       =_                             配置
                  编译和安装
        生成监控服务器根目录
   
          导入监控服务器材存储监控数据的表
       
       
     
      客户端访问

登陆面板需要配置的信息，帐号默认密码：         =    =      =  =      =  = _      = __ = __ = 

客户端访问如下：

配置，启动监控服务    
    
    _
   _
     =
   _
     =
   _
      =
      =
      =
  _    
          |  
   _
      =
      =
  _    
      |  


监控实战

使用已有模版监控本机 是  监控的基本载体所有的监控项都是基于  的。步骤如下：通过   来创建监控设备如图：按提示填入 、、 其他选项默认即可。在  处选择一个模板。 即可成功添加设备。在  中会出现监控的主机。重启监控服务端的服务_   。查看是否加亮。加亮则可查看监控状态。结果如图：绘图界面如下：
监控远端主机并且自定义监控项目：监控项：系统用户数    安装——包，启动服务
    
   
       
   
   =      
   _ 
    _ 
   _    修改配置
     =       更改服务器
     =    更改监控服务器
     =        去掉注释
   _      修改脚本根目录
     =
  _     启动客户端服务，端口为
 被监控主机创建自定义监控命令 自定义的文件一般存储在_目录，这里还需要修改_文件，来读取该目录下的所有文件 。
   _
    =_ 
   _
   _ 
    =_   |  { }  获取主机的用户数命令
  _  
  _    _   测试命令是否创建正确
设置监控控制台添加模版通过 创建模板创建应用点击模板后面的链接创建项目选择 创建项目给项目设置名称及对应的自定义将模板链接到被监控主机如图：

启用报警功能设置邮件信息及触发动作创建：找到账户；  通过按钮创建新的；  创建时需要设置的类型，选择类型，则在 后填写接收报警邮件的收件人邮箱；  创建完成后，继续设置该设置邮件服务器信息；
创建动作通过 创建动作创建动作后，为发送邮件报警的行为设置报警邮件的标题、内容等信息设置动作的触发条件创建触发器通过找到之前创建的模板，点击模板后面的来创建触发器 配置触发器监控项目选择之前创建的项目：___，触发器条件是账户数量大于是触发动作，的值设置为触发器规则设置完成后，激活该触发器即可测试效果如图：监控主机用户数绘图如下：监控主页如图：

测试报警功能
    
 
    
  
收取邮件的结果测试如下：邮件内容如下：
                              _   =  
         


 监控总结
防火墙默认区域设置为 设置为 源码安装包时指定进程的属主，属组。   目录必须使得 的属主和属组具有访问权限，否则页面没有权限，显示 所有需要安装的依赖包必须安装。重点不要忘记  包。创建自定义监控项时，必须修改_ 来读取自定义的监控命令文件。、、服务器虚拟主机配置
有时候我们只有一台服务器，大家都知道一个域名对应着一个地址，一个地址或多个地址对应的是一个服务器的网站目录。如果用域名直接访问的话不管怎样都只能访问到一个网站的根目录，其它放在服务器的网站只能靠层级去访问，这样就达不到我们所要的效果。下面就介绍一下如何解决这个问题，用域名访问同一台服务器下的不同网站目录，可以节约我们服务器的网站资源。
首先我们有一个域名  注，两个一级域名不相同也可以使用域名解析服务，添加记录，记录类型 ，主机记录和，记录值为主机的地址。这样我们有两个二级域名    和 现在假设输入 和 分别直接访问两个网站。
服务器虚拟主机配置方法、在中添加网站其中  绑定一栏中的主机名为 ，在分配好网站的文件路径、添加筛选器其中可执行文件位置为的安装位置、处理程序映射添加脚本映射、最后重启服务器，就可以用域名访问了再添加站点，同样的步骤。
服务器虚拟主机配置方法在节点下增加节点
 =  =
            = =

               
                
        
         = 
        

             
               
                     = 
         = =
               =__ =
               =       


 =   =
            = =

               
                
        
         = 
        

             
               
                     = 
         = =
               =__ =
               =       


注在目录下的要创建目录才可以，而且必须大写。在目录先放置代码。在浏览器输入 为的默认端口，修改为的话就不用在网址后缀加了会根据主机名称自动寻找相应的网站目录去访问。
服务器虚拟主机配置方法打开文件去掉 __ __这句前面的号和 这句前面的号 这句在文件底部然后打开\\下的文件，加入如下代码
配置自己的虚拟主机
 
    网站目录，如果在目录下的目录，下面    就填写
     网站目录 
    域名
      
    这里配置欢迎首页面
       
     
     
    不允许别人修改我们的页面
     
    设置访问权限
     
      
       

 
    网站目录，如果在目录下的目录，下面    就填写
     网站目录 
    域名
      
    这里配置欢迎首页面
       
     
     
    不允许别人修改我们的页面
     
    设置访问权限
     
      
       


相关推荐
腾讯云极速配置运行环境
【腾讯云的种玩法】编译下客户端和相关配置
建立网站，从域名注册开始导语
以高并发写入而闻名，而和功能贯穿了的整个写入过程，而只有掌握了和内部逻辑以及控制参数才能根据具体的实际业务场景来调整参数满足业务需要，首先介绍的功能，是把的内存中到存储介质一般是上的小文件合并成大的文件，小文件太多会严重影响的查询性能，的分为和后面会详细介绍，会在的过程中删除过期的以及删除的单元格，该项操作对要求很高如果设置不好会严重影响的性能，是当一个的达到一定大小的时候会对该进行以达到自动分散热点的目的，下面将会就的和进行源码分析以便如何了解设置该部分的功能参数来满足业务需要。
 写入流程
要想了解  的  和  功能必须先从  的写入过程说起，以  的   调用为入口客户端多个  实际会调用到该方法，其具体处理逻辑如下：

如上图，任何一次写请求都有可能触发  或者是 ，下面将就上图各个模块的角色做详细描述，首先看 该类实现所有  的  调用方法。

实现  的  调用，在入口处会做基于用户维度的  控制主要包括读写频率，数据量控制等，这些校验通过后会调用类  相关方法。

写请求达到  后， 首先会加行锁，然后进行  操作，在 操作里主要检查  是否大于 ，其中  由等于 ，
默认值是 ，而参数  大小由参数  指定，该值默认值是 ， 设置的太大在写入量大的时候很可能会导致机器内存耗尽而引发  错误，如果当前  比  大，那么抛出  异常，此时客户端会进行重试，同时并请求刷  动作，请求刷  动作本质是向  的队列里添加刷内存请求，如果  通过，那么将把数据写进  并写 ，在写 看用户策略是否需要成功后更新  版本号数据才对外可见。

 的职责是接受  的刷新请求并调度该请求，在  内部有一个  队列，消费此队列的是 ， 的个数由参数 设定默认值是 ， 从队列  取出需要刷新的请求，从队列里取请求超时时间是参数： 控制该值默认是  秒， 线程在处理的时候如果当前队列为空或者需要立刻刷新，首先会检查当前内存水位，具体示意图如下：

 在处理  请求的时候，会查看当前  的  是否过多，如果过多就会暂停  而进行  操作并阻塞一定时间后才进行  操作，阻塞文件参数由参数  控制该值默认为 ，阻塞时间由参数  控制，该值默认为  毫秒。如果非阻塞则会查看是否需要 ，如果需要  则会发送  请求。
 策略
 有两种分裂策略，分别是

该方法中的分配策略，是根据  中  的个数平方，乘以  的大小。得出应当切分的大小。假设   配置为 ，则在  第一次刷入  数据时，进行第一次 ，     = 。
当  数达到  个时，     = 。当  数达到  个时，     = 。依此类推

禁止 
 的分裂策略可以通过表的属性 _ 指定，也可以通过  全局指派，参数为：，默认为。

 的  主要实现在类 ，中默认的分裂点是当前  的中间  一分为而，当一个  加入到  的  队列后，由  线程负责 ，在研究  之前先看下  类的结构，其内部结构如下：

在  内部维护了三个队列，分别是 、 和  合并相关的下面在介绍， 队列有一个调度线程池来消费该队列， 个数默认为 ， 最终会调用到 ， 的  详细过程如下：

 相关的参数主要有 ，执行  的线程数，默认为 ，
 当前  的  个数最大值，如果当前  的  个数超过该值，那么将不会在进行  操作。

通过上面的分析知道  的  在  中分  和 ，而触发  除了每次  内存之后还有入口外部  调用和  的周期性检查， 周期性检查的频率由参数  控制，默认是  秒，而是否决定  操作则需要根据  的策略而定， 的  策略即是挑选需要合并的 ，挑选的原则是文件数不能太多、不能太少、文件大小不能太大等等，最理想的情况是，选取那些承载  负载重、文件小的文件集，实际实现中， 提供了多个文件选取算法：、 和  等，用户也可以通过特定接口实现自己的  算法， 默认的策略是 ，不过可以通过参数修改为适合自己的挑选策略，对应的参数为 ，在默认的  挑选算法中判断是否需要合并的逻辑是当前  的个数是否大于参数  设定的值，该值默认为 ，当  请求到达  后具体是放入  还是  队列，具体由以下原因决定：如果  为 ，即系统自身引发的合并，比如  、 检查线程等，统一放入到  中，即放入     而如果是人为触发的，比如  ，则还要看  中合并请求大小是否超过阈值，超过则放入 ，即  ，否则还是  综上， 的  简化流程图如下：

、  应该说  操作的源头就来自  操作，  会产生  文件，文件越来越多就需要 。因此在每次执行完  操作之后，都会对当前  中的文件数进行判断，一旦文件数＃  ，就会触发 。需要说明的是， 都是以  为单位进行的，而在  触发条件下，整个  的所有  都会执行 ，所以会在短时间内执行多次 。
、 后台线程周期性检查： 后台线程  定期触发检查是否需要执行 ，检查周期为：。和  不同的是，该线程优先检查文件数＃是否大于，一旦大于就会触发 。如果不满足，它会接着检查是否满足   条件，简单来说，如果当前  中  的最早更新时间早于某个值 ，就会触发  ， 预想通过这种机制定期删除过期数据。上文  是一个浮动值，浮动区间默认为［， ］，其中  为 ， 为 ，可见默认在  天左右就会执行一次  。用户如果想禁用  ，只需要将参数  设为 。
、手动触发：一般来讲，手动触发  通常是为了执行  ，原因有三，其一是因为很多业务担心自动   影响读写性能，因此会选择低峰期手动触发；其二也有可能是用户在执行完  操作之后希望立刻生效，执行手动触发  ；其三是  管理员发现硬盘容量不够的情况下手动触发   删除大量过期数据；无论哪种触发动机，一旦手动触发， 会不做很多自动化检查，直接执行合并。
选择合适  合并
选择合适的文件进行合并是整个  的核心，因为合并文件的大小以及其当前承载的  数直接决定了  的效果。最理想的情况是，这些文件承载了大量  请求但是大小很小，这样  本身不会消耗太多 ，而且合并完成之后对读的性能会有显著提升。然而现实情况可能大部分都不会是这样，在  版本和  版本，分别提出了两种选择策略，在充分考虑整体情况的基础上选择最佳方案。无论哪种选择策略，都会首先对该  中所有  进行一一排查，排除不满足条件的部分文件：
、 排除当前正在执行  的文件及其比这些文件更新的所有文件 更大
、排除某些过大的单个文件，如果文件大小大于  默认  最大值 ，则被排除，否则会产生大量  消耗，经过排除的文件称为候选文件， 接下来会再判断是否满足   条件，如果满足，就会选择全部文件进行合并。
判断条件有下面三条，只要满足其中一条就会执行  ：
、用户强制执行  、 长时间没有进行  的判断条件 且候选文件数小于 默认 、 中含有  文件， 文件是   产生的临时文件，只是简单的引用文件，一般必须在  过程中删除，如果不满足   条件，就必然为  ， 主要有两种  策略： 和 ，下面分别进行介绍：
 
 从老到新逐一扫描所有候选文件，满足其中条件之一便停止扫描：
 当前文件大小  比它更新的所有文件大小总和  ，其中  是一个可变的比例，在高峰期时  为 ，非高峰期为 ，也就是非高峰期允许  更大的文件。那什么时候是高峰期，什么时候是非高峰期呢？用户可以配置参数  和  来设置高峰期 当前所剩候选文件数 = 默认为 
停止扫描后，待合并文件就选择出来了，即为当前扫描文件 比它更新的所有文件
 
 该策略思路基本和  相同，不同的是， 策略在找到一个合适的文件集合之后就停止扫描了，而  策略会记录下所有合适的文件集合，并在这些文件集合中寻找最优解。最优解可以理解为：待合并文件数最多或者待合并文件数相同的情况下文件大小较小，这样有利于减少  带来的  消耗。
挑选合适的线程池
  实现中有一个专门的线程  负责接收  请求以及  请求，而且为了能够独立处理这些请求，这个线程内部构造了多个线程池：、 以及  等，其中  线程池负责处理所有的  请求， 和  负责处理所有的  请求，其中前者用来处理大规模 ，后者处理小规模 。这里需要明白三点：
 、上述设计目的是为了能够将请求独立处理，提供系统的处理性能。
 、哪些  应该分配给  处理，哪些应该分配给  处理？是不是   就应该交给  线程池处理？不对。这里有个分配原则：待  的文件总大小如果大于值 可以通过参数  配置， 默认为 ，分配给  处理，否则分配给  处理。
 、 线程池和  线程池默认都只有一个线程，用户可以通过参数  和  进行配置
 执行  文件合并
上文一方面选出了待合并的  集合，一方面也选出来了合适的处理线程，万事俱备，只欠最后真正的合并。合并流程说起来也简单，主要分为如下几步：
 、分别读出待合并  文件的 ，并顺序写到位于 目录下的临时文件中 、将临时文件移动到对应  的数据目录 、将  的输入文件路径和输出文件路径封装为  写入  日志，并打上  标记，最后强制执行  、将对应  数据目录下的  输入文件全部删除
上述四个步骤看起来简单，但实际是很严谨的，具有很强的容错性和完美的幂等性：
 、 如果  在步骤  之前发生异常，本次  会被认为失败，如果继续进行同样的 ，上次异常对接下来的  不会有任何影响，也不会对读写有任何影响。唯一的影响就是多了一份多余的数据。 、如果  在步骤  之后、步骤  之前发生异常，同样的，仅仅会多一份冗余数据。 、如果在步骤  之后、步骤  之前发生异常， 在重新打开  之后首先会从  中看到标有  的日志，因为此时输入文件和输出文件已经持久化到 ，因此只需要根据  移除掉  输入文件即可
如上即使  内存以及  和合并的大致流程，希望对有用到的同学有一定的帮助。服务器 腾讯云主机 
项目 开源项目模版
该项目使用 打包 内网涉及到请使用
环境安装
安装
根据官方指导进行安装
官网给出的安装引导是安装   但是我们项目使用的 
所以必须再安装 备注  可以多个版本并存
    =
    
 下载的地址不一样
禁用防火墙
   停止
   禁止开机启动
由于是学习项目可以先关闭防火墙 生成环境请配置防火墙
安装
　  

　  
 使用命令行测试    能访问到内容则正常
项目构建
构建项目
在环境 构建  指引 参考
如果访问问题可以使用
   
   
创建项目
选择高级模版

取消 安装 使用  

编译项目
编译 编译
 程序集 打包 本地运行项目
有兴趣的同学可以多了解快命令具体做了啥

本地访问


部署项目
执行发布脚本
 
 该命令会执行 的构建命令
 {
          
        
}
压缩生成文件
目录
\\\\\\\
压缩成  稍后上传到进行部署
上传项目
使用工具上传只  我使用的
解压文件  
启动项目
 _=
  =
 备注 此处没有使用 是因为 下错误 
 
已经监听了 
测试

发现上面虽然打开了我们的页面其实是爆了一个错误
需要修改 \\ 文件
  = =
    

去掉如下代码
= =   测试正常
配置代理
端口不适合暴露外网 配置 反向代理
 

添加 
 _ 
        __ 
        __  _
        __  
        __  
        __ _
       __  _
            __  _
            __  ____
检查配置
重启
 


  
获取使用
  
查看成果
使用外网访问站点 直接访问端口就好了

其他
该项目目前只是用于学习   顺便熟悉一下 。

相关推荐下一篇 【腾讯云的种玩法】 守护  程序作者：徐凯导读：企业部徐凯有着丰富的  应用经验，曾荣获《  中国社区十大贡献者》称号。本文将其在年月日在北京举办的    上分享的内容进行整理，内容主要介绍了虚拟机的  流程分析方法，几个特殊的情形下的  分析，以及最后根据  分析得到的结果进行了  优化的建议。


现在市场上，很多私有云的解决方案都是基于开源的    架构来做的，而我们的虚拟机通常会使用  来运行。虚拟机的资源一般都是存储在  里面的，借助的块存储功能，通过调用  库向  读写数据。
、虚拟机 = 黑盒子 ？

对我们普通用户来说，一台台虚拟机就像一个个黑盒子，为什么这么说呢？因为我们知道虚拟机的数据都存储在  集群中，并且也会不断地向  集群发送读写请求。但是，我们并未深入地去剖析过一台虚拟机向  集群发送的每一个读写请求是做什么的。虚拟机已经将这层请求封装好，那么现在，我们就要撕开这层包装，看个究竟！
、为何  集群总是有着稳定的高 
在集群搭建好投入生产一段时间后，随着业务的增长，虚拟机的数量会不断增加，整个  集群  也会从当初的几十逐渐增加到后面的几千。
但是有个奇怪的现象，不论是在白天业务高峰期还是夜晚业务低谷期， 集群始终都会有稳定的四五千的，难道说，虚拟机产生的  和实际的业务没有正比关系吗？
又或者，我们曾经咨询过某些高  的虚拟机用户，据他们反馈，他们并没有在使用这些虚拟机，此时的虚拟机是处于静置状态，难道说没有任何人为操作的虚拟机也会产生很高的  吗？
、虚拟机的启动风暴
众所周知，在集群搭建完后，通常会做许多压力测试，比如，批量虚拟机的建立，启动，重启等操作。而当批量启动上百台虚拟机的时候，很容易造成瞬间的大压力，导致后端存储无法承受之。
这种瞬间压力，我们一般叫做虚拟机的启动风暴。可是，知道了虚拟机批量启动会带来风暴，那这场风暴里的每一个  都是做什么用的呢？这在本文后面会对得到解答。
、虚拟机的读写流程简析

本文的环境使用的是常见的  用来启动虚拟机。虚拟机使用的是  中的  即块设备。通过调用  提供的库  来向  集群发送 。
在阅读完  的源码后，我发现每一个读写  都会调用名为 _ 和 _ 的函数，而这些函数在运行时，会输出一行很有特征的日志文件。也就是说，每发生一个读写 ，日志文件中都会记录下这个  的具体信息，包括这个  产生的时间，在整个块设备中的漂移量， 的大小。所以通过分析客户端的日志，就可以得到每一个和  集群交互的 。
这里需要注意的一点是，本次关于  的讨论，仅仅是从  层去分析，而这些  经过 _ 之后以及经过  的  而产生的合并效应，不在我们的讨论范围内。
、 的日志特征

如上图所示，通过过滤日志中的关键字： _  _ ， 可以得到上图中的  记录日志。其中  代表这个  在整个  中的偏移量，单位为字节。  代表这个  的大小，  也就是一个  的 。 同理，_ 的日志中最后的方括号内的两个数字分别代表了一个读请求的偏移量和大小，单位均为字节。
、如何获取  的日志呢？

这里，我们推荐采用打开  文件的方式，而不是简单的增加日志级别来获取。原因很简单，每一个  进程都会在虚拟机启动的时候加载  的配置文件，并且在进程启动之后，无法再修改配置项了，除非你硬重启虚拟机重新加载，或者使用  文件对绝大多数参数进行动态的修改。
另外一个要说的是，记录 _ ，_ 的日志等级很高，要开到才能输出，而当日志等级开到之后，日志的生成速度很快，大约一小时几个的样子，如果长时间打开很容易把服务器写满，通过  的方式动态的开启和关闭日志，可以达到较为不错的使用体验。
、块设备和日志的对应关系

在获取到了日志之后呢，我们可以将日志得到的偏移量加大小，和整个块设备对应起来，因为这个偏移量就是这个  在整个  里面的偏移量，通过将虚拟机对应的   到本地，然后将这个偏移量的数据读取出来，对读取的内容进行分析，就可以知道这个  的功能了。
实际上，块设备本身是不支持多路径挂载写的，但是由于这里使用场景的特殊性，即尽管这个块设备已经被虚拟机实时调用，但是我们将其  到本地，不会对这个块进行任何写入操作，仅仅是读取操作，所以不会造成因为多路径同时写而产生的数据不一致问题。
、一个有趣的 

在这次  分析中，我一共采样了几千个  的内容并对其进行分析。而在所有的  之中，有一个十分有趣的 ，它的偏移量为 ，  的大小为 ，而它的内容的就是上面我们熟悉的开机界面，也就是说 在启动的时候会在一个固定的  的位置，将启动界面的内容写入到里面。
、新建虚拟机静置时分析

现在，创建一台崭新的虚拟机，开机一段时间后，将该虚拟机静置在那，不执行任何指令，采样一小时的日志，并对  进行分析。可以发现，有一个  进程，每过会生成对应的日志文件，并记录到  和  文件中。
同时，相关的的产生时间和  日志生成时间十分吻合，所以这里我进行了一个猜测，是不是生成日志文件会产生较大的  层的。于是将  进程关闭，又采样了一小时的日志进行分析。
观察得到，除了不再生成相关日志外，  层生成的  也少了许多许多，说明  定时写日志的操作会带来  层的连带写操作，产生一定的放大效应，放大比在：：左右。
并且还有一个比较有趣的现象，在关闭  的 后，不再有任何写  请求，说明对于新建的虚拟机来说， 是唯一会带来  集群  负载的进程，其他所有进程在系统静置时都不会给  集群带来 。
、生成单文件的分析

这里，我简单执行了     这个写文件的操作。在生成的所有的个  中，只有一个是包含了实际文件内容的  请求，也就是执行  操作的写 。 其他的个都是  文件系统相关的写 ，说明写文件会带来很多  层的消耗。
在对更多的写操作进行统计后，发现写文件操作越频繁， 的消耗越少，但是总体上保持着    的连带消耗。
、引发的一些思考

之所以分析这些 ，是为了给我们生产实践提供一些帮助，目前一个比较急需的值是：每种类型的虚拟机大概产生多少的 ，比如常用的两种类型： 网站访问的虚拟机，跑数据的虚拟机。这两种虚拟机产生的  请求往往是不一样的。 网站访问，可能  会集中在某天的某个时间点，比如门户网站早上八点开启注册抢号功能。所以八点那会会产生一个小的峰值。而跑数据库的虚拟机可能会带来稳定的密集的小操作，所产生的要比网站的要高很多。
因此，我们可以对生产环境的虚拟机进行  监测，当然还是建议使用测试环境观察稳妥些，对一段时间内的不同类型的虚拟机进行建模，获取到每种类型的虚拟机的  模型，然后将不同的模型进行叠加，可以得到集群所有虚拟机  叠加图形，只要保证叠加峰值不超过集群的总承载能力，就可以继续新增虚拟机，卖更多的服务。
由前面的分析可以看到，  层会因为写文件操作，而产生大量的放大写操作，我们甚至可以大胆的从文件系统层面，根据这里的放大效应，对文件系统的写操作进行合并优化，使得放大比降低到 甚至  以下。
总结：经过对多种情形的虚拟机的分析，我们可以大致的对虚拟机的有一个直观的认识，后面会对这些  数据进行建模，将虚拟机的动态的展现出来。腾讯云分布式数据库是一个适用于场景且与  、兼容的分布式关系型数据库。其前身是腾讯计费平台部为托管公司的虚拟账户，如、点、包月服务、游戏的二级账户等数据而打造的高性能数据库集群。在支持各大业务实时在线交易顺畅进行的同时，保证在各种灾难场景下数据的一致性、可用性。目前已经承载了包括、米大师等多家金融领域的主要业务数据。下面主要介绍的核心架构和应用场景。
分布式数据库的挑战：
数据高一致性：对金融业务来讲，数据的强一致尤为重要，因为如果出现数据丢失，就意味着交易的丢失，这会给组织或用户带来直接的金钱方面损失，也有损企业商誉和信。因此，数据的一致性是应该最需要考虑的问题之一。然而，传统数据库如果不使用共享存储的情况下很难做到主库出问题时数据不丢失。即使采用一些强同步的方案进行改造，也会造成数据库性能的下降，无法满足业务高并发需求。
服务高可用性：随着业务需求的不断提高，搭建一个数据库高可用环境已经成为很多企业迫切的需求。确保企业中的计算资源持续可用性是的主要目标之一。如果支持应用程序的数据库不可用，不仅会带来大量投诉或用户流失，也会给组织带来金钱方面的损失，损失信誉和商。高可用性和减少停机时间是数据库系统的目标，在诸如订单、支付等需要无障碍运行的金融业务环境中尤其如此。
高并发和益伸缩性：互联网金融的到来让金融服务向高效率、碎片化、低成本的方向快速转化。数据体量不断膨胀的同时，对业务请求的响应时间要求也愈加苛刻。在保证前两点的前提下，不断提升系统容量和吞吐率，保证毫秒级请求响应时长也是一个必不可少的能力。
投资和回报：当前企业信息化的投入越发理性，决定企业信息系统构成的除了基础架构，通常还包括企业 的预算模型。对于或大或小的业务系统，在保证高一致性和高可用性的同时，也必须要考虑到企业预算和成本。商业数据库基于许可的采购模式，势必会导致建设成本高昂，难以扩展，且需要大量的资源来配置和维护。事实上，为维持可用、稳定的生产环境甚至非生产环境，企业需要不断地投入建设和管理费用，最终导致企业为数据库资源投入巨额成本。
腾讯云分布式数据库解决方案：
简介：  的诞生经历了十余年：年，基于运营商业务，腾讯数据库团队开始对 进行改造年，腾讯互联网增值业务开始爆发，业务量的爆炸给数据库层带来了巨大扩容压力，这就开始引入分库表机制来解决难题；年，腾讯游戏、空间、财付通等各类业务再次爆发，为提高可用性，减少故障带来的损失和投诉，腾讯数据库团队全力解决一致性这个问题，引入多种机制保障主备数据的一致性，并提供数据自动恢复的能力。年，基于正在火热的互联网支付业务超高可用性、超高并发和极短响应需求，腾讯数据库团队启动高一致分布式集群存储项目，最终达成了完全自动化的，在数据底层实现跨的强同步、跨城容灾、切换一致性保障、数据自动分片、集群管理等能力。年，腾讯内部正式给这款产品命名为  ，且为了提高扩展性和开放性，将作为数据库引擎的基础。在后续两年时间，陆续支撑米大师、微众银行等多个兄弟业务的上线，并针对银行场景的数据关系模型设计了关系紧密的数据聚合，同时将跨节点的分布式架构转换扩展到单机架构，有效的覆盖了大中小多层次的用户。年，正式进驻腾讯云，并更名为腾讯云金融级数据库  ，开始面向腾讯之外的企业提供金融级云数据库服务。年，腾讯云  更名为  ，同时正式推出分布式数据库
架构：
系统由三个模块组成：、、网关，三个模块的信息交换都是通过完成，极大简化了各个节点之间的通信机制。
先说下这个逻辑概念：由一主多从多个节点构成，每个节点包含一个实例和一个实例，是承载数据存储和服务的底层物理数据库。一个或多个可以通过网关形成一个逻辑数据库。
作为集群的管理调度中心，主要功能包括：

管理，提供创建、删除、内节点替换等工作

所有的操作统一下发和调度

监控内各个节点的存活状态，当内主节点故障，发起高一致性主备切换流程

监控各个的、磁盘容量、各个表的资源消耗情况，必要的时候自动发起扩容流程


自身的容灾通过的选举机制完成，保证中心控制节点无单点。
模块负责监控本机实例的运行情况，主要功能包括：

用短连接的方式周期性访问本机的实例，检测是否可读、可写，若发生异常，会将异常信息上报到，最终会由上面描述的模块检测到这个异常情况，从而发起容灾切换；

检测主备复制的执行情况，会定期上报主备复制的延时和延迟的事务数，若发生了主备切换，自动向新主机重建主备，因此的主备不需要干预，对于新增的实例会自动采用通过主机自动重建数据；

检测实例的利用率和各个表的请求量、数据量、利用率，上报到，通过全局的资源情况抉择如何扩容、缩容；

监控是否有下发到自身的扩容任务，如有则会执行扩容流程；

监控是否要发生容灾切换，并按计划执行主备切换流程。


网关基于 开发，在网络层、连接管理、解析、路由等方面做了大量优化，主要特点和功能如下：

解析，将识别出的语句直接存到，让来统一调度；

 的路由信息，拉取最新的路由表保存到本地文件和内存；

将请求路由到对应的，支持读写分离；

对接入的、用户名、密码进行鉴权；

记录完整的执行信息，与秒级监控平台对接完成实时的请求的时耗，成功率等指标监控分析；

对、、、、、、 、 等聚合类一般需要访问后端的多个，网关会分析结果并做合并再返回，暂不支持跨 和分布式事务；

网关无状态，既支持与业务部署到一起，也可以独立部署可通过或者做容灾。


分表逻辑
在中，每个表逻辑表可能会拆分成多个子表建表的时候通过在建表语句中嵌入注释的方式提供一个字段名，最多会拆分出多个子表，每个子表在上都是一个真实的物理表，这里称为一个，分布在某个中，因此一张表的数据可能会按这样的方式分布在多个中，如下图：

每个请求到达网关之后，网关会做词法和语法解析，重点会解析出字段，如果带了字段就可以直接查询路由表并发送到某个具体的中。计费的类业务的请求都会带上字段；如果某笔请求没有字段，查询路由之后会将请求发送到所有的对应的中，并对所有返回的结果做一些聚合运算。
分片方式比较： ：

 ：

逻辑、、表中具有同样的 的数据分布到同个中目前在腾讯云上暂时只支持单模式， 模式也会很快上线。
容灾机制：对于来说，我们希望容灾做到自动切换，自动恢复，主备一致性保证业务提交的事务在切换过程不丢失，跨容灾。异步复制：在发展的早期，就提供了异步复制的技术，只要写的压力不是特别大，在网络条件较好的情况下，发生主备切换基本上能将影响控制到秒级别，因此吸引了很多开发者的关注和使用。但这套方案提供的一致性保证，对于计费或者金融行业是不够的。半同步复制：到了 版本的时候，提供了一个半同步半异步的插件，确保必须收到一个备机的应答才让事务在主机中提交；当备机应答超时的情况下，强同步就会自动退化成异步模式这也是半同步半异步名字的由来下图是二者的比较：

半同步复制可保障一致性，但是：超时后蜕化成异步，金融场景不合适跨的情况下性能不容乐观

半同步性能不好的原因分析：

不管是模型一还是模型二，每次执行，都要先写，然后往从机同步，等待从机应答，然后再返回给应答。虽然是多个线程，但执行流是同步的，利用不起来。线程异步化改造：


上半部分：任务执行到写为止，然后将会话保存到中，接着执行下一轮循环去处理其他请求了，这样就避免让线程阻塞等待应答了；
然后：自身负责主备同步的线程会将立即发送出去，备机的线程收到并写入到 之后，再通过给主机一个应答；
在主机上，开一组线程来处理应答，收到应答之后找到对应的会话，执行下半部分的，应答，绑定到等操作。绑定到之后这个连接又可以被其他线程检测到并执行了。效果：


数据高可用性保障机制：主备自动切换

细心的同学可能会发现上面的强同步还有点小缺陷：比如主机用 杀掉，那么可能写了但没有来得及发送到远端，此时当然也不会返回给业务成功，备机上不存在这笔数据，但主机起来之后会多出来这笔事务。我们的做法是对新增的事务根据格式的做闪回，当然回退不了的比如 之类的，就直接提醒运维手工确认是保留还是清除数据库，然后会由机制自动从新的备机全量拉取数据重构。
灵活的主备配置：通常为了保证可用性，最少要求一主二从分布在个的部署方式，保证任意一个挂掉都不影响系统的可用性和数据一致性。个同时挂掉，系统还可以提供只读服务。当然业务可以根据自身需要增加更多的从节点，同时可以选择性的将读请求分到从机，进一步提高系统的可用性和处理能力。甚至可以选择增加异地的灾备节点通常采用异步的方式，提供跨城容灾的能力。
应用
完善的帐号和权限管理：为了更好的控制风险，默认不提供超级用户，也无法直接通过语句进行帐号和权限管理。响应的，在管理页面，有非常方便的管理模块：

上图是帐号列表，点击左上按钮可以新建用户，指定用户名和主机，主机支持这样的匹配方式，点击克隆帐号可以完全复制当前帐号的权限来新建一个帐号。点击修改权限，如下图：

可以看到，通过左边的导航栏，提供了完全兼容管理方式的图形化界面，权限管理可以细化到列级。图中因为是系统表，所以只提供权限的授权。
高效便捷的数据库参数设置：

支持批量设置参数

支持查看参数修改历史记录
慢查询分析：下图是按时间段列出的不同慢查询抽象后的的列表

下图是某条慢查询抽象后的详细统计数据：

操作日志：

记录天内所有相关管理操作记录
数据库审计：

管理员可以针对关心的敏感操作，创建审计规则，然后绑定审计策略到实例，系统会记录符合规则的，供管理员查看
数据库同步：

支持创建为源，或为目标的数据库同步任务，自动完成历史数据的传输，实时同步增量数据。
分布式数据库的未来规划
支持小表广播、分布式事务等支持复杂查询作者：李洋

前段时间学习了项目里边关于全景图的案例之后，自己动手练习了一下，实现了两个全景图的例子，分别如下：
 球型全景图
 立方体全景图
网络不好的情况下第一次打开可能会比较慢，因为全景图资源比较大。
实现原理比较简单，只要把摄像机放在模型中心，然后把全景图渲染到模型内表面即可；
不过还是需要注意以下两点：
其一有两种方法可以把全景图渲染到模型内表面；
  一种是在创建材质时设置参数为；

 另一种种则是对模型进行镜像变换；

其二球型全景图和立方体全景图使用的图片资源是有区别的；
球型全景图如下：

立方体全景图如下：

虽然球型全景图更贴近人眼的构建模式，但是从模型上来说比立方体更复杂，而且出于兼容性考虑使用时是无法构建球模型的，因此立方体全景图具有更高的性能和更好的兼容性。
但是我在网络上并没有找到把球型全景图转换为立方体全景图的工具，相关文章也较少，稍有提及的也是一笔略过。

所幸在上找到了一遍的文章虽然没有代码实现但是推导过程比较详细的文章球面全景图到立方体全景图的转换。

根据自己搜到的相关知识并加以理解最终用实现了球型全景图转立方体全景图工具。
点击上述链接应该会看到该程序根据一张球型全景图生成了一张正方形图片即立方体全景图的一个面；

该工具核心代码如下：

该工具每次只能得到立方体的一个面，图中轴负平面没有被注释得到了执行，因此得到是轴负平面也就是立方体的底面，要想得到其它平面，只需要执行相关平面代码即可。
最终得到的六个面后，对应相关命名代入立方体全景图例子中的图片数组即可得到立方体全景图了。

如果你还有兴趣了解该工具的实现，可以接着往下看；
虽然上边的核心代码很简单每个面大概三四行代码的样子，其实球型全景图到立方体全景图的转换涉及到好几个坐标系的相互映射，稍不小心就会出错，如下：

坐标系说明：
坐标系是全景场景中的坐标系；坐标系是立方体单个平面的纹理坐标系。

中的纹理坐标系统是二维的，为了将纹理坐标和广泛使用的坐标和坐标区分开来，使用和命名，称之为坐标系统，纹理坐标系示意图以及纹理映射相关知识可以在 学习总结一、二找到。

假设点是从球面和轴的交点绕轴旋转，然后在轴和其本身组成的平面上绕其过原点的法向量旋转得到，那么点的坐标如下：
    

     = 
     = 
     = 
因为立方体的六个面都和球面相切，那么假设上图中的直线和正方体的某个面相交于点，那么向量肯定等于乘以向量，那么点的坐标如下：
     = 

    

     =  = 
     =  = 
     =  = 
如果点在立方体的平面上；
     =  = 

     = 
     = 
     = 

     = 
     = 

    
此时得到了点在坐标系中的坐标，再假设点在坐标系中的坐标为，那么就可以求得和的值；
    纹理坐标最大为，因此 = 
      = 

    坐标系和坐标系的映射关系
     = 
     = 
通过上边的分析就不难看懂下述代码了；

之所以求出和的值是因为可以通过这两个值把球型全景图转换为二维；示意图如下：

      =   
      =   
整个推导过程就可以理解为点为立方体全景图轴正平面的点，对应到二维球型全景图中的坐标为；
最后需要注意的是需要控制和的值不能让其超出范围，还有就是负平面的和可以根据正平面的或者加上一定的值得到。游戏社交化是近年来游戏行业发展的重要趋势，实时互动的实现和社交平台的能力是游戏社交化的两大关键。游戏中玩家的沟通协作从最初的文字交流，逐渐发展为音、视频结合的多场景下的实时互动，是游戏中社交关系建立和维持的关键因素。另外，游戏社交需依托于平台，如何构建玩家间的社交网是各大游戏厂商的重要考虑点，这对平台的能力提出了很高的要求。
本期腾讯云沙龙，与您一一探讨！
演讲主题：全球同服游戏语音解决方案嘉宾简介：崔博 腾讯游戏云架构总监超年研发经验，主导过分布式存储产品、海外游戏产品及直播产品的研发运维，擅长解决高并发、高可用、高可扩展等复杂场景下的架构问题。
演讲概要：通过《部落冲突》等全球同服游戏席卷海内外的案例，来剖析腾讯云如何帮助游戏厂商更好的应对全球化挑战。本议题从全球化游戏语音功能为切入点，全面介绍腾讯云为全球同服游戏架构提供的相关解决方案。
下载：
关于：系列沙龙由腾讯云主办，旨在为游戏开发者提供一个自由的交流分享平台。沙龙将围绕游戏行业趋势、研发技术、运维和推广等热点进行探讨。每期沙龙将邀请国内外游戏领域专家，分享游戏开发及运营过程中的思考和实践。
访问沙龙官网 ，了解最新沙龙资讯和更多往期回顾。在网络广告投放指标评估中， 是众多有效的评估手段中的一种，而预测也是数据挖掘上一个热门的领域，在腾讯举办的大赛中，预测移动广告转化率，也有一定的相关性，所以前人在预测中用到的方法也很值得在这次比赛中借鉴与学习。而对的平滑处理这是这些方法的其中一种，并且在初赛实践中发现，平滑处理后相较于未平滑处理有之间的分数提升这里面的区别跟统计的方法，还有参数设置等等有关，笔者也没有特别的把握，加了就能有这样的提升下面文章将分三个方面：、为什么要加入平滑处理 、相关细节介绍 、针对天数不同可以做的额外处理。
一、为什么要加入平滑处理
   首先，我们在进行预测时常常会加入一个广告或者用户等等过去的转换率作为特征，并且这个特征往往在最后训练中占有较大的权重，但是简单的计算转换率往往会由较大的方差。如：广告过去被看到次，而被转换了次，最后的转换率是，广告被点击了次，转换了次，转换率是，我们是否就能得出的转换率比高呢，我想这里面的稳定性是很低的。
 
并且时常会出现，近期新出现的广告需要预测，而这类广告的历史出现次数都是很低的。而这时候就需要平滑点击次数少的广告，降低低点击次数的噪音，并且避免对样本多的数据造成较大的影响。
二、相关细节介绍
 
首先介绍最简单的 方法，，其中将分子与分母加上如、、等，这样就能够避免上面讲到的，因为没有被点击过而有可能错误的将其点击率估计为。          然而  也有它的弊端，即使加上之后，因为样本少的原因，这样计算出来的点击率仍旧是存在较大的方差的。
          
当我们除了这个特征以外，在其他特征上有对应较好的转换率作为先验的话，就可以将这个信息加入到我们的平滑方法中去，  μ = μ … μ是对应的其他特征上的转换率。如在比赛中，因为特征维度低，样本数量够大，我们可以将的转换率作为我们的μ，使得我们平滑后的转换率噪音更低，避免了过拟合并且符合真实情况，而这个方法也是笔者在在  上的中学到的，读者可以前往进行深入的学习。但是这里仍然存在一个问题，这里的到底要设多少，我也没有很好的解决方案如果读者有更好的想法，欢迎交流，可能这里也是需要调参的地方，而这会花费大量的时间。
三、针对天数不同可以做的额外处理
首先，我们在统计前几天转换率时，大部分时间我们是对天数统一看待，每一天在统计转换率的权重都是相同的，而真实情况下，前一天的转换率相较于再前一天的转换率有更高的可信度，此时我们可以给每一天设置一定的权重，并增加近期转化率的权重，降低较远时间上转化率的权重，以使得构造的特征更具有可信度。而这个方法是在 实验室发的一篇关于的上看到的具体方法，可以前往查看。
：笔者在使用这个方法上得到的提升没有上面的方法得到的提升更有效
最后，因为刚接触比赛的原因，所以上面的一些见解可能存在偏颇，所以，若有发现，希望能够指出，并希望在比赛中，能够与伙伴们一同进步。
 
基于函数调用关系链的功能用例消振算法
上帝的视角 
一、引言
问题简述：当一个功能用例执行时，背后就会有数以千计的函数被调用运行。其中有与这个功能用例息息相关的业务函数，也有与这个功能用例描述无关的数据上报函数、日志函数。如何区分什么是核心业务函数，什么是无关函数？
《三体》像我们阐述了这样一个事实：一个文明不会孤立的存在，宇宙有其社会学法则。在这个法则的作用下，一个文明或主动或被动的与其他文明产生关联关系。地球文明不是孤岛。
二、函数孤岛？
地球文明不是孤岛，函数呢？从静态的视角观察函数，她只是一个一个在文件中孤立存在的代码片段。但从动态的视角观察，函数与函数之间就天然的发生了关联。这个关联是怎么产生的呢？答案是函数调用关系链。函数调用关系链就是函数自己的宇宙社会学法则，函数不是一个孤岛。我们将这种动态的视角称为上帝的视角文中最后部分有解释这个的含义。
三、函数的宇宙社会学法则导致的用例关联函数问题剖析。
在函数调用关系链的作用下，一个函数或主动或被动的与其他函数产生调用关系。这种调用关系的存在，造成了用例与函数两者在关联的时候，总会出现一系列问题：
、从函数角度而言，越是基础的公共函数，她被调用的次数就越多，她与其他函数的互相交叉关系就越复杂。如何将函数关联的用例控制在最能描述这个函数的用例集上呢？且不会关联过多无效的用例。
、从用例角度而言，用例的设计主要是为几个有限的关联业务函数服务的。但是由于函数调用关系链的影响，用例会被动的关联很多跟他的功能描述不相关的函数。若是这个用例操作步骤很复杂，那么其所调用的函数将呈现爆炸式的递增。如何能够将用例关联的函数控制在核心业务函数范围内呢？
要解决上述两个问题，是否可以借鉴《三体》中挽救人类文明于灭亡边缘的“面壁计划”的思路：既然无法突破宇宙社会学法则，那么就利用、学习她，在绝境中寻求浴火重生的机会。我们是否也可以利用函数调用关系链的规则，制定我们自己的“面壁计划”？答案是肯定的，经过我们团队成员不懈的努力，我们找到了解决上述问题的方式：从调用链的两个不同视角来解决这两个问题：
广度视角：利用函数调用关系链值来解决问题。
深度视角：利用函数调用关系链亲密度值来解决问题。
额，好抽象的视角啊，如何理解？莫急，各位看官请听我将她娓娓道来：
四、广度视角：利用函数调用关系链值解决函数关联过多无效用例问题尤其是公共库函数。
首先让我们一起将视角调整到：函数与其调用的子函数之间这个角度，站在函数角度而言这是主动的调用，子函数之间是平等的兄弟节点的关系，她是横向的广度。
函数有分支的概念，就造成了子函数分派的依附各自的分支中。为了方便大家理解这个概念，我们在这里打一个比方：在一棵树分支中分布的叶子，如图，我们将一个函数的调用想象成上图中有分支有叶子的树图，树的分支代表函数分支，树的叶子代表函数调用的子函数。

图 
一棵树是靠他的分支像叶子输送养分的，若是在输送养分的过程中，只专门跑一个分支，就会造成其他分支的叶子因得不到养分而渐渐枯萎。为了使每一个分支的叶子都不会枯萎，需要在传输养分的时候保证每一个分支都能被传送到，保证叶子雨露均沾。若是我们再规定每天每一片叶子只能得到一次营养传输机会，那么我们如何严格的保证这个规则的执行呢？因为每一片叶子都是独一无二的，而她又依附于她所在的分支吸收营养，那么我们就可以通过一个分支中所有叶子的集合来区分每一个分支。当上图这棵树的三个分支都可以相互区分之后，我们就可以保证每一天每一个分支的每一片叶子一天只得到一次营养传输。若是一天中一个分支第二次意外的遇到有外部营养的传输的时候，我们就可以直接拒绝。
函数的用例设计也是与上述的类比一样的，为了保证函数的质量，需要为每一个分支设计一个关联的用例。当我们完成了函数每一个分支用例设计的时候，若是突然有一个无关的用例也调用了这个函数，我们如何拒绝将这个函数与这个用例进行关联呢？恩，与叶子是一样的，每一个子函数也是独一无二的，我们可以通过每一个分支的子函数集合来标识区分每一个函数的分支。然后在设计分支用例的时候，将每一个分支的与与这个用例相关联，这样当我们再遇到一个无关用例关联这个函数的时候，测试分析师就可以有法可依的拒绝这个用例的关联。
汇总：每一个分支的子函数集合就是函数调用关系链的概念。当一个公共库函数完成了其所有分支用例分覆盖之后，突然有一天多次意外的遇到无关用例主动关联的时候，那么作为测试分析师的我们就可以大胆的拒绝这个关联关系。
五、深度视角：函数调用关系链亲密度值解决用例关联不相关函数的问题。
首先让我们一起将视角调整到：函数与调用这个函数的父函数之间这个视角，站在函数角度而言这是被动的调用与广度视角正好相反，父函数与函数之间是直系亲属的关系，她是纵向的深度。
由于函数之间有调用与被调用的关系，就造成了函数间：祖父函数、父亲函数、儿子函数、孙子函数、曾孙函数之间直系亲属关联关系的概念。了方便大家理解这个概念，我们在这里打一个比方：清朝皇室族谱中的直系亲属关系，看下图：

图
我们将一个被调用的函数想象成上图中具有直系亲属关系的族谱图，族谱中的一个人名代表了一个函数。通过生物遗传学的特性，我们发现族谱中父子之间血缘关系是最亲近的，而隔着几代的两个人相互之间的血缘关系却是很淡薄的。
用例与其关联的核心业务函数的关系也是与上述的类比一样的，当我们把用例当做祖先，那么其关联的核心业务函数就是其子孙。调用链层次越上层的函数他所包容的功能越多，越靠近用例所描述的功能，其血缘关系就越近。调用链层次越下层的函数他所包容的功能越少只是上层函数的一个功能子集，越远离用例所描述的功能，其血缘关系就越浅薄。
我们将用例与函数的血缘关系称为亲密度。若是亲密度的描述在这里就停止，我们相信大家都不会满意： 你们的系统怎么一定可以确认在调用链越下层的函数，就一定不能描述这个用例呢？额，从系统层面确实不能肯定的回答是，好心塞。
抛开低落的情绪，让我们平静下来。回头再来看看我们的项目的目标：测分及测试体系精准化、测试分析师养成。默默的多读几遍，对啊！我们忽略了精准测分最重要、最核心的角色：拥有上帝视角的测试分析师。因为用例是由测试分析师创造设计的，他才是用例及其关联函数真正的祖先，他最清楚用例应该关联那些核心业务函数。测试分析师才是精准测分项目的“面壁者”，其拥有至高的话语权上帝视角。
通过测试分析师的选择我们过滤出一批核心业务函数，再在函数调用关系链的作用下，将这批核心业务函数按照调用链的层次分成不同的亲密度值。通过亲密度我们知道，哪些函数跟我这个用例才是最亲密的、哪些用例跟我这个函数才是最亲密的。
为了方便大家更深入理解函数调用关系链亲密度值，这里我们举一个用例设计过程中关联函数的实际例子：模拟器项目中“摇一摇”功能用例，下面是这个用例的描述截图。

图
通过上面的截图描述我们知晓这个功能用例的主要关联业务函数类型是：界面窗口的摇一摇、模拟器模块摇一摇事件消息发送、事件中堆内存的清除。分析了业务函数的类型之后，将他们与这个用例相关联即可，之后系统会根据函数调用关系链计算关联函数的亲密度值。接着当我们继续深入分析界面窗口摇一摇函数的时候，发现一个用例不能完全覆盖他所有的分支，这时我们就要创造设计出不同的用例对函数进行高质量的覆盖。上述我们创造设计的用例与函数的亲密度值均为，因为他们都是围绕这个函数而生的。但是当还有其他不怎么相关的用例，因为调用关系链的缘故也被迫关联了函数时，我们就可以通过测试分析师的选择以及函数调用链将其亲密度降低。这样在亲密度值的作用下，测试分析师只需执行亲密度为的用例，更低亲密度的用例呆一边去。
汇总：函数调用关系链亲密度值的计算通过两个步骤的操作来完成：
、测试分析师的选择过滤，这是至关重要的选择。不然下面一步的操作就会变成无源之水、无本之木。
、通过函数调用关系链将中选择过滤的业务函数进行亲密度值的计算。
根据这些亲密度值，我们就可以将函数关联的用例进一步的过滤消振。
六、总结
通过广度视角：函数调用关系链值我们解决了函数关联用例过多的问题，将函数关联的用例在横向方向上过滤出一批。再通过深度视角：函数调用关系链亲密度值我们解决了用例关联函数过多的问题，将用例关联的函数在纵向的方向上再过滤出一批。这样剩下的函数关联用例，用例关系函数，互相之间才是最核心、优先级最高的。自然的，与用例无关的函数、与函数无光的用例都被无情的过滤了。
上述就是桌管安全测试团队针对精准测分中用例消振提出的“面壁计划”。这里请允许我代表我们团队再郑重的跟大家阐述一下精准测分项目的目标：测分及测试体系精准化、测试分析师养成，额一不小心泄露了个大秘密。
七、名词解释
《三体》：是刘慈欣创作的系列长篇科幻小说，由《三体》、《三体Ⅱ·黑暗森林》、《三体Ⅲ·死神永生》组成。
“面壁计划”：一个通过利用三体人唯一战略劣势——不能隐瞒自己想法。利用地球人无法被看穿的思想找到阻止三体入侵的方法的计划的总称。
“面壁者”测试分析师：选定一批面壁计划的制定者和领导者，他们完全依靠自已的思维制定战略计划，不与外界进行任何形式的交流，计划的真实战略思想、完成的步骤和最后目的都只藏在他们的大脑中，我们称他们为面壁者。面壁者将被授予很高的权力，使他们能够调集和使用地球已有的战争资源中的一部分。
“上帝的视角”在二维角度平面上的点看自己，只是一个点。但是从三维角度看，却是互相关联组成的网状图。广播操作 
一种用 来保证参数的形态兼容的操作。

一块可以用来运算并且拥有自己的地址空间的硬件，比如和。

 的一个方法，返回  的值。触发任意一个图计算都需要计算出这个值。只能在一个已经启动的会话的图中才能调用该  值。

 的一个概念：把一个  直接连接到一个会话图表中的任意节点。 不是在构建图的时候创建，而是在触发图的执行操作时去申请。一个  临时替代一个带有  值的节点。把数据作为 方法和 方法的参数来初始化运算。方法运行结束后，替换的  就会消失，而最初的节点定义仍然还在。可以通过 把特定的节点指定为  节点来创建它们。详见【   】。

中的一个概念：为了取回运算操作的输出结果。取回的申请发生在触发执行图操作的时候，而不是发生在建立图的时候。如果要取回一个或多个节点的  值，可以通过在  对象上调用方法并将待取回节点的列表作为参数来执行图表。详见【 】。
图
把运算任务描述成一个直接的无环图形，图表中的节点代表必须要实现的一些操作。图中的边代表数据或者可控的依赖。 是系统中描述一个图表的协议，它由一个  集合组成。一个可以转化成一个更容易操作的图表对象。
索引化切片
在   中， 仅仅在第一维上对  有所体现。如果一个  有维，那么一个  实例在逻辑上代表一个沿着这个  第一维的维切片的集合。切片的索引被连续储存在一个单独的一维向量中，而对应的切片则被拼接成一个单独的维 。如果  不是受限于第一维空间，请用 。
节点
图中的一个元素。 把启动一个特定操作的方式称为特定运算图表的一个节点，包括任何用来配置这个操作的属性的值。对于那些多形态的操作，这些属性包括能完全决定这个节点签名的充分信息。详见。
操作
在  的运行时中，它是一种类似  或  或 的运算。可以用【    】中的方法来向运行时添加新的操作。
在  的中，它是图中的一个节点。在【】类中列举出了这些操作。一个操作的  属性决定这个节点的操作类型，比如和。在一个运行的图中执行某种操作的行为。要求图必须运行在会话中。在  的  中，它是  类的一个方法【】。可以通过  来订阅或获取操作。
在的中，它是【】类的一个方法。
会话
启动图的第一步是创建一个  对象。 提供在图中执行操作的一些方法。在  中，使用【】。在  的中，【】是用来创建一个图并运行操作的类：

 的维度和它们的大小。在一个已经启动的图中，它表示流动在节点之间的  的属性。一些操作对  有比较强的要求，如果没有  属性则会报告错误。在  中，用创建图的  来说明  的  属性。 的 属性要么只有部分已知，要么全部未知。详见【】在中， 类用来表示  的维度。【】。

在   中，它用来表示在  中稀疏散落在任意地方的  。 以字典值格式来储存那些沿着索引的非空值。换言之，个非空值，就包含一个长度为的值向量和一个由列索引组成的矩阵。为了提升效率， 需要将 索引按维度的增加来按序存储，比如行主序。如果稀疏值仅沿着第一维度，就用 。

是一种特定的多维数组。比如，一个浮点型的四维数组表示一小批由，，组成的图片。
在一个运行的图中，它是一种流动在节点之间的数据。 在  中， 类表示添加到图的操作中的输入和输出，见【】，这样的类不持有数据。在中，是方法【 】的返回值，见，这样的  持有数据。原文：【】背景
本次是在腾讯云监控最详细数据数据量在非压缩情况下每天左右的数据，进行存储并提供接口多样化查询的背景下，使用进行实践，本文目的在于通过在监控数据中的应用，分享一种无阻碍快速使用的思路，而非最佳实践。
业务场景
监控数据大部分使用场景都是使用域名时间作为条件来查询数据，查询频率不高，并且提供给用户高频率查询有一层数据汇总缓存，减少了查询频率。典型的写多读少的场景。
数据字段：
域名，时间，指标名，平台，，指标值
为什么选择
、写入快，写数据时，首先会将请求写入 以确保数据不会丢失，然后再写入内存中的，超过内存容量后再将内存中的数据刷到磁盘的，并定期异步对做数据合并以减少数据读取时的查询时间。因为写入操作只涉及到顺序写入和内存操作，因此有非常高的写入性能。在测试中，数据写入速度，比要快。
、是列式存储及顺序写入，对于命中分区键的低频率顺序数据查询，效率还是比较理想，测试中查出个时间点所有域名域名并格式化，耗时在秒内。监控数据最小是一分钟数据，该读取速度能满足业务的需求。
、搭建简单，因为的区中心化模式，只需安装节点，配置同步后，修改、启动程序即可。可用性高。
、的一致性问题，可以通过多副本的方式来规避。比如开副本，写，读。
 在监控数据中的一些姿势
、不使用
 类型在中似乎是一个累赘个人观点。在分钟数据入库时，数据在汇总后，大概是行每分钟，此时只要调大，即可以支持，并且对系统的负载不会特别高。当使用分钟数据入库时，数据汇总后，数据量大概是行每分钟，字段使用后，节点频繁挂掉，并且出现大量写入超时及失败的情况。监控发现内存暴增，且集群负载极高，频率也特别高，集群不可用性极其高。的写入是会对数据进行一次查询后，再写入，所以可能会引起所有数据成为热点数据，引起集群负载异常。所以对于小量数据，使用是比较方便，但是数据量大了之后，建议放弃，且对于重入的数据，无法辨识，只能通过业务来消除，对业务逻辑造成一定的复杂度。
 对于的替代，监控数据中，每一批入库数据，使用一个唯一可识别的键值，对每行数据做唯一性标示，即避免了重入的问题，也避免了带来的集群不稳定问题。
、删除数据的姿势
 删除数据的时候，并不会直接删除，而是有一个被写进来，标示该数据已经被删除，并且等到__后，才会被删除。
  表的时候，会将该表的数据全部生成一个，且不会删除，必须人工删除或使用 来清理
 最细粒度数据存储的时候，使用直接往写数据，数据分表比较困难还没到这姿势，在数据写了一段时间后，磁盘告警。当时很傻很天真地以为使用遍历分区表键的方式，来清理数据，然而事与愿违，查询分区键的时候，出现大量超时且读不出来的情况，数据清理上突然间陷入了困境。即没办法分表删除，也没办法遍历分区键删除。这份数据真想不到要怎么清理了。再想到数据库都会有过期的一些做法。随即查了一下，发现有这个东西，经过一周测试，该方式是确实可行。但是查询超时的情况有所增长，但是在可接受范围，该超时情况暂时还没实际解决。
 删除数据当前使用了两种方式：
 、设置表的，并且调整__，一般建议秒，可以配合节点退出监控的间隔来设置，主要是避免墓碑被删掉之后，节点启动数据又重现。使用该方式，在数据入库时，可以直接写数据，不用再筛选数据。
 、数据分表，定时 历史表，使用 ，清理数据。使用该方式因为分表，在数据入库时，要对数据进行一次筛选。当使用 时，如果数据量太大，可能会引起_飙高，数据查询超时的情况。
、分区键的选择
 分区键的选择，这是一个数据建模的关键，对于查询速度，写入都有至关重要的影响。因为监控数据的业务场景都是必须通过域名来查询数据，所以域名做为分区键是再合适不过了，这样即可避免写入的热点问题，也实现了集群的负载均衡。但是又带来了一个问题，通过时间点或时间段查询数据，则无法查询。下一点则介绍了当前的解决方法。
、其他索引的建立非级索引
 通过数据冗余的方式，来建立索引。当前每一个时间戳的分区键都存到了，即建立了一层索引。为什么索引数据不直接写入？因为如果表的分区键使用时间戳，会带来全天写入的热点问题，导致某一节点负载特别高。所以当天的热数据索引都存到，第二天凌晨会将前一天的冷数据索引通过同步程序，同步到。
、数据写入的姿势
 数据写入，提供了接口和接口，接口已经不建议实用，对于数据的写入方式，提供了同步、异步和批量的写入方式。
 的批量写入的方式，每一批次的数据量是有限制的，每次提交太多行数据则会写入失败。上明确说了，它对提高写入效率并没有很大帮助，的主要功能是一种事务型的操作，但是在每次提交的数据中，如果是同一个分区的数据，或者同一个节点的数据，确实是能提高写入效率，因为它能避免了节点间的网络开销。上文章表示，可以实用异步写入的方式来替代。但是在实际的写入中，发现的写入速度还是可以的，不比异步写入慢，而且不需要等待回调。所以我还是使用了
、数据读取的姿势
 数据读取，尽量将大批量的查询划分成合适的小批量查询，分多次请求拉取，否则，容易出现查询超时的情况，因为对于不在的数据，会再到搜索，这样查询会有一定延迟。如果数据量比较大，超时情况会变严重。
、节点存活监控
 因为的节点容易出现莫名其妙挂掉的情况，所以在每一个节点部署的时候，都加了一个进程存活的旁路监控脚本，实时监控，并拉起进程。
、调整
 调大，可以减少数据频繁从 到，且数据可以更多到内存，增强查询效率，但是如果过大，的时候，容易产生节点过长时间的不可用，所以的设置，这个得根据具体的场景和的来调整。暂时还没研究到具体的算法可以确定这个值。就目前的数据量，我是配置了的，暂时还没发现什么特别大的问题。
、版本变动会有不向下兼容的情况
 除了重新搭建，不会更新版本，这个大坑，当某个版本使用稳定了之后，则固化不升级。
暂时未解决的一些问题：
、数据查询超时
 对于部分数据量比较大的查询，会存在第一次查询超时的情况，必须发起第二次重试，才可正常查询，或者把大批量查询分多次查询来实现。
、节点程序莫名关闭
 该问题暂时无解，现在的处理方式是，监控进程是否存在，如果不存在则拉起程序并发告警。
、遍历分区键的问题
  分区键的时候，键比较多，几十到上百万，查询时只能查询到前面的部分键，查到后面基本都回超时，使用分批查询时超时的情况也是必现，暂时无解。目前的替代方式，是对当天活动的分区键冗余存到，每天凌晨同步一次到的一个表中，这样来避免分区键实时入的热点的问题，且保留了遍历分区键的功能。
总结
监控数据利用了的高可用，写入速度快，搭建简单等特点，存储了每天高达的数据。通过数据冗余建立索引、分区键的选择、调整，支持了多样化的查询。通过外部旁路监控程序监控进程等手段保证了集群的高可用。弃用类型，保证数据的唯一性和节点的高可用性。
文章相对比较少，版本间变动比较大，在监控数据的应用中，只是将当做一个高可用，灵活扩展的存储来使用，使用了其中最简单和最常用的功能。在以往的测试过程中，每当遇到程序出现  的状况，我的第一反应就是有 ，让开发定位原因，但是如果自己能够去挖掘原因，在与开发沟通的过程中能明确指出问题所在，一定能提高沟通，定位问题的效率。
最近利用空余时间学习了一下  的基本知识，发现有很多新的发现其实是自己以前不知道，呵呵，在这里分享给大家，希望对大家有所帮助。
  文件的简单介绍
在一个程序崩溃时，它一般会在指定目录下生成一个  文件， 文件包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息等，可以帮助我们进行调试。
 造成  的常见原因

内存访问越界

多线程程序使用了线程不安全的函数

多线程读写的数据未加锁保护

非法指针

堆栈溢出


       文件的生成开关和大小限制
使用  – 命令可查看  文件的生成开关，若结果为，则表示关闭了此功能，不会生成  文件。

使用  –  命令，可以限制  文件的大小，如果此文件大小超过限制，将会被裁剪，最终生成不完整的  文件。若为  –  ，则不限制  文件的大小。
 注意：在测试前需检查  文件的开关是否打开；在测试过程中发现程序异常退出，但没有产生  ，我们也需要第一时间检查  文件是否打开；有几种方式让程序产生  。

修改  文件生成大小的配置，例如  –  ，这个修改只对当前会话有效。

通过将一个相应的    语句添加到由登录    读取的文件，如  ，例如在用户下的  增加  –  ，那么对于  用户就可以生成没有大小限制的  文件，但是对于其他用户不生效。

修改  文件，将默认配置     ，将配置改成可用，并设置为    ，那么该机器的所有用户都将生成无大小限制的  文件。

在程序的启动脚本例如  的开头设置  –  ，这只是对该进程有用。


        文件的名称和生成路径设置
若系统生成的  文件不带其他任何扩展名称，则全部命名为 ，新的  文件生成将会覆盖原来的  文件。
 __ 可以控制  文件的文件名是否添加  作为扩展。文件内容为表示添加  ，生成的  文件格式为  ，为表示不添加。可以通过以下命令修改此文件：  “”  _ 。
 _可以控制  文件保存位置和文件名格式。可以通过以下命令修改此文件：
 “” _，可以将  文件统一生成到    目录下，产生的文件名为   命令名    时间戳，以下是参数列表：
表示添加；

表示添加当前；

表示添加当前；

表示添加导致产生的信号；

表示添加文件生产时的时间；

表示添加主机名；

表示添加命令名；
 如何查看  文件
如果我们不清楚  是由哪个进程产生的，我们可以通过使用命令 “   文件 ”来查看。
例如  文件是由  这个进程产生的，那么通过命令 “     ” 查看  文件的内容，在输入  或  检查程序运行到哪里，来定位  的行。
我们查看一个的例子，例如在启动时出现了 ，内容为：

我们可以看到在  的行调用  函数出现错误，从而抛出了信号，产生了  。
 显示的内容为堆栈信息，我们可以通过输入  来查看上一层堆栈的信息，例如：我们最初看到  文件信息为：

连续输入  后，显示内容为：

  常用命令
有些  能简单的定位出，但是有些  文件的定位还需要了解  常用的命令，通过这些命令与  文件结合，我们才能快速定位出问题。下面简单的介绍一下  常用的命令：
：相当于，从第一行开始列出原码；

回车：表示重复上一次命令；

：的缩写，打印变量的值，格式为 变量名；

：设置断点，例如 表示在行设置断点， 表示在函数入口处设置断点；

 ：查看断点信息；

：表示运行程序；

：继续运行程序；

：的缩写，表示单步运行；

：查看函数堆栈；

：退出函数；

相关推荐【腾讯云的种玩法】服务器配置系列一服务器的配置做开发十年，我总结出了这些开发经验导语
随着前端技术快速发展，前端开发模式先后经历了静态黄页时期、服务器组装动态网页数据时期、后端为主的模式时期、前后端分离时期、纯前端直出、前端 、前后端同构时期。《体育视频播放页》基于开发，此次开发总结，将会总结开发过程中涉及到的知识点以及开发技巧，希望能帮助到想要在工作中使用开发的小伙伴。
专辑页地址：
单视频页地址：
一、技术选型
基础框架搭建           
  环境配置需要环境，使用安装相应的依赖包

  及以上

  及以上


 快速安装
    
    
  
  
   

 自带命令测试部分可配置
  
 

      
  

     
  

   
  

   
  

   
 

 开发环境
   

   代码构建
   

  代码发布
   

二、组件化构建
组件系统是  的另一个重要概念，因为它是一种抽象，允许我们使用小型、自包含和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树。


  页面，组件树如下：

  页面，组件树如下：

三、文件目录结构
为开发目录
用来存放、、等资源文件
存放组件
 存放多页面模版组件
 主程序入口
 页面入口
 定义项目所需要的各种模块，以及项目的配置信息
 执行命令以及配置项
 构建后文件目录

四、技术点
 核心插件   ： 
安装：   
如果在一个模块化工程中使用它，必须要通过  明确地安装路由功能：
 如果使用模块化机制编程，導入和，要调用 
   
   


将组件映射到路由，然后告诉  在哪里渲染它们
 创建  实例，设置参数，并定义路由
  =  {
   
   
    {
       
       
    }
    {
       
       
    }
    {
       
       
    }
  
}

 创建和挂载根实例
  =  {
  
}
 核心插件   不再继续维护，并推荐大家使用 
                 
用法：

 
 
 
 
  
  
  

   
  
   

    
  
   
下面在列举一些基础知识：
 声明式渲染 ｛｛｝｝

 视频标题 
    ={{  }}
 视频标题 
 
  {
   
    {
     ： 视频标题
  ｝
｝
  条件与循环 、、
 =现在你看到我了  惰性的，如果不需要显示，则什么都不做
 =现在你看到我了  通过隐藏显示

     =  
      {{  }}
    

  单元素组件过渡 、

   =
    {{  }}
  

 = =
     =   = =
      {{  }}
    

  组件 使用传递参数
 {
   声明 
   
   就像  一样， 可以用在模板内
   同样也可以在  实例中像 “” 这样使用
   {{  }}
}
 =
  非父子组件通信 
有时候两个组件也需要通信非父子关系。在简单的场景下，可以使用一个空的  实例作为中央事件总线：
  =  
 触发组件  中的事件
 
 在组件  创建的钩子中监听事件
   {
   
}本文首发于  

基础词汇解释：
 记录、记录传输：利用解析过程，在请求解析的域名中包含需外传的数据，如。则最终的服务器会收到这个数据回传。
的类型回包：一般指为某个主机名或域名设置的说明，可被黑客利用回传数据。终端请求某恶意域名的解析，返回记录，包含黑客需要的回传内容，如模块更新数据、指令等
正文
概述：
随着越来越多的公司安全意识提高，大量公司已封锁通信，仅允许员工通过协议外网，同时采取了越来越多针对协议的检测措施如数据分析恶意等。为逃避检测，传输已逐步成为越来越多的恶意软件隐蔽传输的方法，传输利用逐级解析过程最终把域名中的恶意内容传输到远端控制器，也利用的类型回包更新本地木马病毒。
为解决此问题，笔者提出基于全代理的恶意传输屏蔽方案，通过禁止终端做解析，仅允许代理做，完全屏蔽的恶意传输的同时，保障终端可以通过代理访问公网备：这也是各大公司当前采取的上外网的方式通用方案，有效解决恶意传输问题。适用于各大公司彻底解决木马病毒传输通道问题。
基本思想与原理
具体原理如下所述：
、固定的服务器配置，并禁止修改，防止木马病毒修改绕过安全策略，或用户修改配置无意降低安全标准
、屏蔽外联的端口访问，防止恶意程序在代码中使用自定义服务器
、收紧终端的解析，服务器仅响应允许的白名单域名解析，其他不返回结果
、通信全代理，允许代理自身做解析
最终实现完全屏蔽的恶意传输的同时，保障终端可以通过代理访问公网，解决恶意传输问题。
系统架构
模块功能描述：

内网终端：内网用户使用的访问公网的终端，可包括、手机、平板等
代理 提供协议的代理，终端可通过此代理访问外网数据
服务：外网的服务
内网终端专用服务器：给内网终端提供服务，仅限白名单域名的解析
白名单：允许被解析的域名，如等
代理专用服务器：给代理提供服务器，不提供黑名单解析，降低恶意业务访问
黑名单：提供恶意域名清单，禁止代理专用解析，进而禁止代理访问恶意
公网服务：外网服务器，包括各个递归服务器
其他服务器：内网终端专用服务器外的其他服务器，包括公网服务器、代理专用服务器等
实验环境演示：
、        实验环境介绍
     一台内网终端， 系统
            ：
          网关：
          ：内网终端专用
     一台服务器内网终端专用， 
           
           网关：
          ：
     一台代理服务器，系统
          
          网关：
          ：代理专用 
     防火墙，禁止内网终端非授权访问，仅允许网关、内网终端专用、代理访问，或白名单程序的连接不支持代理，联通需要内网终端专用白名单配合
、        配置过程：
     终端配置
          锁定配置，防止用户或木马病毒修改：
系统可使用这个

可使用此工具

           配置代理，访问外网：

     服务器配置
           使用条件转发不允许解析白名单以为域名

清空根提示防止无法控制的递归



确认，不可禁止递归否则无法实现条件转发



如果允许解析，则配置到代理专用，可实现递归解析


     配置
          配置黑名单，例如：淘宝、京东，防止员工上班购物，当然从安全角度可配置各种黑域名

          配置代理专用，可解析任意域名

     防火墙配置允许访问内网专用：，允许访问网关，允许访问代理，其他均不允许，防止用户使用其他或

、        效果展示：
     终端无法进行请求除了白名单域名

     外联失效前后对比
未实施策略前，可外传成功有返回包

实施策略后，无法外传无回包

     终端不配置代理，无法访问服务器终端无法进行解析，且无法直接访问外网


     终端配置代理可正常上网，但无法访问黑名单网站，保障日常互联网需要，并防止访问恶意域名


原理细节详描
、 终端使用代理访问公网服务，如下图

      终端不解析域名，将请求直接抛给代理
          浏览器可通过脚本等方式劫持终端到公网的流量经代理中转
           其他软件可通过配置代理地址等方式
      代理向代理专用服务器请求域名解析并获取结果，如下图

          代理服务器向代理专用服务器请求域名
          代理专用查询黑名单，如匹配则返回禁止解析，如不匹配则进一步向公网服务请求结果并返回
           代理专用服务器返回结果给代理，如为黑名单则返回默认警示页面地址
      代理根据反馈结果访问公网
、 禁止终端进行解析，仅开放白名单域名解析：
      屏蔽终端的解析仅允许部分白名单域名解析，如下图：

          部分未配置代理的程序请求解析，请求发送内网终端专用服务器
          终端专用服务器查询白名单，如在白名单例等，则进一步向公网查询并返回结果，如不是白名单则返回无法解析
      固定的服务器配置并屏蔽到其他服务器的端口访问，防止恶意程序自定义配置，如下图：

           通过防火墙等措施封闭终端出去的端口专用端口，仅开通到内网终端专用服务器的解析前言
最近在跟进的相关工作，由于之前对并不怎么了解，因此系统地学习了下，为了加深对的理解，对相关知识点做了笔记，并在组内进行了相关技术的分享，由于涵盖的内容比较多，因此计划分享期，下面就是针对第一期技术分享整体而成，第一期的主要内容如下
一、介绍二、的介绍三、的写逻辑介绍四、的故障恢复五、的拆分和合并
如下所示：

下面就来针对各个部分的内容来进行详细的介绍：
一、介绍
、简介
是 的简称 ，项目是由公司的 和 在年末发起，根据的等人发表的论文“：      “来设计的。年月发布了第一个版本。年月，从子项目升级成顶级项目。
是分布式、面向列的开源数据库其实准确的说是面向列族。为提供可靠的底层数据存储服务，为提供高性能的计算能力，为提供稳定服务和机制，因此我们说是一个通过大量廉价的机器解决海量数据的高速存储和读取的分布式数据库解决方案。
、几个特点介绍
提炼出的几个特点，如下图所示：

、海量存储
适合存储级别的海量数据，在级别的数据以及采用廉价存储的情况下，能在几十到百毫秒内返回数据。这与的极易扩展性息息相关。正式因为良好的扩展性，才为海量数据的存储提供了便利。
、列式存储
这里的列式存储其实说的是列族存储，是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。为了加深对列族的理解，下面是一个简单的关系型数据库的表和数据库的表：
的表：

的表：

下图是针对和关系型数据库的基本的一个比较：

、极易扩展
的扩展性主要体现在两个方面，一个是基于上层处理能力的扩展，一个是基于存储的扩展。通过横向添加的机器，进行水平扩展，提升上层的处理能力，提升服务更多的能力。
备注：的作用是管理、承接业务的访问，这个后面会详细的介绍通过横向添加的机器，进行存储层扩容，提升的数据存储能力和提升后端存储的读写能力。
、高并发
由于目前大部分使用的架构，都是采用的廉价，因此单个的延迟其实并不小，一般在几十到上百之间。这里说的高并发，主要是在并发的情况下，的单个延迟下降并不多。能获得高并发、低延迟的服务。
、稀疏
稀疏主要是针对列的灵活性，在列族中，你可以指定任意多的列，在列数据为空的情况下，是不会占用存储空间的。
、的几个概念介绍
在我学习的时候有几个概念需要重点理解一下，列出个基础概念如下图所示：

、 的概念
 又叫列族，通过列族划分数据的存储，列族下面可以包含任意多的列，实现灵活的数据存取。刚接触的时候，理解起来有点吃力。我想到了一个非常类似的概念，理解起来就非常容易了。那就是家族的概念，我们知道一个家族是由于很多个的家庭组成的。列族也类似，列族是由一个一个的列组成任意多。
表的创建的时候就必须指定列族。就像关系型数据库创建的时候必须指定具体的列是一样的。
的列族不是越多越好，官方推荐的是列族最好小于或者等于。我们使用的场景一般是个列族。
、的概念
的概念和中的主键是完全一样的，使用来唯一的区分某一行的数据。
由于只支持中查询方式：

基于的单行查询
基于的范围扫描
全表扫描

因此，对的性能影响非常大，的设计就显得尤为的重要。设计的时候要兼顾基于的单行查询也要键入的范围扫描。具体要如何设计后续会整理相关的文章做进一步的描述。这里大家只要有一个概念就是的设计极为重要。
、的概念
的概念和关系型数据库的分区或者分片差不多。会将一个大表的数据基于的不同范围分配到不通的中，每个负责一定范围的数据访问和存储。这样即使是一张巨大的表，由于被切割到不通的，访问起来的时延也很低。
、的概念
对来说至关重要，因为它是实现多版本的关键。在中使用不同的来标识相同行对应的不通版本的数据。
在写入数据的时候，如果用户没有指定对应的，会自动添加一个，和服务器时间保持一致。在中，相同的数据按照倒序排列。默认查询的是最新的版本，用户可同指定的值来读取旧版本的数据。
、的架构
的架构图如下图所示：

从图中可以看出是由、、、、等几个组建组成，下面来介绍一下几个组建的相关功能：
、
包含了访问的接口，另外还维护了对应的来加速的访问，比如的元数据的信息。
、
通过来做的高可用、的监控、元数据的入口以及集群配置的维护等工作。具体工作如下：
通过来保证集群中只有个在运行，如果异常，会通过竞争机制产生新的提供服务
通过来监控的状态，当有异常的时候，通过回调的形式通知 上下限的信息
通过存储元数据的统一入口地址
、
节点的主要职责如下：为分配维护整个集群的负载均衡维护集群的元数据信息发现失效的，并将失效的分配到正常的上当失效的时候，协调对应的拆分
、
直接对接用户的读写请求，是真正的“干活”的节点。它的功能概括如下：管理为其分配的处理来自客户端的读写请求负责和底层的交互，存储数据到负责变大以后的拆分负责的合并工作
、
为提供最终的底层数据存储服务，同时为提供高可用存储在的支持，具体功能概括如下：提供元数据和表数据的底层分布式存储服务数据多副本，保证的高可靠和高可用性
、的使用场景
是一个通过廉价机器集群来存储海量数据的分布式数据库解决方案。它比较适合的场景概括如下：

是巨量大百、级别
查询简单基于或者范围查询
不涉及到复杂的关联

有几个典型的场景特别适合使用来存储：海量订单流水数据长久保存交易记录数据库历史数据
二、的介绍
前面已经介绍了类似于数据库的分片和分区的概念，每个负责一小部分范围的数据的读写和维护，包含了对应的起始行到结束行的所有信息。将对应的分配给不同的，由来提供的读写服务和相关的管理工作。这部分主要介绍实例以及的寻找路径：
、实例

上图模拟了一个的表是如何拆分成，以及分配到不同的中去。上面是个表，里面有条记录，其中为到的记录被分配到了上，为到的记录被分配到了上，而为、和的记录则被分配到了上。和被分配给了，被配分给了
备注：这里只是为了更容易的说明拆分的规则，其实真实的场景并不会几条记录拆分到不通的上，而是到一定的数据量才会拆分，具体的在的拆分那部分再具体的介绍。
、的寻址
既然读写都在上发生，我们前面有讲到，每个为一定数量的服务，那么要对某一行数据做读写的时候如何能知道具体要去访问哪个呢？那就是接下来我们要讨论的问题
、老的寻址方式
在 版本以前，有两个特殊的表，分别是表和表，其中的位置存储在中，本身存储了  的信息，并且不会分裂，只有一个。而表可以被切分成多个。读取的流程如下图所示：

第步：请求获得所在的地址
第步：请求所在的地址，获取表的地址，会将的相关信息下来，以便下一次快速访问
第步：请求 表的地址，获取访问数据所在的地址，会将的相关信息下来，以便下一次快速访问
第步：请求访问数据所在的地址，获取对应的数据
从上面的路径我们可以看出，用户需要次请求才能直到用户真正的位置，这在一定程序带来了性能的下降。在之前使用层设计的主要原因是考虑到元数据可能需要很大。但是真正集群运行，元数据的大小其实很容易计算出来。在的论文中，每行数据存储大小为左右，如果按照一个为的计算，层设计可以支持的个数为个，采用层设计可以支持。那么层设计的情况下一个 集群可以存储的数据。这仅仅是一个只有的情况下。如果是呢 因此，通过计算，其实层设计就可以满足集群的需求。因此在版本以后就去掉了表了。
、新的寻址方式
如上面的计算，层结构其实完全能满足业务的需求，因此版本以后将表去掉了。如下图所示：

访问路径变成了步：
第步：请求获取所在的的地址。
第步：请求所在的获取访问数据所在的地址，会将的相关信息下来，以便下一次快速访问。
第步：请求数据所在的，获取所需要的数据。
总结去掉的原因有如下点：
其一：提高性能其二：层结构已经足以满足集群的需求
这里还有一个问题需要说明，那就是会缓存的数据，用来加快访问，既然有缓存，那它什么时候更新？如果更新了，比如不在上了，被转移到了上。的缓存没有更新会有什么情况？其实，的元数据缓存不更新，当的数据发生更新。如上面的例子，由于的位置发生了变化，再次根据缓存去访问的时候，会出现错误，当出现异常达到重试次数后就会去所在的获取最新的数据，如果所在的也变了，就会去上获取所在的的最新地址。
三、的写逻辑
的写逻辑涉及到写内存、写、刷盘等操作，看起来简单，其实里面又有很多的逻辑，下面就来做详细的介绍
、写入逻辑
的写入流程如下图所示：

从上图可以看出氛围步骤：
第步：获取数据写入的所在的第步：请求写第步：请求写
只有当写和写都成功了才算请求写入完成。后续会逐渐刷到中。
备注：存储在，当出现异常，需要使用来恢复数据。
、刷盘
为了提高的写入性能，当写请求写入后，不会立即刷盘。而是会等到一定的时候进行刷盘的操作。具体是哪些场景会触发刷盘的操作呢？总结成如下的几个场景：
、全局内存控制
这个全局的参数是控制内存整体的使用情况，当所有占整个的最大比例的时候，会触发刷盘的操作。这个参数是，默认为整个内存的。但这并不意味着全局内存触发的刷盘操作会将所有的都进行输盘，而是通过另外一个参数来控制，默认是整个内存的。当到所有占整个内存的比率为的时候，就停止刷盘。这么做主要是为了减少刷盘对业务带来的影响，实现平滑系统负载的目的。
、达到上限
当的大小达到大小的时候会触发刷盘，默认大小
、的数量达到上限
前面说到为了保证数据的一致性，那么如果太多的话，会导致故障恢复的时间太长，因此会对的最大个数做限制。当达到的最大个数的时候，会强制刷盘。这个参数是，默认是个。
、手工触发
可以通过 或者 手工触发的操作。
、关闭触发
在正常关闭会触发刷盘的操作，全部数据刷盘后就不需要再使用恢复数据。
、使用恢复完数据后触发
当出现故障的时候，其上面的会迁移到其他正常的上，在恢复完的数据后，会触发刷盘，当刷盘完成后才会提供给业务访问。
、
、简介
是实现  方式产生的日志信息，内部是一个简单的顺序日志。每个对应个备注：版本的可以开启功能，允许多个，所有对于该的写入都被记录到中。实现的功能就是我们前面讲到的保证数据安全。当出现问题的时候，能跟进来做数据恢复。此外为了保证恢复的效率，会限制最大保存的数量，如果达到的最大个数参数控制的时候，就会触发强制刷盘操作。对于已经刷盘的数据，其对应的会有一个过期的概念，过期后，会被监控线程移动到 ，然后会被自动删除掉。
是如何判断过期的呢？要找到这个答案，我们就必须了解的详细结构。
、结构
下图是的详细结构图片来源  ：

从上图我们可以看出都个共享一个文件，单个在中是按照时间顺序存储的，但是多个可能并不是完全按照时间顺序。
每个最小单元由和两部分组成。由、、 、以及等组成，是由一系列的组成，对一行上所有列即所有的更新操作，都包含在同一个对象中，这主要是为了实现写入一行多个列时的原子性。
注意，图中有个的东东。是一个级别的自增序列号，这东东非常重要，的数据恢复和过期清除都要依赖这个东东。下面就来简单描述一下的相关逻辑。

在达到一定的条件会触发刷盘的操作，刷盘的时候会获取刷新到最新的一个的下一个，并将新的赋给，并刷到中。有点绕，举个例子来说明：比如对于某一个，开始的时候为，此时，如果触发的操作，假设初始刷盘到为，那么会在的基础上一个空的到，最新的为，然后将为的号赋给，并将的值刷到文件中进行持久化。
文件对应所有的中最大的如果已经刷盘，就认为文件已经过期，就会移动到，等待被移除。
当出现故障的时候，需要对进行回放来恢复数据。回放的时候会读取的中的和中的进行比较，小于的就直接忽略，但与或者等于的就进行重做。回放完成后，就完成了数据的恢复工作。

、的生命周期
从产生到最后删除需要经历如下几个过程：

产生所有涉及到数据的变更都会先写，除非是你关闭了

滚动的大小通过参数控制，默认是个小时，时间达到 设置的时间，会创建一个新的文件。这就实现了滚动的目的。通过参数控制的个数。滚动的目的，为了控制单个文件过大的情况，方便后续的过期和删除。

过期前面我们有讲到这个东东，的过期依赖于对的判断。会将的和最大的刷新到的最新位置进行比较，如果该文件中的比刷新的最新位置的都要小，那么这个就过期了，过期了以后，对应会被移动到目录。这里有个问题，为什么要将过期的移动到目录，而不是直接删除呢？答案是因为还有一个主从同步的功能，这个依赖来同步的变更，有一种情况不能删除，那就是虽然过期，但是对应的并没有同步完成，因此比较好的做好是移动到别的目录。再增加对应的检查和保留时间。

删除如果开启了，当执行完一个的时候，会删除上的对应节点。在被移动到目录后，每隔默认秒时间会去检查目录下的所有，确认对应的的节点是否被删除，如果 上不存在对应的节点，那么就直接删除对应的。默认分钟这个参数设置在目录保留的最长时间。

更多相关内容详见： 技术细节笔记下一、引言
本次腾讯社交广告算法大赛以移动广告转化率预估为背景，以移动广告为研究对象，预测广告点击后被激活的概率：== | ，即给定广告、用户和上下文情况下广告被点击后发生激活的概率。大赛为我们提供了非常珍贵的真实数据，使得我们有机会把平时所接触到的理论加以实践，下面我们分享一些我们参赛过程中的心得体会。
二、数据，特征与模型
数据使用方面，几位周冠军同学都做了很好的分享，合理的选择线下测试集，使线下线上同步即可，唯一需要注意的就是数据的时序性，提取特征时要小心不要发生数据泄漏。在模型方面，因为之前没有转化率预测方面的经验，我们查看了上类似的几个比赛的成功经验，发现在这类问题上表现较好的大概有两类模型：与这类针对类稀疏特征的模型，以及这类主要采用特征的模型。
经过了一些尝试，我们发现，并没有取得预期的结果，这个不知道是我们的使用姿势不正确，还是激活数据本身与广告数据有所区别。后来通过同学们在公众号以及群中的分享，我们转向了模型，专注于点击数，激活数，转化率等各类统计特征，并进行组合特征的提取。这样粗暴的做法使得我们的特征维数很快就超过了维，但是成绩并没有相应的提高，反而大大的增加了模型训练时间，于是我们开始着手精简手上的特征，精简的方式，一方面是通过查看的 的结果，另一方面对于一些通过我们对业务的理解觉得重要的特征我们进行单独的验证，渐渐的我们的成绩有了提高。做特征时我觉得最重要的就是要细心，每一个细节可能都会有小小的提高。
这里分享一下我们最初做的数据分析：








初赛后期很多队伍进行了模型融合，取得了非常显著的提高，这里我们介绍一下我们的融合策略。我们分别尝试了模型加权平均三种模型融合方式。采用融合的模型为模型，模型以及 的模型，对于不同的模型我们进一步的采取了不同的特征进行训练，进一步的增加模型的多样性。其中方法提升最为显著，这里详细介绍一下。
相比于简单的模型加权平均以及，可以更好的利用训练数据，这以   为例，说明下说明下我们的融合策略，集上的操作如下图所示：

我们在第一层选取，五个模型进行融合，上图即描述了具体的融合过程。对于模型首先我们将训练数据随机的分成份，用其中的份数据上图左侧蓝色部分预测余下的份数据上图左侧黄色部分，重复上面过程次，将次预测结果放到一起就得到了上图中右侧的新特征，对于五个要融合的模型重复上述过程，我们就的到了维新特征。这维度新特征将会在第二层的中起到训练数据特征的作用。
对与数据在是在第二层的维特征，我们通过下图方式得到：

以模型为例，上面已经说了在集上用其中的份数据预测余下的份数据这个行为被重复了次，每一次我们不止预测余下的份数据，我们也对整个数据集进行预测，这样我们就对集预测了次，对次预测取平均，我们就得到了集上的新特征。对模型到模型我们在集上重复上述过程，得到另外的维特征。这样我们便在集上得到了与集上维新特征对应的特征。在第二层，我们依然选取模型，此时和集上的特征即为地一层生成的新特征。
我们目前采取的融合策略还是相对简单的，模型数量和种类相对较少，所选模型都是  ，复赛中我们希望能结合，等差异性较大的模型进行融合得到更好的结果。
三、展望
初赛已经接近了尾声，整个过程学到了非常多的知识，从特征的处理再到模型的选择，参数的调节，都有了更深的认识，非常感谢主办方能让我们接触到这么珍贵的数据，期待复赛更大数据给我们带来的挑战。作者：

大家好，给大家介绍一下，这是

应该有很多的用户熟悉上面这图。。。
一、背景
国庆前几天，微信大量用户反馈接收或发送类似“。。。。。。。。。。。。。。。”信息会导致微信聊天界面卡死，整个垮掉，竟然垮掉。这对微信来说是很严重的事情啊，一时半会反馈也铺天盖地的过来，我们得知这个问题后，第一时间对这个问题进行了紧急修复并在两天内覆盖了全网大部分用户，最终这个问题得到了解决。追根溯源，毫无疑问这锅开发小弟来背，这次不能冤枉了产品哈哈。
与此同时，很多热心的网友也开始分析原因，号当日就有行内大神通过日志和反编译，一步步推敲出此次的根源，给出了卡死的原因。请受小弟一拜，实在佩服佩服！原文链接
下图是网友分析结果图：

根据该网友的推敲，此次卡死的真正原因在于：“这个是始终等于的，也就是不满足内部的的置空条件，也就造成了死循环”。这里具体怎么做到动态反编译的？这个知乎的回答很详细，学习可参见：链接
二、原因揭晓：
真正的原因确实如网友分析的，主要是卡在了这个循环里面，这个循环的主要作用是将当前文字内容按具体的规则进行断句排版。

因为且一直不为空，一直满足这个条件，所以造成死循环。而这个值为的条件取决于下面这个函数

“”变量实际是断句算法返回截断的实际位置，实际是当前行的文字长度，这里因为断句算法的，造成了””这个变量一直返回，而当前行文字长度是的，所以这个永远不会被赋值为空。继续追根问底：是什么原因造成断句算法一直返回呢，实际上断句算法是调用了以下这个函数：

该函数返回了一个对象其包含两个参数，一个是断句的位置，及断句后的文字长度，主要是因为在判断换行的时候，因为考虑到标点符号不应该位于行首这条规则，需要将当前行最后一个非标点符号截断到下一行，而截断受另外一条规则限制，截断不可以为英文或者数字，这导致。。。。。。。。。。。最后返回截断的位置为，并将结果返回，所以才产生了死循环，造成这个。
那么问题来了
很多网友也开始讨论，为什么要自己排版，放着好端端的系统不用？到底好在哪里？效果是怎么样的？不着急，诸多问题的来龙去脉得容小弟一一道来。
三、为什么有这个需求
实际上，世界上大部分需求都源于用户。这需求还得得益于之前有几个用户会反馈说“微信的聊天气泡好像没有的美观，比较死板”。这个问题也引起了我们的关注。那事实是否如此呢？我们对和进行了对比，如下图：

从效果图看，确实比好看了些，至少最右边并不会有多余的这么明显，简单来说多余的产生的原因是气泡宽度受屏幕大小的限制，所以这里即是气泡有了最大的宽度限制，当剩下的空间不足以容下一个字符时，系统排版会选择自动换行，导致了这个问题的产生。
又一个问题
那么，的排版是否就是完美的呢，其实仔细观察并非这样，从上图可以看出，除了，也会有这种问题，那就是气泡中的文字左右参差不齐。
一开始我们怀疑，会不会是微信应用本身使用该组件不当的原因造成，而非系统组件的问题。于是乎，在手机上，我们随便找了一些热门，仔细对比，同样的问题依然存在。
知乎：

掘金：

支付宝：

等等。。。
而且除了移动端，端同样也有诸类问题。结合上面这些对比，确实市面上大部分应用都存在这个问题。通过这次反馈，我们也开始在思考能不能在移动客户端的文字排版上做得更人性化一些，体验上更好？。就这个问题，我们找了设计的同学一起探讨，认为确实有这个必要。于是就开始有了下一步。
四、排版要怎么排？
对于文字排版，这容易让人想起，“我的哥”，微软对于这款应用，有没有一些文字左右对齐的手段或者方案可以参考呢？
下图为的左对齐效果，也就是的默认对其方式。

下图为的居中‘硬’对齐效果：

下图为的居中‘软’对齐效果：

从这种效果上看，“软对齐方式”更美观，体验最好。于是我们能想到的就是动态调整字间距的方式来实现这种效果也是这么实现的。
那既然要动态调整字体间距，是不是可以一味的这么做就可以？答案当然不是，如果这么做就像‘硬对齐方式’一样，显得过于生硬了。
我们就这个问题跟设计组的同事进行讨论，通过他们的调研及尝试，得出了一个合理的方案，那就是最多允许有一个英文字符宽度的调整范围，将调整的宽度平均分配到当前行每个字符中去，对用户来说影响是最小的，同时也保持了一定的美观。
五、实践自定义排版
对于来说，实现这条规则并不难，要么是改造系统，要么自己写个自定义实现文字排版及渲染，最后我们采用了后者这个方案。
原因在于：
系统真正排版及绘制的逻辑不在其本身，而是交给三个继承了的子类负责，分别为、、，我们更常用的是，它只负责静态的文字处理，关于各自的区别，这里了就不展开讲了。系统并没有暴露接口去代理它们。当然没有接口不意味着做不到，我们完全可以通过反射等手段代理它，但其实这么做的话，代价是比较大的。
原因有三：
其一，从 到 ，的代码虽说变化不会很大，但从来看，实现的逻辑或者接口也好都有所变更，如果通过这个方式，代理的兼容性会是一个问题。
其二，堪称最复杂的一个组件之一，几个逻辑代码的复杂程度很高，自己实现所有的接口，本身就是一件复杂且工作量很大的工作。
其三，实际上自己实现一个，基本上就实现了一个显示组件，排版和渲染都是要处理的，所以这样实现的意义不大，甚至反而不灵活。
回归正题，我们对系统的规则进行对比，最后我们确定了以下几条规则：
、最多允许有一个字母字符宽度的来调整字间距、对于标点符号尽量规避不出现在行首、对于英文单词或数字不截断排版
于是我们开始进行简单的实现。效果如下图：

对比优化前的效果，确实这么做效果是明显的。但仔细观察，还是会发现，对于一些特殊的中文全角符号如，《》【】等因为有多余的存在，放在行首和行末也会导致参差不齐的效果。于是我们多增加了一条规则
、对一些常见的有多余的全角符号位于行首或行末时，默认减去多余的来达到更好的对齐效果。
最后的优化效果，如图：

最后一张是应用了条规则的效果图，整体文字的对齐效果比系统默认的排版改善了不少。
问题又来了
那既然效果是不错的，是否存在其他问题？确实如此。
一、小语种处理问题
因为微信对小语种是支持的，对于一些特殊的小语种，如泰语，阿拉伯语等，泰语的排版方式并非简单的横排，字符与字符之间是有上下关系的，而对于阿拉伯语，是从右往左排列的。如果只是按上面所讲的几个规则，那么排版后的效果肯定是不合理的。考虑到小语种存在多样性，排版规则不统一，而且使用小语种用户比例小，但也不能让其排版错误不管，所以对于这种情况，我们通过一个简单的正则表达式去匹配是否属于能处理的字符串范围内，这就是为什么有网友分析”。。。。。。。。”这个事件时，一开始会怀疑是正则匹配耗时造成的。下图为该网友的分析：

而实际上，这个简单的正则表达式，如该网友测试的一样，处理起来很快，基本都在内，对性能的影响可忽略。
通过正则去判断后，如果是可处理的字符串则应用上面的规则进行排版，如果是特殊的字符串，则用系统的代理显示。
二、适配率问题
既然小语种的问题可以解决，但这里又产生一个问题，现网上的用户， 使用特殊字符的频率多高？这问题直接关系到我们这个排版组件的适配率，也就是对用户体验改善多少？在我们看来，一般人并不会发些奇奇怪怪的符号在微信里面，所以能应用上这个排版规则的应该占大多数。当然这里只是猜想，如果这样确定可行性也太草率了。于是我们针对这个问题，进行了一轮灰度，灰度的结果如下：



灰度
结果




目标灰度人数



总次数



平均命中率




通过这次灰度，现网用户能应用上该组件适配的情况达到了预期的结果。
三、性能问题
如果该组件的性能跟系统相差太多，甚至严重影响帧率，造成用户卡顿，这当然也是不可取的。我们针对这个问题，进行了本地的自动化帧率测试及与系统进行函数间的对比：实验数据：














聊天界面，各类长短文本，跑同一个，在好机器上的帧率





差机器上的帧率





相同的文字，连续每隔，一次，统计次平均耗时





触发，次的平均耗时





触发，次的平均耗时





整个过程，次的平均耗时



结论：

从微观上，通过函数进行对比，对比系统性能稍差倍，主要差距在于绘制文字时需要单字调整间距。
从宏观上，对实际帧率的影响较小，用户无明显感知性能变差。

通过以上的尝试及灰度结果来看，做这个事情其实是很有意义的，那么最后也敲定下了这个优化方案。
结尾
整个需求的来龙去脉就是这样子的，其实梳理这个过程的来龙去脉来，一来可以让自己不断反思该过程存在的一些问题，二来呢，因为本次确实对大家造成了不好的影响真的是深感歉意啊！，可以让大家清楚这个事情是怎么发生的，至少大家不会卡得不明不白的。写代码万万要小心谨慎，考虑周全啊。这次痛定思痛，吃一堑，长一智吧。愿天下的程序统统没有。对，统统没有！！！
最后贴上一张优化后的效果图：

文章写得不好的地方，望见谅，大神莫喷莫喷。小弟我要背锅去面壁了。汇总国外社区相关文章，覆盖 等内容：

         
链接：
点评： 的 博客文章，文章向你介绍在上开发 应用部署到上
       
链接： 
点评：的博客上的从 转到 的系列文章的第二篇，这篇主要介绍类型系统
             
链接：
点评：文章介绍如何在程序中引用一个 的类库，也是一篇应用引用 的指引文章
             
链接：
点评： 的跨平台 已经有了多款，  ，   还有，文章简要介绍这三款，总有一款适合你的
            
链接：
点评：微软并没有停止 的开发，版本在性能方面有很大改进，现在版本已经开始通过微软的网络推送

        
链接：
点评： 介绍通过将 应用部署到
   
链接：
点评：介绍在 应用程序中支持。
    ’    
链接： 
点评：在 应用程序中如何保证敏感配置信息的安全保存。
         
链接：
点评：通过 和 介绍 的会话管理
        
链接：
点评：介绍 的日志系统，如何自定义扩展日志系统
    –  
链接：
点评： 有，， 统一为来处理请求，文章详细的介绍。
        
链接：
点评：通过把 的 管理起来，对于测试，开发比较容易。
     
链接：
点评：详细介绍   讨论了  和  月 日，腾讯云云服务器正式全量上线！本次全量上线，针对腾讯云所有开发者全量放开。
目前提供的 云服务器为高性能计算类云服务器。采用高性能    显卡，目前采用单机单卡、单机双卡两种机型配置。质优价廉，加速性能稳定优异！
具体购买方法可参考  购买指引
【售卖地域】

在广州三区、北京二区、上海一区系列提供云服务器售卖。 
将于月初于上海二区、深圳金融一区进行云服务器售卖，后续地域升级，敬请期待。

【计费模式】

腾讯云  云服务器目前仅提供包年包月的计费模式，暂不支持按量计费的计费模式。 
将于近期支持按量计费的购买模式。按秒计费，按小时结算，敬请期待功能升级。

【文档介绍】

 云服务器产品文档，查看请点击这里
 云服务器价格，查看请点击这里
 云服务器实例概述，查看请点击这里

【后续更新】
后续，腾讯云还将推出更多计算类  和图形渲染类 ，敬请期待。作者 | 王拥军

王拥军，毕业于天津大学计算机系，拥有从计算机硬件到操作系统安全、从后台服务器到客户端的全平台工作经历。目前在腾讯自选股从事互联网证券软件研发管理。对上市公司及创业团队的产品、文化、经营等具有独到的见解。
个人公众号“水滴的声音”，专注企业文化、团队管理。

前言
当领导当然是好事情，升官发财嘛！
然而许多人当了领导没多久，要么自己逃了，要么被大领导赶走了。
业绩不好，被大领导赶走，这还可以想象，为何有些人自己要逃呢？
一个非常重要的原因，是被自己亲手点燃的“三把火”给烧跑了。
电视剧里的新官上任，一般都是以下这样的情节。

《欢乐颂》新官上任，把自己的下属，那些公司的老员工，挨个痛批一顿，告诉他们以后要按照自己的规矩做事，不可懈怠。
作为一种单纯的艺术表现手法，用别人的无知衬托主人公的优秀，这是可以理解的。
然而，现实中，这样的做法，衬托的不是主人公的优秀，而恰恰表明了他的无知！
强龙不压地头蛇，一切等到成为“地头龙”再说
所谓强龙不压地头蛇，无论官位有多大，新到一个团队，新人的“势力”都是最最弱小的，需要观察和学习的，不是那些下属，而是新来的老板。
一个团队内部，尤其是大的团队，除了名义上的领导，还有各种各样具有不同威望和“权势”的“民间领导”。比如：资历最老的那个，技术最强的那个，出手最阔绰的那个，跟上边大老板走的最近的那个，
些民间权威，对团队有非常重要的作用，是团队稳定和进步的一部分动力源泉，也是老板们赖以推进团队业务进展的核心力量。
得罪这些人，轻则对方消极怠工，延误工作进度，重则到处抱怨，宣扬新任老板的各种不是，进而影响团队氛围，更有甚者，跨级打报告。
不要忘记，跟空降的新任老板相比，对于团队来说，这些人是“老人”，是“熟人”，所以他们的话有很多人愿意相信，甚至连耳根子软的大老板也会相信。
一个是新来的陌生的老板，一个是共同相处了三年五年甚至十年的朋友，谁的话更容易令人信服？当然是熟人的话！
即便是耳根子硬的跨级大老板，对于他新雇佣的下属，如果刚刚入职就引起一大群老员工的强烈反弹，那么，很容易形成一个结论：这个人缺乏沟通经验，缺乏管理经验，连自己的下属都搞不定，有什么资格当一个团队领导？
当然了，新任老板可以跟自己的大老板解释：“老的团队铁桶一块，无论我做什么都有人反对。”
回复往往是这样的：“你这么着急干嘛？你就不能先想想办法打进铁桶里边再说么？难不成，你的意思是：让我把所有人全都裁掉，你再招聘一拨新人从头开始？”
所以，空降的新任老板，首先要做的事情，是“尊重”顺从当前团队的各种民间地方势力，最迅速的得到尽可能多的团队成员的“接受”，无论这种接受来自于正面的认可，还是负面的妥协，总之，这种最广泛的接受，是获得团队权威的第一步。
想想这样的景象：团队空降了一个新任老板，半年之后，骨干员工天天向大老板抱怨新老板的各种不是，甚至，若干骨干员工离职，结果会如何？
知己知彼，方能对症下药
新官上任三把火，如果是一些简单的为了树立自己威信的三把火，也是自然的事情。
 然而，团队需要空降一个领导，说明这个团队是存在某些问题的，否则原来的老领导不至于走人。如果是被动走那还好，说明老领导能力有限。如果是主动走，那说明这个团队存在老领导无能为力的事情其中包括了这项业务存在发展瓶颈的可能。如果是后者，新领导就更加要慎重了，连老领导都无能为力，自己该如何应对？
所以，新官上任，首先要做的，是调查！
、搞清楚团队目前的主要业务及其状况。
团队的主要业务是什么？目前是初创期还是高速发展期还是平稳期还是下滑期？
团队的主要竞争对手有哪些？团队在业界处于何种地步？主要竞争对手又处于何种地步？
行业的发展状况如何？竞争对手的布局如何？
但凡跟团队业务有关系的，都要尽可能的调查清楚，从而摸清团队目前的发展障碍和核心问题。唯有如此，才能有针对性而不是想当然的“烧三把火”。
、搞清楚团队目前的组织架构及其状况。
上边一个是摸清“事”的问题，这一个是摸清“人”的问题。
事总是要人去做的，什么人做什么事，团队总是有分工的。
更何况，许多团队，问题的本身就不在“事”上，而在“人”上。
、首先一点当然是团队内部。
存在哪些正式或非正式的团体，哪些人的权威比较高，哪些人是单纯的追随者，哪些人是团队的骨干，哪些人对团队毫无价值，哪些人对业务最有建设性，哪些人最保守，
团队最近的人员变动如何？整体的氛围是积极向上的，还是消极被动的？
甚至，是否存在勾心斗角甚至拉帮结派彼此冲突的问题？
、其次一点是直属的上级及关联团队，彼此的关系以及合作流程、合作态度、等等。
上级对当前团队以及自己的预期是怎样的？
同属一个上级的其他团队以及领导，对自己以及团队有何看法或期望？彼此之间的态度和历史瓜葛到底如何？
、然后一点是跨部门甚至跨公司的各种合作团队，彼此的供求关系、合作模式、等等。
哪些部门是大爷，不能得罪？
哪些部门求着自己，但对自己团队毫无价值？
哪些部门可以互惠互利？
越是级别高的领导，涉及到“人”的问题越是比涉及到“事”的问题多。
低级别的领导自己需要做事，高级别的领导，则可以安排最合适的人去做对应的事情。
、某些财务独立的团队，需要搞清楚“钱”的状况。
“人”管的再好，“事”做得再漂亮，如果“钱”没了，公司也就没了。
群策群力，好过单打独斗
无论是前边的“调查”还是后边的“决策”，如果只是自己独断专行，先不说执行的效果好与坏，至少，是对团队成员的不尊重。
身在一个团队，级别越低的员工，其实越是无奈。因为团队的命运影响着个人的前途，而自己对团队的命运却无可奈何，只能寄希望于自己的老板足够英明。
所以，但凡愿意时常倾听员工意见的领导，员工满意度都会比较高，员工的工作积极性也比较高。
马斯诺需求层次理论，除了吃饱穿暖有份工作，更高的需求就是“被重视”。
许多最底层的员工离职，是因为“被压制”，而稍微有些话语权的员工离职，大都是因为“被忽视”。
比“被重视”更高级的，是“被认可”。
很多老板也愿意倾听员工的意见，然而，仅仅是“倾听”而已，听完之后，就没了下文，连一句“说的很好”这样的简单反馈都没有。
所以，不要以为自己身为老板就可以对员工爱答不理，他们至少可以用脚投票，临走之时也是客客气气，让老板永远也猜不透他们到底是为何走的！
倾听和认可下属，不仅仅是最最廉价的激励方式，而且是摸清团队真实问题，甚至是制定精准解决方案的必要手段。
尤其对于空降的新任领导，下属员工要比领导更加清楚团队的各方面问题，包括业务的状态、团队成员的状态。
无论是学习、熟悉业务，还是熟悉团队成员，甚至制定业务策略，激励或挽留员工，这些，新任领导都需要下属团队成员的协助。
作为领导，个人不是万能的，获得大家的协助成为三头六臂，才能解决各种疑难杂症。
兼听则明，偏信则寡
倾听并接受下属意见，很容易犯的错误是：偏听偏信。
人们喜欢跟与自己意见相同的人聊天、共事，这是本性。而想把事情做成，就要克服这种人所共有的本性。
观察事物的角度是多方面的，一件事情的影响也是多方面的。
通常在调查一个事物本相的时候，人们根据自己个人的调查迅速做出判断，而忽视了其他更多的人尤其是不同的人从不同的方向看到的景象。
在做一个决策的时候，人们根据自己的意愿乐观的假设事情朝着有利于自己的方向发展，而忽视了其他人尤其是利益冲突者从相反的方向所做出的应对措施。
所以，一个领导，不能够只跟最乐观的人守在一起，也要倾听悲观者他们何以悲观的理由；更不能只跟依顺自己的人谋定策略，而忽视了那些反对者之所以反对的原因。
当团队内某些人成为大家共识的“领导的亲信”，那么，其他人就会对领导敬而远之。更有甚者，某些亲信会恃宠若娇，做出不利于团队甚至不利于领导自身的事情。
从古至今，不知道多少大大小小的团队，因为“偏听偏信”而招致灭顶之灾。
兼听，难就难在，这是在跟自己的“人性”做斗争。
兼容并蓄，百花齐放
解决问题没有错，不要企图“解决人”，尤其是“解决所有人的所有问题”。
业务竞争落后于竞争对手，影响的因素有很多，或因为对手太强，或因为自身进入行业太晚，终是有赢必有输。
更多的团队，更多的老板，不是因为业务上不够高明，而是团队成员的管理上无法服众，导致众叛亲离，功败垂成。
团队需要有纪律，如此业务才能快速发展。
然而团队之所以需要有纪律，恰恰是因为团队成员有各种缺点，惰性也好，消极也好，终归人无完人，否则何必要纪律和制度来约束？
团队领导要做的，是建立对应的制度和纪律来制约某些人性的弱点，从而保证业务得到稳步发展。
团队领导要做的，绝非将自己的下属成员全都培养成完美无缺的圣人，更不是通过大换血来从新招聘符合自己性格脾气的人，后者的代价将会极其高昂甚至惨痛，甚至绝对做不到！
从来没有听说过有谁能够通过几次面试就能摸清楚候选人的所有状况，也从来没有听说过哪个团队的成员全都是一模一样的。
更何况，一个团队如果所有成员全都一模一样，这样的团队一定会犯错。一个人想不到的，所有人都想不到！
最奇葩的是：一大堆老同事离职，大老板询问大家对新任老板的看法，竟然没有一个人帮新老板说好话即便同时也不说坏话，结果会如何？
被空降到一个团队当领导
首先，尽可能倾听最广泛群体的意见建议，摸清业务和团队状况，找出需要解决的问题，找出能够解决问题的人；
其次，跟最懂业务的一群人，一起做出最可行的决策，并且动员尽可能多的人；
然后，依靠最靠谱的一群人，带领尽可能多的人，逐个依序解决团队面临的各种问题。
最忌讳的是：
、不懂业务却独断专行；
、全权委托却所托非人；
、未获认可却强势推进。
以上内容来自本人个人公众号【水滴的声音】关注企业文化、团队管理。作者：莫卓颖

序言
相信很多程序员都会经历两件事：第一件事情是没日没夜加班撸代码；第二件事情是写的程序出现没有及时发现而被老板骂。
不知道大家有木有考虑从工具或者架构的角度出发去解决以上两个问题，木有考虑的同学也木有关系，本系列文章将会将会围绕整个前端的开发流程出发解决这两个问题，帮助大家提高产品质量以及开发效率。
文章导航图
对于前端开发来说大致分为个阶段：开发、联调、测试、上线、监控维护，本系列文章将会选取每个阶段比较影响效率以及质量的点进行详细描述。这一章我们先来从开发阶段出发考虑有哪些方面可以做效率提升？

页面结构继承化
信很多同学都会利用或不完美的继承成化方案实现功能或样式的重用，不知道大家是否有考虑过页面结构或者数据也可利用类似的继承方式以便达到结构以及数据重用，我们先来看一个例子以便更好了解继承的作用，如下图：

假设同学和同学分别开发页面和，这两个页面的特点是页头、页脚和公共资源都是一样的，唯一不同的就是内容部分即是。同学发现这个特点后，聪明的只开发内容部分，其它相同等同学开发后把相同的代码拷贝过来便可。相同部分如下图红框，不同部分如下图黄框：

但是同学相当靠谱，他的程序经常出，导致每一次修改页头和页脚都需要通知同学，然后同学需要把需要修改部分黏贴覆盖到代码中。这种方式很明显会带来两个问题：、修改困难，同一个修改需要同步多次 、维护困难，需要维护大量相同的代码。于是同学想到了另外一种方式，把公共部分分别抽取为单独的一个文件，然后用的方式引入，方式如下图所示：

把两个页面相同的公共的功能的页头，公共的页脚，公共的脚本统一抽取成一个文件，相信很多同学都是使用类似的架构来设计但是不知道有木有同学考虑过这种方式的缺点：无法进行颗粒度化的结构扩展以及修改。举个例子，比如嵌入的，如果说每个页面某个模块大部分内容一样，但是有一小部分都不一样，我们是否需要在这个模块中使用大量的 使用这种方式很快会使得代码无法维护。因此更加理想的架构方式是让也具有继承结构，把通用结构、数据放到中，所有的页面均继承此类父类，继承结构如下图所示：

我们先来看看定义的通用父类的含义

如上图，我们在通用父类中定义通用的属性如蓝色框所示相信在一个产品线中，所有页面一致的部分包括通用的公共样式等、通用的脚本库等、和某些对于不变的无需定义属性等有需要的时候再定义便可。页面有可能不变的包括、、、等，可提前定义属性见上图的蓝色框，定义好类后，我们的页面便可简化为如下图所示：

对于这些我们相信到这很多同学会产生疑问，不像动态语言，具有以及继承功能，怎么样才能达到上述功能，实现原理很简单，借助构建工具在编译的过程中遍历所有文档，找出所有的基类，然后读取所有的子类，把子类的属性覆盖到父类便可，伪代码如下图：

总结
页面结构继承早已经在动态语言模板等实现，因为它可以更加有效的管理模板以及提高开发效率，但是在不支持类似的方式导致很少同学使用类似的结构实现导致木有维护的困难，通过本文学习，可简单的实现继承已达到重用的目的。下篇文件将会阐述如果实现模块化以便提升开发效率。

原文链接：


相关推荐

打造前端工程测试体系
前端开发框架简介和导语
 是分布式基于  的多线程非阻塞的高性能且支持同步、异步、单向调用  框架。框架将网络线程和业务线程隔离，并通过队列和管道实现网络线程和业务线程间通信。框架维护网络连接，实现客户端和服务端远程调用和本地调用基本一样，用户只需关注业务逻辑。框架支持多种语言开发，集高可用，高性能，高并发，高效率等优秀特性。
  简介
  框架整体划分为五层结构，运营、平台、通信框架、公共库、协议层。框架将网络线程和业务线程隔离，通过消息管道和队列实现业务线程应用层和网络线程传输层间通信，业务侧只需关注业务逻辑开发。框架协议层使用适宜传输且与语言无关的、协议；提供了完善的公共库；传输层提供完善网络通信机制，包括单向同步异步，过载保护；平台层提供统一管理，负载均衡，容错等机制；运营层前端集发布，监控，自动配置等。      
框架比较
目前主要基于和基于框架的后台开发，因此对两个框架有浅显的了解和学习。两个框架都是通信，框架是基于的多线程非阻塞框架，而是基于多进程，主要应用于电商形式的后台框架。
 服务端
 服务端启动过程
服务需要继承基类 调用框架函数，解析服务端配置文件加载到服务端，然后初始客户端通讯器，初始化服务端并创建_对象，并绑定到，然后绑定和，启动业务线程。调用框架创建网络线程并监听端口，然后启动网络线程，完成服务启动。

启动过程概述：
、业务系统服务_调用框架完成以下过程：
调用，解析服务模板内容配置，包括和的，超时，，心跳等。
调用，初始化客户端通信器_
调用，初始化基础配置
  初始化结构体
  _  =  _
 初始化日志服务代理，配置中心代理，信息中心代理，代理，管理对象。
 创建，给网络线程绑定，并设置连接数，超时，队列等。  
调用，线程绑定和端口
回调的方法，业务初始化
遍历，并创建线程组
调用_，启动业务处理线程组
调用 ，网络线程创建对象
、业务系统服务_ 调用完成以下过程：
调用_完成
 遍历线程组，并依次调用启动
 创建对象，并监听事件
  如果有请求调用接收请求信息，如果有关闭请求调用，遍历网络线程，调用结束网络线程。
服务线程结束，调用，析构业务申请资源。
 服务端分析
 基础类图
业务服务系统需继承框架类初始化服务端基础配置，并创建_类对象，在类中创建网络线程类和，并把线程和绑定。

 调用方式
是多线程基于的框架，主要实现网络线程和业务线程隔离，框架实现底层网络线程，框架维护网络连接队列，数据接收队列，数据发送队列，通过实现网络线程和业务线程间通信，业务侧只需要考虑业务线程处理业务逻辑，很大程度提升业务开发效率。如下图所示：
 
基于实现单向、同步、异步的远程通信方式。客户端和服务端调用方式如图所示。客户端首先通过方式上报主控并获取到当前活跃的服务端和端口，然后客户端可以发送连接请求与服务端通信。服务端每台机器需要安装，不断上报心跳等信息到主控，并通过实现主控控制服务节点。如下图所示：
 
 业务线程
、服务提供业务处理线程类，并由统一管理。相当于业务处理线程池。有请求则把请求回调到的方法并分发给业务线程处理，同步调用直接将处理结果写入到消息对列，网络线程取出消息对列数据返回调用方。
每个存在一个实例，负责统一管理的信息。当服务端接收到客户端的请求，网络线程把请求放到的消息队列。并唤醒锁，线程从消息对列取出消息。
 网络线程
  
 、遍历连接长时间无数据，主动关闭并删除链接。
  、等待消息，事件到来处理消息。
连接请求 
客户端连接，建立连接，框架选择网络线程处理连接列表，再把加入事件的处理列表，调用接收数据
停止请求
到外层，调用通知线程
控制通知：
 关闭通知，则调用关闭并删除此连接；
 发送通知，将网络线程缓存发送，避免关闭网络线程导致数据丢失。
数据请求：
 如果收到数据，调用
 如果缓存有处理结果待发送，发送处理结果给客户端。
 更新连接表超时时间。每天分钟，用去食堂吃饭的时间解决一个知识点。

 分钟的由来
之前在某社区看到有个同学分享了 ， 分钟快速了解  的使用，我挺受启发的。也想尝试使用这种形式，帮助大家在碎片时间内，理清楚一些容易忽略的知识点。
关系
工作后由于个人很喜欢 ，也接触一些  的圈子，发现挺多  会将关系型数据库中的关系一词，理解成表与表之间的关联。实际上这个词指的是关系代数。关系代数是关系型数据库的数学理论基础。我们的优化工作，本质上也是让关系运算的结果尽量地小。
从关系的角度看，我们进行数据库设计，就是将业务映射成关系的模式。而本文要复习的范式 ，是我们用来衡量关系的冗余程度的，目的是为了方便数据的存储和更新。本文只复习最基础的三个范式， 与第四范式，基本上实际工作中不会满足的，这里就不浪费大家时间了。
第一范式
不精确的话，只是为了直观，我们可以将关系理解成表，域理解成列。如果一个域的元素被认为是不可分的单元，那么我们将这个域称为原子的。如果一个关系模式中每个域都是原子的，我们就说这样的设计符合第一范式   。
在实际工作中，当我们拿出一个表设计的时候，可以看成已经符合  了。为什么说可以看成呢？举个例子，假设我们的关系中有个属性 ，是由    组成的。如果我们是物流行业，以后会按省份或城市进行分析，在这样的场景下  就是可分的，那这样的设计就不符合 。如果我们业务中地址只是用作一下展示，那么  作为一个整体就不必细分了。重点不在于域本身，而在于业务场景中要如何使用域。
函数依赖
对于元组  和 ，若 α=α，则 β=β，那么我们可以说这是一个函数依赖：αβ。直观的理解就是，β字段会由α字段决定。
第二范式
 在  的基础上，消除了非主属性对候选键的部分函数依赖。有点拗口。一样地，不求精确的话，出于直观，我们可以理解成，非主属性要依赖于主键。在实际工作中，我们拿出一个带主键的表设计时，同  类似，实际上我们已经可以看成符合  了。因为在定主键时，我们已经考虑了业务场景中，哪些字段依赖于主键比较合适了。不会将不相干的东西揉在一张表中，基本上也就不会出现部分函数依赖。
第三范式
 在  的基础上，消除了非主属性对候选键的传递函数依赖。我们可以理解成消除非主属性之间的依赖关系。那这一般出现在什么情况下呢？比如我们有一张视频表，主键为 _，表中记了投稿者的 ，即 _，为了显示方便又记了投稿者的姓名 _，这就产生了传递函数依赖：__，__。 就要求进行分解，即继续拆表。当然，拆不拆看你。
结语
范式只是一个工具。它的提出是为了帮助我们减少数据库的冗余性，在设计阶段为我们提供思考上的便利。前面的介绍中也可以看出，并不是一定要苛求精确地符合范式，我们最终的目的，还是要根据业务场景设计出合适的结构。运用之妙，存乎一心。希望本文对大家有所帮助。
相关阅读 分钟梳理关系数据库基础知识二：存储结构分钟梳理关系数据库基础知识三：树分钟梳理关系数据库基础知识四：两阶段多路归并排序分钟梳理关系数据库基础知识五：查询优化与连接算法本文作者： 

接 动画精髓上
线条动画
 中的线条动画常常用作过渡屏 中。例如：

或者，一些比较炫酷的  中，比如  的：

看到这些炫酷的效果，大家有没有动心想学一学，看看自己到底能否做的这么好呢？
，我们现在来正式介绍一下线条动画。在  中，最长用到的线条标签就是 。这里我前面一篇文章已经做了介绍，我这里就不赘述了。
而在具体变化当中用到的是关于的相关属性：下面的属性都可以直接用在  当中！

：定义笔触的颜色。例如：=
：定义  和  的长度。它主要是通过使用  来分隔 实线 和 间隔 的值。例如：= 表示，按照 实线为 ，间隔为  的排布重复下去。如下图：



放大看有：

另外， 并不局限于只能设置两个值，要知道，它本身的含义是设置最小重复单元，即，。比如，我定义 =   则相当于， 为一段。则有：

放大看则有：
 

 用来设置  定义其实  线条开始的位置。值可以为  || 。百分数是相对于  的 。通常结合  可以实现线条的运动。
 线条的端点样式。 
 线条连接的样式
 一个比较复杂的概念，如果我们只是画一些一般的线段，使用上面  即可。如果涉及对边角要求比较高的，则可以使用该属性进行定义。它的值，其实就是角长度比上线宽：


而实际理解的话，就是假设当  为 。此时比例为 。那么  = 。那么超过  的  部分则会被  掉。可以参照：

他主要是配合 一起使用。因为  默认取值就是 。所以，默认情况下就可以使用该标签属性。它默认值为 。其余的大家下去实践一下即可。详细可以参考 

：线段的透明度
：线的粗细。

，介绍完关于  的所有  属性之后，我们就要开始动手写一下让线条动起来的代码。简单来说，就是通过 和  来做。整个动画可以分为两个过程：

通过  将实线部分隐藏，空余为全线段长。然后，将实线部分增加至全长。比如： 变为  。
同时，通过  来移动新增的实线部分，造成线段移动的效果。有，变为 。

不过，这里我们不打算使用  来做啥复杂的动画，这主要考虑到手头没有一些  生成工具。所以，这里我们就以  来做吧因为做起来真的简单。
这里，先以  这段文字来做动画。
先给大家看一下最终结果：

那么这种动画是怎么做的呢？
这里，我主要介绍一下关于  相关， 就一个  我直接贴代码了：
  =   

    
   =
     =
          = = =
      
    
    

     
   = =
       
   = =
       
   = =
       



 上面是通过创建一个居中定位的字体，然后使用  个  重叠。具体  我们下面来说一下。首先，我们营造的效果是从无到有，就需要使用 将  设置的足够大。这里我取  即可。  
 然后，通过 选择器，给每一个文字使用不同的颜色值：
   {
   
}
   {
   
}

   {
   
}
 下面才是重点内容。此时，这  个  的起始点重合。我现在既要他们在运行时不完全重合，又要他们的线条能进行滚动。不啰嗦了，直接看代码吧：
  {
   {
     
      
  }
}

  {
   {
     
      
  }
}


  {
   {
     
      
  }
}
 这就是上面  个不同的  运用的动画。 由  到 。这完成了滚动的目的。同时，为了让字体不重合，我还需要在对应字体的  上，加上不同的间隔距离。比如，第一个字体  为 。那么第二个字体，我需要加上前一个字体  的长度，即，。所以，第二个字体就变为 。那么第三个就是加上前两个的 长度，即 。
大致过程就是这样，详情可以查看：  线条动画。

这里再给大家布置一个练习作业，如何实现无线连续的分段动画呢？

具体效果如图：

给点提示：

将多个文字重叠，取不同的  和  即可。动画的终止位置一般取一个    的周期长即可。

后面看看这篇文章反响如何，到时候再决定是否再写一篇续集，介绍该作业的原理。
 文字
在  中定义文字直接使用 标签即可。关于文字来说，一般而言需要注意的点就那么即可，文字的排列，间距等等。这些都可以直接使用  进行控制。不过，有几个属性比较特殊，这里需要额外提一下。

用来定义参考点和实际字符之间的定位关系。格式为：

  |  |  | 

直接看代码解释吧：
     
     =
          = =

     =
          = =

     =
          = =
 第一个 ，参考的是  的点，定义为，那么参考点应该在字符的前面。

而剩下两个也是同样的道理：


现在，假如我们想在  里面添加一些特殊的字符效果，比如斜体，加粗等。由于， 标签不能实现嵌套，所以，为了解决这个痛点，提出了  的标签。它其实就是一个可以嵌套的  标签。
 = = =
   
   = 
    = 

  里面同样可以自定义相关的自身属性。详细的可以参考  我这里就不详述了。
在  展示 
 一般可以横放，竖放。那有没有啥办法让文字可以按照一定的路径任意排放呢？
有的，这里可以使用标签，来定义具体参考路径。
 =
    =      
    =   


     =
       
    

 如图：

具体细节我这里就不多说了。

在  中如果想展示一个图片的部分，或者以某种形状展示图片的部分，一般是通过一个   来实现的。不过，如果涉及到不规则图形的话，那么  就有天生缺陷了当然使用  里的 可以完成，不过兼容性不太好。而在  中，提供了 标签，能够让我们自定义裁剪图片的范围和形状。
 里面可以接任何图形，比如， 甚至是 。使用的时候，直接在  中，指定  即可，或者直接使用 属性指定。

   =
     = = = =
      =  
             

    
  
 

  = 
  = = 

    = 
  = =

或者说，如果我们想画一个圆的裁剪区域的话：

      = =
      = = =
    


 = =  
 参考标签

分组标签应该毫无意外排第一，因为其实作为绘制图形中最常和最基本的标签。前面一篇文章也主要介绍过了，这里做点补充。
每一个分组标签都带有  属性，唯一标识该分组，为什么呢？
因为，后面我们可以使用该  标签添加动画，重用该分组等。
  = = = =
      = = =
      = = =
      = = =
      = = =
   
 每个分组里面可以含有一些描述标签，比如 。 这些描述内容是不会被渲染的。
 = = = =
     
      = = =
   

该标签就是结合  标签一起使用，作用是可以复用  分组的样式。
 =
       =  =

 = = = =
 里面使用 加上指定  的 ，然后通过，属性指定副本放置的位置。不过，有一个限制， 标签的  属性，并不能覆盖点原始的   样式。而且，有时候，我们只是想使用一些模板，即，图形并未被解析，只有代码存在。这时候，就需要使用 来包裹了。

用来保存一些代码，使其不会被浏览器解析。并且里面的分组可以被  属性的  样式所覆盖。

     =
       =  =
    
  

  = = = = 

该标签和 标签类似，也是用来进行分组。不过，它有个特点，即，不会被浏览器所渲染。那它不和  差不多吗？
恩，确实。不过， 是官方推荐，用来包裹一些模板  代码而创造出来，用来增加可读性的标签。而  是存粹的作为一个模板。它可以独立于  的  来自定义子  和 。
  = =   
   = = = =
      = =
   = = = =
      = =


 =
     = = = =
 同样使用该模板，也是使用  标签来完成。

既然 可以重用  代码，那么  里面能不能重用已经画好的  的图片呢？
这时候，就需要用到 标签。其可以用来加载外部的   图片，注意，官方规定是前两种，其它图片支持不支持官方没做答复。即，如果你使用  图片，并不能保证所有的浏览器都能正常显示。
 =
  = =
  = =

 同样，该  标签也具有自定义  的效果。

 定义水平位置
 定义垂直位置
 图片渲染的宽度，必须有。
 图片渲染的高度，必须有。
 控制图片的缩放


 一般是用来画箭头或者线段始末的标识图形。
 
     = =    = =
        = = =
       =          
    
  

   =   = = 
      = = 
 如图

这里我们只需要里了解即可，因为在实际画的时候，直接使用相关工具生成更加方便。

这里的  标签和我们直接在  使用的超链接  标签类似。也是用来定义一个外链的。
  =
      =_
     = = = = =
     = = 
          = =  
  
 更多内容，可以关注我的公众号：前端小吉米。

分享吉米的前端路，后面也会定期推出当前热门的前端技术 比如，直播，
原文链接：文章中会涉及到值、向量、矩阵，表示方式以  为例 值为小写字母 ，向量为加粗小写字母，矩阵为大写加粗字母，运算非常简单，只需要具备基础线性代数知识即可。
部分例子和图片来自于   的   神经网络和深度学习，结合自己在学习过程中的心得和其他资料，分享出来
 请看字母识别  

一、放松心情 一点都不难～
先来讲一个故事：
我是一个爱吃披萨的人，选择是否去一家新开的披萨店吃披萨
三个因素影响我是否去这家披萨
 天气好
 有人陪伴
 交通方便
交给一个抉择模型来处理

这个模型非常简单：
把三个因素作为输入值，形成一个三维输入向量   
为每个输入值设定一个权重，三维权重向量    
所以输出有  =         ， 再设定一个阈值  与  做对比，给出结论：

如果    就去

如果  =  果断家里睡觉


用公式表达：
去： ×    ×    ×      
睡觉： ×    ×    ×    = 
设  = ， ×    ×    ×    是否大于  就是我想要的结果
影响结果的变量有三个，向量 ，向量 ，值 
是已知的，三个因素，，每个值满足就是  不满足就是 。
，，和  怎么设定呢？
至少要先武断的设定一套值，这个模型才能运作：
我先给  设定一个值  = ，那么只要        我就能愉快的出门了 一个一个来看吧：
 我是个很看重天气的人，天气不好我不出门，所以我给它的权重最大： 
 其实有没有人去还好啦，人总要习惯寂寞，它的权重：
 因为没有车，只能公共交通，太麻烦就不去了，它的权重：
好了，可以有结论了，只要天气差，果断睡觉，天气好再满足任意一个条件我就去。
不错，这个模型可以，不过费了这么大劲，就只为了决定是否去吃披萨？回头瞅一眼三个因素：
 天气好
 有人陪伴
 交通方便
这个貌似很通用哎，日常生活很多出行：吃饭，看电影，逛街 似乎都可以用这个模型来决定，因为它们的输入因素是相同的，或许不只有  个，可以是  个，那么通过为模型设定合适的   ，总能为大多数【选择请求】 给出令人满意的结果。
如何寻找   
假如我是个很闲的人，每次有这种类型的 【选择请求】，我的都会交给这个模型去判断，如果输出结果让我不满意，我就去手动调整    值，因为它结构很简单，经过无数个日日夜夜，无数次更新迭代，总有一款    适合我多数的【选择请求】，彻底治愈选择恐惧症。
二、神经网络初识
但是现实往往没有这么简单，显然一个三维的输入向量和一个一维的输出向量是无法满足要求。

现在可以介绍 神经元 的概念，上图中的圆圈就是一个神经元，它的作用是为输入向量的每个分量分配权重值  和偏置值  通过  ×    ×    ×    计算出输出 这已经构成了一个非常简单的 神经网络 模型 感知机。
先不考虑很复杂的 神经网络 的设计思路，先把神经元增加到两个，让输出结果成为一个二维的向量，，然后梳理结果计算流程

输入向量，，    
神经元 它分配给  的权重向量，，和偏置值 
神经元 它分配值  的权重向量，，和偏置值 
那么输出结果是什么呢
神经元  的输出结果： =  ×     =  ×    ×    ×   
神经元  的输出结果： =  ×     =  ×    ×    ×   
那么二维的输出向量 ，=  ×    ×    ×     ×    ×    ×  
从
，，    
，，、
，，、
到
  ×    ×    ×   ， ×    ×    ×   
这个过程应该整合得更规范才行，复杂的神经网络的计算过程才会变得清晰。
先优化结果的表示：
  ×    ×    ×   ， ×    ×    ×   
=  ×    ×   × ， ×    ×    ×  ，
注意，， 此时形成了一个偏置向量
这里熟悉矩阵的童鞋会发现，可以用矩阵运算表示更加简洁：
      ×     这一步看不懂多看几遍
值得关注的是：这个式子并不等于上面的二维向量，因为它是一个 × 的矩阵，即便转置之后也是一个  ×  的矩阵并不是向量，尤其是在程序代码中，不过意义是一样的，为了计算方便我们干脆将输出结果改用矩阵来衡量，同时，输入值、权重、偏置值都用矩阵来表示
= ， ×      
用  表示矩阵 ，，用  表示矩阵    ，用  表示矩阵  ，那么
=  ×     这是一个  ×  的矩阵
好，三个输入值，两个神经元的神经网络
输入值为  ×  矩阵 
权重为  ×  矩阵 
偏置为  ×  矩阵 
所以 ×× ×结果是×矩阵 再与矩阵 ×相加 符合矩阵运算规则，合情合理，没毛病 
明白这段计算合理性，对于理解整个神经网络过程是很关键的，否则在梳理计算逻辑时会一头雾水，到后面反向传播直接蒙逼， 一定要搞懂～
结论： =       
 是输出结果矩阵， 是输入因素矩阵， 是权重矩阵， 是偏置矩阵
注意：这是一个只有一层神经元组包含了两个神经元的神经网络推导出的结果公式
现在我再加一层神经元组会怎样，如下图

这个图的表达不准确，第一层只是输入层，不应该画成圆形，相当于上面 、、，并不算作神经元组，也不会有和，图是用的别人的，请见谅！
那么，这个网络中，实际起作用的神经元组有两层，分别包含了  个神经元和  个神经元
上面公式推导是针对一层神经元组的，我要想应用在现在这个网络中，我要先把这个网络分割成两个，第一层 第二层算一个网络 ，第二层 第三层是一个网络 ， 输出值算作  的输入值， 的输出值为整个网络的结果
那么对于
 =    
对于
 =  =    这里先不展开
得到一个递推公式： =          其实就是输入层 
这下牛逼了，不管多么庞大的神经网络，计算过程都是通过递推公式从前算到后。
好，现在来说一个从开始就被忽略掉的关键问题，我所有的推导过程都是基于  =     而来，但它是线性方程，线性方程会有什么问题，简单说：神经网络的训练本质是对数据的一个分类过程，线性方程无论通过多复杂的叠加，带来的始终是线性分类，直观的说，就是用直线给数据平面做划分，划分的能力不够，很多类型的数据，只有非线性曲线 才能将其分开，所以要引入非线性激活函数。
寻求一个有限值域的非线性函数作为激活函数，可以将     的值收敛到一定范围，激活函数  函数登场，它的值域是，，体态光滑，容易求导，后面要用
它的导数：    

 =   =     注意，这里是对值的计算，所以前面每一步求值 ，都要套上  函数。为了方便，我就直接用大写的  套在递推公式的矩阵外面：
 =    ， =  这是正确的递推公式
好，讲了这么多，说的好像真的能通过  求出  似的，的确，如果你知道每一层的  和  的话。
然而我们是不知道的，神经网络模训练过程就是调节  和 ，目的是将  和  调至最优，来确保输出的  无限接近真实的结果 ，然而初始的  和  从哪里来，先简单搞，用正态分布的数值来填充 和 ，随便填？ 是的，随便填，反正你要给个初始值，这跟文章开头武断的赋值给  和  没有任何区别，这当然不是最优办法，但现阶段是  的。
三、反向传播：调节  和 
给了  和  赋值后，网络就可以运作了，通过  算出 ， 基本上是不可能等于  的，最后一层每个维度的误差值组成  来代表神经网络的最后一层的误差矩阵，它源于  和  的不恰当导致，每一层的  和  的误差  和  最终导致了整个网络的误差 ，我们现在要做的就是通过  从最后一层往前面推，来确定每一层的  和 ，这就是反向传播的含义。
 关于  和  的函数叫做神经网络的  ，俗称 损失函数，这里先介绍其中简单的一种：
 =     
下面通过它来推导每一层的  和 
推导过程用值来算，更贴近实际程序运算的过程
如何通过 、、、、、  推导出 、  
 是 最后一层 第一维 误差
 是 最后一层 第一维 正确值
 是 最后一层 第一维 输出值
 是 倒数第二层 第一维 输出值
 =     
应用链式求导法则，结合这下面三个式子展开
 = 
 =    
 =   
 就是  对  求偏导：下面的  代表对  求导
 =    
=    
=    
=    
=       ``  
=        
 就是  对  求偏导：下面的  代表对  求导
 =    
=    
=    
=    
=         
=       
从后算到前，填充每一层的  矩阵和  矩阵
然后，更新每一层的  和 
 =   _  
 =   _  
_ 一般是一个介于 ～ 之间的学习速率值，来控制步进，不宜过大，否则梯度不降反升，误差越来越大
四、实战
  的  识别手写字体的  已经很好了，也是这个  的  代码帮助我弄清了反向传播的细节计算，建议大家去看下。  
我做了一个识别简单字母，就是本文开头的 ，搭在腾讯云上的，还在完善中，不稳定，欢迎围观～
 的识别过程是在浏览器端完成，训练通过  调用  脚本实现
页面会每十秒跟后台请求一次最新的网络模型参数，也就是   ，生成模型来识别验证码～
五、后续
在神经网络中，激活函数和损失函数是决定 网络模型是否有效和学习速率的关键部分，这次没有展开说，我觉得对于刚接触的同学先不要纠结于此，自己把程序先跑起来，识别几种简单的字母或文字，后面我会整理出常用的激活函数和损失函数的相互比较和应用，再来分享。作者简介：
吴锦华，年毕业于西安电子科技大学，目前就职于诺基亚上海贝尔，从事嵌入式平台开发工作年，负责对第三方和移植和适配到公司的软件平台架构。
明鑫，年毕业于武汉大学，目前就职于诺基亚上海贝尔，从事嵌入式平台开发工作年，先后参与了、等下的底层及驱动开发，主导接入网络设备到的移植。

用户态文件系统介绍
用户态文件系统  ， 简称，它能使用户在无需编辑和编译内核代码的情况下，创建用户自定义的文件系统。文件系统是操作系统的重要组成部分，一般在内核层面实现对于文件系统的支持，而通常内核态的代码难以调试，生产率较低。在用户态空间实现文件系统能够极大幅度的提高生产效率，简化为实现新的文件系统的工作量。主要包含两个部分，内核模块从版本开始支持和用户态库。
目前支持的平台：

 完全支持
 部分支持
参考

比较知名的用户态文件系统：

：商业文件系统，实现了协议；
：用于集群的分布式文件系统，可以扩展到级；
：通过协议访问远程文件系统；
：通过文件系统方式访问；
：加密的虚拟文件系统
和 ，在非中对文件系统提供支持；
：支持通过文件系统接口访问上的文章；
升阳公司的：和类似但更早的一个集群文件系统
：的版；
：
 提供的分布式文件系统。可以通过一系列命令访问，并不一定经过 ；

在嵌入式开发平台上，我们利用实现，  和 的文件系统。
官网：
实现机制分析
在这个章节，我们首先对于虚拟文件系统做一个简单介绍，下的文件系统都依赖于虚拟文件系统，要了解，首先要对虚拟文件系统有一个了解。然后我们对于做一个宏观框架的分析，先大致了解一下整个是如何工作的，最后两个小节分别从用户态和内核态具体分析的实现。
虚拟文件系统介绍
支持，，，，，， ，，，，，， 以及  等多种文件系统。为了实现这一目的， 对所有的文件系统采用统一的文件界面，用户通过文件的操作界面来实现对不同文件系统的操作。对于用户来说，我们不要去关心不同文件系统的具体操作过程，而只是对一个虚拟的文件操作界面来进行操作，这个操作界面就是  的虚拟文件系统  。形象地说， 的内核好像一个  机的主板， 就是上面的一个插槽，具体的文件系统就是外设卡。
因此，每一个文件系统之间互不干扰，而只是调用相应的程序来实现其功能。在  的内核文件中， 和具体的文件系统程序都放在 \ 中，其中每一种文件系统对应一个子目录，另外还有一些共用的  程序。在具体的实现上，每个文件系统都有自己的文件操作数据结构。所以， 作为 内核中的一个软件层，用于给用户空间的程序提供文件系统接口，同时也提供了内核中的一个抽象功能，允许不同的文件系统很好地共存。 使  同时安装、支持许多不同类型的文件系统成为可能。 拥有关于各种特殊文件系统的公共界面，如超级块、、文件操作函数入口等。实际文件系统的细节，统一由  的公共界面来索引，它们对系统核心和用户进程来说是透明的。

图 示意图
内核模块的实现跟传统的文件系统实现既有相似点，也有差别的地方，内核模块实现了文件系统，只不过与传统的文件系统不同，需要把层的请求传到用户态的，在用户态处理，然后再返回到内核态，把结果返回给层。更多细节，且看下文。
宏观框架
当用户自定义一个新的用户态文件系统被挂载之后，我们在访问该文件系统的文件的方式与访问其他文件系统的文件是一样的，保证了这一点。不同的是，文件系统下面的访问行为是可以用户自定义的。我们从一个简单的例子出发，先宏观上理解一下整个工作的流程。以为例，整个调用的过程如下：

用户态调用 接口，触发_系统调用。
_ 调用中节点定义的方法。
中生成一个消息，并通过发送消息到用户态。
调用_用户自定义的的方法，并将返回值通过通知给内核。
内核收到消息的处理完成的唤醒，并将结果放回给系统调用结果。
用户态收到的返回结果。


图 实现框架图
实现分析
对于的分析，我们从一个简单的例子开始。
  _ _ = {
        = _
        = _
           = _
           = _
}

    
{
     _  _ 
}
这个例子实现了一个最简单的用户态文件系统。
  
  
  
 
                            
  
 
  
    
    
     
  
       
上面是测试的结果，可以看到：

可以读取目录
可以读取文件属性
可以读文件，不可以写文件
不可以创建目录
不可以创建文件

我们再结合中定义的方法，不难看出它们之间的关联。要使用实现自己的文件系统，我们需要定义一个_类型的结构体变量，并将它传递给_，剩下的交给去处理，实现一个文件系统简单了很多。
接下来我们看一下_的定义：
 _ {
           
           _
         __ __
         _ _
         _
        
        
           
           
           
         _
         _ _
         _
           
          __ 
           _ _
              __ 
            _ _
              __ 
           
          __ 
          __ 
           __ 
               _ 
              _
           _
           
          __ 
           ___ _
             __ 
          __ 
           __ 
       __ 
       
         
         _  __ 
         _  __ 
             __ 
          __   
               
            
         _  _ 
      __
      _
      ___
      _
            
               __      
          __ 
              _   
     _     _  _ 
               __ 
     _     _ 
             _  _   __ 
          __   
          _ _
               __ 
}
在_中所有的方法都是可选的，但是为了实现一个有价值的文件系统，有些方法是必须实现的比如。

 类似于 
 读取链接文件的真实文件路径
 已经过时，使用替代
 创建一个文件节点
 创建一个目录
 删除一个文件
 删除一个目录
 创建一个软链接
 重命名文件
 创建一个硬链接
 修改文件权限
 修改文件的所有者和所属组
 改变文件的大小
 修改访问和修改文件的时间，已经过时，使用替代
 打开文件
 读取文件
 写文件
 获取文件系统状态
 刷缓存数据
 释放打开的文件
 同步数据
 扩展属性接口， 下同



 打开一个目录
 读取目录
 释放打开的目录
 同步目录
 初始化文件系统
 清理文件系统
 检查访问权限
 创建并打开文件
 修改文件的大小
 获取文件属性





_
_



在探究的实现之前，我们先给出的核心的数据结构框架图。这幅图可以我们在阅读代码的时候作为参考。

图 数据结构图
接下来我们来看一下是如何实现的。从_这个入口开始，从这里我们注册进去定义的文件操作方法来实现我们自己的文件系统。在_中，首先会完成参数解析，注册用户定义的 实现文件系统的挂载系统调用，填充相关的数据结构，消息的处理。消息的处理部分是最核心的部分，实现用户态与内核的互动，从内核接收消息，解析，调用用户自定义的，完成处理后，把结果通过返回给内核，内核再返回给层的系统调用，获得结果。

图 实现流程图
内核实现分析
对于内核部分又为两个部分，一个部分是文件系统部分，另一个部分是字符设备部分。两部分建立关联是在文件系统挂载的时候。
我们首先从挂载部分看起，利用工具，截取系统调用相关的信息：
  
…
 _|_   = 
…
   _|_ ==_= = 
…
参数部分需要关注一下，=，这个是关联字符设备和文件系统关键纽带。
上面是用户态的系统调用，接下来我们再来看一下内核态中系统调用的处理过程。
_
| _
       | __
            | __
            | __
                 | _
                      |  _
                           | _
                                | __
                                     |  = 
                                     |  = 
                                     | __ = 
                                     |  = __
                                     | _ = 
在最后的__部分，就是通过传进来的参数”=”得到的，对应于打开的“”。在挂载时候创建的，_ _，在这里关联起来了，具体的可以看一下图更清楚一些。

图  模块数据结构图
接下来我们以删除一个文件为例，看一下是如何工作的，图摘自官方文档内核部分。
首先_会阻塞在读 当挂载点下面有新的行为删除文件触发时，会通过系统调用调用文件系统内核接口，并生成消息，同时唤醒阻塞的_读操作，_读到之后，到用户态利用进行解析，根据中的找到对应的并执行，执行之后通过把处理的结果传回。阻塞的行为会被唤醒，然后完成的访问。

图 用户态和内核态交互过程示例
实践过程记录
在实践章节，我们准备在环境中演示一下一个实用的用户态文件系统，实现用户态配额文件系统。这里我们需要用到和，本文主要还是为了演示，对于和本身不做详细介绍，只介绍一些用到的命令。
是一个开源组件，广泛用于嵌入式开发平台，集，，，， 等于一身，方便开发者定制自己的系统。
是一个虚拟机，可以做到指令集的仿真，支持，，等架构，可以用于模拟实体板卡。
平台： 平台：_ ：

安装实验必须的组件：     
从上克隆库。  
编译，切换到根目录  ___

    

 


在编译完成那个以后，我们可以得到下面的
 
    
运行环境
 
    
        = =       
测试。在用把环境启动起来以后，我们可以测试我们，相应的代码可以从 获取。
  
  
  
   _  _ _ 
     

     
          
      
      
 
     
     =_==
     
     ==
     =
     
     =
     
     _=_=
  
 
                                 _
                         _  
  _

  _

  = = = =
  
  
  _


文章来源微信公众号  作者：

  
我们先来看看，我们干哈要学正则表达式这玩意儿：

复杂的字符串搜寻、替换工作，无法用简单的方式类似借助标准库函数达成。
能够帮助你进行各种字符串验证。
不止应用于编程语言中：、、、、。
也应用于许多操作系统的主流指令中：、、 。

在我们常用的开发工具中，如 、、，正则表达式也能帮助我们方便的进行的工作。由于正则表达式的流派很多，这篇文章主要是描述中的正则表达式。
介绍点语法
定义

所谓正则表达式，就是一种描述字符串结构模式的形式化表达方法。

这是《精通正则表达式》对于它的定义，反正我看了这句话还是不知道正则表达式是干嘛用的，不过没关系，下面我们先来看一下的正则表达式中一些常用的语法。
创建方式
在中，我们可以通过构造函数或者直接量两种方式去创建正则表达式。
  = 
  =  

上面代码中的和是等价的，都是用来匹配所有以字母结尾的字符串。
多说两句：
在创建变量时，对于布尔、数值、字符串、和这个五个原始值类型来说，原始类型优于封装对象，原因如下。
、不同于字符串直接量，出来的是一个真正的对象，这意味着你不能使用内置操作符来比较两个截然不同的对象的内容。
  =  
   
   

  =  
  =  
 ===   

这是因为每个对象对是一个单独的对象，其总是只等于其自身。使用不严格相等运算符也是一样。
 ==   

、在规范中，就像{}这样的对象直接量一样，程序运行时每次碰到直接量都会创建新对象。比如，如果在循环体中写  = ，则每次遍历都会创建一个新的正则表达式对象。然而在规范中一个正则表达式直接量会在执行到它时转换为一个对象，同一段代码的正则表达式直接量的每次运算都返回同一个对象。而做了相反的规定。用下面这段代码做比较。
  {
      = 
     = 
     
}

  = 
 = 
 ===   在中返回，在中返回
 = 
  在中返回，在中返回

显然的规范更符合开发者的期望。
各种表格
直接量字符



字符
匹配




字母和数字字符
自身


\
字符


\
制表符\


\
换行符\


\
垂直制表符\


\
换页符\


\
回车符\


\
由十六进制数指定的拉丁字符


\
由十六进制数指定的字符


\
控制字符



注：

由十六进制数指定的拉丁字符，例如：\等价于\由十六进制数指定的字符：\等价于\控制字符：\等价于换行符\如果不记得哪些标点符号需要反斜杆转义，可以在每个标点符号前都加上反斜杆。

字符类



字符
匹配





方括号内任意字符



不在方括号内的任意字符



除换行符和行终止符外的任意字符


\
任何Ⅱ字符组成的单词，等价于_


\
任何不是Ⅱ字符组成的单词，等价于_


\
任何空白符


\
任何非空白符，注意\和\的不同


\
任何Ⅱ数字，等价于


\
除了Ⅱ数字之外的任何字符，等价于


\
退格直接量




注：
方括号又叫字符组，注意某些元字符在字符组外和字符组内的意义不同。例如：在字符组外匹配行的开头，在字符组内表示排除型字符；在字符组外匹配普通连字符号，在字符组内不在开头表示一个范围；问号和点号在字符组外通常是元字符，但在字符组内只是匹配普通字符而已。


重复字符类



字符
匹配




{}
匹配前一项至少次，但不能超过次


{}
匹配前一项次或多次


{}
匹配前一项次



匹配前一项次或次，也就是说前一项是可选的，等价于{}



匹配前一项次或多次，等价于{}



匹配前一项次或多次，等价于{}




注：
默认是贪婪匹配，也就是说匹配重复字符是尽可能多地匹配，而且允许后续的正则表达式继续匹配。而进行非贪婪匹配，只需要在待匹配的字符后面跟随一个问号即可：“”、“”、“ ”、“{}”。比如：可以匹配一个或多个连续的字母。当使用“”作为匹配字符串时，会匹配它的三个字母。但是会尽可能少的匹配，只能匹配第一个哦


选择、分组和引用字符



字符
匹配




竖线
选择，匹配的是该符号左边的子表达式或右边的子表达式



组合，将几个项组合为一个单元，这个单元可通过“”、“”、“”和竖线等符号修饰，而且可以记住和这个相匹配的字符串以供伺候的引用使用



只组合，把项组合到一个单元，但不记忆与该组相匹配的字符


\
和第个分组第一次匹配的字符相匹配，组是圆括号中的子表达式也有可能是嵌套，组索引是从左到右的左括号数，“”形式的分组不编码



锚字符



字符
匹配





匹配字符串的开头，在多行检索中，匹配一行的开头



匹配字符串的结尾，在多行检索中，匹配一行的结尾


\
匹配一个单词的边界，简而言之，就是位于字符\和字符\之间的位置，或位于字符\和字符串的开头或结尾之间的位置但需要注意的是在字符组内\匹配的是退格符


\
匹配非单词边界的位置


=
零宽正向先行断言，要求接下来的字符都与匹配，但不能包括匹配的那些字符



零宽负向先行断言，要求接下来的字符不与匹配



修饰符



字符
匹配





执行不区分大小写的匹配



执行一个全局匹配，简而言之，即找到所有的匹配，而不是在找到第一个之后就停止



多行匹配模式，匹配一行的开头和字符串的开头，匹配行的结束和字符串的结束



用于模式匹配的方法



方法
意义





参数：一个正则表达式。返回：第一个与参数匹配的子串的起始位置，如果找不到，返回。不支持全局搜索，如果参数是字符串，会先通过构造函数转换成正则表达式。



检索和替换。第一个参数：正则表达式，第二个参数：要进行替换的字符串，也可以是函数。设置了修饰符，则替换所有匹配的子串，否则只替换第一个子串。通过在替换字符串中使用“”，可以使用子表达式相匹配的文本来替换字符。



参数：一个正则表达式。返回：一个由匹配结果组成的数组。设置则返回所有匹配结果，否则数组的第一个元素是匹配的字符串，剩下的是圆括号中的子表达式，即中存放的是的内容。



参数：正则表达式或字符串。返回：子串组成的数组。



对象
构造函数
  =   

 正则表达式中两条斜杆之间的文本
 可选，指定修饰符：
作用：动态创建正则表达式，例如待检索的字符串是由用户输入的。
的属性



属性
意义





只读字符串，包含正则表达式的文本。



只读布尔值，是否带修饰符



只读布尔值，是否带修饰符



只读布尔值，是否带修饰符



可读写整数，如果带修饰符，这个属性储存在整个字符串中下一次检索开始的位置，这个属性会被和方法用到。



的方法



方法
意义





参数：字符串。在一个字符串中执行匹配检索，与非全局检索类似，返回一个数组或。



参数：字符串。返回  



转换成字符串形式



关于对象的属性和方法多说两句：
对象的属性包含了发生匹配的字符位置，属性引用的是正在检索的字符串。当调用或的正则表达式具有修饰符时，它将把当前正则表达式对象的属性设置为紧挨着匹配子串的字符位置。如果没发现任何匹配结果，将重置为。可以通过此特性反复调用或来遍历字符串。
中，正则表达式直接量的每次计算都会创建一个新的对象，每个新的对象具有各自的属性，这势必会大大减少“残留”属性对程序造成的意外影响。
一些栗子

匹配
常见的：当然，或的结尾也很常见，或者干脆没有部分，还包括或的协议头。

其实的规则比较复杂，但是跟在之后的就有可能是主机名，所以这个部分先简单的用_来匹配，再加上可能存在的端口号，所以再加上， 就成了_。

部分变化更多，所以需要使用_=来匹配。注意，连字符必须放在字符组的开头，保证它是一个普通字符，而不是用来表示范围。

综合起来，我们得到的正则表达式就是：  = \\_\_=\||

因为我们降低了对匹配的要求，所以 这种显然不是合法的字符串也能匹配，不过我觉得还好，毕竟我们需要在正则匹配的复杂性和完整性之间取得平衡。


接下来，我们一步步地对进行分析。
我们可以将分为三个部分：

协议头：或

主机名：主机名是位于之后和第一个反斜杆如果有的话之前的内容。

路径：除了上面两者之外的内容。

得到正则表达式：  = \\

由于可能包含端口号，它位于主机名和路径之间，以冒号开头 \

得到正则表达式：  = \\\

匹配合法的主机名：由点号分隔部分组成，每个部分可以包括Ⅱ字符、数字和连字符，但不能以连字符开头和结尾。则可以得到：  = |

结尾的后缀部分只有有限个可能：|||||||||||||

完善后得到：  =\|{}\|||||||||||||


匹配 
匹配标签嘛，感觉很简单的样子，我们的第一反应可能是：  = 不过这样匹配可能存在的问题是：如果中含有，上面的正则就不能正常匹配了。如：
 = = 

虽然上面这种的写法很少见，但确实合法的。因此，简单的就不能用了，需要想个聪明点的办法。
我们先来看一下 中有什么规则：中能够出现

引用文本被单引号或双引号包裹的
非引用形式的“其他文本”包括除了和引号之外的任何字符

引用文本：中的引文可以用双引号，也可以用单引号，但不允许嵌套转义的引号。


因此我们可以使用|来匹配。

其他文本：除了和引号之外的任意字符

可以使用来匹配现在可以得出匹配 的正则表达式最终版！
  = ||
给这个正则表达式来点注释：
                 开始的尖括号
                     任意数量的
                   双引号字符串
        |                 或者是
                   单引号字符串
        |                 或者是
                    其他文本
                        
                 结束的尖括号

需要注意的是，我们不用来修饰的原因是可能会带来灾难性的后果。匹配次数呈指数级增长。比如：对于简单的目标字符串，是星号会迭代次，每一次迭代中匹配一个字符？还是星号迭代次，内部的分别匹配、、个字符？或者、、、个字符？还是其他情况？这样会把正则引擎搞疯掉的啦！
匹配
其实匹配引号内字符串的最简单办法是用这个表达式：。
不过我们要容许其中包含转义的引号，例如：   \\ 。
下面进行任务分解：

匹配起始引号
匹配正文
匹配结束引号

不过由于转义之后的引号也能够出现的正文中，所以处理起来比较棘手哈。
我们还是以   \\ 为例子。如果中有逆序环视可用，我们可以这样写：  = |=\\。
但是这个正则表达式无法匹配下面这两个无聊的例子：|\\  我本来想匹配|\\，结果匹配的确是|\\  。

注：
这里的结束分隔符是一个引号，但正文也可能包含转义之后的引号。匹配开始和结束分隔符很容易，诀窍就在于，匹配正文的时候不要超越结束分隔符。


匹配正文的思路：、不是引号：由匹配。、是一个引号，而它左边又有一个反斜杆，那么这个引号也属于正文。使用逆序环视：|=\\
鉴于上面的例子，我们需要对  = |=\\进行修改！
第一个表达式的问题在于，我们把反斜杆认为只是用来转义引号的，其实反斜杆在字符串中可以用来转义任何字符。因此，我们要匹配的文本其实是开始引号和结束引号之间，包括转义字符和非引号的任何字符。得到：\\|
不过！
上面的表达式还是会错误的匹配：   \\  中的   \\ 即使这并不是一个字符串。
因为，这个表达式一开始匹配到了引号之后的文本，如果找不到结束的引号，它就会回溯。而匹配到了\里的反斜杆后，之后的那个引号会被表达式认为是一个结束的引号。。。
继续改改改！
所以我们需要保证，字符串里的反斜杆不能以方式匹配。要将改为\\上面的正则表达式使用了正则表达式并不兹瓷的逆序环视，这里给出支持的版本。
\\|\\\\ 或者 \\\\
好了，由于本人笔力有限，关于的正则表达式只能介绍到这里，感兴趣的同学可以去阅读犀牛书的第十章以及《精通正则表达式》这本书

原文链接：


相关推荐在中玩转 腾讯云从零部署站点这本书特别针对没有接受过计算机科学或软件工程专业学习的软件开发人员，这类人员除了熟悉所用语言语法和语义之外，很少接受其他专业培训，对软件工程中的一些概念理解欠缺。软件设计方面考虑较少。如果要成为一个专业的程序员，就需要学习已形成工业化的软件构建方式。
可维护性解释
这本书解释了可维护软件中的“维护”的意思：可维护性是软件质量的一个标准，代表一个系统可被修改的难易程度。所以它是面向程序员的，假设两个软件完成相同的功能，但一个软件的源码，让其他人或者一段时间之后的自己，很难理解，更不用提修改了，就说明这个软件的可维护性比另一个差。软件维护有种方式：发现并纠正纠正性维护；适应操作系统或运行环境的改变适应性维护；根据需求增加新的功能完善性维护；改进代码质量预防产生预防性维护。
三个基本理论
本书提供了条可以实现高可维护性的指导原则，这些原则背后有三个理论：
、坚持简单的原则最有助于提高可维护性
、可维护性不是项目开发完后才去考虑的，而应该是在项目开发的一开始就加以考虑。每个人的贡献都应当计算在内
、不同原则的违例会带来不同的影响，有些严重程度甚至于他。一个软件系统越遵守原则，可维护性越高。
对大要则的理解
按照从小到大，从细微到宏观的层次，这本书提取了编写可维护软件中大编程原则，小到程序开发者应当时刻注意的代码规范，大到系统架构师应该考虑的系统重构、组件和及接口的设计准则。
编写短小的代码单元
代码单元即面向对象编程里的方法或函数。这个原则要求每个函数的长度不应超过行。
动机
小的函数的好处？作者提出，小的函数容易重用，因为一个巨型的方法会包含很多细节，导致很难有一模一样的场景使用这个方法。作者提出，小的方法更易理解和进行单元测试。若超过行，则意味着方法可以被拆分了。
如何使用本原则
拆分重构的方式有提取方法和将方法替换为方法对象。
提取方法很容易理解，即从一个函数中提取一段代码，写成一个新的方法。但如果提取方法时发现，这个方法访问了很多局部变量，如果都作为新方法的参数的话，势必会导致参数列表过长。还有返回值的问题，如果这个方法会产生不止一个结果变量。一个重构技巧是将这个方法替换成一个方法对象，将不同的局部变量和结果变量作为类的成员，然后调用类方法。
编写简单的代码单元
这里的“简单”体现代码单元的分支点，所以这个原则可量化为：限制每个代码单元分支点的数量不超过个。 中常见的分支点代码就是和语句。
动机
让代码单元保持简单基于两个原因，一是简单的代码更容易修改，二是简单的代码更容易测试，分支点过多，意味着要有更多的测试用例。
如何使用本原则
复杂的代码单元可能是因为其中包含很多互不相关的代码块，这种情况可以采用“提取方法”若是其它复杂的情况，比如碰到链式的条件语句，如下判断国旗的语句：  {       =  {}           =  {}    }
第一种方法是引入数据结构，将国家映射到指定的对象上；第二种方法是使用“使用多态来代替条件判断”，实现同一个接口，代表广泛的国旗类型，然后为每个国家的国旗实现一个类。
再比如碰到嵌套的条件语句，为了使代码简单，可以使用“使用卫语句来代替嵌套的条件语句”的重构技巧，即标识出各种独立的情况，并插入语句来代替嵌套式的条件语句。
例如
 {
   {
     
  }  {
     
  }
}  {
   
}
可以改写成
 {
   
  
}
 {
   
  
}
 {
   
  
}
可以看到分支点并未减少，然后可以再用“提取方法”减少复杂度。
不写重复代码
对重复代码的定义是，一段至少行都相同的代码。
动机
如果复制代码，相同的代码出现在不同的地方，不利于源码的定位；如果需要修改的地方正是重复的代码，意味着要做很多重复性的工作，而且容易出错。
如何使用本原则
首先想到的是提取方法；但若是一个方法是另一个类的私有方法怎么办？这时应当将提取的方法放到一个工具类中。如果重复代码行以上完全相同已不存在，但代码相似，具有相同的逻辑，这时应该考虑提取父类。
保持代码单元的接口简单
限制每个代码单元的参数不能超过个。
动机
较少的接口参数能够保持简单的上下文，易于重用、理解和修改。
如何使用本原则
将多个参数包装成对象，比如输入坐标参数，与可以包装成一个点对象。使用“使用方法对象替换方法”的重构技巧，此处和前面有重合。
分离模块之间的关注点
模块对应类的概念。实际上就是要求类要保持小的体积，不要过大过复杂。
动机
小的体积的类带来了类之间的松耦合，松耦合意味着类能更灵活的适应将来的变化。如果一个类做了很多事情，其耦合度会越来越紧，积攒大量代码，导致代码很难阅读和修改。
如何使用本原则
第一种方法：根据功能将大类拆分为很小的类。一个类一开始可能很小，只是实现单一功能，但都不可避免负责越来越多的职责，当意识到这个类承担了不止一个职责时，就应该将这个类进行拆分。
第二种方法：提取一个接口，实现松耦合。比如一开始为一台相机设计了简单的相机类，只具备拍照，闪光灯打开和关闭个方法。后来这个类的使用扩展到新的移动设备上，增加了定时功能。这时类变大，而且只有一个类，还需要检查旧设备上的代码有没有受影响。为了降低耦合度，可以使用一个接口，它只定义所有相机都需要实现的功能。
第三种方法：使用第三方库和框架来替代自定义的实现。
架构组件松耦合
组件是比模块类更高一层的单元，设计到系统的架构。此原则要求尽可能减少当前模块暴露给例如，被调用其它组件中模块的相关代码。
动机
独立的组件可以单独进行维护，方便划分职责，让测试变得容易。
如何使用本原则
使用抽象工厂设计模式，简单的讲就是类的实例不能直接被创建一个，而是通过工厂类的方法返回。这种通用的工厂接口背后，隐藏了具体产品的创建过程。在这个环境下，产品通常都不止有一种类型。如果要使用其中的逻辑，需要通过创建通用的工厂对象调用类方法成员。注：抽象工厂不同于工厂模式，简单理解就是抽象工厂的类型不止一个，所以产品至少有两个。
保持架构组件之间的平衡
保持源代码中的组件数量接近于。
动机
好的组件平衡让查找和分析代码更容易，提供清晰的功能边界，分离维护职责。
如何使用本原则
软件系统的开发有两种组织模式：
基于功能领域划分的系统：好处是可以从高层功能的角度来分析代码，坏处是技术人员需要了解多个技术栈
基于技术划分的系统：根据技术专长来划分，可能会有前端，后端，接口、日志等组件。
软件架构师需要选择如何组合功能的合适原则。明确系统的领域并坚持下去。
保持小规模代码库
动机
大型系统更加难以维护，易出现更密集的缺陷，以大型代码库为目标的项目更容易失败。
如何使用本原则
功能层面：控制需求蔓延，功能标准化技术层面：不要复制黏贴代码，重构代码，使用第三方库和框架这同样是前面提到的准则
自动化开发部署和测试
测试包含单元测试、集成测试、端对端测试、回归测试、验收测试。不同类型的测试需要不同的自动化框架。
动机
自动化测试可重复，有效率；自动化测试里的断言可以充当注释；通过编写测试可以反过来推促编写可测试的代码，提高代码质量。如何使用本原则
使编写单元测试成为每个开发人员的职责，比如使用中的单元测试框架。使用像或者这样的技术。即测试桩。需要测试桩是因为有些影响测试结果的测试条件是易变、无法统一的。比如拍照，两次拍摄的环境不可能完全相同，结果无法验证，所以需要一个假对象，即测试桩。模拟是因为测试中某些函数是沉默的，不包含任何结果，可以在函数中添加计数来验证函数执行过。技术有自动化的框架。
建议生产代码和测试代码一比一，提高覆盖率。
编写简洁的代码
给程序开发人员总结了条“童子军军规”：
、编写单元级别的良好代码、不要编写不好的注释、不要注释代码、不要保留废弃代码注：包括，同时还有其它的形式，比如不可能执行到的代码、无用的私有方法、注释中的代码、不要使用过长的标识符名称、不要使用魔术常量注：指表达式中突兀出现的数字，应该先定义。、不要使用未正确处理的异常
注：包括以下情况，捕获异常却不处理为空，直接捕获通用异常比如异常，这些异常不会提供触发失败的状态或事件信息，所以没意义，将异常信息展示给终端用户避免用户困惑或暴露信息，应该先转换为通用信息作者：钟秉成

《饥荒》是由   开发的一款动作冒险类求生沙盒游戏，是目前较火的一个独立游戏。
多人联机服务器让你和你的小伙伴可以合作，共同在沙盒世界里求得生存。游戏中有多样化的道具制作及建筑系统，此外怪物们的能力提高并加入更多新道具，给了玩家更多的发挥空间，讲究协同作战的魅力。
需要解决的问题：

常规多人在线联机的问题在于主机需要较高的配置以及较稳定的上传带宽

并且由于服务端依赖于主机，故主机不能离线，限制性较大。

家庭宽带上传带宽不稳定，且基本没有公网 ，给联机游戏带来了一定的体验问题。

由于《饥荒》的优化问题，饥荒服务端不支持多核心，单核性能是关键。


解决思路：
据了解和测试，腾讯云的服务器单核处理性能是阿里云的至倍经游戏测试，阿里云服务器在控制台调出只蜜蜂的时候开始卡顿，而腾讯云在只的时候才开始卡顿。故选择腾讯云作为联机服务器搭建平台。由于《饥荒》游戏里分为地上世界及地下世界，在同一个服务器上搭建的话，服务器荷载较大，游戏体验也会降低。故在两个服务器上分别搭建两个世界，然后通过端口将两个世界连接起来，从而使服务器容纳人数提升到倍，且降低延迟和卡顿出现的机率。并且使用  脚本对服务器进行简单的管理如：开关服务器，新建世界，备份恢复存档，增减  等一系列功能。
使用到的腾讯云产品：
个核的云服务器最低带宽，推荐带宽，操作系统可选  或 ，推荐  
个人感受：
相比于用自己电脑建立服务器供小伙伴玩耍，这种方法明显降低了延迟 低于，常规联机至少以及卡顿，大大提高了游戏体验，有较高的实用性以及可行性。本人在饥荒联机贴吧发过相关视频教程，也是被置顶供大家参阅。
相比于阿里云，腾讯云服务器有较强的单核性能，但是也有不足的地方。比如最低配置的学生服务器只有 带宽阿里云可选  按流量收费，这在一定程度上影响了游戏体验。还有就是  用户权限的问题，腾讯云默认是不给  用户权限的，如何获取  用户权限对普通玩家来说也是一个难点。
待完善的部分：

如果有条件的话，可以把搭建好的云服务器镜像上传到镜像市场，免去一步步搭建的烦恼，一步到位。
目前的服务器管理脚本比较简陋，可以再进行完善。

由于之前出的教程是用阿里云搭建的，故不方便公开展示，仅供参考，链接见附录。
附录：
 由于第一个视频教程刚出，饥荒官方就对联机服务端进行了更新，文件目录等有了较大的变化，故视频教程分为两部分，第二个视频是更新后对教程的补充，视频均上传至云盘，可下载原画版。
 更新前
 更新后
 = 云盘

相关推荐
【腾讯云服务器安装饥荒专属服务器】
云服务器功能概述
学生专属云服务器作者 |李涛编辑 | 顾乡

是一种快速多渠道打包工具，同时支持基于签名和签名进行多渠道打包。插件本身会自动检测使用的签名方法，并选择合适的多渠道打包方式，对使用者来说完全透明。

概述
众所周知，因为国内应用分发市场的现状，我们在发布时，一般需要生成多个渠道包，上传到不同的应用市场。这些渠道包需要包含不同的渠道信息，在和后台交互或者数据上报时，会带上各自的渠道信息。这样，我们就能统计到每个分发市场的下载数、用户数等关键数据。
普通的多渠道打包方案
既然我们需要进行多渠道打包，那我们就看下最常见的多渠道打包方案。
  
 本身提供了多渠道的打包策略：首先，在中添加渠道信息占位符：
 
= ={} 
然后，通过 提供的标签，添加渠道信息：
{
    {
         =   
    }
    {
         =   
    }
}
这样，编译生成多渠道包时，会用不同的渠道信息替换中的占位符。我们在代码中，也就可以直接读取中的渠道信息了。
但是，这种方式存在一些缺点：
每生成一个渠道包，都要重新执行一遍构建流程，效率太低，只适用于渠道较少的场景。
会为每个渠道包生成一个不同的类，记录渠道信息，导致每个渠道包的的值都不同。一般情况下，这是没有影响的。但是如果你使用了微信的热补丁方案，那么就需要为不同的渠道包打不同的补丁，这完全是不可以接受的。因为是通过对比基础包和新包生成差分补丁，然后再把补丁和基础包一起合成新包。这就要求用于生成差分补丁的基础包和用于合成新包的基础包是完全一致的，即：每一个基础渠道包的文件是完全一致的，不然就会合成失败

是一个逆向分析工具，可以把解开，添加代码后，重新打包成。因此，基于的多渠道打包方案分为以下几步：
复制一份新的通过工具，解压  删除已有签名信息添加渠道信息可以在的任何文件添加渠道信息通过工具，重新打包生成新  重新签名经过测试，这种方案完全是可行的。
优点：
不需要重新构建新渠道包，仅需要复制修改就可以了。并且因为是重新签名，所以同时支持和签名。
缺点：
工具不稳定，曾经遇到过升级 版本后，低版本解压失败的情况。生成新渠道包时，需要重新解包、打包和签名，而这几步操作又是相对比较耗时的。经过测试：生成企鹅电竞个渠道包需要分钟左右，虽然比 方案减少很多耗时。但是若需要同时生成上百个渠道包，则需要几个小时，显然不适合渠道非常多的业务场景。
那有没有一种方案：可以在添加渠道信息后，不需要重新签名那？首先我们要了解一下的签名和校验机制。
数据摘要、数字签名和数字证书
在进一步学习和签名之前，我们有必要学习一下签名相关的基础知识。
数据摘要
数据摘要算法是一种能产生特定输出格式的算法，其原理是根据一定的运算规则对原始数据进行某种形式的信息提取，被提取出的信息就是原始数据的消息摘要，也称为数据指纹。一般情况下，数据摘要算法具有以下特点：
无论输入数据有多大长，计算出来的数据摘要的长度总是固定的。例如：算法计算出的数据摘要有。一般情况下不考虑碰撞的情况下，只要原始数据不同，那么其对应的数据摘要就不会相同。同时，只要原始数据有任何改动，那么其数据摘要也会完全不同。即：相同的原始数据必有相同的数据摘要，不同的原始数据，其数据摘要也必然不同。不可逆性，即只能正向提取原始数据的数据摘要，而无法从数据摘要中恢复出原始数据。著名的摘要算法有公司的算法和系列算法。
数字签名和数字证书
数字签名和数字证书是成对出现的，两者不可分离数字签名主要用来校验数据的完整性，数字证书主要用来确保公钥的安全发放。
要明白数字签名的概念，必须要了解数据的加密、传输和校验流程。一般情况下，要实现数据的可靠通信，需要解决以下两个问题：
确定数据的来源是其真正的发送者。确保数据在传输过程中，没有被篡改，或者若被篡改了，可以及时发现。
而数字签名，就是为了解决这两个问题而诞生的。首先，数据的发送者需要先申请一对公私钥对，并将公钥交给数据接收者。然后，若数据发送者需要发送数据给接收者，则首先要根据原始数据，生成一份数字签名，然后把原始数据和数字签名一起发送给接收者。数字签名由以下两步计算得来：
计算发送数据的数据摘要用私钥对提取的数据摘要进行加密
这样，数据接收者拿到的消息就包含了两块内容：
原始数据内容附加的数字签名
接下来，接收者就会通过以下几步，校验数据的真实性：

用相同的摘要算法计算出原始数据的数据摘要。
用预先得到的公钥解密数字签名。
对比签名得到的数据是否一致，如果一致，则说明数据没有被篡改，否则数据就是脏数据了。

因为私钥只有发送者才有，所以其他人无法伪造数字签名。这样通过数字签名就确保了数据的可靠传输。综上所述，数字签名就是只有发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对发送者发送数据真实性的一个有效证明。
想法虽好，但是上面的整个流程，有一个前提，就是数据接收者能够正确拿到发送者的公钥。如果接收者拿到的公钥被篡改了，那么坏人就会被当成好人，而真正的数据发送者发送的数据则会被视作脏数据。那怎么才能保证公钥的安全性那？这就要靠数字证书来解决了。
数字证书是由有公信力的证书中心颁发给申请者的证书，主要包含了：证书的发布机构、证书的有效期、申请者的公钥、申请者信息、数字签名使用的算法，以及证书内容的数字签名。
可见，数字证书也用到了数字签名技术。只不过签名的内容是数据发送方的公钥，以及一些其它证书信息。这样数据发送者发送的消息就包含了三部分内容：

原始数据内容
附加的数字签名
申请的数字证书。

接收者拿到数据后，首先会根据的公钥，解码出发送者的公钥。然后就与上面的校验流程完全相同了。
所以，数字证书主要解决了公钥的安全发放问题。因此，包含数字证书的整个签名和校验流程如下图所示：
签名和多渠道打包方案
签名机制
默认情况下，使用的就是签名。解压后，在目录下，可以看到三个文件：、、。它们都是签名的产物。
其中，文件内容如下所示：它记录了中所有原始文件的数据摘要的编码而数据摘要算法就是。
文件内容如下所示：主属性记录了文件所有主属性的数据摘要的编码。则记录了整个文件的数据摘要的编码。其余的普通属性则和中的属性一一对应，分别记录了对应数据块的数据摘要的编码。例如：文件中___对应的，就是下面内容的数据摘要的编码。
 ___
 =
\\
这里要注意的是：最后一行的换行符是必不可少，需要参与计算的。
文件包含了对文件的数字签名和开发者的数字证书。就是计算数字签名使用的非对称加密算法。
签名的详细流程可参考，整个签名流程如下图所示：整个签名机制的最终产物就是、、三个文件。
校验流程
在安装时，系统会校验签名，检查是否被篡改。代码流程是：  ，类负责签名的具体校验。整个校验流程如下图所示：若中间任何一步校验失败，就不能安装。
，了解了的签名和校验流程。我们来看下，签名是怎么保证文件不被篡改的？首先，如果破坏者修改了中的任何文件，那么被篡改文件的数据摘要的编码就和文件的记录值不一致，导致校验失败。其次，如果破坏者同时修改了对应文件在文件中的值，那么中对应数据块的值就和文件中的记录值不一致，导致校验失败。最后，如果破坏者更进一步，同时修改了对应文件在文件中的值，那么的数字签名就和记录的签名不一致，也会校验失败。那有没有可能继续伪造的数字签名那？理论上不可能，因为破坏者没有开发者的私钥。那破坏者是不是可以用自己的私钥和数字证书重新签名那，这倒是完全可以！
综上所述，任何对文件的修改，在安装时都会失败，除非对重新签名。但是相同包名，不同签名的也是不能同时安装的。
文件结构
由上述签名和校验机制可知，修改中的任何文件都会导致安装失败！那怎么添加渠道信息那？只能从的结构入手了。
文件本质上是一个压缩包，而格式是固定的，主要由三部分构成，如下图所示：第一部分是内容块，所有的压缩文件都在这部分。每个压缩文件都有一个  ，主要记录了文件名、压缩算法、压缩前后的文件大小、修改时间、值等。第二部分称为中央目录，包含了多个   和第一部分的  一一对应，每个中央目录文件头主要记录了压缩算法、注释信息、对应  的偏移量等，方便快速定位数据。最后一部分是，主要记录了中央目录大小、偏移量和注释信息等，其详细结构如下图所示：
根据之前的签名和校验机制可知，签名只会检验第一部分的所有压缩文件，而不理会后两部分内容。因此，只要把渠道信息写入到后两块内容就可以通过校验，而的注释字段无疑是最好的选择。
基于签名的多渠道打包方案
既然找到了突破口，那么基于签名的多渠道打包方案就应运而生：在文件的注释字段，添加渠道信息。
整个方案包括以下几步：

复制
找到数据块
修改注释长度
添加渠道信息
添加渠道信息长度
添加魔数

添加渠道信息后的数据块如下所示：
这里添加魔数的好处是方便从后向前读取数据，定位渠道信息。因此，读取渠道信息包括以下几步：

定位到魔数
向前读两个字节，确定渠道信息的长度
继续向前读字节，就是渠道信息了。

通过进制编辑器，可以查看到添加渠道信息后的小端模式，如下所示：
       是魔数， 表示渠道信息长度为，   就是渠道信息了。 就是注释长度了，正好是。
虽说整个方案很清晰，但是在找到数据块这步遇到一个问题。如果本身没有注释，那最后字节就是。但是若本身已经包含了注释字段，那怎么确定的起始位置那？这里借鉴了系统签名确定位置的方案。整个计算流程如下图所示：
整个方案介绍完了，该方案的最大优点就是：不需要解压缩，不需要重新签名，只需要复制，在注释字段添加渠道信息。每个渠道包仅需几秒的耗时，非常适合渠道较多的。
但是好景不长，之后新增了签名，该签名会校验整个的数据摘要，导致上述渠道打包方案失效。所以如果想继续使用上述方案，需要关闭 中的签名选项，禁用签名。
签名和多渠道打包方案
为什么需要签名
从前面的签名介绍，可以知道存在两个弊端：
中的数据摘要是基于原始未压缩文件计算的。因此在校验时，需要先解压出原始文件，才能进行校验。而解压操作无疑是耗时的。 签名仅仅校验第一部分中的文件，缺少对的完整性校验。因此，在签名后，我们还可以修改文件，例如：通过进行字节对齐后，仍然可以正常安装。
正是基于这两点，提出了签名，解决了上述两个问题：

签名是对本身进行数据摘要计算，不存在解压的操作，减少了校验时间。
签名是针对整个进行校验不包含签名块本身，因此对的任何修改包括添加注释、字节对齐都无法通过签名的校验。

关于第一点的耗时问题，这里有一份实验室数据 、 可供参考。



安装耗时对比
取次平均耗时秒




签名



签名




可见，签名对的安装速度还是提升不少的。
签名机制
不同于，签名会生成一个签名块，插入到中。因此，签名后的结构如下图所示：
签名块位于中央目录之前，文件数据之后。签名同时修改了中的中央目录的偏移量，使签名后的还符合结构。
签名块的具体结构如下图所示：首先是字节的签名块大小，此大小不包含该字段本身的字节；其次就是序列，就是一个字节的和对应的数据；然后又是一个字节的签名块大小，与开始的字节是相等的；最后是字节的签名块魔数。其中，为对应的就是签名块数据。
签名块的生成可参考，整体结构和流程如下图所示：
首先，根据多个签名算法，计算出整个的数据摘要，组成左上角的数据摘要集；接着，把最左侧一列的数据摘要、数字证书和额外属性组装起来，形成类似于签名的“”文件第二列第一行；其次，再用相同的私钥，不同的签名算法，计算出“”文件的数字签名，形成类似于签名的“”文件第二列第二行；然后，把第二列的类似文件、类似文件和开发者公钥一起组装成通过单个签名后的签名块第三列第一行。最后，把多个签名后的签名块组装起来，就是完整的签名块了中允许使用多个对进行签名。
上述流程比较繁琐。简而言之，单个签名块主要由三部分组成，分别是上图中第二列的三个数据块：类似文件、类似文件和开发者公钥，其结构如下图所示：
除此之外，也优化了计算数据摘要的算法，使得可以并行计算，如下图所示：
数据摘要的计算包括以下几步：
首先，将上述中文件内容块、中央目录、按照大小分割成一些小块。然后，计算每个小块的数据摘要，基础数据是  块字节长度  块内容。最后，计算整体的数据摘要，基础数据是  数据块的数量  每个数据块的摘要内容。这样，每个数据块的数据摘要就可以并行计算，加快了签名和校验的速度。
校验流程
  之上默认会同时开启和签名，同时包含和签名的文件会有一个特殊的主属性，如下图所示：该属性会强制走校验流程之上，以充分利用签名的优势速度快和更完善的校验机制。因此，同时包含和签名的的校验流程如下所示：
简而言之：优先校验，没有或者不认识，则校验。
这里引申出另外一个问题：签名时，只有签名，没有签名行不行？经过尝试，这种情况是可以编译通过的，并且在 之上也可以正确安装和运行。但是之下，因为不认识，又没有签名，所以会报没有签名的错误。
，明确了平台对和签名的校验选择之后，我们来看下签名的具体校验流程   ，如下图所示：其中，最强签名算法是根据该算法使用的数据摘要算法来对比产生的，比如：  。
校验成功的定义是至少找到一个对应的签名块，并且所有签名块都按照上述流程校验成功。
下面我们来看下签名是怎么保证不被篡改的？
首先，如果破坏者修改了文件的任何部分签名块本身除外，那么的数据摘要就和“”数据块中记录的数据摘要不一致，导致校验失败。
其次，如果破坏者同时修改了“”数据块中的数据摘要，那么“”数据块的数字签名就和“”数据块中记录的数字签名不一致，导致校验失败。
然后，如果破坏者使用自己的私钥去加密生成“”数据块，那么使用开发者的公钥去解密“”数据块中的数字签名就会失败；
最后，更进一步，若破坏者甚至替换了开发者公钥，那么使用数字证书中的公钥校验签名块中的公钥就会失败，这也正是数字证书的作用。
综上所述，任何对的修改，在安装时都会失败，除非对重新签名。但是相同包名，不同签名的也是不能同时安装的。
到这里，签名已经介绍完了。但是在最后一步“数据摘要校验”这里，隐藏了一个点，不知道有没有人发现？
因为，我们签名块中的数据摘要是针对的文件内容块、中央目录和三块内容计算的。但是在写入签名块后，修改了中的中央目录偏移量，那么在进行签名校验时，理论上在“数据摘要校验”这步应该会校验失败啊！但是为什么签名可以校验通过那？
这个问题很重要，因为我们下面要介绍的基于签名的多渠道打包方案也会修改的中央目录偏移量。
其实也很简单，原来系统在校验的数据摘要时，首先会把的中央目录偏移量替换成签名块的偏移量，然后再计算数据摘要。而签名块的偏移量不就是签名之前的中央目录偏移量嘛！！！，因此，这样计算出的数据摘要就和“”数据块中的数据摘要完全一致了。具体代码逻辑，可参考的  行。
基于签名的多渠道打包方案
在上节签名的校验流程中，有一个很重要的细节：系统只会关注为的签名块，并且忽略其他的，同时签名只会保护本身，不包含签名块。
因此，基于签名的多渠道打包方案就应运而生：在签名块中添加一个，存储渠道信息。
整个方案包括以下几步：

找到的块
找到签名块
获取已有的 
添加包含渠道信息的
基于所有的生成新的签名块
修改的中央目录的偏移量上面已介绍过：修改的中央目录偏移量，不会导致数据摘要校验失败
用新的签名块替代旧的签名块，生成带有渠道信息的

实际上，除了渠道信息，我们可以在签名块中添加任何辅助信息。
通过进制编辑器，可以查看到添加渠道信息后的小端模式，如下所示：

   就是我们的渠道信息。向前个字节：   就是我们添加的，再向前个字节：       就是我们的的长度，正好是。
整个方案介绍完了，该方案的最大优点就是：支持之上新增的签名，同时兼有方案的所有优点。
多渠道包的强校验
那么如何保证通过这些方案生成的渠道包，能够在所有平台上正确安装那？
原来提供了一个同时支持和签名和校验的工具：。它包括一个命令行和一个类库。其中前者就是  下面的命令行工具。而我们正是借助后面的来进行渠道包强校验，它可以保证渠道包在   最高版本之间都校验通过。详细代码可参考
多渠道打包工具对比
目前市面上的多渠道打包工具主要有和美团的。下表是我们的和它们之间的简单对比。



多渠道打包工具对比







签名方案
支持
支持
不支持


签名方案
支持
不支持
支持


带有注释的
支持
不支持
不支持


根据已有生成渠道包
支持
不支持
不支持


命令行工具
不支持
支持
支持


强校验
支持
不支持
支持



这里我之所以同时支持和签名方案，主要是担心后续平台加强签名校验机制，导致多渠道打包方案行不通，可以无痛切换到签名方案。后续我也会尽快支持命令行工具。
插件接入
具体的接入流程可参考插件接入文档。

相关推荐
编译的原理解析和打包分析【腾讯云的种玩法】安卓加固在腾讯云上的使用附反编译结果接《 基础：，看这篇就够了 上》
相关
基本使用
是 库中提供界面滑动的类，继承自。是的适配器类，为提供界面。但是一般来说，通常都会使用的两个子类：和作为的适配器，他们的特点是界面是。

在 和 中都提供了和，区别在于： 中使用，而 使用。一般都使用 中的和。

默认，会缓存当前页相邻的界面，比如当滑动到第页时，会初始化第页和第页的界面即对象，且生命周期函数运行到，可以通过设置离线缓存的界面个数。
和需要重写的方法都一样，常见的重写方法如下：

   构造函数，参数为。如果是嵌套场景，子的参数传入。
   返回第位置的，必须重写。
  返回的页数，必须重写。
     是对象，返回第位置的。
       是对象，是对象。
  是对象，如果返回_，则表示当前不刷新，如果返回_，则表示当前需要调用和进行销毁和重建。 默认情况下返回_。

懒加载
懒加载主要用于且每页是的情况，场景为微信主界面，底部有个，当滑到另一个时，先显示”正在加载”，过一会才会显示正常界面。
默认情况，会缓存当前页和左右相邻的界面。实现懒加载的主要原因是：用户没进入的界面需要有一系列的网络、数据库等耗资源、耗时的操作，预先做这些数据加载是不必要的。
这里懒加载的实现思路是：用户不可见的界面，只初始化，但是不会做任何数据加载。等滑到该页，才会异步做数据加载并更新。
这里就实现类似微信那种效果，整个布局为：底部用项目实现，上面是，使用。逻辑为：当用户滑到另一个界面，首先会显示正在加载，等数据加载完毕后这里用睡眠秒钟代替显示正常界面。
默认缓存左右相邻界面，为了避免不必要的重新数据加载重复调用，因为有个，因此将离线缓存的半径设置为，即。
懒加载主要依赖的 方法，当变为可见时，会调用；当变为不可见时，会调用，且该方法调用时机：

之前，调用。
之前，如果该界面为当前页，则调用，否则调用。
界面变为可见时，调用。
界面变为不可见时，调用。

懒加载的实现：
     {

      
      
      

    
            {
         = _  
         = 
        
         
    }

       {
              {
            异步初始化，在初始化后显示正常
            
        }
    }

       {
          {
               {
                 加载数据
                 更新
                  = 
            }
        }
    }

    
        {
        
          {
            
        }
    }

        {
          
    }
}
注意点：

在中有两个变量控制是否需要做数据加载：
：表示是否准备好，因为数据加载后需要更新，如果还没有，就不需要做数据加载，因为会在之前调用一次，如果此时调用，还没有，因此不能加载数据。
：表示是否已经做过数据加载，如果做过了就不需要做了。因为在界面可见时都会调用，如果滑到该界面做过数据加载后，滑走，再滑回来，还是会调用，此时由于=，因此不会再做一遍数据加载。


：懒加载的核心类，在该方法中，只有界面可见==、准备好==、过去没做过数据加载==时，才需要调做数据加载，数据加载做完后把置为。

布局主要分两个，一个是初始显示的状态，即_，当数据加载完成，就显示：
 =
    = _=_
    _=_

    
        =_
        _=_
        _=_
        
            _=_
            _=_
            _=
            =正在加载
            

    
    
        =
        _=_
        _=_
        =
        
        
    

参考文献

入门
教程
教程
生命周期
  
     
    
和的区别
如何避免异常一、微信小程序接入的困境
农历新年将至，微信小程序也如期发布，开发者在接入微信小程序过程中，会遇到以下问题：
小程序要求必须通过  完成与服务端通信，若开发者选择自行搭建  服务，那需要自行  证书申请、部署，完成  服务搭建，效率低流程冗长且  的  加解析，对服务器的  有极大的开销。
不仅仅是小程序，苹果  平台，  在  也逐步强制要求开发者使用  接入。 似乎是一个绕不开的门槛，让不少开发者头痛不已。
针对以上问题，腾讯云的负载均衡服务  ，希望通过对  的性能优化，提供一键式的  证书申请服务，降低  的应用门槛和使用成本，让开发者能快速接入微信小程序等服务。首先，先让我们看看  与  的对比，逐一解开您的谜团。
二、为什么要接入 — 的安全风险
 协议是一个非常简单和高效的协议，互联网大部分的主流应用默认都是使用的。由于性能和上个世纪  年代使用环境的限制， 协议本身并不是一个为了安全设计的协议，既没有身份认证，也没有一致性检验，最头疼的是， 所有的内容都是明文传输的。
另外一方面，互联网的发展也是日新月异，各种  应用不断地渗透到人们生活的方方面面。不管是社交、购物、金融、游戏、还是搜索，这些  服务都能带给人们极大的便捷，提升生活质量和效率。
显然， 和人们生活及经济利益密切相关，遗憾的是，它不安全。也就意味着这里一 定潜藏着巨大的安全隐患。这些隐患又集中表现在如下两方面：
、隐私泄露
由于  本身是明文传输，用户和服务端之间的传输内容都能被中间者查看。也就是说 你在网上搜索、购物、访问的网点、点击的页面等信息，都可以被「中间人」获取。由于国人大多不太重视隐私的保护，这里的风险比较隐性，伤害后果也不太好定量评估。已知的一些比较严重的隐私泄露事件包括：

 登陆态被不法分子窃取，然后在异地登陆，进行广告和欺诈行为。
用户手机号和身份信息泄露。
用户网上行为泄露。比如搜索了一所医院，很快就会有人打电话进行推广非效果广告。

、页面劫持
隐私泄露的风险比较隐蔽，用户基本感知不到。但另外一类劫持的影响就非常明显非常直接了——页面劫持，也就是直接篡改用户的浏览页面。有很多页面劫持很简单粗暴，直接插入第三方广告或者运营商的流量提示信息。

但也有一些劫持做得比较隐蔽，比如下面的京东页面劫持：其中上图是使用  方面的页面，顶部箭头所示的地方出现了一个购物推荐，很逼真，就像京东或者浏览器官方的工具。

但换成  访问，就没有这个工具页面，显然是被劫持了。

、劫持路径及分类
那劫持到底是如何产生的呢？从技术上来讲比较简单，在内容经过的地方进行监听篡改就行了。但要想把整个劫持的产业链条摸清楚，需要深入黑产内部，比较困难。有一点可以肯定的是，劫持大部分都是在中间的网络节点发生的，又叫「中间人」，    。如下图所示：

由于信息传输都需要经过上述的「中间人节点」，它们又拥有信息的读写权限，如果信息没有加密，也没有校验，那么想要查看隐私，篡改页面，对于「中间人」来说可谓是轻而易举。
那劫持又有哪些主要的分类呢根据劫持路径划分的话，主要是下图所示的三类：

 劫持，客户端劫持和链路劫持。 根据我们的不完全统计，业务遇到的绝大部分劫持 都属于链路劫持。
三、 是解决链路劫持的核武器
 为什么能很好的解决链路劫持呢？主要是三大武器
、身份认证—防假冒，防抵赖
每次建立一个全新的  连接时，都需要对身份进行认证，确保用户访问的是正确的目的网站。

、内容加密—防窃听
内容加密意味端对端的通信内容全都是密文，中间人无法直接查看到明文， 所有的应用层内容都是通过对称加密来实现加密和解密的。

、一致性校验—防篡改
通过对数据和共享密钥的  码来防止中间者篡改消息内容，确保数据的一致性。

四、 普及之痛
事实上   年就诞生了，是一个非常古老、成熟的协议。同时又能很好地防止内容劫持，保护用户隐私。但是为什么一直到今天，还有大部分的网站不支持 ，只使用  呢

影响  普及的主要原因可以概括为两个字：「慢」和「贵」。
、慢
在未经任何优化的情况下， 会严重降低用户的访问速度。主要因素包括

网络耗时。由于协议的规定，必须要进行的网络传输。比如  完全握手， 跳转等。最坏情况下可能要增加  个 。



计算耗时。无论是客户端还是服务端，都需要进行对称加解密，协议解析，私钥计算，证书校验等计算，增加大量的计算时间。

、贵
 的贵，主要体现在如下三方面：

服务器成本。 的私钥计算会导致服务端性能的急剧下降，甚至不到  协议的十分之一，也就是说，如果  的性能是 ， 的性能可能只有几百 ，会增加数倍甚至数十倍的服务器成本。

证书成本。根据证书个数及证书类型，一年可能需要花费几百到几百万不等的证书成本。

开发和运维成本。 协议比较复杂， 的开源实现也经常发生安全， 包括协议的配置，证书的更新，过期监控，客户端的兼容等一系列问题都需要具备专业背景的技术人员跟进处理。


五、腾讯云负载均衡器  的性能优化
腾讯云负载均衡器深针对  推广应用过程中的痛点进行了深度优化。接下来我们详细地介绍下这些优化方案：
、访问速度的优化
前文提到  非常慢，我们也主要从两个层面对访问速度进行了优化：协议栈和前后端资源。
全链路协议栈优化
 可以认为是   ，而  又是使用  协议进行传输，所以整个协议栈的优化涉及到三个层面

 优化。包括拥塞窗口的调整，  ， 的支持，最新的  拥塞控制算法的支持等。



 协议优化。分布式    ，    ， 动态   等。

 协议优化最重要的目标还是提升简化握手的比例。腾讯云通过实现全局   和全局   来提升  的简化握手比例，节省用户访问时间和计算资源。


应用层协议优化。同时支持 ，， 等。

 相比  最大的优势就是多路复用，能够将多个  请求通过一个  连接并行发送，相比  的串行发送，性能无疑是提升很多。
由于  是从  继承发展出来的，所以部分较老的客户端只支持 ，不支持 。而大部分新客户端，只支持 ，不支持 。为了同时兼容新老客户端的性能，腾讯云同时支持  和 ，最大化提升新老版本客户端的性能。
前后端优化
 及  最大的特性和优势就是多路复用，能够将多个请求通过一个连接并行发送出来。这个特性虽然很强大，但是如果还使用传统的  优化策略，多路复用的效果会很有限。比如域名分片， 等都会影响多路复用的效果。于是我们又通过多次的数据实验，调整了一些前端资源包括后端接入的策略：

域名收归。通过页面资源及性能分析，确实域名收归方案，比如移动页面不超过  个。
预建连接。 提供预连接页面，通过对热点页面的用户行为进行分析，提前建立连接，减少协议开销对用户体验的影响。
通过腾讯云遍布全球的  及  节点就近完成  卸载。

、计算性能优化
针对  的计算性能，腾讯云主要从三个层面进行了优化，包括

尽量减少完全握手的发生，提升简化握手比例。比如前文提到的全局  和  。
对于不可避免的完全握手，腾讯云实现了  异步代理计算，通过对协议栈的改造和  硬件加速卡的使用，大幅度提升了  的计算能力和防攻击能力。
对称加密计算过程也进行了场景使用上的优化。

下面再详细介绍一下：
 异步代理计算
腾讯云针对  性能消耗最严重的环节——非对称密钥交换算法进行了重点优化。优化思路主要包括如下三部分


算法分离。就是将最消耗  资源的算法剥离出来，不让消耗本地的  资源。

代理计算。使用空闲的  机器或者专门的  硬件加速卡来完成  计算。

异步执行。传统的  在进行  的时候，上层应用，比如  都需要同步等待。这一步骤也非常影响，必须要进行异步改造，这样在加速集群进行  计算的时候，接入服务器也可以接入其他用户的请求，提升吞吐能力。


通过对  握手协议栈的深度改造以及  硬件加速卡的  计算性能，腾讯云  的  计算能力提升了 。单机 _ 处理性能达到了  。
对称加密算法的自动最优选择
腾讯云根据应用场景匹配最优的对称加密算法

对于视频等流媒体内容，优先使用 。
针对不支持  硬件加速指令的移动终端，使用  。
针对  等古董级别的客户端，使用  算法。


、协议的并行卸载
腾讯云  支持现在主流的全部  类协议接入和卸载。包括：


 及前身 
包括  
 及  。
 透明转发。

 能够将上述七层协议统一转换成 ，透传给业务。对业务的好处也非常明显  开发成本就能使用  和 ，极大减少了适配各种协议和客户端的压力。

、安全
安全涉及的领域和场景非常庞大， 虽然能够彻底解决链路劫持，但是对于如下两类问题却无能为力

 攻击，特别是  计算型攻击， 的性能会急剧降低，引入更大的安全风险。
业务安全，包括  注入， 跨站、网站挂马等。 

上述两类都是经常困扰业务的风险极大的安全问题。 
针对上述问题，腾讯云也设计实现了一套针对  的防  和  的安全系统，能够有效地防御这类安全风险。

无密钥加载
私钥的重要性
对证书稍微熟悉的朋友都知道， 密钥和证书都是成对使用的，一个证书一定唯一对应一个私钥。整个  最重要的一个数据就是  的私钥了，如果私钥泄露，整个握手过程就可以被劫持，签名可以被伪造，对称密钥也可以被破解。整个  就毫无安全可言。
传统的私钥使用方案和风险
传统的私钥方案就是将私钥和应用程序绑定在一起。比如大家熟知的  ，如果想使用 ，必须在部署  的接入机器上部署相关的证书和私钥。

这种方案会有如下安全上的问题：私钥部署在云端或者 ，如果泄露了怎么办？
无秘钥方式
虽然腾讯云的内网非常安全，但是出于对客户的安全负责，彻底打消用户对私钥泄露的顾 虑，确保用户对私钥的绝对控制，腾讯云提供一种无私钥的加载方案。这个方案核心是「不需要把私钥存储在腾讯云，允许用户使用自己的服务器保管私钥，完成  的接入」。 腾讯云完全接触不到私钥，客户甚至可以把私钥保存在自己家里的服务器上。
它的接入过程如下：

用户发起  握手请求。
在涉及到私钥计算的时候，腾讯云  会将这个私钥计算请求通过加密的自定义协议，转发给用户自己的  服务器上。
 服务调用用户的私钥完成计算。
 服务将计算结果返回给腾讯云 。
 继续进行  请求的处理。

整个过程，腾讯云接触不到  私钥，需要注意一点的，  是腾讯云提供一个服务端程序，代码开源，用户自主部署，服务端行为用户掌握得一清二楚。

六、零门槛， 快速接入微信小程序
腾讯云  负载均衡器通过对协议栈及服务端的深度优化，实现了  性能的巨大提升。同时，我们也通过与国际上著名的证书机构合作，极大降低了证书的成本。腾讯云  在如下几个方面，能够为微信小程序接入带来非常显著的收益：

提供一键式的  证书申请， 负载均衡服务作为  代理，减轻开发负担，让开发者可以专注小程序业务的开发。

使用  并不会降低  端的访问速度。、 访问时延几乎一致。

集群内单台服务器  加解密性能，高达  的完全握手。相比高性能 提升了至少  倍，节省了服务端成本，极大提升了业务运营及流量突涨时的服务能力， 增强了计算型防攻击的能力。

支持多种协议卸载及转换。减少业务适配客户端各种协议的压力，业务后端只需要支持  就能使用 ，，， 等各版本协议。满足微信小程序， 平台等对协议的要求。

 证书申请、监控、替换。我们和国际顶级的证书厂商 ， 已有深入合作，服务体系完善。

防  及  功能。能够有效杜绝慢连接、高频定点攻击、 注入、网页挂马等应用层攻击。


以上的这些收益，可以帮助开发者降低  的试用门槛。开发者还可以通过访问我们官方网站或点击「微信小程序解决方案」，查看微信小程序接入的最佳实践。

相关推荐 探索第一篇——概念 新增线下、、公众号多处入口，小程序会再火起来么？内有福利 微信小程序之提高应用速度小技巧作者：周志杰

前言
 是微信官方的终端基础组件，是一个使用  编写的业务无关、跨平台的基础组件。目前在微信 、、、、 等多个平台中使用。 主要包括以下几个独立的部分：

：基础库，包括、线程、消息队列、协程等基础工具；
：通用日志模块，充分考虑移动终端的特点，提供高性能、高可用、安全性、容错性的日志功能；详情点击：高性能日志模块
：网络诊断模块；
：信令传输网络模块，负责终端与服务器的小数据信令通道。包含了微信终端在移动网络上的大量优化经验与成果，经历了微信海量用户的考验。

 系列开始，将为大家介绍 信令传输网络模块。由于  的复杂性，该模块将被分解为多个篇章进行介绍。本文主要介绍微信中关于  连接及  选择的思考与设计。
你需要知道的连接
 协议应该是目前使用的最广泛的传输层协议，它提供了可靠的端到端的传输，为应用的设计节省了大量的工作。 建立连接的”三次握手”与连接终止的“四次挥手”也广为人知。在这简单的  调用中，还能做怎样的思考与设计呢？
      _ 
连接的超时重传
超时与重传是  协议最核心的部分，在不稳定的移动网络中，超时重传的设计尤为重要。在连接建立的过程中，由于网络本身的不可靠特性，不可避免的需要重传的机制来保障可靠服务。在《详解 卷》的描述中，在大多数  实现中，若主动  方没有收到  的回应，会在第秒发送第个  进行重试，第个  则是与第个间隔秒。在第秒还没有收到回应，则  调用返回 。
这就意味着，在不能立刻确认失败例如  等的情况下，需要秒的时间，才能获得结果。如果真相并不是用户的网络不可用，而是某台服务器故障、繁忙、网络不稳定等因素，那秒的时间只能尝试个  资源，对于大多数移动应用而言，是不可接受的。我们需要更积极的超时重传机制！！！
然而，我们并不能修改  的协议栈，我们只能在应用层进行干预，设计应用层的超时机制。说干就干，这个时候你是否已经在构思新的、应用层的连接超时重传机制了呢？应用层的超时重传，典型做法就是提前结束  的阻塞调用，使用新的  资源进行  重试。但是，我们应该选择怎样的连接超时值呢？秒？秒？秒？秒？不同的应用场景会有不同的选择。我们来看一下常见的几种场景：

连不同  网络不可用等
服务器繁忙  中间路由故障等
基站繁忙  连接信号弱  丢包率高等

在第一种场景中，连接超时设置不会带来什么区别。在第二种场景中，部分服务器资源或路由不可用，我们希望连接超时能稍微短一些，使得我们能尽快的发现故障，并且通过更换  的方式获得可用资源或路由路径。而第三种场景则是在移动网络中经常遇到的弱网络的场景。在这种场景中，我们更换  资源也是无效的，因此希望连接超时能相对长一些，进行更多的层的重传。当然，也不是超时越长越好，后面的分析可以看到很多等待时长是效果低微的
不同的场景对连接超时有不同的需求，然而，我们在程序中并没有很好的方法来区分这些场景。在进行连接超时这个阈值的选择前，我们先来看看，当前主流的 、 操作系统的连接设计。 的  层连接超时重传如下图所示测试机型为 ， 。超时间隔依次为，，，，，第次重试后秒返回 ，总用时秒。超时设置符合  的常规设置。

但在不同的机型中，偶尔会出现差异性。如下图  抓包三星  。

 的  超时重传如下图所示。超时间隔依次为，，，，，，，，，，总共是。

经过  的调研分析后，我们发现：

在  系统中对  的超时重传进行了一定的修改，在  初期使用更积极的策略，以适应移动网络的不稳定特征。而在  系统中， 超时重传则使用了较为“懒惰”、适用于有线网络的超时重传间隔；
不管什么平台，连接总超时时长都需要分钟左右，这个时长在大多数移动应用中，都是不符合用户体验要求的；
连接的初始阶段， 超时重传会更积极一些，越到后面，重传间隔越大。

因此，在实际的连接超时设置上，我们根据不同的系统特征，结合应用能接受的“用户体验”范围，可以设置不同的连接超时间隔。例如在  系统中，由于采用了较为积极的超时间隔，我们可以将  调用的超时设置为。在内， 会自动进行次的重发。在  系统中，系统会在第秒发起第次重发，之后需要在第秒才会重发。在不同的用户体验要求下，应用可以将  的调用超时设置为不同的值。例如也可以设置为意味着给第次重发的等待时间，从而避免无效的等待时长。同时通过更换  后，重新调用  操作的方式，来获得更积极的重发策略，更快的查找到可用的  组合。
连接的终止
“四次挥手”的连接终止协议已经口熟能详。过程如下图所示。需要关注的是，图中主动关闭的一方会进入 _ 状态，在此状态中通常将停留倍的  时长。 时长在不同的操作系统中有不同的设置，通常在秒到秒。_ 的数量太多会导致耗尽主动关闭方的  端口和句柄，导致无法再发起新的连接，进而严重影响主动关闭方的并发性能。虽然在实际的使用中，可以通过 __，__，___ 等方式缓解该问题，但也会带来一些副作用。最好的解决方案是在协议的设计上，尽量的由终端来发起关闭的操作，避免服务器的大量 _ 状态。例如，使用长连接避免频繁的关闭；在短连接的协议设计上，务必加上终止标记例如  头部加上  使得可以由终端来发起关闭的操作。

串行连接  并发连接  复合连接
在上述的连接超时策略中，我们选择秒的连接超时。这就意味着我们需要秒的时间来确认一个  组合的  超时。当我们有多个  资源时，遍历的效率偏低。那我们是否能设置  的超时为更短呢？例如秒。我们知道移动互联网具有不稳定的特征，超时时间设置过短，会导致在弱网络的情况下， 总是失败，导致不可用。串行连接的策略在超时选择上，由于需要兼顾高性能与高可用的设计目标，使得该策略是一个相对“慢”的连接策略。
与此相应，我们会想到并发连接的策略。并发连接，同时发起对个  的连接调用，可以让我们第一时间发现可用的连接，并且还顺带发现了  最快的  配置。并发连接可以一举解决了“高性能”、“高可用”的设计目标，看起来很完美。然而，这个时候，服务端的同学“跳”起来了。在并发连接的策略下，服务器需要提供的连接能力是串行连接的倍，对服务器连接资源是极大的浪费。同时，并发连接是否会引起连接资源的竞争，从而影响网络正常用户的常规体验，也是个未知的因素。
让我们来回顾串行连接与并行连接的优缺点。
串行连接

资源占用少
无服务器负载问题
超时选择困难
最慢可用

并行连接

网络资源竞争
服务器负载高
最快可用

那么，有没有一种策略，能同时满足高性能、高可用、低负载的目标呢？在微信的连接设计中，我们使用了”复合连接“的策略。如下图所示。

初始阶段，应用发起对   的  调用。在第秒的时候，如果第一个  还没有返回，则发起对   的  调用。以此类推，直至发起了组  的  调用。对比串行连接与并行连接，复合连接有以下特点：

常规情况下，服务器负载与串行连接策略相同，实现了低负载的目标；
异常情况下，每发起新，组合的  调用，使得应用可以快速的查找可用 ，实现高性能的目标；
在超时时间的选择上，复合方式的“并发”已经实现了高性能、低负载的目标，因此在超时时间的选择上可以相对宽松，以保障高可用为重。

综合对比，复合连接能够维持低资源消耗的情况下，能同时实现低负载、高性能、高可用的目标。
微信  排序算法的演进
在建立连接的调用中，除了超时时间的设置外，是连接的最重要参数。 的排序、选择对于  的性能也是有着重大的影响。本节主要讨论在已知  列表、 列表的情况下，如何排序、组合的问题，而不讨论如何获得就近接入等问题。
 的组成
在微信中，有多种来源类型。优先级从上而下分别为：

 
 
 
 

  是通过微信自建的  服务获得的列表，自建  对防劫持、有效期控制等有重要作用。  则是通过常规的  解析获得的  列表。  是微信动态下发的保底列表。而  则是最终的保底列表。总体而言，分为常规列表、保底列表两个类别。 、  为常规列表， ，  为保底列表。同时，在组成实际使用的  列表时，由于  与  的功能近似，因此通常只出现其中一种类型的列表。  与  的功能近似，也是同时只能出现两者中的一种类型。 
在  的选择上，微信服务在常规情况下提供个端口，预防端口被封锁的情况。特别情况下，可以通过配置下发进行端口更新。
排序算法一：随机组合排序算法
每个连接都是以  的组合为唯一标识。在  的选择上，我们初步归纳为个目标：

高可用：尽快的找到可用的  资源
高性能：优先使用质量好的 
负载均衡：的排序算法不带任何偏向因子，避免造成人为的负载不均衡

在微信早期的排序选择上，我们使用了一种随机组合的排序算法。即将     列表与  列表进行组合，组合后的结果进行随机排序。在随机排序的结果列表中，使用下述步骤进行排序：

选取；
选取，尽量使得与不相等，与不相等；
选取，尽量使得与、都不相等，与、都不相等；
以此类推，形成常规列表。

同理，使用      列表与  列表的组合，我们按照相同算法生成另外一份保底列表，并将保底列表排序在常规列表的后面，从而组成完整的  列表。随机组合排序的算法有着以下的特点：

高性能：每一次尝试都尽量使用完全不同的资源，使得能最快的发现可用资源；
初始随机，从而避免列表顺序的固化；
保底列表在最后，形成最后的保护屏障；
在不同的网络下，维护着不同的资源列表。

在使用中，如果发现  访问失败，则在列表中  掉该资源。这里有个小优化，即当  的上一次访问成功时，需要连续失败次才  该资源。目的是为了减小偶然的网络抖动造成的影响。
随机组合排序算法的设计初衷，是为了以最快的速度尝试不同的资源组合，从而快速寻找到可用的资源。然而，在微信的实际使用中，却发现这种算法存在着诸多的问题。例如：

网络不可用或网络较大波动情况下，列表被的速度较快；
     列表太容易被访问到：随着常规资源陆续被，保底资源总是会被访问到，造成对保底资源的访问量大。保底资源是为了微信服务这不符合保底资源的设计初衷。
当引入复合连接策略后，资源不足。这是因为  的策略简单粗暴的丢弃失败的 ，导致  资源越来越少；
每次缓存超时或列表轮空后，对于新列表没有经验信息可用

在随机组合排序算法的基础上，为了解决遇到的新问题，微信使用了新的“以史为鉴”的算法。
 排序算法二：以史为鉴
由于复合连接的引入，在每次复合连接的尝试中，微信可以伪“并发”的对个  进行 微信中目前=。简单的丢弃的策略会使得  资源越来越少。 针对这个特点，我们对算法进行了以下修改：

初始资源列表分为两类列表：常规列表，保底列表，分别使用方案一随机组合排序算法生成初始顺序；
对每次复合连接使用的列表，规定个资源的组成是个常规资源个保底资源，并且保底资源在最后完全无法获取常规资源的情况除外。这种资源组成方式一方面解决了“保底资源太容易被访问到”的问题，一方面也保障了保底资源的作用；
在不同网络中，分别记录每个  的使用情况，并根据使用记录进行评分、排序；
区分连续记录：对每个  的更新，秒内的连续成功或失败，不进行使用情况的记录。这种处理方式一方面是为了避免网络不可用或网络出现较大波动时，资源被过快的错误标记；一方面也避免失败历史被快速的覆盖；
最近的条使用记录中，如果有超过条失败记录，且最新一次失败记录时间为分钟内，则本次排序该记录。这种处理方式的目的是避免历史分数较高的  在突然出现故障时很难被排序算法排除的问题；
无历史的记录使用随机评分排序。

通过上述方法，我们保证了保底资源不会被轻易访问到，解决了列表被快速标记的问题，同时也保证了历史记录好的资源在出现故障时也能被快速替换。
 排序算法三：遗忘历史
“以史为鉴”的方案在微信中使用了一段时间，看起来运行良好。直至某一天，微信的部分服务集群出现了故障。虽然微信客户端快速的切换到可用的服务器资源，但当故障服务器恢复后，微信客户端却迟迟没有分流到已恢复服务的集群，导致部分微信服务器负载过高，而部分微信服务器却负载较低的情况。通过分析，发现“以史为鉴”的排序方案存在着一些问题：

初始阶段排在前面的资源容易获得较多的成功记录，从而分数始终维持在较高的水平；
出灾情况下，故障机器由于有失败记录，使得很难获得“被原谅”的机会，从而也很难更新使用历史；
采用了无历史记录随机评分，破坏了原有的“相邻记录尽量不相同”的随机性设计；

因此，好的  排序算法，不仅应该快速的发现可用的资源，使得在出灾情况下能快速的响应，同时，也应该具备一定的“遗忘性”、“容灾性”，使得灾情恢复后能较快的发现“灾情恢复”这一事实，并且进行重排序，使得服务器资源得到更合理的使用。在综合考虑“以史为鉴”和“遗忘历史”后，新的 方案具有以下特征：

内存历史、文件历史双层记录历史：反映资源使用的近期情况及历史情况；
初始化状态：每次进程重启或网络切换后，从文件历史中“压缩”出内存历史作为初始状态；
旁路检测：额外更新历史的渠道，更有助于挑选高性能的资源，并且帮助“灾情恢复”的资源获得使用的机会；
文件历史的遗忘性：文件历史每小时强制刷新，避免高分数的记录长期“占有”队列；
无历史、有历史的混合排序。

具体实现查看  源代码中的 __。
总结
连接是信令传输的前提，一个简单的连接操作蕴含着不少的优化空间。在连接超时的选择上，我们要兼顾性能与可用性，过短的连接超时可能导致弱网络下的低可用性，但过长的连接超时又影响用户体验。在  中，我们结合系统本身的  连接重传特性，进行了相应的设计考量。即使如此，串行的连接方案仍然不能满足高性能的需求。并发连接的方案获得高性能的同时，也带来了服务器负载剧增的损失。综合考虑下， 使用了“复合连接”的方案，获得高性能的同时，也保证通常情况下的服务器低负载。
 是连接的最重要资源， 的排序选择是连接过程的重要部分。在微信的实际使用中，我们依次使用了“随机组合”、“以史为鉴”、“遗忘历史”三种方案，综合的考虑了查找性能、移动互联网的不稳定性、容灾及容灾恢复等。
连接超时、连接策略及  排序是连接的是三个重要组成部分，相关的方案也随着微信实践在不断的发展中。相信在不同的应用场景中，我们可能会遇到更多的不同问题及需求。随着的开源，也能有机会参考、吸收其他应用中的实战经验，使得网络优化持续的深入。
关注 ，来  给我们  吧

本文来源于： 微信公众号

相关推荐微信终端跨平台组件  系列一：高性能日志模块微信终端跨平台组件  系列二：信令传输超时设计导语   腾讯社交与效果广告广点通定向团队在年底开始调研探索  技术，技术构架经历了若干个阶段。本文先简单介绍 的背景，然后介绍我们各个阶段使用的算法框架。

抱歉，一些公式的格式我怎么调也调不好。大家细心一些根据上下文看，应该能看懂。
摘要
相似受众定向 定向，简称为在近年来逐渐成为各大广告系统的必备功能。通过 ，广告系统可以根据上传或指定的一个高质量人群计算出与他们相似的人群前者称为种子，后者称为扩展人群。考虑到新客户与现有客户具有类似特征，对扩展人群投放广告能有效帮助广告主拓展业务和发掘新客户。
因为篇幅原因，本文不包含过多技术和业务数据，工程上的实现和  也不展开。
简介
我们知道，广告系统几乎都有以下定向方式：人口学，地域，兴趣，行为，再营销。那么如果没有，广告主只能使用这些定向投放广告。这样至少有两个问题：第一，广告主可能会陷入大量的定向条件试错，才有可能找到合适的定向方式；第二，可能现有标签都不能满足广告主的需求。
对于广告平台也有问题，各种   广告主总有自己的诉求，标签的定制化、个性化需求永远是无穷尽的。而标签挖掘的成本高、周期长，需要挖掘、内测、调优、开发上线等步骤。
只需要广告主指定种子，系统会自动发现种子的相似人群，既省去了定向条件的试错，也规避了自定义标签的问题。
举个例子，如果广告主提供的种子人群是持有某种信用卡的客户，那么相似人群也在某些方面和持有这个信用卡的客户相似。如果相似人群没有持有卡，那么他们也是很有可能去开卡的。这样，显式选择定向条件和标签不够丰富的问题， 可以简单、直接的解决。
也并非完美，与显式标签相比它的直观程度低一些。
在不同的广告系统中， 有不同的名字，比如       粉丝爆炸器等。业界最大的两个广告公司  和的技术细节并没有公开，只能从产品形态上进行揣测。但总结起来， 无外乎有这么几种做法或者它们的组合：用户分类，协同过滤，用户聚类，特征选择等。
第一阶段：探索中的
广点通定向团队在年启动了 技术的探索。
第一版 使用了大规模分布式 系统 – 。

通过对 矩阵分解，我们得到了 矩阵。

用户  和种子  的相似度如下定义其中  是用户的 分布， _ 是种子用户  的分布：

其中  ，即种子中每个用户的平均  分布，很自然的可以认为是种子集合  的  向量。因此，遍历全部人群，计算出每个用户与种子集合的相似度，取排序较高的即是扩展人群。
这个方法的内测效果仅略好于随机定向，不能让人满意。我们又尝试了基于关系链的 。这个方法利用共同好友信息，直觉是共同好友越多，两个人有相同兴趣、属于同一圈子的概率越大。

用户  和种子人群  的相似度如下定义：

遍历全部人群，计算出所有用户的相似度，取   即是扩展人群。
这种方法也没有取得好的结果。之前的直觉是禁不住推敲的。例如，我和我的某个大学同学有很多共同好友，但我们只有在所学专业上有共同点、年龄相仿，此外几乎找不到共同点。
通过尝试，我们也得到了一个宝贵的经验：在  任务上，无监督的方法效果不如有监督的好。而后面的事实也证明了这点，想到使用有监督模型，就已经离成功不远了。
第二阶段： 
年，我们尝试了用有监督的方法做 。我们将种子作为正例，将随机用户进行降采样后作为负例，为每个种子训练一个   模型。用这个模型在全部用户上预测，我们认为预测概率值越大，越和种子相似。

用户  和种子  的相似度这样定义其中  是用户特征向量， 和  是  模型的参数：

遍历全部人群，计算出所有用户的相似度，取   即是扩展人群。
有了原型算法，我们先后在购物行为定向和商业兴趣定向上做了实验，同时邀请了若干广告主进行内测，得到了大量的正向反馈。随后，  很自然的完成工程开发并上线。
在工程实现中，一个扩展人群的形式是这样的：
 =   
为了在线使用，将他们系统所有的扩展人群建立倒排索引，形式如：
 =    

 =     

 =    
  系统从年服务到了年中。随着广告主使用增加，系统的弊端逐渐暴露出来：倒排索引占用空间不断上涨，导致索引更新周期过长，每个用户身上的  也不得不按照相似度截断，而这种截断会加剧马太效应，对广告主扩展新用户不利。同时，离线模型训练和预测的机器也在不断增加。
  系统可以支撑至万级别的广告 年的公开资料表明，他们的 只支撑了 广告。若要支持万级别广告，倒排索引存储、离线训练和预测的机器使用不可接受。
因此，  本身的缺陷阻碍它进一步推广。
第三阶段：
了解到了  扩展性差的原因，我们尝试着抛弃完整的倒排索引，抛弃每个种子一个模型的思路。
在考虑离线模型训练扩展性，倒排索引容量和性能等因素的前提下，我们经过反复推敲，反复思考与实验检测各个模块的可行性，提出了第三代的 –  。
首先，直接上干货，我们的模型网络结构是这样的：

与   不同的是，上图的模型将对所有种子建模。每条训练样本由部分组成：

用户特征 
 
标签  

用户特征  经过    后，将  中的非零项对应的  取出求平均，得到 。  只有一个，直接从     中取出对应 。得到   和   后，对这两个求内积，继续通过  函数向前传播，最后使用 和输出概率之间的  作为损失函数。
有了 ，我们可以计算出全量用户的  ，将这些数据写入正排索引供线上查询。注意到  的规模和用户数量成正比，和种子数量无关。
有了  ，将他们加载到定向服务器万个 只有几十 。
在线召回广告的过程如下：从正排索引取到  ；  矩阵–   向量做乘法，得到  和每个广告的相似度；根据每个广告扩展倍数的阈值截断；随机保留  个 ，将它们对应的广告召回。

当  维度为，广告为万时，使用高性能  计算库，第一步矩阵向量乘法的性能没有任何问题。随机保留广告的过程，可以缓解马太效应，提升广告主的收益。由于整个召回过程是在服务器实时计算得到，所以我们叫它  。
年月，我们完成了  对   的全量替换。
未来工作
模型。刻画用户特征的子网络可以走的更深：加入多层全连接，捕捉非线性关系。同时   的子网络可以加入种子的信息图中未画出。

特征。加入更具有区分度的特征。
模型训练。随着  广告的增加，训练系统需要超强的能力来处理上百 的训练数据。潜在的方案是：分布式训练； ；正负例共享等。
在线召回。当 广告超过万后，目前的性能满足不了要求时，可以使用若干方法：  矩阵分 ；使用；使用 或  近似快速计算向量相似度。
总结
  使用一个神经网络将用户和广告均压缩到了一个低维  向量空间，使得在线计算成为了可能。在线计算相似度并扩展，只需要存储常量容量的  和 少量的 。“所有种子一个模型”比“每个种子一个模型”更具有扩展性。“在线随机截断”比“离线按概率截断”，缓解了马太效应，提升了广告主的收益。  支持万级别广告，是目前已知最具有扩展性的 构架。、简介
通过内核虚拟化技术及等来提供容器的资源隔离与安全保障等，由于通过操作系统层的虚拟化实现隔离，所以容器在运行时，不需要类似虚拟机额外的操作系统开销，提供资源利用率。
、  


、组件
镜像、容器、仓库
、安装
   

= 
=
=
=
=

     
、基础操作
    
     
    
  
      拉取镜像
    
有时候拉取速度很慢，采用国内源加速
   
增加下面这行
=
新建配置文件
   
在   注册，然后点击加速器生成加速链接
==  _ |   
      搜索镜像

    

                                                     

                                                
导出镜像
      
      
导入镜像
      或者      
删除镜像
     镜像
       
 
    
                                                                                           
                                                               _

         
  

   
                           
                             
                             

  

    
                                                                                            
                                                                        
                                                              _

            代表放入后台执行

    
                                                                                            
                                                                       
                                                                        
                                                              _

        停止容器
       启动容器

       

  
   
                                                                                            
                      
                    


进入容器
   _ 


_{

  _=
  =   {{  }} _
         

}


_ 
、网络
        


    
                                                                                                                        
                                        

   | 
                                                          

    
  
 
      
 
 
      
 
 
 
转换前
    
   
                               
                                  
                               
                                
                                    
                                  

   
                               
                             
                                
                                  
                                
                                
                                  

   
                               

   
                               

   
                               
                     
转换后
        

    
                                                                                                                        
                                        
    
   
                               
                                  
                               
                                
                                    
                                  

   
                               
                             
                                
                                  
                                
                                
                                  

   
                               

   
                               
                                 
                                 

   
                               
                                

   _ 
 
 
  
  _         
       
        
       _  _ 
        
       _  _ 
  _         
       
        
       _  _ 
        
       _  _ 
、数据存储
         


   _ 
  
 
  
        
 
        

   
  
 
        
        
        
        
        
        
        
        
   
  
  
   
  
_
   _    容器内的文件实际在物理机上面的的保存目录
 _ 


            


   表示把物理机的目录挂载到容器内的目录下面


         


  
         

  
         


相关推荐
如何搭建及使用 在腾讯云服务器上体验我们知道对于有过反编译经验的同学分分钟把正常的安卓程序源代码搞出来。一直也在寻找此类服务，之后发现腾讯云上有一个叫乐固的服务，支持反破解反调试反窃取防篡改防二次打包 兼容至  任何安卓系统 兼容系统，重要的是免费的，支撑的团队响应速度也很及时拖入专项问题讨论组乐固团队人员帮你处理，这个太佩服，效率绝对的高。
前序：准备好之前已经签名好的产品。
首先找到云产品里找到应用乐固的服务。

进入以后
选择好我们的文件。

等到上传完毕以后：
 
提交，系统就会自动进行加固。

下载加固包。

会提示：

此时，如果没有下载签名工具，就先下载签名工具，如果已经下载好了 就点击 “继续下载加固包”。

这是一个已经加固，但是没有签名的包。需要我们重新用我们自己的签名和密码重新打包签名一下。
包签名
 首先下载好乐固提供的自助加固工具。

正常情况下打开根目录的。 

插曲：我的当时打不开，应该是权限问题，我直接找到\\
我们选择辅助工具：

原包：就是我们下载的加固包
输出路径：选择一个目录然后，程序会把签名好的生成在这里
下面、密码别名等就把我们生成签名的数据填写上
点击立即签名 完成加固。

实践是检验真理的唯一标准
我不相信任何吹嘘，验证一下是否可行。
用工具尝试还原代码，已经失败了。

目录结构是混淆后的了

目前我们这边正式产品已经使用上，表现良好兼容性也很强。

相关推荐动态库压缩壳的实现编译的原理解析和打包分析
移动安全一站式解决方案本文结构：


建立模型


昨天只是用了简单的  做数字识别，准确率为 ，这个太低了，今天用  来提高一下准确率。
关于 ，可以看这篇：
图解何为
简单看一个典型的   由若干组 －－ 层组成。

这三层可以提取出有用的 ，但它们并不知道这些  是什么。所以接着是   层，它可以对数据进行分类。

在  中有几个重要的概念：





，就是每跨多少步抽取信息。每一块抽取一部分信息，长宽就缩减，但是厚度增加。抽取的各个小块儿，再把它们合并起来，就变成一个压缩后的立方体。
，抽取的方式有两种，一种是抽取后的长和宽缩减，另一种是抽取后的长和宽和原来的一样。
，就是当跨步比较大的时候，它会漏掉一些重要的信息，为了解决这样的问题，就加上一层叫，事先把这些必要的信息存储起来，然后再变成压缩后的层：
即  层是用来降维的。经过  和  的作用后，会有越来越复杂的形式，所以 层负责提取出最重要的 ，进而提高时间空间的效率。

，就是小方块的长宽的像素，  是的厚度为， 是输出的厚度为

模型
主要就是建立  组 － 层，全连接层，加  减小过拟合，得到预测值 _：

每一层建立  和 ，
和上一层的输出值经过  作用后，应用  激活函数，
再做  后得到的输出值传递给下一层


 和注释：
   
   _
     
 = ____ _=

 __ _
     
    _ =  _={ _ _ }
    _ = _ _
     = __ 
     =  _={ _  _ _ }
     

 产生随机变量，符合  分布
 传递  就可以返回和的变量
 _
     = _ =    
                                 

 _
     =  =
     

 定义维的  图层
  
       _ _ 
        =  = 
      就是跨多大步抽取信息
       =    =        

 定义  图层
 __
       _ _ 
     用对付跨步大丢失信息问题
     _ = = =        

      
 =             ＝
 =   
_ = 
_ =                  最后一个表示数据是黑白的
 _   _ 

    
  把_的厚度加厚变成了
_ = _                            
_ = _
 构建第一个层，外面再加一个非线性化的处理
_ = _ _  _                
 经过后，长宽缩小为
_ = ___                                        

    
 把厚度加厚变成了
_ = _                           
_ = _
 构建第二个层
_ = _ _  _                
 经过后，长宽缩小为
_ = ___                                        

    
 飞的更高变成
_ = _ 
_ = _
 _     _ 
 把后的结果变平
__ = _  
_ = __ _  _
__ = _ _

    
 最后一层，输入，输出 ，用  计算概率进行分类的处理
_ = _ 
_ = _
 = __ _  _


       
_ = __  
                                              _=        
_ = _

 = 
  
__

   
    _ _ = _
    _ _={ _  _ _ }
        == 
        _
             
学习资料：_前言
系统给我们提供了一种可以发送格式化数据流的通信手段，这就是消息队列。使用消息队列无疑在某些场景的应用下可以大大减少工作量，相同的工作如果使用共享内存，除了需要自己手工构造一个可能不够高效的队列外，我们还要自己处理竞争条件和临界区代码。而内核给我们提供的消息队列，无疑大大方便了我们的工作。
环境提供了和两套消息队列，本文将帮助您掌握以下内容：
如何使用消息队列。如何使用消息队列。它们的底层实现分别是什么样子的？它们分别有什么特点？以及相关资源限制。
消息队列
系统提供了四个方法来操作消息队列，它们分别是：
 
 
 

 _   

      _   

_     _     

      _ 
我们可以使用去创建或访问一个消息队列，与其他 一样，使用一个作为创建消息队列的标识。这个可以通过生成或者指定为_。指定为_时，此队列会新建出来，而且内核会保证新建的队列不会与已经存在的队列冲突，所以此时后面的应指定为_。当指定为_时，会去试图创建一个新的消息队列，除非指定的消息队列已经存在。可以使用_ | _在指定已经存在的情况下报错，而不是访问这个消息队列。我们来看创建一个消息队列的例子：
   _
 
 
 
 
 

  
  

 
{
     
    _ 
     _ _

     =  
      ==  {
        
        
    }

     =  _|_|
      ==  {
        
        
    }

      _ _ ==  {
        
        
    }

     \ 
    _ \ __
    _ \ __
    _ \ __
    _ \ __
    _ \ __
    _ \ __
}
这个程序可以创建并查看一个消息队列的相关状态，执行结果：
  _ 
 
_ 
_ 
_ 
_ 
_ 
_ 
如果我们在次执行这个程序，就会报错，因为没有变化，我们使用了_|_，所以相关队列已经存在了就会报错：
  _ 
  
顺便看一下方法，我们可以用它来取一个消息队列的相关状态。更详细的信息可以  查看。除了查看队列状态以外，还可以使用设置相关队列状态以及删除指定队列。另外我们还可以使用 命令查看系统中消息队列的相关状态。其他相关参数请参考 。
使用和向队列发送和从队列接收消息。我们先来看看如何访问一个已经存在的消息队列和向其发送消息：
   _
 
 
 
 
 
 

  
  
   

  {
     
     
}


 
{
     
    _ 
      

     =  
      ==  {
        
        
    }

     =  
      ==  {
        
        
    }

     = 
      
         ==  {
        
        
    }
}
使用访问一个已经存在的消息队列时，指定为即可。使用发送消息时主要需要注意的是它的第二个和第三个参数。第二个参数用来指定要发送的消息，它实际上应该是一个指向某个特殊结构的指针，这个结构可以定义如下：
  {
     
     
}
这个结构的实际上是用来指定消息类型的，可以指定的数字必需是个正整数。我们可以把这个概念理解为消息队列对消息优先级的实现方法，即：需要传送的消息体的第一个长度是用来指定类型的参数，而非消息本身，后面的内容才是消息。在我们实现的消息中，这个结构题可以传送的最大消息长度为的字节数。当然，如果你的消息并不是一个字符串，也可以将后面的信息实现成各种需要的格式，比如想要发送一个人的名字和他的数学语文成绩的话，可以这样实现：
  {
     
     
      
}
这实际上就是让使用者自己去设计一个通讯协议，然后发送端和接收端使用约定好的协议进行通讯。的第三个参数应该是这个消息结构体除了以外的真实消息的长度，而不是这个结构题的总长度，这点是要注意的。所以，如果你定义了一个很复杂的消息协议的话，建议的长度写法是这样：

的最后一个参数可以用来指定_。在消息队列满的情况下，默认的发送行为会阻塞等待，如果加了这个参数，则不会阻塞，而是立即返回，并且设置为。然后我们来看接收消息和删除消息队列的例子：
   _
 
 
 
 
 
 

  
  

  {
     
     
}


 
{
     
    _ 
      

     =  
      ==  {
        
        
    }

     =  
      ==  {
        
        
    }

          ==  {
        
        
    }

     \ 
     \ 

      _  ==  {
        
        
    }

    
}
会将消息从指定队列中删除，并将其内容填到其第二个参数指定的地址所在的内存中。第三个参数指定承接消息的长度，如果消息内容长度大于指定的长度，那么这个函数的行为将取决于最后一个参数是否设置了_，如果这个标志被设定，那消息将被截短，消息剩余部分将会丢失。如果没设置这个标志，会失败返回，并且被设定为。
第四个参数用来指定从消息队列中要取的消息类型，如果设置为，则无论什么类型，取队列中的第一个消息。如果值大于，则读取符合这个类型的第一个消息，当最后一个参数设置为_的时候，是对消息类型取逻辑非。即，不等于这个消息类型的第一个消息会被读取。如果指定一个小于的值，那么将读取消息类型比这个负数的绝对值小的类型的所有消息中的第一个。
最后一个参数还可以设置为：
_：非阻塞方式读取。当队列为空的时候，会阻塞等待。加这个标志后将直接返回，被设置为。
_：从 之后开始支持以消息位置的方式读取消息。如果标志为置为_则表示启用这个功能，此时的含义将从类型变为位置偏移量，第一个消息的起始值为。如果指定位置的消息不存在，则返回并设置为。并且_和_不能同时设置。另外还要注意这个功能需要内核配置打开__选项。这个选项默认应该是不开的。
使用删除消息队列的方法比较简单，不在复述。另外关于的其他使用，请大家参考的手册。这部分内容的另外一个权威参考资料就是《环境高级编程》。我们在这里补充一下系统对消息队列的限制相关参数介绍：
：这个文件限制了系统中单个消息最大的字节数。
：这个文件限制了系统中可创建的最大消息队列个数。
：这个文件用来限制单个消息队列中可以存放的最大消息字节数。
以上文件都可以使用或者命令进行修改。
消息队列
消息队列是独立于消息队列的一套新的消息队列，让进程可以用消息的方式进行数据交换。这套消息队列在 版本之后开始支持，还需要你的版本必须高于。它们使用如下方法进行操作和控制：
              _  
             
 

_ _    
_ _     _   _ 
类似对文件的，我们可以用_来打开一个已经创建的消息队列或者创建一个消息队列。这个函数返回一个叫做_类型的返回值，其本质上还是一个文件描述符，只是在这这里被叫做消息队列描述符  ，在进程里使用这个描述符对消息队列进程操作。所有被创建出来的消息队列在系统中都有一个文件与之对应，这个文件名是通过参数指定的，这里需要注意的是：必须是一个以”“开头的字符串，比如我想让消息队列的名字叫””，那么应该给的是””。消息队列创建完毕后，会在目录下产生一个以命名的文件，我们还可以通过这个文件来看这个消息队列的一些状态信息。其它进程在消息队列已经存在的情况下就可以通过_打开名为的消息队列来访问它。
 __    _ _ _   _

 __    _ _ _   _    _

_ __   _ _ _   _

_ __   _ _ _   _    _
在一个消息队列创建完毕之后，我们可以使用_来对消息队列发送消息，_来对消息队列接收消息。正常的发送消息一般不会阻塞，除非消息队列处在某种异常状态或者消息队列已满的时候，而消息队列在空的时候，如果使用_去试图接受消息的行为也会被阻塞，所以就有必要为两个方法提供一个带超时时间的版本。这里要注意的是_这个参数，是用来指定消息优先级的。每个消息都有一个优先级，取值范围是到____  的大小。在上，这个值为。默认情况下，消息队列会先按照优先级进行排序，就是_这个值越大的越先出队列。同一个优先级的消息按照原则处理。在_方法中的_是一个指向的地址，它并不是用来指定取的消息是哪个优先级的，而是会将相关消息的优先级取出来放到相关变量中，以便用户自己处理优先级。
 __ 
我们可以使用_来关闭一个消息队列，这里的关闭并非删除了相关文件，关闭之后消息队列在系统中依然存在，我们依然可以继续打开它使用。这跟文件的和的概念是类似的。
 _  
使用_真正删除一个消息队列。另外，我们还可以使用_和_来查看和设置消息队列的属性，其函数原型为：
 __   _ 

 __    _   _ 
_结构体是这样的结构：
 _ {
     _        只可以通过此参数将消息队列设置为是否非阻塞_ 
     _       消息队列的消息数上限 
     _      消息最大长度 
     _      消息队列的当前消息个数 
}
消息队列描述符河文件描述符一样，当进程通过打开一个子进程后，子进程中将从父进程继承相关描述符。此时父子进程中的描述符引用的是同一个消息队列，并且它们的_参数也将共享。下面我们使用几个简单的例子来看看他们的操作方法：
创建并向消息队列发送消息：
   
 
             
 
 
 
 
 

  


    
{

    _ 
     

      =  {
          \
        
    }

     = _ _|_  
      ==  {
        _
        
    }

     = _   
      ==  {
        _
        
    }

    
}
注意相关方法在编译的时候需要链接一些库，所以我们可以创建来解决这个问题：
    
= 
我们添加了和库，为以后的例子最好准备。当然大家也可以直接使用  来解决这个问题，然后我们对程序编译并测试：
   
   
          
    
    
    
    
    
    
我们以不同优先级给消息队列添加了几条消息。然后我们可以通过文件来查看相关消息队列的状态：
    
                   _
然后我们来看如何接收消息：
   
 
             
 
 
 
 
 

  


 
{

    _ 
     
     
     

     = _ _
      ==  {
        _
        
    }

     = _   
      ==  {
        _
        
    }

     = _
      ==  {
        _
        
    }

       \  

    
}
直接编译执行：
   
   
   
   
   
   
   
   
   
   
   
   
可以看到优先级对消息队列内部排序的影响。然后是删除这个消息队列：
    
 
             
 
 
 
 
 

  


 
{

     

     = _
      ==  {
        _
        
    }

    
}
大家在从消息队列接收消息的时候会发现，当消息队列为空的时候，_会阻塞，直到有人给队列发送了消息才能返回并继续执行。在很多应用场景下，这种同步处理的方式会给程序本身带来性能瓶颈。为此，消息队列使用_为处理过程增加了一个异步通知机制。使用这个机制，我们就可以让队列在由空变成不空的时候触发一个异步事件，通知调用进程，以便让进程可以在队列为空的时候不用阻塞等待。这个方法的原型为：
 __     
其中用来想内核注册具体的通知行为，可以  查看相关帮助。这里我们不展开讲解，详细内容将在信号相关内容中详细说明。简单来说，我们可以使用_方法注册种行为：_，_和_。它们分别的含义如下：
_：一个“空”提醒。其实就是不提醒。
_：当队列中有了消息后给调用进程发送一个信号。可以使用 结构体中的_指定信号编号，信号的_字段将设置为_以标示这是消息队列的信号。还可以通过_和_来指定信号来自什么和什么。
_：当队列中有了消息后触发产生一个线程。当设置为线程时，可以使用 结构体中的__指定具体触发什么线程，使用__设置线程属性，使用__传递一个任何东西的指针。
我们先来看使用信号的简单例子：
   _
 
 
 
 
 
 

 _ 

 __ _
{
     __是信号处理函数，
    当队列从空变成非空时，会给本进程发送信号，
    触发本函数执行。 

     _ 
     
    _ 
     
      

     我们约定使用信号进行处理，
    在此判断发来的信号是不是。 
     _ =  {
        
    }

     取出当前队列的消息长度上限作为缓存空间大小。 
     _    {
        _
        
    }

     = _
      ==  {
        
        
    }

     从消息队列中接收消息。 
     = _  _ 
      ==  {
        _
        
    }

     打印消息和其优先级。 
       \  

    

     重新注册_，以便下次可以出触发。 
    _ = _
    _ = 
     _  ==  {
        _
        
    }

    
}

    
{
      

      =  {
          \
        
    }

     注册信号处理函数。 
      __ == _ {
        
        
    }

     打开消息队列，注意此队列需要先创建。 
     = _ _
      ==  {
        _
        
    }

     注册_。 
    _ = _
    _ = 
     _  ==  {
        _
        
    }

     主进程每秒打印一行，等着从消息队列发来异步信号触发收消息。 
      {
        \
        
    }
}
我们编译这个程序并执行：
  _ 



会一直打印，等着队列变为非空，我们此时在别的终端给队列发送一个消息：
    
进程接收到信号，并且现实消息相关内容：



   


再发一个试试：
    
显示：


   


在_的手册中，有一个触发线程进行异步处理的例子，我们在此就不再额外写一遍了，在此引用并注释一下，以方便大家理解：
   
 
 
 
 
 

 _ \
     {  _ }  

                          
  
{
     此函数在队列变为非空的时候会被触发执行 

     _ 
    _ 
     

     上一个程序时将实现成了全局变量，而本例子中使用_指针传递此变量的值 
    _  = _  _

              

     _  == 
        __
     = _
      == 
        _

     打印队列中相关消息信息 
     = _  _ 
      == 
        __

        \ 
    

     本程序取到消息之后直接退出，不会循环处理。 
    _             
}


   
{
    _ 
      

      =  {
           \ 
        _
    }

     = _ _
      == _ 
        __

     在此指定当异步事件来的时候以线程方式处理，
    触发的线程是：
    线程属性设置为：
    需要给线程传递消息队列描述符，以便线程接收消息 

    _ = _
    __ = 
    __ = 
    __ =         
     _  == 
        __

                
}
大家可以自行编译执行此程序进行测试。请注意_的行为：

一个消息队列智能通过_注册一个进程进行异步处理。
异步通知只会在消息队列从空变成非空的时候产生，其它队列的变动不会触发异步通知。
如果有其他进程使用_等待队列的消息时，消息到来不会触发已注册_的程序产生异步通知。队列的消息会递送给在使用_等待的进程。
一次_注册只会触发一次异步事件，此后如果队列再次由空变为非空也不会触发异步通知。如果需要一直可以触发，请处理异步通知之后再次注册_。
如果指定为，表示取消注册异步通知。

消息队列相对消息队列的一大优势是，我们又一个类似文件描述符的的描述符可以进行操作，所以很自然的我们就会联想到是否可以使用多路转接机制对消息队列进程处理？在上，答案是肯定的，我们可以使用、和对队列描述符进行处理，我们在此仅使用举个简单的例子：
   _
 
 
 
 
 
 
 
 

  
  


 
{

    _ 
        
     
     _  
     _  

     = _ _
      ==  {
        _
        
    }

     因为有帮我们等待描述符是否可读，所以对的处理可以设置为非阻塞 
    _ = _

     _   ==  {
        _
        
    }

     = _
        {
        _
        
    }

     关注描述符是否可读 
     = 
     = 

     = _ __  
        {
        _
        
    }

      {
         = _   
            {
             如果被信号打断则继续_ 
              ==  {
                
            }  {
                _
                
            }
        }

         此处处理所有返回的描述符虽然本例子中只有一个 
         = {
             = _   
              ==  {
                  ==  {
                    
                }
                _
                
            }
               \  
        }

    }

     恢复描述符的 
     _   ==  {
        _
        
    }

     = _
      ==  {
        _
        
    }
    
}
这就是消息队列比更有趣的地方，的消息队列并未遵守“一切皆文件”的原则。当然，使用和这里就不再举例了，有兴趣的可以自己实现一下作为练习。
以上例子中，我们也分别演示了如何使用_和_，此处我们应该知道，在所有可以显示的属性中，_是_唯一可以更改的参数设置，其他参数对于这个方法都是只读的，不能修改。系统提供了其他手段可以对这些限制进行修改：
_：在_的参数设置为的时候，这个文件中的数字限定了_的值，就是队列的消息个数限制。默认为个，当消息数达到上限之后，再使用_发送消息会阻塞。
_：可以通过_的参数设定的_的数字上限。这个值默认也是。
_：在_的参数设置为的时候，这个文件中的数字限定了_的值，就是队列的字节数数限制。
_：可以通过_的参数设定的_的数字上限。
_：系统可以创建的消息队列个数上限。
最后
希望这些内容对大家进一步深入了解的消息队列有帮助。如果有相关问题，可以在我的微博、微信或者博客上联系我。

大家好，我是！
如果你喜欢本文，欢迎在微博上搜索“”关注我，地址是：
大家也可以在微信上搜索：系统技术 关注我的公众号。
我的所有文章都会沉淀在我的个人博客上，地址是：。
欢迎使用以上各种方式一起探讨学习，共同进步。背景
针对昨日英国医院被攻击，随后肆虐中国高校的  勒索事件，腾讯安全反病毒实验室第一时间给出了深度权威的分析。此次勒索事件与以往相比最大的亮点在于，勒索病毒结合了蠕虫的方式进行传播，传播方式采用了前不久  被泄漏出来的  漏洞。在  泄漏的文件中， 传播方式的漏洞利用代码被称为，所以也有的报道称此次攻击为永恒之蓝。
 漏洞指的是，攻击者利用该漏洞，向用户机器的  端口发送精心设计的网络数据包文，实现远程代码执行。如果用户电脑开启防火墙，也会阻止电脑接收  端口的数据。但是在中国高校内，同学之间为了打局域网游戏，有时需要关闭防火墙，这也是此次事件在中国高校内大肆传播的原因。
攻击流程

勒索病毒被漏洞远程执行后，会从资源文件夹下释放一个压缩包，此压缩包会在内存中通过密码： 解密并释放文件。这些文件包含了后续弹出勒索框的 ，桌面背景图片的 ，包含各国语言的勒索字体，还有辅助攻击的两个  文件。这些文件会释放到了本地目录，并设置为隐藏。

其中 就是后续弹出的勒索窗口。

窗口右上角的语言选择框，可以针对不同国家的用户进行定制的展示。这些字体的信息也存在与之前资源文件释放的压缩包中。

通过分析病毒，可以看到，以下后缀名的文件会被加密：。

以图片为例，查看电脑中的图片，发现图片文件已经被勒索软件通过   进行  的组合加密。并且后缀名改为了

此时如果点击勒索界面的 ，会弹出解密的框。

但必须付钱后，才可以解密



。
作者目前是通过这三个账号随机选取一个作为钱包地址，收取非法钱财。
防范建议
利用  系统远程漏洞进行传播，是此次勒索软件的一大特点，也是在高校爆发的根本原因，所以开启防火墙是简单直接的方法。下面以  通过图例简单介绍一下，如何关闭  端口。
 打开控制面板点击防火墙

 点击高级设置

 先点击入站规则，再点击新建规则

 勾中端口，点击协议与端口

 勾选特定本地端口，填写 ，点击下一步

 点击阻止链接，一直下一步，并给规则命名后，就可以了。

另外，也可以通过升级微软补丁来阻止攻击。
：腾讯科技近日，正式对外宣布第二批媒体融合云项目开启，该项目作为媒体融合的底层支撑系统，共包含私有云平台、云存储、微服务三大组件。该项目将支撑媒体融合项目产品的开发，推进媒体向商业化发展进程，并加快传统媒体向新媒体转型速度。
时至今日，新的信息技术革命，改变了人们的生产生活方式，技术创新也成为媒体发展的核心动力，促使着媒体行业向泛媒体时代变革。随着搜索、智能推送等技术的出现，媒体用户的阅读习惯、媒体业务格局均出现改变。
如何在新的技术环境下，借助自身电视平台和网络平台的双平台的优势，创新服务理念，为用户贴身定制多样性，全方位的网络视听互动服务，是最为关心并迫切要解决的问题。

以创造性应对趋势变化
从技术发展的趋势来看，以人为本、不断满足人的需求将是媒体技术发展的必然走向，也是其重要价值之所在，人性化追求为大势所趋，媒体在满足人们新闻信息需求的同时，更要让自身传播习惯符合用户的使用习惯及需求，为受众提供个性化服务。
在互联网的大环境下，以参与式电视体验为产品理念，在对传统电视节目资源再生产、再加工以及碎片化处理的同时，着力打造网络原创品牌节目，鼓励网友原创和分享。注重用户体验，不断完善服务体系，让网友在轻松体验高品质视听服务的同时，更多的参与到网络互动中来。首期上线的内容包括首页、客户端、新闻台、体育台、综艺台、爱西柚播客台及爱布谷搜视台。从年开始，中国网络电视台还陆续上线包括电影、电视剧、纪录片、财经、探索、健康、气象、家居、旅游、教育、民族、音乐等系列内容服务。在互联网信息时代，为用户贴身定制多样性，全方位的网络视听互动服务。
作为文化产业的重要组成部门，立志推动自身在内容、渠道、平台、经营、管理等方面的深度融合，着力打造新型主流媒体形式。从单纯的“内容制作机构”升级为内容制作、运营、分发的智能化平台；兼顾多种业务形态、多种传输网络、多种服务模式、多种终端制式和跨网联动、多屏互动需求；不仅能使受众获得信息，还能通过对信息的筛选分析进行重新组合，并将准确信息传递给特定人，为人们提供有效、即时、个性化的信息服务。
在融合的前提下，基础设施便显得尤为重要，如何提升自身基础设施，更好的为融合云服务呢？就现有需求，大胆选择了以开源云平台，技术自面市至今，不过短短年的时间，已经被国内外金融、医疗、电信、政府军工等行业、机构采用，是当前认可度最高的云技术之一。
用开源云平台支持媒体融合建设各业务的底层计算、存储等服务，不仅满足了对系统高可靠和易用性的要求，更简化了运维流程，提升了业务上线效率，加快了业务的更新速度。为内容运营、分发以及多终端应用的环境提供了坚实的基础服务架构，保证了其新业务的稳定落实。

内容为王，技术为助攻手
“互联网媒体”绝对不是指形式上的变化，媒体的自身属性奠定了其“内容为王”的基因。在这个自媒体遍天下的时代，人人都是“记者”，在这种纷繁复杂的媒体环境下，媒体内容量大大增加，如何保证内容的优质以及高效的传播，成为媒体当下的主要问题。
为了保证内容的优质性，提高受众黏性。让传统媒体稳自身信息来源的稳定性与报道的严谨性，与新媒体内容的多元化、灵活性相结合，让自身内容多元化的同时，也让更多受众找到自己的文化归属，让受众在传统的主流媒体渠道获取更多样化的信息。
换而言之，要保持内容的优势，面临着两个方面的问题

如果保证内容采集，并对内容做出分类，统筹策划，快速发布出去。
如何让内容实现多渠道传播，受众覆盖面最大化。 

做到以上两点并不容易，媒体融合发展需要借助技术手段实现平台再造，拓宽传播渠道，重新构建媒体与受众之间的关系。基于建设的私有云平台，利用开源软件虚拟化优势，将物理设备资源形成多个虚拟资源池，提供了计算、网络和存储能力，同时，快速适应不同应用的扩容需求，提供“弹性”资源的分配能力。保证了融合媒体内容采集汇聚、融合媒体内容加工编辑、融合媒体内容资源管理、融合媒体内容共享服务、融合媒体内容分发等项目的顺利实施。
与此同时，随着大数据、云计算等技术的发展以及新的传播媒介的出现，带给媒体的不仅是传播形式的改变，更是其开创的无限可能性以及由此带来的媒体生态环境的重大改变。如何把握这一全新时代机会，推动融合的发展，是未来关注的重点。
在未来，将整合自身优势资源，坚持技术创造性与内容相互统一，实现集约化和多层次的内容生产、资源共享。让自身的媒体融合发展之路走稳走好，提升自身影响力。海云捷迅作为的合作伙伴，也将通过自身技术优势，为提供灵活可靠的云机技术支持，保证资源调度及管理的稳定性。双方也将本着构建健康丰富的社会思想体系和提供深度优秀的精神资源为己任，为人民大众建设一个健康向上、寓教于乐的新闻平台。导语：是由主办的全球顶级技术盛会，每年在伦敦、北京、东京、纽约、圣保罗、上海、旧金山召开。自 年 月份首次举办以来，已经有超万名高级技术人员参加过大会。内容源于实践并面向社区，演讲嘉宾依据热点话题，面向 年以上工作经验的技术团队负责人、架构师、工程总监、高级开发人员分享技术创新和最佳实践。

月日性能优化面面观专题会议上，腾讯研发总监王辉以“十亿级视频播放技术优化揭秘”为主题，用空间的日均播放量一年内从千万级突破到十亿级所面临的严峻考验为切入点，为大家分享视频团队在视频组件的整体架构、优化效果衡量、带宽优化、秒开优化、缓冲优化、成功率优化等六个方面的技术实践。

王辉：大家早上好！我叫王辉，来自腾讯，从年开始从事空间技术研发，近期主要关注手机短视频、视频直播、智能硬件。很高兴能在上与大家一起分享和交流。我今天的话题是“十亿级视频播放技术优化揭密”。主要介绍我们团队在去年一年短视频风口上，我们的视频播放量从万到十亿级过程中的一些技术实践，希望我的介绍能给大家做一些借鉴和参考。

众所周知，短视频去年是一个风口，起因是来自 年的财报，财报表明在平台上每天有亿次短视频播放，给带来了强劲的广告收入，正是这个数据给国内核心大公司和创业公司带来的一些新的突破口。其实短视频已经不是一个新的概念，从年开始国内就有很多公司在做短视频。随着吹起短视频风，去年在短视频行业有近百款应用出现，中国网民里面每个里面就有个是短视频的用户，短视频成为互联网的流量入口。空间也在这个风口中，从年月份的每天万视频播放量，经过一年的耕耘细作，徒增到年月份的亿量级，现在还在不断增长。
我的演讲主要是按照我们产品迭代的几个关键步骤展开：
首先是快速上线，年我也是跟随着大家的体验快速上线了新短视频的体验；
其次面临的是成本问题，在做的过程中做了一些成本的优化工作；
然后是体验优化。在解决成本问题之后，短视频的观看体验要做到极致。比如说视频的秒开、不产生缓冲、不卡、成功率的提升。
快速上线

在开始之前，我先介绍一下我们的团队职责，我们团队负责手机和手机空间两个，每个有和两个团队，一共四个团队，四个团队负责两个。在这个项目中，我们四个团队要针对两个平台实现四套逻辑，这里的效率是存在一定的问题。
关于短视频体验，在这之前，我们也只是做到能播放而已，没有做很精细的工作，并且这里的产品观感体验也不是很一致，也不是很好。
技术上，之前也只是做很基础的架构，直接由播放器连接服务器下载数据，达到能播放就可以。之前我们没有积极去做这个事情，导致播放成功率低、失败原因未知、不支持边下边播、缓冲时间比较长等问题，流量浪费也比较严重。在产品上要解决的，是在整个里面把所有产品的体验做到一致，比如说每个功能的观看体验，视频浮层的体验，统一观看体验也为我们项目清除了很多障碍。

而这里的技术上的要点是非常关键的，第一个是边下边播，这是基础的要求，是为了加快视频播放速度。第二个是流量的控制，这么大的平台，之前只是做万的播放量，如果没有流量控制的云策略，可能到后面流量是无法把控的。第三，刚才讲到团队的现状，团队要负责两个，这里要做代码复用，不可能再像之前一样四个团队维护四套代码，第四，我们支持第三方的视频源。第五，需要完善监控上报，对业务知根知底。

可以看到，完成核心技术要点最核心的一点是如何控制视频的下载，传统的方式是播放器直接塞播放地址给播放器，它就可以直接播放，这其实是一个黑盒。我们在中间加了一个本地代理，播放器与服务器的数据请求，我们完全可以把控。在这个过程中，比如说播放器要数据时，可以给它更多的数据，这样能解决它缓冲的问题。有了这层代理之后，架构也更清晰一点。

基于这样的架构，在一层做一些业务的逻辑，在这一层做控制视频的播放和下载。有了下载代理之后，就可以通过代理管理下载，在里面有很多的视频请求，可以管理这些请求，做流量控制，做预加载，还可以做优先级调度和做监控上报，下载逻辑层则主要关注怎么优化服务器，对接缓存管理层，同时我们抽象出了一个数据层，我的数据源可以是，也可以读本地，也可以是来来自腾讯视频的数据源，也可以是第三方的数据源，协议层主要是、、的解决。
在的逻辑里，其实都可以放到层来实现，这样安卓和完全可以通用，这一层的逻辑可以在和空间两个里面使用，相当于是我们一套逻辑可以完全复用，不用再开发四套逻辑，我们团队的职能也做了相应调整，之前可能是按团队划分，四个团队负责四个终端，现在可能是按的方式划分做视频的团队，做视频的团队可能负责和空间里的业务，安卓也是如此。直播的也可以这样划分，的负责的两个，安卓的负责安卓的两个，这样代码复用更清晰一点，我的团队更专注一点。视频的团队专注视频的研发。
监控上报，肯定是不可缺少的，这是一个成熟的项目必备的要素。

问题定位，老板跟用户反馈说我这个视频播不了，要有一套成熟的问题定位的方式；

耗时统计，用户播放这个视频花多长时间播出来，这也是要了解到的；

成功率统计，外网用户播放视频的成功率是多少？还要通过实时报警，才能及时知道外网发生一些故障。



传统的捞方式大家都有，但是这种方式效率太低，需要等用户上线之后才能捞到，捞到之后还得花时间去分析。我们做法的是在关键问题上做一些插装，把每一类错误和每一个具体的子错误都能定义出来，这样一看错误码就知道播放错误是由什么原因导致的。还可以把每次播放视频的链路所有关键流水上报到统计系统里来，每一次播放都是一组流水，每一条流水里面就包含了例如首次缓冲发生的，或下载的链接是多少，下载的时间是多少，有了这些流水之后，用户反馈播放失败，我首先可以用流水看发生了什么错误？错误在哪一步？每一步信息是什么？几秒钟就可以定位到问题。
有了这个数据上报之后，还可以做一些报表。比如说可以做错误码的报表，有了报表之后就可以跟进哪个错误是在的，负责人是谁，原因是什么，都可以看到。
我们也有自己实时的曲线，可以看到各项数据的情况。在告警方面，基于成功率和失败率的统计，进行实时告警。一出现错误码，微信立即可以收到提醒，提醒说是什么原因导致这次告警，全自动。
成本优化
上线一个月之后，一个坏消息一个好消息。好消息是播放量涨了倍，坏消息是带宽涨了倍。带宽优化是每个做视频的人必须要面临的问题，我们也分析这个过程中的原因，发现因为改为边下边播之后用户观看视频的意愿比较强，用户有挑选心理，不是每个视频都去看，看了一下之后不喜欢就划走了，之前下载的那部分其实是浪费的。如果之前不做限速的话，一点开视频就疯狂的下数据，带宽有多大就下多少的数据，这样浪费很严重。

我们采取的第一个策略是进行流量控制。在高峰期播放到第秒时，预下载秒数据，下载到秒就停下来。然后，可以做多级限速。一开始不限速，下载到合适时机做倍码率限速。高峰期时预加载的数据会少一些，防止高峰期时带宽占用明显，这是初级的策略。最终我们也有码率切换的策略。这对用户的观看体验影响比较大，这也是之前必备的一个策略。
上线这个策略之后，对带宽的优化还是比较明显的。在高峰期时从：到凌晨点带宽下降，这个是我们不断灰度最终确定的值。这个值会影响播放缓冲，因为数据少的话必定会卡顿，在卡顿之间和流量之间取了一个最优值，最终是
但这样肯定是不够的，因为流量涨的还是很明显的，我们想到，压缩率相对于提升了，但它的复杂度也是呈指数级上升。复杂度导致它的编解码耗时更长，占用资源也更长。如果把用在客户端上的话，可能要评估一些点，比如说在编码上面，现在手机上没有做硬件支持的，相对于的耗时倍，之前耗时可能是分钟，而现在可能需要到分钟左右。解码的硬件支持的也很少，耗时差不多是一样的。解码是可行的，你可以采用软解的方式，这个带来的问题是占用非常高，可能之前占的，占、左右，带来的问题是发热和耗电。
结论，解码是可行的，但是编码不用考虑，在移动客户端不可行的情况下，那编码就要放在后台来做了。

为了解决如何在我们手机上能够解码的问题，对手机的解码能力做一次评估。我在合适的时机做一次大规模的浮点数运算，将数据上传到后台服务器进行云适配。如果当前的指数满足条件的话，可以给你下载视频给你播放。从而保证软件解码柔性可用，针对视频源规格按机型适配降级，保证用户视频播放体验。
经过我们的统计，外网上有的手机还是支持解码的。支持手机的解码占

编码只能在后台做，如果在视频后台进行全面编码的话，是不现实的。因为编码复杂度呈指数级上升，拿后台服务器进行编码也是不可行的。我们的做法是只用热点视频进行后台转码，不是所有视频都去编码，对观看量在 的视频进行编码，只需要编码少量的视频就可以带来流量优化效果，因为 就占了全网的流量。
因为热点视频的热点转化很快，可能前几分钟是热点，后几分钟就不是热点，因为社交网络的传播非常快。我们给后台的要求是转码速度一定要快，在之前没有优化时，转一个分钟的视频要半个小时左右。后来我们做了分布式处理之后，转分钟的视频只用两三分钟。一些短视频最长分钟左右，只要监测到这个视频很热的话，分钟之内就能转出来，就是了。

同样，在编码器上做了一些优化，比如说编码速度和码率的都会有提升。
上线优化之后，我们的带宽进一步下降，节省了左右。
秒开优化
带宽问题解决之后，面临的下一个问题是体验优化。用户最想要的是视频能立马播出来。我们定了一个秒开技术指标，只要这个视频从到我的视野范围，到视频播出来之间的耗时在一秒以内。这也是对标的体验，一打开动态，视频是能立即播出来的，不需要等待就能播，这个体验其实很顺畅。核心的流程主要是三个步骤：、客户端的耗时；、下载数据；、等待播放。
这里主要有两个大的耗时点，第一下载视频数据耗时；第二个是客户端的耗时，下载视频数据耗时的话，主要是下载数据量和下载的速度。

这里有一个很直接的问题，播放器需要下载多少数据才能播放？我们可以看一下，其实是一个比较灵活的容器格式，每个东西都是用表达的，每个又可以嵌入到另外一个。主要由和组成，是囊括了所有的视频关键信息，肯定是先把下载完之后才能找视频数据才能播起来。不巧的是，在我们外网会发现有左右用户上传的视频，它的是在尾部的。后来也发现，有很多安卓手机比如说山寨机，一些摄像头处理的厂商可能比较偷懒，因为他们只有在你采集完信息之后才能知道他所有的信息，他可能把所有的信息放在尾部。对于来说，一开始把头部下载了，下载头部时可能找不到这个，就猜测这个在尾部，我可能就有一次请求去探测这个头部到底在哪？这个探测的话基本做法是去尾部探测。如果在其他地方的话，这次播放肯定是失败的。现在主流的系统都是去尾部进行一次探测。
比如安卓某些手机是无法自定义，那就需要下载完整个文件才能播放。我们的处理方式，用户在后台做一次转码修复，客户端采集后做一次转码修复。
再看一下，这是视频的原数据。目前大部分是编码，通过真预测的方式来进行视频编码，这里有一个概念，也是在直播里面经常谈的。一般的视频需要下载歌完整的数据才可以播，可以看到在这个里面需要下载多少数据才能播呢？每个播放器的行为也不一样。大家可以看到要下载一个完整的才可以播。像的话我可能只需要关键帧就可以播出来。安卓是比较尴尬的一个系统，在级以下，可能需要秒视频数据才可以播起来。如果说是需要下载秒数据才可以播起来的话，那肯定是非常慢的。我们这里的一个策略会采用自己来做解码，这里要关注功能性和耗电的问题。
解决了之后，你会发现如果我的数据在头部，拿关键信息进行播放的话，其实我播放的数据量非常小的。

对于下载优化的话，会有一个防盗链的请求，通过拿到真实的才可以下载数据。在手机上执行请求是非常耗时的，这里我们走私有长连接通道做这个事情。
关于优化下载链路，这里也是谈的比较多的，一般也是直接输出地址，利用地址做跑马的策略，兼顾性能的效率，这个是用的比较多的方式。
进一步思考，按照普遍码率的话，我们统计到现在上面下载的平均速度是左右，这样计算的话，可能在安卓上面播放一个视频的话，需要将近秒左右才可以下载到你需要的数据。如果码率再进一步提升的话，可能会更大，这其实我们也做了一些场景分析，会发现我们是社交网站，它有好友动态，视频在好友动态里播放，或者是在视频浮层里播放，我们的选择是预加载的策略，这也是常见的策略。我们会在当前看的这条动态时会预加载后面视频的关键信息，比如说会加载头部信息和需要播放的数据，来进行预加载。比如说在播放当前视频时，我的视频在加载一定数据之后会加载下一秒预加载数据，这些都可以做到的。
预加载有一个问题，我们之前踩了一个坑，可能预加载视频时还是要优先图片的。视频当然重要，但是社交网络上的图片也更重要，可能在预加载视频时会考虑到图片的一些任务，还有视频封面之类。
优化效果也是比较明显，经过刚才几个策略，一个是我们对头和播放器的处理，我们对防盗链的处理，还有对下载链路的处理和预加载，这样我们的耗时大幅度减少了，之前是秒降到秒左右。客户端的性能也是让人容易忽视的问题，发现有些用户虽然有视频的缓存，但是播起来还是很慢，这其实是客户端性能的影响。因为视频涉及到的和流程比较多，在这个过程中还要更关注到客户端的影响，要分析下客户端是哪些在抢占你的视频播放资源，我们之前犯过一些错误，会卡住一些流程，或者是会阻止你的任务，会导致视频播放更慢。
在优化视频播放过程中，我们在月份也做直播。直播这里面插入个事情，我们要播放直播的视频流，是的视频，在好友动态里面可以观看直播的内容。在安卓上面体验非常差，因为安卓之后对基本没有做的优化工作，这里每次安卓上播放需要等待秒。分析发现它的处理也不是很得当，因为安卓系统请求链路较长，串行下载，需要下载片才能启动播放，下载个分片的话，耗时就会很久。之前提到我们这里有代理，有了代理之后做事情方便很多了，通过里获取，解析里面有哪些文件，可以做并行下载，只让他下载一次，这样下载速度大幅度提升。回到刚才架构上，有了下载代理层的话，你可以做的加速和管理，可以加入的视频源。

缓冲耗时也是很明显的，之前需要秒左右，现在秒左右就可以播起来。整体从之前的秒左右现在优化到秒，用户都可以在秒内播视频。

还有一个是用户比较关注的问题，观看视频时卡，观看一会卡了一下，数据，完以后又卡，这个体验非常差，我们希望所有的视频都不卡。其实这有两个播放场景，一个是正常场景，边下边看，数据在下载。对于正常场景下载时会做一些带宽调整，在低速时会做切换的处理，比如说当前连通的耗时比较久的话，会做一些处理，也会对网络进行速度限制。

针对场景的话，如果用户拖动的话，文件缓存系统是连续存储系统的话，必然会造成拖到这里时，后面的缓存数据是没有办法下载到系统里面来的。

我们就对存储做了一次重构，支持文件空洞。会按照一兆的方式对文件进行碎片划分，好处是我可以分段存储，我可以允许逻辑空洞的，拖动的话也可以在后面存储，也不需要数据库，我可以知道这是从哪个位置到哪个位置的存储。这样淘汰缓存也高效一点，并可以制定更灵活的缓存策略。这里可以淘汰更低密度的文件，还可以做的事情是对文件加密。这里产生卡顿的用户里面，是因为进行拖动，拖动之后又没有缓存数据，所以这里有可能导致发生缓冲。统计效果也是比较明显的，上了分片缓存之后，之前的缓存概率是左右，最后下降到，基本上看不到发生缓冲的场景。
成功率优化，也是我们比较关键的指标。成功率优化没有捷径，可能是  各个击破。之前我们进行编码，有几百个错误码，错误码原因进行上报，每次进行循环，一个个错误码进行解决。下载常见的错误码，劫持是比较多的，一些网络运营商会劫持你的请求。

这个在国内是比较常见的劫持，有的小运营商按月会劫持你的视频内容，可能直接污染你的让你查找不到，这是比较多的，还有一些网络不稳定的影响导致。更隐藏的会直接污染你的视频内容，让你视频内容是错误的。播放比较多的可能是一些编码的原因，刚才提到一些手机采集出来的视频在低端手机上播不出来，我们会对这些视频进行修复。
逻辑上的问题，因为播放器有状态的，可能开发人员比较多，每个人过来加一个逻辑的话，会导致播放状态出现问题。
我们做的播放器错误解决方法：
播放器接口与回调，实现播放器状态机，监控插放器的调用是否合法，不合法直接告警或。帮助开发快速定位问题，同时减轻测试同事的负担，封装成组件，使其它开发不必理解播放器。

最终优化的成果是这样的，下载成功率优化前是，优化后是。播放成功率优化前是，优化后是。首次缓冲耗时优化前是，优化后是。二次缓冲概率优化前是，优化后是。数据还是很可观的。
我的演讲基本是这些，欢迎大家关注我们团队的公众账号，也会分享一些技术文章。    


问题：刚才您提到已经开始尝试用了，能透露一下你们播放的在整体中占多大的比例？
王辉：现在热视频里面都是。亿里面会有、左右。
问题：推进的还是挺靠前的。刚才你提到要判断手机的能力，用大规模的浮点运算，首先我先了解一下你们用的什么浮点运算的？其次，为什么要用浮点运算？其实视频编解码里面几乎全部都是整数运算。
王辉：浮点运算能代表你这个手机性能，其实我们是评估性能的，不是评估转码，如果性能达到的话，解码也是可以达到的。
问题：如果想针对解码做评估的话，我建议整数运算。你可以确认一下，首先视频编解码的标准规定是没有浮点运算，不同的编解码时限可能会插入少量的浮点运算，大部分是整数运算。
王辉：我们初步做的时候是判断手机有没有运算能力来做的浮点运算判断。
主持人：感谢各位嘉宾的提问，感谢王辉老师给大家带来的讲解。导语 语言从年发布第一版开始，逐渐变的流行，被人所熟知，但是很多人可能听说过，但是对的特性并不是很了解，这里主要介绍的一些关键特性和语言总体的情况。

分享和语言圣经上的聊天室代码附上。
在之外，补充几点分享之后收集到的。

目前已经不依赖，除非使用，才会默认链接到目录下的几个，验证即可。

现在虽然已经支持编译成和文件供使用，但是有诸多限制，比如类型不支持，一些库不支持等等。另外，生成文件，使用工具，会自动生成和文件，然后进行编译即可；生成文件，使用=即可，但是在中需要使用一整套，相当麻烦，另外也觉得难以修改和维护。：个人觉得作为高层次一些的语言，作为更为底层的语言，用调用总感觉怪怪的，不知道效果是否真的能达到

版本后，支持将代码编译成，可以在其余服务中用库进行动态加载，插件式的方法，变的更加方便，适合框架开发，当然目前仅仅支持。


最后，还有很多我不了解的知识，需要持续学习。
这里有任何不对和不准确的地方，欢迎指正和帮助，。分享者：邵宗文

本次分享主题
搜狐图文匹配大赛相关经验介绍等框架介绍 环境搭建介绍通过猫狗结合等模型使用模型讲解文本模型相关的介绍通过对新闻列表相关新闻进行分析，词向量生成和使用介绍。针对的模型的介绍在托管平台的容量预测，一些股票预测的案例模型。行业其他公司如阿里巴巴的一些试点业务展望近两天，关于公有云经典网络基础网络与私有网络的讨论引发技术圈极大关注，事件起因于有开发者将数据库限制在内网访问，但由于安全组设置的原因，阿里云邻居用户被黑后，牵连到了自己的业务。为此，开发者左耳朵耗子发表了《科普一下公有云网络》，指出阿里云默认的内网是经典网络，管理复杂，配置错误是高概率事件，呼吁大家采用方案，防止重现上述事故。
对比起“谈安全色变”，圈内理性探讨总归是好事。这次“经典网络安全争议”，让方案迅速为广大开发者所了解，相信将推动公有云服务商加速相关网络技术的布局，那么是什么呢？接下来是否有必要从经典网络迁移到上？在这里给大家做个科普：
、是什么？
  是公有云上自定义的逻辑隔离网络空间，与用户在数据中心运行的传统网络相似，托管在内的是用户在私有云上的服务资源，如云主机、负载均衡、云数据库等。用户可以自定义网段划分、地址和路由策略等，并通过安全组和网络等实现多层安全防护。同时也可以通过或专线连通与用户的数据中心，灵活部署混合云。
、与经典网络基础网络的区别
经典网络：公有云上所有用户共享公共网络资源池，用户之间未做逻辑隔离。用户的内网由系统统一分配，相同的内网无法分配给不同用户。
：是在公有云上为用户建立一块逻辑隔离的虚拟网络空间。在内，用户可以自由定义网段划分、地址和路由策略，安全可提供网络及安全组的访问控制，因此，有更高的灵活性和安全性。经典网络和的架构对比图：

对比可以看到，优势明显，通过，用户可以自由定义网段划分、地址和路由策略；安全方面，可提供网络及安全组的访问控制，灵活性和安全性更高。可适用于对安全隔离性要求较高的业务、托管多层应用、弹性混合云部署等使用场景中，符合金融、政企等行业的强监管、数据安全要求。
、各家对比
目前，也是各大云厂商正在力推的网络方案。、阿里云、腾讯云等官网对都有详细的介绍：

总的来说，和腾讯云的评分最高，能支持弹性网卡、服务、网络等多项服务，很大程度上降低了用户使用时的技术门槛，让复杂的配置变得更加简便、安全、灵活。
同时，从腾讯云的官网说明看，腾讯云还支持外网直通、子网广播和组播、专线功能，这些是目前公有云市场的独家服务。
、经典网络用户如何平滑迁移
以上较多篇幅介绍了的优势，那么对于已经在经典网络内有较多云主机的客户如何实现经典网络和之间的平滑迁移呢？

和腾讯云基础网络互通都提供了平滑过渡方案，可以将经典网络内的云服务器关联至指定，使经典网络中的云服务器可以与内的云服务器、数据库等云服务通信。 
本次网络事件的爆发或将可能成为网络界的一个转折点。无论从业内人士的，还是从厂商的产品布局中，可以看到，经典网络引争议后，被业界推崇，或成为网络市场的主流应用。

相关推荐如何使用私有网络部署全球同服游戏服务【腾讯云的种玩法】运维的网络管理利器：弹性网卡体验插件网络相关接口的应用前言
年月日谷歌新开源了一个图片压缩优化算法。
这是谷歌官方的博客
这是一种的编码器，比目前其它压缩图片的方法大小大约减少了。
使用后质量不但没有损失，甚至还更加优化。
这是鹅厂的体验报告
你可以在上获取个人版本的源码，对其进行重建。
这是地址
本文就将指导读者如何利用这“新玩意”来优化你的图像。
情景假设
假设你的网站上有个图片，设每张图的大小为，
如果可以将文件大小减小，这样可以网站上的图片总存储容量将减少。
这样用户端的下载速度会加快，减小了服务器的负担。
正文
是一个通用文件优化器，它是支持的程序之一。
这是它的下载地址需要梯子
这个程序很简单，我们只需要将要优化的图片拖放到软件中，然后从菜单中选择优化即可。
但是要注意：
不是默认的解码器，因为它并不是无损的，所以要在中启用支持。所以你需要执行以下步骤：

在安装路径下打开你安装的位数

小编的是
\\

找到参数，并将其设置为。
在行打开

重启软件
优化你的图片

小编随便使用了几张图片
最后看见优化效果还是不错的

只不过最终具体值还是与官方放出来的数据有点偏差的。
不足
但是有一个缺点就是运行时间较长。 具体需要多长时间取决于图像的大小，如果超过，会很慢一分钟或更长时间。 不过，对于网站管理员来说，这是值得的。 
最好用一台备用电脑，小时运行来运行压缩任务腾讯云可以的哈哈
最后附上软件下载地址送给没有梯子的读者
链接  密码 


相关推荐： 图片压缩算法预研报告谷歌开源图片压缩算法实测体验报告：谷歌家的东西可能也没有想像的辣么美刚看到腾云阁新一期的活动又开始了，跃跃欲试，恰巧看到我就把安装过程记录一下。

必备环境：



安装命令：
  
 
  
安装过程中问题一：
          
解决方法：我把代码稍加修改了。 都是的 我这里很疑惑
去掉：
   
     = 

   
     = 
初始化：
 =
 _=
问题二：
“      
解决办法：

手工安装

  
问题三：
      _
   由于连接方在一段时间后没有正确答复或连接的主机没
有反应，连接尝试失败。
解决办法：
安装
运行案例：

\\\ _  
_
_\\\\



_

_\\\
\\\\
  
  \\\\\
    
 
 
  \\\\\\__\
\_
     
    
  
 
 |||||
    

     
    
  
 
 |||||
    

      
    
  
 
 |||||
    

     
    
  
 
 |||||
    

     
    
  
 
 |||||
    
                    

     
    
  
 
 |||||
    

     
    
  
 
 |||||
    

     
    
  
 
 |||||
    

     
    
  
 
 |||||
    

     
    
  
 
 |||||
    
                    
导语
最近分享过一次关于技术主题的演讲，由于接触时间不长，很多技术细节认识不够，也没讲清楚，作为一个技术人员，本着追根溯源的精神，还是有必要吃透，也为自己的工作沉淀一些经验总结。网上关于 的资料多集中于怎么搭建，对于为什么要这么做描述甚少，所以本文对于是如何搭建的暂不介绍，主要是介绍是怎么运作，又是怎么发挥功效的。
一、 系统架构
 和 架构
在介绍之前，我们先来看下的系统架构，这对于理解是至关重要的。 之前，其官方架构如图所示

 图 架构图 
从图中可看出，版本之前只有一个所有元数据由惟一的负责管理可想而之当这个挂掉时整个集群基本也就不可用。 的架构与有什么区别呢。我们来看下的架构：

 图 架构图 
版本中，架构解决了单点故障问题，即引入双架构，同时借助共享存储系统来进行元数据的同步，共享存储系统类型一般有几类，如： 、、 和   ，上图中用的是作为共享存储组件，通过搭建奇数结点的实现主备元数据操作信息同步。的元数据包括哪些信息呢，下面介绍下关于元数据方面的知识。
  元数据
的元数据主要作用是维护文件系统中文件和目录相关信息。元数据的存储形式主要有类：内存镜像、磁盘镜像、日志。在启动时，会加载磁盘镜像到内存中以进行元数据的管理，存储在内存；磁盘镜像是某一时刻的元数据信息的快照，包含所有相关节点文件块映射关系和命名空间信息，存储在本地文件系统；日志文件记录发起的每一次操作信息，即保存所有对文件系统的修改操作，用于定期和磁盘镜像合并成最新镜像，保证元数据信息的完整，存储在本地和共享存储系统中。
如下所示为本地的和文件格式，文件有两种状态： 和 表示正在写的日志文件，文件名形式，表示已经写完的日志文件文件名形式：； 文件也有两种状态 和， 表示已经持久化磁盘的文件，文件名形式 _ 表示合并中的 版本过程在 上进行，会定期将本地和从上拉回的的进行合并，合并完后再通过传回。

├── 
│ ├── 
│ ├── _
│ ├── _
│ ├── _
│ ├── _
│ ├── _
│ ├── _
│ ├── __
│ ├── _
│ ├── _
│ ├── _
│ ├── _
│ └── _
└── _
上面所示的还有一个很重要的文件就是_保存的是一个事务，这个事务是最新的一个结束事务，当重启时，会顺序遍历从_到_所记录的所在的日志文件，进行元数据恢复，如果该文件丢失或记录的事务有问题，会造成数据块信息的丢失。
其本质上就是要保证主备元数据是保持一致的，即保证和在备上也是完整的。元数据的同步很大程度取决于的同步，而这步骤的关键就是共享文件系统，下面开始介绍一下关于共享存储机制。
二、原理
 背景
在出现之前，为保障集群的，设计的是一种基于的共享存储机制，即主备间通过进行元数据的同步。该方案有什么缺点呢，主要有以下几点：

定制化硬件设备：必须是支持的设备才能满足需求
复杂化部署过程：在部署好后，还必须额外配置挂载、定制隔离脚本，部署易出错
简陋化客户端：多，部署配置易出错，导致不可用

所以对于替代方案而言，也必须解决相关缺陷才能让更好服务。即设备无须定制化，普通设备即可配置，部署简单，相关配置集成到系统本身，无需自己定制，同时元数据的同步也必须保证完全，不会因问题而同步失败。
 原理
 介绍
全称是   由组成，一般是奇数点结点组成。每个对外有一个简易的接口，以供读写到本地磁盘。当写时，会同时向所有并行写文件，只要有结点写成功则认为此次写操作成功，遵循协议。其内部实现框架如下：

 图内部实现框架 
从图中可看出，主要是涉及的不同管理对象和输出流对象，每种对象发挥着各自不同作用：

：所有操作的入口
 集成本地磁盘和集群上的相关操作
 实现本地磁盘上  操作
 实现 集群操作
 实现 集群  的写操作集合
：发起请求到，执行具体的日志同步功能
：运行在  节点进程中的  服务，接收  端的  的  请求。
：运行在  节点进程中的  服务，用于接收处于  状态的  和其它  的同步  文件流的请求。

下面具体分析下的读写过程。
  写过程分析
上面提到，会把同时写到本地和。写本地由配置中参数控制，写由参数控制，在写时会由两个不同的输出流来控制日志的写过程，分别为：本地输出流和输出流。写也不是直接写到磁盘中，为保证高吞吐，会分别为和定义两个同等大小的，大小大概是，一个写，一个同步，这样可以一边写一边同步，所以是一个异步写过程，同时也是一个批量同步的过程，避免每写一笔就同步一次日志。
这个是怎么实现边写边同步的呢，这中间其实是有一个缓冲区交换的过程，即和在达到条件时会触发交换，如在达到阈值同时的数据又同步完时，数据会清空，同时会将指针指向以满足继续写，另外会将指针指向以提供继续同步。上面过程用流程图就是表示如下：

 图输出流程图 
这里有一个问题，既然是异步写的，怎么保证缓存中的数据不丢呢其实这里虽然是异步但实际所有日志都需要通过同步成功后才会给返回成功码，假设某一时刻不可用了，其内存中的数据其实是未同步成功的，所以会认为这部分数据未写成功。
第二个问题是，怎么在多个上保持一致的呢。下面展开介绍。
隔离双写：
在每次同步到时，先要保证不会有两个同时向同步日志。这个隔离是怎么做的。这里面涉及一个很重要的概念 ，很多分布式系统都会用到。有如下几个特性：

当成为活动结点时，其会被赋予一个

每个是惟一的，不会有相同的出现

有严格顺序保证，每次切换后其都会自增，后面生成的都会大于前面的


是怎么保证上面特性的呢，主要有以下几点：

第一步，在对作任何修改前，上必须被赋予一个
第二步， 把自己的通过的方式发送给所有结点
第三步， 当收到请求后，会把的保存到一个变量中并持久化到本地磁盘
第四步， 同步日志到的任何请求如等，都必须包含的
第五步，在收到请求后，会将之与对比，如果请求的小于将会拒绝同步请求，反之，会接受同步请求并将请求的保存在


这样就能保证主备发生切换时，就算同时向同步日志，也能保证日志不会写乱，因为发生切换后，原的肯定是小于新的，所以原向的发起的所有同步请求都会拒绝，实现隔离功能，防止了脑裂。

 恢复日志
为什么要这步呢，如果在写过程中写失败了，可能各个上的的长度都不一样，需要在开始写之前将不一致的部分恢复。恢复机制如下：

 先向所有发送请求； 会向返回一个； 收到大多数的后，选择最大的一个并加作为当前新的，然后向发送新的请求，把新的下发给； 收到新的后，和对比，若更大则更新到本地并返回给自己本地一个最新起始事务若小则返回错误； 收到多数成功响应后认为生成成功，开始准备日志恢复； 会选择一个最大的事务作为恢复依据，然后向发送； 请求，对应协议阶段的，若多数响应成功，则可认为阶段成功； 选择进行同步的数据源，向发送 请求，并将数据源作为参数传给。 收到请求后，会从下载并替换到本地保存的，对应协议阶段的，完成后返回请求成功状态。 收到多数的响应成功请求后，向发送请求，表示数据恢复完成，这样之后所有上的日志就能保持一致。数据恢复后，上会将本地处于状态的日志更名为状态的日志，形式如。

日志同步
这个步骤上面有介绍到关于日志从同步到的过程具体如下：

 执行过程，将上的日志数据放到缓存队列中 将缓存中数据同步到，有相应线程来处理请求 收到数据后，先确认是否合法，再验证日志事务是否正常，将日志刷到磁盘，返回成功码 收到成功请求后返回写成功标识，若失败则抛出异常

 通过上面一些步骤，日志能保证成功同步到，同时保证日志的一致性，进而备上同步日志时也能保证数据是完整和一致的。
 读过程分析
这个读过程是面向备的，定期检查上的变化，然后将拉回本地。上有一个线程，会定期将上和合并，并将合并完的文件传回主上，就是所说的过程。下面我们来看下是怎么进行的。
在版本中，已经将原来的由主导的替换成由主导的。下面是一个的流向图

 图流向图 
总的来说，就是在上先检查前置条件，前置条件包括两个方面：距离上次的时间间隔和中事务条数限制。前置条件任何一个满足都会触发，然后会将最新的数据即内存中当前状态的元数据保存到一个临时的文件 然后比对从上拉到的最新的事务，将_中没有，中有的所有元数据修改记录合并一起并重命名成新的文件，同时生成一个文件。将最新的再通过请求传回。通过定期合并有什么好处呢，主要有以下几个方面：

可以避免越来越大，合并成新后可以将老的删除
可以避免主压力过大，合并是在上进行的
可以保证保存的是一份最新的元数据，故障恢复时避免数据丢失

三、主备切换机制
要完成，除了元数据同步外，还得有一个完备的主备切换机制，的主备选举依赖于。下面是主备切换的状态图：

 图流程图 
从图中可以看出，整个切换过程是由来控制的，具体又可分为、和三个组件。

 是和的母体，执行具体的切换操作
 监控健康状态，若状态异常会触发回调进行自动主备切换
 通知执行主备选举，若完成变更，会回调相应方法进行主备状态切换

在故障切换期间，主要是发挥什么作用呢，有以下几点：

失败保护：集群中每一个都会在维护一个持久的机器一旦挂掉，就会过期，故障迁移就会触发
 选择：有一个选择的机制，一旦现有的宕机，其他可以向申请排他成为下一个节点
防脑裂： 本身是强一致和高可用的，可以用它来保证同一时刻只有一个活动节点

那在哪些场景会触发自动切换呢，从中归纳了以下几个场景：

 奔溃：上状态上报会有连接超时异常，会触发状态迁移至__ 然后上的会退出选举，上的会获得  作相应隔离后成为结点。
 冻结：这个是没奔溃，但也无法响应，同奔溃一样，会触发自动切换。
 机器宕机：此时会失去同的心跳，会话超时，上的会通知删除的活动锁，作相应隔离后完成主备切换。
 健康状态异常： 此时会收到一个，并触发自动切换。
 奔溃：虽然是一个独立的进程，但因设计简单也容易出问题，一旦进程挂掉，虽然此时是的，但系统也认为需要切换，此时会发一个请求到要求放弃主结点位置，收到请求后，会触发完成自动切换。
奔溃：如果奔溃了，主备上的都会感知断连，此时主备会进入一个模式，同时不改变主备的状态，继续发挥作用，只不过此时，如果也故障了，那集群无法发挥 也就不可用了，所以对于此种场景，一般是不允许挂掉到多台，至少要有台保持服务才算是安全的。

五、总结
上面介绍了下关于机制，归纳起来主要是两块：元数据同步和主备选举。元数据同步依赖于共享存储，主备选举依赖于和。整个过程还是比较复杂的，如果能理解协议，那也能更好的理解这个。希望这篇文章能让大家更深入了解关于方面的知识。
六、参考文献
   任何的服务器的性能都是有极限的，面对海量的互联网访问需求，是不可能单靠一台服务器或者一个来承担的。所以我们一般都会在运行时架构设计之初，就考虑如何能利用多个、多台服务器来分担负载，这就是所谓分布的策略。分布式的服务器概念很简单，但是实现起来却比较复杂。因为我们写的程序，往往都是以一个，一块内存为基础来设计的，所以要让多个程序同时运行，并且协调运作，这需要更多的底层工作。
首先出现能支持分布式概念的技术是多进程。在时代，计算机在一个时间内只能运行一个程序，如果你想一边写程序，同时一边听，都是不可能的。但是，在操作系统下，你就可以同时开多个窗口，背后就是同时在运行多个程序。在和后来的操作系统里面，都普遍支持了多进程的技术。
所谓的多进程，就是操作系统可以同时运行我们编写的多个程序，每个程序运行的时候，都好像自己独占着和内存一样。在计算机只有一个的时候，实际上计算机会分时复用的运行多个进程，在多个进程之间切换。但是如果这个计算机有多个或者多个核，则会真正的有几个进程同时运行。所以进程就好像一个操作系统提供的运行时“程序盒子”，可以用来在运行时，容纳任何我们想运行的程序。当我们掌握了操作系统的多进程技术后，我们就可以把服务器上的运行任务，分为多个部分，然后分别写到不同的程序里，利用上多或者多核，甚至是多个服务器的一起来承担负载。

多进程利用多
这种划分多个进程的架构，一般会有两种策略：一种是按功能来划分，比如负责网络处理的一个进程，负责数据库处理的一个进程，负责计算某个业务逻辑的一个进程。另外一种策略是每个进程都是同样的功能，只是分担不同的运算任务而已。使用第一种策略的系统，运行的时候，直接根据操作系统提供的诊断工具，就能直观的监测到每个功能模块的性能消耗，因为操作系统提供进程盒子的同时，也能提供对进程的全方位的监测，比如占用、内存消耗、磁盘和网络等等。但是这种策略的运维部署会稍微复杂一点，因为任何一个进程没有启动，或者和其他进程的通信地址没配置好，都可能导致整个系统无法运作；而第二种分布策略，由于每个进程都是一样的，这样的安装部署就非常简单，性能不够就多找几个机器，多启动几个进程就完成了，这就是所谓的平行扩展。
现在比较复杂的分布式系统，会结合这两种策略，也就是说系统既按一些功能划分出不同的具体功能进程，而这些进程又是可以平行扩展的。当然这样的系统在开发和运维上的复杂度，都是比单独使用“按功能划分”和“平行划分”要更高的。由于要管理大量的进程，传统的依靠配置文件来配置整个集群的做法，会显得越来越不实用：这些运行中的进程，可能和其他很多进程产生通信关系，当其中一个进程变更通信地址时，势必影响所有其他进程的配置。所以我们需要集中的管理所有进程的通信地址，当有变化的时候，只需要修改一个地方。在大量进程构建的集群中，我们还会碰到容灾和扩容的问题：当集群中某个服务器出现故障，可能会有一些进程消失；而当我们需要增加集群的承载能力时，我们又需要增加新的服务器以及进程。这些工作在长期运行的服务器系统中，会是比较常见的任务，如果整个分布系统有一个运行中的中心进程，能自动化的监测所有的进程状态，一旦有进程加入或者退出集群，都能即时的修改所有其他进程的配置，这就形成了一套动态的多进程管理系统。开源的给我们提供了一个可以充当这种动态集群中心的实现方案。由于本身是可以平行扩展的，所以它自己也是具备一定容灾能力的。现在越来越多的分布式系统都开始使用以为集群中心的动态进程管理策略了。

动态进程集群
在调用多进程服务的策略上，我们也会有一定的策略选择，其中最著名的策略有三个：一个是动态负载均衡策略；一个是读写分离策略；一个是一致性哈希策略。动态负载均衡策略，一般会搜集多个进程的服务状态，然后挑选一个负载最轻的进程来分发服务，这种策略对于比较同质化的进程是比较合适的。读写分离策略则是关注对持久化数据的性能，比如对数据库的操作，我们会提供一批进程专门用于提供读数据的服务，而另外一个或多个进程用于写数据的服务，这些写数据的进程都会每次写多份拷贝到“读服务进程”的数据区可能就是单独的数据库，这样在对外提供服务的时候，就可以提供更多的硬件资源。一致性哈希策略是针对任何一个任务，看看这个任务所涉及读写的数据，是属于哪一片的，是否有某种可以缓存的特征，然后按这个数据的或者特征值，进行“一致性哈希”的计算，分担给对应的处理进程。这种进程调用策略，能非常的利用上进程内的缓存如果存在，比如我们的一个在线游戏，由个进程承担服务，那么我们就可以把游戏玩家的，作为一致性哈希的数据，作为进程调用的，如果目标服务进程有缓存游戏玩家的数据，那么所有这个玩家的操作请求，都会被转到这个目标服务进程上，缓存的命中率大大提高。而使用“一致性哈希”，而不是其他哈希算法，或者取模算法，主要是考虑到，如果服务进程有一部分因故障消失，剩下的服务进程的缓存依然可以有效，而不会整个集群所有进程的缓存都失效。具体有兴趣的读者可以搜索“一致性哈希”一探究竟。
以多进程利用大量的服务器，以及服务器上的多个核心，是一个非常有效的手段。但是使用多进程带来的额外的编程复杂度的问题。一般来说我们认为最好是每个核心一个进程，这样能最好的利用硬件。如果同时运行的进程过多，操作系统会消耗很多时间在不同进程的切换过程上。但是，我们早期所获得的很多都是阻塞的，比如文件，网络读写，数据库操作等。如果我们只用有限的进程来执行带这些阻塞操作的程序，那么会大量被浪费，因为阻塞的会让有限的这些进程停着等待结果。那么，如果我们希望能处理更多的任务，就必须要启动更多的进程，以便充分利用那些阻塞的时间，但是由于进程是操作系统提供的“盒子”，这个盒子比较大，切换耗费的时间也比较多，所以大量并行的进程反而会无谓的消耗服务器资源。加上进程之间的内存一般是隔离的，进程间如果要交换一些数据，往往需要使用一些操作系统提供的工具，比如网络，这些都会额外消耗服务器性能。因此，我们需要一种切换代价更少，通信方式更便捷，编程方法更简单的并行技术，这个时候，多线程技术出现了。

在进程盒子里面的线程盒子
多线程的特点是切换代价少，可以同时访问内存。我们可以在编程的时候，任意让某个函数放入新的线程去执行，这个函数的参数可以是任何的变量或指针。如果我们希望和这些运行时的线程通信，只要读、写这些指针指向的变量即可。在需要大量阻塞操作的时候，我们可以启动大量的线程，这样就能较好的利用的空闲时间；线程的切换代价比进程低得多，所以我们能利用的也会多很多。线程是一个比进程更小的“程序盒子”，他可以放入某一个函数调用，而不是一个完整的程序。一般来说，如果多个线程只是在一个进程里面运行，那其实是没有利用到多核的并行好处的，仅仅是利用了单个空闲的核心。但是，在和这类带虚拟机的语言中，多线程的实现底层，会根据具体的操作系统的任务调度单位比如进程，尽量让线程也成为操作系统可以调度的单位，从而利用上多个核心。比如之后，提供了的内核线程模型，就提供了线程到内核线程的映射，从而利用上多核。而系统中，据说本身线程就是系统的最小调度单位，所以多线程也是利用上多核的。所以我们在使用\编程的时候，多线程往往已经同时具备了多进程利用多核、以及切换开销低的两个好处。
早期的一些网络聊天室服务，结合了多线程和多进程使用的例子。一开始程序会启动多个广播聊天的进程，每个进程都代表一个房间；每个用户连接到聊天室，就为他启动一个线程，这个线程会阻塞的读取用户的输入流。这种模型在使用阻塞的环境下，非常简单，但也非常有效。
当我们在广泛使用多线程的时候，我们发现，尽管多线程有很多优点，但是依然会有明显的两个缺点：一个内存占用比较大且不太可控；第二个是多个线程对于用一个数据使用时，需要考虑复杂的“锁”问题。由于多线程是基于对一个函数调用的并行运行，这个函数里面可能会调用很多个子函数，每调用一层子函数，就会要在栈上占用新的内存，大量线程同时在运行的时候，就会同时存在大量的栈，这些栈加在一起，可能会形成很大的内存占用。并且，我们编写服务器端程序，往往希望资源占用尽量可控，而不是动态变化太大，因为你不知道什么时候会因为内存用完而当机，在多线程的程序中，由于程序运行的内容导致栈的伸缩幅度可能很大，有可能超出我们预期的内存占用，导致服务的故障。而对于内存的“锁”问题，一直是多线程中复杂的课题，很多多线程工具库，都推出了大量的“无锁”容器，或者“线程安全”的容器，并且还大量设计了很多协调线程运作的类库。但是这些复杂的工具，无疑都是证明了多线程对于内存使用上的问题。

同时排多条队就是并行
由于多线程还是有一定的缺点，所以很多程序员想到了一个釜底抽薪的方法：使用多线程往往是因为阻塞式的存在，比如一个操作会一直停止当前线程，那么我们能不能让这些操作变成不阻塞呢？——就是退出的非阻塞式。如果我们使用了非阻塞的操作函数，那么我们也无需用多线程来并发的等待阻塞结果。我们只需要用一个线程，循环的检查操作的状态，如果有结果就处理，无结果就继续循环。这种程序的结果往往会有一个大的死循环，称为主循环。在主循环体内，程序员可以安排每个操作事件、每个逻辑状态的处理逻辑。这样既无需在多线程间切换，也无需处理复杂的并行数据锁的问题——因为只有一个线程在运行。这种就是被称为“并发”的方案。

服务员兼了点菜、上菜就是并发
实际上计算机底层早就有使用并发的策略，我们知道计算机对于外部设备比如磁盘、网卡、显卡、声卡、键盘、鼠标，都使用了一种叫“中断”的技术，早期的电脑使用者可能还被要求配置号。这个中断技术的特点，就是不会阻塞的一直停在等待外部设备数据的状态，而是外部数据准备好后，给发一个“中断信号”，让转去处理这些数据。非阻塞的编程实际上也是类似这种行为，不会一直阻塞的等待某些的调用，而是先处理其他逻辑，然后每次主循环去主动检查一下这些操作的状态。
多线程和异步的例子，最著名就是服务器领域的和的模型。是多进程多线程模型的，它会在启动的时候启动一批进程，作为进程池，当用户请求到来的时候，从进程池中分配处理进程给具体的用户请求，这样可以节省多进程线程的创建和销毁开销，但是如果同时有大量的请求过来，还是需要消耗比较高的进程线程切换。而则是采用技术，这种非阻塞的做法，可以让一个进程同时处理大量的并发请求，而无需反复切换。对于大量的用户访问场景下，会存在大量的进程，而则可以仅用有限的进程比如按核心数来启动，这样就会比节省了不少“进程切换”的消耗，所以其并发性能会更好。

的固定多进程，一个进程异步处理多个客户端

的多态多进程，一个进程处理一个客户
在现代服务器端软件中，这种模型的运维管理会更简单，性能消耗也会稍微更小一点，所以成为最流行的进程架构。但是这种好处，会付出一些另外的代价：非阻塞代码在编程的复杂度变大。

相关推荐上一篇 高性能服务器架构思路 二 —— 缓冲清理策略下一篇 高性能服务器架构思路 四 —— 编码复杂度和通信导语：时下音乐酷狗音乐等似乎让用户觉得它比任何人都更懂得自己的音乐口味，会为用户推荐喜欢的歌曲，每一次都充满了。本文作者 将通过介绍音乐推荐始祖的音乐推荐系统及算法，带大家一探其中究竟。

每个周一，数亿的用户会在上看到一个全新的音乐推荐列表，这是一个包含了首歌曲的自定义混音专辑，被称为“ 每周发现”，这里边的音乐都是你未曾听过的，但基本上都是你喜欢的。
我是的忠实粉丝，尤其是“每周发现”。 为什么这么说？因为它令我觉得它比任何人都更懂得我的音乐口味，每周都会为我推荐喜欢的歌曲，并且都是我自己从来不会发现的歌曲，每一次都充满了。

的“每周发现”播放列表  具体来说，是我的播放列表。
事实证明，不仅仅只有我自己中了“每周发现”的毒——很多用户都痴迷于此，这也促使彻底重新思考他们的产品焦点，将更多的资源投入到基于算法的推荐播放列表中。
下面是上两位网友的说法：
  _

   播放列表对我的了解是如此之深。就像一个以前与我一同经历过生死考验的情人一样。

   

在这一点上， 的“每周发现”非常了解我，以至于它推荐的音乐我都会喜欢。

自从年“每周发现”首次上线以来，我一直醉心于研究它是如何向人们推荐音乐的加上我是的狂热粉丝，所以有时候我喜欢假装我在那里工作，并且对他们的产品进行研究。经过三周疯狂的搜索之后，我终于非常幸运地了解到它背后的原理。
那么是如何每周为数亿用户推荐个性化歌曲的呢？让我们先简单地看下其他音乐服务是如何完成音乐推荐的，然后再了解如何更好地做到这一点。
在线音乐推荐的简史

早在年，就开始使用人工推荐的方式进行在线音乐推荐，并为用户创建播放列表。“人工推荐”意味着一些“音乐专家”或其他推荐人要手动把那些他们认为听起来不错的音乐放到同一个播放列表里后来， 也采用了同样的策略。人工推荐工作是没错的，但它需要手动操作，因此无法考虑每位听众个人音乐品味的细微差别。
像一样，也是音乐推荐的原始玩家之一。它没有手动标记歌曲的属性，而是采用了更先进一点儿的方法。即先让一群人听音乐，为每个曲目选择一堆描述性的词，并用这些单词把曲目标记起来。然后，的代码可以简单地筛选某些标签来制作相似音乐的播放列表。
大约在同一时间，来自麻省理工学院媒体实验室的音乐情报机构“ ”诞生了，并且提出了一种更加先进的方式进行个性化音乐推荐。 使用算法分析音乐的音频和文本内容，从而得以进行音乐识别，个性化推荐，播放列表创建和分析。
再往后，采用了另一种不同的方法，到今天仍然存在，他们使用了叫做协作过滤的过程来识别用户可能喜欢的音乐。
所以如果上面这些就是其他音乐推荐服务的做法，那是怎样实现神乎其技的推荐引擎，并且似乎比任何其他服务都更准确地戳中了个人用户的口味的呢？
的种推荐模型
实际上并没有使用一个革命性的推荐模型，而是将其他服务使用的一些最佳策略混合在一起，从而创建自己独特而又强大的发现引擎。
为了创建“每周发现”，采用以下三种主要类型的推荐模型：
协作过滤模型即最初使用的模型，通过分析您的行为和其他人的行为来工作。自然语言处理模型，通过分析文本工作。音频模型，通过分析原始音轨本身进行工作。

图片来源： ，
下面，让我们来深入了解这些推荐模式的运作方式！
推荐模型＃：协同过滤
首先需要了解一些背景：当许多人听到“协同过滤”这个词时，他们首先想到的是，因为他们是首先使用协作过滤来构建推荐模型的公司之一。他们通过使用用户的星级电影评分来了解该把什么电影推荐给其他相似的用户。
在将“协同过滤”成功应用之后，这个算法的使用速度迅速扩大，现在通常被认为是任何想要构建推荐模型的人的入门算法。
不像，没有让用户对音乐进行星级评价。相反，所用的数据是隐含的反馈  具体来说，我们收听的曲目的流数，以及额外的流数据，包括用户是否将曲目保存到自己的播放列表中，或者在收听后访问了歌手页面等等。
但是什么是协同过滤呢，它是如何的发挥作用的呢？ 这是一个更高层的抽象，我们现在把它画在下面的这张图里：

   
看懂这张图了吗？ 这两个人中的每一位都有一些音乐的偏好  左边的人喜欢音乐，，和 右边的人喜欢音乐，，和
通过协同过滤对数据分析后，初步得出这样的结论：
嗯。 你们都喜欢三首相同的音乐——，和 ——所以你们可能是类似的用户。因此，你们每个人都有可能喜欢另一个人听过而你还没听过的其他曲目。
因此，我们建议右边的那个人听一下歌曲，左边的那个人听一下音乐。很简单，对吧？
但是如何在实际操作中使用这一概念来根据数百万其他用户的偏好计算他们的的建议曲目的呢？
…数学矩阵，用库就能完成！ 

实际上，上图的这个矩阵是非常巨大的。 每一行都代表的亿用户之一如果您使用，您可以想象，自己就是此矩阵中的一行，并且每列代表数据库中的万首歌曲之一。
然后，库会运行这个漫长而复杂的矩阵分解公式：

一些复杂的数学
计算完成时，我们就会得到被和表示的两种类型的向量。其中是用户向量，表示单个用户的口味，是表示单个歌曲的资料的歌曲向量。

用户歌曲矩阵产生两种类型的向量：用户向量和歌曲向量。
现在我们有亿个用户向量  每个用户就是其中一行  以及万个歌曲向量。这些向量的实际内容只是一堆数字，它们本身是无意义的，但把它们相互一比较就非常有意义了。
要找到哪些用户的口味和我最相似，协作过滤算法会将我的向量与所有其他用户的向量进行比较，最终揭示与我最相似的用户。向量也是一样，歌曲  您可以将歌曲的矢量与所有其他歌曲矢量进行比较，并找出哪些歌曲与您正在查看的歌曲最相似。
协同过滤算法的效果其实已经相当不错了，但为了做得更好还添加了另一个推荐引擎——。
推荐模型＃：自然语言处理
采用的第二种推荐模型是自然语言处理模型。这些模型的源数据，顾名思义，是常规的字词 – 歌曲元数据，新闻文章，博客和互联网上的其他文字。

自然语言处理 – 代表了计算机理解人类语言的能力  是一个庞大的领域，通过情感分析来实现。 
背后的确切机制超出了本文的范围，并且下面我们介绍的这些场景都是在很高层次上发生的事情：会不断地浏览网页，不断寻找和音乐有关的博客或其他书面文字，了解人们对特定的艺术家和歌曲谈论的内容——即对这些歌曲经常使用什么形容词和语言，还会讨论哪些其他艺术家和歌曲。
虽然我不知道如何选择处理其数据的细节，但我可以告诉您 如何与之合作。他们会把它们搜集到他们所谓的“文化向量”或“根词汇”中。每个艺术家和歌曲都有数以千计并且每天都在更新的“根词汇”。每个词都有一个权重相关联，它揭示了描述的重要性粗略地说，权重代表了人们用这个词描述音乐的概率。

 使用的“文化向量”或“根词汇”。表格来自 
然后，就像协同过滤算法一样，模型使用这些词汇和权重来创建歌曲的向量表示，可以用来确定两段音乐是否相似。听起来酷毙了，是不是？
推荐模型＃：原始音频模型

这里有个问题，首先，你可能会在想：但是，亲爱的，我们已经从前两个模型里搜集到了这么多数据！为什么还要在费劲儿分析音频本身呢？
嗯…首先，加上第三个模型可以进一步提高这个推荐服务的准确性。但实际上，使用这种模型还考虑到一个次要目的：与前两种模型类型不同，原始音频模型可以用来发现新歌曲。
例如，你的歌手作曲家朋友在上传了一首歌曲，但可能只有个听众，所以很少有其他听众通过协同过滤算法发现它。它也没有在互联网上的任何地方被提到，所以模型也不会接受它。幸运的是，原始音频模型并不会在意一首歌到底是新的曲目还是流行的曲目，所以在这个算法的帮助下，你朋友的歌曲就可以和其他流行歌曲一起被选择出现在 的播放列表里！
好，解决了为什么的问题，现在我们来探究一下它的原理——我们如何分析原始的音频数据，这似乎听起来很抽象。
方法就是卷积神经网络！
卷积神经网络就是面部识别背后的支撑技术。但在中，它们被进行了相应的修改，以处理音频数据，而不再是图像数据。下图是一个神经网络架构的例子：

图片来源： 
这个特定的神经网络有四个卷积层，即左边的四个宽条，和三个全连接层，即右边的三个窄条。输入是音频帧的时间频率表示，然后将它们进行级联以形成频谱图。
音频帧通过这些卷积层，在最后一个卷积层之后，您可以看到一个“全局时序池化”层，它对整个时间轴进行池化，可以有效地计算歌曲整个时间内学习到的特征的统计。
在处理之后，神经网络会输出对歌曲的分析结果，包括像估计的拍子记号，调，模式，速度和响度等特征。以下是 乐队的作品“  ”秒摘录的数据。

图片来源： 和   
最终，对这首歌曲的主要特征的分析使得能够了解歌曲之间的基本相似之处，从而使得用户可以基于自己的播放历史欣赏相似的歌曲。
下面这张图涵盖了为推荐管道提供的三种主要类型的推荐模型的基础知识，并最终为“每周发现”播放列表提供建议！

当然，这些推荐模型最终都要连接到的更大的生态系统中，其中包括大量的数据存储，使用大量的集群来扩展建议，并使这些算法引擎对巨型矩阵，无尽的互联网音乐文章和大量的音频文件进行计算。
我希望这篇文章提供的信息量可以足够丰富，并且我的介绍可以激起你的好奇心。现在，我要去看自己的“每周发现”啦，找到我最喜爱的音乐，了解并体会这些场景下用到的所有和机器学习有关的知识。 
另外，推荐我的，包括相关代码和我的一些其他文章和项目
参考资料：
从想法到执行：的每周发现 ，
的协同过滤 ，
通过深度学习推荐音乐 
音乐推荐何时起效 – 何时失效“回声巢”联合创始人布莱恩·惠特曼 
每周发现如何实现？数据科学镀锌
每周发现播放列表如何创造奇迹
 ’分析文档

作者： ，软件工程师，作家。个人主页 原文地址：文章来源： 科技大本营微信号：作者介绍：黄日成，手游戏中心后台开发，腾讯高级工程师。从事服务后台开发年多，主要负责手游戏中心后台基础系统、复杂业务系统开发，主导过手游戏公会、企鹅电竞对战系统等项目的后台系统设计，有丰富的后台架构经验。

引言
作为文章“《从三次握手说起：浅析协议中的疑难杂症》”的姊妹篇，很早就计划写篇关于的文章，尽管协议远没协议那么庞大、复杂，但是，要想将描述清楚，用好却要比难不少，于是文章从下笔写，到最终写成，断断续续拖了好几个月。
对应系列的上一篇：《告知你不为人知的：连接性和负载均衡》
 疑难杂症
 的传输方式：面向报文
面向报文的传输方式决定了  的数据发送方式是一份一份的，也就是应用层交给  多长的报文， 就照样发送，即一次发送一个报文。那么的报文大小由哪些影响因素呢？  数据包的理论长度是多少，合适的  数据包应该是多少呢？
  报文大小的影响因素，主要有以下个
 协议本身，协议中有位的报文长度，那么报文长度不能超过=。
 以太网数据帧的长度，数据链路层的最大传输单元。
 的发送缓存区大小
 数据包最大长度
根据  协议，从  数据包的包头可以看出， 的最大包长度是的个字节。由于包头占个字节，而在层进行封装后的包头占去字节，所以这个是数据包的最大理论长度是       = 字节。如果发送的数据包超过字节，或函数会错误码  ，   ，当然啦，一个数据包能否发送字节，还和发送缓冲区大小下发送缓冲区大小为： _相关，如果发送缓冲区小于字节，在发送一个数据包为字节的时候，或函数会错误码  ，    。
 数据包理想长度
理论上  报文最大长度是字节，实际上发送这么大的数据包效果最好吗？我们知道是不可靠的传输协议，为了减少  包丢失的风险，我们最好能控制  包在下层协议的传输过程中不要被切割。相信大家都知道这个概念。  最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系， 帧的结构          由于以太网传输电气方面的限制，每个以太网帧都有最小的大小字节，最大不能超过字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。由于以太网  最大的数据帧是字节，除去以太网帧的帧头目的  地址=源  地址=域和帧尾校验部分那么剩下承载上层协议的地方也就是域最大就只能有字节这个值我们就把它称之为。在下层数据链路层最大传输单元是字节的情况下，要想层不分包，那么数据包的最大大小应该是字节 – 头字节 – 头字节 = 字节。不过鉴于上的标准值为字节，所以建议在进行的编程时，最好将的数据长度控制在 字节以内。
 数据包的发送和接收问题
 的通信有界性
在阻塞模式下，的通信是以数据包作为界限的，即使端的缓冲区再大也要按照发包的次数来多次接收数据包，只能一次一次的接收，发送多少次，就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。
 数据包的无序性和非可靠性
依次发送、、三个数据包，端先后调用次接收函数，可能会依次收到、、次序的数据包，收包可能是、、的任意排列组合，也可能丢失一个或多个数据包。
 数据包的接收
发送两次数据，第一次 字节，第二次字节，端阻塞模式下接包，第一次  ，收到是 ，还是，还是，还是其他？

由于通信的有界性，接收到只能是或，又由于的无序性和非可靠性，接收到可能是，也可能是，也可能一直阻塞在调用上，直到超时返回也就是什么也收不到。

在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，端阻塞模式下接包，先后三次调用： ， ， ，接收情况如何呢？

由于通信的有界性，第一次 将接收第一个字节的数据包，但是因为用户空间只有字节，于是只会返回前面字节，剩下字节将丢弃。第二次 将返回字节，第三次 将会阻塞。

 包分片问题
如果是，发送一个字节大小的包，那么端阻塞模式下接包，在不丢包的情况下，是收到，还是。如果某个分片丢失了，，又返回什么呢？根据通信的有界性，在足够大的情况下，接收到的一定是一个完整的数据包，数据在下层的分片和组片问题由层来处理，提交到传输层一定是一个完整的包，那么将返回。如果某个分片丢失，里有个检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以是不可靠的传输协议，那么将阻塞。
 丢包问题
在不考虑下层层的分片丢失，检验包不完整的情况下，造成丢包的因素有哪些呢？
  缓冲区满造成的丢包
通过  _ 和 _可以查看缓冲区的缺省值和最大值。如果缓冲区满了，应用程序没来得及处理在缓冲区中的包，那么后续来的包会被内核丢弃，造成丢包。在缓冲区满造成丢包的情况下，可以通过增大缓冲区的方法来缓解丢包问题。但是，如果服务已经过载了，简单的增大缓冲区并不能解决问题，反而会造成滚雪球效应，造成请求全部超时，服务不可用。
  缓冲区过小造成的丢包
如果发送的报文很大，而缓冲区过小无法容下该报文，那么该报文就会丢失。
 缓存过期导致丢包
 的缓存时间约分钟， 缓存列表没有对方的  地址或缓存过期的时候，会发送  请求获取  地址，在没有获取到  地址之前，用户发送出去的  数据包会被内核缓存到 _ 这个队列中，默认最多缓存个包，多余的  包会被丢弃。被丢弃的  包可以从 _ 的最后一列的 _ 看到。当然我们可以通过    _ 来增大可以缓存的  包。
 的丢包信息可以从   的最后一列中得到，而倒数第四列  是丢失  数据包的  的全局唯一的虚拟节点号，可以通过这个  号结合      |  来查到具体的进程。
 冗余传输
在外网通信链路不稳定的情况下，有什么办法可以降低的丢包率呢？一个简单的办法来采用冗余传输的方式。如下图，一般采用较多的是延时双发，双发指的是将原本单发的前后连续的两个包合并成一个大包发送，这样发送的数据量是原来的两倍。这种方式提高丢包率的原理比较简单，例如本例的冗余发包方式，在偶数包全丢的情况下，依然能够还原出完整的数据，也就是在这种情况下，的丢包率，依然能够达到的数据接收。

 真的比要高效吗
相信很多同学都认为无连接，无需重传和处理确认，比较高效。然而在大多情况下并不一定比高效，发展至今天，为了适应各种复杂的网络环境，其算法已经非常丰富，协议本身经过了很多优化，如果能够合理配置的各种参数选项，那么在多数的网络环境下是要比更高效的。
 影响高效因素
 无法智能利用空闲带宽导致资源利用率低一个简单的事实是并不会受到的影响，只会影响下层的分片，对此一无所知。在极端情况下，每次都是发小包，包是的几百分之一，这样就造成包的有效数据占比较小头的封装成本；或者，每次都是发巨大的包，包大小的几百倍，这样会造成下层层的大量分片，大量分片的情况下，其中某个分片丢失了，就会导致整个包的无效。由于网络情况是动态变化的，无法根据变化进行调整，发包过大或过小，从而导致带宽利用率低下，有效吞吐量较低。而有一套智能算法，当发现数据必须积攒的时候，就说明此时不积攒也不行，的复杂算法会在延迟和吞吐量之间达到一个很好的平衡。
 无法动态调整发包由于没有确认机制，没有流量控制和拥塞控制，这样在网络出现拥塞或通信两端处理能力不匹配的时候，并不会进行调整发送速率，从而导致大量丢包。在丢包的时候，不合理的简单重传策略会导致重传风暴，进一步加剧网络的拥塞，从而导致丢包率雪上加霜。更加严重的是，的无秩序性和自私性，一个疯狂的程序可能会导致这个网络的拥塞，挤压其他程序的流量带宽，导致所有业务质量都下降。
 改进的成本较高可能有同学想到针对的一些缺点，在用户态做些调整改进，添加上简单的重传和动态发包大小优化。然而，这样的改进并比简单的，编程可是比要难不少的，考虑到改造成本，为什么不直接用呢？当然可以拿开源的一些实现来抄一下例如：，或者拥抱一下的协议，然而，这些都需要不少成本的。上面说了这么多，难道真的不该用了吗？其实也不是的，在某些场景下，我们还是必须才行的。那么的较为合适的使用场景是哪些呢？
 的使用场合
 通信实时性和持续性
在分组交换通信当中，协议栈的成本主要表现在以下两方面：
 封装带来的空间复杂度； 缓存带来的时间复杂度。
以上两者是对立影响的，如果想减少封装消耗，那么就必须缓存用户数据到一定量在一次性封装发送出去，这样每个协议包的有效载荷将达到最大化，这无疑是节省了带宽空间，带宽利用率较高，但是延时增大了。如果想降低延时，那么就需要将用户数据立马封装发出去，这样显然会造成消耗更多的协议头等消耗，浪费带宽空间。
因此，我们进行协议选择的时候，需要重点考虑一下空间复杂度和时间复杂度间的平衡。通信的持续性对两者的影响比较大，根据通信的持续性有两种通信类型： 短连接通信  长连接通信。对于短连接通信，一方面如果业务只需要发一两个包并且对丢包有一定的容忍度，同时业务自己有简单的轮询或重复机制，那么采用会较为好些。在这样的场景下，如果用，仅仅握手就需要个包，这样显然有点不划算，一个典型的例子是查询。另一方面，如果业务实时性要求非常高，并且不能忍受重传，那么首先就是了或者只能用了，例如 协议，重传消息纯属添乱为什么呢？重传一个过期的时间包过来，还不如发一个新的包同步新的时间过来。如果协议采用，撇开握手消耗较多数据包交互的问题，由于受算法等影响，用户数据会在一定情况下会被内核缓存延后发送出去，这样时间同步就会出现比较大的偏差，协议将不可用。
 多点通信
对于一些多点通信的场景，如果采用有连接的，那么就需要和多个通信节点建立其双向连接，然后有时在环境下，两个通信节点建立其直接的连接不是一个容易的事情，在涉及穿越的时候，协议的无连接性使得穿透成功率更高原因详见：由于的无连接性，那么其完全可以向一个组播地址发送数据或者轮转地向多个目的地持续发送相同的数据，从而更为容易实现多点通信。一个典型的场景是多人实时音视频通信，这种场景下实时性要求比较高，可以容忍一定的丢包率。比如：对于音频，对端连续发送、、三个包，另一端收到了和，在没收到的保持的最后一个音也是为什么有时候网络丢包就会听到嗞嗞嗞嗞嗞嗞…或者卟卟卟卟卟卟卟卟…重音的原因，等到到就接着播了，不需要也不能补帧，一补就越来越大的延时。对于这样的场景就比较合适用了，如果采用，那么在出现丢包的时候，就可能会出现比较大的延时。
 使用原则
通常情况下，的使用范围是较小的，在以下的场景下，使用才是明智的。
 实时性要求很高，并且几乎不能容忍重传；例子：协议，实时音视频通信，多人动作类游戏中人物动作、位置。
 实在不方便实现多点传输的情况；
 需要进行穿越；
 对网络状态很熟悉，确保网络中没有氓流行为，疯狂抢带宽；
 熟悉编程。
参考资料

文章来源公众号 小时光茶社 


相关推荐告知你不为人知的：连接性和负载均衡网站及服务器疑难杂症处理从三次握手说起：浅析协议中的疑难杂症年月日，项目正式启动，并在同年月日举行的会议上开源。一年过去了，两个人，的工作时间。总的来说，填了一些坑，获得少许成绩，也遭受不少批评。究竟是否将已经很糟糕的  的生态变得更差，会不会对用户的安全造成更大的挑战？
回想的初心，我们希望开发者可以用很小代价进行快速升级，它是国内追求快速迭代诉求。立项至今，踩了很多坑也填了很多坑。今天，我希望跟大家分享这一年来我们遇到的一些问题，以及解决它们的思路与过程。
的现状
首先在回顾过去之前，我想先简单的介绍一下的现状。
开源的现状
的开源地址为：。 它作为的第一个开源项目，也让第一次在周排名第一。微信也在持续使用，并且我们承诺与外部开发者使用同样的开源版本。不仅如此，在应用宝 的应用中，有多个应用已经使用了，使用第三方平台接入并持续使用的应用也超过个。

生态的现状
使用的开发者数是一方面，更令人振奋的是，初步建立了它自己的小生态。
一 热修复服务平台
个人感觉热补丁不是请客吃饭，如果不了解它，直接使用它可能会造成更大的问题，所以在一些接入上面，的确人为的增加了难度。

热修复不是请客吃饭

对于某些的产品来说并不一定成立，它们希望无论客户端、后台都有一整套的服务，它只要：

一行代码，快速接入

当前  与  都基于提供了热修复的一站式服务，降低了许多开发者的工作。
二 厂商
受益于微信的产品影响力，我们与、、、小米、一加、联想等厂商都建立了紧密的联系。他们不仅帮助我们解决了许多兼容性问题，每次升级，厂商也会帮忙做相关兼容性的测试。更重要的是的出现与推广使得厂商在系统定制改造时也会考虑到是否会影响热修复。
同时我们一直极力反对厂商对微信做定制的优化，我们希望在框架内能够解决，所有的用户所有的产品表现是一致的。在这一年来，的确十分感谢厂商的帮助与支持。
三 加固
对于许多开发者，它们因为各种各样的原因必须要使用加固。首先在版本我们通过回退的方案支持加固，但是发现市面上各种的加固实现差异非常大，且对我们是黑箱。最终在版本取消了对加固的支持。最近我们联合乐加固、、爱加密等加固厂商，一起讨论协商了支持热修复的加固方案。最终我们商定如下规则：
、不能提前导入类；、在平台若要编译文件，需要将内联取消。
我们并不想让它们仅仅支持，我们希望整个生态是健康的，其他的热修复方案也应该被支持。随着加固厂商陆续发布了新版，在版本也可以很好的支持上述加固厂商。
此外我们也看到有一些基于衍生的开源项目，例如 、、等。
跪着走完的路
一个开源项目不仅仅是一堆源码，更像一个产品。这里需要很多技术之外的努力，与第三方平台、厂商沟通，争取加固厂商的支持等等。但是技术本身才是最大的影响因素，我们一直坚持使用最大的努力去保证质量。下面简单回顾一下这一年遇到的一些比较有代表性的问题。大家可能不一定会遇到，希望解决问题的思路与过程会对你们有所启发。
一、方案在与的问题分析
方案在与的问题是我们在热修复道路上第一个比较大的挑战，也是我们启动项目的主要原因。详细分析可以参考微信热补丁实践演进之路。
以地址偏移的例子来说，当时我们某次补丁发现在的机器线上发现以下的一个：

对应的路径对应代码是一个 对象为空，这非常颠覆我们的认知。
   = 
但是这个问题只有补丁存在的情况会出现，如何去定位与分析？
、增加日志；通过增加日志，我们发现整个调用流程并没有问题，但是访问这个变量的时候还是会出现。
、查看源码；在 之后，推出了，它在的时候提前生成机器码，提升运行速度。我们怀疑补丁有可能造成访问了错误的地址，但是过程并不容易。相关的代码比复杂很多，我们大约花了一周时间才把相关的代码研究了一遍，的确发现了可疑的路径。
、编证实；如何证实？我们通过自己编译并增加相关的日志，为了看清对象内存排列，还把内存地址出来。最后发现地址的确错乱了，错误的调用了  变量。
这个经历告诉我一个道理，在使用一个方案之前，需要知其然以及所以然。同时也给我们很大的信心，让我们坚信只要能复现都是可以找到原因的。
二、 混合编译问题
 的问题是在 版本解决，对这个问题的详细分析可以参考 混合编译与对热补丁影响解析。
这个问题源于华为在 内测过程给我们提的一个：

这个问题只在 出现，但是在本地却无法复现。首先我们怀疑一定与 的某些变更相关，对虚拟机部分重大的变化是默认打开了，并使用了混合编译模式。通过跟工程师与华为负责的工程师讨论沟通，比较确认是这块的变动导致的。怎么样去解决？
、查看源码；一定要带着目标去阅读源码，不然容易被庞大的代码淹没。因为有了之前的基础，这里大约花了天时间也大致知道原因。在本地通过生成全量的成功复现。
、问题解决；这里提出了几种方案，最后采用了替换的方式。不得不说，这个方案并不完美，对启动时间也造成了部分影响。
在 出来之后，我们惊奇的发现的指针移到上层，我们也在尝试其他的方式去规避的影响。这个问题给我比较大的体会是解决问题时不能拘泥于现象，从一些可疑的点出发，尝试本地去构造复现的场景。
三、的内联导致
内联的问题对的影响是非常巨大的，这个问题在 版本解决，对它的详细分析可以参考下的方法内联策略及其对热修复方案的影响分析。
问题的发现首先是线上出现下面的一个：

这个与之前地址偏移的问题非常像，当时我们还在使用分平台合成。这里首先怀疑是我们某些类没有正确的打入或者没有生效，通过查看出现异常代码的机器码，我们发现是因为虚拟机内联导致出现类似地址错乱的问题。
因为这个问题，我们忍痛将之前花费一个多月实现的分平台合成废弃，强制使用全量覆盖的方式。但是这个也带了另外一个严重问题，即厂商之后导致的启动过慢，甚至的问题，这里在后面会详细说明。
四、华为微信双开导致
这个问题在 版本发现，在某次补丁，我们发现在华为部分 的机器会出现以下的：

这个问题只在华为的部分机器出现，而且量的占比并不大。当时的解决思路主要分为以下几步：
、我们怀疑是华为修改了部分虚拟机的逻辑导致的，经过跟华为工程师的沟通了解，这个怀疑点初步排除。
、找到相同固件的手机，但是并不重现。这个问题外部用户并没有反馈，所以怀疑可能是某些对微信特殊的逻辑导致。在手机的设置中，发现微信分身的设置。呵呵，年轻人你很大嫌疑。
、补丁后，再开启分身，问题的确重现了。原因是华为分身时没有将所有路径都映射，导致分身没有读取补丁路径的权限。补丁由于安全模式被清除，导致主号出现上面的异常。
把问题报给华为的工程师后，在新版将这个问题解决了。这个问题的难度在于如何构造复现场景，如何将跟微信分身关联起来。当时考虑的点主要是这个问题只在非常少部分的机器出现，这些人非常可能使用了特殊的功能。到此我们依然坚信，只要能复现，一切都好说。
五、 异步问题
这个问题在 版本发现，并在 版本解决。系统的实现是会阻塞调用线程，为了加快调用，先使用解释模式执行，然后异步去生成文件。
这个问题会导致我们以为文件已经生成，事实上并没有。修改的方案一是跟他们沟通，希望他们不要对微信做这个特殊的优化，然后是补丁合成时需要等待文件真正有效的生成。
厂商的这个思路对我们后来解决的问题有着一定的启发。
六、 算法有效性与性能优化
算法非常复杂，若有兴趣可以查看 算法解析与 会议 。
我们也非常害怕它出问题，所以做了一套验证流程与方案：
、通过固定、、随机生成个互相做与验证；
、为了更加真实，使用微信最近个版本的，随机选择两个出来做与验证；
、还是不敢保证？在编译的时候提前验证最终的合法性，即使出现问题，只能编译不出来补丁包，而不能影响线上用户。
在有效性之外，我们还做过几轮的内存与耗时优化，具体可以查看版本的提交。我坚信我们要用科学的态度去研究问题，所以在线上我对加了个监控上报，每个问题每个更改都会去总结分析线上的数据。
七、 之前的问题
这个问题在 解决。有厂商反馈在它们的某台的机器，微信在补丁后有一定的概率出现。
拿到厂商快递的机器之后，在补丁后连续进入一个群次以上，的确会出现。根据之前的经验，如果是经过一段时间才出现问题，跟应该是有关的。查看了这台手机的配置，的确是打开了，事实上之前都是默认关闭的，这只是一个实现中功能。询问了厂商，这个打开其实是某个开发在过程无意打开的，如何解决？
事实上，所有的热修复方案可能都会踩中这个问题。这部分的用户并不多，灰度人，只有人在之前打开了。具体的解决方法是过滤掉 之前开启的机器，详细的解决代码可参考 的。
八、损坏问题
损坏事实上会出现在任意动态加载过程，这个问题在 解决。在线上我们有时候会发现部分用户会出现等奇怪的，之前一直不知道原因。
  指的可能是由于文件异常导致，通过提取部分用户的文件，我们发现该文件的确偏小，而且不是合法的文件。
解决方案是在结束时检测补丁生成的文件是否为合法的文件。具体的检测方法可参考文件。同样灰度人，出现异常的有人，大约概率。若出现这种情况，我们需要删除非法的文件，重新执行。
九、厂商后应用启动耗时问题
在系统后，旧的补丁的文件都已经过期。系统会在首次加载时，会重新执行。这导致可能会在前台等待很长的时间，甚至出现。这也是在某次会议上点名批评的最大原因。
事实上，我们并非没有努力过。更早的时候，我们花费了个多月的时间实现了分平台合成方案。即在合成全量的，在合成一个小的。同一个输入，生成不同的并且合法的输出。这个的确不容易，我们也是踩过无数的坑，无数次尝试才实现。但是由于的内联问题，这个方案需要废弃。
还有什么样的方案？这个时候，厂商给我们抛出橄榄枝，可以给微信做单独的优化：
、在系统升级时，帮助微信把目录的文件重新做、首次调用补丁时，采用类似的异步策略。
但是个人坚决反对这些特殊的优化，如果没有做定制的厂商怎么办？外部使用的应用怎么办？这不是一个非常良好的选择。如何解决：
、回退版本；检测到厂商之后，我们立刻删除补丁，然后再在后台异步重新做。这个方法非常简单，看起来也的确可以解决的问题，但大范围的回退版本是否会造成更大的问题，尽管只是短暂的回退。假设我某次补丁修改了某些数据库的结构？所以这个方案是不能采用的。
、弹等待框；看起来厂商的间隔不会非常频繁，如果使用等待框的方式用户也可以接受。这个我们采用的方案是当检测到系统后，使用单独的进程去展示等待框。看起来好像没问题，但是这个有个非常大的问题，当主进程超过的时候，一样会由于 被系统杀死。这个方案在中提交，很快被删除了。但是这套代码其实可以应用在的多加载，大家可以参考一下。
解释执行；受异步执行启发，我们是否可以在的首次先使用解释模式执行文件，在后台再做异步的事实上，这也是我们最终采用的方案。但是这里要注意的细节其实非常多，如果判断解释执行成功，解释执行的命令参数如何拼写， 如何获取？大家可以参考这个。
事实上，往往大家看到的是我们在尝试多个方案，踩过各种坑后的结果。但是过程也是很重要，对我们解决问题的思路与经验的积累都有着非常大的帮助。
十、资源相关的问题
上面讲的都是相关的一些问题，但是资源相关的问题也是非常多的。例如：
、一些厂商的适配 ；、如何检测或者是否真正的补丁成功，通过自定义方法；、如何快速的合成资源补丁，这里通过研究格式，做到没有解压与压缩实现补丁的资源合成；、如何判断真正的内容修改？这里是通过重写去解析的内容，忽略结构、顺序、以及属性的影响；、的问题， 之后需要反射以及字段。
对于资源，感觉最大的挑战是小米的一个问题。在某次补丁后，我们发现在小米的手机会出现以下的：

这个问题只在小米出现，而且微信补丁了非常多次，为什么只有这次会出现？更加神奇的是，重启手机的第一次这个问题不会出现。从现象看来，似乎是资源错乱了。为什么会这样，有什么样的解决思路？
、寻求小米的帮助；这个问题应该跟的一些修改相关，询问了小米相关的开发人员。由于无法定位到具体的模块，无法得到进一步的帮助；
、看代码；将出现问题小米的提取出来，同样由于源码的范围太大，如果无法定位到相关的刻意模块。同样无法进一步分析；
、 函数分析；终于我们使用迫不得已的绝招，对出现问题的函数前后的系统函数一个个的。看究竟是在哪一个方法导致资源的读取错乱了。
最后我们发现，这个是在初始化时加载了错误的文件导致的。由于在加载自己的主题资源时使用自定义，所以这里拿出来的就非常有可能是之前用过的，导致后面调用的方法时逻辑与原生系统不一致。
这个问题只在补丁的时候增加资源的时候会出现，为什么重启的第一次没有问题？那是因为重启的第一次微信被拉起来，没有加载，所以也不会出现缓存的错乱问题。最后的解决方法也非常简单，资源补丁时直接清空的缓存即可。
十一、其他
厂商预加载的问题，的问题，冲突的问题…
回想起来，这的确是一条跪着走完的路。特别是被点名批评之后，我们也做了反思。解决的问题，限定的线程数，锁屏后去做补丁的合成，我们希望减少对用户的影响，与厂商共赢。
这一路走完，对我们的收获也是巨大。让我们坚信只要复现都应该可以找到原因，若无法复现，请创造一切条件复现。这个过程经验往往非常重要，而经验则需要我们不断的去尝试与总结。
没做好的事情
由于边幅问题，还有很多技术细节问题没有讲到。这个项目我们的确花了比较多的心血，特别是在年和我都有其他一些高优先级的工作，很多的工作都会放到晚上或者周末。但是尽管这样，还是有很多未完成的工作我们承诺会把这些坑填上，也欢迎大家一起来，比如：
、四大组件代理、启动保护
开源的本意就是希望和大家一起进步而不是闭门造车，衷心希望有更多的开发者可以与我们共同努力，可以让国内的开源环境变的更好。
致谢
有很多的用户对做出了各种各样的贡献，这里都会有一份小小的礼品感谢对腾讯开源的支持。当然我希望有越来越多的人可以加入到这个队伍，反馈社区。
感谢 的孙胜杰、百度的孙鹏飞、蘑菇街的往之谢国、的吴志伟、同城的赵聪颖、欧应科技的郭永平、的刘敏、滴滴的赵旭阳、华为的穆俊含谢小灵、的郝雄、小米的陶建涛等。


参考资料
关于更多的实现原理与技术细节，可以参考如下文章：
微信热补丁实践演进之路 混合编译与对热补丁影响解析  微信热补丁分享微信的一切都在这里，包括源码一 算法解析下的方法内联策略及其对热修复方案的影响分析 会议 格式查看工具作者简介：范怀宇，轻芒联合创始人，毕业于清华大学，前豌豆荚技术负责人，专注于移动开发十余年，曾出版《 开发精要》。爱研习好代码和设计，相信好的产品能改变生活，好阅读乐分享。

本文首次发表在《程序员》杂志年月期，已获《程序员》授权，版权归《程序员》所有，未经允许请勿转载。腾云阁已获得作者及《程序员》杂志授权转载此文。
 「轻芒小程序」是由轻芒团队提出的小程序解决方案，它将替内容创业者免费搭建属于自己的微信小程序。在进行「轻芒小程序」和其他小程序应用开发的过程中，本文作者与其团队对当前正火热的小程序开发有了更为深度的理解与认识，进而有了本文。

从小程序诞生伊始，就有很多人开始研习其机理与特点，从源代码或整体架构的角度已经有很多不错的文章会令人受益。但理论是一回事，真正理解小程序，还需要实践，才能进一步理解其背后的想法，与已有平台的异同，以及如何去适应它，做出更有趣的小程序。
理解开发平台的特性，一个不错的角度就是从编程模式入手，看在这个平台上开发，需要如何书写和组织自己的代码，进而搞清楚三个问题：

数据如何获取；
界面如何呈现；
交互如何传导。

换而言之，就是从 的视角去拆解这个平台的特性，从而理解其开发有何特点。
数据如何获取
程序的本质，可说就是数据的呈现和加工。所以，看一个客户端开发平台的基本能力，首先就要看能把哪些数据放在上面处理，有哪些局限？如果缺少了必要的数据获取方式，那对于开发者而言，巧妇也难为无米之炊。
从这点看，小程序提供的数据获取方式非常丰富，大概涵盖：

通过  请求去服务端获取数据。支持  是最基本的，小程序对  有限制，除了要求通信协议是 ，出现的域名必须提前预设之外，还将应用层协议限定到了  格式下。这一点，可能比任何一个已有客户端平台都更为严苛。站在小程序的平台角度来看，通过这样的协议规定，对应用中流动的数据有了更强的管控能力；而对于开发者而言，则需要花些时间去调整自己的服务协议以便适应小程序的要求。
可以在本地文件系统上存取数据。小程序提供了丰富的  供开发者在手机系统上存取文件。可用本地文件来做缓存、状态记忆等，为开发提供了便利。
可以读写设备中的一部分信息。小程序开放了一些 ，帮助开发者获得设备上的基本信息，比如手机型号、屏幕尺寸、网络状态等。较为有价值的是可以选择获取手机上的图片等多媒体文件，这给做图像应用提供了可能；并且，它还提供了罗盘、重力感应器、地理位置等信息，对开发者理解用户所处的环境大有裨益。

从上面的介绍不难看出，小程序中的数据获取方式，和一般浏览器提供的相仿也就是和  应用能获取的信息，比原生的客户端更局限一些，但对于绝大多数的应用而言足够用了。
除此之外，小程序提供了微信生态中的一些数据，比如账号信息等。这对于微信庞大的生态而言，只是非常小的一部分数据，但却是开发小程序应用中最值得利用的数据。
举个例子，在其他平台上，如果想要获取微信的账号信息，需要通过一次用户授权。假如用户暂时不想提供，则会使程序呈现“未登录”状态，给整个服务的展开带来困难。而在小程序中，只要用户点开，就意味着完成了授权，开发者可以直接读取到小程序的账号信息，并同步到自己的服务端作为该用户的身份标识，从而实现“始终登录”的状态，使得后续服务可以更好地提供。
一份可行的示例如下：
 先调用登录接口，获得请求码
{
       {
         获取到请求码，继续请求用户的基本信息
          = 
        {
               {                
                 获取到了加密的用户信息，去服务端解密并存储
                  =                 
                  = 
                {
                     _
                     {
                         
                        _ 
                         
                    }
                      {                        
                         在服务器上，解析并生成自己的账号验证信息
                          =                         
                          =                         
                         并且还可以存在本地存储上，供下次打开使用
                      {
                             _
                             
                      }
                    }
                }
            }
        }
    }
}
界面如何呈现
小程序刚发布的时候，一片人开始惊呼  的时代就要到来了，因为小程序在界面层使用了  这套  的技术栈。但很快，随着聪明的程序员们对小程序的理解进一步加深，就发现小程序所说的  和  中的完全不是一回事，其差异基本等同于  和 。
在小程序中，和  对应的是 ，保留下来的只有  的概念，而传统的、标签都完全被抛弃了。和  的  类似，小程序引入了自己的  标签，它和 〉、 这样的语义标签不同，小程序中的标签更像是传统客户端开发中的组件或者叫控件，每个组件都有自己背后的职能和使用方式。比如：如果需要展示图片，就只能用标签，其他的都无法承载。而如果需要提供可选的文本，则只能使用标签等。
这样的方式带来最大的问题就是传统的  页面都无法在小程序中呈现而小程序正好，没提供类似  的客户端控件。比如有大量的内容网站，其文章内容都是存储为一个  片段，无法直接呈现在小程序中。如果需要展示，一个思路是构建中间服务，将  转译成一种更简单利于渲染的中间格式数据，然后，在小程序端把中间格式的数据转换成小程序的标签进行呈现。我们在做“轻芒生活”的时候，正好设计并实现了一个转义服务，将任意一个  页面转换成中间格式内部名是 ，解决了内容性  页在小程序上的呈现问题，如图  所示。
图   在小程序中呈现  内容页
和  相比，小程序的  算是比较完整地保留了  的特征，这一点还蛮出乎意料。 在语义上最大的不同，一是在于它支持了相对尺寸单位  ，每  等价于当前设备的屏幕宽度，它的引入，把那种繁复的屏幕尺寸适配变得简单了不少。而和  的另一个不同是它更像传统控件样式用法，不支持  那么多的选择器，使用中更多的是一个控件一个 。
小程序中虽然支持  标准的 ，但窗口级的  却完全被废弃掉了，开发者无法用  去调用 、 对象来修改界面元素完成逻辑。小程序中的  其实直接对应  的用法，用来完成后台业务逻辑，而不是直接控制交互。小程序的这个设计，使其可以用到   的方式来渲染界面，让界面数据更新时的性能优化成为可能，但付出的代价就是少了窗口级  的那层胶水黏合，使得很多功能的开发变得极其呆板和繁复。
交互如何传导
所谓交互的传导，是当用户和界面发生交互时，平台框架通过何种方式告诉业务层，并将处理后的变化呈现回交互界面上。如果把    绘制的页面看成“前端”，把  撰写的业务逻辑看成“后端”，你会发现，小程序的前后端交互特别像   的模式，前端把交互行为封装成事件发送到后端，后端处理完成后，通过  方法将数据回传到前端，如图  所示。
图   小程序的交互传导
小程序提供的 ，基础的有类似单击、长按、触摸、滑动等，对于视频播放器等控件，还有监听播放、暂停等。这些事件比较基础，没有更高级的手势、多点触控等相关事件，但也还足够让开发者具体了解用户的输入，进而做出响应。 而小程序给界面响应的唯一方式，是通过  中的   对界面上的数据进行更新，小程序会比较两次调用期间数据的变化，来决策需要更新哪部分的交互界面。
举个实际的例子，假设开发者需要做一个滑动切换页面的效果，在小程序中该如何实现？首先，是将变量数据引入渲染页面：
 = = 
        ={{}}
        = =
        = =

可以看到， 是一个模版参数，它初始值为 ，表示移动的距离。通过  等函数绑定上  的方法，将事件回传。
  {
      = {
         
         
    }    
     处理各种事件，计算是否需要刷新，和移动方向
      ===  {
        开始计算移动
        
    }    ===  {        
        判定移动的距离是否足够
        
    }    ===  {        
        被打断就算了
        
    }    ===  {        
        计算移动距离
        
    }    
     根据移动的距离，来更新界面
      {
        {
             
        }
    }
}
而在  一端，则捕获事件、计算偏移量，然后将新的偏移量送到前端界面。
从这里可以看到，小程序的交互是典型的单向模式，前端回传事件，数据单向地推到前端，而不是通过类似“变量”、“状态”等方式来告知。这样的模式下，开发者对界面变化的控制往往不可能太精准，整个核心都依赖于小程序对两次数据变化的  计算，这将会最终影响整个交互的性能。
小程序开发模式的特点
至此，我们可以来总结一下小程序开发的一些特点了。整体来看，小程序是借了  的技术栈，行了传统客户端开发的模式，这一点和  等平台会比较相近，可以视为  的一个新分支。
从设计思路看，小程序做了大量的“限制”，最大的限制是开发者其实无法通过  这样的编程语言直接对界面进行控制，而是通过数据驱动来间接实现。这对于缺少开发经验的人而言，是有益的事情，因为降低了理解的门槛，但对于复杂的应用来说，这个模式开发起来比较呆板，往往是一个变化多处修改，增加了理解代码的成本。
开发小程序的坑
开发小程序的日子，也是一个踩坑的历程。简单总结，小程序中的坑大概来自这几个方面：

 兼容性。小程序引入了  作为技术栈，并在其基础上进行了定制。很多开发中的问题都来自于“定制”，因为你并不知道哪部分是被定制，哪部分是被继承了。比如，你用了一个  语法，发现并不生效，或者效果和浏览器中的不一样，于是，只能换一个写法，结果很有可能又会继续发现，这个新的写法可能效果也不对，于是只能继续尝试，如此反复，可能会消耗大量的时间。

开发环境不稳定。小程序的开发，是基于微信自制的 ，但当下， 的稳定性、易用性都非常差，时常出现 ，你以为是程序写错了，但其实，是  的 ，重启一下 ，一切都迎刃而解了。于是，当你日后开发小程序时出现某种异样，先重启 ，再看问题还在不在，也许是种更节省时间的方式。

缺少真机调试环境。小程序的运行时其实就是微信，微信几乎没提供任何真机上的调试工具也不能说完全没有，有一个只能在真机上瞪着眼睛看的日志框。在模拟器中调试好的程序，可能在真机上运行起来并不如预期。比如，我们碰到过真机上白屏、位置错乱、动画效果不对，以及  上至今还不能运行等问题。这对于稍微复杂的程序而言，颇为梦魇，想做一些细粒度的调整和优化，基本只能靠猜。

闭源且缺少学习资料。小程序整体上是闭源状态虽然模拟器和  部分可以通过反编译来看，且缺少足够的学习资料。如果一旦碰到控件如何使用、为什么这么用不对之类的问题，就只能靠不停地试来解决，也需要耗费大量时间。


简而言之，作为一个新的开发平台，微信小程序从本身的稳定性，以及配套的工具链上都不算完善。对于早期开发者而言，需要耗费额外的精力去尝试和探索，但这也许就是一个新平台的价值和代价吧。

相关推荐
一起脱去小程序的外套和内衣  微信小程序架构解析
【腾讯云的种玩法】元体验腾讯云小程序后端解决方案
从前端界面开发谈微信小程序体验线上运行的生产系统会定时采集一项丢包数据，这项数据与某个进程相关联，从进程启动开始就一直递增，每隔分钟采集一次数据，当进程重启之后，这项数据会清零。现在要求使用来统计某个时间段 内，多个进程此项数据的变化量汇总。可以看到数据形如以下形式。进程会通过分组，每个组内有多个进程，需要计算的是各组值的总的变化量。总数据量约为。
                            
                         
                         
                         
                         
                         
                         
                         
                         
                         
                         

粗看起来这个问题似乎很简单，因为数据量并不是很大，可以首先整个数据集，然后按照分组，在分组内对时间排序，计算最后一个与第一个的差值，然后再对分组将刚才计算出来的差值求和即可。仔细想想这是不行的，因为在每个分组内，本次时间片内的数据有可能因为进程重启而清零如下图，所以不能简单的按照时间排序后尾首相减来计算。

这种累积型数据的计算方式应该如下图，计算多个分段分别的值，最后汇总。

具体的算法也非常简单：

对数据集按照聚合
对于每个聚合子集，按照进行排序
对于排序过后的序列 _ _  ……  _ 计算： _ =  –  =    –   从最后一个开始，计算 –  的值并求和，当遇到差值为负的情况，也就是出现了进程重启清零的情况，就加零。
对聚合，求出一个分组下所有进程_的求和值。

上述算法很简单，用脚本可以很快搞定。但如果需要用任务来写，第个步骤就没有这么容易实现了。不过好在脚本可以调用其他语言编写的  来完成某些复杂的计算逻辑，我们就采用此种方案。如何使用实现 请参考官方文档

先来看脚本代码：
 __    
 
 
 

 =     = 
 =               
 =                      
 =   
              
              
              
              

_ =  
 =  _   
 =   {
     =  _   
    _ = ___
         
                   _  _
}
 =      
    {__}{__}  
      
    _  __

 =    __   
      
    {_}{_}{_} 
    {_} {_} 
       {_}   __    
我们选用来实现，主要是实现第步的逻辑，代码如下：

 ____
     = 
       _
           _  
             = _  _
              =  
                 =  
     作者：兰瑞
导语：空间陪伴大家走过了将近年的时光。时至今日，相册已经存储了超过万亿张图片，对比业界，可以说是当之无愧的中国第一大相册，也是世界上规模最大的图片类产品之一。本文从存储架构、容灾、加速等多方面对相册的架构进行了阐述。


空间，陪伴大家走过了将近年的时光。其中的相册，也和大家一路走来，记录下了很多中国人的成长瞬间。
时至今日，相册已经存储了超过万亿张图片，物理存储量。平均日增亿张图片，日用户浏览数达亿次。对比业界，可以说是当之无愧的中国第一大相册，也是世界上规模最大的图片类产品之一。
随着业务的发展，不仅用户看得到的页面样式在变，由腾讯架构平台部开发和运营的相册系统也经历了不断的优化。下面我们介绍一下相册的后台架构长什么样。
如果从头搭建一个小型的相册系统，我们通常想到的架构是这样的。

索引系统存放用户的相册列表和每个相册内的图片列表。文件系统存放实际的图片文件。
实际上最早的相册系统，就是直接用存储用户索引，文件系统存放图片文件。这是一个最简易的系统，能够满足少量的用户和基本的功能。在面对相册用户和请求量急速增长的过程中，部门针对性地研发了底层的存储系统家族引擎进行支撑。
索引
针对相册用户量大、读写频繁、操作数据小、需要支持平滑扩容等特点，推出了基于大容量的分布式存储平台。通过多副本保证数据可靠性，通过自研持久化存储引擎解决随机写性能瓶颈，结合与生俱来的随机读优势，使得具备出色的混合读写性能，单台峰值万次的读写。在支持高并发读写的同时， 独有的延时毛刺控制技术，使得运营中读写访问延时低于。
此外，针对用户行为进行分析，发现有大量的用户操作只是拉取相册和图片列表，并没有去查看图片的详细信息。对此，我们对用户索引进行了轻重分离，将列表所需关键信息和其他详细信息分开存储，大大降低了每次操作平均读写的索引数据块大小。
压缩
相册支持、、等主流图片格式，并且在保证图片质量的前提下不断尝试和使用压缩比更高的新格式。比如已经全面支持，比节约存储和带宽。目前正在推进使用公司自研图片格式，对比体积还减少以上。
为了应对超大并发量的压缩请求，我们搭建了几千台机器规模的压缩集群。并且这部分压缩集群大部分使用技术，和现有业务机器混用，显著节约了成本。对于时延敏感的场景，我们还推广使用了硬件压缩卡，耗时仅为机器的。这项能力目前也通过腾讯云对外开放。
园区分布
亿的相册用户被逻辑上划分到不同的园区，每个园区都有一套完整的服务。每个园区可以平滑扩容，园区也可以按需增加。

就近上传
为了保证索引信息的一致性，每个用户的完整索引信息最终只会保存在某一个特定园区。用户的园区归属信息是预先划分好的。比如一个用户的索引归属信息在上海，他在深圳出差期间，如果每次上传需要访问上海的服务器，延时将很高。
为此我们后台进行了就近上传的改造，用户上传图片时，会根据地域、运营商接入最近的上传园区，并就近落地图片数据。索引归属信息则由我们的在后台进行同步。很大程度提高了上传成功率，降低了响应时延。
异地容灾
当程序感知到某个园区发生网络故障等情况时，数据和索引可以写入备份点。多个园区之间形成了一个环状备份关系。

下载加速
在全国建立了个加速点，就近为用户提供下载服务。还建有香港和美国加速点，为海外用户提供加速。
预推送
根据对用户行为的分析，最近上传的图片访问量往往最大。为了给用户提供更好的下载体验，在用户上传相册后，我们会预先发送指令给加速点通知它们拉取图片进行缓存，当后续用户的好友进行访问时，能够快速加载，无需回源。
未来我们还会在提升服务质量和稳定性上继续努力，让网友们放心、便捷地使用相册来记录生活点滴。

文章来自：腾讯架构师学习资源
我的腾讯云主机预装了   ，截图如下：

两台主机通信实战
在上一篇我给大家介绍了《腾讯云上网络编程三之协议获得地址表》。
接下来我们让用户输入要发送的  地址和要发送的数据
_ 
        _
        请输入你要发送的内容\
        
        _
        要发送的内容\
声明一下 
        发送内容
接下来就是重头戏了，需要声明各种结构体，我们发送的是  数据，这样，  的   就作为真正的内容，然后在前面加上  头， 头，帧头，还有校验和要正确。
最后构成一个完整的帧，那么另外声明的结构体如下，前面代码声明过的帧头部结构体就去掉了。
地址格式
 
{
    _ 
    _ 
    _ 
    _ 
}

帧头部结构体，共字节
 
{
    _     目的地址 字节
    _    源地址 字节
    _          上一层协议类型，如代表上一层是协议，为  字节
}

头部结构体，共字节
 
{
      _   版本信息位 ，头长度位 字节
                          服务类型    字节
                                   数据包长度 字节
                                      数据包标识  字节
     _                    标志位，片偏移位  字节
                         存活时间  字节
                协议类型  字节
                            首部校验和 字节
            源地址   字节
      目的地址  字节
}

头部结构体，共字节
 
{
                              源端口号  字节
                              目的端口号 字节
                     序号  字节
               确认号  字节
                               首部长度位，保留位位 共位
                                    标志位位
        窗口大小位 字节
                        校验和位   字节
                                紧急指针位   字节
}

伪首部结构体 字节
 
{
                          源地址  字节
                  目的地址 字节
                                                         填充位  字节
                                                    协议号  字节
                                 包长度 字节
}
继续  函数中对各种结构体的数据进行初始化赋值，并计算校验和。
结构体初始化为序列
          
         
        目的  地址此处没有对帧的  地址进行赋值，因为网卡设置的混杂模式，可以接受经过该网卡的所有帧。当然最好的方法是赋值为刚才获取到的地址，当然不赋值也可以捕捉到并解析，在此处仅做下说明。
         = 
         = 
         = 
         = 
         = 
         = 
        赋值目的地址
          
         
        源地址
         = 
         = 
         = 
         = 
         = 
         = 
        赋值源地址
          
        上层协议类型代表协议
         = 
        赋值
         ð  
        赋值头部信息
        _ = 
         = 
         =       
         = 
        _ = 
         = 
         = 
         = 
        源地址
         = 
         = 
         = 
         = 
        目的地址
         = 
         = 
         = 
         = 
        赋值
           
        赋值头部内容
         = 
         = 
         = 
         = 
         = 
         = 
         = 
         = 
         = 
        赋值
             
        赋值伪首部
         = 
         = 
         = 
         = 
         =    
        声明临时存储变量，用来计算校验和
         
           
              
                
        计算的校验和
         =        
        重新把赋值，因为此时校验和已经改变，赋值新的
                 
                   
        初始化为序列，存储变量来计算校验和
          
           
        计算校验和
         =   
        重新把赋值，校验和已经改变
              
        发送序列的长度
          =          
          = _ 
          = 
        {
             \
        } 
        
        {
              \
             \ 
             \ 
            \ 
            \ 
             \   
            \ 
            \ 
            \ 
            \ 
             \
        }
校验和方法如下：
获得校验和的方法
      
{
       = 
       
    {
         =  
         =  
    }
     
    {
         =  
    }
     =      
     =   
      
}
记得在声明一下这个方法。如果放在  函数前当然就不用声明啦。
另外需要声明的变量有
              以太网帧头
                                  头
                            头
                   伪首部
         发送队列
接下来的运行结果：
获取地址完毕请输

请输入你要发送的内容
  
要发送的内容 
  
 
 


 




 
截图如下：

好啦，发送帧到此就告一段落啦！如果有疑问请留言。
帧的接收很简单，直接贴源码如下：
 
 
 


 _        _即为  
 __    _   _ _
                      和时间处理有关的变量

 
{
    _ 
    _ 
    _ 
    _ 
}

帧头部结构体，共字节
 
{
    _     目的地址 字节
    _    源地址 字节
    _          上一层协议类型，如代表上一层是协议，为  字节
}

头部结构体，共字节
 
{
      _   版本信息位 ，头长度位 字节
                          服务类型    字节
                                   数据包长度 字节
                                      数据包标识  字节
     _                    标志位，片偏移位  字节
                          存活时间  字节
                 协议类型  字节
                             首部校验和 字节
                源地址   字节
        目的地址  字节
}

头部结构体，共字节
 
{
                              源端口号  字节
                              目的端口号 字节
                     序号  字节
               确认号  字节
                               首部长度位，保留位位 共位
                                    标志位位
        窗口大小位 字节
                        校验和位   字节
                                紧急指针位   字节
}

伪首部结构体 字节
 
{
                           源地址  字节
                   目的地址 字节
                                                         填充位  字节
                                                    协议号  字节
                                 包长度 字节
}


 {

         以太网帧头
                                 头
                           头
                  伪首部

    __          所有网络适配器
    __                      选中的网络适配器
     __   错误缓冲区大小为
     __
    _            捕捉实例是_返回的对象
      =                             适配器计数变量
     _     接收到的数据包的头部
     _ _              接收到的数据包的内容
                                         表示是否接收到了数据包
    _                        过滤时用的子网掩码
     _ =         过滤字符
     _                      _所调用的结构体

    _ _                                       地址有效长度
    _                         主机字节序列
    _                        发送数据包目的地址
    __          堆文件

    _ __                和时间处理有关的变量
                         和时间处理有关的变量


    获取本地适配器列表
    _____ == {
        结果为代表出现获取适配器列表失败
          __\
        代表正常退出为非正常退出这个值会传给操作系统
        
    }
    打印设备列表信息
     =  = = {
        \\\
        {
            打印适配器的描述信息
            \
        }{
            适配器不存在描述信息
             \
        }
        打印本地环回地址
        \ \  __

         __        网络适配器的地址用来存储变量
          =  = {
             _代表了地址的类型是地址类型还是地址类型
              _
             {
                  _  代表类型地址
                       _\
                     {
                         的优先级等同于括号高于强制类型转换因为为类型，对其进行操作须转换为_类型
                         \ _ __
                     }
                     {
                         \ \ _ __
                    }
                     {
                           \  \ _ __
                     }
                      {
                           \  \ _ __
                     }
                     
                  _ 代表类型地址
                       _\
                         \
                     
                 
                     
             }
         }
    }
    为代表上述循环未进入即没有找到适配器可能的原因为没有安装导致未扫描到
     == {
             
    }

     
       
    让用户选择选择哪个适配器进行抓包
    _
    \

    用户输入的数字超出合理范围
    ||{
           \
        _
         
    }
    跳转到选中的适配器
    = =    = 

    运行到此处说明用户的输入是合法的
     = _        设备名称
                                                               存放数据包的内容长度
                                                        __  混杂模式
                                                                   超时时间
                                                                  远程验证
                                                                 错误缓冲
                                                         == {
        打开适配器失败打印错误并释放适配器列表
        \          \ 
         释放设备列表 
        _
         
    }


    打印输出正在监听中
    \  \ 

    所在网络不是以太网此处只取这种情况
    _ = _
    {
        \      \
        释放列表
        _
         
    }

    先获得地址的子网掩码
     = 
        获得接口第一个地址的掩码 
        = _ ___
    
         如果接口没有地址，那么我们假设一个类的掩码
        =

    _的原理是将高层的布尔过滤表
    达式编译成能够被过滤引擎所解释的低层的字节码
    _    适配器处理对象
                                        
                                        _   过滤和
                                                               优化标志
                                                   子网掩码
                                        
    {
        过滤出现问题
        \        \
         释放设备列表
        _
         
    }

    设置过滤器
     _ 
    {
        \   \
        释放设备列表
        _
         
    }


    利用__来接受数据包
     = ___=
    {
         =={
            返回值为代表接受数据包超时，重新循环继续接收
            
        }{
            运行到此处代表接受到正常从数据包
            为帧的头部
               _ 
             获得数据包头部的位置
             =   _     为以太网帧头部长度
            获得头部的位置
            _ = _   
            _ _
             =  _ _
              
              =  _ 
             将网络字节序列转换成主机字节序列
             =   
             =   
             \
              \
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
            \
        }

    }


    释放网络适配器列表
    _

    
     _   _     
                                      
                                  _    
                                  _      
                                 
       __    _ 
                  _ 
    
    开始捕获信息当捕获到数据包时会自动调用这个函数
    __

     
    _ 

     

}

 每次捕获到数据包时，都会自动调用这个回调函数 

_函数是基于回调的原理来进行数据捕获的，如技术文档所说，这是一种精妙的方法，并且在某些场合下，
它是一种很好的选择。但是在处理回调有时候会并不实用，它会增加程序的复杂度，特别是在多线程的程序中


 __    _   _ _
{
       = 
     
    _ __

     将时间戳转换成可识别的格式
    __ = _
    ___
         

     \  _ 

}

 将数字类型的地址转换成字符串类型的 
     
 _ 
{
      
      
    _ 

     = _ 
     =    ==       
    _     
     
}
运行截图如下


 
如有问题，欢迎留言

相关推荐腾讯云上网络编程一之前言、目标腾讯云上网络编程二之环境配置腾讯云上网络编程三之协议获得地址表作者赵丽娜
团队：腾讯移动品质中心 
我理解的测试左移，即将测试活动与开发活动结合更加紧密， 同步于开发活动甚至早于开发活动便开始的质量保障活动。业界已有关于测试前置的一些讨论 因此本文也沿用测试前置的概念 本文将讲解测试前置在腾讯地图  的实践情况。鉴于  与  的不同形式， 类产品在实践测试前置方法时需做适当调整。
一、持续测试过程
测试前置的前提是持续集成和持续测试，持续测试的前提是自动化测试。自动化测试的实现离不开好的测试框架和测试平台的支持。地图  之所以能逐渐做到测试前置，正是依赖于地图  在自动化测试的积累。详细的测试框架介绍请期待后续  相关文章。
持续测试过程中，开发工程和测试工程的统一使得自动化测试校验点增强，同时也使得测试用例开发与开发功能开发同步进行变得可能。
二、测试前置活动
、引入测试前置活动的原因
通过对版本  的系统分析，我们发现基础类问题占比达到 如图 ，基础类问题是可以通过 ，静态扫描，或者单元测试活动发现的，大量的基础类问题遗留到测试执行阶段，浪费了测试成本，也增加了问题定位成本。另外通过  扫描发现静态扫描问题多 如图 ，潜在稳定性风险大。因此我们认为测试前置活动是有必要的。 图   根因构成
图  静态扫描问题对比
、测试前置活动
测试前置活动包含两方面内容，一是开发参与质量保证；二是测试活动提前。开发参与质量保证的活动有 ，进行静态扫描并扫清扫描中出现的问题，和高质量的自测。业界开发自测通常采用  的方式。在本产品中，自测以功能验证方式为主。
图  描述了从需求评审开始，测试线与开发线并行进行的活动过程。在开发线，开发通过需求文档映射到设计文档由于互联网应用的快节奏，在小  中可跳过。 这时测试线同步进行手工测试用例的设计和编写。开发线进一步在梳理接口后输出比较确定的接口定义，测试线基于接口定义进行自动化用例和测试  的实现。开发代码完成时，由于在同一工程下，测试用例代码可实时或相对实时与开发代码集成和调试，开发  ，自测的过程的同时自动化测试用例也在调试中。提测后，测试进入手工测试环节，关注在复杂逻辑和效果验证。
图  测试前置流程
汇而总之目前采用的测试前置活动如下
手工用例提测前输出；
自动化用例提测前编写和调试；
代码静态扫描；
  。
、测试前置效果检测
我们定义测试交付件包括手工用例，自动化用例， 和符合测试准出标准的被测包。我们通过每个版本中的   分析来检查是否有基础问题遗留到后期手工测试阶段，遗留的问题是由于什么原因引起的，进而反作用于测试前置流程，完善测试前置流程。
以下举例说明。图  和图  为一次  分析结果，从图中可以看出基本功能覆盖引起的问题占问题总量 ，基础类的问题条件检查、初始化、算法基本逻辑等 占有效问题 。说明本次测试中，测试前置效果不好。进一步分析，基础类问题集中在一个  上，最终调研发现，该  没有开展测试前置活动。
图   触发原因分析
图   缺陷类型分析
汇总一下 检测步骤如下
测试结果  分析；
 结果反馈跟进；
反馈完善测试前置流程和方法。
三、测试前置的下一步——
从上面的讨论我们已了解，单元测试也是测试前置的重要活动。但单元测试在互联网产品尤其是前端实施阻力非常大，因此我们通过一定原则筛选出一些适合做单元测试的模块，目前正在实践中，有一定实践效果再与大家分享。
筛选的原则如下：
、逻辑性强的模块；
、当前测试用例代码覆盖率低的模块；
、代码可测性高的模块：我们是从函数扇入扇出、函数行数、函数深度、函数圈复杂度等方面进行函数分级。
获取更多测试干货，关注腾讯移动品质中心  公众号。月日，腾讯云在「云未来」峰会上推出了战略新品——智能云，宣布将腾讯积累近年的能力向政府、企业和开发者开放，其中首批开放计算机视觉、智能语音识别、自然语言处理的三大核心能力。腾讯云技术社区将陆续推出系列文章，介绍普通开发者如何快速接入并使用这三大  能力。
在峰会上，腾讯云总裁邱跃鹏提到：顺丰使用腾讯云开发的计算视觉能力，能在小时识别万张快递手写运单。这背后的技术究竟是怎么实现的呢？
本文将以一张快递运单为例，为开发者介绍腾讯云开放的计算视觉能力——万象优图，是如何快速识别快递运单的。
 背景
随着电子商务的不断发展，线上线下商业模式已经密不可分，其中物流起着至关重要的作用。从商家到买家、从厂家到商家，都需要通过物流来完成。通过了解发现：一件商品从揽收到送达中间要经过多个环节，其中打包中转这一环节最为繁忙，也最为重要。为了提高该环节效率，需要更加快速的识别运单上的物流信息。万象优图的运单内容自动识别，将极大的促进了这一环节的稳定高效运作。
 万象优图运单识别
下面是一张常见的某快递单，其中收件人地址和收件人电话是非常关键的信息，物流中转完全依赖这两个信息的完整性。

传统的运单扫描都是靠人工肉眼识别的，成本高且效率低。因此探索人工智能是否可以自动扫描运单，具有非常大的意义。下面将为您详细介绍万象优图运单识别的流程。


运单版式识别

每个快递公司的运单都有不同的版式。通过大数据分析和深度学习训练，使用模式匹配方法，找出不同版式运单的特征。如下图所示，在已知版式的情况下，可以根据版式解析出图片中固定区域的内容。


字段定位

字段定位是针对收件人或寄件人的具体字段的区域检测，如电话号码、地址信息等。通过大量样本的训练，不断学习和适应各种运单中的版面变化、字体多样性变化、容忍各种噪声干扰等，最终训练得到准确性和稳定性非常强的字段定位的算法。字段定位效果示例如下图所示：


电话号码识别

运单上的电话号码通常是指位的手机号或者位的固定电话，基本上都是以整行的方式出现。通过长期的积累和对该场景的深入分析研究，万象优图提供了一套业内先进的整行识别技术，无需切分单字，直接识别整行手写字符。

地址信息识别

针对地址场景，结合运单的具体需求，我们提供独创的地址信息识别方案。借鉴数字整行识别的方法，并针对省市区地址特征和手写文本特征，改进了识别网络，使其能够适应整行手写汉字的图像特点，并直接给出对应的省市区分类结果。整个地址识别流程简化成可以直接。作者：阮一峰

越来越多的软件，开始采用云服务。
云服务只是一个统称，可以分成三大类。



：基础设施服务，
：平台服务，
：软件服务，


它们有什么区别呢？
 的软件架构师   曾经使用披萨作为比喻， 解释这个问题。  进一步  引申，让它变得更准确易懂。
请设想你是一个餐饮业者，打算做披萨生意。

你可以从头到尾，自己生产披萨，但是这样比较麻烦，需要准备的东西多，因此你决定外包一部分工作，采用他人的服务。你有三个方案。
方案一：
他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。

方案二：
除了基础设施，他人还提供披萨饼皮。

你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道海鲜披萨或者鸡肉披萨，他人提供平台服务，让你把自己的设计实现。

方案三：
他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 。

上面的三种方案，可以总结成下面这张图。

从左到右，自己承担的工作量上图蓝色部分越来越少，    。
对应软件开发，则是下面这张图。

 是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以拿来即用。普通用户接触到的互联网服务，几乎都是 ，下面是一些例子。


客户管理服务 
团队协同服务  
储存服务 
储存服务 
社交服务     


 提供软件部署平台，抽象掉了硬件和操作系统细节，可以无缝地扩展。开发者只需要关注自己的业务逻辑，不需要关注底层。下面这些都属于 。



  



 是云服务的最底层，主要提供一些基础资源。它与  的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。下面这些都属于 。


 
 
 


参考链接

          
         


原文链接：导语 中频繁的垃圾回收往往是造成手游性能瓶颈的一大元凶，本文对常见的造成频繁垃圾回收的原因做一个扫描，让开发者在日常开发中可以有意识的避开这些问题。


 会分配在栈上，但是  会分配在堆里。

 方法会产生   ，每次调用会产生   的大小。

 在赋值操作时，等同于一次  。

 在进行=操作时，如果原本是  则会有一次转换，并更新。

由于的是采用   原理， 对象数量  引用关系复杂度  对象尺寸 这一优化原则可以作为通用的优化原则。

利用数组对于是一个对象的原则，可以对原本储存在中的对象进行一些属性分离来优化。


比如有个对象存在一个里，那的次数就是次本身占一次
 
{
     
     
     
     
}
但是如果将它们的属性进行拆分，将所有值属性放到一个里，如：
 _
{
     
     
     
}

_ 
 
 那这个对象的次数就会降低为次

单个的值属性  分配是在栈上进行，但是 永远是在堆上。

避免在代码中频繁调用会分配内存的  如 。

避免频繁调用  及其它类型的衍生。

避免在  内使用  和 。

避免在  内  和 。

避免在  内访问  组件。

避免在  内 。

避免在  里赋值给栈上的数组，会触发堆内的反复分配。

避免频繁使用  等函数的数组版，重载中的多参数都会调到数组版。

避免频繁使用参数中带  修饰的函数。

在不需要时避免使用    时把  关掉

避免使用 ，可以先拿到迭代器，然后进行迭代。

避免使用枚举或  做  进行字典查找，由于 在 的主要接口      在被调用时都需要对传进来的  调用默认的  来判断是否相等



 =   
 而  的内部有私有方法  来创建真实的 ，内建类型 等等已经实现了良好的  判断，而用户定义的  则没有，每次调用       等接口时， 会为你创建一个。
要避免这一问题，可以人为指定对象的 或者对你的自建实现 和  等方法。作者：林伟勋 

导语
本文介绍了如何解析  的  堆栈，分别使用了来自动解析整个堆栈，以及使用 来解析单个地址的符号。
在  开发中，解决  问题是比较常见的工作。其中能够解析出符号当然是定位问题的开始。
实际工作中，也有看到很多人其实会卡在解析符号这里，遇到这种情况，可以按照本文中的做法解决。
使用  解析堆栈
 是  自带的  符号解析工具，可以自动搜索本地符号表，解析整个  堆栈。
确认  环境
首先，需要确认  的环境，执行以下代码，获取当前  的目录。
 结果应该是：
如果结果不是上述的路径，则指定一下路径：
   准备好解析堆栈符号的工具：
需要先找到  所在的路径，以  版本为例，执行：
     将会返回：
可以做一个快捷方式：
 =需要先配置好_，否则会报错。如下：
 _=
开始解析
准备好  文件和  文件，可以存放在任何位置，只要  系统的  能够找到就行。接着执行
 
就可以解析符号了。
找不到符号的解决方法
首先，需要确认一下符号表是不是正确的。可以通过以下方式看看符号文件和堆栈是否是对应的 判断  是否相同：
  
  
   
如果不一样，那么说明崩溃堆栈和符号文件对应不上，很可能是搞错版本，或者打包的时候有问题导致符号文件生成不正确。如果输出一样的 ，那么就是对应的，此时  应该可以正常解析符号。如果还是不能正确解析，那么很可能是  自动查找的问题。 找符号文件的时候，是通过  来找的，比如：
 ____ = 
该命令会把当前环境下的所有符号文件找出来。如果你的符号文件不在此列表中，说明  找不到我们的符号，
那么就在执行的时候显式指定文件的路径：
  
如果还是不能解析，试一试把  文件也指定：
   
使用  解析单个符号
有时候我们需要解析单个地址的符号，比如  寄存器的地址对应的符号，就需要用到 用法如下：
            
其中 指定二进制的架构，比如 ，， 等等。
 指定符号文件，可以是  文件，也可以是包含了符号表的可执行文件。是加载地址，由于  默认打开  选项，所以加载地址每次都不一样，所以需要指定，可以在  堆栈的   那段看到应用的加载地址。最后一个参数是需要解析符号的地址。
原文地址解析堆栈“你有困难我帮忙，我住隔壁我姓王”这句耳熟能详的话很多人都能继续发散，讲讲段子，但老王为什么深受隔壁喜爱呢？是因为老王长的很帅？今天我们就来从需求分析的角度讲一下老王深受隔壁喜爱的原因。
、理解需求
我们首先来通俗的理解一下需求是什么：我理解的需求其实可以概括为用户没有的、需要的、想要的。但在我们接触到的用户中很少能有清晰讲出自己需求的，需要我们根据用户的使用场景去挖掘，举一个例子：
一土豪相亲，有三个女孩都比较合适，于是土豪给了三个女孩每人元，请她们把房间装满。女孩买了很多棉花把房间装满了，女孩买了很多气球把房间装满了，女孩买了蜡烛，让光亮充满了房间，大家都感叹女孩有创意、懂浪漫，认为她胜券在握，最终土豪选了胸部最大的那个。
讲到这里我相信很多人都笑了，笑归笑，我们从这个例子中可以看出用户真正的需求有时是隐性的，所以我把需求分为两个大类：显性需求和隐性需求。
、显性需求
如下图，到，到，显而易见，很直观，是用户可以明确感受并且可以表达出来的，可以进行针对性满足的需求。

例如：你要喜庆点颜色的衣服，我给你红色的连衣裙；你饿了，我给你馒头，管饱；这些都是客户比较直观的关注点，这些显而易见的用户需求我们统一称之为用户的显性需求！这些也是很多小伙伴在包装自己产品和推广产品的时候喜欢的思考方式！但是，满足了用户这些，他基本也没啥太大的反应；但不被满足时，呵呵，用户会骂娘。

、隐性需求
指的是用户不能准确表达的，但存在于内心深层次，需要我们揭开层层遮挡去发现，往往有着情感化的需要。

例如：你要喜庆点颜色的衣服，我给你红色的连衣裙，并告诉你如果出席酒会可以红色连衣裙搭配个粉色水晶鞋会很出彩；你饿了，我给你馒头，并递给你一瓶水防止你吃后口渴；其实如果不说红色连衣裙如何搭配，不提供水，你也没想着要，这些就是你的隐性需求。当用户的隐性需求被满足时，用户会兴奋，会产生共鸣，会感动。但不被满足时，也可得过且过。
用几个我们生活中常见的广告来解读一下他们是如何满足用户人性、情感化隐性需求的：脑白金一段时间家喻户晓，脑白金广告词：“今年过节不收礼，收礼还收脑白金”，就抓住了用户送礼的需求；如洋河蓝色经典，男人的情怀！用酒来衬托男人的品味，给人感觉喝了洋河蓝色经典，顿时品味上去了，瞬间让用户有了一种自我提升的感觉；小米手机广告词：一块钢板的艺术之旅，先不说质量咋样，给人感觉就是高大上，不锈钢都能说得这么优雅，不得不佩服。
、显性需求和隐性需求与转化率之间的关系

通过我们对显性需求以及隐性需求的理解以及上面这张图我们可以得出这样一个公式：
转化率 = 本身需求吻合度显性需求  情感共鸣认可度隐性需求；

回归到我们做互联网产品中可见：吃穿住行柴米油盐酱醋茶这样的显性需求中我们很难找出一款让人惊喜的产品，因为拉不开差异化，竞争激烈；好的产品在满足用户显性需求的同时，势必洞察用户背后的隐性需求，在人性、欲望、情感等方面和用户产生了强烈的共鸣，这就是隐性需求的价值所在。
、挖掘隐性需求
、走到实际场景中去

有一个农夫，赶着头猪去临镇，路途遥远天色又已晚，只好找了附近一寡妇家要求借宿一夜，向来寡妇门前是非多，当即表示不方便。农夫：大妹子，求你了，给猪一头。寡妇：好吧，但你只能睡院子里。晚上天冷，农夫想进屋睡，寡妇不肯。农夫：再给一头猪。寡妇：好吧，但你只能睡地上。半夜农夫想上床与寡妇同睡，寡妇不肯。农夫：把我剩下的猪都给你。寡妇：好吧。后面的事大家都懂的早上起来农夫表示要继续赶路，寡妇要求农夫再留下来陪她一天，农夫不肯。寡妇：那我把猪都还给你。农夫扔表示要赶路，不肯。寡妇：我把自家养的猪都给你。
⊙⊙…额看到这里大家知道【猪】根本不是寡妇的隐性需求，什么是？大家都懂了，我就不多说了。运用到产品中也是一样，我们不感受一下是根本无法知道真实的需求点在哪，所以走到实际的使用场景中去，感受实际遭遇到的痛点，分析痛点背后的故事，才能真正了解哪些才是用户真正需要的。
、看我们的用户有什么样的共性

我们在做微云版同步盘的时候，经常被用户投诉我们的同步速度太慢，开发哥哥努力优化同步机制，在现有网络环境的基础上可以说已经达到最优，但一番折腾下来后，还是不断的有用户投诉同步速度太慢！为了探究原因，我们做了一次用户访谈，在跟这些投诉同步速度太慢的用户聊时我们发现其中不乏使用带宽百兆光钎以上的用户，他们的下行速度可以达到兆左右，可还是一直抱怨太慢。其中有个有趣的信息引起了我们的注意，这类用户有个共同属性：他们每次同步的文件都很多！基于这一点，我们在新版本中加入了“优先同步”功能，目的是让用户能自由控制优先同步某个文件，这个功能上线后，我们同步慢的投诉减少了。
由此可见提升同步速度根本不是用户的隐性需求，优先同步我要立刻用的文件才是！同用户的交流中他们有时候不能准确表达出自己的需求，那就需要我们去分析这类用户有什么样的共性这个示例中我们可以知道用户的共性是一次同步的文件较多，在这些共性中分析用户行为这个示例中用户在多文件同步这个场景下，由于同步的文件并不是自己立刻想要用的文件，所以习惯性的把这个等待的过程归咎于同步速度慢，这些行为中没有被覆盖的点才是用户真正需要的。
、情感、人性的满足最容易带来现象级的产品

有些人可能有了解过年国内网盘百花齐放的时候，大家为了吸引用户大打空间战，百度云首先提出免费存储空间，云盘跟上喊出免费存储空间，我们微云自然不甘落后，直接喊出了免费存储空间，当时用户欢呼雀跃，大赞腾讯土豪就是这么任性。结合国内的网速，我们认为是很大的空间，很多用户可能“一辈子”都用不完，那自然不需要签到领网盘空间这个活动了每天送你那可怜的几十兆空间根本没有意思嘛！，但出乎意料的是，用户对于升级了新版后找不到签到功能这件事情大为愤怒， 上也纷纷给一星！通过对用户的访谈我们知道了很多用户已经习惯了每天过来点一下，到也不一定是送的那一点儿空间他真的有用，只是这样的行为会很大程度上加深用户的成就感，还能拿出去跟朋友们装逼我十零三百九十五兆，就是比你十的牛逼，这就是“人性”啊。
由此可见我们通过增大到空间满足用户的显性需求，但确忽略了用户隐性方面的情感、人性方面的需求。人性的美与丑，都是在发现需求阶段很有价值的珍宝，人们没有发现的欲望，但这个欲望又确实存在，打开人性中的欲望就掌握了有现象级产品的钥匙。
、老王是怎么做的
通过我们上面对需求的理解以及挖掘隐性需求的学习，我们再回到今天的主题“老王为什么深受隔壁喜爱”？首先我们来看看隔壁的需求：
场景一：
隔壁小妹总是抱怨：“我家网速太慢了！”我们通常会说“那升级带宽啊！”
隔壁老王的做法是：“我家网速快，密码是六个。”老王，你真大气！
场景二：
隔壁少妇抱怨：“好冷啊，晚上睡觉都要盖两层被子！”我们通常会说“买个电热毯啊！”
老王的做法是：“我不怕冷，我帮你暖被窝，暖好了你再钻进来。”我怎么没想到尼玛！让我来！
场景三：
隔壁少妇做好了饭，不过菜炒的有点多，吃不完。我们通常会说“吃不完放冰箱啊，下顿接着吃！”
老王的做法是：“我来陪你吃，跟我吃饭最有意思了！”
不用更多的场景了，我们都明白了，我们由于过于“善良”，听到和看到的只是隔壁表达出来的显性需求，可老王真正洞察到了隔壁背后的隐性需求，并且很好的满足了。所以这样的老王是真的深受隔壁喜爱！
、写在最后
需求作为一个产品的起点，承载着这个产品的成败，有些时候我们知道用户需要某些东西显性需求，但还没意识到用户到底想要什么隐性需求，隐性需求不像显性需求那样垂手可得，让我们一起努力，做出更多深受“隔壁”喜爱的产品！一自动文本分类
概述文本分类，顾名思义，就是将一篇文档归为已知类别中的一类或者几个类，为了实现自动分类的目标，通常有以下几个步骤：

构建分类类别体系

获取带有类别标签的训练数据

训练数据的文本表达及特征选择

分类器的选择与训练

分类应用数据


给定一篇待分类的文档，若对其进行自动分类，通常需要把文档表达成机器可以处理的数据类型。目前常用的文本表达方式有向量空间模型，即把文档映射为一个特征向量

其中为文档分词后的词条项，为相应词条项的权重。
我们的自动文本分类系统，为用户提供自动文本分类服务，平台已对文本分类的模型算法进行了封装，用户只需提供待分类的文本数据，而不必关注具体的实现，通过平台就能得到提供文本的所属类别。目前平台能识别类别囊括了软件、影视、音乐、健康养生、财经、广告推广、犯罪、政治等多个类别，且系统算法支持快速迭代更新已有类别及增加新类别。
二．自动文本分类系统
系统主要框架
目前我们的自动分类系统框架如图所示。系统主要分为三大块：系统输入层、系统算法封装层和输出层。其中系统的输入可包含四个部分：包含文本的、主标题和副标题及正文部分，其中前三个输入串可选；系统的算法封装层，封装了对文本目标进行分类的分类器及算法模型的迭代更新；系统的输出为该文档所属的类别。

图 自动分类系统框图
系统关键技术
 类别体系
目前我们系统构建的类别体系主要基于网页内容分类体系，主要类别涵盖了旅游资讯、游戏、人物访谈介绍、体育、音乐、影视、软件、文学、健康、美食、财经、教育、广告推广、犯罪类别、自然灾害、政治等多个类别。每个类别体系下对应一个与类别相关的词特征文件。词特征文件的生成及挖掘更新，文章后面会有提及。此类别体系，易扩展，增加新的类别时，若与旧体系类别无交叉，则直接添加该类别及生成一个对应的词特征文件，原有类别体系不变。若为旧体系类别中的子类别时，只需分拆原有体系中对应的大类类别，即对该大类类别词特征文件分拆即可，别的类别词特征文件不变。图为系统类别体系的一个缩略的层级结构。

图 类别体系层级结构
 分类相关技术
 概述
从图中可以看到，我们的分类系统输入支持四个维度的特征：

包含输入文档内容的网址可选

文档的主标题可选

文档的副标题可选

文档的正文


直观上来说，网址中的某些模式和类别呈现很强的正相关性。比如包含“”字符串，那么该对应的文档分为影视类的概率就很大。同理，文档的标题所属的类别往往决定文档的最终类别。下图为分类器分类的主要流程。其中数据预处理主要包括数据去噪、去重等，各个分类器请参见下节。

图 分类器分类主要流程
 分类模型
目前流行的分类算法有决策树、基于规则的分类、朴素贝叶斯、支持向量机、逻辑回归、神经网络等。我们的自动分类系统根据目前类别体系及应用场景，最终采用了朴素贝叶斯规则相结合的方法。
 特征选择
从分类流程可看出，系统支持对和文本内容分别分类，最后通过类别投票打分方式确定最终的类别输出。从系统的输入数据来看，提取的特征主要包括：域特征和文本词特征。域特征通过简单的串分割即可得到，文本词特征可利用分词软件进行切分。文档通过分词之后，会包含大量的词。而有些词，如“的”、“很好”等对类别不具有区别性。因此需要通过特征选择方法来选择一批类别相关的词特征。常用的特征选择方法有基尼系数、互信息、信息增益、卡方统计等。通过比较，最终系统卡方统计方法来进行特征选择。图为系统采用的特征选择流程。流程输入为类别的正样本和负样本。通过文档分词之后，可通过简单的词的及词性对词进行过滤。然后对于最后保留的词计算词与类别的卡方值，通过设置一个合理卡方值阈值及词个数阈值，选取大于阈值的词作为该类的特征词。对于最后选出的特征词，通过及归一化后的卡方值来确定该词的权重。域特征文件生成方法亦类似。

图 类别特征选择流程
 类别在线预测与特征词的离线挖掘
通过上面特征选择方法之后，最终系统会为类别体系中的每个类别生成类别词特征文件。为了提高分类时的时间性能，系统会为特征文件生成，这样能更快的匹配命中的特征，而无需对全文档进行分词。考虑到输入的正文的长度，在实际分类时，算法会对正文按一定长度进行切分分别分类，最后加权综合得到正文的分类类别。目前，针对输入的文档，系统提供个预测器分别给出、主标题、副标题、正文的分类类别结果。为了判别出输入文档的最终类别，算法采用加权各个分类结果，最后投票得出。公式如下式所示：

其中加权权重可通过学习算法训练得到。系统最终输出的是文档分为系统所支持的各个类别的得分。
上述分类算法对文档进行分类后，得到带有类别标签的文档数据这部分数据可作为类特征词更新补充离线挖掘流程的输入集。图给出了类别在线预测与特征离线挖掘流程。

图 在线预测与离线挖掘流程
图可看出，离线挖掘流程复用在线预测的分类部分，得到挖掘流程的输入数据，通过离线挖掘，更新类别的词特征，进而反馈给输入端，用于改进下一次的分类模型，如此则形成预测、更新的闭环。
图中的特征离线挖掘，系统主要采用以下两种方式完成：
方式一： 把经过分类后的文本数据，即带有类别标签的数据，经过图所示的特征挖掘流程得到类增加的特征集。由于输入的数据为直接系统分类后的数据，非人工标注的样本数据，因此，为了增加挖掘的特征准确性和可用性，经算法挖掘后的特征需要经过人工进行标注，并与旧特征集排重合并，最终离线迭代更新类的特征集。
方式二： 选取大批量数据进行主题模型 聚类训练如聚类，得到隐含主题及描述该主题的特征词文件。再把经过分类后的文本数据用训练得到的隐含主题进行表征描述，通过卡方检验方法选择与类别相关的 个主题，合并这些主题下的特征文件，同样经过人工标注剔除噪声特征，并与旧特征集排重合并，最终离线迭代更新类的特征集。

图类特征离线挖掘两种方式
方式一和上述讲到的特征选择方法类似。方式二则基于图所示直观理解所实现，即一篇文档可由多个抽象主题进行表达，而每个主题可直接由词特征集来表示。比如说一个典型的交通事故类别文章，可能会命中很多汽车类别中的汽车类型名，如“宝马”、“大货车”，同时也可能命中犯罪类别中的经常出现的“伤亡”、“死亡”等特征词。语义层面上，把文档用主题进行表达，可用相关的主题模型算法得到。本系统使用开源工具把词按隐含主题进行聚类。在主题模型聚类过程中，需要指定训练语料的隐含主题数，鉴于当前的应用场景，设定主题数为。通过工具得到的词特征集，覆盖面全且语义相近，能很好解决类别词特征覆盖的长尾问题。

图 文档、主题、特征集关系表示
系统关键指标

分类时间性能：单进程、平均每条数据长度，条秒

分类准确率：类别体系中分类准确率平均以上


系统应用
系统最初为网页抽取或转码时对网页进行分类。经过不断的迭代更新，目前系统适应的场景更加广泛，如微博等社交消息的分类处理与应用、网络热门话题识别与应用等。图为系统分类的效果图示例。

图 文本分类效果图

相关推荐【 文智背后的奥秘 】系列篇：基于的人名识别【 文智背后的奥秘 】系列篇：海量数据抓取【 文智背后的奥秘 】系列篇：分布式爬虫之我们可以尝试分析来抓取了相关数据，但是并不是所有的页面都是可以分析来就可以完成抓取的，比如淘宝。它的整个页面数据确实也是通过获取的，但是这些接口参数比较复杂，可能会包含加密密钥等参数，所以我们如果想自己构造参数是比较困难的，对于这种页面我们最方便快捷的抓取方法就是通过，本节我们就来用来模拟浏览器操作，抓取淘宝的商品信息，并将结果保存到。
接口分析
首先我们来看下淘宝的接口，看看它的接口相比一般多了怎样的内容。
打开淘宝页面，搜索一个商品，比如，此时打开开发者工具，截获请求，我们可以发现会获取商品列表的接口。

它的链接包含了几个参数，如果我们要想构造链接直接请求再好不过了，它的返回内容是格式。

但是这个接口包含了几个参数，其中_、参数不能直接发现其规律，如果我们要去探寻它的生成规律也不是做不到，但这样相对会比较繁琐，所以如果我们直接用来模拟浏览器的话就不需要再关注这些接口参数了，只要在浏览器里面可以看到的我们都可以爬取。这也是为什么我们选用爬取淘宝的原因。
页面分析
我们本节的目标是爬取商品信息，例如：

这样的一个结果就包含了一个商品的基本信息，包括商品图片、名称、价格、购买人数、店铺名称、店铺所在地，我们要做的就是将这些信息都抓取下来。
抓取入口就是淘宝的搜索页面，这个链接是可以直接构造参数访问的，例如如果搜索，就可以直接访问=，呈现的就是第一页的搜索结果，如图所示：

如果想要分页的话，我们注意到在页面下方有一个分页导航，包括前页的链接，也包括下一页的链接，同时还有一个输入任意页码跳转的链接，如图所示：

在这里商品搜索结果一般最大都为页，我们要获取的每一页的内容，只需要将页码从到顺次遍历即可，页码数是确定的。所以在这里我们可以直接在页面跳转文本框中输入要跳转的页码，然后点击确定按钮跳转即可到达页码页码对应的页面。
在这里我们不直接点击下一页的原因是，一旦爬取过程中出现异常退出，比如到了页退出了，我们如果点击下一页就无法快速切换到对应的后续页面，而且爬取过程中我们也需要记录当前的页码数，而且一旦点击下一页之后页面加载失败，我们还需要做异常检测检测当前页面是加载到了第几页，因此整个流程相对复杂，所以在这里我们直接选用跳页的方式来爬取页面。
当我们成功加载出某一页商品列表时，利用即可获取页面源代码，然后我们再用相应的解析库解析即可，在这里我们选用进行解析。
代码实战
下面我们用代码来实现一下整个抓取过程。
获取商品列表
首先我们需要构造一个抓取的，=，非常简洁，参数就是要搜索的关键字，我们只需要改变链接的参数即可获取不同商品的列表，在这里我们将商品的关键字定义成一个变量，然后构造出这样的一个。
构造出之后我们就需要用进行抓取了，我们实现如下抓取列表页的方法：
   
   
   
   _  
   
   

 = 
 =  
 = 

 _
    
    抓取索引页
      页码
    
    正在爬取第  页
    
         = =  
        
           
             = 
                ____    
             = 
                ____    _
            
            _
            
        
            ______     
        ____   
        _
     
        _

在这里我们首先构造了一个对象，使用的浏览器是，然后指定一个关键词，如，然后我们定义了一个_方法，用于抓取商品列表页。
在该方法里我们首先访问了这个链接，然后判断了当前的页码，如果大于，那就进行跳页操作，否则等待页面加载完成。
等待加载我们使用了对象，它可以指定等待条件，同时指定一个最长等待时间，在这里指定为最长秒。如果在这个时间内成功匹配了等待条件，也就是说页面元素成功加载出来了，那就立即返回相应结果并继续向下执行，否则到了最大等待时间还没有加载出来就直接抛出超时异常。
比如我们最终要等待商品信息加载出来，在这里就指定了___这个条件，然后传入了    这个选择器，而这个选择器对应的页面内容就是每个商品的信息块，可以到网页里面查看一下。如果加载成功，就会执行后续的_方法，提取商品信息。
关于翻页的操作，我们在这里是首先获取了页码输入框，赋值为，然后获取了提交按钮，赋值为，分别是下图中的两个元素：
首先我们清空了输入框，调用方法即可，随后调用_方法将页码填充到输入框中，然后点击确定按钮即可。
那么怎样知道有没有跳转到对应的页码呢？我们可以注意到成功跳转某一页后页码都会高亮显示：

我们只需要判断当前高亮的页码数是当前的页码数即可，所以在这里使用了另一个等待条件 _____，它会等待某一文本出现在某一个节点里面即返回成功，在这里我们将高亮的页码节点对应的选择器和当前要跳转的页码通过参数传递给这个等待条件，这样它就会检测当前高亮的页码节点里是不是我们传过来的页码数，如果是，那就证明页面成功跳转到了这一页，页面跳转成功。
那么这样，刚才我们所实现的_方法就可以做到传入对应的页码，然后加载出对应页码的商品列表后，再去调用_方法进行页面解析。
解析商品列表
接下来我们就可以实现_方法来解析商品列表了，在这里我们直接获取页面源代码，然后用进行解析，实现如下：
     
 _
    
    提取商品数据
    
     = _
     = 
     =   
       
         = {
              
             
             
             
             
             
        }
        
        __

首先我们调用了_属性获取了页码的源代码，然后构造了解析对象，首先我们提取了商品列表，使用的选择器是   ，它会匹配到整个页面的每个商品，因此它的匹配结果是多个，所以在这里我们又对它进行了一次遍历，用循环将每个结果分别进行解析，在这里每个结果我们用循环把它赋值为变量，每个变量都是一个对象，然后我们再调用它的方法，传入选择器，就可以获取单个商品的特定内容了。
比如在这里我们查看一下商品信息源码，如图所示：

在这里我们观察一下商品图片的源码，它是一个  节点，包含了、、、、等属性，在这里我们之所以可以看到这张图片是因为它的属性被赋值为图片的，在这里我们就把它的属性提取出来就可以获取商品的图片了，不过这里我们还注意到有一个属性，它的内容也是图片的，观察后发现此是图片的完整大图，而是压缩后的小图，所以这里我们抓取属性来作为商品的图片。
所以我们需要先利用方法先找到图片的这个节点，然后再调用方法获取商品的属性即可，这样就成功提取了商品图片链接。然后我们用同样的方法提取商品的价格、成交量、名称、店铺、店铺所在地等信息，然后将所有提取结果赋值为一个字典，叫做，随后调用__将其保存到即可。
保存到
接下来我们再将商品信息保存到，实现如下：
_ = 
_ = 
_ = 
 = _
 = _
 __
    
    保存至
      结果
    
    
         _
            存储到成功
     
        存储到失败

我们首先创建了一个的连接对象，然后指定了数据库，在方法里随后指定了的名称，然后直接调用方法即可将数据插入到，此处的变量就是在_方法里传来的，包含了单个商品的信息，这样我们就成功实现了数据的插入。
遍历每页
刚才我们所定义的_方法需要接收一个参数，即代表页码数，所以在这里我们再实现页码遍历即可，代码如下：
_ = 
 
    
    遍历每一页
    
        _  
        _

实现非常简单，只需要调用一个循环即可，在这里定义最大的页码数，方法的返回结果就是到的列表，顺次遍历调用_方法即可。
这样我们的淘宝商品爬虫就完成了，最后调用方法即可运行。
运行
我们将代码运行起来，可以发现首先会弹出一个浏览器，然后顺次访问淘宝页面，然后控制台便会输出相应的提取结果，这些商品信息结果都是一个字典形式，然后被存储到了里面。
对接
但是此次爬取有个不太友好的地方就是浏览器，爬取过程必须要开启一个浏览器确实不太方便，所以在这里我们还可以对接，只需要将的声明修改一下即可，但是注意这里必须要安装好，如果没有安装可以参考第一章里的安装方法说明。
将声明修改如下：
 = 

这样在抓取过程中就不会有浏览器弹出了。
另外我们还可以设置缓存和禁用图片加载的功能，进一步提高爬取效率，修改如下：
_ = = =
 = _=_

这样我们就可以禁用的图片加载同时开启缓存，可以发现页面爬取速度进一步提升。
源码
本节代码地址为：。导语
除了闷头专研技术之外，程序员还需要不断地写作进行技术积累，写博客是其中最重要的方式之一。商业博客平台不少，但是更符合程序员背景的方案，是自己开发一个博客平台或者使用开源的博客平台。
开源的博客平台多如牛毛，而且不乏优秀之作，如 、、、。本系列文章将分享如何利用各种博客引擎在云端搭建属于自己的个人博客。上篇介绍了 《  服务器上部署  博客》，今天这一篇，介绍如何快速部署一个国人用  开发的博客系统。
前几天，在社区看到有国人开发者开源了用  写的一个博客系统 。从作者放出的  站点来看，效果还是不错的。正好最近在整理一些好用的博客引擎，今天正好研究了一下如何部署 。
作者王爵在  提供了一份简单的部署指南，主要包括安装 、安装 、创建数据库、下载并运行  等步骤。但是实际在部署时，发现这份指南缺少许多细节，而且也会碰到一些问题。我们一步一步来看。
 前提条件
在部署一个博客网站之前，你必须要有一台云服务器，否则只能在本地尝尝鲜，无法真正使用。笔者经常使用的是腾讯云提供的  云服务器，推荐给大家。
操作系统建议安装  。下文将以该系统为例，介绍具体的部署过程。
 安装 
 是用  语言编写的博客系统，因此必须先安装 。云服务器的系统是  ，你可以选择直接从  的网站下载针对  的安装包，但笔者推荐一个更加简便的方法：通过  安装。
首先，添加   仓库到系统中，然后再通过  安装  。具体命令如下：
   
   
    
安装结束之后，我们验证是否成功：
  
如果出现类似如下输出，说明成功安装：

  _
     _
         
然后，还需要配置一下  环境。在上文安装  的过程中，应该已经安装了  包。我们运行如下命令确保已经安装成功：
    
最后，配置一些相关的环境变量：
  _=
  _=
 安装 
根据官方的指南， 使用的是  数据库，所以第二步就是在云服务器上自建建一个  数据库。如果你希望更强大的数据库性能，可以选择云厂商提供的云数据库：  。
自建  还是比较简单的，只要依次执行如下命令，就可以安装好  并完成安全设置。
   
    
  __
  __
在安装的过程中，注意设置好  用户的密码。为了方便，此次部署博客过程中直接使用  用户。在最后的  安装过程中，要求填写  数据库的  和用户名及密码。
 创建数据库
第三步，我们以  用户身份连接到 ，然后创建名为  的数据库。
    
   

          

         
        


   \    \      

   ``      __
创建数据库的命令为：      __。
下载并安装 
接下来，可以下载  的源代码了。
  
  
 目录下包含以下文件：
          
          
          
        
通过  命令运行  文件，即可启动博客系统。
  
   
成功运行以上命令后 ，输出大致如下：


       |  {}{}
       |  
       |     
最后一行显示， 博客使用的  服务器正在监听 。但是，我们怎样才能访问云服务器上的这个地址呢？
 安装并配置 
从第五步开始，是  的作者没有在  的指南中说明的。接下来，我们使用  作为一个反向代理服务器，来访问 。
我们修改  的  设置：
  
修改其中的   部分，并注释掉某些行，具体见下面的示例：
 {
          _
          _ =

         
          

             
        _ 

          {
                        
                         
                 _   =
                _ 
                       
                  
        }
}
保存并退出文件。然后重启  服务即可。
   
现在我们访问云服务器的  地址时，就会进入  的安装页面。


 创建系统启动脚本
如果手动执行    命令，那么结束终端会话时就必须要退出  进程。为了让网站能够长时间访问，我们需要让该命令一直在后台自动运行，最好是支持系统重启时自动启动。因此，我们可以将  变成一个系统服务。
创建  文件，写入如下内容：
   
   

 
 

 
   
上面定义了该服务在  为 、、、 时启动，而在非这几个  时停止该服务。

运行级别：系统停机状态，系统默认运行级别不能设为，否则不能正常启动运行级别：单用户工作状态，权限，用于系统维护，禁止远程登陆运行级别：多用户状态没有运行级别：完全的多用户状态有，登陆后进入控制台命令行模式运行级别：系统未使用，保留运行级别：控制台，登陆后进入图形模式运行级别：系统正常关闭并重启，默认运行级别不能设为，否则不能正常启动

配置好了  文件之后，就能够通过如下命令启动、停止和重启  博客了：
    启动 
    停止重启 
    查看  的状态
结语
至此，就完成了在云服务器或云主机上部署  开源博客系统的整个过程。
简单体验了下前后台，博客基本的功能都具备了，而且速度上确实挺快的。不过目前的主题样式还比较单一，需要社区其他开发者的贡献。

另外反馈一个问题给作者：博客后台的系统设置中，有关闭「允许重新安装」的选项，这个默认设置为「关闭」了。但是实际还是能够进入安装页面，如果有网友能够猜出博主的数据库用户名和密码的话，估计就能把对方的博客给一锅端了。是一个开源的内容管理平台，它驱动着全球数以百万计的网站和应用，来世界各地不同地方的人们形成的多元并且活跃的社区创建和使用，并且提供支持。
的优势：

遵从开源许可，拥有最庞大的开源社区
可扩展性强
多站点支持
优越的模块数据库表结构的定义和升级机制
命令行工具
内置网页压缩缓存功能
有丰富的网络服务接口

许多网站都使用来建设例如：北京大学图书馆门户、清华大学图书馆、复旦大学哲学院、国外著名的社交网站 和 、新闻媒体网站  
    
、前提条件
本文将介绍如何利用，来搭建一个自己的个人博客。在开始之前，你需要具备如下条件：

云服务器：腾讯云服务器
操作系统：  位

一、    准备工作
、    首先切换到用户，切换到用户方便我们的操作

、安装软件包
  
、安装服务、和
  
过程中最需要设置数据库用户的密码

、创建的工作目录
   
之所以要将的工作目录的所有者从改为，一是出于安全的考虑，二是为了方便对工作目录进行操作。
、启用的模块
   

二、    下载的安装包：
 
三、    将安装包中文件解压至的工作目录
      
四、    创建上传目录
 
  
  
      
      
过程中需要添加属性 

其中将该上传目录用户设为主要是为了让能够知道它对该目录有读写的权限，以便在做带宽优化时可以合并和压缩，否则的话该功能不能正常。 语句的作用就是让用户名和您的用户名对该上传目录都有权限。
五、创建站点配置文件
    
六、    创建的数据库
     
密码为安装时的用户密码！然后创建的数据库用户
   
                     
  
 
其中为的数据库用户，为数据库用户的密码。
 
七、    修改的工作目录

 
 
 
将默认工作目录从修改为 

修改完成按退出编辑模式，输入保存修改。
修改完成后一定记得重启服务才能使修改生效
  
八、    安装必需的拓展
  
九、    浏览器安装
你的主机的地址
打开浏览器，在地址栏中输入上面的地址，根据提示进行安装
选择安装模式

选择安装语言

输入设置的数据库信息

点击保存和继续进入安装步骤

设置网站的相关信息

设置完成后保存

安装完毕，点击浏览网站

好啦，尽情享受吧
十、    将站点配置文件的权限还原
  

至此，的安装教程结束啦，不知道各位有没有学会呢？

相关推荐
个人网站如何开启？
使用  和  快速搭建个人博客
免费博客平台作者：莫卓颖

背景
相信大家在做项目的过程中会经常遇到这样的一个需求，鼠标到某个元素的时候为这个元素添加边框，这个简单的需求仅需注意添加边框后不会对原有的位置造成布局的影响从而造成布局跳动。本文将会试图探讨完成这个简单需求的方法。
方案一
实现思路：为元素中预先设置边框，边框的颜色与元素所在父元素背景色一致，边框大小与时候的边框大小一致，鼠标过元素的时候只需要设置边框颜色便可。兼容问题：无实现代码：
结构
 =
    
    
    
    



{
   
   
   
}
 {
   
   
     
   
   
   
}
 {
    
}

方案二
实现思路：首先设置元素为然后添加额外隐藏的边框元素，鼠标过元素的时候显示提前隐藏的边框元素兼容问题：无实现代码：
结构
 =
  
       =
  
    
     =
    



{
   
   
   
}
 {
   
   
   
     
   
   
   
}
  {
   
   
  
  
   
     
}
  {
   
}

方案三
实现思路：当过元素的时候，利用设置属性设置容器为怪异模式，即设置盒模型为 容器 =     内兼容问题：
实现代码：
结构
     =
            
            
            
            
        


    {
             
             
             
        }
         {
             
             
             
             
             
        }
         {
            
               
        }

方案四
实现思路：当过元素的时候，利用的新属性为元素添加实体的阴影作为边框兼容性：实现代码：
结构
     =
            
            
            
            
        


  {
     
     
     
  }
   {
     
     
     
     
     
  }
   {
    
               
  }

您还能想到其他好办法为的元素加套么？欢迎留言讨论

原文链接：


相关推荐前端识别验证码思路分析  全面进阶导语
          
文章指出一种基于 提升原理，逐层训练深度残差神经网络的方法，并对性能及泛化能力给出了理论上的证明。
 背景
 
 是一种训练  模型的经典方法，其中一种具体实现  更是广泛应用在各类问题上。介绍的文章很多，这里不再赘述。简单而言， 方法是通过特定的准则，逐个训练一系列弱分类，这些弱分类加权构成一个强分类器图。

图  方法原理图【】
 残差网络
残差网络目前是图像分类等任务上最好的模型，也被应用到语音识别等领域。其中核心是   或者说 图。这种结构使梯度更易容向后传导，因此，使训练更深的网络变得可行。

图 残差网络基本
在之前的博文作为  模型的  中，我们知道，一些学者将残差网络视一种特殊的  模型。论文作者之一是 刚注意到已经加入微软研究院，的提出者和  一起。 的观点基本算是主流观点之一了。
 训练方法
 框架

图  框架

残差网络


即这是一个线性分类器 。

 


其中  为分类任务的类别数。

  


其中 \ 为标量，也即  是相邻两层  的线性组合。第一层没有更低层，因此，可以视为有一个虚拟的低层，\_= 并且 、_=。

将残差网络显示表示为 

令残差网络的最后输出为 ，并接合上述定义，显然有：


这里用到了裂项求和的技巧 ，因此作者称提出的算法为   

我们只需要逐级 训练残差网络，效果上便等同于训练了一系列弱分类的 。其中，除了训练残差网络的权值外，还要训练一些辅助的参数——各层的 \ 及 训练完成后即可丢弃。
   裂项求和提升
文章正文以二分类问题为例展开，我们更关心多分类问题，相关算法在附录部分。文章给出的伪代码说明相当清楚，直接复制如下：

其中，\_ 是一个标量；_ 是一个  乘  样本数乘类别数的矩阵，_  表示其中第  行第  列的元素。
需要特别说明的是，  表示 _的第  个元素此处符号用的略随意；而  = \{\=} \ = \_ \ _ 。

与算法中类似，_  表示 _ 的第  个元素，_ _ 表示 _ 的第  个元素。
显然   给的最小化问题可以用  优化，也可以数值的方法求解  节。
 理论
理论分部没有详细看。大体上，作者证明了  保留为  算法是优点：误差随网络深度即弱分类器数量指数减小；抗过拟合性，模型复杂度承网络深度线性增长。详细可参见论文。
 讨论
 最大的特点是逐层训练，这样有一系列好处：

减少内存占用 ，使得训练大型的深层网络成为可能。目前我们也只能在上训练千层的残差网络，过过干瘾
减少计算量 ，每一级都只训练一个浅层模型。
因为只需要训练浅层模型，在优化方法上可以有更多的选择非方法。
另外，网络层数可以依据训练情况动态的确定。

 一些疑问
文章应该和逐层训练的残差网络固定或不固定前面各层的权值进行比较多，而不是仅仅比较所谓的 。作者这  节最后也提到，训练框架不限于 ，甚至不限于神经网络。不知道用来训练普通深度模型效果会怎样，竞争   现在已经显得有点过时了。


       
        
           
         腾讯云开发者实验室为开发者提供了一个零门槛的在线实验平台开发者实验室提供的能力：

零门槛扫码即可免费领取实验机器，支持使用自有机器参与，实验完成后支持保留实验成果；
在线   支持  命令操作，支持机器文件操作，支持文件实时编辑，结合交互式教学体验提供了良好的在线实验体验；
基于云的真实标准的实验环境，确保实验的普适性；

具体内容可以看视频：

从这篇文章  开发者 开始学习    吧可以看出，有 的同学有计划使用     的最重要的一个特性就是跨平台， 很多同学都会，学习  已经成为一个 程序员的必备技能，因此我和腾讯云同事合作在腾讯云上提供了  个   环境下的实验教程结合腾讯云上其他  的教程，这就是一个非常好的实现在线学习环境。
腾讯云在线实验室目前有  个教程，具体参看  实验列表 。其中有  个实验是  和  相关的。
从  基础开始到  的入门的系列实验，动手实验的效果要比纯粹的看文章的效果要好很多，这里给大家整理一下在腾讯云学习的系列实验推荐。
、 基础入门：实验介绍基本的  操作和命令，如目录切换、文件操作、进程查看、端口查看、资源占用情况等等，实现从零开始操作  机器。具体可以参考我整理的一个文档 《 跨平台  相关文档整理》。
、 搭建   开发环境：本实验将带您学习搭建   和  组成的    开发环境。参考文章： 在  上使用  托管运行 
、 搭建  开发环境 ：本实验带您搭建  开发环境， 体验在  上写传统 应用的环境，具体参考：  新突破：  下安装  作者介绍：叶嘉梁 腾讯云工程师 热衷社区分享 热衷新技术的实践 相信编码如写诗

小程序发布后，相信很多人已经蠢蠢欲动，心急的小伙伴更是已经操起小程序开发工具撸了起来。至于小程序是什么东西，在这几天朋友圈的狂轰乱炸后相信大家已经比较清楚，不清楚的可以点击 
但小程序作为新兴的东西，开发中一定会遇到一些坑，为了造福广大开发者，腾讯云为小程序量身打造了相关解决方案，今天就手把手带着大家使用微信小程序解决方案之一：瘦身方案
为什么我们需要  ？

为了提升小程序体验流畅度，编译后的代码包大小需小于  ，大于  的代码包将上传失败。

上面这段话是在小程序官方文档里给出的，每个项目不能超过 ，超过  会导致项目文件在上传的时候上传失败，如图 。在我们平时的开发中，通常会引用大量本地图片资源。而大家都知道，图片就是资源占用的元凶，它随时能让包的大小超过、。
图 开发者工具在上传时不允许代码包超过
常见的解决方法是：把图片传到图床进行存储，删掉本地图片，然后替换图片引用的地址。但是目前小程序开发者工具的功能还比较单一，无法批量替换。用户要么需要使用其他编辑器替换项目文件中图片的引用地址为线上地址，要么手动去替换。但这两种方式对于开发者而言都比较繁琐，在修改引用的同时还需要小心翼翼，因为在大量操作的过程中难免会引入其他问题。
为此，腾讯云官方提出了该问题的解决方案：。
什么是  呢？
 是一个本地命令行工具也提供  包，主要用于帮助开发者解决小程序包超过大小限制的问题。 不仅支持自动将小程序项目的图片资源上传到配置好的腾讯云对象存储服务上存储，同时，还可以自动替换项目代码中本地资源引用地址为线上 ，并移除项目目录中的图片资源。为小程序项目包瘦身，一键解决项目包超过  的烦恼。
开始使用
我们有一个开发好的小程序开发目录「」，目录大小为 。目录下有大量图片且代码中有对图片资源的引用。为了能够上传并正常运行项目代码，下面来示范如何使用腾讯云  来解决项目包过大的问题。项目目录如图 。
图 待处理的开发目录
根据  的使用指引，只需三步，使用十分简单。
第一步，前期准备
注册腾讯云账号，开通  并创建 。在本机上安装  的环境。
第二步，安装  并修改配置文件
在命令行中使用  自带的  工具，输入   ，等待完成安装。 表示全局安装，这样才能全局调用  命令，安装如图 。
图 命令行输入安装
根据指引，在与开发目录  同目录下创建一个  配置文件，在配置里填写基本的配置信息。配置文件如图 。
图 同目录下创建文件
 里填写了最基本的配置项，如图 。其中，

 指定了小程序开发目录。
 为腾讯云账号的 。
 是为存储图片创建的  的名称，这里是名为「」的。
 可以指定到  下的某个目录，本文指定到「」目录下
 是指定上传到  的指定地区，这里指定为「」，即天津。目前  支持天津、上海、广州。
_、_ 是账户密钥，用户可以自行到腾讯云  控制台上获取。

以上信息指定了开发目录以及图片要上传到的  的地址，完成这些配置，基本上已经完工。
图 的配置
第三步，运行程序
最后，我们在命令行中执行  命令，如图 。
图 执行命令
可以看到，命令行显示项目中的三个图片上传成功。翻看项目目录，发现图片已经被删除，代码中的图片引用也被换成了线上的地址，项目包一下子小了。同时， 很贴心的在开发项目外生成了个 _ 目录，来保存原来的图片作为备份。除此之外， 默认启用监听模式，这是为了让开发过程中无感知，当我们不再进行项目开发，停止运行  即可。目录如图 。
图 处理后的项目
被处理后的整个项目目录只剩下不到 ，用微信小程序开发者工具预览我们的小程序发现除了图片部分的更改，其他部分跟处理之前没有什么差别。此时，我们可以重新上传我们的小程序代码，代码很顺利的上传成功了， 的限制什么的不再是问题。如图 。
图 处理后的代码包被上传成功
除了基础配置之外， 还提供一些个性化的高级配置说是高级配置，使用起来其实也是十分简便。如自定义域名替换，匹配的图片文件后缀，是否开启图片压缩等等。如果有需要可以直接参考  上的使用介绍。
以上为大家介绍了一遍  的基本用法。相信如此方便实用、短小精悍的工具一定能帮助大家更方便的创建微信小程序。

相关推荐
一起脱去小程序的外套和内衣  微信小程序架构解析
【腾讯云的种玩法】元体验腾讯云小程序后端解决方案
简约而不简单——大众点评小程序开发经验谈简介
与，一样，都属于应用服务器。与一样，属于轻量级的服务器。是  软件基金会  的  项目中的一个核心项目，由 、 和其他一些公司及个人共同开发而成。
 由于其比较突出的优势，譬如 技术先进、性能稳定，而且免费，所以深受  语言爱好者的喜爱，并且得到了部分软件开发商的认可，目前已经成为比较流行的  应用服务器。 在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试  程序的首选。
部分是  服务器的扩展，但它与  服务器是独立运行的，互不影响。服务器默认监听 端口，服务器默认监听 端口。所以当你运行  时，它是以与  服务器独立的进程进行的。
安装软件

安装_官网找软件资源。

   

安装解包，然后将软件包部署到相关位置。由于是原生软件，只需解压即可使用。

   
   

包各目录解析：

  
 
                       主程序目录
                       库文件目录
                      日志目录
                      临时目录
                      自动编译目录代码转化为
                      配置文件目录
                   网页根目录

服务控制

    开启
     关闭
配置文件解析

主配置文件：，

主要内容如图：


主配置文件解析：

是  实例的顶层元素。一个  实例中包括如下内容：
 是一个集合，它由一个或者多个  以及一个组成。  负责接受用户请求和向客户端返回响应的结果。负责处理所有的所获得的客户请求，它处理在同一个  中所有的  源色接收到的客户请求。它匹配请求和自己的虚拟主机，并将请求结果发给相对应的处理，默认的主机是  。一个元素可以包含多个元素，每个的元素定义一个虚拟主机，它包含一个或者多个  应用。
应用

测试静态页面

安装好所有的软件包之后，启动服务，测试服务，登陆其首页。如图
  
  


测试动态页面

编写  代码，测试  处理  代码。
  


   = 


客户端测试结果如图：


部署基于域名的虚拟主机

配置和
  
           
            =  =            
                = =        
           

            =  =
                 = =
           

创建  和  的网页根目录，操作如下：
   {}
    
    
重启服务
  
  
客户端访问结果如图。修改客户端的 文件，加上和本地域名解析：
  
  


更改网页根目录

更改主配置文件操作如下：
  
         =  =
              = =
               = = =
        
创建网页根目录
   
    
重启服务
  
  
客户端访问结果如图，

识别用户的

更改主配置文件操作如下
  
         =  =
              = =
               = = =
        
    
重启服务
  
  
客户端访问，结果如图，

配置加密网站

更改配置文件，操作如下：
  
    
     =   
            =
            = = =
            = = = 
            = 
            =

生成证书和密钥：
           
按照提示输入密码
重启服务
  
  
客户端访问：
结果如图。点击我以充分了解可能的风险，然后添加例外。最后出现结果，如图。


为每个虚拟主机设置不同的日志文件

更改配置文件，更改日志文件名，与不一致就可以。具体操作如下：
  
     =  =
          = =
           =
          = =__ =
          =      
    
重启服务
  
  
客户端访问下，即可出现相应的日志文件。

总结和答疑



可能原因：
未安装，或者安装后为指定正确的环境变量。

主配置文件语法严格，区分大小写，容易出错。关键词不匹配，位置错误，默认站点名称被修改，均会报错。关于作者：蓝邦珏，腾讯前端工程师，年加入腾讯增值产品部，期间主要负责过手阅读、手动漫项目的业务开发。业余喜欢折腾前端新技术和写文章。 

上期文章：源码解析一： 详解
 之所以在性能上好于 ，主要是因为有了  助力来做数据的传输和处理。那么我们不难猜想出，在  的任务中， 接口将匹配到的文件转化为可读或 流，通过  流经各插件进行处理，最终推送给  所生成的可写或 流并生成文件。
本文将追踪 的源码，对上述猜想进行验证。
为了分析源码，我们打开  仓库下的入口文件 ，可以很直观地发现，几个主要的  都是直接引用  模块上暴露的接口的：

因此了解  模块的作用，便成为掌握  工作原理的关键之一。需要留意的是，当前  所使用的  版本是 。
 其实是在  模块的基础上做了进一步的封装，在这里先对它们做个介绍：
一 
 可以看做一个文件描述器，通过它可以轻松构建单个文件的元数据 描述对象。依旧是来个例子简洁明了：

上述代码会打印两个文件对象：

简而言之， 可以创建一个文件描述对象，通过接口可以取得该文件所对应的数据类型、路径、文件名等等：

打印结果：更全面的  请参考官方描述文档。
对于完整的  源码注解，可以到如下地址查阅：
二 
 虽然可以很方便地来描述一个文件、设置或获取文件的内容，但还没能便捷地与文件系统进行接入。
我的意思是，我们希望可以使用通配符的形式来简单地匹配到咱想要的文件，把它们转为可以处理的 ，做一番加工后，再把这些  转换为处理完的文件。
 就是实现这种需求的一个  适配器，我们看看它的用法：

如上方代码所示， 的  接口可以匹配一个通配符，将匹配到的文件转为  ，而  接口又能消费这个 ，并生成对应文件。
这里需要先补充一个概念 ——  接口所传入的“通配符”有个专有术语，叫做 ，我们先来聊聊 。

 可以理解为我们给  等接口传入的第一个  参数的形式，例如“”，另外百度百科的“模式”描述是这样的：

所谓的  模式是指  所使用的简化了的正则表达式：⑴ 星号匹配零个或多个任意字符；⑵ 匹配任何一个列在方括号中的字符这个例子要么匹配一个 ，要么匹配一个 ，要么匹配一个 ；⑶ 问号只匹配一个任意字符；⑷ 如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配比如  表示匹配所有  到  的数字。

在  中，是使用  通过算法来解析  的，它会拿符合上述  模式规范的  参数去匹配相应的文件：

而  又是借助了  来匹配文件列表的：

打印结果：

 的全部源码注解可以到  进行查阅，鉴于源码字数太多不便阅读，这里仅贴下它的执行流程图：

留意通过  创建的流中，所写入的数据格式：

是不像极了  创建文件对象时可传入的配置。

我们回过头来专注  的源码，其入口文件如下：

下面分别对这三个对外接口也直接就是  的对应接口进行分析。
 
该接口文件为 ，代码量不多，但引用的模块不少。主要功能是使用  匹配  并创建  流，通过  写入   的  去，把数据初步加工为  对象，再按照预设项进行进一步加工处理，最终返回输出流：

该模块的源码注解可以到  进行查阅。
这里有个  的概念 ——  即   ，也称为软链 ，它使用了其它文件或文件夹的链接来指向一个文件。一个  可以链接任何电脑上的任意文件或文件夹。在  系统上， 可以通过  指令来创建；在  系统上可以通过  指令来创建。更多  的介绍建议参考  —— _。
 
该接口文件为 ，其主要作用自然是根据  接口透传过来的输出流，生成指定路径的目标文件文件夹：

此处也有一点很值得了解的地方 —— 当输出文件为  类型时大部分情况下，使用的是异步的  接口，而在  中使用的是阻塞的  接口参考 ，这是即使  默认使用  传递文件内容，但速度相比  依旧会快很多的重要原因。
接前文的流程图：

至此我们就搞清楚了  的  和  是怎样运作了。另外  还有一个  接口，其功能与  是一样的，只不过是专门针对  的方式来处理使用场景较少，有兴趣的同学可以自行阅读其入口文件 。
本文涉及的所有示例代码和源码注释文件，均存放在我的仓库上，可自行下载调试。共勉
关于我们：小时光茶社 ，由腾讯会员技术团队创建，用于技术分享和交流。导语： 随着地广泛使用，各大公司越来越关注 问题，虽然多次在和官方网站上做出解释，但不同的公司和组织有自己的考虑。本文整理搜集关于 第一手资料，供大家阅读讨论。

背景
是用于构建用户界面的  库， 年被开源。
世界上许多著名公司都采用该框架开发产品 包括， 国内包括百度，阿里巴巴，腾讯，美团，携程，去哪儿，知乎等，使用非常广泛。
近期随着的即将完成，社区又即将迎来一波新的增长，但是随着地广泛使用，各大公司越来越关注 问题，虽然多次在和官方网站上做出解释，但不同的公司和组织有自己的考虑。本文整理搜集关于 第一手资料，供大家阅读讨论。

  
中文文档
  

相关事件
月 软件基金会法律事务委员会宣布，所谓的“  专利许可”不再被允许用作项目的直接依赖。
日 的联合创始人发博文宣布由于 问题将移除的使用
日 百度公司该消息在验证中宣布将在用户端产品中禁止使用和 ，已经使用相关技术的产品，半年内迁移到或者自研的
官方对 的表述

 
 ’ 
   
     
提出  的目的是防范不良专利起诉，相比于其他公司，将其用于核心产品的技术开源，没有专利保护，每年将会面临大量不良专利诉讼。



    解答了关于大家专利授权方面的疑惑

如果我创建一个竞争产品，  专利许可证中的附加专利授权是否终止？ 不会

如果我对进行专利侵权以外的其他专利诉讼，  专利授权中的附加专利授权是否终止？不会

的 专利许可证中的附加专利授权如果首先针对专利侵权我的诉讼终止，那么我就会针对回应专利反诉？不会，除非您的专利反诉与的 专利许可证授权的软件有关。

在  专利许可证中终止额外的专利授权会导致版权许可也终止？不会


上相关

         
     
         

国外社区相关讨论

      
   
          

国内相关讨论

阿里还会使用吗？
如何看待百度要求内部全面停止使用   
法律角度你可以放心使用吗？
 路粉黑 都该了解的   争议
关于百度停用

国内外知名开发者谈 
   å

 科学家 成员 团队负责人
  
和作者，核心团队成员，社区极度活跃者
 流形
现任阿里巴巴数据技术与产品部前端团队负责人，专注在、数据可视化、等领域，《深入  技术栈》作者，知乎专栏《 》创办人
 程墨
《深入浅出和》作者
相关回退方案
月日，腾讯云在「云未来」峰会上推出了战略新品——智能云，宣布将腾讯积累近年的能力向政府、企业和开发者开放，其中首批开放计算机视觉、智能语音识别、自然语言处理的三大核心能力。腾讯云技术社区陆续推出了系列文章，向普通开发者如何快速接入并使用这三大  能力，节省自身的开发成本，同时极大提升开发效率和用户体验。
具体产品发布细节，请访问：识别手写快递单、听懂人话的小微腾讯云公布了哪些大动作？
目前已发布的系列文章如下：
计算机视觉能力相关指南

智能云上手指南：如何接入腾讯云开放的计算机视觉能力？
智能云上手指南：如何使用腾讯云开放的图片鉴黄能力？
智能云上手指南：万运单快速识别背后
智能云上手指南：如何使用万象优图服务的  
智能云上手指南：如何将历史数据迁移到万象优图

智能语音识别能力相关指南

智能云上手指南：实时流式语音识别  

自然语言处理能力相关指南

智能云上手指南：如何接入腾讯云的自然语言处理能力？ 简介
 是存储 的仓库，它在生态环境中的位置如下图所示，运行 、 、 时，实际上是通过 与 通信。

 源码结构分析
主要由以下两部分组成：源码地址：

“前端”：基于框架，为提供 接口。代码主要在目录下。了解框架对理解整个代码框架有很大的帮助。

“后台”：驱动，为和提供存储的地方，并为“前端”提供一些接口。代码主要在_目录下。


驱动需要提供的接口有：_、_、_、_、_、、、_，其它的在里如果为一个新的存储如：写驱动，可以从继承类开始，编写驱动时需要注意：”          ’      ”。_与_都是写文件，区别在于前者适合写小文件，后者适合写大文件_的实现使用了关键字，_和_分别适合读取小文件和大文件。
有兴趣的同学可以看看里的实现，当然这只是基于本地文件系统最简单的实现——普通的文件操作，例：_的定义如下：

  _ 
       = __
      
             =  
            = 
       
                 

       
值得一提的是_前的装饰器。它会以为从配置好的中去取值，如果取到则直接返回，否则从文件去读。当然，_前会有一个，会以的形式写到中。、、由_提供。注：需要将配置为模式：。
还有重要的一点是：的“前端”是无状态的，状态数据都存储在和上。
 运行 
可以直接通过官方的 运行：
      _=   `
以上命令的作用是把 运行在里，通过 可以看到。_指定存放的路径，但这个目录存在于里，“ ”的作用是将该里的目录映射到本地目录请确保该目录存在，最好是空目录，方便观察。通过配置文件或命令行选项可以调整该命令的行为，关于配置文件的内容可见。
打开就可以看到界面了，不过，界面上什么也没有 
通过其打印的日志，我们能看出它做了哪些操作，比如：如果打印  …，我们就能知道它调用了相应的函数__。
  在  上是怎么存储的
在分析 的机制之前，我们需要了解： 由哪些部分组成，在上是怎么存储的以下内容以的实现举例说明。
我们刚才启动的里的是空的，我们可以向里面一些
 从上 
                    

 打上我们的标签，重要的是加上标识
       

 通过 中的和识别出这是一个发往的请求，因此会将该请求发送给我们启动的
              
        
  
    
   
   
   
   
   
   
   
      {}
我们只了一个，但是显示的是有多个被成功了？下面会解释。
现在我们可以看看上是怎么存储它的。
    

|  
|   | 
|   | 
|   | 
|   | 
|   | 
|   | 
|   ` 
` 
` 

   

` 
| __
| 
| _
` _
我们可以看到在下，由__、等组成。
__记录了所有的由哪些组成的，记录的是这些的。一个会有多个，是因为 用的层级的概念，如下图所示，除了 ，每个都是基于其他而制成，这就是里最开始那条语句如“ ”的作用，告诉它将基于而制成事实上也是基于其它制成的。引入层级的概念有什么好处呢？假设 ‘’是基于 、 、 的，而 ‘’是基于 、 、 的，这样在  ‘’后此时会将 、、都到本地，如果再  ‘’，此时就只需要  了。而存储时也会有相同的好处。
 上可能有多个，默认是，我们可以再向 一个带的   ，然后我们可以看到目录下多了一个文件_，它记录的是对应的 ，而_对应的是也就是的 。
每个 都对应着一个，它们在目录下有相应的目录。以为例，它有以下内容：
   
 _  
：记录该依赖的，如果该文件里记录的内容只有它自己的，说明它不依赖于别的
_ 的的检验值
 的一些描述信息
：实实在在起作用的数据、程序。它们是压缩后的。
现在，我们可以想想怎么根据一个来获取了：以下为例说明

从_，取出它对应的  

获取 的内容，包括和，并根据得到它依赖的，采取广度或深度优先的方法遍历这些以及它们依赖的当然还有它们的


  的工作机制
我们将以 为例说明的作用， 和 的工作机制类似。
  时，会首先搜索本地是否有相应的，如果没有则会向发送请求通过” ”中的’’和’’识别出这是一个发往的请求。
  
获取的__文件的内容。
相应的处理函数如下所示：
‘’ =‘’
__
_
__=
 __ 
  
获取下的所有和其相应的 通过读取文件_得到，对于 ，返回的是 {   }。
相应的处理函数如下所示：
‘’ =‘’
__
_
__
 __ 
 

获取的内容了_ __是由 指定的，读取指定范围的内容，提供了其他两种方式供我们选择：提供了___返回一个重定向到的，然后从那获取内容和_返回一个重定向的，从那获取内容，“_                      ”。
相应的处理函数如下所示：
‘’ =‘’
_
_
__
_= =
 ___ 
 

获取依赖的 。根据这些再去遍历它们所依赖的，并获取。
相应的处理函数如下所示：
‘’ =‘’
_
_
__
_= =
 ___ 
注：为了简便，以上省略了一些过程，如：如果发现该已在本地则不用了。
 总结
本文主要介绍了 的源码结构及工作机制，对于读者了解有一定的帮助。后面将继续介绍我们对做的一些改进和优化。
 参考资料
源码：
快速入门：
源码分析：
    ： 作者：廖晶贵，腾讯云研发工程师，隶属于腾讯基础架构部云存储研发团队，主要负责分布式存储系统研发与运营工作。


导语
分布式存储一直是个经久不衰的话题，在当前竞争激烈的云市场，存储系统的性能与稳定性一直是用户考量存储产品的重要指标，为适应用户需求与市场发展，腾讯云团队一直在不断打磨存储产品，推出了一款新的分布式块存储系统 ——    。
、背景
块存储是云上不可或缺的一部分，虽然很多云产品商在对外提供服务时虚拟机内还有本地硬盘的身影，但随着网络块存储的技术发展以及本地存储自身的缺陷，最终云上将只存在云盘而非本地盘。腾讯云块存储在经历了从无到有，从性能波动到性能稳定的发展，随着市场份额越来越大，原有的  系统已经不足以适应市场需求，用户对性能以及价格阿里云和腾讯云已连续两轮降价永远是要求苛刻的，因此团队适时推出一款同时满足性能与价格兼容的分布式存储系统，——高性能网络块存储系统。
、框架
是一种两层架构的分布式存储，用户与后端存储池以直通的方式交互，两层架构的好处是将路径化繁为简，既降低了因网络通信带来的延时，同时也减少了部署难度和运营成本。

系统架构图 
类似于，分为三类节点，用于管理集群元数据的节点，并将集群元数据记录在中；以客户端身份向用户呈现块设备的节点；以及后端存储池集群。从架构图中可以看到，用户直接通过透传到底层存储池，不存在任何中间转发过程。
、实现细节
 客户端——
作为整个存储系统的客户端须部署在云母机上，通过协议提供块读写服务。的主要功能是向用户呈现出块设备以及转发用户到后端存储池。由两部分组成：负责逻辑卷以及路由信息管理的；转发用户请求的。从二者的分工可以看出主要与中心控制节点交互，主要与存储池交互。与之间通过共享内存进行通信。这种设计的好处是当某个不服务或升级时可将自动切换到其它上而不影响用户访问，实现热升级。

节点内部实现
 局部元数据管理器——
 作为元数据管理器，管理由推送过来的集群的路由信息和与其相关的逻辑卷信息，为提供逻辑卷鉴权和查找路由的功能，同时收集由上报上来的带宽、、错误码等信息以便上报给进行决策。元数据的分散管理必然会引入不一致的问题，如何保证上局部元数据与中心控制器一致关系到整个系统的可用性。一种粗暴的方式是定时将与相关的所有元数据全量推送过去，只需做一个简单的全覆盖即可，这种方案的缺陷很明显，在分布式系统中网络通信本身就很频繁，加之每次全量导致交互数据量大，影响整个集群性能，也容易出现风暴效应；为此引入元数据版本号，与二者之间通过心跳交互版本号，当出现版本号不一致时采用增量同步。
同时类似于一个守护进程对进行监控管理，与的部署模型可以是一对一，也可以是多对一。在多对一模型下需保证落在每个上的负载均衡。一种简单的均衡性算法就是在不考虑每个逻辑卷的实际频繁度的情况下，将所管理的卷均衡的映射到每个上。另一种合理的均衡性算法则是根据每个逻辑卷的实际进行动态调整。

一对一与多对一模型
与交互涉及如挂载、卸载、扩容等操作，以挂载为例。用户通过向发起挂载请求，收到请求后，若对应是第一次挂载则推送集群全量路由信息，若不是则直接将卷信息推送到上，接收到卷信息将通过生成块设备盘符如呈现在用户的虚拟机上具体可参见协议的卷发现过程。用户就可以在本地如使用物理硬盘一样对逻辑卷进行格式化、分区、安装系统或其他应用等操作了。
 分发器——
负责响应用户以及如何保证正确路由到底层存储池中，当接收到某个卷请求时，通过卷向查询卷信息，然后以、作为输入计算出一致性值从而获得路由信息。由于存储引擎以为粒度进行管理，当收到跨的请求时需要对其进行拆分。为每个卷分配一个深度为的队列，队列访问策略为，当收到请求时将其压入队列中，同时依次从每个队列取出固定数目的请求下发到存储池以保证每个逻辑卷都能获得同等优先级的待遇，不至于存在某个卷出现“饥饿现象”；另一种防止“饥饿现象”的策略是流控，流控以卷为粒度，可根据用户场景动态调控流控阈值，保证所有卷具有合理的带宽与。
 集群控制中心——
是整个存储集群的控制中心，负责所有元数据的管理以及监控集群健康状况，同时协助存储池进行快速的故障恢复。主要管理两类元数据，一类是呈现给用户的逻辑卷信息；另一类是保证完整性的路由信息。而对集群健康状况监控主要包含如下几个方面。

以盘为粒度的流量和流控信息。

存储池资源消耗预警。

对空闲存储控件进行回收再利用，以提高资源利用率。

集群结构管理包括存储池上下架以及三副本结对。

管理存储池故障探测与恢复。


分布式一个很常见的问题就是容易出现单点失效，为解决此问题采用主备多活部署模式，一旦主出现异常备将在秒级时间内快速接管工作具体实现可参考选主案例，保证系统高可用性。下面重点介绍元数据与集群自愈能力。
逻辑卷与路由信息
卷元数据除了基本卷信息外还携带了两个特殊——与，前者向用户呈现，后者用于存储池做唯一区分，这样设计的好处是实现前端与后端隔离，可实现卷克隆与内部快照等特性。路由是存储系统的核心元数据，具有全局唯一且单调递增的位版本号，每一个路由项又称为小表对，每个小表对包含三个小表——一个主副本，两个从副本分布式存储常用的三副本机制，每个小表对也同样有版本号_。它不仅涉及到存储数据的完整性与一致性，同时还会影响集群的负载均衡。如何保证所有都能够随机均匀的落在存储池中是设计路由管理的关键。最主要的功能之一就是如何构造与管理集群路由信息。
路由的构造
前面已经讲到负责集群结构管理，在存储池正式对外提供能力时需先向进行注册认证，以结对的形式对所有进程进行分组管理。三个对等的进程组成一组也称，进程对应管理一块物理盘结对，以标识每个；同时给每个进程分配相同数量的小表，以标识每个；上对等的三个小表组成小表对，以标识且全局唯一，上的三个同样也有主副本之分。如图所示相同色块表示属于同一个对。

路由组织结构
路由的管理
采用环进行管理。环被划分为个格子，所有的路由项被均匀打散到这个格子上，环实际记录的是每个。在介绍时讲到每次下发时都会以_、为输入参数，通过公式 = _   获得一个落在 之间的索引，通过这个就可从环上找出对应的小表对信息。最后只需要将发送到三副本的主副本上。

路由环管理
故障探测与恢复系统自愈
任何分布式存储系统要想其成为永动机是不可能的，如何确保集群在故障后自动恢复同时不影响用户体验是分布式系统设计的核心。常用的三副本机制已经解决了大部分问题，即一个副本失效可继续从其他两个副本恢复数据。但是一个副本失效不能听之任之，必须让其重新恢复到正常状态，否则一旦其他两个副本也发生异常将存在数据丢失的风险。感知某个副本失效即为“探测”，而将失效副本重新启用则为“恢复”也即系统自愈，在自愈阶段系统提供降级服务。

如何探测？

故障探测主要有两种手段——心跳与上报。
心跳：所有的进程都会定时向发送消息，若在后未收到下一个心跳则认为处于不稳定状态，将置，同时其上的置为状态且从将升主，每个所属的状态置为，从而发生路由变更，由将新路由信息推送到存储池上，保证原来落在异常上的切换到正常上；若在到内收到消息则原来置的需进行数据恢复，若在后仍未收到消息则认为永远无法进入稳定状态而需进行剔除。心跳检测一种极端情况是网络故障将导致所有无法进行，为此在进行剔除操作时需要设置剔除上限值。
上报：当存储池出现坏盘时可能仅仅只是某个扇区不可写而进程却是正常的，这时无法通过心跳监控，因此通过在下发时返回特定错误码并上报给，由进行决策踢盘。

故障鉴定约束

如何自愈？

当出现故障时系统只能提供降级服务一副本故障可读写，两副本故障只读，为提供稳定服务必须尽快进行系统自愈，自愈就需要进行数据搬迁，存在两种迁移任务——、，且迁移以为粒度，待迁移的为源小表_，数据写入为目的小表_。
  、丢失心跳在到中之间，从不稳定状态进入稳定状态时需要从其他副本进行数据。
  、丢失心跳后或因上报而踢盘，需将原故障上的数据到新上。

两种故障恢复方式
当检测到故障后会生成相应类型的迁移任务下发给目的小表所在的进程，由目的上的迁移模块负责数据搬迁，具体搬迁过程在介绍时详述。
 存储引擎——
进程为整个分布式集群提供存储能力，以为粒度进行空间分配。的后端存储服务器机型为，拥有块容量为的物理盘，则每块盘有个数据单元。如前所述每个进程负责管理一块物理盘，以桶方式将按小表进行分段管理，实际上是将容量打散到上的小表上，则每个小表对应管理的容量平均为与函数冲突率有关。

与之间映射关系
当下发到上时先比较与的路由版本，存在如下几种可能。
  、   全局版本号 相同 相同，接收。
  、   全局版本号 相同 不同，拒绝，同时谁版本号小谁更新，下同需更新路由。
  、   全局版本号 不同 相同，接收，同时需更新路由。
  、   全局版本号 不同 不同，拒绝，同时需更新路由。
为防止同一时间点多个向发起更新路由请求，以“曲线救国”的方式进行路由更新——惰性同步策略。即先向主所在的拉取，失败则继续向从所在获取，仍失败则从获取直到成功为止。
在经过一系列校验之后最终以扇形多副本同步策略将数据写入其他两个副本中，数据采用分布式经典的两阶段提交方法，先写落盘，然后将数据写入内存返回，进程异步将数据刷入磁盘。

存储池读写方式
的救赎
为实现存储系统自愈，每个进程都配备了一个数据搬运工——，数据迁移以小表为粒度进行。前面已经提到两类迁移任务、，二者的区别在于是增量搬迁增量数据为故障期写入，则是全量搬迁。搬迁过程中用户同时在写入，这样存储池会同时存在两种，如何保证两者互不冲突以及最终能搬迁结束是关键搬迁时源小表同样支持写入。

迁移

迁移
从两种任务的迁移数据流可以看出，是将增量数据从主副本复制写入到故障恢复的从副本以重新达到三副本可用的过程；则是将原来故障的全量迁移到新的上。在迁移时不可避免的会有用户不断写入，这样会导致数据无法收敛而导致迁移不能完成。为防止此种情况出现最简单的做法就是禁止用户写入，从而可实现迁移收敛，但这严重影响了系统的可用性而用户无法接受。如何不影响用户写入而又保证迁移收敛呢？一种可行方式是进行串联写入，所谓串联写即在源接收到写时不仅仅写入对等副本，还需要根据串联路由将写入到目的，由原来的写三份变成写五份源端故障的副本不写，而目的端收到串联时只写内存不落盘。串联写需要用到串联路由。串联路由同样也是路由，但生命周期只处于迁移阶段。整个迁移流程大致如下：
  、  检测到故障后推送路由变更与串联路由到存储池，然后发起迁移任务到目的对应的上。
  、  从源连续迁移数据次或某次需要迁移的数据量少于则主动收敛搬迁一次先元数据，再根据元数据迁移实际数据，主动收敛意味着需要进行串联写。
  、  先通知目的端写内存，然后通知源端开始进行串联写。
  、  进行最后一次数据搬迁，搬迁完通知目的端下刷内存数据。
  、  向上报迁移完成，再进行一次路由变更结束串联写，故障恢复。
、总结
对于是腾讯云分布式存储具有里程碑式意义，其无论是在性能还是成本在云市场都具有很大优势，以为基础衍生出了许多云产品如、、等，同样支持快照功能。其的优势在于两层架构不仅降低了成本与网络通信，运营也同样变得灵活；同时惰性路由同步策略使得管理数据不需要强一致特性分布式系统的一大难点在于如何保证各节点数据一致。扇形多副本写相比于直接写三副本不仅降低了端压力，同时也起到了封装效果外部转换为存储池内部，减少失败概率。但同样也存在不足，从之前描述可以知道存在结对概念，即副本之间并没有做到完全离散，这使得一个副本故障必须同时换掉其他两个正常副本，代价稍高，这是后续优化的重点。关于  是什么，有个著名的隐喻：集装箱。但是它却起了个“码头工人” 的英文翻译的名字。
这无疑给使用者很多暗示：“快来用吧！用了 ，就像世界出现了集装箱，这样你的业务就可以随意的、无拘无束的运行在任何地方 公司的口号：，，   ，，于是码头工人就基本都可以下岗了。”但是人们往往忽略了一个问题，隐喻的好处是方便人理解一个不容易理解的概念，但并不能解释其概念本身。
互联网技术行业的一大特点是，这里的绝大多数事物并不像现实生活那么具体，在这个行业中我们所接触的绝大多数概念都是抽象的、不具体的。所以现实生活中很多可笑的事情在互联网技术行业就不仅变的不可笑，反而可能很严肃。就比如，现实生活中你是几乎不可能看见两个神经正常的成年人争论到底是锤子更好还是螺丝刀更好这个问题的。而在我们这个行业，你可以很容易的被卷入到底是  好？还是  好？还是  好？或者类似的语言之争中。当然除了语言，其它的软件工具之争也比比皆是，比如经典的还有   。
由于不具体和抽象，就需要隐喻来给投资人解释其价值，毕竟投资人大多数是外行嘛。至于  到底是“集装箱”还是“码头工人”并不重要，即使这两个概念本质上冲突了都不重要，很少有人会去真的思考集装箱的出现导致码头工人几乎绝迹。只要能让大家明白  是个重要的、有价值的、划时代的工具，骗到投资人的钱就足够了。也很少有投资人去考究集装箱的发明人到底有没有因此赚到钱？以及为什么没赚到钱？只要概念能忽悠人就行了。当然这个概念顺便也忽悠了所有懒得思考的技术工程师。
吐了一大段槽之后，回到我们的正题， 到底是什么？既然大家喜欢集装箱这个隐喻，那么我们也不妨先来看看集装箱的本质。大家应该基本都理解集装箱是怎么改变世界的吧？在集装箱之前，货物运输没有统一的标准方式进行搬运，于是铁路、公路、海洋等各种运输之间，需要大量的人力作为货物中转，效率极低，而且成本很高。集装箱出现之后，世界上绝大多数的货物运输都可以放到这个神奇的箱子里，然后在公路、铁路、海洋等所有运输场景下，这个箱子都可以不用变化形态直接可以承运，而且中间的中转工作，都可以通过大型机械搞定，效率大大提升。从此全球化开始，商业的潜力被进一步挖掘牛逼之处我就不多说了，可是这个箱子为什么这么神奇呢？答案其实也就在上面的描述中，无非就是两个字：标准。
是的！标准！标准！标准！重要的事情说三遍。
因为规范了集装箱的大小和尺寸的规格标准，于是相应的船舶、卡车、列车才能按照规格制造出来使联运成为可能，所有的运输中转的自动化工具才能被设计建造出来并且高效的使用，才可以极大的提高效率，提升自动化水平，以至于码头工人才会失业。集装箱本身是一个产品，而这个产品无非就是“标准化”的这个概念穿上了马甲，马甲可以有红的、绿的、蓝的、花的，但是大小规格必须都一样。现实世界中的事实显而易见，就是这么简单。那么  呢？
按照这个思路， 其实跟集装箱一样，或者说它想跟集装箱一样，成为穿着马甲的“标准化”。这样开发工程师就可以把它们开发出来的  们放到“集装箱”里，然后运维人员就可以使用标准化的操作工具去运维这些可爱的  们。于是实现了“海陆联运”，就好像运维工程师根本不需要了解其运维的软件架构而开发工程师也并不需要了解其软件运行的操作系统一样
这就是  的实质：穿着马甲的标准化。 的发明人根据自己运维  平台的经验，重新思考了自己的工作，将  平台的  工作从各个角度标准化了一下，将系统底层实现的 、、｜  等技术集成在一个使用镜像方式发布的工具中，于是形成了 。观察  形成的思考过程，其实就是作者针对他所运维的场景如何做自动化运维的思考，大家可以参见其演讲的 ：      。
这个演讲的名字就跟自动化运维相关：       。那么  的实质是什么？在我看来就是个针对  平台的自动化运维工具而已。众所周知当然如果你不知道，那么我来告诉你：自动化运维的大前提就是标准化。
如果你正好是一个运维工程师而且你正感觉你的运维环境一团糟，麻烦请你思考一下这是为什么？你是不是正在运维着一个使用 、、甚至 等用各种语言编写的应用都在运行的环境里？这个环境是不是因为某种历史原因，使你的操作系统运行着各个版本的内核甚至还有 ？即使是同样语言编写的业务也运行着不同版本的库？你的整个系统环境是不是甚至找不出来两台硬件、操作系统、库版本以及语言版本完全一样的环境？于是你每次遇到问题都要去排查到底那个坑到底在那里？从网络、内核到应用逻辑。你每次遇到产品升级都要在各种环境上做稳定性测试，发现不同的环境代码  的原因都不尽相同。你就像一个老中医一样去经历各种疑难杂症，如果遇到问题能找到原因甚至都是幸运的，绝大多数情况是解决了但不知道原因和没解决自动好了也不知道原因。于是你们在一个特定的公司的环境中积累着“经验”，成为你们组新手眼中的大神，凭借历经故障养成的条件反射在快速解决不断发生的重复问题，并故弄玄虚的说：这就是工作经验。因为经验经常是搞不清楚原因时的最后一个遮羞布。当别人抱怨你们部门效率低的时候，你一般的反应是：”   ，   逼逼！“
我花了这么多口舌吐槽运维，无非就是想提醒大家”运维标准化的重要性“这一显而不易见的事实。标准化了，才能提高效率。标准化了，才能基于标准建设属于你们系统的自动化运维。那么我们再来看看  是怎么做的？
首先，标准化就要有标准化的文档规范，要定义系统软件版本等一系列内容。规范好了之后，大家开始实施。但是在长期运维的过程中，很可能出现随着系统的发展，文档内容已经过时了，工程师又来不及更新文档的问题。怎么解决？ 给出的答案是：用 。 就是你的文档，并且用来产生镜像。要改变  镜像中的环境，先改 ，用它产生镜像就行了，保证文档和环境一致。那么现实是，有多少在使用  的人是这样用的？你们是不是嫌这样麻烦，于是干脆直接在线   产生镜像，让文档跟现场环境又不符了？或者我还是太理想，因为你们压根连文档都没有？
其次，标准化要有对应用统一操作的方法。在现实中，即使你用的是  开发的应用，启动的方式都可能不尽相同。有用  的，有用  的，还有用某种不知名  容器的，甚至是自己开发  容器的。如果操作范围扩大到包含  等其它语言，或数据库等其它服务，那么操作方式更是千奇百怪。虽然  操作系统早就对此作了统一的规范，就是大家常见的把启动脚本放到 中， 标准中甚至规定了启动脚本该怎么写，应该有哪些方法。但是绝大多数人不知道，或者知道了也不这么做，他们习惯用 作为自己业务启动的唯一标准。甚至是哪个目录可能都记不住。于是  又给出了解决方案：我压根不管你怎么启动，你自己爱咋来咋来，我们用   或  作为统一标准。于是   可以启动一个 、、、 等等。有人病垢  的设计，质疑它为什么设计上一个容器内只给启动一个进程？这就是原因：人家压根不是为了给你当虚拟机用的，人家是为了给启动生产环境的进程做标准化的！
第三，为了维护生产环境的一致性和配置变更的幂等， 创造性的使用了类似  管理代码的方式对环境镜像进行管理。于是：

你想做库版本升级吗？更新个镜像吧！你想做 、 的版本升级吗？更新个镜像吧。好方便！太爽了！等等神马？你想改变  配置文件中的一个字段？做个新镜像升级吧！你的  代码写错了一行要改个 ？做个新镜像升级吧

在一群人吐血三升之后，于是有人出了个主意。唉，其实后两种需求没必要这么麻烦，有一种软件叫做 、、、、
于是我们要在  中启动一个 。

什么？你要用 ？好吧，我们来看看怎么在  中启动一个 ？我有个计划任务要跑，起个  可以么？

你的  是不是就这么变成了“虚拟机”的？
不过请注意：我并不是说  不好，只是你是否真的评估了它标准话的方式是不是适合你的业务场景？锤子是用来砸钉子的，但是你非要用它来砸手指，我也没什么办法。
作为一个工程师，而且是受过专业训练的工程师，总是想设计出一套工具满足所有场景需求。因为工程师所受的思维训练是：你越是解决了更普遍的问题，你所创造的价值就越大。但是请搞清楚，这个任务一般是由标准委员会来完成的，每个工程行业都会有这么个组织来做这件事情。当然，不排除商业公司的产品可以深刻影响标准制定的情况。
那么我们这些工程师最大的价值是什么？摆正自己的位置，看清自己的问题，帮组所在的企业进一步提高效率，提高竞争力。每个企业都有其历史和当前特点，就运维工作来讲，根据企业的实际情况找到其标准化的最经济有利方式才是我们这些受聘用的职业工程师的核心价值。软件选型要要因地制宜，而不是跟风炒作。当然，如果你的核心价值是想要站在“技术前沿”，打算一直引领技术潮流，做一个出没于各大技术交流会的新技术吹牛逼者，并以此抬高自己身价的话，那我的话自然是对你不适用的。说这话可能会得罪很多人，我要解释一下：对于那些真诚的想要分享自己技术，希望为社区发展做贡献的人，我是怀着深深的敬意的！谢谢你们！
对待新技术，大多数工程师的状态是：测试是为了上线的，测试出的问题都是要解决的而不是用来评估的，不上线就没有工作成果。我认为工程师对待新技术应有得态度是：激进的用新技术新方法来做线下测试，认真的总结评估测试流程和结果和现有环境的异同，保守谨慎的评估决策新技术是否在业务上大规模使用。
 是银弹么？真的能像集装箱那样改变世界么？我的看法当然不是。即使集装箱，也不能解决一些特殊的运输问题，比如大型飞机零部件的运输，或者小件零散商品的运输。如果说云计算行业真的要出现集装箱的话，那么首先这个行业要被几大云计算厂商瓜分完毕，市场成熟之后才有可能。为什么？因为让一个应用可以在任何地方跑的需求，主要应该来自云的用户，他们可能为了稳定性考虑既租用了阿某云，又租用了腾讯云纯广告，自己所在的公司，所以请勿吐槽，还可能为了海外市场还用了某马逊云。这时用户会有需求说，我想要这些云的环境标准一致，以便我的应用可以在哪朵云上都能跑，，   。而现在，云计算市场刚刚起步，群雄逐鹿，正是差异化发展争夺用户的时候。出了云计算厂商外，其它公司的  环境都不一样，标准化要求也就不可能一样。那么你觉得  这个标准可能适合所有人么？
如果你用过了 ，并且还觉得它非常合适你的环境，那么我希望你能回答这几个问题：

你的  是用   产生的镜像还是直接  ？
你的  里面跑了多少个进程？
你的  是当虚拟机用的么？
那么你用的是  么？

最后，送大家一个段子，希望能博你一笑。

工程师：“嘿有人发明了一个叫做集装箱的东西，这东西一定可以使运输成本大大下降！甚至改变世界！”
用户：“好兴奋！这东西可以运输我的波音  客机么？“
工程师：“额。。不能整个运，需要拆开再运，因为我们要符合集装箱的标准”
用户：“那这东西可以运输我的空客  嘛？”
工程师：“额。。我们讨论的是同一件事情。”
用户：“不行是嘛？那不能改造一下集装箱让它可以运嘛？”
工程师：“额。。。这不仅仅是我们的问题，要到达运输目的地还要经过铁路，公路，他们可能也无法”
用户：“真的不能改造集装箱么？可这东西是以后的发展方向啊！未来的世界都是应该是集装箱运输的！”
工程师：“额”
老板：“嗯！这东西说不定真的是未来的发展方向！我们一定要实现用集装箱运输这些飞机！工程师们，你们赶紧去攻克这些技术难题，早日可以实现我们用户的特殊需求！让集装箱可以达到我们的业务要求！快去吧！加油啊！”
工程师：“额”在上篇两篇文章里《遇见大数据可视化：基础研究》和《遇见大数据可视化 ：来做一个数据可视化报表》，简单的介绍了下可视化的基础和制作流程。我们也发现将数据进行可视化的好处，可以清晰有效的传达数据信息，以实现“用视觉的方式去思考”。相比数据的公平，视觉的方式会带有一定的引导性。

如上图所示，我们能快速的发现图形上的不同之处。的图形和图像处理小组称之为“可视化感知”，人眼的启动时间至少需要毫秒，在启动时间内能感知到区别的存在见附录 。上图就是一种简单的预先处理感知实例，目标对象具有视觉属性“圆形”，“长条形”干扰物对象没有所有非目标对象都被认为是干扰物。观察者一眼就能知道目标对象是否存在还是不存在。
这种“可视化感知”实际上是运用人眼低层视觉系统 的引发的快速感知特征。能够迅速的引发预设在图形中的潜在目标对象的注意。所以我们在可视化设计中可以运用这一特点，快速的迁移观察者的注意点。

按照 在早期提出特征理论  人类视觉注意力最有影响力的心理模型之一，我们可以继续去寻找影响【个体特征】的视觉属性点。

通过去预设目标对象和干扰对象的颜色、大小、对比和方向的不同特征属性。观察者也可以快速的通过这种“特征搜索” 迁移注意点。
之所以很快就能找到这些注意点，因为它们跟其干扰项相比，最多只相差了一种视觉元素。比如，红色线条和黑色线条，长线条和短线条。当只有一种视觉元素的时候，我们的视觉系统中的低层视觉系统  就起作用了，它可以平行处理所有在图中出现的点，然后很快找到特征点。我们再来看下反例

跟上面的例子相比，我们要花相对长的时间找到那个注意点。原因很简单，因为图中使用了两种视觉元素来区分特殊点，颜色和大小，方向和对比。在这种情况下，我们的低层视觉系统 就不行了，视觉系统需要一个一个的处理每个点，识别两种元素，做仔细的区分。
理论说了这么多，那在我们做可视化图表的时候有什么作用呢？在可视化中，我们希望想让用户注意到重要的数据，可以用单一特征去引导用户的注意点。

上图图表，展示一个国内云厂商的用户占比情况之类的数据，大致如上。那作为本厂的产品腾讯云，我们希望观察者关注到腾讯云的数据，占比【】。但是上图的使用了多个视觉元素，没用突出目标项，这样就很难引导观察者的注意点。
修改上图图表，减少视觉元素的使用，我们再来看一个图。

从这个图表来看，只使用一个目标项和一个干扰项作为视觉元素的差异，我们就可以去引导观察者的注意点。引导到我们想要重点说明的数据上面去。
但是对于数据可视化来说，引导注意点，其目的是为了让观察者快速的去了解数据，而非刻意诱导，造成观察者的误解。

我们来看一个例子，上图是一个销售财年的报表，年销售额万，年到达万，从上图图表展示出来给观察者的信息就是，年比年销售额增长了倍的样子。

但是我们把所有数据拉出来看，却发现出完全不同的事实，年销售额万，年万，年万。年虽然比年增长了，但是和前几年相比有着明显的下滑，这就是一种图表展示的错误诱导的方式。

这种在轴上诱导的方式很常见，经常【某额宝】上展示近几日收益的时候，通过图表好像月号的时候收益非常高，但是仔细去看轴上的数值，会发现其实月号比月号的收益增长只有的，但是感观上给观察者非常夸张的展示。

而按照坐标轴为来展示的情况，实际只是一个非常稳定的状态。
数据可视化的真正价值在于，让观察者轻松的理解数据的价值。“可视化感知”低层视觉系统 是让观察者快速的找到重点数据所在，而非孤立数据导致传递给观察者错误的理解。

附录：
我们将图形的展示时间设置为毫秒，只设置一个视觉元素形状 。“圆形”作为目标对象，“长条形”作为干扰对象。测试观察“可视化感知”的低层视觉系统 的实际作用。

除了上述列举的【形状】、【颜色】、【大小】、【对比】、【方向】。还列举出一下视觉元素的对比【密度】、【闭环】、【曲率】、【整体方向】、【投影方向】和【投影深度】。本文大概讲解如何在镜像护卫神·全能安全环境 |||上如何开设网站，绑定域名等。一，登录安装护卫神镜像的服务器，打开桌面上的”主机管理系统“

打开左边菜单中”主机管理“”新增主机“

接着在右边填写网站相关信息，如帐户密码，绑定域名等

为了演示方便，或者有个别客户没有自己的域名、域名没有绑定等，可以在绑定域名这里填写其它的端口号

完后点击下面的”创建“

网站创建成功后，我们可以输入域名或者是测试的地址打开看接《大规模机器学习框架的四重境界上》
同步协议
本节假设读者已经对随机梯度优化算法比较熟悉，如果不熟悉的同学请参考吴恩达经典课程机器学习中对的介绍，或者我之前多次推荐过的书籍《最优化导论》。
我们先看一个单机算法的运行过程，假设一个模型的参数切分成三个分片，，；比如你可以假设是一个逻辑回归算法的权重向量被分成三段。我们将训练样本集合也切分成三个分片，，；在单机运行的情况下，我们假设运行的序列是，、，、、、、、、、、。。。看明白了吗？就是假设先用中的样本一次对参数分片、、进行训练，然后换；这就是典型的单机运行的情况，而我们知道这样的运行序列最后算法会收敛。
现在我们开始并行化，假设、、分布在三个 上，、、分布在三个上，这时候如果我们还要保持之前的计算顺序，则会变成怎样？计算的时候，和只能等待，同样计算的时候，和都得等待，以此类推；可以看出这样的并行化并没有提升性能；但是也算简单解决了超大规模模型的存储问题。
为了解决性能的问题，业界开始探索这里的一致性模型，最先出来的版本是前面提到的中的模式，就是完全不顾之间的顺序，每个按照自己的节奏走，跑完一个迭代就，然后继续，这应该是大规模机器学习中的了，如图所示

的优势是最大限度利用了集群的计算能力，所有的所在的机器都不用等待，但缺点也显而易见，除了少数几个模型，比如，协议可能导致模型无法收敛。也就是彻底跑飞了，梯度不知道飞到哪里去了。
在之后提出了另一种相对极端的同步协议，用的就是这种方式，如图所示

每个都必须在同一个迭代运行，只有一个迭代任务所有的都完成了，才会进行一次和之间的同步和分片更新。这个算法和严格一直的算法非常类似，区别仅仅在于单机版本的 在的时候变成了有所有的单个 求和得到的总的 替换。毫无疑问，的模式和单机串行因为仅仅是 的区别，所以在模型收敛性上是完全一样的。同时，因为每个在一个周期内是可以并行计算的，所以有了一定的并行能力。
以此协议为基础的在很长时间内成为机器学习领域实际的霸主，不是没有理由的。此种协议的缺陷之处在于，整个 的性能由其中最慢的决定；这个一般称为。读过文章的同学应该都知道的存在是非常普遍的现象。
能否将和做一下折中呢？答案当然是可以的，这就是目前我认为最好的同步协议；的思路其实很简单，既然是允许不同之间的迭代次数间隔任意大，而则只允许为，那我是否可以取一个常数？如图所示

不同的之间允许有迭代的间隔，但这个间隔数不允许超出一个指定的数值，图中=
协议的详细介绍参见，的大拿 在其中详细介绍了的定义，以及其收敛性的保证。理论推导证明常数不等于无穷大的情况下，算法一定可以在若干次迭代以后进入收敛状态。其实在提出理论证明之前，工业界已经这么尝试过了：
顺便提一句，考察分布式算法的性能，一般会分为 和 来看。前者指不同的同步协议导致算法收敛需要的迭代次数的多少，后者是单次迭代所对应的耗时。两者的关系和\关系类似，就不赘述了。有了，就可以通过指定=而得到。而同样可以通过制定=∞来达到。
核心技术
除了参数服务器的架构、同步协议之外，本节再对其他技术做一个简要的介绍，详细的了解请直接阅读沐帅的博士论文和相关发表的论文。
热备、冷备技术：为了防止 挂掉，导致任务中断，可以采用两个技术，一个是对参数分片进行热备，每个分片存储在三个不同的 中，以的形式存活。如果挂掉，可以快速从获取并重启相关。
除了热备，还可以定时写入文件到分布式文件系统来对参数分片及其状态进行备份。进一步保证其安全性。
 管理：可以使用一致性哈希技术来解决 的加入和退出问题，如图所示

当有 加入或退出的时候， 负责对参数进行重新分片或者合并。注意在对参数进行分片管理的情况下，一个分片只需要一把锁，这大大提升了系统的性能，也是参数服务器可以实用的一个关键点。
        大规模机器学习的四重境界
到这里可以回到我们的标题了，大规模机器学习的四重境界到底是什么呢？
这四重境界的划分是作者个人阅读总结的一种想法，并不是业界标准，仅供大家参考。
境界：参数可单机存储和更新
此种境界较为简单，但仍可以使用参数服务器，通过数据并行来加速模型的训练。
境界：参数不可单机存储，可以单机更新
此种情况对应的是一些简单模型，比如  ；当的数量突破百亿的时候，的权重参数不太可能在一台机器上完全存下，此时必须使用参数服务器架构对模型参数进行分片。但是注意一点，的更新公式
’=α，其中可以分开到单个维度进行计算，但是单个维度的  =  
这里的表示是全部参数的一个函数，具体推倒比较简单，这里篇幅所限就不赘述了。只是想说明在计算梯度的时候可能需要使用到上一轮迭代的所有参数。
而我们之所以对参数进行分片就是因为我们无法将所有参数存放到一台机器，现在单个有需要使用所有的参数才能计算某个参数分片的梯度，这不是矛盾吗？可能吗？
答案是可能的，因为单个样本的具有很高的稀疏性。例如一个百亿的模型，单个训练样本往往只在其中很小一部分上有取值，其他都为假设取值都已经离散化了。因此计算的时候可以只拉取不为的对应的那部分即可。有文章统计一般这个级别的系统，稀疏性往往在 ，记得不是很准，大致这样以下。这样的稀疏性，可以让单机没有任何阻碍的计算。
目前公司开源的和正在做的系统都处于这个境界。而原生还没有达到这个境界，只能在中小规模的圈子里厮混。改造的基于的则达到了这个境界。
境界：参数不可单机存储，不可单机更新，但无需模型并行
境界顺延境界二来，当百亿级且比较稠密的时候，就需要计算框架进入到这层境界了，此时单个的能力有限，无法完整加载一个样本，也无法完整计算。怎么办呢？其实很简单，学过线性代数的都知道，矩阵可以分块。向量是最简单的矩阵，自然可以切成一段一段的来计算。只是调度器需要支持算符分段而已了。
境界：参数不可单机存储，不可单机更新，需要模型并行
进入到这个层次的计算框架，可以算是世界一流了。可以处理超大规模的神经网络。这也是最典型的应用场景。此时不仅模型的参数不能单机存储，而且同一个迭代内，模型参数之间还有强的依赖关系，可以参见姐夫对的介绍里的模型切分。
此时首先需要增加一个组件来进行模型并行的控制。同时参数服务器框架需要支持切分，将依赖关系通过来进行表示。
一般参数间的依赖关系因模型而已，所以较难抽象出通用的来，而必须以某种形式通过脚本来生产整个计算任务的图，然后通过调度器来完成。对这个问题的介绍可以参考 的分享。

目前业界比较知名的深度学习框架有、、、、等，但目前最炙手可热的应该是发布的。这里单独拿出来稍微分解下。
前面不少图片引自此文，从的论文来看，框架本身是支持模型并行和数据并行的，内置了一个参数服务器模块，但从开源版本所曝光的来看，无法用来级别的稀疏模型。原因是已经曝光的只支持在神经网络的不同层和层间进行参数切分，而超大规模可以看做一个神经单元，不支持单个神经单元参数切分到多个参数服务器上。
当然，以的实力，绝对是可以做到第四重境界的，之所以没有曝光，可能是基于其他商业目的的考量，比如使用他们的云计算服务。
综上，个人认为如果能做到第四重境界，目前可以说的上是世界一流的大规模机器学习框架。仅从沐帅的里看他曾经达到过，内部应该也是没有问题的。第三重境界应该是国内一流，第二充应该是国内前列吧。
        其他
   资源管理
本文没有涉及到的部分是资源管理，大规模机器学习框架部署的集群往往
资源消耗也比较大，需要专门的资源管理工具来维护。这方面和都是佼佼者，细节这里也就不介绍了。
   设备
除了资源管理工具，本身部署大规模机器学习集群本身对硬件也还是有些要
求的，虽然理论上来说，所有机器都可以用来搭建这类集群，但是考虑到性能，我们建议尽量用高内存的机器万兆及以上的网卡。没有超快速的网卡，玩参数传递和样本加载估计会比较苦逼。
        结语
从后台转算法以来，长期沉浸于算法推理的论文无法自拔，对自己之前的后台工程能力渐渐轻视起来，觉得工程对算法的帮助不大。直到最近一个契机，需要做一个这方面的调研，才豁然发现，之前的工程经验对我理解大规模机器学习框架非常有用，果然如李宗盛所说，人生每一步路，都不是白走的。
在一个月左右的调研中，脑子每天都充斥这各种疑问和困惑，曾经半夜点醒来，思考同步机制而再也睡不着，干脆起来躲卫生间看书，而那天我一点多才睡。当脑子里有放不下的问题的时候，整个人会处于一种非常亢奋的状态，除非彻底想清楚这个问题，否则失眠是必然的，上一次这种状态已经是很多年前了。好在最后我总算理清了这方面的所有关键细节。以此，记之。于年月日凌晨！
致谢
感谢、、、、等同学一起讨论，特别感谢在方面的深厚造诣和调研。因为本人水平所限，错漏难免，另外还有相当多的细节因为篇幅限制并未一一展开，仅仅是从较高抽象层面上简述了下大规模机器学习框架的关键思路，其他如分片向量锁、通信协议、时钟逻辑、调度器、资源调度模块等均为展开来讲，希望以后有机会能补上。
引用

      

     



       



    

      

         



              

     

       

          

          

     ；黄明作者：郑小辉
团队：腾讯移动品质中心

三种测试模式预研
在测试代码放在什么位置上，及如何运行上， 经历了如下过程：
最初模式：采用官网单测模式：  和   。
但：组内希望与大组保持一致，即用，提供一个界面点击后运行用例。同时是运行在业务内。
因此，模式诞生
模式考虑：和开发代码写在同一目录下，以不同区分，同时新建测试界面供点击运行用例，整体测试代码编进开发代码以运行。
缺点：
和业务耦合太大，业务在打包时需要裁掉测试代码和资源，和中的测试元素。开发也不建议写在一起；
同时都能以命令行运行了，还要搞界面来点击运行用例，感觉多此一举；
测试范围上有些减少，比如 层的测试，内一些的逻辑的测试，则测试不了。非要测，就会变成触发点击来测，就变成了自动化了；
与单测理念不一致，一些提供的测试库不支持；
调试不方便，每调试一次，都要打一次包，而打包耗时较久。
优点：
测试代码是在真的环境上执行；
可以直接调用业务代码和被测接口。
综上，考虑到该模式，在测试范围，业务代码耦合，上，均不够好，因此放弃。
希望继续保持和大组一致，诞生了模式。
模式考虑：因为目前小组内的产品，均是开发环境，而且也是行业趋势。因此，新建，类型为，测试代码写在下，同时被业务依赖，相当于手管插件方式。和业务代码统一打成，真机运行。
缺点：
、需要先运行业务，才能触发测试代码，如果还需要和大组有界面点击运行，仍然需要在业务代码上 增加该代码，也是有耦合，同时业务在打包时，需要裁掉该代码；
、因为只能是，因此被测接口要反射来调用，不能直接调用；
、调试不方便；
、业务打包，要裁掉该；
、测试范围上同样有些减少，比如 层的测试，内一些 的逻辑的测 试，同样测试不了。
优点：
、测试代码剥离了，和业务耦合小了点。也可以不用界面点击来运行；
、测试运行环境为真环境。
综上，考虑到该模式，在测试范围，调试方便性，均不够好，因此放弃。
最终还是回归到了最初模式：  和 。     

方案选型
在经过各模式的预研，实践，选好测试模式后，选用什么框架来测试也是个选择。
考虑的是：。

样例代码：

综上：
、从样例代码可以看出，目前 基本是 从层介入，理论上可以忽略层，测试单一组件的逻辑，但关键的是不能测试组件的集成逻辑。
、层的测试也是运行在端的，它并不能测试业务在真实环境上的表现。
因此，最终放弃了，选择了  和 。
未完待续
搜索微信公众号：腾讯移动品质中心，获取更多测试干货！网络安全里经常说的一句话是未知攻焉知防，基本所有的安全人员也是一名黑客，在黑客攻击愈发普遍的今天，如何更好的防御黑客攻击？用句带有点哲学的话，成为黑客，只有成为黑客，像黑客一样思考，你才能知道从哪去防御黑客；很俗的一句话，但很实在！
看到了什么？

看到上图的第一直觉，你可以自己想下答案，问问自己看到了什么？
正常的思维，第一直观感受是中间那个很明显，很大的黑点，因为这个黑点最吸引大家的注意力，稍微看过一些哲学故事的同学可能会想到黑点周围白色的区域，是的，黑点只是其中一个小点，而黑点周围白色的部分则足够大；但是，我不知道有没有人的答案是白色再外面？文章区域再外面？或者整个浏览器？整个电脑屏幕？电脑外呢？其实想表达的也正是黑客的思维里，永远不是局限于可以看到的部分，而在于能够想到或者没想到的所有面。
其实这类同于攻击面！安全是木桶短板原理，木桶能装多少水不在于最长的那块板，而是最短的那块；而一个系统的安全程度不取决于安全做的多全，做的多高大上，而在于是否把那些最简单的问题处理掉？数据告诉我们，服务器入侵，除了漏洞之外最大途径是弱口令，而这就是一个根本没多少技术含量的方式，属于安全基线问题，就是同样的道理。对于黑客而言，攻击面不会局限于能够看到的点，而在于所有可能关联或者没关联的面，就比如渗透测试或者说，很多时候结合社工这个点能够取得很好的效果，成为一个绝佳的入侵渠道。所以，第一点，学会放开自己的思维与想象，发现和关注平时所容易忽略和没有看到的地方。
什么是黑客？
什么是黑客？我用八个字总结，突破创造，守正出奇。在我看来，黑客永远不是一个贬义词，黑客本身就是极客，对于黑客来说，这个世界充满好奇，这个世界有太多的东西可以探索，特别是网络的世界。

黑客是一个追求自由的群体，不喜欢受到条条框框的约束，总是喜欢突破这一切，突破同时也可能是一种创造，创造新的方法，新的方式，新的工具，新的东西，就比如上图，小学课本里的乌鸦喝水，在我们看来是一种很傻的行为，但未尝不是一种稳定传统的方式？在生活中很多的事不也正如此？或者说就网络上很多安全的措施有时候也是稳定起见，因为新的东西除了先进，有时候也会带来风险。而对于黑客来说，可能考虑的更不是这些，而是尝试，好奇一切。
对于黑客而言，也有自己的黑客精神，有自己要坚持和秉承的东西地下黑客的原则可能不同于正常黑客，这就是守正，自由、共享、平等、互助；在安全的世界里，我们经常会提到一个词猥琐，或者说不仅限于安全，因为很多时候攻击的产生不是利用一个多厉害的漏洞，而在于猥琐的思路，几个定义为低危的小漏洞的组合也许威力比一个高危漏洞还大，这就取决于漏洞的组合使用，利用思路；这些猥琐行为就是一种出奇的表现。
了解黑客，成为黑客，才能更好的学会黑客的思考。
看到框就想
 
这是一个意见反馈的界面，看到这样一个界面，大家会怎么做？对于普通人来说，这就是一个正常的意见提交框，用处就是提交反馈内容；大家想想黑客会怎么做？提交攻击代码，比如下面的代码：
 =
实际上，当时看到这样一个功能，我就这样做了。这是手游客服中心手机版的一个页面，可以提交反馈意见，我当时就直接提交了上面的攻击代码，然后就攻击成功了这其实是一次盲打，什么是盲打大家可以自行搜索或者看我之前发的文章。由于这样的功能往往看反馈内容的都是系统的相关管理员，于是被攻击成功的也是管理员，通过盲打可以直接拿到管理员登录的账号的等信息下图就是盲打平台中收到的攻击成功返回的后台地址和管理员。

当然，不仅限于这个页面，还有其他的：

这种行为总结而言，就是看到框就想，这里的也就是的意思；其实这更多的是一种习惯和意识，在黑客的想法里，看到功能首先想到的不是使用，而是能不能利用，然后由于攻击做的多了，看到不同的功能和应用页面，自然就能意识到可能存在的问题，自然而然的就会去测试；经常会有很多人问，那些人在各种提交的漏洞都是怎么挖的，是不是有神器？但是也不是每个人的安全测试工具都是神器啊！其实很多时候是在使用中发现漏洞！
不同的潜意识行为和想法，取决于不同的知识面和经验，也取决于不同的目的。
功能也是攻击方式
如果手机没电了，那么旁边如果其他人正好有电脑，借用其他人电脑的口给手机充电是一件很常见的事，但其实，只是插个数据线，也可以导致电脑被攻击，下面视频演示的是一部手机通过连接电脑执行指定的命令视频里是。

视频里的手机是一个很普通的手机，安装了一个叫做的黑客操作系统，也就成为黑客手机里面集成了一些黑客攻击工具，比如视频里演示的工具叫做 。看到这个视频，大家是否会觉得这个攻击挺高端的，物理黑客攻击，但当我告诉大家原理之后，大家可能想到的就是原来如此，这么简单。
手机上显示的代码是：
 
 




看完这个代码不知道大家是否已经明白了攻击原理，熟悉操作的同学可能知道其实是调起，一个类似快捷启动的工具，然后输入，就是查找，然后回车，打开后，再输入，再回车，就完成了整个命令输入执行的过程；大家可以发现，这其实就是一个模拟键盘操作的过程，没错，上面视频演示的攻击原理就是模拟键盘操作，其实这时候的手机用接入电脑相其实就是把自己设置为键盘接入电脑，然后再直接模拟键盘操作进行攻击。
那么是否可以进行危害更大的攻击？比如反弹？当然可以，改下代码即可：
 
  

       
反弹监听 监听端口

采用下载一个脚本来实现反弹，如下面视频：

讲这个例子的目的其实就是这部分的标题，功能也是攻击方式。在黑客的眼里，不是一定得使用漏洞，使用多高端的技巧，能达到攻击目的和效果的方式都是好的攻击方式，这些方式不局限于大家所了解的只是漏洞或者暴力破解等，而经常做的就是利用正常的功能来实现攻击，这种攻击因为使用的是正常的功能，有时候反而更隐蔽；而类似的攻击方式，不在少数。
结语
其实，近几年来，大家对黑客的了解已经越来越多，黑客也越来越失去神秘，然后大家就会发现，他们其实也是生活中的普通人；而在黑夜中工作，有时更多的是因为那时候安静，做事效率高，或者是管理员不在线好做一些秘密的攻击和测试等，而不是所谓各种描述里的戴着衣帽，把自己包裹在黑暗中，不露出自己的真面目等。
其实黑客所不同于普通人的点，除了掌握的知识外，就是做事和思考的方式，仅此而已！人工智能是一项前瞻性科学研究，自信息技术产生发展以来，人们在这一领域进行了长期的科学探索和技术攻坚，并不断涌现出新思想、新观念、新理论、新技术，成为未来科学技术革命的重要发源地。就现阶段发展来看，智能化是未来信息技术的发展趋势，人工智能技术也为基于互联网和移动互联网等领域的创新应用提供理论基础。腾讯优图也在用自己的方式——“开放”努力着。
近日，腾讯优图开放平台发布了版本，正式更名为腾讯优图·开放平台。除了直观的视觉冲击改变，本次版本更新为开发者提供了更全面的能力和更丰富的产品解决方案。

亮点一：更全面的技术开放

人脸融合技术重磅上线—揭秘天天图人脸变妆的秘密 

火爆朋友圈的全民军装照活动创吉尼斯世界纪录！参与人数达亿，参与人次达亿。其背后的黑科技——人脸融合技术也重磅上线了，将用户上传的照片与特定形象进行脸部层面融合，让生成的图片效果既有用户的五官特点，也呈现出对应形象的外貌特征，从此军装照、民族照、二次元照、爱豆照……想怎么玩就怎么玩，一键变脸不再是梦！


人脸聚类——轻松管理你的相册相册的照片太多，找起来太麻烦怎么办？优图人脸聚类来帮你。优图独创深度人脸模型，对电脑或手机中的照片进行聚类，自动将属于同一人的照片归为一组，使相册的管理更加智能、方便。同时自研去遮挡技术和人脸演变模型，有效减少眼镜、口罩、帽子等遮挡物对人脸聚类算法的影响，以及即使面部随着年龄增长，皮肤、肌肉、骨骼发生明显变化，也能被正常识别并聚类。



车辆属性识别——解密车辆信息的钥匙相信你肯定也会有这种困扰，当在街头看到让你怦然心动的那款车时，却无法知道车的具体品牌、车系及参配、价格口碑等详细信息。有了优图车辆属性识别能力，用户只需上传车辆的拍摄图片，即可快速获取车辆信息，如品牌、车型、车系、颜色、车标位置等，大大简化了信息获取的成本。该技术不仅能为购车的消费者提供便利，同时也可以为监控和安防系统提供智能的数据处理能力，减少人工审核的成本。



银行卡、车牌优图最具竞争力的战队又加入了新成员——银行卡和车牌。金融及第三方支付行业使用银行后，用户无需手动输入，轻轻一拍即可快速获得卡号、有效期、发卡行等信息，极大提升了用户体验，降低出错率，加速行业智能化升级。车牌被广泛运用于治安卡口违章识别和停车管理，自动识别车牌信息，既能实现车辆进出全自动化，还能对违章车牌号码的车进行进一步处理，助力智慧警务的全面升级。


亮点二：丰富的产品解决方案
优图天眼寻人解决方案优图天眼寻人解决方案，是基于优图海量人脸检索技术针对寻人场景专门研发的一款“天眼寻人引擎”，让助力公安，公益寻人，帮助更多走失的人员被找回。将优图天眼寻人引擎与城市的走失人口库相结合，当大家在路边发现疑似的走失人员时，随手拍一张照片，就可以快速的和城市的走失人口库进行比对，返回最相似的人脸识别信息。让破碎的家庭重拾温暖，让走失的家人不再流浪。 


优图天眼交通解决方案

无论是在人类生活领域还是经济发展领域，交通作为不可缺少的元素发挥越来越重要的作用。而交通监控是保障交通平安、畅通必备的手段。优图面向交通行业推出智能化解决方案，可以检测并追踪车辆、结构化存储车辆信息、自动识别车辆违章行为、自动识别拥堵等路面情况，助力城市智慧交通的建设。

安全审核解决方案优图安全审核解决方案是针对广告、社交、游戏、直播、短视频等行业存在的图片内容涉黄、涉恐、涉政、隐含恶意广告等违规问题推出的解决方案，该方案基于优图智能鉴黄技术、暴恐图片识别技术、技术和人脸识别技术，可以精准识别出图片中的露点不雅行为等色情内容、暴力恐怖内容、恶意文本以及政治敏感人物，为客户提供一站式图像内容监控服务，辅助甚至代替人工过滤垃圾，提高审核效率，助力客户更好地进行违规处理与风险管控。

亮点三：优图学术论文全新开放
优图学术论文全新开放，在这里你可以获得最前沿、最全面的人工智能领域学术论文。
人工智能的生命刚刚开始，而且它还有很长的路要走。我们要做的是开放，让每一位开发者都能拥有坚强的技术后盾，开发者不再需要进行重复且耗费大量资金和时间去做基础研发，而是可以通过优图开放平台获取最领先的技术能力，不仅提升了的应用发展速度，也将在全世界率先掀起行业共建生态的热潮。
开放助开发者一起用改变世界。戳我：推荐使用桌面端之前看过很多  的识别模型，都是识别数字的，为啥不做一个汉字识别模型呢？因为汉字手写的库找不到啊。当时我还想自己从字库生成汉字用作识别已经做出来了，导出字体图片再识别之。后来看了这篇文章和这篇文章   这个神奇的东西。原文是用  实现的，比较复杂，现在改成用  去完成。
数据集下载
      __
      解压没得说 之后还要解压  压缩文件
      __
正好用新学的  来尝试建模识别。  
首先要将下载来的  文件解压。这部分我完全不懂，图像处理部分直接使用他们的代码了。  
其中  是常用的  个汉字，这个我用来跟另外一个根据字体生成汉字的脚本配合使用。
     
       
     
       


    _ = 
    __ = _ _
    __ = _ _

      =   =
     =  
    _ = 
    _

     ____=__
       _
        _ = 
         
           =  = =_
               
            
          _ =                
           =      
           =      
           =      
           _    = _
            
           =  = = 
            
       _  _
         _
          _ = _ _
           _   
              _
              
    _ = 
     _   ____=__
    _ =  
    __
    _ = _
    _ = _ _
     _  
     
     = _ 
    _ 
    
    _ = 
    _ = 

        ____=__
      _ =  
       _  _
         = 
        _ =    __
          _
          _
        _    _   
        _  = 
        ____=__
      _ =  
       _  _
         = 
        _ =    __
          _
          _
        _    _   
        _  = 
解压完会生成一个  和一个  的文件夹，里面分别用数字为文件夹名，里面都是一些别人手写的汉字的图片。  
如果用  写的话，大概需要  行，需要处理图像当然  也会帮你处理大部分繁琐的操作，需要写批量加载，还有各种东西。  
到了 ，十分简单。总共的代码就  多行，连图像加载和偏移处理都是智能的。图片转换都给你包办了，简直贴心。
     ____  _
     
       
            
        _

    _ = 
    __ = _ 
    __ = _ 

        
    _ _ =  
    _ = 
    __ = 
    ___ = 
    __ = 

     
      _ = 
        =  
        _=
        __=
        __=
      
      _ = =

      _ = ___
        __
        _=_ _
        _=
        _=
        _=
      _ = ___
        __
        _=_ _
        _=
        _=
        _=

      =_
        =
        =
      __
        __=___
        _=__
        _=_
        __=__

     __= _=   =_
      _ = =_
       =    = _= =__
       =    = _= =_
       =   =  =_
       =    = _= =_
       =    = _= =_
       =   =  =_

       _
         = =
         = 
         =  = =
         =  = =

       = _  =
       

     = _
      = _
    
     
可以看到生成模型的代码就  行，十分简洁。开头两套双卷积池化层，后面接一个  防过拟合，再接两个全链接层，最后一个  输出结果。于是开我的  机器开跑，大约花了半天时间。

  ==============          ==============================          _   _ 

在  次  后，准确率在 ，验证的准确率在 左右，基本可以识别大部分库里的汉字了。
实际看来汉字识别是图像识别的一种，不过汉字数量比较多，很多手写的连人类都无法识别，估计难以达到  数据集的准确率。
最后可以看到， 是非常适合新手阶段去尝试的，代码也十分简洁。不过由于底层隐藏的比较深，如果深入研究的话容易会遇到瓶颈，而且包装太多，想对他做出修改优化也不是太容易。后期研究还是建议使用  和 。个人在看 ，比  要简洁不少，而且大部分  都移植过去了， 最近热门全是他，潜力无限作者：  


我们可以在这里下载到最新的  版 下载链接
 内核改变 
什么是 
         
      
              
 是为了增强动画、布局、移动端手势领域的适用性，最重要的特性是对页面渲染的优化 允许将渲染方面的工作拆分为多段进行
其中 英文意思是纤维，众所周知， 是单线程的，当 在执行一段代码功能的过程中会对其他的代码进行堵塞
在如今越来越复杂的前端环境下，往往可能需要加载且渲染大量的节点，那么在渲染的过程中，即使我们使用了  进行维护，但是，也是会阻塞其他功能的进行。例如，当其他节点渲染的过程中，用户执行了某些交互操作，例如点击，输入，手势等， 由于在渲染的过程中会阻塞线程，导致 这些交互行为延迟，也就是在用户眼中的卡顿。
， 在这样的使用背景下， 团队在两年前就开始为我们研究，并且提供了  的新功能， 可以为我们提供如下几个功能：
 设置渲染任务的优先
 采用新的算法
 采用虚拟栈设计允许当优先级更高的渲染任务和较低优先的任务之间来回切换
 团队计划于   发布 目前已经发布了  版本详细介绍可以看 介绍视频

首先，我们可以先看一个栗子 使用  渲染谢 尔宾斯基三角形 很明显可以看出，在大数量节点渲染的情况下，使用原来正常的方式所渲染的页面要顺畅很多
使用
让我们来尝试一下  的使用对比正常的，做了一次升级
 首先引用改变了
   

 由于是版，所以渲染的时候，团队采用了这种方式
 以回调的形式进行
 从我们可以看出，这是渲染低优先级的函数

_ =
     = {
         我们可以通过回参取得旧
         更新组件之前的逻辑处理
         新的

         {
                  
        }
    }

在刚刚的例子中高优先级的渲染任务为父节点的动画 低优先级的渲染任务为每一个节点的数据渲染
的其他功能
同时  还提供了其他新功能允许 函数 处理多纬渲染
  = {

    {
      = 

     
     

      = {
      
        
           =
          
           =
          
        
      
    }

     
        {}
    
  }

}
可以看出，我们希望能够以一个数组的形式渲染多个节点渲染异常的降级错误处理
  = {
   {
 
}
}

  = {
   {
  
}
}

 {
 希望抛出错误
 
}   {
 进行错误降级处理
 
}
在之前，如上代码是无法执行到降级处理的，而在 中会允许降级处理，并且为我们提供完整可读的组件堆栈异常信息，这样我们就可以对渲染异常的错误进行捕获监控
重写服务器渲染方法，提供多个以流的渲染方法


直出同学的福音
有关  函数

对于 对象返回为  的情况下不会触发重新渲染
 的回调函数 会在所有组件渲染完成之前触发即   两个钩子之前

需要注意的问题
 已经依赖   和  类型，如果需要支持老旧浏览器场景   需要在场景内引入垫片库
 引入  垫片库
 
 

   
   


   
  

 还依赖  这一， 如果老旧浏览器不支持，可以使用 替代
 =  {
   
}

原文出处：社区 作为当下最火的容器技术，各企业都在积极拥抱 ，在  中，一个非常重要的元素就是 镜像  ，对于一些没有私密保护需求的镜像，我们可以选择将镜像推送到  ，但是对于一些比较私密的镜像，涉及到安全问题，就不能推送到  ，这就需要配置一个私有的 ，来存放我们的   久而久之，我们就需要一个好用的  来管理我们的 ， 推出的  是一个不错的选择。
安装
这里我使用的是   来配置  环境，首先，我们要先安装 
首先，更新下系统的软件包
  
然后，加入  的  
   

= 
=
=
=
=


接下来，使用   安装  
   

并启动 
   
   

安装 
 是一个定义及运行多个  容器的工具。使用   后，你只需要一个配置文件，就可以自动配置和启动多个容器，并自动解决容器之前的依赖问题
首先，我们来安装  
      

然后授予可执行权限
   

安装 
首先，我们要下载  的安装包。执行命令
 

解压我们下载好的压缩包
  
 
然后修改配置文件，修改为我们自己的需要参数
 

将其中的  修改为我们的公网 ，方便我们在公网中使用。

根据你的需要，也可以设置为内网 ，只在私有网内部使用。
配置完成后，运行安装脚本
 

当你看到这样的界面时，就说明安装好了，就可以开始使用了！

打开浏览器，输入我们绑定的地址
使用默认的帐号密码登录，就可以看到我们的界面了

接下来，就是使用  来管理我们的镜像！

相关推荐 在 上使用腾讯云  镜像加速构建 如何构建镜像 使用指南 一—— 基本操作 如何搭建及使用 作者 | 况鹰编辑 | 迷鹿

况鹰，腾讯高级工程师，目前主要负责手个性化增值及企鹅电竞助手业务开发与性能优化，在和端都有丰富的经验，闲暇之余比较爱折腾和研究各种新技术。

在直播如此火热的  年， 作为一名元老级开源组件在主播和开发面前继续展示着它常青的魅力。自己接触其源码小半年，发现国内的分析篇要么篇幅太短文不达意，要么内容太杂枯燥难懂，总是不令人满意。失望之余便想尝试挑战自己的审美观来分析一下这位美人，今天就首先来分析一下美人的个人状态。
、身世： 的爸爸是 ，自出生起发展截止目前主要分为两个阶段，第一代犹如未成熟的少女尚未绽开，在设计和代码上都存在较多的缺陷，追求者基本来自叫  的城市。随着工程的膨胀导致后期维护成本变高， 也不满足其发展，便对其进行了整容重构，工程的线条变得更加明朗婀娜，追求者也多了来自  和  的城市，人数直接翻了两倍多，而且在继续增长。
、皮肤变身：第一版用的是底层  写的窗口，所以大家会发现皮肤上面有很多痘痘： 基本一个控件一个句柄，第二版由于兼容  和 ，嵌入了全球著名皮肤精华水 ，像战网、、、优酷客户端、 等都用的这款牌子， 也紧跟潮流，成为了又一名「形象代言人」。
、琴棋书画： 之所以吸引人，主要根源于其具备极多的才艺，可以极大的满足大家的视听，我们来尝试梳理一下套路：

琴  音频编码：第一代用的 ，第二代迁移到 ，录制主要依靠就是 ，利用管道跨进程写文件录播；
棋  视频编码：软编 、硬编 、硬编 ，其中  主要用的 ，属于  流派， 顾名思义就是  股民们熟悉的  流派，相对于  在 编码方面性能更优 ；
书  推流：第一代和第二代都用了鼎鼎大名的  库，有推流地址和密钥便可以让所有主播上「电视」，斗鱼、熊猫、战旗、站、全民直播都可以用这种方式推送；
画  渲染引擎：第一代只支持 ，第二代支持分别封装了  和  ， 渲染脚本可以共用一份无差使用，语法用的 ，在  渲染时包装内会转换成 ，了解原理后可以非常方便的嵌入各种 ，可以加入更多的特效。            

、杂耍：第二版由于追求者众多，每个人都想在  上留下自己的印记， 除了学会了展示窗口、显示器、图片、幻灯片、视频、游戏、文字之外，还可以展示浏览器基于 、 视频等。在第二版所以这些印记可以方便替代升级，希望你也能鼓足勇气去贡献一把。
第一篇先简单带领大家了解  美女的「个人情况」，下一篇我将为大家介绍  的五官构成  代码架构组成。

相关推荐
写入源码分析
 线程模型源码分析作者：

前言
现在时富媒体时代，图片的重要性对于数十亿互联网用户来说不言而喻，图片本身就是像素点阵的合集，但是为了如何更快更好的存储图片而诞生了各种各样的图片格式：、、、等，而这次我们要拿来开刀的，就是。
简介
首先，是什么鬼？我们来看看上的一句话简介：

              

也就是说，是一种使用无损压缩的图片格式，而大家熟知的另外一种图片格式——则是采用有损压缩的方式。用通俗易懂的方式来讲，当原图片数据被编码成格式后，是可以完全还原成原本的图片数据的，而编码成则会损耗一部分图片数据，这是因为两者的编码方式和定位不同。着重于人眼的观感，保留更多的亮度信息，去掉一些不影响观感的色度信息，因此是有损耗的压缩。则保留原始所有的颜色信息，并且支持透明／通道，然后采用无损压缩进行编码。因此对于来说，通常适合颜色更丰富、可以在人眼识别不了的情况下尽可能去掉冗余颜色数据的图片，比如照片之类的图片；而适合需要保留原始图片信息、需要支持透明度的图片。
以下，我们来尝试获取编码的图片数据：
结构
图片是属于进制文件，因此在拿到图片并想对其进行解析的话，就得以二进制的方式进行读取操作。图片包含两部分：文件头和数据块。
文件头
的文件头就是图片的前个字节，其值为       ，人们常常把这个头称之为“魔数”。玩过的同学估计知道，可以使用命令类判断一个文件是属于格式类型，就算我们把这个文件类型的后缀改得乱七八糟也可以识别出来，用的就是判断“魔数”这个方法。有兴趣的同学还可以使用将这个“魔数”转成字符串看看，就知道为什么会取这个值作为文件头了。
用代码来判断也很简单：
 读取指定长度字节
    {
         
}

  =            

数据块
去掉了图片等前个字节，剩下的就是存放数据的数据块，我们通常称之为。
顾名思义，数据块就是一段数据，我们按照一定规则对图片这里指的是去掉了头的图片数据，下同进行切分，其中一段数据就是一个数据块。每个数据块的长度是不定的，我们需要通过一定的方法去提取出来，不过我们要先知道有哪些类型的数据块才好判断。
数据块类型
数据块类型有很多种，但是其中大部分我们都不需要用到，因为里面没有存储我们需要用到的数据。我们需要关注的数据块只有以下四种：

：存放图片信息。
：存放索引颜色。
：存放图片数据。
：图片数据结束标志。

只要解析这四种数据块就可以获取图片本身的所有数据，因此我们也称这四种数据块为“关键数据块”。
数据块格式
数据块格式如下：



描述
长度




数据块内容长度
字节


数据块类型
字节


数据块内容
不定字节


冗余校验码
字节



这样我们就可以轻易的指导当前数据块的长度了，即数据块内容长度  字节，用代码实现如下：
 读取位无符号整型数
   {
     =  || 
                         
}

  =   数据块内容长度
  =   数据块类型
  =   数据块内容
  =   冗余校验码

这里的冗余校验码在我们解码过程中用不到，所以这里不做详解。除此之外，数据块内容长度和数据块内容好解释，不过数据块类型有何作用呢，这里我们先将这个转成字符串类型：
 将数组转为字符串
  {
      = 
     = =  {
         = 
    }
     
}

 = 

然后会发现的值是四个大写英文字母，没错，这就是上面提到的数据块类型。上面还提到了我们只需要解析关键数据块，因此遇到不等于、、、中任意一个的数据块就直接舍弃好了。当我们拿到一个关键数据块，就直接解析其数据块内容就可以了，即上面代码中的字段。

类型为的数据块用来存放图片信息，其长度为固定的个字节：



描述
长度




图片宽度
字节


图片高度
字节


图像深度
字节


颜色类型
字节


压缩方法
字节


过滤方式
字节


扫描方式
字节



其中宽高很好解释，直接转成位整数，就是这张图片等宽高以像素为单位。压缩方法目前只支持一种 压缩算法，其值为；过滤方式也只有一种包含标准的种过滤类型，其值为；扫描方式有两种，一种是逐行扫描，值为，还有一种是隔行扫描，其值为，此次只针对普通的逐行扫描方式进行解析，因此暂时不考虑隔行扫描。
图片深度是指每个像素点中的每个通道占用的位数，只有、、、和这个值；颜色类型用来判断每个像素点中有多少个通道，只有、、、和这个值：



颜色类型的值
占用通道数
描述






灰度图像，只有个灰色通道




真彩色图像，有色通道




索引颜色图像，只有索引值一个通道




灰度图像  通道







类型为的数据块用来存放索引颜色，我们又称之为“调色板”。
由数据块解析出来的图像信息可知，图像的数据可能是以索引值的方式进行存储。当图片数据采用索引值的时候，调色板就起作用了。调色板的长度和图像深度有关，假设图像深度的值是，则其长度通常为的次幂  。原因是图像深度保存的就是通道占用的位数，而在使用索引颜色的时候，通道里存放的就是索引值，点次幂就表示这个通道可能存放的索引值有多少个，即调色板里的颜色数。而每个索引颜色是色通道存放的，因此此处还需要乘以。

通常使用索引颜色的情况下，图像深度的值即为，因而调色板里存放的颜色就只有种颜色，长度为  个字节。再加上位布尔值表示透明像素，这就是我们常说的图片了。


类型为的数据块用来存放图像数据，跟其他关键数据块不同的是，其数量可以是连续的复数个；其他关键数据块在个文件里有且只有个。
这里的数据得按顺序把所有连续的数据块全部解析并将数据联合起来才能进行最终处理，这里先略过。
  = 
  =   总数据长度

  

 存在数据块  {
    
     = 
}


当解析到类型为的数据块时，就表明所有的数据块已经解析完毕，我们就可以停止解析了。
整个数据块的值时固定的：           ，因为数据块没有数据块内容，所以其数据块内容长度字段数据块前个字节的值也是。
解析
解压缩
当我们收集完的所有数据块内容时，我们要先对其进行解压缩：
  = 

  =  
  = 
 = {
     = { = }
}

 解压缩
 =  

扫描
上面说过，此次我们只考虑逐行扫描的方式：
 读取位无符号整型数
   {
     =  || 
       
}

   解析数据块时得到的图像宽度
   解析数据块时得到的图像高度
   解析数据块时得到的通道数
   解析数据块时得到的图像深度

  =        每像素字节数
  =     每行字节数

  =        存储过滤后的像素数据
  =   当前行的偏移位置

 逐行扫描解析
 = =  = {
      =     当前行
      =    

     第一个字节代表过滤类型
      {
         
            
            
         
            
            
         
            
            
         
            
            
         
            
            
        
              未知过滤类型！
    }

     = 
}

上面代码前半部分不难理解，就是通过之前解析得到的图像宽高，再加上图像深度和通道数计算得出每个像素占用的字节数和每一行数据占用的字节数。因此我们就可以拆分出每一行的数据和每一个像素的数据。
在得到每一行数据后，就要进行这个编码里最关键的步——过滤。
过滤
早先我们说过过滤方法只有种，其中包含种过滤类型，图像每一行数据里的第一个字节就表示当前行数什么过滤类型。
为什么要对图像数据进行过滤呢？
大多数情况下，图像的相邻像素点的色值时很相近的，而且很容易呈现线性变化相邻数据的值是相似或有某种规律变化的，因此借由这个特性对图像的数据进行一定程度的压缩。针对这种情况我们常常使用一种叫差分编码的编码方式，即是记录当前数据和某个标准值的差距来存储当前数据。
比如说有这么一个数组    ，我们可以将其转存为    。转存的规则就是以数组第位为标准值，标准值存储原始数据，后续均存储以前位数据的差值。
当我们使用了差分编码后，再进行压缩的话，效果会更好压缩是延伸出来的一种算法，压缩频繁重复出现的数据段的效果是相当不错的，有兴趣的同学可自行去了解。
好，回到正题来讲的种过滤类型，首先我们要定义几个变量以便于说明：
 
 

：当前像素。
：当前像素点左边的像素。
：当前像素点上边的像素。
：当前像素点左上边的像素。

过滤类型：
这个没啥好解释的，就是完全不做任何过滤。
     {
     =   {
           = 
    }
}

过滤类型：
记录  的值，即当前像素和左边像素的差值。左边起第一个像素是标准值，不做任何过滤。
     {
     =   {
           {
             第一个像素，不作解析
               = 
        }  {
             其他像素
              =     

              =   
               =   
        }
    }
}

过滤类型：
记录  的值，即当前像素和上边像素点差值。如果当前行是第行，则当前行数标准值，不做任何过滤。
     {
       {
         第一行，不作解析
         =   {
               = 
        }
    }  {
         =   {
              =     

              =   
               =   
        }
    }
}

过滤类型：
记录      的值，即当前像素与左边像素和上边像素的平均值的差值。

如果当前行数第一行：做特殊的过滤，左边起第一个像素是标准值，不做任何过滤。其他像素记录该像素与左边像素的二分之一的值的差值。
如果当前行数不是第一行：左边起第一个像素记录该像素与上边像素的二分之一的值的差值，其他像素做正常的过滤。

     {
       {
         第一行，只做
         =   {
               {
                 第一个像素，不作解析
                   = 
            }  {
                 其他像素
                  =     

                  =       需要除以
                   =   
            }
        }
    }  {
         =   {
               {
                 第一个像素，只做
                  =     

                  =       需要除以
                   =   
            }  {
                 其他像素
                  =     
                  =     

                  =       
                   =   
            }
        }
    }
}

过滤类型：
记录  的值，这种过滤方式比较复杂，的计算方式伪代码如下：
 =     
 =   
 =   
 =   
  =    =    = 
   =    = 
  = 
 

如果当前行数第一行：做过滤。
如果当前行数不是第一行：左边起第一个像素记录该像素与上边像素的差值，其他像素做正常的过滤。

     {
       {
         第一行，只做
         =   {
               {
                 第一个像素，不作解析
                   = 
            }  {
                 其他像素
                  =     

                  =   
                   =   
            }
        }
    }  {
         =   {
               {
                 第一个像素，只做
                  =     

                  =   
                   =   
            }  {
                 其他像素
                  =     
                  =     
                  =       

                  =     
                  =   
                  =   
                  =   
                 

                  =    =   = 
                   =   = 
                  = 

                  =   
                   =   
            }
        }
    }
}

获取像素
到这里，解析的工作就做完了，上面代码里的数组里存的就是像素的数据了，不过我们要如何获取具体某个像素的数据呢？方式可参考下面代码：
   数据块内容，即调色板内容
   解析数据块时得到的颜色类型
   透明像素面板，解析数据块获得

   {
       ||  =  ||    ||  =  {
          或的值超出了图像边界！
    }

      =        每像素字节数
      =        

     {
          
             灰度图像
                
          
             真彩色图像
                    
          
             索引颜色图像
              = 

              = 
             ===   = 

                            
          
             灰度图像  通道
                  
          
             真彩色图像  通道
                      
    }
}


此处用到了非关键数据块的数据，不过这里不做讲解，有兴趣的同学可去官网了解：此数据块的结构相当简单

尾声
的解析流程可以由这一张图简单概括：

此文只对图片的格式做了简单的介绍，我们也知道如何对一张图片做简单的解析。上面出现的代码只是代码片段，如果对完整代码有兴趣的同学可以戳这里，虽然代码仓库还在建设过程中，不过关于简单的图片解析部分已经完成。
参考资料：



__系列推荐
机器学习概念总结笔记一机器学习概念总结笔记二机器学习概念总结笔记四
分类决策树
算法继承了算法的优点，并在以下几方面对算法进行了改进： 用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足； 在树构造过程中进行剪枝； 能够完成对连续属性的离散化处理； 能够对不完整数据进行处理。
算法有如下优点：产生的分类规则易于理解，准确率较高。其缺点是：在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。此外，只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时程序无法运行。
构建一个决策树时，有个重点，第一个是构建树的过程中首先选择哪个属性进行判断，即选择哪个属性作为根节点。 这个叫做属性选择度量，度量方式常见的有种， 使用信息增益度， 采用信息增益率， 采用指标。第二个是如何修剪这棵树，即减枝。
信息增益率使用“分裂信息”值将信息增益规范化。分类信息类似于，定义如下：

这个值表示通过将训练数据集划分成对应于属性测试的个输出的个划分产生的信息。信息增益率定义：
选择具有最大增益率的属性作为分裂属性。
集成学习
集成学习英文：  是使用一系列学习器进行学习，并使用某种规则把各个学习结果进行整合从而获得比单个学习器更好的学习效果的一种机器学习方法。集成学习的思路是在对新的实例进行分类的时候，把若干个单个分类器集成起来，通过对多个分类器的分类结果进行某种组合来决定最终的分类，以取得比单个分类器更好的性能。如果把单个分类器比作一个决策者的话，集成学习的方法就相当于多个决策者共同进行一项决策。
集成学习方法是机器学习领域中用来提升分类算法准确率的技术，主要包括和即装袋和提升。
集成学习之算法
装袋算法采取自助法的思路，从样本中随机抽样，形成多个训练样本，生成多个树模型。然后以多数投票的方式来预测结果。相同的分类器，各个分类器是独立的；使用同一个算法对样本多次训练，建立多个独立的分类器；最终的输出为各个分类器的投票用于分类或取平均值用于数值预测。
集成学习之算法
方法是一种用来提高弱分类算法准确度的方法这种方法通过构造一个预测函数系列然后以一定的方式将他们组合成一个预测函数。他是一种框架算法主要是通过对样本集的操作获得样本子集然后用弱分类算法在样本子集上训练生成一系列的基分类器。他可以用来提高其他弱分类算法的识别率也就是将其他的弱分类算法作为基分类算法放于 框架中通过框架对训练样本集的操作得到不同的训练样本子集用该样本子集去训练生成基分类器每得到一个样本集就用该基分类算法在该样本集上产生一个基分类器这样在给定训练轮数  后就可产生  个基分类器然后框架算法将这 个基分类器进行加权融合产生一个最后的结果分类器在这 个基分类器中每个单个的分类器的识别率不一定很高但他们联合后的结果有很高的识别率这样便提高了该弱分类算法的识别率。在产生单个的基分类器时可用相同的分类算法也可用不同的分类算法这些算法一般是不稳定的弱分类算法如神经网络 决策树等。
最早由 提出， 对其进行了改进。通过这种方法可以产生一系列神经网络，各网络的训练集决定于在其之前产生的网络的表现，被已有网络错误判断的示例将以较大的概率出现在新网络的训练集中。这样，新网络将能够很好地处理对已有网络来说很困难的示例。另一方面，虽然方法能够增强神经网络集成的泛化能力，但是同时也有可能使集成过分偏向于某几个特别困难的示例。因此，该方法不太稳定，有时能起到很好的作用，有时却没有效果 。值得注意的是，  和  的算法在解决实际问题时有一个重大缺陷，即它们都要求事先知道弱学习算法学习正确率的下限，这在实际问题中很难做到。年，和 提出了 算法，该算法的效率与算法 很接近，却可以非常容易地应用到实际问题中，因此，该算法已成为目前最流行的算法。
 方法中，各神经网络的训练集由从原始训练集中随机选取若干示例组成，训练集的规模通常与原始训练集相当，训练例允许重复选取。这样，原始训练集中某些示例可能在新的训练集中出现多次，而另外一些示例则可能一次也不出现。方法通过重新选取训练集增加了神经网络集成的差异度，从而提高了泛化能力。 指出，稳定性是能否发挥作用的关键因素，能提高不稳定学习算法的预测精度，而对稳定的学习算法效果不明显，有时甚至使预测精度降低。学习算法的稳定性是指如果训练集有较小的变化，学习结果不会发生较大变化，例如，最近邻方法是稳定的，而判定树、神经网络等方法是不稳定的。
与 的区别在于 的训练集的选择是随机的，各轮训练集之间相互独立，而的训练集的选择不是独立的，各轮训练集的选择与前面各轮的学习结果有关； 的各个预测函数没有权重，而是有权重的；的各个预测函数可以并行生成，而的各个预测函数只能顺序生成。对于象神经网络这样极为耗时的学习方法，可通过并行训练节省大量时间开销。
此外还存在多种个体生成方法。例如，有些研究者 利用遗传算法来产生神经网络集成中的个体；有些研究者使用不同的目标函数、隐层神经元数、权空间初始点等来训练不同的网络，从而获得神经网络集成的个体。
集成学习之随机森林算法
随机森林 算法，指的是利用多棵树对样本进行训练并预测的一种分类器。该分类器最早由 和 提出，并被注册成了商标。简单来说，随机森林就是由多棵   构成的。对于每棵树，它们使用的训练集是从总的训练集中有放回采样出来的，这意味着，总的训练集中的有些样本可能多次出现在一棵树的训练集中，也可能从未出现在一棵树的训练集中。在训练每棵树的节点时，使用的特征是从所有特征中按照一定比例随机地无放回的抽取的，根据 的建议，假设总的特征数量为，这个比例可以是。
因此，随机森林的训练过程可以总结如下：
给定训练集，测试集，特征维数。确定参数：使用到的的数量，每棵树的深度，每个节点使用到的特征数量，终止条件：节点上最少样本数，节点上最少的信息增益，对于第棵树，=
从中有放回的抽取大小和一样的训练集，作为根节点的样本，从根节点开始训练。
如果当前节点上达到终止条件，则设置当前节点为叶子节点，如果是分类问题，该叶子节点的预测输出为当前节点样本集合中数量最多的那一类，概率为占当前样本集的比例；如果是回归问题，预测输出为当前节点样本集各个样本值的平均值。然后继续训练其他节点。如果当前节点没有达到终止条件，则从维特征中无放回的随机选取维特征。利用这维特征，寻找分类效果最好的一维特征及其阈值，当前节点上样本第维特征小于的样本被划分到左节点，其余的被划分到右节点。继续训练其他节点。有关分类效果的评判标准在后面会讲。
重复直到所有节点都训练过了或者被标记为叶子节点。
重复直到所有都被训练过。
利用随机森林的预测过程如下：
对于第棵树，=：
从当前树的根节点开始，根据当前节点的阈值，判断是进入左节点还是进入右节点=，直到到达，某个叶子节点，并输出预测值。
重复执行直到所有棵树都输出了预测值。如果是分类问题，则输出为所有树中预测概率总和最大的那一个类，即对每个的进行累计；如果是回归问题，则输出为所有树的输出的平均值。
集成学习之迭代决策树算法
   迭代决策树 又叫    ，是一种迭代的决策树算法，该算法由多棵决策树组成，所有树的结论累加起来做最终答案。
有个特征。 第一个是构建的树是回归决策树， 第二个是采用梯度迭代 ， 第三个是缩减技术。
回归树   ，提起决策树   绝大部分人首先想到的就是分类决策树。但如果一开始就把中的树想成分类树，那就是一条歪路走到黑，一路各种坑，所以说千万不要以为是很多棵分类树。决策树分为两大类，回归树和分类树。前者用于预测实数值，如明天的温度、用户的年龄、网页的相关程度；后者用于分类标签值，如晴天阴天雾雨、用户性别、网页是否是垃圾页面。这里要强调的是，前者的结果加减是有意义的，如岁岁岁=岁，后者则无意义，如男男女=到底是男是女？ 的核心在于累加所有树的结果作为最终结果，就像前面对年龄的累加是加负，而分类树的结果显然是没办法累加的，所以中的树都是回归树，不是分类树，这点对理解相当重要尽管调整后也可用于分类但不代表的树是分类树。
，迭代，即通过迭代多棵树来共同决策。这怎么实现呢？难道是每棵树独立训练一遍，比如这个人，第一棵树认为是岁，第二棵树认为是岁，第三棵树认为是岁，我们就取平均值岁做最终结论？当然不是！且不说这是投票方法并不是，只要训练集不变，独立训练三次的三棵树必定完全相同，这样做完全没有意义。之前说过，是把所有树的结论累加起来做最终结论的，所以可以想到每棵树的结论并不是年龄本身，而是年龄的一个累加量。的核心就在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。比如的真实年龄是岁，但第一棵树的预测年龄是岁，差了岁，即残差为岁。那么在第二棵树里我们把的年龄设为岁去学习，如果第二棵树真的能把分到岁的叶子节点，那累加两棵树的结论就是的真实年龄；如果第二棵树的结论是岁，则仍然存在岁的残差，第三棵树里的年龄就变成岁，继续学。这就是 在中的意义。
缩减的思想认为，每次走一小步逐渐逼近结果的效果，要比每次迈一大步很快逼近结果的方式更容易避免过拟合。即它不完全信任每一个棵残差树，它认为每棵树只学到了真理的一小部分，累加的时候只累加一小部分，通过多学几棵树弥补不足。用方程来看更清晰，即没用时：表示第棵树上的预测值， 表示前棵树的综合预测值
 = 残差， 其中： 残差 =  真实值    
   =   
不改变第一个方程，只把第二个方程改为：
   =       
即仍然以残差作为学习目标，但对于残差学习出来的结果，只累加一小部分残差逐步逼近目标，一般都比较小，如注意该非的，导致各个树的残差是渐变的而不是陡变的。直觉上这也很好理解，不像直接用残差一步修复误差，而是只修复一点点，其实就是把大步切成了很多小步。本质上，为每棵树设置了一个，累加时要乘以这个，但和并没有关系。这个就是。就像一样，能减少过拟合发生也是经验证明的，目前还没有看到从理论的证明。
算法之算法
方法有许多不同的变形。其中最流行的一种就是方法，这个名称是“ ”的缩写。这个方法允许设计者不断地加入新的“弱分类器”，直到达到某个预定的足够小的误差率。在方法中，每一个训练样本都被赋予一个权重，表明它被某个分类分类器选入训练集的概率。如果某个样本点已经被准确分类，那么在构造下一个训练集中，它被选中的概率就被降低；相反，如果某个样本点没有被正确分类，那么它的权重就得到提高。通过这样的方式，方法能够“聚焦于”较为困难更富有信息的样本上。在具体实现上，最初令每一个样本的权重都相同，对于第次迭代操作，我们就根据这些权重来选取样本点，进而训练分类器，然后根据这个分类器来提高被他错分的那些样本点的权重，并降低被正确分类的样本权重。


邻近算法，或者说最近邻，分类算法是数据挖掘分类技术中最简单的方法之一。所谓最近邻，就是个最近的邻居的意思，说的是每个样本都可以用它最接近的个邻居来代表。
算法的核心思想是如果一个样本在特征空间中的个最相邻的样本中的大多数属于某一个类别，则该样本也属于这个类别，并具有这个类别上样本的特性。该方法在确定分类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 方法在类别决策时，只与极少量的相邻样本有关。由于方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，方法较其他方法更为适合。
算法流程如下： 准备数据，对数据进行预处理； 选用合适的数据结构存储训练数据和测试元组； 设定参数，如；维护一个大小为的的按距离由大到小的优先级队列，用于存储最近邻训练元组。随机从训练元组中选取个元组作为初始的最近邻元组，分别计算测试元组到这个元组的距离，将训练元组标号和距离存入优先级队列； 遍历训练元组集，计算当前训练元组与测试元组的距离，将所得距离 与优先级队列中的最大距离； 进行比较。若=，则舍弃该元组，遍历下一个元组。若  ，删除优先级队列中最大距离的元组，将当前训练元组存入优先级队列。 遍历完毕，计算优先级队列中 个元组的多数类，并将其作为测试元组的类别。 测试元组集测试完毕后计算误差率，继续设定不同的值重新进行训练，最后取误差率最小的 值；
的优点在于：简单，易于理解，易于实现，无需估计参数，无需训练； 适合对稀有事件进行分类；特别适合于多分类问题对象具有多个类别标签， 比的表现要好。
的缺点在于：该算法在分类时有个主要的不足是，当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的个邻居中大容量类的样本占多数。 该算法只计算“最近的”邻居样本，某一类的样本数量很大，那么或者这类样本并不接近目标样本，或者这类样本很靠近目标样本。无论怎样，数量并不能影响运行结果。该方法的另一个不足之处是计算量较大，因为对每一个待分类的文本都要计算它到全体已知样本的距离，才能求得它的个最近邻点。可理解性差，无法给出像决策树那样的规则。
神经网络
人工神经元是神经网络的基本元素，其原理可以用下图表示：

常见的激活函数有以下类：

神经网络是由大量的神经元互联而构成的网络。根据网络中神经元的互联方式，常见网络结构主要可以分为下面３类： 
 前馈神经网络      前馈网络也称前向网络。这种网络只在训练过程会有反馈信号，而在分类过程中数据只能向前传送，直到到达输出层，层间没有向后的反馈信号，因此被称为前馈网络。感知机 与神经网络就属于前馈网络。图是一个层的前馈神经网络，其中第一层是输入单元，第二层称为隐含层，第三层称为输出层输入单元不是神经元，因此图中有层神经元
 反馈神经网络    反馈型神经网络是一种从输出到输入具有反馈连接的神经网络，其结构比前馈网络要复杂得多。典型的反馈型神经网络有：网络和网络；
 自组织网络      自组织神经网络是一种无监督学习网络。它通过自动寻找样本中的内在规律和本质属性，自组织、自适应地改变网络参数与结构；

 网络是年由和为首的科学家小组提出，是一种按误差逆传播算法训练的多层前馈网络，是目前应用最广泛的神经网络模型之一。网络能学习和存贮大量的输入输出模式映射关系，而无需事前揭示描述这种映射关系的数学方程。它的学习规则是使用最速下降法，通过反向传播来不断调整网络的权值和阈值，使网络的误差平方和最小。神经网络模型拓扑结构包括输入层、隐层 和输出层 。
是后向传播的英文缩写，那么传播对象是什么？传播的目的是什么？传播的方式是后向，可这又是什么意思呢。传播的对象是误差，传播的目的是得到所有层的估计误差，后向是说由后层误差推导前层误差：
的思想可以总结为利用输出后的误差来估计输出层的直接前导层的误差，再用这个误差估计更前一层的误差，如此一层一层的反传下去，就获得了所有其他各层的误差估计。 网络能学习和存贮大量的输入输出模式映射关系，而无需事前揭示描述这种映射关系的数学方程。利用一种称为激活函数来描述层与层输出之间的关系，从而模拟各层神经元之间的交互反应。激活函数必须满足处处可导的条件。
更多详见：机器学习概念总结笔记一机器学习概念总结笔记二机器学习概念总结笔记四和，作为近些年最常用的缓存服务器，相信大家对它们再熟悉不过了。前两年还在学校时，我曾经读过它们的主要源码，如今写篇笔记从个人角度简单对比一下它们的实现方式，权当做复习，有理解错误之处，欢迎指正。
文中使用的架构类的图片大多来自于网络，有部分图与最新实现有出入，文中已经指出。
一 综述
读一个软件的源码，首先要弄懂软件是用作干什么的，那和是干啥的？众所周知，数据一般会放在数据库中，但是查询数据会相对比较慢，特别是用户很多时，频繁的查询，需要耗费大量的时间。怎么办呢？数据放在哪里查询快？那肯定是内存中。和就是将数据存储在内存中，按照的方式查询，可以大幅度提高效率。所以一般它们都用做缓存服务器，缓存常用的数据，需要查询的时候，直接从它们那儿获取，减少查询数据库的次数，提高查询效率。
二 服务方式
和怎么提供服务呢？它们是独立的进程，需要的话，还可以让他们变成进程，所以我们的用户进程要使用和的服务的话，就需要进程间通信了。考虑到用户进程和和不一定在同一台机器上，所以还需要支持网络间通信。因此，和自己本身就是网络服务器，用户进程通过与他们通过网络来传输数据，显然最简单和最常用的就是使用连接了。另外，和都支持协议。而且当用户进程和和在同一机器时，还可以使用域套接字通信。
三 事件模型
下面开始讲他们具体是怎么实现的了。首先来看一下它们的事件模型。
自从出来以后，几乎所有的网络服务器全都抛弃和，换成了。也一样，只不多它还提供对和的支持，可以自己配置使用哪一个，但是一般都是用。另外针对，还支持使用。而是基于的，不过底层也是使用的，所以可以认为它们都是使用。的特性这里就不介绍了，网上介绍文章很多。
它们都使用来做事件循环，不过是单线程的服务器也是多线程的，只不过除了主线程以外，其他线程没有 ，只是会进行一些后台存储工作，而是多线程的。 的事件模型很简单，只有一个 ，是简单的实现。不过事件模型中有一个亮点，我们知道是针对的，它返回的就绪事件也是只有，里面的就是服务器与客户端连接的的，但是处理的时候，需要根据这个找到具体的客户端的信息，怎么找呢？通常的处理方式就是用红黑树将与客户端信息保存起来，通过查找，效率是。不过比较特殊，的客户端的数量上限可以设置，即可以知道同一时刻，所打开的的上限，而我们知道，进程的在同一时刻是不会重复的只有关闭后才能复用，所以使用一个数组，将作为数组的下标，数组的元素就是客户端的信息，这样，直接通过就能定位客户端信息，查找效率是，还省去了复杂的红黑树的实现我曾经用写一个网络服务器，就因为要保持和对应关系，不想自己写红黑树，然后用了里面的，导致项目变成了的，最后项目使用编译，这事我不说谁知道？。显然这种方式只能针对数量上限已确定，并且不是太大的网络服务器，像这种服务器就不适用，就是自己写了红黑树。
而是多线程的，使用的方式，主线程监听端口，建立连接，然后顺序分配给各个工作线程。每一个从线程都有一个 ，它们服务不同的客户端。线程和线程之间使用管道通信，每一个工作线程都会创建一个管道，然后保存写端和读端，并且将读端加入 ，监听可读事件。同时，每个从线程都有一个就绪连接队列，主线程连接连接后，将连接的放入这个队列，然后往该线程的管道的写端写入一个命令，这样 中加入的管道读端就会就绪，从线程读取命令，解析命令发现是有连接，然后就会去自己的就绪队列中获取连接，并进行处理。多线程的优势就是可以充分发挥多核的优势，不过编写程序麻烦一点，里面就有各种锁和条件变量来进行线程同步。
四 内存分配
和的核心任务都是在内存中操作数据，内存管理自然是核心的内容。
首先看看他们的内存分配方式。是有自己得内存池的，即预先分配一大块内存，然后接下来分配内存就从内存池中分配，这样可以减少内存分配的次数，提高效率，这也是大部分网络服务器的实现方式，只不过各个内存池的管理方式根据具体情况而不同。而没有自己得内存池，而是直接使用时分配，即什么时候需要什么时候分配，内存管理的事交给内核，自己只负责取和释放既是单线程，又没有自己的内存池，是不是感觉实现的太简单了？那是因为它的重点都放在数据库模块了。不过支持使用来替换的，前者是的产品，比的快。
由于没有自己的内存池，所以内存申请和释放的管理就简单很多，直接和即可，十分方便。而是支持内存池的，所以内存申请是从内存池中获取，而也是还给内存池，所以需要很多额外的管理操作，实现起来麻烦很多，具体的会在后面的机制讲解中分析。
五 数据库实现
接下来看看他们的最核心内容，各自数据库的实现。
 数据库实现
 只支持，即只能一个对于一个。它的数据在内存中也是这样以对的方式存储，它使用机制。
 首先看是如何存储数据的，即存储对。如下图，每一个对都存储在一个结构中，包含了相关的属性和和的值。
 是保存对的，当多的时候，怎么查找特定的是个问题。所以维护了一个表，它用于快速查找。表适用开链法与一样解决键的冲突，每一个表的桶里面存储了一个链表，链表节点就是的指针，如上图中的_就是指桶里面的链表的下一个节点。 表支持扩容的数量是桶的数量的以上时扩容，有一个_，还有一个_，其中正常适用_，但是扩容的时候，将_ = _，然后_设置为新申请的表桶的数量乘以，然后依次将_ 里面的数据往新的表里面移动，并用一个变量_记录以及移动了多少个桶，移动完成后，再原来的_ 即可也是有两个表，也是移动，不过不是后台线程完成，而是每次移动一个桶。扩容的操作，专门有一个后台扩容的线程来完成，需要扩容的时候，使用条件变量通知它，完成扩容后，它又考试阻塞等待扩容的条件变量。这样在扩容的时候，查找一个可能会在_和_的任意一个中，需要根据比较它的桶的位置和_的大小来比较确定它在哪个表里。
是从哪里分配的呢？从中。如下图，有很多，它们管理，每一个其实是的集合，真正的是在中分配的，一个分配一个。一个中的的大小一样，不同的，的大小按比例递增，需要新申请一个的时候，根据它的大小来选择，规则是比它大的最小的那个。这样，不同大小的就分配在不同的中，归不同的管理。 这样的缺点是会有部分内存浪费，因为一个可能比大，如图，分配的的时候，选择的，但是会有的浪费，这部分内存资源没有使用。

如上图，整个构造就是这样，管理，一个有一个_，可以管理多个，同一个中的的大小都一样。有一个指针，保存了未分配的已经被掉的不是真的内存，只是不用了而已，有不用的时候，就放入的头部，这样每次需要在当前中分配的时候，直接取取即可，不用管是未分配过的还是被释放掉的。
然后，每一个对应一个链表，有数组和数组，它们分别保存了链表的头节点和尾节点。链表中的节点就是改所分配的，新分配的放在头部，链表越往后的，表示它已经很久没有被使用了。当的内存不足，需要删除一些过期的时候，就可以从链表的尾部开始删除，没错，这个链表就是为了实现。光靠它还不行，因为链表的查询是的，所以定位的时候，使用表，这已经有了，所有分配的已经在表中了，所以，用于查找，然后链表有用存储的最近使用顺序，这也是的标准实现方法。
每次需要新分配的时候，找到对于的链表，从尾部往前找，看是否已经过期，过期的话，直接就用这个过期的当做新的。没有过期的，则需要从中分配，如果用完了，则需要往中添加了。
支持设置过期时间，即 ，但是内部并不定期检查数据是否过期，而是客户进程使用该数据的时候，会检查 ，如果过期，直接返回错误。这样的优点是，不需要额外的来进行 的检查，缺点是有可能过期数据很久不被使用，则一直没有被释放，占用内存。
是多线程的，而且只维护了一个数据库，所以可能有多个客户进程操作同一个数据，这就有可能产生问题。比如，已经把数据更改了，然后也更改了改数据，那么的操作就被覆盖了，而可能不知道，任务数据现在的状态时他改完后的那个值，这样就可能产生问题。为了解决这个问题，使用了协议，简单说就是保存一个位的 值，标记数据的版本，每更新一次数据值有修改，版本号增加，然后每次对数据进行更改操作，需要比对客户进程传来的版本号和服务器这边的版本号是否一致，一致则可进行更改操作，否则提示脏数据。
 以上就是如何实现一个的数据库的介绍。
 数据库实现
首先数据库的功能强大一些，因为不像只支持保存字符串，支持， ， ， ，  种数据结构。例如存储一个人的信息就可以使用 ，用人的名字做，然后 ，  ， 通过 和 ，就可以取到名字，或者通过和，就可以取到年龄。这样，当只需要取得的时候，不需要把人的整个信息取回来，然后从里面找，直接获取即可，高效方便。
为了实现这些数据结构，定义了抽象的对象 ，如下图。每一个对象有类型，一共种：字符串，链表，集合，有序集合，哈希表。 同时，为了提高效率，为每种类型准备了多种实现方式，根据特定的场景来选择合适的实现方式，就是表示对象的实现方式的。然后还有记录了对象的，即上次被访问的时间，同时在 服务器中会记录一个当前的时间近似值，因为这个时间只是每隔一定时间，服务器进行自动维护的时候才更新，它们两个只差就可以计算出对象多久没有被访问了。 然后 中还有引用计数，这是为了共享对象，然后确定对象的删除时间用的。最后使用一个指针来指向对象的真正内容。正式由于使用了抽象 ，使得数据库操作数据时方便很多，全部统一使用 对象即可，需要区分对象类型的时候，再根据来判断。而且正式由于采用了这种面向对象的方法，让的代码看起来很像代码，其实全是用写的。
 _      字符串类型
 _          链表类型
 _          集合类型无序的，可以求差集，并集等
 _          有序的集合类型
 _          哈希类型

 __            未加工
 __          
 __            
 __       
 __        
 __      
 __       
 __       
 __      
                                                                       

   {
                  对象的类型，包括    
              底部为了节省空间，一种的数据，
                                                 可   以采用不同的存储方式
     __       
               引用计数
     
} 
说到底还是一个的数据库，不管它支持多少种数据结构，最终存储的还是以的方式，只不过可以是链表，， ， 等。和一样，所有的都是，而， ， 等具体存储的时候也用到了。 而没有现成的，所以的首要任务就是实现一个，取名叫  ，如下的代码， 非常简单的一个结构体，存储改的内存总长度，表示还有多少字节没有使用，而存储具体的数据，显然就是目前字符串的长度。
  {
     
     
     
}
字符串解决了，所有的都存成就行了，那么和怎么关联呢？的格式在脚本语言中很好处理，直接使用字典即可，没有字典，怎么办呢？自己写一个呗十分热衷于造轮子。看下面的代码，存额外信息，用的很少，至少我们发现。 是具体的哈希表，一个对应两张哈希表，这是为了扩容包括也是为了扩容。存储了哈希表的属性。还为实现了迭代器所以说看起来像代码。
哈希表的具体实现是和类似的做法，也是使用开链法来解决冲突，不过里面用到了一些小技巧。比如使用存储函数指针，可以动态配置桶里面元素的操作方法。又比如中保存的取桶的数量，用它与做操作来代替取余运算，加快速度等等。总的来看，里面有两个哈希表，每个哈希表的桶里面存储链表，存储具体的和。
前面说过，一个对于两个，是为了扩容其实还有缩容。正常的时候，只使用，当中已有的数量与桶的数量达到一定的比例后，就会触发扩容和缩容操作，我们统称为，这时，为申请后的大小的内存，然后把里的数据往里面移动，并用记录当前已经移动万的桶的数量，当所有桶都移完后，完成，这时将变成 将原来的变成，并变为即可。不同于，这里不用开一个后台线程来做，而是就在 中完成，并且不是一次性完成，而是分成多次，每次用户操作之前，移动一个桶的数据，直到完成。这样就把移动分成多个小移动完成，把的时间开销均分到用户每个操作上，这样避免了用户一个请求导致的时候，需要等待很长时间，直到完成才有返回的情况。不过在期间，每个操作都变慢了点，而且用户还不知道在他的请求中间添加了移动数据的操作，感觉太贱了 
   {
          哈希表的相关属性
          额外信息
          两张哈希表，分主和副，用于扩容
             ==    记录当前数据迁移的位置，在扩容的时候用的
                 目前存在的迭代器的数量
} 

   {
        是，多个组成桶里面的链表，则是多个链表头指针组成的数组的指针
           这个就是桶的数量
     取   然后一个数据来的时候，通过计算出的 让  来确定它要放的桶的位置
     当取的时候，就是，这样就和  有一样的效果，但是使用会快很多。这就是原因
        
               已经数值的数量
} 

   {
              的方法
              的复制方法
              的复制方法
                 之间的比较
             的析构
             的析构
} 

   {
     
     {
         
        _ 
        _ 
    } 
      
} 
有了，数据库就好实现了。所有数据读存储在中，存储成中的，用 指向一个 ，它可以是种类型中的任何一种。如下图，结构构造是这样，不过这个图已经过时了，有一些与不符合的地方。
中的对象，每一个都至少有两种底层实现方式。有种：__ __ __， 有：普通双向链表和压缩链表，压缩链表简单的说，就是讲数组改造成链表，连续的空间，然后通过存储字符串的大小信息来模拟链表，相对普通链表来说可以节省空间，不过有副作用，由于是连续的空间，所以改变内存大小的时候，需要重新分配，并且由于保存了字符串的字节大小，所有有可能引起连续更新具体实现请详细看代码。有和全是整数的时候使用它来存储，  有：和， 实现有压缩列表和和。就是跳表，它有接近于红黑树的效率，但是实现起来比红黑树简单很多，所以被采用奇怪，这里又不造轮子了，难道因为这个轮子有点难？。  可以使用实现，则改中，每个中保存了这是哈希表中的键值对的，而则保存了，它们都是。 而中的，每个中保存了中具体的一个元素的值，则为。图中的有序集合有误，使用和实现，首先很好理解，就把它当做红黑树的替代品就行，和红黑树一样，它也可以排序。怎么用存储呢？首先在中，每个中的元素都有一个分值，用它来排序。所以在中，按照分值大小，先存元素，再存它的，再存下一个元素，然后。这样连续存储，所以插入或者删除的时候，都需要重新分配内存。所以当元素超过一定数量，或者某个元素的字符数超过一定数量，就会选择使用来实现如果当前使用的是，会将这个中的数据取出，存入一个新的，然后删除改，这就是底层实现转换，其余类型的 也是可以转换的。 另外，如何实现呢？其实也很简单，就是存储一个，存储一个，再存储一个，再存储一个。还是顺序存储，与实现类似，所以当元素超过一定数量，或者某个元素的字符数超过一定数量时，就会转换成来实现。各种底层实现方式是可以转换的，可以根据情况选择最合适的实现方式，这也是这样使用类似面向对象的实现方式的好处。
需要指出的是，使用来实现的时候，其实还用了一个，这个存储一样的键值对。为什么呢？因为的查找只是的可能变成，而可以到， 所以使用一个来加速查找，由于和可以指向同一个 ，所以不会浪费太多内存。另外使用实现的时候，为什么不用来加速查找呢？因为支持的元素个数很少个数多时就转换成了，顺序遍历也很快，所以不用了。
这样看来，上面的，，，， 都是很有考量的，它们配合实现了一个具有面向对象色彩的灵活、高效数据库。不得不说，数据库的设计还是很厉害的。
与不同的是，的数据库不止一个，默认就有个，编号。客户可以选择使用哪一个数据库，默认使用号数据库。 不同的数据库数据不共享，即在不同的数据库中可以存在同样的，但是在同一个数据库中，必须是唯一的。
也支持 的设置，我们看上面的 ，里面没有保存的字段，那怎么记录数据的 呢？ 是为每个数据库又增加了一个，这个叫 ，它里面的 里面的就是数对的，而全是数据为位的 ，这个就是 。这样，判断一个是否过期的时候，去 里面找到它，取出 比对当前时间即可。为什么这样做呢？ 因为并不是所有的都会设置过期时间，所以，对于不设置 的来说，保存一个 会浪费空间，而是用 来单独保存的话，可以根据需要灵活使用内存检测到过期时，会把它从 中删除。
 的 机制是怎样的呢？ 与类似，也是惰性删除，即要用到数据时，先检查是否过期，过期则删除，然后返回错误。单纯的靠惰性删除，上面说过可能会导致内存浪费，所以也有补充方案，里面有个定时执行的函数，叫，它是维护服务器的函数，在它里面，会对过期数据进行删除，注意不是全删，而是在一定的时间内，对每个数据库的 里面的数据随机选取出来，如果过期，则删除，否则再选，直到规定的时间到。即随机选取过期的数据删除，这个操作的时间分两种，一种较长，一种较短，一般执行短时间的删除，每隔一定的时间，执行一次长时间的删除。这样可以有效的缓解光采用惰性删除而导致的内存浪费问题。
以上就是的数据的实现，与不同，还支持数据持久化，这个下面介绍。
数据库持久化
和的最大不同，就是支持数据持久化，这也是很多人选择使用而不是的最大原因。 的持久化，分为两种策略，用户可以配置使用不同的策略。
 持久化用户执行或者的时候，就会触发持久化操作。持久化操作的核心思想就是把数据库原封不动的保存在文件里。
那如何存储呢？如下图， 首先存储一个字符串，起到验证的作用，表示是文件，然后保存的版本信息，然后是具体的数据库，然后存储结束符，最后用检验和。关键就是，看它的名字也知道，它存储了多个数据库，数据库按照编号顺序存储，号数据库存储完了，才轮到，然后是 一直到最后一个数据库。
每一个数据库存储方式如下，首先一个字节的常量，表示切换了，然后下一个接上数据库的编号，它的长度是可变的，然后接下来就是具体的对的数据了。
      
                             
{
         
      =  {
                 
             
         ____ ==   
          ==   
    }

         
      ==   
      ==   
      ==   
     
}
由上面的代码也可以看出，存储的时候，先检查 ，如果已经过期，不存就行了，否则，则将 存下来，注意，及时是存储 ，也是先存储它的类型为____，然后再存储具体过期时间。接下来存储真正的对，首先存储的类型，然后存储它按照字符串存储，然后存储，如下图。
在中，会根据的不同类型，按照不同的方式存储，不过从根本上来看，最终都是转换成字符串存储，比如是一个，那么先存储整个的字节数，然后遍历这个，把数据取出来，依次按照写入文件。对于 ，也是先计算字节数，然后依次取出 中的，按照的方式存储它的和，然后存储下一个。 总之，的存储方式，对一个对，会先存储 如果有的话，然后是的类型，然后存储字符串方式，然后根据的类型和底层实现方式，将转换成字符串存储。这里面为了实现数据压缩，以及能够根据文件恢复数据，使用了很多编码的技巧，有些我也没太看懂，不过关键还是要理解思想，不要在意这些细节。
保存了文件，当再启动的时候，就根据文件来恢复数据库。由于以及在文件中保存了数据库的号码，以及它包含的对，以及每个对中的具体类型，实现方式，和数据，只要顺序读取文件，然后恢复即可。由于保存了 ，发现当前的时间已经比 大了，即数据已经超时了，则不恢复这个对即可。
保存文件是一个很巨大的工程，所以还提供后台保存的机制。即执行的时候， 出一个子进程，让子进程来执行保存的工作，而父进程继续提供正常的数据库服务。由于子进程复制了父进程的地址空间，即子进程拥有父进程时的数据库，子进程执行的操作，把它从父进程那儿继承来的数据库写入一个文件即可。在子进程复制期间，会记录数据库的修改次数。当子进程完成时，发送给父进程信号，父进程捕捉到这个信号，就知道子进程完成了复制，然后父进程将子进程保存的文件改名为真正的文件即真正保存成功了才改成目标文件，这才是保险的做法。然后记录下这一次的结束时间。
这里有一个问题，在子进程保存期间，父进程的数据库已经被修改了，而父进程只是记录了修改的次数，被没有进行修正操作。似乎使得保存的不是实时的数据库，有点不太高大上的样子。 不过后面要介绍的持久化，就解决了这个问题。
除了客户执行或者命令，还可以配置保存条件。即在配置文件中配置，在时间内，数据库被修改了次，则进行后台保存。在 的时候，会根据数目和上次保存的时间，来判断是否符合条件，符合条件的话，就进行 ，注意，任意时刻只能有一个子进程来进行后台保存，因为保存是个很费的操作，多个进程大量效率不行，而且不好管理。
 持久化首先想一个问题，保存数据库一定需要像那样把数据库里面的所有数据保存下来么？有没有别的方法？
保存的只是最终的数据库，它是一个结果。结果是怎么来的？是通过用户的各个命令建立起来的，所以可以不保存结果，而只保存建立这个结果的命令。 的就是这个思想，它不同保存的数据，它保存的是一条一条建立数据库的命令。
我们首先来看文件的格式，它里面保存的是一条一条的命令，首先存储命令长度，然后存储命令，具体的分隔符什么的可以自己深入研究，这都不是重点，反正知道文件存储的是客户端执行的命令即可。
 中有一个  _ 如果持久化打开的话，每个修改数据库的命令都会存入这个_保存的是文件中命令格式的字符串，然后 没循环一次，在 中调用，把_中的命令写入文件其实是，真正写入的是内核缓冲区，再清空_，进入下一次。这样所有的数据库的变化，都可以通过文件中的命令来还原，达到了保存数据库的效果。
需要注意的是，中调用的，它只是把数据写入了内核缓冲区，真正写入文件时内核自己决定的，可能需要延后一段时间。 不过支持配置，可以配置每次写入后，则在里面调用，将内核中的数据写入文件，这不过这要耗费一次系统调用，耗费时间而已。还可以配置策略为秒钟一次，则会开启一个后台线程所以说不是单线程，只是单而已，这个后台线程会每一秒调用一次。这里要问了，的时候为什么没有考虑的事情呢？因为是一次性存储的，不像这样多次存储，的时候调用一次也没什么影响，而且使用 的时候，子进程会自己退出，这时候函数内会冲刷缓冲区，自动就写入了文件中。
再来看，如果不想使用_保存每次的修改命令，也可以使用持久化。提供_，即根据现有的数据库生成命令，然后把命令写入文件中。很奇特吧？对，就是这么厉害。进行_的时候，变量每个数据库，然后根据对中的具体类型，生成不同的命令，比如是，则它生成一个保存的命令，这个命令里包含了保存该所需要的的数据，如果这个数据过长，还会分成多条命令，先创建这个，然后往里面添加元素，总之，就是根据数据反向生成保存数据的命令。然后将这些命令存储文件，这样不就和 达到同样的效果了么？
再来看，格式也支持后台模式。执行_的时候，也是一个子进程，然后让子进程进行_，把它复制的数据库写入一个临时文件，然后写完后用新号通知父进程。父进程判断子进程的退出信息是否正确，然后将临时文件更名成最终的文件。好了，问题来了。在子进程持久化期间，可能父进程的数据库有更新，怎么把这个更新通知子进程呢？难道要用进程间通信么？是不是有点麻烦呢？你猜怎么做的？它根本不通知子进程。什么，不通知？那更新怎么办？ 在子进程执行_期间，父进程会保存所有对数据库有更改的操作的命令增，删除，改等，把他们保存在___中，这是一个链表，每个都可以保存命令，存不下时，新申请，然后放入链表后面即可，当子进程通知完成保存后，父进程将___的命令 进文件就可以了。多么优美的设计，想一想自己当初还考虑用进程间通信，别人直接用最简单的方法就完美的解决了问题，有句话说得真对，越优秀的设计越趋于简单，而复杂的东西往往都是靠不住的。
至于文件的载入，也就是一条一条的执行文件里面的命令而已。不过考虑到这些命令就是客户端发送给的命令，所以干脆生成了一个假的客户端，它没有和建立网络连接，而是直接执行命令即可。首先搞清楚，这里的假的客户端，并不是真正的客户端，而是存储在里面的客户端的信息，里面有写和读的缓冲区，它是存在于服务器中的。所以，如下图，直接读入的命令，放入客户端的读缓冲区中，然后执行这个客户端的命令即可。这样就完成了文件的载入。
 创建伪客户端
 = 

命令不为空 {
    获取一条命令的参数信息 ， 
   

     执行
     = 
     = 
    
}
整个持久化的设计，个人认为相当精彩。其中有很多地方，值得膜拜。
 的事务
另一个比强大的地方，是它支持简单的事务。事务简单说就是把几个命令合并，一次性执行全部命令。对于关系型数据库来说，事务还有回滚机制，即事务命令要么全部执行成功，只要有一条失败就回滚，回到事务执行前的状态。不支持回滚，它的事务只保证命令依次被执行，即使中间一条命令出错也会继续往下执行，所以说它只支持简单的事务。
首先看事务的执行过程。首先执行命令，表示开始事务，然后输入需要执行的命令，最后输入执行事务。 服务器收到命令后，会将对应的的状态设置为_，表示处于事务阶段，并在的结构体里面保持事务的命令具体信息当然首先也会检查命令是否能否识别，错误的命令不会保存，即命令的个数和具体的各个命令，当收到命令后，会顺序执行里面保存的命令，然后保存每个命令的返回值，当有命令发生错误的时候，不会停止事务，而是保存错误信息，然后继续往下执行，当所有的命令都执行完后，将所有命令的返回值一起返回给客户。为什么不支持回滚呢？网上看到的解释出现问题是由于客户程序的问题，所以没必要服务器回滚，同时，不支持回滚，服务器的运行高效很多。在我看来，的事务不是传统关系型数据库的事务，要求那么非常严格，或者说的事务都不是事务，只是提供了一种方式，使得客户端可以一次性执行多条命令而已，就把事务当做普通命令就行了，支持回滚也就没必要了。
我们知道是单 的，在真正执行一个事物的时候即收到命令后，事物的执行过程是不会被打断的，所有命令都会在一个 中执行完。但是在用户逐个输入事务的命令的时候，这期间，可能已经有别的客户修改了事务里面用到的数据，这就可能产生问题。所以还提供了命令，用户可以在输入之前，执行命令，指定需要观察的数据，这样如果在之前，有其他的客户端修改了这些被的数据，则的时候，执行到处理被修改的数据的命令的时候，会执行失败，提示数据已经。 这是如何是实现的呢？ 原来在每一个中还有一个 _，_中的是被的数据库的，而则是一个，里面存储的是它的。同时，每个也有一个_，里面保存的是这个当前的。在执行的时候，在对应的数据库的_中找到这个如果没有，则新建一个，然后在它的客户列表中加入这个，同时，往这个的_中加入这个。当有客户执行一个命令修改数据的时候，首先在_中找这个，如果发现有它，证明有在它，则遍历所有它的，将这些设置为__，表面有的被了。当客户执行的事务的时候，首先会检查是否被设置了__，如果是，则表明数据了，事务无法执行，会立即返回错误，只有没有被设置__的时候才能够执行事务。 需要指出的是，执行后，该的所有的都会被清除，同时中该的列表也会清除该，即执行后，该不再任何即使没有执行成功也是一样。所以说的事务是简单的事务，算不上真正的事务。
以上就是的事务，感觉实现很简单，实际用处也不是太大。
 的发布订阅频道
支持频道，即加入一个频道的用户相当于加入了一个群，客户往频道里面发的信息，频道里的所有都能收到。
实现也很简单，也_实现差不多， 中保存了一个_的，里面的是频道的名称显然要唯一了，则是一个链表，保存加入了该频道的。同时，每个都有一个_，保存了自己关注的频道。当用用户往频道发消息的时候，首先在中的_找到改频道，然后遍历，给他们发消息。而订阅，取消订阅频道不够都是操作_而已，很好理解。
同时，还支持模式频道。即通过正则匹配频道，如有模式频道   则向普通频道发送消息时，会匹配，，除了往普通频道发消息外，还会往，模式频道中的发消息。注意，这里是用发布命令里面的普通频道来匹配已有的模式频道，而不是在发布命令里制定模式频道，然后匹配里面保存的频道。实现方式也很简单，在 里面有个_的这里为什么不用？因为_的个数一般较少，不需要使用，简单的就好了，它里面存储的是结构体，里面是模式和信息，如下所示，一个模式，一个，所以如果有多个监听一个_的话，在面会有多个，保存和_的对应关系。 同时，在里面，也有一个_ ，不过里面存储的就是它监听的_的列表就是，而不是结构体。
   {
          监听的
                  模式
} 
当用户往一个频道发送消息的时候，首先会在 中的_里面查找该频道，然后往它的客户列表发送消息。然后在 里面的_里面查找匹配的模式，然后往里面发送消息。 这里并没有去除重复的客户，在_可能已经给某一个发过了，然后在_中可能还会给用户再发一次甚至更多次。 估计认为这是客户程序自己的问题，所以不处理。
    
     {
      = 
     
     
     

        
     = _
      {
          = 
         
         

        
          =  =  {
              = 

            
            
            
            
            
        }
    }
         
     _ {
        _
         = 
          =  =  {
              = 

             
                                
                                
                                 {
                
                
                
                
                
                
            }
        }
        
    }
     
}
六 总结
总的来看，比的功能多很多，实现也更复杂。 不过更专注于保存数据这已经能满足大多数使用场景了，而提供更丰富的数据结构及其他的一些功能。不能说比好，不过从源码阅读的角度来看，的价值或许更大一点。 另外，里面支持了集群功能，这部分的代码还没有研究，后续再跟进。