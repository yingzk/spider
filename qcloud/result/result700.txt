概述
是最初由公司开发，是一个分布式、分区的、多副本的、多订阅者，基于协调的分布式日志系统也可以当做系统。
主要被用于两大类应用：

在应用间构建实时的数据流通道

构建传输或处理数据流的实时流式应用


一、基础架构
有个核心：

 ：用于应用程序将数据流发送到一个或多个 

 ：用于应用程序订阅一个或多个并处理被发送到这些中的数据

 ：允许应用程序作为流处理器，处理来自一个或多个的数据并将处理结果发送到一个或多个中，有效的将输入流转化为输出流

 ：用于构建和运行将 和现有应用或数据系统连接的可重用的和。例如，如链接到关系数据库的连接器可能会捕获某个表所有的变更



几个重要概念：



是发布记录的类别。中的一般是多订阅者的，也就是一个可以有个或多个订阅它的数据。



分区日志分布在集群中服务器中，每个服务器处理一部分分区的数据和请求。每个分区可以配置分布的服务器，以实现容错。
每个分区拥有一个节点，和零或多个。处理该分区所有的读写请求，复制数据。如果节点宕机，将会有一个节点自动的转化为。每个节点成为其部分分区的，并成为剩余分区的，这样整个集群的负载将比较均衡。



发送数据到它选择的。负责决定将数据发送到的那个分区上。这可以通过简单的循环方式来平衡负载，或则可以根据某些语义来决定分区例如基于数据中一些关键字。



使用一个 来标识自己的身份，每条被发送到一个的消息都将被分发到属于同一个的的一个实例中 相同的属于一个组，一个的一条消息会被这个组中的一个实例消费。实例可以在单独的进程中或者单独的机器上。
二、部署

部署环境

常用部署机型：或 操作系统版本：     版本：   _ 版本：   版本：_

部署步骤

分别解压和_



修改配置文件，设置相关参数后，分别启动和

 __
 _

常用命令

创建：
                
列出所有：
    
查看信息包括分区、副本情况等：
     
往某生产消息：
    
从某消费消息：
     
三、集群配置
    

=                 每一个都有一个唯一的作为它们的名字

=                     服务端口

=     的主机地址

=        处理消息的最大线程数

=            处理的线程数

=   _参数

=    _参数

= 控制在一个请求中获取的消息的字节数

=____

 数据的存放地址，多个地址的话用逗号分割多个目录分布在不同磁盘上可以提高读写性能  ，

=               默认分区数

=

=                     控制一个保留多长个小时

=              单一的 文件大小

=       检查数据是否要写入到硬盘的时间间隔。

=…   指定连接字符串

=       指定客户端连接的最大超时时间

=

=                 默认副本数
四、监控
通过监控和
_   

  _  

      _  



_=

_= _

=

_=



_=

_= __

=

_=
五、增加节点
集群的容错能力的算法为：=总数，即为可容纳的故障节点
即：台能容错台，台能容错台，台能容错台
新搭的一个集群只有台节点，为了增加容错能力，决定扩容

先在新节点上安装软件，修改和

= 

= 

= 

= 

= 

= 

= 

修改整个集群中与相关的系统配置

  

=…

重启服务

  

所有节点依次重启服务

 

 
六、修改数据保存时间

存储时间设置太长会导致磁盘空间不够，修改存储时间小时

     __  =

     __  =

     __  =
不需要重启，修改集群默认设置才要重启
七、增加数据目录迁移数据
原有集群都是使用机型，该机型只有一块大磁盘，所以集群只需配置一个数据目录，把数据存储在该磁盘上，最近的上海端游集群也是按此模板搭建的。但是新集群是机型，提供了块的磁盘，随着接入的数据增多，发现一个磁盘快撑满了，另外三块却空着，为了充分利用多个磁盘，需要在原来基础上增加数据目录
  

=____

  用户执行



  

  

  

  _  

  _  

  _  

 _ 用户执行

   

   

   
重启集群：
 



  

      
重启后可以看到新加的磁盘目录下已经产生了初始化文件，说明新目录已添加成功，以后集群新建时会优先把存到空闲率高的目录下。但是已有的数据不会自动需要人为的去，步骤如下：
先看下现有的分布情况，可以看到__的分区现在都在
  

  __  __ __ __
现在开始，先手动生成一个文件
{

     

        { __}

    

     

}
调用生成迁移计划，使用的工具来分配的分区位置
          

   

{{__}{__}{__}{__}{__}{__}}
上面的即为新的分区分布，把它复制到
执行—执行迁移
     
使用查看进度 
     –
附扩容时同步状态：

经过两次后，可以看到已经均匀分布到四块磁盘上了
再看下的分布情况，从命令输出结果可以看到 __有个分布在三个上，数据有俩个副本。
      __

__              ===

        __                     

        __                     

        __                     

        __                     

        __                     

        __                     
八、扩容
 启动新节点
将原节点上的  目录通过  命令拷贝到新节点，只需要修改配置文件中的 _ 和  地址，然后依次启动  服务。
数据存储
同样集群扩容后数据是不会自动均衡到新机器上的，需要采用这个工具脚本。脚本可以工作在三种模式，，，详细步骤可参考第七节：增加数据目录
九、运营经验
不同的机型磁盘情况不一样，灵活配置数据存储目录 ，使磁盘利用最大化。
集群健康状态监控，检查集群同步情况，有异常发出告警：
    
_=``
=`__     ___| |   { }|  | `
 
      
  _    

自带性能测试工具：



开源管理及监控工具： 
 


导读
月至日，“云未来”峰会在深圳召开，腾讯向外界进一步展示了开放的诚意：充分开放腾讯的数据能力，包括智能推荐、数字营销等重量级服务，让行业真正感受到数据的价值。腾讯的开放是一个漫长的过程。许勇指出，腾讯曾经是一个较为封闭的环境，技术研发也不例外。
年的大战后，腾讯开始拥抱“开放”战略，技术研发也正是在这种环境下，开始向共享、复用和开源迈进。腾讯内部的开源社区，给大家提供了从轻度到重度参与开源的途径；而从年开始，腾讯外部开源也开始进入了快节奏时代。
在方面，深度计算的基础平台能力不断迎来开放，一个是的开源，作为高性能的机器学习计算平台，目前应用于腾讯内部包括广告推荐，视频推荐，微信公众号等业务场景。另外一个的开源，是腾讯优图实验室前向卷积神经网络的实现，在手机、手机、微信、天天图等腾讯业务中广泛使用。
越来越多的业务团队开始拥抱开源，把自己的项目开源出来，在接下来，还有更多经过腾讯众多明星业务检验的项目开源出来。相对于，这样的科技公司，腾讯的开源，目前还是处在一个追赶者的阶段，但我们看到了腾讯的工程师们已经被开源的力量唤醒，腾讯希望和外部开发者一起，砥砺前行，创造中国开源的未来。

以下为许勇演讲实录：
，大家下午好，简单介绍一下自己，我是腾讯研发管理部的许勇，目前任职腾讯的研发平台，主要致力于推动腾讯内部开源社区建设和外部开源项目的管理工作。今天，我以“腾讯开源，在路上”为题，分享腾讯内部如何打造工程师文化和外部开源的情况。
曾经的腾讯比较保守，什么事情都是关起门来自己做，内部的技术研发也是如此，各业务和产品都会重复开发很多类似的功能，比如个不同版本的二维码扫描，个功能类似的热补丁组件等等。年，随着大战，变革来临，腾讯开始“开放”战略，同时前的一批工程师加入腾讯做搜索，虽然搜索没有做起来，但他们带来的的工程师文化却得到了很多认同，正是在这种大环境和背景下，腾讯的技术研发开始由封闭向共享，复用和开源迈进。

我们从年开始，在内部提倡以公共组件的形式共享和复用代码；年，尝试发布了腾讯第一个对外开源项目，一个构建系统；年，旨在鼓励和推进腾讯内、外部开源落地执行的腾讯代码文化项目启动；年，制定和发布了腾讯的开源策略和具体流程，并发布第一批的个官方开源项目；年，在腾讯技术管理委员会下成立腾讯开源联盟，整体指导和管理腾讯开源工作；截止到年底，腾讯正式发布的开源项目共计个。这是腾讯开源年的发展历程。

然而腾讯开源的起步还是比较艰难的，即使是先从内部开源做起也是如此。公司是希望通过开源，减少内部消耗，更多的复用同事的工作成果，这样不仅能提高代码质量和效率，还可以为外部开源积累经验；然而腾讯的研发模式是业务和产品驱动，这里会存在三个方面的问题。第一，工程师会先去考虑能更快的满足业务需求，因此代码的实现与业务耦合性很强，这样好处就是对业务和产品侧的反应会很快，很到位，但很难复用到别的类似业务和场景中去，而解耦的难度更大。第二，就是每个大公司都会遇到的问题，做开源不是的内容，那么时间投入和对工程师的重要性方面就会弱很多。第三，就是部门墙，有些业务甚至存在内部竞争的问题，比如最初做类似微信类产品的团队就有个，竞争很激烈，这样去开源代码的阻力更大。
因此腾讯内部开源的工作主要是围绕着如何解决这三个问题展开的。
现有代码开源比较困难，但是如果从分享一段代码片段开始呢？微码这种低门槛的代码分享方式应运而生了，这让工程师很快感受到了用代码交流的魅力，吸引和培养了内部开源社区的第一批用户，至今，微码分享的活跃度还是非常可观。

突破的难题，如果把开源当做是一个好玩，很酷或者是情感诉求的事儿，那么是不是能够吸引到工程师去积极参与和贡献呢？我们内部开源社区的定位和运营上，在这方面做了许多尝试，比如腾讯员工最关注和期待的每年的圣诞晚会，有圣诞大奖的抽奖环节，在每次遗憾自己与大奖失之交臂的同时，工程师都会很关心算法是否真正体现公平，自己的名字是否在随机算法的盲区等技术问题，由此，腾讯内部最长寿，参与工程师最多的开源项目圣诞抽奖项目诞生了，也成为腾讯内部开源的样板；还有乐高机器人编程大赛，基于预测年欧洲杯等等活动，让工程师以码会友，同场，感受到了技术社区可以很酷，很好玩；每年的代码统计报告，不是冰冷的数据统计，而是试图描绘工程师在代码世界中的生活，感受到技术社区是有温度的，是温暖的。
对于部门墙的问题，当工程师对于分享和开源有了认识和实践以后，追求更高的技术价值和成就感驱动大家，突破部门业务的局限性去开源项目，从给与中获得满足。技术社区必须靠开源项目和贡献说话，而非或者资历，因此我们保持了社区草根化的特质，比如区别于公司内部官方的优秀评选，社区的优秀项目的评选完全取决于项目的客观数据，工程师的票选和一部分专家评选三者结合的总成绩，这获得了工程师的极大认可。

因此，腾讯内部的开源社区，给大家提供了从轻度到重度参与开源的途径，你可以仅仅只是轻量化的分享代码片段，或者是贡献公共组件，或者开源项目去实现技术价值的最大化和建立技术影响力，截止年，内部的组件和开源项目数达到了，内部开源社区的在。技术研发由最初的封闭，到现在工程师普遍认可开源，并积极参与其中。

有了一定的内部开源基础，我们开始尝试外部开源，然而发现，同样不简单。由于公司性质的对外开源，所以需要把控的方面特别多。这个数字，是我们开源一个项目之前，需要对项目做的检查项的数量，包括安全，商标，专利，协议等等各方面；是我们做一个开源项目所涉及的部门和业务领域的数量；是一个开源项目从发起到最终正式开源的周期个月。因此可以看到，开源一个项目的投入是巨大的，还不包括开源之后，项目团队投入的维护资源。所以腾讯开源的节奏开始很慢，至今开源的数量仅仅是个项目，但我们看到，从年开始，这个节奏快了起来。同时腾讯也在以其他三种方式参与开源，积极参与知名开源社区、运营自己开源项目的社区以及为开源项目贡献。
腾讯云在今年月份，宣布加入和基金会，腾讯云是国内最大的基于提供容器服务的公有云服务商，也是拥有国内最大规模集群的企业，将在容器服务、虚拟化等重大开源项目贡献力量。
月，腾讯云加入基金会，释放腾讯云数据库的内核积累。腾讯在去年，也成为项目的白银会员，两次主办全球技术实践峰会。

另外腾讯也独立运营了一些自己项目的开源社区，例如，开源了腾讯许多优秀的前端项目，并举办了届前端大会，工具类的和游戏的蓝鲸平台等，都有不错的口碑，并聚集了一批热心的开发者。
腾讯积极贡献知名的开源社区和项目，过去一年，产生一名项目，一名项目的，个到，个到，个到，个到，个到 等等，腾讯正在以不同的方式，积极参与到开源活动中来。
腾讯目前大多数的官方开源项目，都已经放在上来管理，下面简单做一些介绍。

，腾讯游戏专家工程师的一个开源项目，是一个 解析／生成器，目前有和 ，被包括守望先锋等许多游戏采用。，微信前端团队的热补丁方案，目前有和，是腾讯第一个占据全球周榜冠军的开源项目。，微信设计团队开源的同微信原生视觉体验一致的基础样式库，目前有和，是腾讯最具影响力的一个开源项目。，后台团队开源的毫秒服务引擎，来自于后台团队年的运营思考。

可以看到，越来越多的业务团队开始拥抱开源，把自己的项目开源出来，在接下来，还会有更多的经过腾讯众多明星业务检验的项目开源出来。

在方面，个项目即将开源，一个是高性能的机器学习计算平台，它的目标是让模型训练能够在千万级别、亿级别、乃至十亿级别维度的模型上，自如的展开，加速各种机器学习算法。目前腾讯包括广告推荐，视频推荐，微信公众号等业务场景，都有应用的。另外一个，是腾讯优图实验室前向卷积神经网络的实现，是优图基于深度学习算法，如人脸检测，五官定位，配准跟踪等    使用  框架实现，在手机，手机，微信，天天图等中使用。
，基于的前端工作流开发工具，应用于微信游戏、微信广告等项目的第三方合作团队前端构建工作，腾讯生物认证组件，应用于微信客户端的指纹支付业务，以及公众平台页面的指纹授权。还有小程序相关的一些项目……
相对于，这样的科技公司，腾讯的开源，目前还是处在一个追赶者的阶段，甚至相对于国内的其他开源先行企业，也还有很大差距，但我们看到了腾讯的工程师们已经被开源的力量唤醒，更有热情的投入到了开源中来，去追求更大的技术价值，腾讯开源也会与腾讯云紧密结合，为开发者提供更多便利的基础服务和工具，以及开源项目使用，我们希望能和外部开发者一起，砥砺前行，创造中国开源的未来作者：， 腾讯游戏测试 工程师商业转载请联系腾讯获得授权，非商业转载请注明出处。原文链接：

导读
苹果在大会，公布了最新的 ，系统新特性肯定是让不少果粉充满期待。在网上已能看到不少关于 的体验文章，那么 的新特性会对产生什么兼容性问题？

 的新特性会对产生什么兼容性问题？针对这次升级，选取了几个与新特性关系较近的项目进行体验，简单测试下各功能目前的兼容性情况。
 测试版本：   
一、安装启动测试
安装与启动在适配测试是最简单但同时最重要的一环，最严重的适配莫过于启动就。
测试目的
安装与启动在适配测试是最简单但同时最重要的一环，最严重的适配莫过于启动就。
测试用例

测试结果

测试结论
测试了上款，均可正常通该项测试。看起来升级了 系统并不会对大部分有致命性的兼容性问题影响。
该功能对兼容性的影响：低
二、屏幕录制功能
此前该功能就一直被广大的苹果用户所渴望，不少第三方尝试实现，由于关乎到底层，效果一直不理想。
终于加入了原生的录屏功能，由于该功能是与并同运行的，因此一开始觉得该功应该会产生或多或少有存在一些兼容性问题，测试完后确实如此。
测试目的
系统自带录屏功能否与互相兼容
测试用例
测试结果

测试结论
、横竖屏不适配
如魂斗罗，游戏本身是正常的，但录制出来的视屏并没有如游戏一样横屏，而是被拉伸了，视频里的游戏画面比例错误。
、音画不同步
该录屏功能，是带有同时录音功能的。在测试的时候，部分发现存在声音与画面不同步的情况，但该缺陷重现性为偶现性。
与录屏功能不兼容已解决
测试穿越火线过程中，启动了录屏功能后，启动穿越火线，游戏音效会消失。并且录屏功能会失灵，即使关闭该后，录屏功能仍然失灵，需重启手机后才能解决。
但该，在系统升级至版本后，尝试重现时，发现问题已解决，从此看来应该是系统导致的。
三、 格式的照片
  引入的是一项名为“高效图像文件格式”    ，简称 的新一代压缩技术。压缩效果几乎能比格式节省一半甚至更多的空间。
测试目的
新格式照片，测试的调用是否存在兼容性问题
测试用例

测试结果

测试结论
挑选了几款与照片交互较多的，发现该格式的图片兼容性不错。并且提供了兼容性设置，在传输到或 时提供了两个选项分别是“自动”与“保留原始图片”，前者可自动传输兼容格式的照片和视屏。
该功能对兼容性的影响：低
四、输入法单手模式
手机屏幕越来越大，单手输入显得越来越吃力，一些第三方输入法开始推出了单手输入的功能，系统自带输入法中也加入了这一功能。
该功能是为了方便单手输入的一个功能，仅在竖屏状态下有效。该功能可让输入法键盘，往左缩小以便左手单手操作，或者往右缩小以便右手操作。
测试目的
在各种竖屏或可竖屏的中能否正常的使用单手模式状态下的输入法
测试用例

测试结果
测试结论
针对这一新功能，几个为数不多的竖屏游戏以及进行测试体验。最后，仅发现一个输入法的通用漏洞。
系统设计缺陷：英文键盘的输入预测框并没有缩放，大屏设备左测仍然不方便进行单手操作。
该功能对兼容性的影响：低
五、剩余新特性
原生相机增加二维码识别功能
改版
新增文档管理
更强大的，带翻译功能，开放更多的资源能整合更多的第三方应用功能等
这部分与兼容性目前关系并不多，所以未进行针对性测试。
六、 新特性兼容性影响结论

、选择了几个较为共用的新特性，简单的针对此进行了兼容性测试，除了录屏功能出现了一些问题，其余测试的新特性并未有发现相关问题。除此还有另外的新特性适用性通用性较低，并未一一测试。
、从此次测试的新特性结果来看，测试系统版本较多，但与兼容性还算不错。至于这些特性或剩余未测试的新特性是否存在其他的影响，还需要等待后续测试版本以及正式版本才有定论。

腾讯兼容性测试团队积累了年的手游测试经验，旨在通过制定针对性的测试方案，精准选取目标机型，执行专业、完整的测试用例，来提前发现游戏版本的兼容性问题，针对性地做出修正和优化，来保障手游产品的质量。目前该团队已经支持所有腾讯在研和运营的手游项目。
服务目前已经对外开放，欢迎访问：   使用。
兼容性测试团队期待与您交流！ ， ！作者：袁宜霞
团队：腾讯移动品质中心

一、怎么界定自动化测试范围
白盒测试主要测试的内部结构或运作，以代码实现的角度来设计测试案例。白盒测试优点在于要求测试人员去学习软件的实现，可以检测代码中的每条分支和路径，揭示隐藏在代码中的错误，对代码的测试比较彻底。
单元测试属于白盒测试的一种手段，是一种提高软件质量非常有效的方法。对于多次的迭代开发和重构，团队需要通过单元测试来看是否新的迭代对于原有的功能是否有影响。但是，单元测试在现实实践中存在的一个不可忽视的问题是：测试用例的维护成本比较高，往往对其维护的工作量并不比被测代码的开发量小。所以，本文引入了逻辑自动化测试概念，希望能在高价值和维护成本中找到平衡。
逻辑自动化测试：考虑到手机的的多变性，仅对非相关的逻辑业务类进行自动化测试，优先对外接口。在本文中，以手机管家为例子，逻辑自动化测试的范围选定为文件夹中的类，此文件夹中的类文件均为与无关的业务逻辑类。
二、单元测试框架使用和代码覆盖率查看
是中新引入的一个测试框架，它非常简单并且与  的  直接集成，并且其单元测试的代码不会打包到开发的项目工程里面，隔离性比较好。
、如何新建测试用例
打开项目工程， －》－》－》－》   输入名字和选择，之后在此文件夹下 新建测试用例类。
：测试类继承类，并且测试用例必须以开头。
、如何执行
有两种方式：一种是执行，一种是命令执行。
执行方式如下：
、直接点击每个  前面的菱形可单独执行特定用例；
、在“   ”下可以点击播放按钮制定测试用例类下的全部测试用例；
、使用执行全部测试用例。
使用命令执行测试用例：
 测试名  工程名  = =  

： 如果执行报错为：     __=  = _=，那么需要修改 的属性包括：修改中 下的   改为，同时 添加  和与工程保持一致_。 
、如何收集代码覆盖率
、首先在 里面，选中工程，将 模式打开；

、执行测试用例；
、打开左边窗口的 图标类似微信聊天气泡，找到  选择这个实例，并选择能看到代码覆盖率汇总数据；

、双击你想要查看的类，可以查看代码执行次数。对于未执行代码，可根据具体的情况增加测试用例；

、实现持续交付中的代码覆盖率数据收集，关注类似如下路径的代码覆盖率数据文件：
。
此文件可以使用进行解析为文件，以文本记录了每个文件的代码覆盖率数据，便于进一步加工：
    文件内容举例如下：

：代码覆盖率仅供参考，单纯追求覆盖率是不可行的，覆盖率只是衡量测试投入的指标，和代码质量并没有直接的关联，另外当覆盖率达到一定程序之后，继续提升覆盖率时投入和产出可能不成正比，效益可能会下降。所以，代码覆盖率数据要进行一定的平衡，即做到保证一定的质量，又做到对于人力资源的合理使用。
三、典型的测试场景
、异步测试场景

在接口测试时，我们常常会碰到异步测试场景，比如手机管家中与后台请。
求相关的接口小资讯请求、诈骗短信云查杀等，都需要等待后台返回结果数据到客户端。在等待子线程完成任务时候，我们继续主线程其他代码执行，同时，异步等待子线程返回的结果数据，并用回调函数来处理即将接收的结果数据。
在以上版本中，苹果添加了用于异步回调测试的，因此不用像旧版本那样，发起异步调用后通过循环查询标志位，来检查异步回调函数的调用了。在新版本中直接使用的即可实现这一功能。
、方式回调；
在单测开始位置声明需要使用的对象，在回调中触发函数，单测的末尾调用进行等待，举例如下：

、代理方式回调；
与方式回调类似，不过由于回调函数在单测函数外侧，需要把变量声明到类中，举例如下：

：如果希望保持测试用例与被测工程代码的独立性，回调函数需要在测试类中进行重写；否则，被测工程代码需要做些调整例如：直接在工程代码中增加宏，在当前模式为测试模式时，在对应的回调函数中进行调用。
、如何访问私有变量和私有方法
、私有变量的访问和修改；
在做接口测试时，会需要私有变量是否有预期变化的情况或者修改。
私有变量的值，共有如下两种方式。

、私有方法的访问和修改
对私有方法的访问同样有两种方法：

、的使用
对于一些不容易构造或不容易获取的对象，可以创建一个虚拟的对象 来完成测试。实现思想就是根据要的对象的来创建一个对应的对象，并且设置好该对象的属性和调用预定方法后的动作例如返回一个值，执行其他方法，设置参数中的返回值和返回异常等等，然后将其记录到一个数组中，接下来开发者主动调用该方法，最后做一个验证，从而判断该方法是否被调用，或者调用过程中是否抛出异常等。
在手机管家的逻辑接口测试中选用通用的开源，配置和的使用参看如下连接文档：
、返回一个值；
举例：在手机管家的加密相册功能中，手机硬件是否支持会影响其登录流程。如下使用了来  接口，使得其返回设定值。
：如下中，通过调用可以返回真实的状态，如果在测试结束前需要保存一个实际情况的数据这个方法是比较合适使用的。后的方法就不能再继续使用了。

、执行其他方法；
举例：如下的对象调用方法时，将会调用对象的方法。本例中，在之前已经将的属性值设置为，所以调用 返回的值是。注：执行其他方法需要保证返回值与对象调用方法的返回值类型一致。
 

、设置参数中的返回值；
对于函数返回值放在参数中的情况即参数传递的是一个指针的指针，直接不执行函数而是将返回值直接设置给返回值参数。举例如下：

、一个异常返回。
在单元测试中，也常常需要一个异常返回，从而去保证异常路径得到覆盖。如下为一个简单示例：

、模拟后台数据返回
对于黑盒测试，如果要后台返回特定的数据需要配单，且还难以模拟一些后台。
返回异常数据情况。有了单元测试后，我们可以在不配单情况下指定后台返回数据，检查客户端对于后台的正常和异常返回处理是否得当。在集成测试前，做验证模块内部的逻辑正确性，避免在联调时花费过多的时间来解决小问题，提高联调的效率。
举例：手机管家问问中一次更新拉取，如果后台有超过篇以上的文章，那么仅返回前条。黑盒测试方案，我们必须在后台配置至少篇以上文章。在接口自动化测试中，先模拟后台有超过篇文章，检查是否有做好仅显示前篇文章客户端逻辑。 
在做接口测试时，常会碰到返回值为的方法，并不总是构造输入参数，得到返回值。对于没有返回值的方法，一定有一些可以被观测的地方，比如说一个对象的状态被改变，所以必须找到合适的断点。如果找不到，说明这个方法无用，不需要做测试。
举例：手机管家的游戏中心的图标下载，没有返回值，但在本地有存入图标文件，那么就可以在测试用例中这个文件是否存在，继而判断是否成功下载。

四、小结
在实际工作中尝试逻辑自动化测试在帮助被测产品发现问题的时候，也能提高测试人员自身的代码能力，一举两得。
协助产品提升质量主要在于：
、输出自动化用例，让代码重构和优化更放心；
、在集成测试前，有机会做验证模块内部的逻辑正确性，避免在联调时花费过多的时间来解决小问题，提高联调的效率；
、其他产出为：产品， 问题，测试分析框架图，根因分析，可测性分析等。
提升测试人员自身代码能力主要在于：
、掌握代码，积累代码编写和调试经验，分析问题与解决问题的经验；
、辅助问题分析，遇到问题时，可以借助分析单元测试代码来了解模块的一般行为。
获取更多测试干货，请搜索微信公众号：腾讯移动品质中心！发现访问公司某些业务时，速度非常不稳定，并且整体慢于竞争对手。分析认为母盘上内核拥塞控制算法和的频率控制的策略存在不兼容情况。
目前至少确认 内核版本存在此问题，打优化补丁或者更换以后可以解决问题。
问题现象：
在体验网环境下测试：大文件下载的情况下，百度的下载速度平均在，我们的下载速度平均低于；互娱情况下，业务下载速度大约是的。
这里是一个典型的下载速度曲线：
我们的服务器的曲线：纵轴单位：包

百度的服务器下载的曲线：

重现该问题的测试环境：
网络： 公司体验网，普通联通 
服务器：位服务器 深圳机房。
服务器程序： ，自研
客户端：  ， ，任意浏览器或者旋风单线程下载
测试工具：， 
测试连接：分别是自建、百度下载、深圳
问题分析：
通过客户端抓包分析发现速度很慢的段有两个问题：

服务器端总是等到前面的数据包确认以后才发送第二个包

总是等到左右才发送确认。




对于端的行为， 为了防止过多导致网络压力， 协议栈在每收到一个数据包时，启动一个定时器，直到收到其他数据包或者定时器过期时才发送包。
通过设置注册表选项  参数为关闭  以后，实验发现下载速度恢复正常，无法重现下载速度慢的问题。
        
 \ \ \ \ \ \ \{}
 =  = =    =         
因为无法强制用户通过修改注册表避免问题，并且竞争对手也没有看到类似问题，因此只能从端解决。
这一端，首先怀疑和算法有关系，在服务器上设置_以后仍然可以重现，可以排除算法的影响。 实际上每次发送大数据包或者直接使用，不太会收到算法影响 其次，都可以重现这个问题，比较怀疑操作系统本身有缺陷。
因为每次仅发送一个数据包，因此怀疑拥塞窗口的问题，推测问题如下：
初始情况下，客户端回复一个时，拥塞窗口增大，每次发送多个数据包，因此刚开始可以有较快的传输速度；因为网络延时抖动或丢包导致服务器协议栈判定数据包超时，重置拥塞窗口为，每次仅发送一个数据包，收到客户端回包，时仍然认为超时，同时调整；直到增大到不算超时为止，拥塞窗口得以扩大，可以发送多个数据包，传输速度增快，如此循环。
通过测试增大初始拥塞窗口为 更换内核加载架平新技术组的优化模块实现，下载速度恢复正常。
 附旋风测试选项：

参考
                 作者： 

一、概要
 已经发布一段时间了，市面上很多应用都已经适配 。权限机制，作为 的一大特性，受到了很多开发者的关注。本文主要分享了以下几个知识点的内容，、权限机制关键知识点；、音乐对于权限的适配经验；、近段时间以来遇到的一些权限方面的问题。，下面进入主题。
二、权限机制
已经了解过基本知识的，建议直接跳到第三点音乐的权限适配经验。
以前，的权限机制比较简单，开发者在文件中声明需要的权限，安装时，系统提示用户将获取的权限，需要用户同意授权才能继续安装，从此便永久的获得了授权。然而，同期的对于权限的处理会更加灵活，权限的授予并不是在安装时，而是在运行时，用户可以根据自身的需要，决定是否授予某一权限，同时，用户也可以很方便回收授予的权限。显然，动态权限管理的机制，对于用户的隐私保护是更加适用的，过于简单的权限机制也受到了不少人的吐槽。终于，也发布了动态权限的机制。
开始适配和如何兼容
要适配非常简单，只需要将和都升级到及以上，同时加入权限检查申请等代码逻辑即可。这里很多人会有一些疑惑，如果针对旧版本的在机型上运行或者针对适配了的在以下机型上运行，会有什么表现呢？是如何兼容的呢？
、首先，旧版本低于，因为没有适配权限的申请相关逻辑，在以上机型运行的时候，仍然采用安装时授权的方案。
、适配了的，在低版本系统上运行的时候，仍然采用安装时授权的方案，但是开发者需要注意的是，权限申请的代码逻辑只应该在及以上的机型被执行。
危险权限与普通权限
一开始，听到要加入权限判断和申请代码逻辑的程序员内心可能是崩溃的：正常的一个有一定规模的，很容易就七七八八的声明了很多权限，如果每个权限都申请岂不是非常麻烦？
好歹，还算比较明智，并不是所有的权限都需要运行时申请才能使用。对每个权限的隐私危害性进行了评估。将权限分为了两大类：普通权限和危险权限。举个例子，控制手机震动的权限对于用户并没有什么危害，只要开发者声明了这个权限，安装后就可以一直被授权，也不能被回收，但是，像读取卡数据这类权限，很显然就是危险权限了，必须向用户申请这个权限。
还是很体贴我们开发者的，为了进一步减少开发的工作量和申请权限对用户的骚扰，对危险权限根据各自的属性进行了分组。举个例子，读卡和写卡，这两个权限通常都是成对声明和使用的，因此，它们被分为一组，而且，只要我们获取了这个权限组里面的任意一个权限，就可以获取整个权限组的权限。对于危险权限的定义和分组见下图。

权限相关说明
首先，在动态权限申请的流程中，开发者主要关注流程和如下：
、检查权限是否授予。

  
、申请权限。
    
      
这个时候，会弹出系统授权弹窗授权弹窗是不支持自定义的，原因理所当然。
、权限回调。
用户在系统弹窗里面选择后，结果会通过的方法回调。
        {
    继续执行逻辑或者提示权限获取失败
}
、权限说明。
用户如果选择了拒绝，下一次在需要声明该权限的时候，建议开发者给予用户更多的说明，因此提供了下面这个这个方法返回值在使用过程中会发现有点纠结具体解析见下面代码块说明。
  
{


    、没有申请这个权限的话，返回
    、用户拒绝时，勾选了不再提示的话，返回
    、用户拒绝，但是没有勾选不再提示的话，返回

因此如果想在第一次就给用户提示，需要记录权限是否申请过，没有申请过的话，强制弹窗提示，而不能根据这个方法的返回值来。
}
三、音乐的权限适配经验
、不同权限，申请的时机不同
音乐作为一个比较复杂的流媒体应用，也需要不少权限，但是究竟在什么时候来申请这些权限就成了适配时首当其冲问题。针对这个问题，我们也对需要的权限进行了思考，大致认为申请权限需要分为两个时机。
用户触发：这个很好理解，有些和特性相关的权限，比如说听歌识曲的录音权限、自建歌单封面拍照权限等，这类权限平时运行时并不需要，那么我们选择在用户触发或者进入该功能的时候，进行授权受阻逻辑。
应用启动时：我们在梳理的时候发现，有些权限读取设备信息，读写卡等并不是由用户或者特性触发的，而是网络免流，登录安全，日志系统这些底层逻辑无时不刻触发的。对于这些权限，就比较纠结了。不过回过头来看，这些权限通常是开发者或者不能妥协的权限，因为如果用户不授权的话，将会影响整个的功能和数据。所以，我们选择比较暴力的方式，在应用启动的时候，就受阻。这也是建议的一种方式。
但是需要注意的是，一开始就申请授权也不要冷冰冰地直接拉起系统弹窗授权，建议先用自己的弹窗向用户礼貌地说明为什么需要这几个权限，比如，读取不到设备信息无法联通免流，无法保证登录安全，读取不到卡无法播放歌曲等，避免太生硬引起用户的反感。特别是，因为本地化翻译的原因，对于权限的弹窗说明很不，例如我们申请读取设备信息的权限时，系统的弹窗是“电话权限”，这里很容易引起用户的误解，所以，合理的引导和解释是必不可少的。
、应用启动授权，需要一个壳
刚刚已经说到了，很多隐形的权限和特性无关。那么，如果我们直接启动，用户又还没有授权的情况下，很多初始化逻辑很容易就因为没有权限了，即使没有，后面也可能会有或多或少其他的问题。因此，我们需要在这些权限完全授予前，禁止这些逻辑的执行。
做过启动相关的同学都知道，拦截一个正常的启动后面再恢复，是很复杂的一件事情，往往我们需要一个外壳来把业务逻辑的内壳隔绝开。就音乐而言，我们很容易的就想到了加载的壳，需求也很类似，加载也需要优先于业务来做。顺着这个思路，很自然地，我们就选择了在的壳里面做权限的受阻逻辑，而且也很快很好的达到了预期的效果。相信现在大部分都是分的了，因此建议按照这个方式来做，可以节省很多的工作量。
四、权限机制“乱象”
这里要说的乱象，其实是和严重的碎片化有一定的关系。随着国产越来越个性，很多在尝试建立自己的权限机制，有些甚至基于就开放了原生的或者开发了自己的权限机制。而面对这些情况，我们往往能做的非常有限，举几个例子。
、读取运动数据权限
开发音乐跑步电台的过程中发现，在某国产的一些机型上会提示“应用读取运动数据权限”的系统弹窗。可是，反复查阅相关发现，我们使用的计步相关的并不需要申请什么权限。可如果用户选择了拒绝，即使注册了，也收不到系统的回调。后来联系该厂商的相关人员后，给出的答复是，第三方无法检查和申请这个权限，这个权限本身也属于该厂商自己的权限机制。
类似的案例还有一个，就是在某厂商的手机管家，会一直提示音乐尝试读取应用程序列表。其实，我们并没有读取应用程序列表，只是调用了相关的一些，就是触发这个告警。
对于这类问题，我们怀疑，第三方是在运行时检测到了调用了相关的后，进行权限阻断。这里开发同学需要注意的是，被阻断的不一定会导致，但是可能导致我们获取不到正确的返回值或者收不到系统的一些消息回调。
、无法添加快捷方式
本来 =_声明后，我们就可以在桌面上创建快捷方式了，而且这个权限也不是危险权限。可是某些国产，对于添加快捷方式限制的比较严，必须要用户在设置里面手动允许添加快捷方式后，才能最终成功的添加。这种情况，也不能知道是否能添加快捷方式，只能默默的添加失败了。不过好在这里受影响并不是主快捷方式，而且某些功能的快捷方式入口。
、消失的桌面歌词，悬浮窗权限
音乐桌面歌词采用了向里面添加的方式实现。可是很多国产很早就具备了悬浮窗权限。一开始，我们将改为_同时声明 =__这个普通权限，躲避了大多数系统的问题。可是，年底，随着某系统的升级，这一招也没用了，大批用户反馈爆发。
我们继续尝试检测悬浮窗权限，发现__返回的结果永远是，因此这条路也走不通。
最终，经过各种查阅，发现这个悬浮窗权限并不在标准的权限机制内，而是里面已经被隐藏了的一个开关位，对应于第个开关。需要注意的是，这个类很早就有了，但是很多隐藏了的方法，好在最后发现通过反射仍旧可以调用这个方法检测权限是否打开。
   =  
 {
      =     
     _ ==  
}    {
        
}
不过，要打开悬浮窗权限，不同的路径还不一样，有的是在设置里面，有的是在系统自带的管家里面，最后我们只能根据不同的，给予用户不同的引导，终于将反馈量降了下去。背景
累觉不爱，追求流浪，只信猫咪与游戏。与三国结缘多年，却因为对物理的愧疚大学没有读计算机而选了物理系。因此丢失了几年对三国未来发展的憧憬，没事，我们还有青春去幻想去设计去定义这游戏的未来，希望多年之后，游戏未倒，焕发二春，又有怀着梦想的少年进入了这个有爱的三国世界。我有满腔对这游戏未来发展的热情，希望十年后该游戏的策划组愿意倾听。
十年计划

在你好棒棒啊的腾讯云服务器参赛就是来拿优惠券续费的，这个广告应打建设一个帮助某游戏新玩家快速熟悉游戏，让老玩家重新热爱起游戏的社区网站三国爱。

开发与该游戏相关的在线攻略功能，运营网站期间收集玩家们的偏好、问题、建议、如何良好体验游戏等。

学习怎么制作游戏，从一个玩家体验友好的角度来策划新游戏。

开发一个个实现小功能的框架，最终整合成自己的游戏引擎。

做一款页游版本的游戏，把策划和源码送到三国工作室，也许其中某个观点和建议可以被接纳，被相信这游戏还有未来，告诉策划组我爱三国，谢谢它陪我度过的青春，希望你们别放弃这游戏，我们选择相信在等着。


接入服务器
不想说搭建的细节，因为老手不需要教，而新手让自己去摸索会更有趣，毕竟腾讯云管理中心的指引后详细了，简单说下会遇到的一些问题，新手遇到时可以查看。
问题基于的环境：、、

遇到、等“新”扩展名文件，无法访问，去添加类型。

某非关键进程利用率太大，但不确定是否可以关闭，而且是系统程序无法删除，去强行限制该帐号的权限。

网站随着访问数量增多，崩溃概率增大，排查后发现问题只可能在云服务器上，去设置应用池回收时间，在更短周期内回收。

从一开始就养成用绝对路径的习惯，以后代码就可以少修改。

定期访问云主机检查有无中毒或异常进程。

网站设置单入口，权限页面可设置，避免被非法访问。

多思考运用或不运用缓存。


网站设计
背景
不知从哪一年起，大概是最高等级开放到开始吧，享受玩三国乐趣的玩家，要么就是已经坚持很多年了的，所以有一定装备和等级基础，要么就是冲堆钱进来的。而达不到这两个要求的新玩家，甚至这几年挂机的老玩家，都跟不上一直新出的副本、道具、市场等，打开官网，又发现官网的资料一直停滞不前，论坛和三国吧的精品资料不错，可惜好帖很容易匿贴，新手也不知道该怎么搜索出想要的资料。
因为对三国九年的热爱，想搭个三国非官方玩家交流平台，帮助新手玩家去快速上手和融入三国这个可爱的世界中。
整体框架

部分功能展示
分别选取一个前端、后台和游戏例子。
副职产品计算器
网站上线后最受欢迎的单页面，利用的数据双向绑定计算副职产品成本和利润。

物品交易平台
访客查看发布访客发布图一统计搜索记录图二后台管理图三



实现关键：
获取用户当前搜索所在的大区、物品类型，合理用好该游戏的特色分类。
拼图游戏
模拟客户端该游戏，帮助不熟悉的玩家训练出游戏技巧。

源码另需引入和：

    {
         
         
    }
    {
         
         
    }
    {
         
    }
    {
         
         
         
         
         
    }
    {
         
         
         
    }
    {
        
         
    }
    {
        
         
    }
    {
         
           
         
    }
    {
         
         
    }
    {
         
         
    }


    {
        {
            
        }
    }
     =
     =
     =
     =
     = 
     =
     =

     {
        清空元素还有计时器，名次
        
        =
        =
        =
        =
        
        
         
         
        =
        取值：，，
        正方形的长宽后缀用大写
         =
         =
         =
         =
         ={
            
        }
        记录初始顺序，之后判断是否胜利
        循环，格子越多，交换次数越多，得到交换后的一个数组
         =
        {
             =
             =
            ={
                 =
                = 
                =
                
            }
        }
        =
        创建格子元素，左盒子的是数字，右是数字
         ={
             = = =
            {
                
                
            }
             =
             =
             =
             =
            
            {
                
                
                
                
                
                
                
            }
            
        }
         = = =
        {
            
            
        }
        {
            
            
            
            
        }
        

         ={
             = = =
            {
                
                
            }
             =
             =
             =
             =
            
            {
                
                
                
                
                
                
                
            }
            
        }
         = = =
        {
            
            
        }
        {
            
            
            
            
        }
        
        计时器
        = 
        =
        捕获键盘按下事件
         =   {
              =  || 
              =  || 
             =
             =
             =
             =
             =
             =
              {
                 
                    左
                    {
                         =
                         =
                        
                        
                        
                        
                        
                        
                    }
                    
                 
                    上
                    {
                         =
                         =
                        
                        
                        
                        
                        
                        
                    }
                    
                 
                    右
                    {
                         =
                         =
                        
                        
                        
                        
                        
                        
                    }
                    
                 
                    下
                    {
                         =
                         =
                        
                        
                        
                        
                        
                        
                    }
                    
                 
                    
                    {
                         =
                         =
                        
                        
                        
                        
                        
                        
                    }
                    
                 
                    
                    {
                         =
                         =
                        
                        
                        
                        
                        
                        
                    }
                    
                 
                    
                    {
                         =
                         =
                        
                        
                        
                        
                        
                        
                    }
                    
                 
                    
                    {
                         =
                         =
                        
                        
                        
                        
                        
                        
                    }
                    
                
                    
            }
        }

    }
     {
        
         =
         ={
             
        }
         =
        =
        =={
             = 
             =
            ===={
                 恭喜你第一名！通过秒，步完成！
            } ===={
                 恭喜你第二名！通过秒，步完成！
            }
            =
        }
    }
     {
        
         =
         ={
             
        }
         =
        =
        =={
             = 
             =
            ===={
                 恭喜你第一名！通过秒，步完成！
            } ===={
                 恭喜你第二名！通过秒，步完成！
            }
            =
        }
    }


 = =
    
         = =显示隐藏游戏规则
         = = = 
            
                仅在有键盘的电脑上可以游戏
                供不熟练华容道拼图的玩家练习
                左手玩家一按键，右手玩家二按↑↓←→键
                按下下面几种游戏难度按钮之一，便开始计时游戏
                如果浏览器长宽不够大，游戏时出现滚动条影响体验，建议把浏览器缩放再游戏，一般是按下加↓缩放
            
        
    
     = =
         = =  =简单
         = =  =一般
         = =  =困难
         = =  =变态
         = =  =神级
    
     =
         = =
         = = =
         = =
         = = =
    

因为网站不盈利，希望可以中奖获取服务器续费券，多谢！

相关推荐
【腾讯云的种玩法】腾讯云搭建论坛【腾讯云的种玩法】搭建属于自己的服务器月日，  在内核邮件列表上宣布释出   。

版中引入了以下主要新特性：

多队列块层支持可插拔  调度器框架和死线调度器；
固态硬盘支持可扩展 ；
新的   命令； 日志；
新的  系统调用；支持    驱动；
支持  协议； 哈希函数；
新的  压缩实现；
以及大量的安全、架构和驱动更新等等。前言
在技术细节的内容开始之前，您可以先通过下方的二维码再次体验这个魔术。



　
　









一、
设置

 = == = = = =
 = =
 = =
配置
添加了标签，可能会出现标签默认置顶的情况，通过以下的样式设置可以解决这个问题。

     {
        
              和  
               
                
         
         
        
    }
    { }

二、屏幕自适应组件
引入
 =
组件作者：
初始化
 = = = = = =
     = 
         = = 
         = = = =
    

横竖屏配置

自适应组件的属性定义了是以横屏显示还是以竖屏显示。属性值为“”表示竖屏，为“”表示横屏。本项目使用“”。

自适应组件的属性定义了移动设备旋转后画面是否可见。属性值为“”表示仅竖屏时可见，为“”表示仅横屏时可见，为“”则表示横竖屏均可以看到画面。本项目使用“”。
屏幕缩放方式
自适应组件的属性定义了屏幕的缩放方式，目前一共有以下种缩放方式。



参数值
缩放方式





宽度等于屏幕宽度，高度等于屏幕高度，会改变原始宽高比



裁剪宽高后铺满屏幕，不改变原始宽高比



不进行任何缩放，不改变原始宽高比



整体进行等比例缩放后在屏幕中显示全部内容，不改变原始宽高比



仅让宽度等于屏幕宽度，高度会等比例缩放，不改变原始宽高比



仅让高度等于屏幕高度，宽度会等比例缩放，不改变原始宽高比



宽高比例
以上种缩放方式中，仅方式会改变原始画布的宽高比，其他方式都是以等比例进行整体缩放的。
画布可能铺不满整个屏幕
和这两种缩放方式始终都能让画面铺满整个屏幕，不过代价就是画布可能会被裁剪掉一部分边界。而、、这三种缩放方式在进行屏幕自适应之后可能会使得画布的尺寸小于屏幕尺寸，此时会导致画布铺不满整个屏幕的情况发生。
三、视频组件
引入
 =
组件作者：
初始化
  =  
{
    必填元素
    视频地址必填 
    可选是否循环默认为循环
    可选是否静音默认下只有生效安卓生效
    可选默认图片
     可选 时间点
    
    {   
    }可选 回调
    
    {
    }可选第一个画面出现回调
    
    {         
    }可选播放完成回调
}
播放视频
切换视频
更换视频源
通过视频组件的属性可以很方便地更换视频源。
视频提示点
如果想要在视频播放到某个位置时触发某个动作以便可以进行其他的逻辑处理，可以通过给视频组件的属性传递一个数组，并通过回调来实现此功能。

 = { }
以上代码的含义是：在视频播放到第秒时发出一个带有属性值的回调，视频组件的可以接收并处理这个回调。以下是包含有两个视频提示点的用法，想要配置更多视频提示点的使用方法可以依此类推。
  =  
{
    必填元素
    视频地址必填 
    可选是否循环默认为循环
    可选是否静音默认下只有生效安卓生效
    可选默认图片
     { } { }两个视频提示点
    
    {
        
        {
             第个视频提示点
                播放到了第秒
                

             第个视频提示点
                播放到了第秒
                
        }         
    }可选 回调
    
    {
    }可选第一个画面出现回调
    
    {         
    }可选播放完成回调
}
特别提醒：在更换视频的属性后，视频原来的属性依旧存在，可以通过重新给属性赋值来覆盖之前设置的视频提示点，或者直接传递一个空数组来清空所有的视频提示点。
让视频跳到新位置播放或暂停
视频组件的属性可以让视频跳到某个时间点并从该位置开始播放，类似的另外一个属性是，后者可以让视频跳到某个时间点并停在该时间点。
 = 让视频从第秒开始播放
 = 让视频跳到第秒并停在第秒
四、周杰伦读心术交互处理
视频分段
考虑到视频的总长度和玩家在一次体验中并不需要看完视频的全部内容，所以整个长达分秒的视频最终被拆分为多段子视频，并通过用户的交互来确定应该加载哪一段。除了开头的第一段，其他的分支视频都是在用户选择了相应的牌色、花色、单双点数之后才去动态加载并播放的。

视频提示点
通过视频组件的埋好选牌交互的提示点，然后就可以在回调触发后显示选牌交互动画。
 = { }


{
     
    {
         视频播放到第秒
            展示选牌互动动画    
            
    }
}
切换新视频
在用户点击了某个分支之后，通过替换的属性值来切换视频源。
 = 新视频
新视频就绪
在新视频开始播放并且画面的第一帧出现后会触发回调，在回调中移除选牌交互动画，这样可以让视频切换得更加平滑。

{
    移除选牌交互动画
}
五、结尾
以上就是本次周杰伦读心术的核心代码以及自适应组件和视频组件在实际项目中的用法介绍，希望对您有所帮助。译者：乐视高翻院 张鹏飞
分支管理策略对一个研发团队发布高质量的软件至关重要。在本文中，我们将探讨同一代码库中多任务并行开发时的解决方案，以及它们之间的优缺点。一般意义上来说冲突合并成本和独立任务发布能力之间的矛盾往往不可调和，但是特性开关提供了一条通往成功之路。
合并冲突
新产品研发初期代码量较少，团队规模也不大，这种时候并不需要太多正式流程。 然而，即使一个团队只有两名开发人员，为了有效避免冲突，仍然建议不要在同时对相同文件进行改动。 
不幸的是，即便我们小心翼翼的保持独立开发，还是会不可避免的修改同一个文件。有时候这种意料之外的代码冲突往往会带来很大的麻烦，比如工程师在使用开发界面时，大多经历过痛苦的三方代码合并
在本文中我们将探讨一些不同的方法来处理多个开发人员使用相同的代码库时出现的合并冲突问题。 
有些人可能会说，如果使用  这样的现代工具，大部分的冲突都会自动解决，所以这并不是什么大问题。然而事实并非如此。诚然在创建新分支方面非常便捷，但那些看似神奇修改自动合并却远没有那么智能。尤其当你在处理文件冲突时，往往无法摆脱对人的依赖。 
更重要的是，对语义冲突的自动解决无能为力。假设在一条分支中， 重命名一个方法，而与此同时在另一条分支中对该方法做了一些改动。当这两条分支合并时，无法得知 的代码正在调用一个不存在的方法，因为那个方法已经被改名了。自然也不会给出任何冲突的提示，因为我们目前的工具集是不支持检测这类语义冲突的。
当我们尝试编译合并的代码线时，才会发现语义冲突，而这些发现可能只是其中的一个子集。 如果代码库是动态类型的语言如，可能直到用户吐槽应用程序崩溃时，我们才会发现这些语义冲突。 
冲突不可避免，手动解决冲突会带来额外的工作量，但是潜在的成本也不可忽视，因为这种方式会对代码质量带来长期负面的影响。如果研发工程师意识到一个让代码质量变得更好的重构会引发大量的代码合并冲突，那么或多或少这种重构的意愿会受到抑制。 
由于代码变更所带来的冲突成本的上升，衡量代码优化投入产出比的天平就会偏转，这样一来随着时间的积累，代码内在质量就无法得到提升。尤其对于一些小巧但是影响范围较大的改动，这些类型的变更本来会逐步提升软件代码质量，但也正是这类变更才最容易诱发代码冲突。
在我看来，这才是分支开发模式所带来的真正的隐藏成本，因为它抑制了那些“让世界变得更好一点”的冲动，结果代码质量逐步下降，并最终走向一条不归路。所以，合并冲突被认为是一个很糟糕的事情，我们来看看如何避免这个问题。
主干开发
当一个小型研发团队启动一个新应用项目时，它们可以通过将所有开发人员的改动频繁推送到一个共享集成主分支的方式，来降低潜在的代码冲突风险，这也是持续集成思想的核心原则之一。
当每个人都频繁向主干同步代码改动的时候，潜在的代码合并冲突会在第一时间暴露出来，并快速得以解决。 
但这里面有一个很大问题，假如任何一个任务没有达到可发布状态，那么会影响整条分支的发布工作，我们可以举个例子来说明。 
和两个团队共同研发一个移动应用。在对用户配置界面进行大幅重构的同时，则专注于一个关键功能的开发，老板们对这个功能非常看重并且要求本周末需要提交到应用商店。
两个团队为了避免大型冲突而频繁的提交代码，到了周四完成了所有改动并提交测试，发现用户配置界面崩溃。她找到，解释，它正在对这部分代码进行大幅重构，而且需要的时间比他预期的更长。
强调这个功能必须本周完成发布上线，深吸一口凉气，于是在接下来的两天和一直在回退的改动，而其中一些修改已经与的新功能交错在一起。不过好在它们想方设法赶在周末前完成了上线工作。 
由此我们发现，由于和共用分支，它们原本独立的工作流反而变的错综复杂，无法独立完成发布工作，这是共用分支的方式所带来的问题，接下来我们看看能否做的更好。
特性分支  
为了解决工作流相互耦合的问题，开发团队会避免将开发一半的代码推送到共享分支上。一些团队选择继续在本地工作，其它团队则使用一条共享的特性分支，只有当功能模块开发完成后才会提交到共享分支。
其实对于这种分布式版本控制工具来说，上面这两种方式是等效的，一种是将未完成的代码修改提交到可见的特性分支上，一种是提交到本地的开发分支。因此，我们将它们都视为特性分支进行讨论。 

那么如果一个开发团队使用特性分支，可以解决全部问题吗，答案是否定的。因为这种方式引入了更加令人痛苦的合并风险。特性分支的改动只有在回归主线时才会集成其它改动，当两条特性分支同时修改了同一个文件，那么无论是有心还是无意都会带来潜在的合并冲突风险。
随着分支上的改动逐渐累积，这样的风险也随之变大，所以为了解决这个问题，部分研发团队会不定期的从主线向特性分支进行代码合并。 

然后，这对于两条同时存在的特性分支来说并不起作用，因为它们只有在回归主线的时候才会意识到彼此的存在，那么这些潜在的合并冲突将如影随形，一直到下一次回归主线为止。 

感谢 关于特性分支的阐述，以上图片受到了本文很大的启发

另外一些团队试图通过“交叉合并”来解决这个问题，将一条特性分支上的改动同步到另一条特性分支，来减小分支间潜在的合并冲突。 
但是，一旦您将两条特性分支合并在一起，基本上等同于创建了一条共享分支，那么我们在一开始提到的问题又会出现，未完成的代码开发会直接影响两条特性分支的工作，于是特性无法解耦和独立发布。
总而言之，功能分支允许团队通过分离工作流，实现独立发布。但是，不可忽视当并行分支包含大量修改时，它们又会引入巨大的合并冲突风险。 
特性分支定期同步主线只能一定程度解决回归问题，单对两条独立的特性分支则毫无帮助，而同步两条特性分支则相当创建了一条共享主线，那么特性分支的独立发布又无法保证。
特性开关  
那么是否有一种替代方案，可以帮助团队解决特性分支合并冲突的风险呢？它们可以选择频繁合并主线，但是这样一来就会让原本独立的工作流耦合在一起，无法独立发布。为此我们引入了特性开关也称为特性标志来解决这个问题。

 “” {}

只有当标志配置打开，新特性才会体现在应用界面中。这意味着即使新特性的相关代码充斥着各类，只要特性开关是关闭状态，也不会影响应用正常发布。
通过特性开关，半成品的代码也可以集成到共享分支中，并且不会影响分支发布。即便的改动只完成了一半，而需要发布一个正式版本，就可以将  的特性开关设置成打开，而将  正在开发中的特性开关设置成关闭即可。
这样我们既可以受益于持续集成所带来的福利，减少潜在的合并冲突，也可以保证特性开发彼此解耦，随时处于可发布状态。
这种技术由来已久，它来源于主干开发的技术实践，，，以及等业界知名公司都在采用这项技术，而特性开关正是每天两次从主线部署到线上环境的有力手段之一。
特性开关的缺点
与迄今为止我们讨论的其它方法一样，特性开关也有其固有缺点。由于需要对未完成的代码增加显式的逻辑控制，导致代码基线中引入大量的噪声。随着时间的推移，这种噪声可能会导致一些凌乱的代码，只有在功能模块不需要的时候才能移除这些代码。
测试人员可能需要一段时间才能适应这种利用特性标记进行开发的应用程序，部分没有完成的功能也会随着应用对外发布。
如果可以远程控制特性开关，那么在部署到最终用户之前，团队就应该对开关功能配置进行充分的测试。 
最后，某些类型的更改可能无法通过特征开关进行控制，尤其是那些修改范围广，涉及大量文件的例子。令人高兴的是，特性开关方法有其灵活的一面，对于那些复杂的改动，通过开关来控制是个不错的选择。
特性开关的常用技巧
当一个团队开始采用特性开关时，它们通常会碰到上面讨论的一些挑战，但最终会找出解决方法。 以下是工作中成功利用特性开关的一些技巧。

让开关过期
当刚开始接触这种方法时，很多团队往往会兴奋的引入很多开关，与此同时并不会花时间来移除那些不再生效的开关。我们需要妥善的管理这些过期的开关，因为它们会引入很多无用代码，让开关管理变得混乱不堪。
一些开发团队采取相当积极的做法确保旧开关过期，例如在创建开关时设置定时炸弹，或者在一段时间后抛出异常，或者在引入开关的时候同时在研发日志中创建一个移除开关的任务作为提醒和跟踪，都是一些不错的方法。
特性开关不是万能的
在新的工作流中引入特性开关需要谨慎评估。对于可以在代码中使用单点控制的功能模块比较适合采用开关方式，这类改动体现在界面上往往是一个按钮的显示隐藏，或者用户交互行为的改变。
对于类似内部重构性质的工作，则很难利用开关控制。对于这种工作可以采用特性分支的方式，通过将工作任务细分到足够小的颗粒度，然后使用一系列短分支渐进性的进行开发，可以有效降低长分支所带来的大规模合并冲突的风险。

总结
特性开关和特性分支都是解决代码并行开发的方法，帮助团队进行独立的变更发布。特性分支很容易入手，但是会引入痛苦的合并冲突。这种风险往往不利于对代码进行渐进式的优化，导致技术债务的累积并走向不归路。
特性开关允许团队实施真正的持续集成，并将代码更改与功能发布解耦，代价是增加了代码中开关的复杂性。特征开关不是万能的，也并非总是最佳选择，好在尝试使用这种方法对于开发团队来说成本很低，只需硬编码  语句即可，接下来的事情，就是看看它通向何方了。
原文：

文章来自：时代社区【批量装机自动化】项目名称   实现无人值守批量装机
项目需求：

利用   技术实现无人值守装和系统

需要有台服务器为新装系统提供自动分配地址服务。

新装好的系统需要以红帽官方提供的光盘系统作为本机源。 


项目分析：

利用为新建虚拟机动态分配地址

利用用来提供装机用的内核，初始化文件，引导程序和配置启动菜单。

分别在已经安装好的和系统上利用服务生成相应应答文件。


项目背景
   技术可解决人工装系统的繁琐的等待以及交互过程，也解决了人工装机的低下效率。利用该技术不仅可实现无人值守自动装系统，还可实现规模化，自动化以及远程实现。规模化就是可以同时装配很多台服务器，也可以同时装配不同的系统类型。自动化就是无人值守，解放劳动力。不需要光盘和盘等介质。
整体思路
  装机条件准备

准备和两个以存在的系统
准备和的安装源方式提供仓库
以系统为服务器提供和服务
配置服务

引导配置

启用服务，提供装机用的内核，初始化文件
提供引导程序，配置启动菜单 

实施步骤
配置装机的源

挂载红帽光盘，开机自动挂载挂载到服务下，实现真机自动发布源。真机：   
               _                      红帽系统光盘挂载
         _                    红帽系统光盘挂载        

客户机配置仓库，  以红帽为例



=
=
=
=

在红帽系统上查看源是否可用。  

       红帽同
服务器上手动搭建服务

以为服务器，安装包  

   

配置服务修改主配置文件： 

           定义服务分配网段
{
                   定义地址池            
                       默认网关
                           服务器地址
                             引导文件
}

启动服务  

  
启动服务

安装包  

   

启动服务  

  
准备装机文件

创建存储装机的必备文件 

   {}

分别在这两个目录下存放各自装系统的内核文件和初始化文件在红帽系统盘下里下载和 以为例
 
 
 

复制引导文件到 


   

下载装机选择时的背景图片和图形模块文件并放在根目录下。

 
 

创建目录来存放默认启动配置文件    

 
下载红帽系统光盘自带的启动配置文件放在目录下进行修改。需要修改地方有如下几处：在红帽系统盘下里下载。注意：只需要留以下四处：安装红帽和，救援模式，默认选择方式并在其配置条目里设置    
   
 
    
准备应答文件
红帽上：

装软件包       

运行



导入一个已经存在的包，进行修改，命名为。

从真机上去提取并创建目录以存放。 


    
红帽上：

装软件包   

   

运行



导入一个已经存在的包，进行修改命名为。

从真机上去提取并创建目录以存放。 


    
进行装机

根据用户需求去进行操作。可装机，修复，进行默认操作。

疑难解答
手动进行配置分区并保证应答文件和创建虚拟机时选择硬盘类型一致，均为。
注释掉应答文件关于的那一行配置
在文件中修改从硬盘启动为默认启动方式。
                                          从硬盘启动
                                默认启动方式
     
 
创建应答文件时，选择软件包时应该注意全部勾选。

相关推荐
精通配置以及问题解决【腾讯云的种玩法】几种在腾讯云建立的方法一前言：
发生了。这种类型的问题比较少见，这里说一下这个问题的分析过程。
分析：
、
生成的，一种是配置了_并且配置了的情况，文件会按照 生成。
还有一种是的，生成的文件使用可以解压出来。
加载文件，查看：

看到了原因是，那么还好，毕竟不是最难分析的。
、
从中来看，应该是 发生了错误，导致了自己主动了。那么具体分析一下 

再结合 的第一个参数，可见，是_的返回值是。
、
打开可见， 是。既然_的返回值是，那么只好继续分析的的在中实现了。
同时，还要找到对应的的版本。有两种办法供参考：
，在的命令行中敲  

可以看到当时映射了哪个的文件，可以判断出来。
，在中敲 _ |  ，再通过 找到对应的文件

确定了的版本是，那么就可以去下载对应的的源代码了。
、_
找到_，分析的具体原因。
在这里先大致说一下平台上的实现：并不区分进程和线程，内核中只有。多个组成一个，同一个组里面的共享虚拟内存空间，， 等等几乎所有的资源。但是，每个都需要有自己的用户栈，所以就需要在创建线程之前先为分配 对齐的内存。分配好内存之后，就可以使用系统调用_创建线程了。
、 
找到第一个可能返回的代码
 如果在为新的线程分配栈内存的时候失败，那么就会返回。
用的内存比较大块，维护了，尽量避免每次都需要。

先确认是不是真的有，如果没有，很可能就是内存分配失败导致的。
再来确认_的地址。
最后确认的的的内容，通过上面的几个关键字段的地址，可以分析出来的双链表都是指向了_。
综上，可以判断出来，内存是分配成功的。一，当时的_有一个缓存，直接分配给了那次分配；二，当时的_是空的，向要了内存，并且成功了，在后面执行失败的时候，把内存归还给了。
此二者，无论那种情况，都可以认为这条路径下，不会返回的。
、_
继续分析，看看还有哪里可能返回。
分析到了_，它的返回值可能是。继续分析，重点_函数中可能返回的可能性：
，的的个数超过了限制？从 和看进程的最大线程数，另外在中 可以看到所有的线程数。对比之下，进程的线程数远小于限制，排除。， 执行的时候遇到了？这个看起来也不太像，从的中没有看到任何信息。，的 不足？ ，发现只有。一来这个数值偏小，二来测试在上跑过多线程模拟的测试，这里看起来可能性最大了。
、复现
修改了之后，在原来的环境上一台虚拟机出现的问题，现在改用七台同时复现。目前七台虚拟机已经跑了超过了一天。还没有遇到。作者：

微信小程序从发布开始，可谓赚足了眼球，一度引发了开发界“全民学”的梗。
为了跟上时代步伐，我们直播团队也在发布后第一时间尝鲜，本文就来扒一扒这几天试水小程序开发的那些事。

入门
准备工作
想要开发微信小程序，首先必须要有一个微信公众平台小程序的帐号目前帐号只有内测邀请唯一途径，此帐号用于获取 、 、添加开发者等管理后台操作。
然后你需要下载官方提供的微信开发者工具，这是一个集成了编码、调试、预览、发布功能的一个。
编码功能：

调试功能，集成了开发者工具，可以实现样式预览、断点调试等：

发布、预览功能，可以在此上传你的程序，预览生成二维码，提供在手机微信上预览小程序的功能；另外，开发者工具还集成了编译、代码压缩等基础代码构建功能：

开发入门
对于哪怕是只有一点点前端经验的开发者来说，微信小程序的入门门槛简直是低到不能再低了。
一个小程序的主要文件目录简洁到如下：
├─  
├─ 
├─ 
└── 
    ├─ 
    │   ├─ 
    │   ├─ 
    │   └─ 
    └─ 
        ├─ 
        ├─ 
        ├─ 
        └─ 

一个小程序大体上分为两大块：

应用实例

页面


应用实例
小程序会读取根目录的，，生成程序实例，当然样式文件不是必需的。
程序配置
 
{
  
    
  
  {
    
     
     
    
  }
}

在这个文件里可以针对以下内容作小程序的全局配置：

页面文件的路径

网络超时时间

程序级配置

窗口颜色

手机导航栏、小程序标题栏的背景色、字体色，下图是设置了导航栏颜色为绿色的效果：




下拉刷新行为禁用下拉、下拉文字、图标、颜色，下图是典型的下拉刷新效果：


逻辑脚本
每一个小程序都是通过{}这样一个方法来注册的，在其具体的配置中，我们可以监听并处理程序级的生命周期函数、声明全局变量。比如，需要设置程序启动、显示时的一些操作，设置一些程序全局的数据、变量、方法，都可以在这里完成。

{
     {
      
  }
   {
     
  }
}

在里声明的属性及方法，都可以在小程序的任意页面里访问到：
 

获取应用实例
  = 
{
    {
    
  }
}

里支持的的程序级的生命周期回调包括：

    小程序初始化完成时触发

       启动，从后台进入前台显示时触发

        从前台进入后台时触发


页面
一个页面简单讲可以理解成小程序的一个完整界面单元，每一次完整的界面切换就是之间的跳转，下图演示一个典型的页面切换、回退过程：

一个页面的组成部分包括：

视图层

       用于描述页面的结构

                  用于描述页面的样式，非必需



逻辑层

                  控制页面行为及数据变化

            页面级配置，非必需




视图层与逻辑层的关系：数据驱动  事件绑定
视图层与逻辑层统一通过数据和事件相互联系起来，用一句话描述就是：数据驱动。
如果你有使用过、或其他框架等，对于“数据驱动”肯定一点都不陌生了，没错，小程序毫无疑问吸收了这一开发理念。
来看看一个简单页面的代码：


 = =
   = ={{}}
   =
    {{}}
  




{
   {
     {
         
         
    }
  }
  事件处理函数
    {
    触发了
  }
}

这段代码实现的是一个简单的页面效果：

可以看到出：
每一个“页面”，都是通过逻辑层的{}方法来注册的；
统一通过{{}}花括号的方式来引用逻辑层的数据；
视图层通过 来和逻辑层的事件回调实现绑定；
当逻辑层需要控制视图层变化时，统一通过关键函数来驱动数据变化，间接改变视图，如：


{
   {
     {
         
         
    }
  }
  事件处理函数
    {
    触发了
    {
         {
             
             
        }
    }
  }
}

上述代码中，调用后，页面图片就变化了。与中的真的是有相当的相似之处。
其实，微信小程序是完全不支持操作的，千万不要想着手动去控制结构。简单的说，开发中的那一整套都没法使用，包括、 
在近似于外，吸收了很多其他模板标记语言的优点，例如支持

条件渲染：

 ={{  }}  
 ={{  }}  
   


循环列表：

 ={{}}
  {{}} {{}}


事件绑定交互回调
前面已经提到过事件绑定，前端人对于事件还是非常熟悉的，事件是视图层到逻辑层的通讯方式。
小程序支持的事件类型包括有：

        手指触摸
     手指触摸后移动
       手指触摸动作被打断，如来电提醒，弹窗
      手指触摸动作结束
                       手指触摸后离开
               手指触摸后，超过再离开

和事件类似，小程序也支持冒泡事件和非冒泡事件，在绑定过程中通过冒泡和非冒泡区分：


 = =
   
   = =
     
     = =
       
       = =
         
      
    
  




{
   {
  }
     {
    
  }
     {
    
  }
     {
    
  }
     {
    
  }
}

上述程序中， 是关键分割点，点击 ，将会依次显示，，，因为 中使用了来绑定事件并阻止事件往上层冒泡， 及其子组件的冒泡事件都会在它这一层被截断。
丰富的组件
文件中，组件是视图的基本组成单元，类似的提供的各种标签，小程序提供了非常全面的组件：

容器

滚动容器

轮播组件

文本容器

视屏、音频

表单组件 输入框、单复选、滑动选择等等表单组件，下图示例是一个在环境中不好实现的组件，通过调用，来实现丝般顺滑的体验：




弹窗



地图展示

画布



样式
关于样式，其实没有什么好说的，作为小程序的描述语言，几乎与无异，写法、支持的属性也一样。不过，样式文件不是必需的，并且，页面级的样式会优先于全局样式，即的样式声明优先级会高于。
页面的切换和生存周期
前面有说到，页面作为小程序的界面单元，那么肯定就有页面间的切换、跳转、后退等。
以下程序是一个简单的通过动作触发页面切换程序：

 =
   =
    
   = =


 
{
   {
  }
  事件处理函数
    {
    {
       
    }
  }
}

除了使用方法外，还可以使用 ，这两者的区别是，前者打开的页面中，可以直接返回原来页面切换前的状态；而后者则是完全关闭当前页面打开新页面，返回时，原来的页面只能“重新渲染”。
区别于应用，小程序为每个页面提供了一些更强大的生命周期和用户操作回调函数：

                                监听页面加载
                       监听页面初次渲染完成
                                监听页面显示
                                监听页面隐藏
                      监听页面卸载
       监听用户下拉刷新动作

为带来的惊喜
应用热更新
以往的产品开发中，如果选用来开发，性能上一般会比要差一些，而选用开发，则一般有比较长的版本发布周期。
微信小程序的出现，使得我们在开发应用的同时，再也不用忍受漫长的版本发布，只要我们编写好了小程序上传，微信就可以通过后台实现客户端的热更新，在产品性能、发布体验上，都达到了质的提升。
强大的，强大的功能
虽然开发小程序非常接近于开发，但是本质上，它已经不再是，它更像是 这样的开发框架，通过，串联起底层和上层的、逻辑。
它通过封装微信客户端提供的文件系统、网络通信、任务管理、数据安全等基础功能，对上层提供了一套完整的，使得开发者能够非常方便的使用到微信客户端提供的各种基础功能，快速构建一个应用。
所以，在以前阶段无法实现或实现起来相当困难的一些功能，在小程序时代将会变得非常简单。
小程序为我们提供了丰富、简单的微信原生，可以方便的调起微信提供的能力或一些系统原生能力：

请求

文件上传、下载



本地图片、音频、视频的预览、播放

本地音频的暂停、进度等控制

视频、音频录制、预览、上传

设备网络状态

系统信息手机型号、设备像素比等

设备重力感应

罗盘

地理位置信息

动画、绘图

数据缓存，类似的，同样有的数据存储限制

微信支付

模板消息服务通知



开发成本低
小程序严格限定了代码的文件、目录结构，即同名依赖识别：
    ├ 
    ├─ 
    │   ├─ 
    │   ├─ 
    │   └─ 
    └─ 
        ├─ 
        ├─ 
        ├─ 
        └─ 

至少在应用、页面的核心代码这一块，开发者没有必要也不允许自定义自己的目录结构；
另外，结合官方提供的开发者工具，无需操心的编译、代码压缩等构建问题。
还没有那么完美
微信小程序的出现，给我们带来了接近、跨平台的开发体验，带来了接近原生应用的产品体验，然而在我们的实践中，还是品尝到了一些不是那么完美的体验。
关于视频
小程序确实提供了类似的组件，用于视频播放，然而把它远远还没达到的那么强大：

视频内容无法被覆盖

个人直播业务，基本所有的主播信息、点赞、评论、礼物等等展示都是覆盖于视频之上，如下图：

可是目前的小程序里提供的组件，会强制所有其他元素必须在其之下，类似中的值，它永远是最高的，这样想通过定位等方式实现漂浮礼物动效等业务需求，变得不可行。
关于后台接口

限制

小程序提供了一个请求接口{}，可以实现类似的功能，然而当我们使用现有的业务接口时，却遇到了困难。
在浏览器环境下，我们的后台接口作了很多安全限制，最基本的一项就是请求的限制，必须是本域请求才能通过。然而，微信小程序明确规定，这个方法中不允许设置。所以，如果你们的业务有类似我们的这样的后台接口时，会面临一些接口改造。

鉴权

我们正常的业务，前后端通信中，对的依赖是无处不在的，但是，小程序作为本质上的应用，请求是没有的，我们的程序中，也没有办法拿到，所以，对于很多现有的业务接口，直接兼容微信小程序，恐怕没那么简单。
小程序提供的唯一鉴权方案需要通过小程序客户端、业务服务端、微信平台服务器三方沟通来实现，具体可以看微信官方文档架构图：

其实，以上就是目前大部分开发平台使用的 标准鉴权方案。
相对封闭
可能是小程序出于战略考虑，设计上还是相对封闭的，想通过小程序打通现有的业务，包括、网站等等，甚至微信公众号，都会受到一些限制。
我们曾想过在小程序里提供常见的长按公众号二维码识别进入关注界面的功能，目前是无法实现的；另外，想通过小程序打开现有的页面、调起系统现有的等，目前也是不支持的。

原文链接：从年创始之初，知乎在互联网行业一直就有着不小的关注度，不论是早期的邀请制，早期创新工场李开复老师的天使投资还是近期的腾讯领投轮、今日资本领投的轮融资都让知乎上了不少次科技媒体的头条。私下里，互联网圈不少朋友也会时常上知乎去寻找今天可以和朋友们交流的热门话题，或者是看看来自不同行业的大牛们的长文解读，甚至于最近几次的百度魏则西事件，支付宝“白领日记”圈子等等舆论热点都是在知乎完成了第一轮舆论发酵。
因为我们团队在腾讯云近期也在负责和知乎有类似之处的内容产品，腾云阁腾云阁  腾讯云。主要是邀请腾讯系的技术大牛和腾讯云客户中的架构师和中小开发者们来以技术文章的形式分享自己一手技术经验。目前正处于一个种子用户不足人的冷启动阶段，所以想到成长的最好办法还是先找到行业的标杆，学习他人的思路并加以应用，内容社区这方面的标杆必然少不了知乎。
为此我结合近期刚学习的分析了一些专业社区最为重要的部分内容。再加上近期用个月的时间在知乎积累了粉丝，获得了知乎“互联网”领域话题优秀回答者的标签，所以干脆把这次的分析整理成一篇文章，分享给其他和我一样对知乎社区演变、功能迭代、社区机制感兴趣的互联网产品经理和运营同学们。
知乎爬虫运行在腾讯云主机上的原因是怕被网站封，这里提醒下各位程序员在部署爬虫的时候注意不要调的太高并发，对于网站的正常用户访问造成影响，这也算是使用爬虫主要注意的一点基本技术素养吧。
知乎位种子用户中创业者占比最高，设计师类活跃度最高。周源接受外界采访的时候说的知乎名种子用户。通过分析四位创始人各自关注的前名用户，并剔除重复数据，我们可以用爬虫获取他们的行业背景，在知乎的活跃程度回答数以及粉丝数量。在位有职业信息的用户中，以创业者人占比最大，其次是程序员人，媒体人人产品经理人，投资人人，设计师人，其他艺术、教育等人，这些互联网行业用户的认真答题氛围对于知乎的氛围影响很大。
在知乎种子用户来源上我发现了不少有意思的现象，不少种子用户都是通过知乎内测阶段的邀请机制加入的，比如腾讯的 是和菜头邀请来的，和菜头又是创始人杜潇邀请来的。
很有意思的数据是，与邀请的早期用户占比数不同。到目前为止，用户的关注人数超过人占该类用户占比用户在知乎活跃与否参考值，比例最高的是其他、设计师，其次是媒体人，产品经理，创业者，投资人，程序员，这部分活跃度的数据与作者本人日常在知乎万粉群里观察到的比例比较接近。
知乎四位创始人在知乎上回答的时间分布活跃曲线，看看知乎这样的社区产品是不是存在对于创始团队活跃度的依赖？
知乎 李申申是四位创始人中最宅的，回答数量最少，最不活跃，当然不排除李申申 老师有小号，可以偷偷看 轮子哥带逛的美女图片。张亮老师最活跃，个人回答问题数个 抵得上其他创始人回答数之和个。黄继新老师关注的知乎用户最多，关注了多人爬了好一会
分析回答的问题中涉及关键词的词频分析，看看知乎的社区氛围在创始人们回答中体现的如何？在一份给定的文件里，词频 ，指的是某一个给定的词语在该文件中出现的次数。这个数字通常会被正规化，以防止它偏向长的文件。
作为问答社区，知乎有以下几类词语讨论的较为频繁“问题”，“回答”，“为什么”，“如何”，“看待”。同时由于初期用户的背景“苹果、互联网、创新工场”等词汇出现，在几位创始人愿意回答的问题里出现的都比较频繁。
分析知乎四位创始人获赞最多的个问题，分析这点纯粹是我个人好奇。回答对应的问题 时间 点赞数 作者回答链接
什么叫「见过大世面」？ 个赞 张亮
能享受最好的，能承受最坏的
北师大东门的野草书店是一家怎样的书店？ 个赞 张亮
北师大东门的野草书店是一家怎样的书店？  北京  知乎
怎么看待恋人的恋爱史？ 个赞 黄继新
怎么看待恋人的恋爱史？  黄继新的回答  知乎
如何评价郭敬明小说改编的电影《小时代》？ 个赞 张亮
如何评价郭敬明小说改编的电影《小时代》？  张亮的回答  知乎
电影《社交网络》给你最深的感受是什么？ 个赞 黄继新
电影《社交网络》给你最深的感受是什么？  黄继新的回答  知乎
为什么在现实中从来见不到知乎大神那样的人？ 个赞 张亮
为什么在现实中从来见不到知乎大神那样的人？  张亮的回答  知乎
快速入睡有哪些妙招？ 个赞 周源
快速入睡有哪些妙招？  周源的回答  知乎
过去的五年～你经历了哪些重要的人生节点？对现在有哪些影响？ 个赞 周源
过去的五年～你经历了哪些重要的人生节点？对现在有哪些影响？  周源的回答  知乎
经常有人说史玉柱、周鸿祎等把握住了人性、人的欲望，是否能系统的说明人性、欲望有哪些？如何把握？能否推荐相关书籍？ 个赞 张亮
经常有人说史玉柱、周鸿祎等把握住了人性、人的欲望，是否能系统的说明人性、欲望有哪些？如何把握？能否推荐相关书籍？  张亮的回答  知乎
百度为什么不收购知乎？ 个赞 张亮
知乎  与世界分享你的知识、经验和见解
小结：从以上数据我们可以看出知乎的近位种子用户中，互联网领域创业者、投资人、程序员、媒体人偏多，但是从用户活跃数据来看，知乎上、艺术、教育、电影等其他类目的用户也颇为活跃，“互联网”以外其他话题的火热，也是知乎能够走到今日用户规模的重要原因。
知乎社区亟待形成认真回答氛围的早期，需要创始团队积极参与社区内容建设。知乎的位创始人在知乎成立的头三年年累计回答了个问题，占他们人累积回答数的，年合计回答了个问题，年年一共才回答了个问题，说明社区的氛围走上轨道了。
知乎的创始人们回答问题也不是都能达到超过个赞，知乎创始人们累计回答个问题，获赞万，也就是平均个回答个赞左右，所以你的知乎回答，获赞数量有没有超过个赞这个水准呢？
后续计划在下一篇文章中分析知乎产品迭代的版本历史，分析哪些是核心的功能迭代，知乎整体的信息流来源与分发机制，商业变现的产品形态；从知乎小管家的文章看社区机制的变化，社区成长的不同阶段，群体演化的历史，比如传说中的知乎万粉群的存在。

相关推荐
【腾讯云的种玩法】云服务器搭建爬虫环境
腾讯云主机环境安装爬虫框架过程
云服务器项目概述


课大作业，做一个小游戏，三人协作，不同终端，一个分支三个文件夹互不影响。地址 ，地址。先来目睹一下吧！


原理图
当玩家在使用画笔在画板上进行绘图工作时，把当前这个玩家的绘图的数据传递到服务器，然后由服务器把该数据广播到其他玩家，其他玩家的画笔将根据这些数据自动在画板上进行绘制。因为是多端，所以得采用统一的通信构架，经过协商，使用框架，客户端就可以统一、

服务器端数据交互

服务器地址：或者，采用了腾讯云的 服务器香港区核 配置，通过转发到的上，进行通信。
服务端关键代码：
 监听的事件
  {
    
      画者事件 
      传入：
      例：
       {
             
             
             
             
             
             
             
             
       }
     
      {
        
          广播事件 
          将画者事件接收的数据，向连接到服务器的客户端猜者进行广播
          例：
           ={
                 自定义画的方法
                {}
            }
          
         
         
    }



     监听客户端的方法
     {
         画者生成一个随机的关键字
         == {
             =   
             = 
             将生成的关键字发送到画者的客户端
             

         画者清空画布     
        }  == {
             猜者端清空画布
            进来了
            
             
        }  == {
             猜对后，清空画布，更换词
            
        }
    } 

    
      猜者提交 
      传入 
      
       }
     
      {
         标志位
          = 
         提示
          = 
         如果
        
          {
              ==  {
                进来了
                 = 
            }{
                 = 
            }
        }{
             = 
        }
        
        

         将标志位传到连接的客户端
         {
            
            
        }
    }
      {}
}

传入数据：因为是多端存在设备大小差异，经过讨论，根据比例进行计算，所以传入数据中有和。
{
      起点坐标 
         起点坐标 
     线的颜色  ，，  
     设备高度  
      设备宽度  
             终止坐标 
              终止坐标 
              线的宽度
}


效果图
端


端


安卓

总结
通过腾讯云的服务器代理各种请求，延迟时间较短，基本能达到本地的同步速度，不同端之间的交互也能处理得当。开发过程中也遇到了很多问题，比如另外就服务器框架没有达成共识， 端说自己用写到本地了这样和就用不了了，然后又我提出用的去统一写。端我用就连起来了，其它端有相应的。服务器解决后，然后各个端开始欢快地写起来了。
最后在跨端交互时，也遇到了不少的问题设备的比例，需要传入的值，然后就开始规定接口格式，每个参数的数据结构和类型、事例。
之后，传到  时也遇到了一些问题，由于其它人对的熟悉程度不一样，所以  是我在他们电脑给和上去的。经过此次开发，锻炼的团队协助能力以及对新框架的学习能力。

相关推荐
如何在腾讯云上搭建一个自动播放的服务器
【腾讯云的种玩法】搭建属于自己的服务器
 小小的激动，终于完成电脑和服务器的通信了作者：蒋鹏

不知道其他人有没有这样的顾虑，就是每次需要外出一些时日的时候总是担心家里的花无人浇水会干死。于是就想着是否能自己动手做一个可以用手机操控实现浇花的“半自动浇花器”呢，之所以称之为“半自动”是因为在一定程度上该设备使用了自动化控制的元件与技术，但操作依然是根据人的意志用手机来完成的因此为“半自动”。当实现自动检测土壤湿度来实现浇花并发送浇花报告到主人手机时可称之为“自动化”。
话不多说，来看看折腾这样一个东西需要准备些什么硬件和软件，有需要的人一定要耐心看完哦，内容有点多。
鉴于网络有点绕，开始前先放一下我的网络拓扑图

一硬件清单
树莓派：由于前段时间用树莓派折腾过家里的，因此树莓派首当其冲作为智控中心用来相应手机端发出的指令

：此设备与各种智能元器件通信非常方便，因此用他作为终端来和小水泵连接

继电器：此设备与下面提到的小型水泵串联，来实现水泵的运行与停止

小水泵：用来抽水的，如图，我为了方便连线，把这个头剪掉了用节号电池供电。这里要对水泵的电路进行简单改造，找到里面的红线正极，剪短分别连到继电器的常开和公共端。

摄像头：用来定时进行拍照，传回运行的监控图片。

其他设备：塑料软管，但由于塑料软管的方向性不好控制导致出水效果不好，后续考虑用一根管来替代。万用表，电烙铁，杜邦线最好有公对母的，可用母对母和排针自制若干。
硬件准备的差不多了，现在我们开始连线。
树莓派是一个完整的系统系统，因此可以以设备的形式挂载，并且用串口进行通信。当然通信方式还可以有其他，读者有想试的可以自己搜索方案。
继电器的，分别连接电源的，端，继电器的口连接的口。
二软件清单不包括
：这个可以设置树莓派与进行串口通信的端口。自行搜索使用方法，设置成功后运行应该能看到的设备
：这个其实树莓派中已经内置了，并且对接了跟硬件操作的函数库，非常方便实现跟其他设备的串口通信或者操作树莓派自身的管脚
：在树莓派上进行请求转发
：用来处理请求，来进行调用程序进行串口通信进而控制。
路由器：家里的路由器上设置端口转发用来将公网的请求转发到树莓派的上
腾讯云：由于是在微信上操作，因此操作一定要在公网进行。
运行在腾讯云上的：由于家里的路由器一般采用的动态，因此从家里路由器定时发送请求到腾讯云，程序获取此后记录到中，后续进行操作的时候先从获取此，然后请求都绑定到该上。
腾讯云对象存储服务：此步骤可生，因为可以当作使用，咱可是一名前端工程师，当然需要把页面、、图片等资源做分布
重要的 ：这个用来烧制程序，可以在下编写好后烧制到即可。
三关键实现
树莓派上的进行串口通信。用来获取的输出，用来向发送指令。
代码：用来向继电器发送指令其实就是高电平与低电平控制继电器的打开与吸合。
做一个简单的手机端界面用进行操控，这里的实现方式太多了，此处不列举了。我用做界面，做后台，页面的生成二维码用微信扫码后运行记得放入微信的收藏夹
鉴于网络交互还是挺绕的，这里补充一张网络拓扑图吧。以后有什么需要可以直接在这个框架上进行。
至此，浇花设备打造完成，放心外出吧，浇花的事情就交给他吧。浇花的同时会定时回传监控图片，用来协助你判断是否该停止浇花。嗯，到了自动化的时候也许就不用这么麻烦了。

相关推荐电源管理配置 下载前言
笔者试着在腾讯云公有云上部署了两台机器，一台、一台。这两台机器通过和以及服务将各自系统的信息传输至一台日志服务器，在日志服务器上部署了栈来保存和处理这些服务器上的信息和系统日志，随后，我在这些服务器上部署了弱口令、带有漏洞的系统组建和服务，作为高交互的蜜罐系统使用。
用一副图来表达一下这个小型的蜜罐系统：

当然，这个系统并不是重点，重点是我们可以借助它无死角地观察到试图进入系统内部的黑客做了什么。
神奇的
在系统部署后的一段时间里，并没有观察到系统被入侵的痕迹，只是发现了许多扫描记录，这些扫描记录大多指向服务，说明攻击者多数试图以暴力破解的方式攻入系统，于是我仔细查看了一下这些暴力破解的内容：

可以看到是一个访问频率非常高的用户名，这引起了我的注意，因为这个用户名似乎与弱口令和用户服务没有直接关联，于是我试着去搜索

原来这个用户名是树莓派的默认用户名，那么我在机器上创建了一个用户名为的帐号，并且设置对应的弱口令，引诱攻击者进入蜜罐：

接下来就是耐心等待登录成功的报警信息了
攻击捕获
月日晚点我截获了第一条攻击者登入的信息

随后，日志系统没有作出进一步的警报，主要是因为过滤模块规则设置不够完善所致好在我通过分析增量备份的信息帮助我看到了攻击者执行的指令

通过攻击者执行的指令可以发现，其通过指令获取了一个名为””的文件并将其保存在下，随后进入目录赋予该文件可执行权限，然后调用脚本执行了这个文件；
随后，攻击者了这个文件到目录下，并试图以权限修改文件将自己的信息写入系统启动脚本，随后尝试重启系统这个写入过程是非常粗暴的，我们可以看到一旦攻击者修改成功，文件中将只包含攻击者写入的内容
紧接着登入蜜罐系统，试图获取””这个文件，但是发现它已不在或目录下

因此，笔者试图从中恢复被攻击者删除的文件信息

行为分析
恢复完毕后，获得了这个脚本的完整内容，接下来作一个简单的分析
这个脚本的几个关键点
写入启动脚本

这一部分主要目的是为了使这个脚本能够在系统重启后自动运行；
杀死一系列进程：注意到其中有挖矿服务进程

将一个可疑地址加入到，将本地地址解析到删除设置的环境变量，并且改掉用户的密码信息

生成公钥写入配置文件

 配置一系列可疑域名，后续分析怀疑是服务器
 
 以后台服务形式挂起执行可疑的程序
 
安装扫描或和

利用作攻击跳板，继续利用当前机器，以””这样的口令对去扫描列表下的其他机器，一旦攻入则通过上传攻击脚本

总结
整个攻击流程并不复杂，但是对于自动化批量攻击的流程来说是非常好的例子，通过这样一种自动化的攻击，黑客往往借助等工具在很短时间内扫遍全网，如果攻击不仅仅是弱口令，而是某个尚未被披露的漏洞或者披露但未打补丁的漏洞那么就可能造成下一个或者在分析这个攻击脚本后，我针对性地优化了的报警规则，在日志系统中成功捕获了一系列类似该脚本在攻击时执行的指令

虽然是针对物联网和树莓派设备的，但是与云端自动化攻击流程有一定的相似之处，将攻击者的攻击路径图形化抽象一下，可以得到下面这个流程：

与传统的僵尸网络相比，云端使得攻击传播更为迅速，并且云服务器充足的带宽和数量众多的公网是和比特币、门罗币等矿机的首选目标。一关键词自动标注简介
关键词自动标注
关键词是指能反映文本主题或者意思的词语，如论文中的字段。大多数人写文章的时候，不会像写论文的那样明确的指出文章的关键词是什么，关键词自动标注任务正是在这种背景下产生的。
目前，关键词自动标注方法分为两类：关键词分配，预先定义一个关键词词库，对于一篇文章，从词库中选取若干词语作为文章的关键词；关键词抽取，从文章的内容中抽取一些词语作为关键词。
应用场景
在文献检索初期，由于当时还不支持全文搜索，关键词就成为了搜索文献的重要途径。随着网络规模的增长，关键词成为了用户获取所需信息的重要工具，从而诞生了如、百度等基于关键词的搜索引擎公司。
关键词自动标注技术在推荐领域也有着广泛的应用。如图所示，当用户阅读图中左边的新闻时，推荐系统可以给用户推荐包含关键词””、”云存储”的资讯，同时也可以根据文章关键词给用户推荐相关的广告。

图基于关键词的资讯推荐系统
关键词可以作为用户兴趣的特征，从而满足用户的长尾阅读兴趣。传统的信息订阅系统一般使用类别或者主题作为订阅的内容，如图所示。如果用户想订阅更细粒度的内容，这类系统就无能为力了。关键词作为一种对文章更细粒度的描述，刚好可以满足上述需求。

图传统的订阅系统
除了这些以外，关键词还在文本聚类、分类、摘要等领域中有着重要的作用。比如在聚类时，将关键词相似的几篇文章看成一个类团可以大大提高聚类的收敛速度。从某天所有新闻中提取出这些新闻的关键词，就可以大致知道那天发生了什么事情。或者将某段时间中几个人的微博拼成一篇长文本，然后抽取关键词就可以知道他们主要在讨论些什么话题。
现有问题与挑战
文章的关键词通常具有以下三个特点：

可读性。关键词本身应该是有意义的词或者短语。例如，“我们约会吧”是有意义的短语，而“我们”则不是。

相关性。关键词必须与文章的主题相关。例如，一篇介绍巴萨在德比中输给皇马的新闻，其中可能顺带提到了“中超联赛”这个关短语，这时就不希望这个短语被选取作为该新闻的关键词。

覆盖度。关键词集合能对文章的主题有较好的覆盖度，不能只集中在文章的某个主题而忽略了文章的其他主题。


从上述三个特点，可以看到关键词标注算法的要求以及面临的挑战：
新词发现以及短语识别问题，怎样快速识别出网络上最新出现的词汇人艰不拆、可行可珍惜…？
关键词候选集合的问题，并不是文章中所有的词语都可以作为候选
怎么计算候选词和文章之间的相关性？
如何覆盖文章的各个主题？
关键词分配算法需要预先定义一个关键词词库，这就限定了关键词候选范围，算法的可扩展性较差，且耗时耗力；关键词抽取算法是从文章的内容中抽取一些词语作为标签词，当文章中没有质量较高的词语时，这类方法就无能为力了。为了解决上述这些问题和挑战，我们设计了层次化关键词自动标注算法
二层次化关键词自动标注算法
层次化关键词体系
针对新闻的关键词识别任务，我们设计了一套层次化的关键词体系，如图所示。第一层是新闻频道体育、娱乐、科技、，第二层是新闻的主题一篇新闻可以包含多个主题第三次是文章中出现的标签词。

图层次化关键词体系
三层关键词体系有以下几个优点：

三层关键词体系从不同角度描述文章所表达的内容，从而能让标注结果能更好地覆盖文章的各个主题，缓解了关键词覆盖度不够的问题。

由于各层之间有隶属关系，利用这种关系，可以抽取出更相关的关键词，如：“非诚勿扰”在娱乐新闻中可能是指娱乐节目或者电影，可以作为一个关键词；如果是出现在汽车新闻中，则不太可能是文章的关键词。



图层次化关键词自动标注结果示例
算法流程
从图中可以看出，主题和标签词依赖于新闻频道，所以在标注一篇新闻的关键词时，首先需要获取新闻的类别，然后根据新闻的类别选择不同的主题模型预测新闻的主题，最后再抽取新闻中的标签词。
在关键词标注方法上，我们融合了关键词分配和关键词抽取两类方法。图描述了算法处理一篇文章的流程。其中频道和主题的抽取方法属于关键词分配这一类算法，标签词抽取则属于关键词抽取这一类算法。除了上一节中所说的层次化关键词的两个优点之外，我们的算法有如下几点好处：

关键词分配算法有效缓解关键词抽取算法召回不足的问题。

在关键词分配算法中，使用频道和主题代替传统的关键词，从而减少词库构建成本、增强算法的可移植性。



图层次化关键词自动标注算法流程
  文本分类器
文本分类器我们采用最大熵模型，使用业务最近一年带频道标签的新闻作为训练集。每个频道选取频道相关度最高的个词语作为分类特征。
对于最大熵模型，网上可以找到很多相关资料，这里就不作介绍了。
  主题预测
使用作为主题聚类模型。开源的大部分开源实现都是单进程的，在处理较大规模的语料时，其时间和内存开销都非常大，无法满足我们的要求。因此我们实现了一套分布式的平台，使得能够快速处理大规模的数据。
语料通过平台处理后，会得到每个主题下概率较高的词语。人工选取质量较高的主题，并使用一个词语或者短语概括这个主题。对于一篇文章，的结果是一个概率向量，我们选取概率值大于阈值的主题作为文章所属的主题。

图高质量的主题

图文章的主题关键词
  标签词抽取
标签词抽取包括：生成候选词和相关性计算。下面分别介绍这两部分。
生成候选词
通过分词得到的基本词、短语等，过滤掉基本词中的停用词
命名实体有效解决新词、热词的自动发现
相关性计算
使用线性加权对候选词打分，其特征包括：



候选词和文章频道的相关程度

候选词和文章的相似度

候选词的长度

候选词出现的位置

候选词的类型基本词、实体类型、短语等


选取相关性得分大于阈值的候选词作为文章的标签词。
效果评价
在腾讯网上随机抽取的篇新闻上做测试，各项指标如表格所示。由于主题集合的开放性，其召回率很难评价，故只评价其准确率。
表格 层次化关键词自动标注算法准召率

三接入业务与展望
对抽取错误的关键词进行分析，算法还存在一些问题，后续会针对这些问题继续改进。

泛义词过滤不彻底，后续需要继续优化候选词过滤模块。

抽取出来的两个关键词可能是表述同一个语义，后续引入同义词等资源解决。


目前已经接入的公司业务有：腾讯新闻客户端、手机个性化资讯。欢迎有需求的团队联系我们，使用腾讯文智自然语言处理。
参考文献
     刘知远 基于文档主题结构的关键词抽取方法研究 北京 清华大学                                                  

相关推荐【 文智背后的奥秘 】系列篇：结构化抽取平台【 文智背后的奥秘 】系列篇：情感分类【 文智背后的奥秘 】系列篇：文本聚类系统作者：

建模大数据用于精简用例的实践
生活的智慧，有时不在于多，而在于少。同理适用于测试用例的管理中。
一．热身活动：数一数你的产品总用例
随着互联网时代节奏的日益加快，许多产品都会在版本迭代中对功能做加法，于是累计的测试用例似乎都无可避免地越来越多。从小编自己的经验，作为测试人员，最开始设计测试用例的时候追求做到“全面”，导致我们的用例似乎也不知不觉中在做加法。你有没有思考过一个问题，你的产品总用例究竟有多少？而当下你是否也感受着用例多带来的效率不高的痛点？
不妨坐下来，随小编一起打开这几个版本产品的总用例。你的用例是否也有以下几个问题中的任意一个：用例量庞大：以笔者的用例为例子，每个版本都有一份该版本的用例以及一份总用例，总用例文件分散，用例数多总用例数接近，无整体清晰视图；
可读性差：由于测试人员分工的不断调整，同个模块的用例的维护是经由几轮不同编写风格的迭代，甚至有些用例格式不统一既有又有图；
用例优先级不明确：用例优先级是凭经验拍脑袋定的，同时历经几个版本未对旧用例的优先级做调整，导致测试执行时间冗长且部分用例已不是核心内容。
如果你的用例也有上述问题中的任意一个，是时候要开始思索，是不是该重新整理一下用例，是不是该对用例做减法了？如何用科学武装自己，有底气来做减法呢？
接下来请小编的脚步，一起对用例做科学的缩减大法。
二．缩减大法解读“建模统计点”齐发力
小编的精简用例，运用了建模法去建立核心模块的能力矩阵图，再根据产品数据埋点上报的排名来确定模块热点图重要等级，确定测试优先级，最终运用到用例的删减中。
本次用例精简，可以解读为以下几步：
 建立能力矩阵图——根据建模思想
注  是测试团队使用的一种建模方法，是对测试内容进行划分属性，部件，组成能力表，用来快速地建立产品的模型，以指导下一步的测试计划和设计。
的定义与使用可以参考文章： 方法可以让测试人员对整体项目有一个全观的视图， 但是也有一定的局限性——需要和其他的建模方法结合起来使用，也就是对某个模块可以通过确定测试策略，具体测试实施需要依赖其他的建模方法。
小编跟产品同学根据产品策略，确认了当前的几个模块的属性值即与竞争对手相区别的关键特征，再根据从的角度确立对应的能力即产品实现其核心价值的手段，得出以下能力矩阵图
 确定热点图，得出测试优先级——根据梳理统计点数据
   建立好能力矩阵图后，如何去确定模块的重要程度矩阵热力图呢？以前我们会根据经验来做判断，那么有没有更科学一点的方法？答案是肯定的，我们可以让用户来告诉我们，什么才是他们关注的，这才是合理的优先级划分的方式。也就是可以通过统计点的上报量来确立对应模块的重要程度。
导出产品的统计点数据，根据模块做归类，根据渗透率做排序
注： 渗透率 = 功能点击人数用户数

分析渗透率数据，定出合理的界定标准：
如何根据埋点数据来界定重要程度的标准呢？
小编这边采用的是二八定律把主要测试精力花在模块上，于是选出排名前的统计点标为最高优先级，再把剩余按照一样的规则分成三层，得出如图的四层结构：
注：统计点从上到下按照渗透率从高到低的排序。
举个例子：假设一个产品总共个统计点，那么我们将这个统计点按照从高到低的顺序进行排序为，，那么可以得到以下的分层关系：
注：这个划分依据是小编根据二八原则以及产品特点来划分的，统计点个数比接近为，读者可以根据不同产品情况灵活调整。
根据界定标准，完善能力矩阵的热点图，区分测试优先级据以上三个步骤所述，小编得到的最终的产品能力矩阵热点图如下，此时我们已对产品的重点模块已有了比较清晰的了解：
 精简对应用例—根据能力矩阵热点图
走到这一步，终于可以开始进行用例精简了。那么问题来了，得到这张能力矩阵热力图之后，如何运用到用例精简中呢？
对用例做预处理
为了方便下一步能痛快做用例精简，预处理测试用例是必要的。预处理主要是做以下几步工作：

统一用例格式与风格：如统一为思维导图或的形式；
合并测试路径：把操作与结果分开写的用例合并为完整的测试路径如下图，或者把可组合的场景的用例组合起来运用场景组合如图、正交法、最大路径组合等方式，减少用例的分支扩散；图 操作与结果合并图 场景组合
去掉功能无关、已过时的需求对应的用例，确保当下用例为最新。

对用例做二次处理
小编的用例精简二次处理，是采用与功能点重要程度强关联的原则详见下图。
在热力图为低优先级的功能点，采用只保留功能可用性相关的用例且优先级置低的方法。因为在整个产品功能里面，若一个功能重要程度较低却写了很多用例，那么我们需要反思一下是不是测试策略定位有问题。也就是说，功能的重要性占比小，那么对应的用例肯定少，同时测试执行优先级也不会很高。
在热力图为高优先级的功能点，会把统计点涉及的场景对应的用例标注较高优先级，其余异常或复杂路径按情况定义不同优先级来保留的方式，只删除无关或废弃或过于复杂的用例。一来是因为高优先级的功能点不会太多根据之前所述的二八原则，二来是因为重要性高，用例保留得多可以方便对整体功能的把握。
三．精简用例后的收益
经历了一场轰轰烈烈的精简后，小编这边也简单总结下缩减大法带来的收益：

整体用例数据

执行策略优化发挥优先级的作用

用例格式统一管理


格式统一为图，且模块重要性标注了颜色来区分，每个用例只有个优先级，优先级按照第二点用例处理原则所述进行标识。
执行效率与质量
根据两次灰度版本验证，得出如下数据：有理论有实际、有科学有底气，既能对用例来次大裁剪，又能对产品逻辑有个整体的梳理和重点的把握。看到这里，你是否动心了？快给你的用例做减法吧。图为：腾讯云产品副总监王琰
发展史：是什么造就了今天的人工智能
王琰在演讲开头提到，人工智能是近年来非常热门的话题，高密度的讨论足以说明人工智能人气之旺，也反映了其市场热度。人工智能的概念从上世纪年代就已产生，经过起步阶段、专家系统推广、再到如今深度学习阶段。年开始由于深度学习神经网络的出现，进入了高速发展期。进入年，在图象视觉、语音技术上面的重大算法突破加快了的市场化进程。
演讲中，王琰提出了她自己思考，为什么人工智能的飞跃会出现在今天？究其原因，王琰认为主要体现在三个方面：第一是计算能力增强。使用并行计算神经网络，更大的硬件存储能力使得创造出更大的神经网络变成可能。第二是大数据出现。互联网时代的到来产生大量数据，训练数据量的增大可以让神经网络更好的学习，提升算法性能。第三是新算法推出。新算法可以提前训练网络，避免网络受层数的限制；更好的方法用来估算参数，可以使网络在更短时间内做得更精准。王琰说，人工智能就像我们的另一个大脑。
腾讯公司初探
腾讯作为一个互联网公司，在领域一直都有非常深入的探索。过去腾讯公司会结合已有的应用场景，包括腾讯自己的社交软件、游戏、搜索引擎、广告等实现在领域的探索，随着概念的更新，腾讯也不断进行新场景的应用探索。
、腾讯人工智能业务应用
第一是微信。语音输入是腾讯在微信的大胆尝试。通过在输入框输入语音，语音就可以转化为文字。看似是一个非常简单的应用，背后却隐藏着复杂的语音识别算法。其次是在音乐里的尝试。当我们听到一首歌但却不知道歌的作曲和演唱者的时候，就可以通过简单的哼唱将这首歌在曲库里面找出来。第三是腾讯优图。腾讯优图是基于图象和人脸深入研究的人工智能研发团队。它的应用场景主要是社交中的智能鉴黄，基于过去建立的庞大黄色图库，优图团队研发的智能鉴黄机器人可以达到的识别率。第四是腾讯的滨海大厦，主要应用技术是刷脸门禁。进门不需要刷卡，只需要小机器人做刷脸，甚至不需要正面，侧面都可以识别出来。
、腾讯 与腾讯云
年开始腾讯公司也开始了战略布局，其目标是让腾讯的 成为全世界顶尖的研究机构。成立不到一年，腾讯 就推出了围棋机器人，在月日举办的第届杯世界计算机围棋大赛上，首次亮相的“绝艺”战全胜夺得冠军，充分体现了腾讯在技术研究方面的实力。腾迅云一直以来拥抱开放，主要做连接和生态，把腾迅过去海量的互联网经验、先进的技术通过这个平台开放出来，连接更多的行业和应用。在云上拥有了资源、数据和算法之后，除了应用在腾讯自身的应用上，也通过  把这些能力分享给客户，以产生更多的市场价值。
、腾讯云  服务矩阵

简单来说，腾迅云 服务矩阵服务三类目标群体，一个是基础研究。基础研究员可以通过云服务器以及深度学习平台快速搭建一个学习环境，以加速技术研究。其二是对应用开发者，通过对外开放图象识别、语音识别接口，可以让开发者在应用中使用一些具有一定实力的人工智能能力。第三是与行业融合，结合云计算本身的资源优势以及在上的技术实力，给大家提供垂直的行业解决方案。
、深度学习平台
深度学习平台是基于腾讯云强大计算能力的一站式深度学习平台。通过可视化的拖拽布局，组合各种数据源、组件、算法、模型和评估模块，让算法工程师和数据科学家在其之上，方便地进行模型训练、评估及预测。目前支持 、、 三大深度学习框架，并提供相应的常用深度学习算法和模型。
腾讯战略布局：打造全方位技术包围 优图计算机视觉
优图计算机视觉在 比赛中刷新  挑战的 项目世界纪录；在无限制条件下人脸验证测试中，优图提交的最新成绩为，再次在这一测试中刷新纪录；在国际权威海量人脸识别数据库中，以的最新成绩在万级别人脸识别测试中拔得头筹。
智能语音识别
智能语音识别由四部分组成，分别是语音识别、语音合成、语音唤醒和声纹识别。除此之外，腾讯还在一些垂直领域做了深耕，除了标准的一些社交场景之外，也在法院、安全、医疗等场景有了语音方面的垂直引擎。
人脸核身解决方案
今年央视的“三一五”晚会上介绍的人脸核身方案，已经被黑产突破防护，并可以伪造身份。优图团队独创的语音唇动活体检测技术，可以抵抗照片、视频、静态模型的攻击，不受方言甚至语种的影响。它的流程主要是身份证扫描出身份证号，同时录一段视频，产生一段随机的验证码，再和身份证图像对比。其实，在优图实验室已经组成了一个专门进行黑产对抗的团队，增强安全能力。除了常用的工程上的随机性，实时的自然交互，同时还在算法上捕捉一些人眼看不到的伪造和差距。目前腾讯的“人脸核身”解决方案已经在互联网上有所应用，比如金融领域、滴滴租车等。
手写运单识别解决方案
在手写体识别和通用印刷体识别实验中，手写体手机电话识别准确率可达以上，在业界突破复杂手写体识别的难题；通用场景单字准确率超过，在国际 文本检测项目中刷新世界纪录；可应用在各类印刷体识别，如广告、菜单、驾照等，以及定制化手写识别场景。
智能相册解决方案
智能相册解决方案主要是用在社交场景，从相册和微云相册演化而来。当在手机上上传照片的时候可以马上归类到某个文件夹，分辨其是小猫、小狗还是一个小孩，即通俗的智能分类技术。目前腾讯可以提供面向社交场景的超过种的热词分类。同时基于特殊行业的定制化标签，也可以通过快速学习的方式实现很快地支持这个标签。
智慧法庭语音解决方案
随着人民法律意识的提高人民法院的案件审理数日益增加，庭审效率亟待提高，而庭审现场记录的百分百还原一直以来都无法实现。通过在法庭现场应用语音识别，可以将法官、原告、被告等各角色的现场发言实时转写成文字笔录，并对录音及文本进行存储，减轻书记员工作负担的同时实现了庭审现场的百分百还原。专业法务领域定制化引擎，有效应对法律专业术语。支持自定义热词，提升人名、机构名、公司名等词汇识别准确率。个案定制话模型，满足物理、化学等专业领域司法案件的高准确率需求。私有化部署，保证人民法院的数据安全性。
目前该系统识别准确率已经达到以上，在北京知识产权法院、河北高级人民法院、珠海中级人民法院等余家法院部署应用。 除了上述方案，腾讯云还提供安防监控解决方案、智能直播审核解决方案等，真正实现技术上的全包围，为当前国内的人工智能发展开出一条血路。 演讲的最后王琰提到，现在的人工智能应用已经趋于成熟，但主要集中在商业领域里，未来将更多的在公共领域进行开发，比如教育、医疗、智慧城市、智能家居等。
：界面新闻 会员活动运营平台  ，是  会员增值运营业务的重要载体之一，承担海量活动运营的  系统。  是一个主要采用语言实现的活动运营平台，  日请求亿左右，高峰期达到亿。然而，在之前比较长的一段时间里，我们都采用了比较老旧的基础软件版本，就是 年的技术。尤其从去年开始，随着  业务随着  会员增值业务的快速增长，性能压力日益变大。
于是，自年月，我们就开始规划  底层升级，最终的目标是升级到  。那时，  尚处于研发阶段，而我们讨论和预研就已经开始了。
一 的学习和预研
  和 
年就  性能优化的方案，有另外一个比较重要的角色，就是由  开源的    ， 是一个  开源的  虚拟机。 使用   ，即时编译是种软件优化技术，指在运行时才会去编译字节码为机器码的编译方式以及其他技术，让  代码的执行性能大幅提升。据传，可以将  版本的原生  代码提升倍的执行性能。
 起源于  公司， 早起的很多代码是使用  来开发的，但是，随着业务的快速发展，  执行效率成为越来越明显的问题。为了优化执行效率， 在年就开始使用 ，这是一种执行引擎，最初是为了将  的大量  代码转成 ，以提高性能和节约资源。使用  的 代码在性能上有数倍的提升。后来， 将  平台开源，逐渐发展为现在的 。
 成为一个  性能优化解决方案时，还处于研发阶段。曾经看过部分同学对于  的交流，性能可以获得可观的提升，但是服务运维和  语法兼容有一定成本。有一阵子， 成为一个呼声很高的东西，很多技术同学建议  也应该通过  来优化性能。
年月，我参加了中国 ，听了惠新宸关于  内核的技术分享。实际上，在年的时候，惠新宸 内核开发者和  另一位语言内核开发者之一就曾经在 的版本上做过一个  的尝试并没有发布。 的原来的执行流程，是将  代码通过词法和语法分析，编译成  字节码格式和汇编有点像，然后， 引擎读取这些  指令，逐条解析执行。
 
而他们在环节后引入了类型推断，然后通过生成，然后再执行。

于是，在  测试程序中得到非常好的结果，实现后性能比  提升了倍。然而，当他们把这个优化放入到实际的项目  一个开源博客项目中，却几乎看不见性能的提升。原因在于测试项目的代码量比较少，通过  产生的机器码也不大，而真实的  项目生成的机器码太大，引起  缓存命中率下降  。
总而言之， 并非在每个场景下都是点石成金的利器，而脱离业务场景的性能测试结果，并不一定具有代表性。
从官方放出的  和  的性能对比可以看出，两者基本处于同一水平。

 在性能方面的优化
 是一个比较底层升级，比起  的变化比较大，而就性能优化层面，大致可以汇总如下：

将基础变量从结构体变为联合体，节省内存空间，间接减少在内存分配和管理上的开销。

部分基础变量_、_等采用内存空间连续分配的方式，降低  的发生的概率。从 获取数据和从内存获取，它们之间效率相差可以高达倍。举一个近似的例子，系统从内存读取数据和从磁盘读取数据的效率差别很大，  类似遇到缺页中断。

通过宏定义和内联函数，让编译器提前完成部分工作。无需在程序运行时分配内存，能够实现类似函数的功能，却没有函数调用的压栈、弹栈开销，效率会比较高。


 平台技术选型的背景
就提升的性能而言，可以选择的是年就可直接使用的或者是年底才发布正式版的。会员是一个访问量级比较大的一个系统，经过四年持续的升级和优化，积累了多个业务功能组件，还有各种编写的公共基础库和脚本，代码规模也比较大。
我们对于版本对代码的向下兼容的需求是比较高的，因此，就我们业务场景而言，良好的语法向下兼容，正是我们所需要的。因此，我们选择以为升级的方案。
二升级面临的风险和挑战
对于一个已经现网在线的大型公共服务来说，基础公共软件升级，通常是一件吃力不讨好的工作，做得好，不一定被大家感知到，但是，升级出了问题，则需要承担比较重的责任。为了尽量减少升级的风险，我们必须先弄清楚我们的升级存在挑战和风险。
于是，我们整理了升级挑战和风险列表：

和这两个年的基础软件版本比较古老，升级到和，版本升级跨度比较大，时间跨度相差年，因此，兼容性问题挑战比较高。实际上，我们公司的现网服务，很多都停留在和的版本，版本偏低。

大量使用自研扩展，很早在公司内部就没有人维护了，这个扩展之前只有和的编译版本，并且，部分扩展没有支持线程安全。支持线程安全，是因为我们以前的使用了模式，而我们希望能够使用的模式年中，在和之后，推出的多进程线程管理模式，对于支持高并发，有更良好的表现。

语法兼容性问题，从到的跨度过大，即使官方号称在向下兼容方面做到，但是，我们的代码规模比较大，它仍然是一个未知的风险。

新软件面临的风险，将和这种基础软件升级到最新的版本，而这些版本的部分功能可能存在未知的风险和缺陷。


部分同学可能会建议采用会是更优的选择，的确，单纯比较和在高并发方面的性能，的表现更优。但是就的而言，和_两者并没有很大的差距。另一方面，我们因为长期使用，在技术熟悉和经验方面积累更多，因此，它可能不是最佳的选择，但是，具体到我们业务场景，算是比较合适的一个选择。
三版本升级实施过程
 高跨度版本升级方式
从一个年的直接升级到年的，这个跨度过于大，甚至使用的的配置文件都有很多的不同，这里的需要更新的地方比较多，未知的风险也是存在的。于是，我们的做法，是先尝试将升级到，调整配置、观察稳定性，然后再进一步尝试到。所幸的是，是一个比较特别的开源社区，他们之前一直同时维护这两个分支版本的和，因此，即使是也有比较新的版本。

于是，我们先升级了一个，对兼容性进行了测试和观察，确认两者之间是可以比较平滑升级后，我们开始进行的升级方案。

的升级，我们也采用相同的思路，我们先将升级至当时，还是版本，然后再将升级到，以更平滑的方式，逐步解决不同的问题。于是，我们的升级计划变为：
 
编译为动态的模式支持通过配置切换模式，根据现网风险等实时降级。
 
、、三者粗略介绍：

，多进程模式，个进程服务于个用户请求，成本比较高。但是，稳定性最高，不需要支持线程安全。

，多进程多线程模式，个进程含有多个线程，个线程服务于个用户请求，因为线程更轻量，成本比较低。但是，在场景下，资源会被占据，无法响应其他请求空等待。

，多进程多线程模式，个进程也含有多个线程，个线程服务于个用户请求。但是，它解决了场景下的线程被占据问题，它通过专门的线程来管理这些连接，然后再分配“工作”给具体处理的，工作不会因为而导致空等待。


关于模式的官方介绍：

部分同学可能会有模式不支持的印象，那个说法其实是年多以前的国内部分技术博客的说法，目前的版本是支持的，详情可以浏览官方介绍
开启动态切换模式的方法，就是在编译的时候加上：
=

从升级到相对比较容易，我们主要的工作如下：

清理了部分不再使用的老扩展

解决掉线程安全问题

将等编译到新的版本

代码语法基于的兼容实际上变化不大

部分扩展的同步调整。扩展变为_和，以前的是包含了编译缓存和用户内存操作的功能，在比较新版本里，被分解为独立的两个扩展。


从升级到的工作量就比较多，也相对比较复杂，因此，我们制定了每一个阶段的升级计划：

技术预研，升级准备。

环境编译和搭建，下载相关的编译包，搭建完整的编译环境和测试环境。编译环境还是需要比较多的依赖。

兼容升级和测试。扩展的重新编译和代码兼容性工作，功能验证，性能压测。

线上灰度。打包为的安装包，编写相关的安装安装执行代码包括软链接、解决一些依赖。然后，灰度安装到现网，观察。

正式发布。扩大灰度范围，全量升级。



因为从升级到的过程中，很多问题已经被我们提前解决了，所以，的升级主要难点在于扩展的编译升级。
涉及主要的工作包括：

的扩展到的比较大幅度改造升级工作量比较大的地方。

兼容的内存操作函数的改名。的时候，我们使用的前缀的函数不可用了，同步变为前缀的函数需要扩展。




语法兼容升级。实际上工作量不算大，从升级到变化并不多。

我们大概在年月中旬份完成了和的编译工作， 月下旬进行现网灰度，月初全量发布到其中一个现网集群。
 升级过程中的错误调试方法
在升级和重新编译扩展时，如果执行结果不符合预期或者进程掉，很多错误都是无法从日志里看见的，不利于分析问题。可以采用以下几种方法，可以用来定位和分析大部分的问题：

_

从代码层逐步输出信息和执行，可以逐步定位到异常执行的函数位置，然后再根据函数名，反查扩展内的实现函数，找到问题。这种方法比较简单，但是效率不高。

 – 

这种方法主要用于分析进程的场景，我们采用的编译方式，是将_变成的子或块的方式，使用 –来监控的服务进程。
命令： | 

 调试指定进程：
命令： 

使用进行捕获，然后构造能够导致的请求：

通常是多进程模式，为了让问题比较容易复现，可以在里修改参数，将启动进程数修改为个下图中的多个参数都需要调整，以达到只启动单进程单线程的目的。

当然还有一种更简单的方法，因为本身就支持单进程调试模式的。
     
然后再通过 –来调试就更简单一些。

通过命令查看进程具体在做了些什么事情，根据里面的执行内容，分析和定位问题。

      进程
备注：执行这些命令，注意权限问题，很可能需要权限。
四到扩展升级实践记录
 数据类型的变化



的诞生始于结构的变化，不再需要指针的指针，绝大部分需要修改成。如果直接操作，那么也需要改成，_也要改成_，_ …需要改成_ …，一定要谨慎使用符号，因为几乎不要求使用，那么很多地方的也是要去掉的。
_，__，__这几个分配内存的宏已经被移除了。大多数情况下，应该修改为，而_宏也被移除了。
 结构源码 
 字段，仅占一个_长度，只有指针或或者 
  __ {
    _                            
                                   
    _  
    _      
    _       
    _      
    _    
    _   
    __     
                 
                 
    __ 
    _    
     {
        _ 
        _ 
    } 
} _

 __ {
    _                      
     {
        。。。
    }  扩充字段，主要是类型信息 
     {
        … …
    }  扩充字段，保存辅助信息 
}

整型

直接切换即可：
_
 定义 
 _ _
  
 _ _

字符串类型

版本中使用  的方式表示字符串，中做了封装，定义了_类型：
 __ {
    __ 
    _                           
    _            
                  
}
_和的转换：
_ 
  = 
_  = 

 从_获取 和 的方法如下 
 = _
 = _
  构造_的方法 
_   = __ 
扩展方法，解析参数时，使用字符串的地方，将‘’替换成‘’：
 例如 
`_` ``
 ____    == 
{
    _
}

自定义对象

源代码：
  _ 定义 
 __ {
    __ 
    _          
    __  
     __  
            
                  _
}
是一个可变长度的结构。因此在自定义对象的结构中，需要放在最后一项：
 例子 
 _ {
     
    _   放在后面
}
 使用偏移量的方式获取对象 
  _ _____  {
     _  _ 
}
 __ ______
 释放资源时 
 ____  _
{
    _  = ____
     
    {
         
         = 
    }
    ___
}

数组

中的表定义如下，给出了一些注释：
中的表结构 
  _ {  表中的一个条目 
                  删除元素类型标记为_ 
_                                
_                           
}         
  __     
 __ {
    __ 
     {
         {
            ___
                _    
                _    
                _    
                _    
        } 
        _ 
    } 
    _          
                 保存所有数组元素 
    _            当前用到了多少长度， 
    _            数组中实际保存的元素的个数一旦的值到达，就会尝试调整数组，让它更紧凑，具体方式就是抛弃类型为的条目 
    _            数组被分配的内存大小为的幂次方最小值为 
    _          
    _         
    __       
}
其中，在_中定义了一系列宏，用来操作数组，包括遍历、遍历、遍历等，下面是一个简单例子：
 数组举例 
 
____   __
 
{
     
    _ 
    _______   {
          
    }
}
 获取到后，可以通过下面的获取、、值 
__ 
__ 
__
版本中是通过__查找，然后将结果给到 变量，并且查询不到时需要自己分配内存，初始化一个，设置默认值。
 中的变化

参数中很多中都需要填入一个参数，表明一个变量是否需要复制一份，尤其是类的操作，中取消参数，对于相关操作，只要有参数，直接删掉即可。因为中定义了_结构，对字符串的操作，不再需要值，底层直接使用__初始化一个_即可，而在中是存放在中的，而的内存需要手动分配。

涉及的汇总如下：
__、__、___、___、__、__、___、___、____、____、___、___、___、___、___、___、__、__、_、_、_、_、_、_

__

中，变量是在堆上分配的，创建一个变量需要先声明一个指针，然后使用__进行分配空间。中，这个宏已经取消，变量在栈上分配，直接定义一个变量即可，不再需要__，使用到的地方，直接去掉就好。

___

修改参数名为
  
  ____ {
     
     
     
} ___
  ______  _
 ___         ___  _

  
 __ {
    __ 中对引用计数做了结构封装
                   
                   
                 
}
  ____ 
 ___  _ 
中，将___结构升级为_，在新版本中只需要修改一下参数名称即可。

二级指针宏，即__

中取消了所有的宏，大部分情况直接使用对应的宏即可。

____被取消

根据官方，可以定义如下宏，用来获取，实际情况看，这个宏用的还是比较频繁的：
  _ ___  {
     _   _ 
}
 }}}  
 __ ____

__、__

对所有需要字符串参数的函数，中的方式是传递两个参数  ，而中定义了_，因此只需要一个_变量即可。
返回值变成了_类型：
 例子 
_    
 = __ 
_ _ = __ 

参考资料：、  、扩展开发及内核应用、 中新的实现和性能改进、深入理解之、官方、手册、 使用资源包裹第三方扩展的实现及其源码解读

五平台升级的性能优化成果
现网服务是一个非常重要而又敏感的环境，轻则影响用户体验，重则产生现网事故。因此，我们月下旬完成编译和测试工作之后，就在其中一台机器进行了灰度上线，观察了几天后，然后逐步扩大灰度范围，在月初完成升级。
这个是我们压测一个查询多个活动计数器的压测结果，以及现网机器，在高峰相同流量场景下的负载数据：

就我们的业务压测和现网结果来看，和官方所说的性能提升一倍，基本一致。

 
平台拥有不少的机器，的升级和应用给我们带来了性能的提升，可以有效节省硬件资源成本。并且，通过的模式，我们也增强了在支持并发方面的能力。
六小结
我们升级研发项目组，在过去比较长的一个时间段里，经过持续地努力和推进，终于在年月下旬现网灰度，月初在集群中全量升级，为我们的活动运营平台带来性能上大幅度的提升。的革新，对于语言本身而言，具有非凡的意义和价值，这让我更加确信一点，会是一个越来越好的语言。同时，感谢社区的开发者们，为我们业务带来的性能提升。

文章来源公众号：小时光茶社 


相关推荐开发者资源云  安装配置服务器在红海时代来临的游戏行业，“全球化”已成为近年来的热点。 
游戏全球化运营，对节点分布、网络稳定、网络加速、安全防护等云端基础能力提出了很高要求。作为国内领先游戏云厂商，腾讯云的全球化布局一直走在快车道，更好地助力游戏快速实现全球化运营。 
本期腾讯云沙龙广州站，将和来宾聚焦探讨腾讯云在全球化方面的技术布局，我们还邀请到了游戏全球化先行者的代表分享实践与洞察。
演讲主题：海外发行实践分享 
嘉宾简介：
徐雨霏 商务总监多年海外发行经验，成功引入数款国内产品发行海外，如《最强猎人》《暗黑起源》，现担任业务部总负责人。
演讲概要： 海外发行道路上一直低调前行，为更多朋友的海外发行寻找更多的机会。本次演讲将从代表作《最强猎人》《暗黑起源》为例，分享如何在众多大厂大作的市场环境下赢得一席之地。
关于：系列沙龙由腾讯云主办，旨在为游戏开发者提供一个自由的交流分享平台。沙龙将围绕游戏行业趋势、研发技术、运维和推广等热点进行探讨。每期沙龙将邀请国内外游戏领域专家，分享游戏开发及运营过程中的思考和实践。
访问沙龙官网 ，了解最新沙龙资讯和更多往期回顾。年月日，由腾讯云联合社区主办的  深圳站成功落幕，现场的粉丝们对于容器技术的分享交流也是热情似火。

腾讯云容器服务团队高级工程师王天夫在沙龙上进行了以《腾讯云多的多维度监控实践》为主题的精彩演讲，现将现场演讲分享出来供大家交流。
也欢迎更多对感兴趣的朋友们继续加入交流。入交流群可加底部小助手腾小云，回复关键词“”拉您入群。
本次分享内容主要包括以下三部分：、腾讯云容器服务的顶层整体设计；、腾讯云容器服务集群化部署的整体方案；、腾讯云容器服务监控。作者：韩伟，个人公众号：韩大：， 以技术提升开发效率
为什么服务器端系统要对运维友好
  外网事故，一直以来都是互联网企业力图尽量避免的，也是服务器端程序员最重视的问题之一。然而，如果我们统计一下各种外网事故的原因，会发现一个结论：的外网事故原因，都是存在于运维领域的，只有左右的事故原因，是由于程序本身的导致。这里说的“运维领域的原因”，包括了由于配置错误、现网操作失误、网络或其他硬件环境变化、硬件故障等等。
在流行“运维”“开发”分离的时代，似乎这些都是运维的锅，但是这锅背了几十年，也没有什么本质上的进步。说明仅仅试图用“分清责任”这种纯管理手段，是解决不了这个技术问题的。
举个例子，当你需要重新部署一个有几百个进程，分为十几不同类型的服务的一个系统时候，你可能要小心翼翼的处理几十上百项配置以及操作命令。这些配置和命令既有大批相似的，也有一些是需要仔细甄别异同的。加上这些配置之中，还有很多互相的关联，你必须理解的非常清楚，加上这些配置和命令的执行顺序也是有严格要求的。部署这一切，就像在操作一个有几百个按钮的机器面板。
最要命的是，如果你搞错了其中任何一项，都可能让系统马上，或者在将来某个不可预料的时间里，造成“外网事故”。这导致了老板就会在半夜三点把你从被窝里扯到电脑前处理这个烂摊子。当然，我说的这个情况并不是每个项目都会发生，但是我们确实是在很多项目中，都不同程度的陷入过类似的陷阱。不知道我们是不是因为都被那复杂的所征服过，所以很多程序员都非常热爱配置文件。
“一切都要可配置！”不但成了我们的口号，还成了无数复杂配置项和诡异的工具命令。——但这些东西，在实际的业务运行中，却切切实实的成为了无数颗定时炸弹。

程序员都爱配置文件
自动化测试现在已经成为开发的标准流程之一。特别是敏捷开发方式兴起之后，最重要的实践之一就是自动化测试。我们知道，一般我们用来做测试的环境，往往和真实环境不一样。比如我们做功能测试的时候，运行被测试程序的内存和硬盘可能比真正的运行环境要小的多。如果我们的程序因为这些硬件或者其他的诸如地址之类的软件差异，都要配置一番才能运行，那么我们的每次测试，都有可能需要手工的去操作一下，这样的测试就不能说是“自动化”了。加上手工操作的错误，更是可能让测试结果严重错漏。
测试工作除了环境上的差异可能导致运维操作，本身测试也需要多套环境的，比如很多系统都有多个分支在同时开发，又或者有内部功能测试、外部邀请用户测试、公共测试等多个测试环境。假设我们的软件，每次部署都要手工进行一大堆的操作，那么面对多个环境，频繁的发布新版本来做测试，部署的工作肯定是非常繁重的，而这些繁重的工作本来是可以尽量的避免。
 美好的闭环往往毁于复杂的部署流程
 快速开发一直是现代软件企业追求的目标。由于需求、市场日新月异，软件产品和应用系统也被迫着每天在更新功能。说到服务器端软件，我们往往需要在开发的过程中，配合其他很多程序一起开发调试，最典型的就是和客户端软件交互。
 假设每个参与项目的程序员，都集中连接到一个开发服务器上进行调试，必定产生各种互相影响的事情。而且这种跨机的开发环境，往往也只有一些命令行界面，比不上图形界面的软件使用效率高。假设我们开发的程序，特别是服务器端软件，能直接在开发的工作机上运行和调试，那么除了能响应更快以外，还可以方便的在多个程序同时运行的时候进行调试，这对于常常因为“联调”而头疼的工程师来说，是一个非常有效的提升工作效率的措施。
但上面说的这些措施，都需要我们的服务器端程序，能很方便简单的部署到各种环境上。反过来说，有的服务器系统结构比较复杂，要启动很多进程，配对很多配置文件才能启动，那么大家一定会懒得部署很多套，而是都挤到一个环境上做开发。
分布式系统在运维友好方面的难点
防止资源泄漏。我们知道，服务器端程序需要长期运行，特别害怕资源系列，比如内存漏洞、文件句柄漏洞、网络连接相关漏洞等等。所以很多时候，我们愿意在服务器一启动的时候，就把所有需要的资源，都全部“占用”或“分配”好，然后不管后续来了多少个请求，做什么事情，都完全不需要“分配”，这样就杜绝了一切的“泄漏”。然而，这个方法也导致程序在运维上的复杂程度大大提高。
首先，我们难以明确的硬编码一个程序所运行的硬件资源，而是设计了诸如配置文件、命令行参数这些东西，来根据运行时的环境，来确定可能使用的硬件资源。比如我们会在配置文件中，设计一个“网络协议缓冲区大小”的配置项，根据服务器的内存大小来配置。但是，一个程序中的功能可能是很复杂的，要把所有用到的内存、文件等资源都弄成配置项，这个配置文件必定也同样巨复杂无比。
如果我们指望运维人员去理解这些配置文件，那还不如开发人员自己去做运维，因为开发人员有时候自己都没想清楚这些资源的合理配置应该是怎样——原因是太过于依赖这种“预先申请”的方式，而习惯于把这些难处理的问题，都延后来解决了。防止资源漏洞，固然是一个重要的问题，但是仅仅是简单化的把资源申请都变成配置文件，却同样带来另外一个灾难。
特别要命的是，这种配置文件灾难在多进程协作的系统中，会承几何倍数的增长。这种运维复杂度，在一个系统刚刚上线的时候，似乎都还可以接受，但是随着系统逐步变得更大、更复杂，运维工作的难度就好像温水煮青蛙一样，慢慢的变得完全不可收拾。有些系统随着年的运营，到后来居然发展到完全没有人能从零开始部署一套新环境的地步。
  打一成语
快速诊断故障。现在的商业应用系统，往往都不会是一个很简单的功能体，而是会包含了大量相关或者不相关的功能。而我们最害怕的问题，就是这些共同运行的功能，在同时处理成千上万的网络请求的时候，如果因为某一个部分功能代码的，导致整个系统不可用。所以我们往往更希望建立某种隔离体系，比如把不同功能的代码运行在不同的进程里。
这样利用操作系统的工具，就能很快的发现那些出问题的代码。但如果你真的要把一个系统的多个功能分开到不同的进程中运行，首先会碰到的就是进程间通讯的问题。这个问题是现代分布式系统的核心问题之一，无数的开源软件项目都在试图解决这个问题。但不管你是使用开源软件，还是自己写代码解决，这都会让系统的进程变多。特别是我们很喜欢按功能来划分代码和进程，那就是说在运维一个系统的时候，我们需要面对大量“不同种类”的进程。
而我们越是划分功能细致，进程的种类就越多，需要操作和运维的进程就复杂。在管理这些进程的时候，除了前面说到的一些性能参数需要配置，还有巨量的进程间关系需要配置。而这些进程间关系，还会随着业务的变更而变化，对于那些没有具体接触开发需求的运维人员来说，简直是噩梦。
也许有些程序员一开始是在通信企业工作，所以很习惯于按进程划分功能，按通信层次来组织系统，但是随着业务系统的日益复杂化，这种工作习惯带来的是大量的麻烦——每周都有可能需要往系统中加入新进程，或者调整某些进程的通信关系。不同的行业需要不同的技术方案，这才是理性的工程师的想法。
  小猫喜欢画地为牢，我们的代码也喜欢用进程边界作牢
负载均衡。现代的服务器端系统，基本上都是分布式系统。也就是由多个服务器、多个进程组合起来提供服务的系统。而为了让这个系统工作稳定，最常见的措施，就是防止过载。在多个进程中防止某一个过载，就需要负载均衡。
而防止所有同类的所有进程过载，则需要过载保护。分布式系统最常见的配置工作之一，就是要配置每类进程启动多少个，每个进程的过载保护阈值。然而，在一个上千个进程，几百个服务器的系统中，要准确无误的填对这些配置，实际上是很难的。特别是这些服务器并不都如提供商说的那样是性能一致的。
假如你需要在集群中加入一些服务器，或者修改搬迁某些服务器上的服务，那么更是危险重重，因为稍有不慎，就可能让原来能工作的系统出现故障。然而，和业务需求在不停变化一样，运维环境也是在不停变化，比如搬迁就是最常见的“折腾”。
我们大可以编写很多运维管理的工具，来试图“自动化”这些工作，但是，业务需求也是在不停“折腾”的，而在一些“开发、运维分离”的团队中，开发人员可不太关心运维工具的开发，因为他们已经被市场和业务人员逼得连续加班，只想功能尽快上线拉倒了。由于需要负载均衡，而产生的大量服务器端软件的与我内工作量，由于和集群中巨大服务器的数量相关，所以是最直接体现运维和开发服务器端系统困难的地方。
如何开发运维友好的服务器端系统
为了让服务器端系统能够良好的运行，我们显然应该采取一些开发措施，而不单纯的依靠所谓“运维”甚至更不靠谱的“管理”手段来降低失误和故障。
第一个可供参考的思路，就是“建立具备性能弹性的系统”。所以性能弹性，最简单的是指，我们的服务器进程，可以在各种不同的性能环境下运行，而无需复杂的配置文件或运维操作。这里除了最简单的自己检测机器的地址、内存大小等自我配置的功能外，更重要的是我们对于资源管理的思路上的改进。由于一个系统要处理的问题可能比较复杂，需要使用到的资源也会很复杂，比如我们需要用内存来缓冲没收完的网络包，还需要用内存来存放用户的会话数据等等。
如果我们只是把这样一块块内存都提出来配置，就会有一大堆各种内存容量的配置。然而，我们完全可以通过建立一个业务抽象，来简化这种资源模型。比如对于一个在线交互的系统，我们可以把资源管理的单位定义为“会话”——每个会话代表了一次“并发”的服务，每个会话要使用多少资源，是我们可以设计的，然后我们注意管理总的“会话”数量，防止资源泄漏。
当然这种“会话”在不同的业务系统中，其概念和功能可能都不一样，幸好我们还可以用面向对象的思想，来用类和对象封装这些会话及其相关数据。这样我们在性能规划的时候，就不用在程序到处翻找使用“资源”的地方机器配置，而仅仅抓住一个关键变量就可以了。更进一步的是，我们可以对“会话”这类关键指标，采用一种“池”的管理策略，把对这种对象的使用，变成需要“申请归还”的机制，这样我们放弃在一开始就“分配”大量资源的做法，而是根据实际需要来分配资源，而由于“池”的限制，在资源达到上限的时候，拒绝进一步的服务请求，在防止资源漏洞的同时，解决一些过载保护的问题。
而且，在某些环境下，我们还可以让这个“资源池”变得更智能和弹性，比如我们可以在请求压力接近阈值上限的时候，不是简单的拒绝服务，而是开始启动一些扩容或者报警的工作。又或者我们可以定期的查询被“申请”的资源的处理情况，如果发现占用时间过久，就可以清理掉这些服务请求，这样就有了一定的自我恢复服务的弹性。
如果建立了具备“资源弹性”的系统能力，这样的进程只需要进行很少的配置就能自我管理和运行。从根本上减轻了运维工作的复杂程度，也降低了环境变化对系统的影响程度。同时抽象良好的功能代码，在代码维护和开发上也非常有好处，可谓一举多得。
 子弹封装了火药、弹头、底火，所以告别了通马桶式发射
第二个思路，是“在功能容器下运行”。在某个项目实践中，我见过某一个系统，他的每个进程，都包含了整个系统的全部功能代码。通过启动时的命令行参数，可以指定此进程需要提供什么功能。这个系统在运维的便利性上，就远远比需要配置、部署各种不同功能发布包的系统来的简单。而且这个服务器系统，还可以以单进程全功能的形态，用于开发和自动化测试，在开发效率上有着明显的优势。
而在技术的使用中，我们往往也是把不同的部署到不同的容器如等中运行，而不需要完整的配置各种不同的容器。现在还有一些系统，把主要的业务功能，都用类似这类脚本语言来编写，系统中的进程部署，只要完成了脚本容器引擎后，基本上就是拷贝脚本文件而已。在容器技术的支持下，我们除了可以简化部署的工作，还可以获得一些“热更新”的好处。
而基于硬件、访问量的运维工作，运维人员可以集中注意力管理好“容器”即可。比如，就是一个高度自动化的 容器，使用者甚至完全不需要安装部署任何软件，直接上传一个脚本或者类文件，就可以开始提供服务。在容器下运行服务器系统，还可以利用容器规定的一些通讯规范，做一些自动化运维的事情，比如自动扩容、缩容、容灾——容器可以自我发现集群的运行状态，加入新的运行资源，剔除有故障比如访问超时的运行资源。这也是所谓概念最常见的实现方式。
从另外一个角度说，如果有了容器支持，我们在配置服务器进程的时候，是可以简化对整个集群中各种关系的配置的，因为只要告诉容器，怎样加入一个目标的集群，其他的事情都可以让容器去和其他集群成员协商配置。容器除了提出了统一的功能代码开发环境约束，还规范了运维工作。这对于需要频繁变化服务内容，以及不断改变运行环境的项目来说，是非常有价值的。
在开发领域，容器的概念已经是深入人心了，所以这一类的系统应用比较广泛，而运维工作也能比较专业顺利的开展，但是在诸如网络游戏这种没有“行业标准”的领域，关于功能容器的概念还是没有被很多人接受，很多人还是在质疑为什么要给自己套上这个“枷锁”，却不知道自由从来都是在约束下行走的。
  进程需要容器，功能也同样需要容器，有容器比没容器好！
最后，我想说说各种运维工具，不管是，还是各种非通用的运维部署系统，如果仅仅以操作系统提供的能力，就想把所有的系统都统一管理起来，是非常困难的。而如果我们在开发的时候，就充分考虑到系统的运维需求，那么可能只进行了一些简单的约束，都能让运维工作有巨大的改进。我想这也是所谓流行起来的原因吧。指针
什么是指针？
指针其实是内存单元地址
什么是指针变量？
指针变量是用于存储内存单元地址的变量
指针变量存储的实质
顾名思义，指针变量存储的是内存单元的值，即存储的值其实指向的一个特定类型内存区域的起始地址。
如下例子，整型变量的值为，其内存单元地址为，指针变量存储的值是变量的内存单元。
指针变量指向了内存地址起始为，长度为个字节的内存单元。也可以对这个个单元进行操作。
  = 
  = 

指针变量的运算
语言中，我们可以像普通整型数据一样，对指针变量进行运算。
指针变量的转换
普通类型的指针变量都可以直接赋值 空类型指针，但空类型指针需要强转才可以转成普通类型指针。
 指针是一种特殊的指针，表示“无类型的指针”，因为其没有指定类型，所有它可以指向任何类型的数据，也就是说任何类型的指针可以直接复制给指针。
  
  

 = 
但是指针赋值给其他类型的指针时，必须强制转换
 
  

 =  
这是因为指定了类型的指针变量指向了内存的一块区域，但空类型指针无法确定指向内存区域的大小。
需要注意的是，不同类型指针变量相互转换时，需避免访问非法的内存区域，导致程序异常退出。如下例子，指向了一段长度为字节的变量的内存区域，当其强制转换成指针时，则超出了编译器分配的内存区域，程序会异常退出。
       = 
       = 
       =  
     = 
指针变量的算术运算
指针变量可以使用算术运算符实现自增减，如下例
      = 
       = 
     =  \ 

       =  
       =  
    
    
     =  \ 
     =  \ 
假设地址为，则上面例子的输出为
 = 
 = 
 = 
即使指针变量的算术运算为增减数据类型的大小。上例子中的值为，强转为 后自增，结果为，强转为 后自增１为，。

同理因为空指针类型无法得知其指向区域的长度， 指针便无法进行增减操作。
数组
语言中，数组与指针是一种非常暧昧的关系，因数组和指针经常可以相互的转换，所以经常会将其两者混淆。真正的事实是，两者拥有不同的存储结构，但引指针的灵活性，两者可以相互的引用、转换。
数组的存储结构
与指针的存储结构相比，数组在内存中占据的是连续的字节单元。即指针存储的长度根据计算机不同，是一个固定的大小 位个字节、位个字节，数组存储的是一块连续的内存区域。
       =  
      = {  }
      \    
      \    

为什么指针可以访问数组的元素？
那为什么指针可以访问数组中元素？
这是因为数组标识符表示的是该数组的第一个元素的地址，当指针指向数组标识符时，便可以通过指针访问数组中的各个元素。
      = {}
       = 

      \
        \ 
        \  
函数调用时数组作为参数时为地址传递
语言的标准中规定：所有的数组在作为参数传递时，都转换成指向数组起始地址的指针，其他参数均采用值传递。
采用地址传递好处是形参不存在存储空间，编译系统不为形参分配内存，数组名或者指针便是一组连续空间的首地址。
例如下面例子输出的都为。
  
{
        
}

  
{
        
}
 
{
      = 
         
         
}
数组与指针的区别
数组和指针其实并不是一个相同概念，虽然在日常的使用中，经常可以使用指针代替数组，用于遍历数组的元素，例如
 =
  = 
  = 
 \
再来一个例子，可以证明数组并不是指针
 文件 
  = {}
 文件  
 
 
{
       
     
}
执行上面代码会提示“” 重定义；不同的间接寻址类型在使用  时，编译器认为是一个在外部声明的整型指针变量，但中，是一个长度为的整型数组，在位系统系统下， 长度为字节，而 长度为 = 字节。
再看一个例子
       = 
      = 
      == 
    {
        
    }
     {
        
    }
程序执行后打印。这是因为指向的是存储于数据段静态变量，则指向编译器分配的内存空间。两者的值并不一样。
对于数组而言，编译器已经为数组分配了一定的空间以及对应的地址，通过数组地址的偏移，可以访问该数组的元素。而指针，编译器为其分配了空间，用于存储地址值。而对于存放在其中的值，只有在程序运行时才能知道。
使用指针和数组的注意点与建议
 使用指针前必须初始化，否则会指向错误的内存区域，导致程序异常。
使用指针作为函数调用失败的返回值。类似函数，当分配内存失败时返回，用以表示为一种异常情况。
在不知内存区域具体类型情况下，避免对 指针进行算术操作
例如，下例子对任何的操作都会导致程序出错
 


 不同类型指针转换时，注意不超出编译器分配的内存区域。
如下例子，使用了超出了编译器分配的内存，会导致程序异常退出
  = 
 　 = 
  =  
 = 
避免指针和整型数据的直接转换。
总结
指针变量是变量，存储内存地址的变量。数组存储的是一段连续的内存区域数组标识符存储了，一段内存区域的起始地址数组作为参数传递时是地址传递，其他类型则为值传递前言
先看一个视频，这个视频并不是去演示如何使用微信，而是演示基于开发的微信小程序。
点击观看视频  【开发的微信小程序 】
中包含的功能有：

仿微信界面

联系人列表

私聊与自动回复

聊天记录本地存储与清除


源代码地址：
是什么？可以查看我的另外一篇文章：《打造小程序组件化开发框架》
下面就讲讲是如何一步一步基于实现这个仿微信的。
一、需求分析
首先要确定好自已在中想要实现的功能，微信有四个：微信聊天，通讯录，发现，我。右上角的搜索，添加好友功能，以及发现里的朋友圈和各项菜单功能，这里主要想实现的就是聊天，还有通讯录好友功能。因为考虑到小程序真机体验时只允许请求安全域名，所以数据不打算使用后端接口返回，而是采用数据模拟后端接口返回。聊天记录储存于小程序提供的中。这样就能完整的模拟聊天功能，而且下载下来的可以直接在真机上体验。
同时评估一些技术细节：
涉及的原生

登录相关 

获取用户信息 

相关 ，，


技术方案

样式部分使用，现阶段支持，，本使用

代码部分使用新特性

数据接口使用数据模拟接口返回


二、页面组件划分
按微信界面展示大致划分为两个页面，首页，聊天页，以及若干组件，如下图：

首页中包含一个组件和四个分别所对应的组件，，，。而且各自还包含一些子组件，如组件中包含字母列表组件，和组件中分别包含一些菜单列表组件。其中组件达到了很好的复用效果。
聊天页中包含一个聊天面板组件和输入框组件。
根据划分的组件，大致可以得到开发的目录结构：

    
          联系人
          聊天面板 组件
          联系人 组件
          发现 组件
          聊天页输入框组件
          菜单列表组件
          我 组件
           组件
           组件
    
          聊天页
          首页
      小程序入口
三、切图与重构
直接用手机截屏然后放到中处理。小程序做不同机型的适配很方便，提供了一个的单位，官方说明如下：
  可以根据屏幕宽度进行自适应。规定屏幕宽为。如在  上，屏幕宽度为，共有个物理像素，则 =  = 物理像素， =  = 物理像素。
我的手机截图尺寸是  × ， 为了方便计算，直接将截图按比例调整为  × 。那么此时的单位换算就是 = ，也就是说一个图片在中是  × ，那么就直接写  。
整理出各图标大小以及各元素之间的宽高间距等，方便在中使用。如下图：

按照第二步划分的页面组件，对组件进行基本的填充。然后页面内容就十分简单了。
：
 =
 _ {
     
}


     =
         =_ _
             =
        
         =_ _
             =
        
         =_ _
             =
        
         =_ _
             =
        
         =
    


 =
 {
     
     
}


     =
          =
          =
    

接着完成基本的重构工作，如下图：

四、数据设计
通过需求分析得到只需要两份基础数据：

联系人数据

初始聊天记录数据


其对应的数据表结构如下：

因此我们可以使用构建这两份数据表作为原始数据，目录结构设计大致如下：

       数据目录
           用户头像目录
               头像
           联系人数据
           聊天记录数据
 模拟联系人数据返回，代码如下：
 所有联系人数据
  = 
    {    }
    {   韩梅梅}

 =   =   

  =  = {
 {
         
         
         `{}`
    }
}
  
模拟初始聊天记录数据返回，代码如下 ：
  
    {                 }
    {             }

五、接口设计
因为使用数据的关系，我们可以同步吐出接口数据，但这里希望能更接近于访问的异步效果，所以所有接口均返回处理的对象。
整理出所需功能的所有数据请求如下：

拉取聊天列表页的聊天列表用户头像，用户名称，最后一条聊天信息

拉取聊天页面的聊天记录 用户头像，自己头像，聊天记录

发送聊天信息

拉取我下的个人头像以及用户昵称等信息


因为涉及到的数据接口并不多，所以单独放在模块下。 
代码结构大致如下：
 _  
 _  

  {

     拉取用户信息
      {}

     拉取与某个用户的聊天历史记录
      {}

     拉取首页聊天列表
      {}

     发送聊天信息
        =  {}
}
六、逻辑代码开发
逻辑代码部分主要包括三部分：

调用数据接口，返回数据，渲染视图

组件内事件交互

组件之间相互通信


在组件中需要拉取聊天列表信息并且渲染，代码如下：

     =
         ={{}} = =
             = = ={{}}
                 =
                     = ={{}}
                
                 =
                     ={{}}
                     ={{}}
                
            
        
    


   
   

      {

         = {
             
        }

         = {
               {
                { =  }
            }
        }
           {
             =  
            
        }
    }

组件中只有一个数据源，通过自定义方法调用模块获取聊天列表信息进行渲染，因为是在自定义的异步方法中进行数据绑定，所以需要执行让视图渲染。 
同时，组件响应页面的事件，选中聊天之后跳转至页面。
在页面进行聊天之后，返回到页面时，需要页面再次调用接口数据，重新渲染聊天列表页，这就需要在页面的方法中去让组件重新调用方法。这里可以选用  提供的方法或者方法，代码如下：
 
 {
     
}
这样就完成了组件的所有功能，进入页面渲染列表，点击消息进入聊天页面。

在页面中加入状态来标记当前选中。并提供切换事件。
：

     =
         =_ _ ={{ = }}
             =
        
         =_ _ ={{ = }}
             =
        
         =_ _ ={{ = }}
             =
        
         =_ _ ={{ = }}
             =
        
         =
    



    
      {
         = 
        
    }

然后在组件中的每个中添加= ={{}}事件。

   

          {
         = {
             
        }
         = {
               {
                 = 
                
            }
        }
    }

在组件中，直接通过去调用父组件的方法，来达到实现切换效果：

至此已完成大致雏形，更多代码还请参考提供源代码。
结束语
让用户能以组件化思维开发小程序，加上一些新特性的引入让开发与维护变得更简单，但同时缺点又在于引入框架以及额外的，增加项目代码体积压缩后，在仅限代码体积的小程序中，代码容量时时刻刻又显得有些捉肘见襟了。希望小程序能早日能放宽限制。内容简介：
运维分析   是近年兴起，其把大数据技术应用于分析运维产生的大量数据，数据来源主要有日志、网络流量、植入代码、布点模拟监控等。过去使用数据库处理日志无法支持大数据量，后来出现了使用等开发框架来处理日志，及最新的使用实时搜索分析引擎来对日志进行实时处理。现如今使用等开发框架来处理日志已经在各大公司被广泛的运用，本次演讲嘉宾将结合具体实践为大家带来如何使用实时搜索分析引擎来对日志进行实时处理。
本文为日志易创始人兼陈军，在年全球运维大会深圳站的演讲实录，包括介绍，比较各种日志处理技术等话题，重点讲解实时日志搜索分析引擎，比较索引阶段对日志做结构化  及检索阶段对日志做结构化  ，在搜索框里编写搜索处理语言   以灵活地支持各种业务分析，及在金融的应用案例。
陈军：
谢谢那么多人来参加这个大会，感谢这个机会。刚才前面有一位朋友问到日志分析的情况，日志易就是专门做日志分析的，我也专门讲一下日志。实际上日志只是一个方面，我今天要讲的是一个更大的话题，《运维分析与海量日志搜索》。

运维分析
 
“运维分析”是这两年新提出来的概念，过去那么多年我们一直在讲的运维，实际上讲的是运维管理，即。
而是这两年随着大数据技术的产生而产生的，它就是把大数据的技术用在运维产生的数据上面。
因为运维本身就会产生大量的数据，用大数据的技术去处理运维产生的数据，来提高运维的效率。它的用途是在可用性监控、应用性能监控、故障根源分析、安全审计这些方面。
据估计，到年的大企业会积极使用，在年的时候这个数字只有。这个报告还是基于欧美的市场，欧美方面的投入更大、更加精细化，在他们那里才做到明年有的大企业积极用。
很多公司还停留在运维管理的阶段，是一个新的阶段，要去做分析，分析之后来提升管理水平。
的四种数据来源
是把大数据的技术用在运维产生的数据上面，所以数据的来源就很重要，它分析些什么数据？

    机器数据 其实主要就是日志，服务器、网络设备产生的数据；    通信数据 实际上就是网络抓包，这些流量的数据，把它抓包解包之后会产生大量的数据；    代理数据 在这些字节码里面插入你的监控代码，去统计函数调用的情况、堆栈使用的情况，在代码这一级来进行分析，插入代码也可以获得一些程序执行的数据；    探针数据 在全国各地布点来模拟用户的请求，来发起的、 这种请求，对系统进行检测，看延时的情况、响应的情况。
所以，就是围绕着这四种数据来源，使用大数据的技术来做分析。

美国一家公司做的用户调查，这四种数据来源使用占比，大家可以看到：日志占，流量抓包占，代理数据占，拟检测占。这是美国一家公司做的调查，这个数据背后其实也是有理由可以解释的。
四种数据来源的比较

、 机器数据：
日志无处不在，网络、设备、服务器、应用程序都会产生日志，比较全。但是它也有它的情况，不同的应用可能吐出来的日志包含的信息不一样，有的应用可能吐出更多的日志，包含的信息比较面；有的日志可能吐出来的日志非常少，只有出错的时候吐出日志，正常情况下都不吐出日志。所以，可能你能够获得的信息不够，日志内容的完整性和可用性不太一样。
、 通信数据
这个信息也非常全面，只要有通信，你就可以抓包。它的问题是什么呢？    有一些事件未必触发了网络流量，如果没有触发网络流量，你就抓不了包。另外，有些包可能是加密的，你抓了之后解不了密，不知道里面的内容，或者里面很多应用层解析的规则你不清楚，没有办法解析，不知道它包含的意义。它用的都是二进制的，你这个解包，每一种应用你都需要专门自己开发解包的规则，去把它给解出来。
、代理数据：
就是在字节码里嵌入你的统计分析代码来进行监控，它是一个代码级的监控分析，它是非常精细化的，精细到代码这一级，哪一个指令被调用了多少次，在这一级做统计分析。但是它有它的问题，它是具有侵入性的。当你做这种分析的时候，你已经改变了这个程序，你在原有的生产线上植入了你的代码，你植入了代码：如果稳定性有问题，可能导致进程崩溃。还有安全的问题，你植入的代码会不会把敏感的信息拿走？
哪怕解决了稳定性和安全性的问题，植入的代码每一次又会被执行，可能也会造成性能的影响。这就有点像量子力学的“测不准”原理，你观测这个量子的时候，你的观测行为就改变了它，你观测得到的东西实际上不是最真实的，并不是它原来执行的情况。
、探针数据
模拟用户请求，现在市面上也有一些产品。他们在全国可能有几百个节点，它布节点，不断地对你的后台服务器发起请求，来监测全国各地的用户访问你的服务的情况，包括网络的延时。它是一种模拟监控，而且是端到端的监控，好处是可以模拟从客户端一直到服务器请求到响应等来回的种类的延时。
但是它就不是真实的用户度量，现在讲监控监测都讲真实的用户度量。对于服务商来讲，他关心的是真实的用户感受到的延时，而不是一个模拟的请求。当然，模拟的请求发现慢了，可能是网络出问题了，立即要采取行动。

一些小的应用，因为他们没有办法在全国布点，日活量不够，那可能会用这种方式。
像大的应用，不管是微信，淘宝，这种每天的活跃用户都是过亿的，全国到县区这一级都有大量的用户。

其实他们是不太需要用这种探针数据去模拟用户请求的，他们直接统计真实的用户请求就知道网络状况，而且他们要做这个事情可以直接来做，不需要用第三方的应用。我记得年汶川地震的时候，腾讯的后台马上就看到汶川地区的用户下线了。所以，这种大的应用直接就可以知道网络的状况。可以看到，这四种数据来源中，具有侵入性的是代理数据，日志和网络流量都是旁路的，网络也是通过镜像流量旁路来抓包的。
日志数据、通信数据、探针数据这三类对应用本身是没有产生直接影响的，但是代理数据是会对应用直接产生影响。所以，这也说明了为什么代理数据的使用百分比是比较低的，而日志和网络抓包是非常高的，也就是了这个理。
日志：时间序列机器数据

首先，它是从服务器、网络设备和应用软件这些机器上产生的，甚至现在智能设备越来越多了，传感器等这些都会产生日志。它还有一个很特别的地方是时间序列，为什么叫时间序列？日志一个很重要的东西是带时间戳，基本上我们很少见到没带时间戳的日志。我们是一个第三方的独立厂商，是卖工具给各种类型用户的，所以各种各样很奇葩的问题都会遇到，比如说：

有的客户日志真的没有带时间戳的，带多个时间戳的也有一条日志里带了好多时间戳。
还有时间戳的格式有近百种，标准的时间戳日志是放在比较靠前的，有的是时间戳放在靠后，都有，它的位置也不固定。

日志包含的信息：

日志包含了的系统信息，比如：服务器的信息，网络设备的信息，操作系统的信息，应用软件的信息；
日志也包括用户的信息，用户的行为信息；
也可能包括业务的信息。

所以，日志反映了系统的事实数据。这家公司是硅谷很有名的做职业社交的公司，它在大数据方面是走得比较前的。他们的工程师写了一篇文章叫《深度解析大数据平台》，有中译本，在上，大家可以搜索一下。非常长，十几页，它的中文翻译跟原来的英文名称是不太一样的，你看中文的名称好象跟日志没啥关系。但是你要看它原文的名称，意思是“每一个软件工程师需要知道的实时数据的统一的抽象”。
日志是一个什么东西？
是每一个软件工程师必须知道的实时的、数据的一种统一的一种抽象，是把日志做到极致了，里面很多不同业务系统之间的对接都通过日志。现在是用得最广泛的消息系统。这个消息系统是在十多年前发明的，十多年前上线，就是用来处理日志、传输日志的，把日志在不同的系统之间流转。所以，有兴趣的同学可以看一下这个文章。
越来越多的公司也意识到日志需要统一来管。我之前工作过不同的公司，公司一大了之后，内部有好多部门，不同的业务，每一个业务部门统计分析自己的业务数据，然后报给老板。这些报上来的数据可能都互相打架，这边讲得非常好，那边看出来好象不太那么好，各个部门有自己的动机和利益，统计出来的东西不完全客观。所以，有的公司老板就意识到这个问题了。
日志集中管理，不同业务部门的日志全部交给一个部门来负责，他们会成立大数据部来统一处理日志，把不同业务系统的日志对照着来看，就会更加协调，更加统一，数据更加对得上号。这个大数据部门就像国家统计局这样的角色，各省说它的是多少，还得看它的用电量。从其他角度来看，日志就是非常重要的角度来看业务的情况，包括日活是多少，每天新增的用户是多少，这些全部在日志中可以看出来。
一条  日志

大家对日志比较熟悉，日志也是一个包含信息量非常丰富的日志。首先，它是一个文本数据，它带来了时间戳、主机名、产生这条日志的、字段。
我们把每一个字段抽出来：
•    地址叫  •    时间戳叫•    ，我们给它这个字段名称叫•    叫•    这个的版本，•    这个状态码是•    是字节•    从哪里过来访问的•      也比较重要，客户端那边是什么操作系统、什么浏览器•    是本台服务器响应的时间•    是后面应用服务其的响应时间。
所以，从这一条日志中可以分析出来的东西就非常多，可以做业务分析，也可以做应用性能的监控。你的响应时间是多少就可以监控，是不是网站慢了，是不是堵了，甚至从这里可以看出安全审计，你是不是被安全攻击了。所以，日志包含的信息是非常丰富的。
日志的应用场景
•    运维监控：可用性监控、应用性能监控•    安全审计：安全信息事件管理、合规审计、发现高级持续威胁•    用户及业务统计分析

谷歌的安全做到没有内网了，它认为内网是不安全的，内网和外网是一样的，内网得做很多防护。其实这种技术就是认为没有内网，内网是不安全的，所以才需要。如果内网是安全的，我在外面放道防火墙就足够了，就像你家有个大铁门，但是小偷爬墙进来，爬窗进来，甚至挖个地洞进来，甚至现在还有无人机了，从窗户飞进来。所以，你必须得全方位地监控，全方位地监控流量和日志，做最重要的就是这两个数据来源。
现在及过去的做法
过去

、很多小公司没有集中管理日志，扔在那里，觉得日志是个负担，出现问题才登录到这台服务器，用一些脚本命令，或者写一些简单的脚本程序去查一下日志，大部分公司还是停留在这样的阶段。
、服务器的硬盘满了，首先第一件事就是去删掉垃圾。日志是有时间效应的，太久之前的日志是没有什么用的，特别是对运维工程师来讲，关心的可能就是今天的日志或者昨天的日志，出现问题了从日志里看是什么问题。对安全工程师来讲，这个日志需要的时间就要长了，有些渗透攻击可能是几个月、一年之前发生的，得去查。黑客如果入侵了系统，聪明一点的黑客第一件事可能就是删除日志，把自己入侵的痕迹抹除掉，因为他的登录行为都在日志中反映出来。
、日志在过去只做事后的追查，没有实时的监控分析。出现错误不能预先知道，都是已经知道错了，然后到日志去找原因，日志没有作为一种监控的手段，只是用来作为追溯根源的手段而已。
、一些公司开始意识到日志的重要性了，开始把日志管起来，但是管的方法不对，用数据库来管日志。
其实市面上也有一些所谓的日志管理分析产品都是基于数据库的，基于数据库有什么问题呢？首先，这些日志越来越多，可能海量的日志每天上。
我们现在日志易在生产线上跑，在乐视跑每天新增日志量是。
这样一种日志的量，你用数据库是根本没有办法处理的，而且数据库是用来处理结构化数据的，非结构化数据是没有办法处理的。
所以，我看过一些用数据库处理日志的产品，数据库有所谓的表格式，但是这个表就三列：    地址，产生日志的主机名、时间戳，日志文本信息。所以，他没有对日志做任何的字段抽取，又不支持全文检索，有时候搜一条日志得把整条日志的信息写全了才能搜出来，否则搜不出来所以，数据库处理日志是一种非常落后、过时的方法。
近年

随着大数据技术的出现，就出现了像这样的框架了，大部分互联网公司目前都是用处理日志的。但是处理日志又有什么问题呢？是批处理的，不够实时。用处理日志通常是晚上处理当天的日志，第二天早上十点钟或者九点钟上班可以看到前一天的日志统计分析的情况，或者有时候要查一些东西也得跑个几小时才能看到日志的情况，而且查询也慢。
我年到年在美国总部的时候是做网页抓取爬虫。当时是每天台服务器的一个集群，每天爬一百多个网站。全世界的网站都爬下来了，但是不是说全部，一部分有的更新慢，有的网站几天才访问一次，有的是每天要去访问。爬这些不同的网站，出现错误的信息就千差万别、千奇百怪，都得看日志。出现了新的错误或者新加了一个功能的时候，原来的程序是处理不了的。当时我在，经常每天早上上班的第一件事是先看一下日志有一些错误信息是无法确认的，不能归类的不能归类的那部分我马上写一个小的程序，可能也就几十行写完之后去跑，跑下来可能几十分钟甚至一两个小时，可能到下午才能出现结果。
所以，的东西是给开发人员用的，不是给运维人员用的，它还得写程序，而且它是做离线挖掘，没有办法做在线分析。所以，对于运维工程师来说，你要让他用，顶多用来查一下。当然，每次运维工程师可能都得求助于开发工程师再改一下的程序来处理。
后来，为了解决实时性的问题，又出现了、这些性能更好的流式处理，但是不管是、、，它都是一个开发框架，不是一个拿来就可以用的产品。另外可能又有一些工程师用，的方案也很多，但是不支持全文检索，它不是一个搜索引擎，你只能是检索它对应的值是什么，并不能够直接搜一个日志的信息。
现在

现在我们需要一种新的技术对日志进行实时的搜索分析，就是所谓的日志的实时搜索分析引擎，它有什么特点：

快：日志从产生到搜索、分析出结果，只有几秒钟的延时，我马上要知道信息。日志里出现了一个错误的信息，不会像出来一个的状态码，意味着后台的应用服务器出错了，运维工程师是最担心的，出了的状态码马上进行告警，以前可能是用脚本写一些工具来做告警。但是你用日志实时搜索分析马上可以告诉你这个出现了多少次。
大：每天要能够处理级的日志量。
灵活：它是工程师的搜索引擎，是所谓的  ，它可以搜索分析任何的日志、日志里任何的字段。
    ：大而快的数据，不仅仅是一个大数据，是一个事实大数据。

日志搜索引擎
日志管理系统的进化

最早的用数据库来做日志，到用或者，到就是实时搜索引擎，我们现在就进入到日志的阶段。
日志易亮点


日志易就是一个可编程的日志实时搜索分析平台。

    搜索处理语言有一个搜索框，光有一个搜索框让你搜东西太基本了，我们是运维工程师，我们具备一定的脚本编程能力，它的可编程在哪里？日志易可以在搜索框里编写脚本语言。我们实现了脚本语言的搜索处理语言，它包括管道服务。你有多个命令，用管道服务把这些命令串起来，跟你在脚本里面命令行写脚本一样，有很多小的命令执行单元操作，再用管道服务把这些单元操作给串起来。所以，写这种的脚本就可以完成这种复杂的查询付息。这样，这个产品就变得非常灵活强大了，用户的业务是千差万别、千变万化的，我们不需要把业务定制到产品里，而是提供基础的平台，让用户直接在搜索框里去写脚本语言来做这种定制化，就可以适应不同的应用场景。任何的应用场景都可以在搜索框里写这种脚本程序，这种脚本程序可能是几十行，甚至是上百行的脚本程序，来进行复杂的分析处理。

日志易可以接入多种的数据来源可以是日志文件可以是数据库里的甚至我们给券商做的恒生电子交易系统，它产生的日志是二进制格式的，我们调用了恒生电子交易系统提供的  来把它解码成文本格式。
我们提供企业部署版，也提供版，版是每天上传的字节处理免费，欢迎大家试用，在我们的网站上有。

日志易功能


搜索。
告警。基于搜索结果，某个字段出现了多少次，可以去告警；
统计。进行统计分析，可以进行事务关联，不同系统产生的日志可以关联起来。
配置解析规则，识别任何日志。

刚才前面的演讲，有一位同学问到日志多种多样，要不要对日志归一化、统一日志格式？当然，如果你能够说服开发人员去改系统去统一日志格式是最好的，但是现实的现有的系统没有人愿意去改，就没有办法去统一日志的规格。日志易强大的地方是可以让用户在界面上配置解析规则，来抽取里面的字段，把日志从非结构化数据转成结构化数据，就可以对每个字段进行统计分析，非常强大灵活。任何格式的日志我们都可以把它从非结构化数据转成结构化数据；
这里讲的是日志进入日志易系统时就抽取字段做结构化，是所谓的  ，好处是日志在入库前做结构化预处理，检索速度快，不好的地方是不够灵活，用户可能在检索日志的时候，才确认需要抽取什么字段。为了适应这种场景，日志易也实现了  ，支持检索阶段使用的命令，抽取用户想要的字段，非常灵活。日志易同时支持   及   ，由用户根据使用场景决定使用哪种方式，非常灵活、强大。

安全攻击自动识别的功能；
开放，可以让用户在上面做二次开发，对接第三方系统；
高性能、可扩展分布式系统。现在在乐视那里跑到每天，每秒钟峰值达到万条的处理量。

因内容文字限定，本文未完结，剩余内容请看本账号文章《日志易：运维分析及海量日志搜索的实践之路下》
日志易提供部署版产品，版产品在腾讯云的体验入口：点我
日志易简介：
日志易专注日志分析领域，产品做得像搜索引擎一样强大、灵活、易用。目前，日志易产品已成功应用于金融、能源、运营商及互联网等诸多行业，其中金融客户包括中国银行、新疆农信、鹏华基金及第三方支付公司等；能源行业客户已囊括国家电网、南方电网、中石油、中石化等国内知名企业；移动、电信等国内主流运营商以及小米、乐视、网宿科技等诸多明星互联网企业均已牵手日志易——目前日志易大客户已达百余家。
日志易对运维日志及业务日志进行实时采集、搜索、分析及可视化等，用于运维监控、安全审计、业务数据分析，最终发掘出数据价值。作者 | 杨海春编辑 | 京露

杨海春曾在从兴技术有限公司担任主要设计开发岗，熟悉移动计费系统整体系统架构。目前就职于腾讯计算机系统有限公司，担任工程师职位，熟悉日志计费系统，离线计算等场景。

软件系统跑在机器上，处理能力受硬件制约，所以，单机处理能力会有上限。评估机器处理能力的上限，检查程序的瓶颈在哪，有助于程序性能分析。
主要的几大硬件：、内存、网络、磁盘。本文主要结合本人经验介绍这几大硬件的性能评估工具。
．性能评估
   工具
使用举例：
  
第一个参数：采样频率
第二个参数：采样次数

结果参数：

运行和等待时间片的进程数
等待资源的进程数。如等待网络
如果值长期大于的个数 则遇到瓶颈

用户进程消耗时间百分比
 ：内核进程消耗的时间百分比
如上图，跑了几个耗的程序，发现长期接近，已经跑满了。这个时候，可能需要考虑优化应用服务算法了。
一般：如果长时间大于，需要考虑优化程序算法等。
     可能存在瓶颈了
 工具
举例：   

值高，表示较空闲。
如果值持续低于，表示系统中目前的瓶颈在。
如上图，已经达到瓶颈了。
．  内存性能评估
   工具
举例： –    –
 以为单位查看
 以为单位查看

关注第二行：
=行：
=行：
一般第二行  表示应用程序可使用的内存。
里的内容，一般可以释放给应用程序使用。
释放里的内存，看是否可用：
   _
再查看内存：

发现末完全释放，只释放了一部分。与上面的图比较
检查：发现部分共享内存占用，无法释放，应用程序也就无法使用这部分了。
删除目前没有使用的共享内存：
  |   ==  {  }
再执行
   _
再执行   
 –

里的内存又释放了一些。
剩下的，部分的共享内存，应用程序正常使用，无法释放。
所以，真正可用的内存，应该是 左右。
还可以使用 查看

．  磁盘性能评估
  工具
举例：
      
 表示，显示设备磁盘使用状态
将用于显示和相关的扩展数据
某些使用为单位的列强制使用为单位

 请求的平均等待时间，单位毫秒；值越小，性能越好；
 请求的平均服务时间，单位毫秒
 统计时间内有百分几的时间用于操作。接近，表示磁盘已经接近满负荷运行了。
如上图，如果时间远大于，表示等待队列的时候太大，磁盘已经达到瓶颈了。
 工具
 举例：
 –  

：队列占满时传送请求等待队列空闲的平均时间。 
 ：完成传送请求所需平均时间毫秒。
  磁盘已经繁忙了。
看写入速度，多每秒。要提高写入速度，可以换更快的盘。
． 网卡性能监控
 工具
 举例：
   | 

 –
查看现有连接数等：

常用选项：
 显示所有的
 显示正在监听的
 显示数字和端口，不通过域名服务器
 显示使用的对应的程序
 打印出统计信息。
．  整体性能评估工具
   工具
举例：
 

指的是用在用户态程序上的时间；
指的是用在内核态程序上的时间；
指的是用在优先级调整过的用户态程序上的时间；
指的是空闲时间；
 
任务队列的平均长度
分钟、分钟、分钟前到现在平均值
三个值长时间大于核数的话，表示机器很繁忙。上图开了个耗程序，可以发现，分钟均值已经越过个数机器个数为核
相关推荐
【腾讯】基于模型的自动化测试工具——【腾讯云的种玩法】利用腾讯云搭建实用小工具【腾讯云的种玩法】激发云力量打造我的云端工具集作者：郑小辉
团队：腾讯移动品质中心

一、左移方向
左移目的大家都明了，不必细说。但左移进行方向不知大家是否有想过？我觉得有个方 向。在开发现有代码的基础点上： 
 
向左：如何让现有代码更可测。
这里会因为人的经验，单测写法等各种原因会认为现有代码不可测。同时，输出的可测案。
例上，开发在短时间内也难以修改。新代码也不一定会按照可测性来。这个在测试程度上可能会依赖开发，如果离职换了一个新来的开发，难免又会出现这种情况。
向右：如何能测试到更多的现有代码。
这个是基于测试角度，假设开发代码就是这个样子，如何才能测试更多。这需要测试人员对单测的深度理解，对环境，及代码实现上一个熟悉。如异步线程如何可测。
在左移上，个方向可同时进行，这样将会达到一个最大覆盖率。
本文后续文章，都将以 向右方向进行探索和实践。
二、单测为什么能达到的覆盖的理解

单测覆盖率达到。然而为什么我们却达不到，甚至只能是。
我认为：
、开发代码可测规范性是个原因；
、单测的理解误区：
对单测的定义，也是不同于以前，可能不少人对单测的理解还停留在对一个类的测试上。单测的定义如下图：基本上能测试的都被定义为单测了。
、测试范围上：
国内的很多单测，大部分只做了 下图中的 、，很少有做 ，而、、部分是基本没有。即使有也只是通过自动化的方式来操作的。而一般业务代码上，、占了很大比重。
以上几点是主要导致覆盖率低的原因。
 
三、单测中 种测试代码的运行机制
、单测之运行机制：
 在官网文档里是：  。
主要测试范围是： 层测试，和部分依赖环境的测试。
和支持：支持和，及库。
运行原理： 
将依赖的环境，用一个的替代，这个没有具体的实现代码，只有接口，所有的返回均可通过来实现你的需求。
因此是运行在上的。
测试代码目录：
运行模式如下：

、单测 之  运行机制：
 在官网文档里是： 。这里也不要认为和之前时代的 一样，是不一样的，这里是比之前高级一点；
运行环境：运行在真机或模拟器上；
主要测试范围是：理论上一切都可测，包括   ；
和支持：普通测试用例支持和，但的测试只能用；
运行原理：测试代码和源代码分别成一个，安装到真机，但是是运行在同一个进程里，因此可以调用业务代码和反射执行。测试代码运行环境均是真环境。你可以选择或不，可以得到业务的等；
测试代码目录：；
运行模式如下：                         

汇总：

问题：
你认为测试，覆盖率可以达到多少？ 
层可以覆盖么？
组件交互层可以覆盖么？
适配可以覆盖么？
未完待续……
搜索微信公众号：腾讯移动品质中心，获取更多测试干货！梁定安， 腾讯织云负责人，目前就职于腾讯社交网络运营部，开放运维联盟委员，腾讯云布道师，复旦大学客座讲师。

前言
运维自动化是我们所渴望获得的，但是我们在一味强调自动化能力时，却忽略了影响自动化落地的一个关键因素。那便是跟运维朝夕相处，让人又爱又恨的业务架构。
因为业务架构是决定运维效率和质量的关键因素之一，所以我想跟大家一起聊一下怎么样的架构设计是对运维友好的。结合这些年在腾讯遇到的业务架构和做运维规划时对业务非功能规范的思考，我们可以把面向运维的架构设计分成六大设计要点。

要点一：架构独立
任何架构的产生都是为了满足特定的业务诉求，如果我们在满足业务要求的同时，能够兼顾运维对架构管理的非功能性要求。那么我们有理由认为这样的架构是对运维友好的。

站在运维的角度，所诉求的架构独立包含四个方面：独立部署，独立测试，组件化和技术解耦。
① 独立部署
指的是一份源代码，可以按照便于运维的管理要求去部署、升级、伸缩等，可通过配置来区分地域分布。服务间相互调用通过接口请求实现，部署独立性也是运维独立性的前提。
② 独立测试
运维能够通过一些便捷的测试用例或者工具，验证该业务架构或服务的可用性。具备该能力的业务架构或服务让运维具备了独立上线的能力，而不需要每次发布或变更都需要开发或测试人员的参与。
③ 组件规范
指的是在同一个公司内对相关的技术能有很好的框架支持，从而避免不同的开发团队使用不同的技术栈或者组件，造成公司内部的技术架构失控。
这种做法能够限制运维对象的无序增加，让运维对生产环境始终保持着掌控。同时也能够让运维保持更多的精力投入，来围绕着标准组件做更多的效率与质量的建设工作。
④ 技术解耦
指的是降低服务和服务之间相互依赖的关系，也包含了降低代码对配置文件的依赖。这也是实现微服务的基础，实现独立部署、独立测试、组件化的基础。
要点二：部署友好
 中有大量的篇幅讲述持续交付的技术实践，希望从端到端打通开发、测试、运维的所有技术环节，以实现快速部署和交付价值的目标。可见，部署是运维日常工作很重要的组成部分，是属于计划内的工作，重复度高，必须提升效率。

实现高效可靠的部署能力，要做好全局规划，以保证部署以及运营阶段的全方位运维掌控。有五个纬度的内容是与部署友好相关的：
① 配置
在每次部署操作前，运维需要清晰的掌握该应用与架构、与业务的关系，为了更好的全局理解和评估工作量和潜在风险。
在织云自动化运维平台中，我们习惯于将业务关系、集群管理、运营状态、重要级别、架构层等配置信息作为运维的管理对象纳管于配置管理数据库中。这种管理办法的好处很明显，集中存储运维对象的配置信息，对日后涉及的运维操作、监控和告警等自动化能力建设，将提供大量的配置数据支撑和决策辅助的功效。
② 环境配置
在运维标准化程度不高的企业中，阻碍部署交付效率的原罪之一便是环境配置，这也是容器化技术主要希望解决的运维痛点之一。
腾讯的运维实践中，对开发、测试、生产三大主要环境的标准化管理，通过枚举纳管与环境相关的资源集合与运维操作，结合自动初始化工具以实现标准环境管理的落地。
③ 依赖管理
解决应用软件对库、运营环境等依赖关系的管理。在织云实践经验中，我们利用包管理，将依赖的库文件或环境的配置，通过整体打包和前后置执行脚本的方案，解决应用软件在不同环境部署的难题。业界还有更轻量的容器化交付方法，也是不错的选择。
④ 部署方式
持续交付原则提到要打造可靠可重复的交付流水线，对应用软件的部署操作，我们也强烈按此目标来规划。业界有很多案例可以参考，如的、、，如织云的通过配置描述、标准化流程的一键部署等等。
⑤ 发布自测
发布自测包含两部分：

应用的轻量级测试；
发布变更内容的校对。

建设这两种能力以应对不同的运维场景需求，如在增量发布时，使用发布内容的校对能力，运维人员可快速的获取变更文件，或对相关的进程和端口的配置信息进行检查比对，确保每次发布变更的可靠。
同理，轻量级测试则是满足发布时对服务可用性检测的需求，此步骤可以检测服务的连通性，也可以跑些主干的测试用例。
⑥ 灰度上线
在《日常运维三十六计》中有这么一句话：对不可逆的删除或修改操作，尽量延迟或慢速执行。这便是灰度的思想，无论是从用户、时间、服务器等纬度的灰度上线，都是希望尽量降低上线操作的风险，业务架构支持灰度发布的能力，让应用部署过程的风险降低，对运维更友好。
要点三：可运维性
运维脑海中最理想的微服务架构，首当其冲的肯定是可运维性强的那类。不具可运维性的应用或架构，对运维团队带来的不仅仅是黑锅，还有对他们职业发展的深深的伤害，因为维护一个没有可运维性的架构，简直就是在浪费运维人员的生命。

可运维性按操作规范和管理规范可以被归纳为以下七点：
① 配置管理
在微服务架构管理中，我们提议将应用的二进制文件与配置分离管理，以便于实现独立部署的目的。
被分离出来的应用配置，有三种管理办法：

文件模式；

配置项模式；

分布式配置中心模式。

限于篇幅不就以上三种方式的优劣展开讨论。不同的企业可选用最适用的配置管理办法，关键是要求各业务使用一致的方案，运维便可以有针对性的建设工具和系统来做好配置管理。
② 版本管理
持续交付八大原则之一“把所有的东西都纳入版本控制”。就运维对象而言，想要管理好它，就必须能够清晰的描述它。
和源代码管理的要求类似，运维也需要对日常操作的对象，如包、配置、脚本等都进行脚本化管理，以备在运维系统在完成自动化操作时，能够准确无误的选定被操作的对象和版本。
③ 标准操作
运维日常有大量重复度高的工作需要被执行，从精益思想的视角看，这里存在极大的浪费：学习成本、无价值操作、重复建设的脚本工具、人肉执行的风险等等。
倘若能在企业内形成统一的运维操作规范，如文件传输、远程执行、应用启动停止等等操作都被规范化、集中化、一键化的操作，运维的效率和质量将得以极大的提升。
④ 进程管理
包括应用安装路径、目录结构、规范进程名、规范端口号、启停方式、监控方案等等，被收纳在进程管理的范畴。做好进程管理的全局规划，能够极大的提升自动化运维程度，减少计划外任务的发生。
⑤ 空间管理
做好磁盘空间使用的管理，是为了保证业务数据的有序存放，也是降低计划外任务发生的有效手段。
要求提前做好的规划：备份策略、存储方案、容量预警、清理策略等，辅以行之有效的工具，让这些任务不再困扰运维。
⑥ 日志管理
日志规范的推行和贯彻需要研发密切配合，在实践中得出的经验，运维理想中的日志规范要包含这些要求：

业务数据与日志分离
日志与业务逻辑解耦
日志格式统一
返回码及注释清晰
可获取业务指标请求量成功率延时
定义关键事件
输出级别
管理方案存放时长、压缩备份等

当具体上述条件的日志规范得以落地，开发、运维和业务都能相应的获得较好的监控分析能力。
⑦ 集中管控
运维的工作先天就容易被切割成不同的部分，发布变更、监控分析、故障处理、项目支持、多云管理等等，我们诉求一站式的运维管理平台，使得所有的工作信息能够衔接起来和传承经验，杜绝因为信息孤岛或人工传递信息而造成的运营风险，提升整体运维管控的效率和质量。
要点四：容错容灾
在腾讯技术运营运维的四大职责：质量、效率、成本、安全。质量是首要保障的阵地，转换成架构的视角，运维眼中理想的高可用架构架构设计应该包含以下几点：

① 负载均衡
无论是软件或硬件的负责均衡的方案，从运维的角度出发，我们总希望业务架构是无状态的，路由寻址是智能化的，集群容错是自动实现的。
在腾讯多年的路由软件实践中，软件的负载均衡方案被广泛应用，为业务架构实现高可用立下汗马功劳。
② 可调度性
在移动互联网盛行的年代，可调度性是容灾容错的一项极其重要的运维手段。在业务遭遇无法立刻解决的故障时，将用户或服务调离异常区域，是海量运营实践中屡试不爽的技巧，也是腾讯和微信保障平台业务质量的核心运维能力之一。
结合域名、、接入网关等技术，让架构支持调度的能力，丰富运维管理手段，有能力更从容的应对各种故障场景。
③ 异地多活
异地多活是数据高可用的诉求，是可调度性的前提。针对不同的业务场景，技术实现的手段不限。
腾讯社交的实践可以参考周小军老师的文章“亿用户大调度背后的架构设计和高效运营”。
④ 主从切换
在数据库的高可用方案中，主从切换是最常见的容灾容错方案。通过在业务逻辑中实现读写分离，再结合智能路由选择实现无人职守的主从切换自动化，无疑是架构设计对最好的馈赠。
⑤ 柔性可用
“先扛住再优化”是腾讯海量运营思想之一，也为我们在做业务架构的高可用设计点明了方向。
如何在业务量突增的情况下，最大程度的保障业务可用？是做架构规划和设计时不可回避的问题。巧妙的设置柔性开关，或者在架构中内置自动拒绝超额请求的逻辑，能够在关键时刻保证后端服务不雪崩，确保业务架构的高可用。
要点五：质量监控
保障和提高业务质量是运维努力追逐的目标，而监控能力是我们实现目标的重要技术手段。运维希望架构为质量监控提供便利和数据支持，要求实现以下几点：

① 指标度量
每个架构都必须能被指标度量，同时，我们希望的是最好只有唯一的指标度量。对于业务日趋完善的立体化监控，监控指标的数量随之会成倍增长。因此，架构的指标度量，我们希望的是最好只有唯一的指标度量。
② 基础监控
指的是网络、专线、主机、系统等低层次的指标能力，这类监控点大多属于非侵入式，很容易实现数据的采集。
在自动化运维能力健全的企业，基础监控产生的告警数据绝大部分会被收敛掉。同时，这部分监控数据将为高层次的业务监控提供数据支撑和决策依据，或者被包装成更贴近上层应用场景的业务监控数据使用，如容量、多维指标等。
③ 组件监控
腾讯习惯把开发框架、路由服务、中间件等都统称为组件，这类监控介于基础监控和业务监控之间，运维常寄希望于在组件中内嵌监控逻辑，通过组件的推广，让组件监控的覆盖度提高，获取数据的成本属中等。如利用路由组件的监控，运维可以获得每个路由服务的请求量、延时等状态和质量指标。
④ 业务监控
业务监控的实现方法分主动和被动的监控，即可侵入式实现，又能以旁路的方式达到目的。这类监控方案要求开发的配合，与编码和架构相关。
通常业务监控的指标都能归纳为请求量、成功率、延时种指标。实现手段很多，有日志监控、流数据监控、波测等等，业务监控属于高层次的监控，往往能直接反馈业务问题，但倘若要深入分析出问题的根源，就必须结合必要的运维监控管理规范，如返回码定义、日志协议等。需要业务架构在设计时，前置考虑运维监控管理的诉求，全局规划好的范畴。
⑤ 全链路监控
基础、组件、业务的监控手段更多的是聚焦于点的监控，在分布式架构的业务场景中，要做好监控，我们必须要考虑到服务请求链路的监控。
基于唯一的交易或的调用关系，通过技术手段还原调用关系链，再通过模型或事件触发监控告警，来反馈服务链路的状态和质量。该监控手段属于监控的高阶应用，同样需要业务架构规划时做好前置规划和代码埋点。。
⑥ 质量考核
任何监控能力的推进，质量的优化，都需要有管理的闭环，考核是一个不错的手段，从监控覆盖率、指标全面性、事件管理机制到报表考核打分，运维和开发可以携手打造一个持续反馈的质量管理闭环，让业务架构能够不断进化提升。
要点六：性能成本
在腾讯，所有的技术运营人员都肩负着一个重要的职能，就是要确保业务运营成本的合理。为此，我们必须对应用吞吐性能、业务容量规划和运营成本都要有相应的管理办法。

① 吞吐性能
持续交付方法论中，在测试阶段进行的非功能需求测试，其中很重要一点便是对架构吞吐性能的压测，并以此确保应用上线后业务容量的健康。
在腾讯的实践中，不仅限于测试阶段会做性能压测，我们会结合路由组件的功能，对业务模块、业务进行真实请求的压测，以此建立业务容量模型的基准。也从侧面提供数据论证该业务架构的吞吐性能是否达到成本考核的要求，利用不同业务间性能数据的对比，来推动架构性能的不断提高。
② 容量规划
英文一词可以翻译成：应用性能、服务容量、业务总请求量，运维的容量规划是指在应用性能达标的前提下，基于业务总请求量的合理的服务容量规划。对容量规划与优化的手段，可参考“运维如何为公司节省一个亿？”。
③ 运营成本
减少运营成本，是为公司减少现金流的投入，对企业的价值丝毫不弱于质量与效率的提升。
腾讯以社交、、云计算、游戏、视频等富媒体业务为主，每年消耗在带宽、设备等运营成本的金额十分巨大。运维想要优化运营成本，常常会涉及到产品功能和业务架构的优化。因此，运维理想的业务架构设计需要有足够的成本意识，
腾讯的成本优化措施，可参考“榨干运营成本：一亿之后再省两亿”。
小结
本文纯属个人以运维视角整理的对微服务架构设计的一些愚见，要实现运维价值最大化，要确保业务质量、效率、成本的全面提高，业务架构这块硬骨头是不得不啃的。
运维人需要有架构意识，能站在不同角度对业务架构提出建议或需求，这也是 精神所提倡的，开发和运维联手，持续优化出最好的业务架构。作者：杨升军

负载均衡：暴露给用户的只有一个，后端机器故障上线先对用户无感知，后端机器可以根据性能差异调整权重，分配访问量
一创建负载均衡
帮助地址
创建地址
二创建或者编辑监听器
访问负载均衡控制台
备注：如果业务需要用户都访问同一台后端真实机器需要选择会话保持，时间可以选择默认，也可以根据业务设置；健康检查建议选择，时间次数可以使用默认，也可以根据业务设置
三绑定云主机：

四下线机器：解绑或者权重更改为

五业务域名业务域名到在腾讯云申请负载均衡时得到的域名：
解析结果：
 ==  ==记录  

相关推荐
内部体验腾讯负载均衡的新功能
告知你不为人知的连接性和负载均衡
负载均衡简介以往一旦  服务出现问题，用户不得不先登录集群 ，然后使用   命令进入容器中查看容器。这个过程费时费力，如果要在不同的容器间切换更是麻烦。
为此，腾讯云率先推出了通过  页面直连  集群内容器功能，帮助用户解决登录容器问题。
要使用这个功能，首先登录腾讯云容器服务页面：

点击服务进入服务页面：

选择需要查看的服务：

在这个页面里面点击远程终端即可马上登录到容器内：

不仅如此，腾讯云提供的  直连  容器功能还可以提供上传文件至容器以及从容器内下载文件的服务。
这套给用户带来友好体验的系统，整体由  个部分构成：
网关系统
远程终端服务
用户集群
其示意图如下：

各个部分的作用如下：
网关系统：负责寻找各个不同地域所对应的远程终端服务，并传输用户数据。
远程终端服务：实现鉴权，编解码，限速，流转发等功能。
用户集群：指用户在腾讯云容器服务上购买并创建的集群。
用户通过  协议连接到网关系统，由网关系统转发请求至远程终端服务，并由远程终端服务进行解码，调用  将操作数据流发送到用户集群内。整个过程通过  保证用户的数据安全。容器推出以来，给软件开发带来了极具传染性的振奋和创新，并获得了来自各个行业、各个领域的巨大的支持——从大企业到初创公司，从研发到各类  人员等等。跨境知名电商小红书随着业务的铺开，线上部署单元的数量急剧增加，以  调用脚本进行文件推送的部署模式已经不能适应需求。本文作者介绍小红书如何以最小的投入，最低的开发量快速的实现容器化镜像部署，以及由此带来的收益。
小红书

图 
小红书是一个从社区做起来的跨境电商。用户喜欢在我们的平台上发关于生活、健身、购物体验、旅游等相关帖子。目前我们已经有有  千万的用户， 千万的图文，每日有  亿次笔记曝光，涉及彩妆、护肤、健身、旅游等等各种领域。
小红书是国内最早践行社区电商这个商业模式并获得市场认可的一家电商，我们从社区把流量引入电商，现在在电商平台的  已经上到了十万级。我们从社区里的用户创建的笔记生成相关的标签，关联相关商品，同时在商品页面也展示社区内的和这商品有关的用户笔记。
小红目前还处在创业阶段，我们的技术团队规模还不大，当然运维本身也是一个小团队，团队虽小，运维有关的方面却都得涉及。小公司资源有限，一个是人力资源有限，二是我们很多业务往前赶。在如何做好 ，怎么务实的落地方面，我们的策略就是开源优先，优先选择开源的产品，在开源的基础上，发现不满足需求的地方再自行开发。
之前的应用上线流程

图 
如图  是之前的应用上线的过程，开发向运维提需求，需要多少台服务器，运维依据需求去做初始化并交付给开发。我们现在有一个运维平台，所有服务器的部署都是由这个平台来完成的，平台调用腾讯云  生成服务器，做环境初始化，配置监控和报警，交付给开发的是一个标准化好的服务器。

图 
开发者拿到服务器准备线上发布时用  触发脚本的方式：用  的脚本做测试，执行代码推送。当需要新加一台服务器或者下线一台服务器，要去修改这个发布脚本。 发布流程大概是这样的： 脚本先往  环境发，开发者在  环境里做自测，自测环境没有问题就全量发。
我们遇到不少的情况都是在开发者自测的时候没有问题，然后在线上发，线上都是全量发，结果就挂了。然后回退的时候，怎么做呢？我们只能整个流程跑一遍，开发者回退老代码，再跑一次  脚本，整个过程最长需要来分钟，这段过程线上故障一直存在，所以这个效率挺低。
以上的做法其实是大多数公司的现状，但是对于我们已经不太能适应了，目前我们整个技术在做更迭，环境的复杂度越来越高，如果还是维持现有的代码上线模式，显然会有失控的风险，而且基于这样的基础架构要做例如自动容量管理等都是很难做到的。
问题  需求
首先，我们整个技术团队人数在增加，再加上技术栈在变。以前都是纯  的技术环境，现在不同的团队在尝试 、、。还有就是我们在做微服务的改造，以前的单体应用正在加速拆分成各个微服务，所以应用的数量也增加很多。拆分微服务后，团队也变得更细分了；同时我们还在做前后端的拆分，原来很多  的页面是后端渲染的，现在在做前后端的拆分，后端程序是 ，前端是展示页面，各种应用的依赖关系也变得越来越多。再加上电商每年大促销，扩容在现有模式也很耗时耗力。所以现在的模式基本上已经不太可行了，很难持续下去。
我们团队在两三个月以前就思考怎么解决这些问题，怎么把线上环境和代码发布做得更加好一点。基本上我们需要做这几点：
■重构“从代码到上线”的流程；
■支持  发布的策略，实现流量的细颗粒度管理；
■能快速回退；
■实践自动化测试，要有一个环境让自动化测试可以跑；
■要求服务器等资源管理透明化，不要让开发者关心应用跑在哪个服务器上，这对开发者没有意义，他只要关心开发就可以了。
■要能够方便的扩容、缩容。
方法

图 
我们一开始就考虑到容器化，一开始就是用  的框架做容器化的管理。为什么是容器化？因为容器和微服务是一对“好朋友”，从开发环境到线上环境可以做到基本一致；为什么用 ？这和运行环境和部署环境有关系，我们是腾讯云的重度用户，腾讯云有对 提供了非常到位的原生支持，所谓原生支持是指它有几个方面的实现：第一个是网络层面，我们知道  在裸金属的环境下，要实现  网络，或者有  网络的环境，而在腾讯云的环境里，它本身就是软件定义网络，所以它在网络上的实现可以做到在容器环境里和原生的网络一样的快，没有任何的性能牺牲。第二在腾讯云的环境里，负载均衡器和  里的  可以捆绑，可以通过创建  的  去维护云服务的  负载均衡器。第三就是腾讯云的网盘可以被  管理，实现  等，当然  本身提供的特性是足够满足我们的需求的。
刚刚说了我们作为创业公司都是是以开源为主，在新的环境里应用了这样的一些开源技术图 ，、、 和 。 和  应该都听说，大家都在用，、 也都是很主流的。
重点介绍两个比较新，但是现在相当火的开源技术：第一个叫 ，在我们的环境里用来取代  反向代理， 是用  写的一个反向代理服务软件。第二是 ，这是一个我个人认为非常优秀的开源的发布系统，它是由  在去年开源的，是基于  内部一直在使用的发布系统做的开源，可以说是  在  方面的最佳实践，整个社区非常活跃，它对  的环境支持非常好。接下来我会重点介绍这两块东西。

■ 开源项目
■开放性和集成能力
■较强的  表达能力
■强大的表达式
■界面友好
■支持多种云平台
刚才介绍了 ，它是一个开源项目，是  的开源项目。 的开源项目在社区一直有着不错的口碑。它有开放式的集成能力，它原生就可以支持 、 的整合，它还支持 ，就是说在某一个环境里，如果后面的某个资源的控制组件，本身是个 ，那它就很容易整合到  里。
再者它有比较强的  的能力，它的  可以复杂非常复杂， 之间还可以关联，它还有很强的表达式功能，可以在任何的环节里用表达式来替代静态参数和值，在  开始的时候，生成的过程变量都可以被  每个  调用。比如说这个  是什么时候开始的，触发时的参数是什么，某一个步骤是成功还是失败了，此次要部署的镜像是什么，线上目前是什么版本，这些都可以通过变量访问到。它还有一个比较友好的操作界面，重点的是支持多种云平台。目前支持 、、亚马逊的容器云平台。

图 
图  是  的架构，是一个微服务的架构。这是一个微服务架构，里面包含用户界面 ， 网关  等， 网关是可以对外开放的，我们可以利用它和其它工具做一些深度整合， 是它做镜像构建的组件，我们也可以不用  来做镜像构建， 是它的核心，就是流程引擎。 是通知系统， 是用来集成  等  系统的一个组件。 是存储管理，  是它用来适配不同的云平台的，比如  就有专门的  ，也有亚马逊容器云的  。 是它一个鉴权的组件。

图 
图  是它的界面。界面一眼看上去挺乱，实际上它还是有很好的逻辑性。这里每一个块都有三种颜色来表示  的环境里的某个实例的当前状态。绿色是代表是活着的，右边是实例的信息。实例的  配置，实例所在的集群，实例的状态和相关 。

图 
图  是  的界面。首先，我觉得这个界面很好看很清晰。二是  可以做得非常灵活，可以说执行了前几个步骤之后，等所有的步骤执行完了再执行某个步骤。这个步骤是某个用户做某个审批，再分别执行三个步骤其中的一个步骤，然后再执行某个环节。也可以说要发布还是回退，发布是走发布的流程，回退就是回退的流程。总之在这里，你所期待的  的功能都可以提供，如果实在不行，还有  的模式让你方便的和外部系统做整合。

图 
图  是  步骤的类型。左上   前置条件满足的时候才执行某个步骤。例如当前面的第一次发布里所有的实例都存活的时候，才执行某个步骤。或者当前面的步骤达到了某个状态，再执行下一个步骤。 是在  环境里生成  ，可以在  里更新一个服务器组、禁用一个集群、把集群的容量往下降、往上升等等。也可以跑某一个脚本，这个脚本是在某一个容器里，有时候可能有这样的需求，比如说  来说这个  跑起来之后并不是马上能够接入流量，可能要到  里跑一个 ，从数据库加载数据并做些初始化工作后，才可以开始承接流量。

图 
 表达式很厉害，它的表达式是用  来做，大家知道  是一个动态语言。凡是  能用的语法，在字符串的地方都可以用。所以，这些步骤中，可以说这个步骤参数是来自表达式。也可以说有条件的执行，生成环境的时候才做这样的东西。也可以有前置条件，当满足这个条件的时候，这个流程和  可以继续走下去。

图 

图 
如图  是各种类型的表达式，从现在看起来，基本上我们各种需求都能满足了。 可以自动触发图 ，可以每天、每周、每月、每年，某一天的时候被自动触发，做一个自动发布等等，也可以在镜像有新  推送到镜像仓库时， 去做发布。
 和  的关系

图 
 和  有什么关系？它有很多概念是一对一的， 有一个叫 的， 对应到  是  ，我们的环境里现在有三个  的 ，分别对应到开发、测试和生产，它也是对应到  的 三个 ； 对应到  里是 ，一个  就是一个运行的单元；还有有  ，这个   对应的是   或者是 。然后是  ，在  里称之为   的东西在  里就是 。


图 
 亮点：
■配置热加载，无需重启
■自带熔断功能
－  
■动态权重的轮询策略
－
为什么我们用  而不用  做反向代理呢？首先  是一个配置热加载，用  时更新路由规则则是做后端服务器的上线、下线都需要重载，但  不需要。 自带熔断功能，可以定义后端某个实例错误率超过比如  的时候，主动熔断它，请求再也不发给它了。还有动态的负载均衡策略，它会记录  秒钟之内所有后端实例对请求的响应时间或连接数，如果某个后端实例响应特别慢，那接下来的  秒钟就会将这个后端的权重降低直到它恢复到正常性能，这个过程是在不断的调整中，这是我们需要的功能。因为上了容器之后，我们很难保证一个应用的所有实例都部署在相同处理能力的节点上，云服务商采购服务器也是按批量来的，每一批不可能完全一致，很难去保证所有的节点性能都是一致的。

图 
图  是  自带的界面。我们定义的规则，后端实例的情况都可以实时的展现。
为什么在  环境里选择了 ？
■ 集群中的  
■动态加载  更新路由规则
■根据  的定义动态更新后端 
■根据  的  检查结果动态调整可用 
■请求直接发送到 
 和  有什么关系呢？为什么在  环境里选择了 ？ 在  是以   存在，大家知道  到  之后就引进了  的概念。 原来只有一个  来实现服务发现和负载均衡， 是四层的负载均衡，它做不到基于规则的转发。在  里  是属于七层  的实现，当然  本身不去做七层的负载均衡，它是通过   实现的， 在  里就是一种  。它可以动态加载  里的  所定义的路由规则， 里也定义了一个路由规则所对应的 ，而  又和具体的  相关， 据此可以将请求直接发送给目标 ，而无需通过  所维护的  来做转发。列表是根据  的  和  状态做动态的调整。

图 
图  是新发布的一个流程或者是开发的流程。我们有三个环节：一个是开发阶段，一个是集成测试，一个是上线。
开发阶段，开发者在迭代开始时生成一个  分支，以后的每次更新都将这个  分支推送到  。 里配置的  触发一个  ，这个  做单元测试和镜像构建，构建成一个  分支的镜像，给这个镜像一个特定的 。生成新的镜像之后，触发  的部署，这个部署只在开发环境里。
开发者怎么访问刚刚部署的开发环境呢？如果这是个  应用，假设应用叫做 ，而分支名称叫 ，那开发者就通过  就可以访问到   的代码。在整个周期里可以不断的迭代，最后开发者觉得完成了这个  了，就可以推送到 。一旦把代码推往  就触发另一个构建，基本上和前面的过程差不多。最后会有一个自动化的测试，基本上是由测试团队提供的自动化测试的工具，用  调用它，看结果是什么样。
如果今天很有信心了，决定往生产发了，可以在  上生成一个 ，比如这个  是 ，今天要发  版了，同样也会触发一个镜像的构建。这三个不同的阶段构建的镜像  不一样，每生成一个新 ，  会根据  的命名规则触发不同的 ，做不同环境的部署。

最重要的是我们有一个  的发布过程，我们在  的基础上，开发了一套  的机制。 和  差不多，但  是真实引入流量，它把线上用户分为两组：一是稳定版的流量用户；二是  版的用户，他们会率先使用新版本，我们的具体策略是先给公司、先给我们自己办公室的人来用，这个灰度如果没问题了，用户反馈 ，看看监控数据也觉得没有问题，再按照  的阶段随机挑选线上用户继续灰度，在这整个过程都有监控数据可以看 任何时候如果有异常都可以通过  进行回退。

图 
这个是  的示意图，线上用户被分成两组，大部分用户访问老版本，特定用户通过负载均衡转发到特定的版本里，后台有监控数据方便去比较两个版本之间的差异。

图 
这是我们在容器环境里实现的  的架构图 ，用户请求从前面进来，首先打到 ，如果没有做  的过程， 是直接把请求打到组实例。如果要发布一个新的版本，有一个  的  控制  ，决定把什么样的流量可以打到这个里面版本。我们的策略可能是把办公室用户，可以通过  看到 ，或者把线上的安卓用户，或者线上  的安卓用户打给它，这些都是可以定义的。

图 
如图  所示是线上真实的部署流程。首先是要设置一个  策略，这个策略可以指定完全随机还是根据用户的特定来源。比如说是一个办公室用户，或者所有上海的用户等等，然后去调整参数，是  的上海用户，还是所有的上海用户。然后开始部署服务。接下来把这个  实例做扩展，在流量进来之前，实例的容量一定要先准备好。进来之后把流量做重新定向，把流量从原来直接打给后端的  改成打到  代理服务上，由  代理服务根据策略和用户来源做进一步的流量分发。整个过程不断的迭代，有  的线上用户开始慢慢到到 。在达到  后，就采用红黑的策略替换掉所有旧版本：先把所有的新版本实例生成出来，等所有的新版本通过健康检查，都在线了，旧的版本再批量下线，这样完成一个灰度。如果中途发现问题不能继续，马上就可以回退，所谓的回退就是把 把流量打回到线上版本去。

图 
图上图 是我们的  策略。这是我们自己实现的一套东西。图中的例子是把来自指定网段一半的  用户进行 。用户分组的维度还可以有其它规则，现在我们支持的是完全随机特定 特定设备类型，这些规则可以组合起来。
我们的用户分组是有一致性保证的，一旦为某个用户分组了，那在当前灰度期间，这个用户的分组不会变，否则会影响用户体验。
下一步打算
■——自动灰度分析
■自动容量管理
下一步我们打算做两件事情：第一，我们想做自动灰度分析，叫 ，现在  概念很热门，我个人认为自动灰度分析可以说是一个具体的  落地。在灰度的过程中，人肉判断新版本是否正常，其实如果日志采集够完整的话，这个判断可以由机器来做，机器根据所有数据来为新版本做评分，然后发布系统根据评分结果自动继续发布或者终止发布并回退。第二，再往下可以做自动的容量管理，当然是基于  的基础上，做自动容量管理，以便更好的善用计算资源。
最后总结一下：一个好的  系统应该能够控制发布带来的风险；我们在人力资源有限的情况下倾向于采用开源的方法解决问题，如果开源不满足的话，我们再开发一些适配的功能。

本文转载自：中国，：，点击查看原文。作者 |董朝编辑 | 顾乡
做客户端开发的同学都知道业务需求千变万化，你永远不知道他未来会变化成什么样子。而作为开发人员也绝对不喜欢需求变更。本来说好的，都快做完了，产品经理变卦了：咱们不这样搞了，你看我七十二变。
我们极不情愿跟着这纷繁复杂的变化屁股后面，而疲于奔命。天下没有那么容易偷的懒，若不想应对这变化。就需要走到变化前面。技术往前走一步，领先于业务，而不是被业务赶着屁股走。这就需要冗余性思考，在做业务开发的时候，作为就需要往后思考，业务可能会怎么变，当前程序结构是否足够灵活，方便调整。当业务需求调整的时候，能够以最小的代价来满足。而这就是『冗余性』思考。

针对变化进行设计而不只是针对需求。

这里说是『冗余』，是因为开发测多想了几步，为未来可能的变化也做了铺垫。与一些同学坚持的程序设计满足当前需求，不进行过度设计的理念多少有些不符。而我认为进满足当前需求进行设计是传统软件开发的路数，在互联网软件开发过程中，已经不适用。互联网软件产品，尤其是终端上的，版本迭代频繁，功能更新迅疾。已经很难有稳定的需求存在，变化是其本质特征。于是要求我们在开发的时候，就需要针对这种变化做出一定的设计。
探寻变化的规律
设计机制而不是仅仅满足需求

机制与策略分离

我们首先要说一个观点就是机制与策略分离。我们希望设计的是一整套能够满足上述要求的协议，其次才是实现，最后才是在我们的中的具体应用。这也是我这一年来的一个非常重要的总结。并且在逐渐开源出来的一些库中也体现着这个设计。具体说一下，所谓机制即是抽象出来的规则比如
= 属于所谓策略即是在具体场景中的应用，比如当=的时候
= =
面对需求，我们需要首先透过表层的的东西，深入一步探讨一下在需求之下在变化的东西。举个例子来讲，我们都有处理过相关的需求。
在版本的时候，产品告诉你我们要做。展示样式吗有目前是这个样子的： 

当没有深入思考的时候。我没有区分什么机制那些变化的规律，什么是需求产品的当前的诉求。然后就开始动手了。写的子类，往上面加和，一起都是固定的。然后加载数据展示。。。。。
而没发布几天，产品说咱们的展示样式太简单了。现在我们需要支持链接跳转，你们看给到的样式是这样的：

于是我们又开始增加新的的子类。。。。。版本发布了。
后面还有版本，，……终于有一天忍无可忍

这个时候于是就有了重构，我们开始抽离的公共部分放在基类里面，通过类继承等技术手段来控制工程的复杂度，同时提高开发效率。这个时候，我们反问一句：

这些重构的工作是否可以提前到版本的时候开始做呢？

这里当然会有两方观点，
一方认为：代码腐败是伴随着项目推进必然产生的现象，何必实现多花费劳工去提前设计，兵来将挡水来土掩就好了。
另外一方认为：我们坚信事物背后都有一定的规律可以依循，虽然代码腐败是必然现象，但是依旧可以通过一定的技术手段来极大的减速这个过程。 
先说一点，这里没有对错之分。要是争对错了，估计又是一场骂战。只能说我更倾向于认同第二种观点。在项目设计初期，我们可以通过去预判功能走向，来进行软件设计。透过表面和业务逻辑，去看背后的底层变化逻辑。而这也正是我一直比较看好的：机制与策略分离比较好的应用。
首先透过表层的业务逻辑，去深度思考业务或者功能背后的底层变化规律。真对这些规律设计类库，然后再在当前的业务中选取适当的策略进行应用。再次强调一个理念：

针对变化进行设计而不仅仅是需求

几种真对变化进行设计的
说完干巴巴的理念的东西，我们来看一些大家喜闻乐见的具体的应用。

      

增加端的动态性或增加之间交互性
一般我们认为客户端开发很像是固体，给人的感觉是很硬的，一旦发版之后很多修改将变得异常困难。尤其是的客户端，由于审核的限制，发版也相对难一点。一个很“硬”的东西，不如一个很“软”的东西更容易应对变化。这种变化有可能是业务需求，有可能是软件的，有可能是系统突发危机…

金以刚折，水以柔成。 ——晋·葛洪《抱朴子·广譬》

所以为了应对这些变化，需要让我们的变得像水：容万物而不折。我们就需要给其相应的能力。这里有两种策略：
增加之间交互性，通过下发指令来操作客户端增加端的动态性，比如，还有这类的方案。让客户端变得像是一个可以接受指令的机器人，能够在服务器的配合下，灵活应对各种需求和突发状况。
动态性
先说动态性，这一块是业界一直在探索的东西，远的有等基于的方案，进的有和，还有阿里团队的，都是非常优秀的尝试。尤其是和，最近一段时间很多团队将其引入到了技术栈，让自己的客户端可以支持动态发版，也就是常说的插件化。
去年下半年滴滴和手团队也分别抛出了两个非常惊艳的方案，一个是滴滴的，一个是手的。在编译器级别进行修改，通过下发中间语言，在客户端上跑对应语言的虚拟机来解释执行对应的语言。让客户端变得像是一个容器，可以承载下发的业务逻辑。
如果我们单纯的从业务需求的角度去思考，可能这些方案很难会出来。这些方案背后的大神们，也是深入思考之后，把这些机制性的方案设计并构建出来的。把动态性的支持做到如此的深入，也是极牛逼的事情。非常期待他们开源。
交互式客户端
交互式的客户端这种策略，更像是一个缩水版的“动态性”策略。我们在客户端中预置一些能够响应的指令。在需要的时候，通过服务器下发具体的指令，来触发执行客户端对应的逻辑。让客户端能够被动的应对一些业务需求和突发状况。下面我们说几个具体的应用：
命令式缓存
在我们构建了服务器与客户端命令式交互的架构服务器向客户端发送指令，执行特定的动作之后，我们做了一些有意思的事情。就比如命令式缓存：服务器向客户端下发文件缓存指令，客户端收到指令后进行文件缓存操作。
这套简单的系统构建起来之后，我们在这上面做了很多有意思的事情。
利用预缓存减小安装包体积
界面开发中往往用到很多的图片资源，尤其是格式的资源，虽然可以进行压缩，但是某些尺寸比较大的背景资源图片还是可能会达到上百。这对于一个包来说，也是举足轻重了。
最开始，可能为了包体积，我们牺牲了用户体验。对于这样的图片使用网络资源。这样就很难保证用户跳转到界面的时候，能够第一时间看到正确的背景图片。甚至有些网络差的时候，图片压根就下载不下来。
于是，我们做了这样的设计：
版本将引入，，三张大体积的图片在版本没有发布之前，就向全量客户端下发预缓存指令：缓存，，三张图片。然后发布版本，用户升级之后进入对应页面时，将直接从本地缓存中读取对应的图片进行展示。这样即兼顾了用户体验也减小了包体积。
利用预缓存减少压力
在活动运营的时候，尤其是重大的节假日，一旦活动发布之后的段时间内，用户访问量激增，将会导致过载。大量用户初次访问页面，大量下载文件资源。这个时候，就完全可以在活动之前，下发预缓存指令，来缓解过载的问题。
染色日志上报
在我们客户端支持的指令列表中，日志上报也是一条非常有意思的指令。当客户端发生问题的时候，我们最开始的时候是手足无措。后来有了上报，但也只是能够上报这种极端情况。有很多没有的情况，可能只是用户某个用法不当，或者产品逻辑本身有问题的时候，就比较难以追踪。这个时候我们就需要去查看生产环境上的日志。这个是在服务器开发中是比较常见的策略。
于是我们就构建了这样的一条指令，当指令被触发的时候，会将用户本地打的生产使用非对称加密之后上传到制定的地址。这种指令是和用户挂钩的，我们是根据针对单一用户下发指令。
然后我就可以，通过管理端拿到对应的，解密后查看。来看生产日志中可能存在的问题。
构建可运营的客户端
可运营的概念来自于别人的文章。意思是让自己的客户端能够支撑运营人员的需求，动态的更改展示的内容，甚至是功能点。虽然我们不进行发版，但是可以支持内容的动态替换，支持功能点的动态上线下线。甚至当某些功能上线之后，能够动态的增加其对应的保障性功能例如日志，数据上报这样的保障性功能。这里要说一下数据部分。
对于数据上报功能的设计，重点需要考虑扩展性，因为对于数据种类的需求无法一次就确定，往往随着产品的迭代会增加新的数据需求。这时候如果能够通过不修改上报模块，只在目标监控点增加采数据集代码就能完成新增需求，这就说明上报系统已经具有不错的扩展性了。当然这只是在客户端增加了数据上报的基础设施，真正运营的工作还要靠团队建立一个强大的大数据分析平台了，数据上报之后其实只是一堆数字垃圾而已，而真正赋予这些数字垃圾信息化价值的过程是分析。试想作为产品经理的你每天一到公司都会收到关于产品的数据邮件，可以看到新鲜的数据报表，曲折的线图，跃动的燃烧图等，这些都将为你的工作和负责的产品提供非常有价值的支撑，你应该感谢有这么好的运营团队。

相关推荐
高性能图片架构与设计腾讯云技术公开课：零基础入门高可用云端架构设计【腾讯云的种玩法】生成器介绍与腾讯云部署作者：郑小辉
团队：腾讯移动品质中心

一：方向篇
、左移方向
、单测为什么能达到的覆盖 的理解
、单测中 种测试代码的运行机制
二：方案选型篇
、种模式预研
、方案选型
三：技术篇
、 层可测性预研：
：可测性
：可测性
：可测性
：可测性
、层单元和接口测试
：单元测试
：接口测试
、异步线程可测性
： 方式可测性
：方式可测性
：方式可测性
：方式可测性
、函数回调可测性
：参数传入回调方式可测性
：内部回调可测性
、
：环境  
：  
：普通和 
：静态和  
、反射调用与执行
：业务代码反射执行
：库代码 反射执行
、业务代码直接调用预研
：业务代码直接调用
四 ：流程与覆盖率篇
、脚本方式执行    和  
、衡量方式  覆盖率接入
、 运行     
五：实战篇
、垃圾模块白盒测试实践
六：形成库篇
、抽离通用性形成库。
未完待续
搜索微信公众号：腾讯移动品质中心，获取更多测试干货！导语： 每年暑期都是各路顶会扎堆，今年也不例外，，，这三个我们一直关注的领域顶会相继召开，本期“技术快报”将重点关注这三大顶会的内容，摘录与游戏开发，游戏体验相关的内容做一个归纳点评。

图像生成    
图像生成是计算机视觉中非常重要的一类问题，也有着很长的研究历史。同时这一类问题也和动画制作有着紧密的关联。广义的说来，凡是生成新的图像内容的相关问题都可以归为图像生成问题。
        
原文链接：
项目主页：
【摘要】
本文由乔治亚理工、 研究院和普林斯顿大学的相关研究人员联合发表在 上。本篇文章提出了一种新的基于深度学习的图像合成框架，根据草图和颜色来生成不同内容的图像。下图左半部分为基于草图的合成结果，右半部分为本文提出的基于草图和颜色的合成结果。

【问题】
近来的基于深度卷积神经网络的图像生成方法由于很难控制网络生成的结果，技术应用受到比较大的限制。
【解决方法】
●     提出一种基于深度对抗网络的图像合成方法：依赖于草图轮廓 和很少量的颜色来生成真实化图片。
●     该方法允许用户在草图上任意的涂写来指定偏爱的颜色使得结果满足用户要求。
●     使用前馈网络直接生成结果，速度达到实时。
●     网络结构为生成式对抗网络生成网络采用编码解码结构，基本模块为残差模块；判别网络采用全卷积网络。
【结果分析】
●     优势：
❖   用来指导网络生成图像高层视觉结构，用很少量的颜色来控制生成的颜色模式
❖   当输入图像分辨率为时，处理速度达到
●     不足：
❖   生成的结果中，有时会出现物体之间或物体颜色不同的区域之间边缘模糊和颜色泄漏的现象
❖   当用户指定一些不太常见的颜色比如紫色的汽车或形状时，生成结果不理想
【应用落地】
●     设计虚拟角色和创作时，提供一款实时交互式图像编辑工具，即刻看到结果反馈。
        
原文链接：
项目主页：
【摘要】
本文由北卡罗来纳大学教堂山分校和研究院的研究人员合作发表在 上。作者提出了一种新的网络结构来从给定的某一视角输入图像合成新的视角图像。减少了结果中的畸变和“洞”，提升合成质量。下图为合成结果示意图。















输入图像
 
当前最好方法本文方法



结果示意图
【问题】
●     视角合成这一问题很困难：从单一视角到形状具有语义的歧义性
●     需要推断输入视角下不可见部分的物体
●     基于图像合成的视角合成方法在视觉质量上低于基于几何的方法
【解决方法】

技术处理流程
给定一幅任意单视角的包含目标的输入图像，合成一幅三维视角的图像，将目标进行一个特定视角的变换。
将该任务分为两个步骤：首先显式地推断在输入和输出视角中可见的几何部分：提出了一个新的神经网络结构来预测一个流动将像素从输入移动到目标视角位置。然后，然后将剩余的合成问题转换为图像填充问题：利用神经网络根据中间结果来推断输入图像中不可见的部分所对应的合成结果。
除了提出了新的网络结构，提出了对抗损失函数和视觉感知损失函数来减少合成结果中的畸变和空洞。
【结果分析】
●     优势：在渲染的标准数据集上和真实互联网图像数据集上分别进行了度旋转的重建、真实图像的物体旋转两组实验，与当前最好方法相比，两个客观指  和 都更优，表明标合成的图像质量更好，更少
●     不足：训练集多样性不足，生成结果中，例如车灯和轮胎等一些结构不够准确和出现失真。
【应用落地】
基于图像的渲染技术中，可以在背景中放置指定姿态的虚拟物体；或者在场景中操作虚拟物体
       
原文链接：
项目主页：
【摘要】
本文由斯坦福大学和慕尼黑工业大学的研究人员联合发表在上。该文章提出了一种基于数据驱动的方法来填充物体的形状。通过利用维编码解码神经网络，实现了高精度预测全局结构和局部高分辨率细节。
【问题】
当前获得的扫描由于遮挡因素的存在，在物理上无法保证所有的表面点能在扫描过程中被覆盖，导致获得的模型是不完整的。甚至对于一个单独的物体进行扫描，以上问题仍然存在。因而限制了在计算机图形学中的应用。
【解决方法】
直接应用深度学习来从部分扫描的输入来预测缺失的结构。一，基于 提出了一个编码预测网络来推断全局结构；二，提出了一个基于迭代优化的形状合成流程来获取局部几何细节，并提高了输出的分辨率。最后将这两个步骤结合在一起，提出了一个端到端的模型来进行形状合成。下图为提出的方法的整理处理流程图。

整体处理流程图
【结果分析】
●     优势：在一个包含个模型的测试集上进行结果量化评估。物体类别包括飞机、桌子、汽车、椅子、沙发、裙子、台灯和木船。对比方法包括经典方法、以及与本方法最相似的三种方法。在 指标上，最终的合成结果要低于对比方法。
●     不足：
❖   编码预测网络的分辨率是最大的限制。尽管它可以预测全局结构，但是无法推断更小的一些结构成分。尤其是几何细节在一个尺寸以下。
❖   当输入结构非常不足以至于缺少足够的上下文来进行有效的推断。
❖   目前仅限于对于单独物体的处理，无法处理较大规模场景，比如一间屋子规模。
         
原文链接：
结果链接：=
【摘要】
本文来自意大利帕维亚研究所、马里兰大学和德国马普智能系统研究所的研究人员。提出了一种对动物形状和姿态进行建模的方法。下图为对动物形状与姿态进行建模的结果示意图。

对动物形状与姿态进行建模的结果示意图
【问题】
相比于人，动作很难听从指令配合，因此也就缺少各种类型和姿态的扫描模型。
【解决方法】
从少量训练集中学习动物的统计形状模型。将这一模型和形状和姿态于图像进行配准，从而可以对之前没有见过的形状生成模型。
【结果分析】
●     优势：通过使用玩具模型 的扫描图作为数据集训练模型，得到的模型具有比较好的泛化性，可以对真实动物图片进行建模，捕捉形状。
●     不足：数据规模不够大，还需要通过更多类型的图像来训练；对于一些方向变化比较大和深度信息模糊的动物图像，建模结果会失败。
【应用落地】
辅助动画制作。
      
原文链接：
代码链接：
【摘要】
本文由德国图宾根大学和 研究院的相关研究人员联合发表在 上。作者在当前图像风格迁移方法的基础上，提出了新的对于合成图像区域位置、颜色信息和空间尺度的控制方法，使得用户可以在一定程度上按照个人喜好来合成图像。以下是不同控制方法对应的图像风格迁移结果示意图。
 
不同控制方法对应的图像风格迁移结果示意图
【问题】
当前基于深度学习的图像风格迁移对于合成的结果图像只有统计学上的解释，单缺乏直观理解，同时对于风格迁移的过程无法进行控制。
【解决方法】
本文提出了如下的假设：图像风格可以被分解为空间区域、颜色与光照信息和跨空间尺度这三个因素。
对于空间因素的控制，通过引入一个新的空间引导矩阵，来控制风格图像的哪一部分用来风格化内容图像对应的图像区域。
对于颜色因素的控制，可以只采用亮度通道进行迁移或者颜色直方图匹配方法来实现。
对于空间尺度因素的控制，通过选择神经网络中不同层对应的统计信息进行风格迁移来实现。
【结果分析】
分别对提出的三种控制合成方法进行了对比实验。在作者给出的三组实验结果中，可以看出可以实现了对于空间区域、颜色与光照信息和跨空间尺度这三个因素的控制。
●     优势：可以生成更加多样性的艺术风格图像
●     不足：评价方法很主观，对于方法的计算效率和实时性没有分析。
【应用落地】
用一种可解释和可控制的方法来进行多种图像风格的迁移与合成，增加结果的多样性。
姿态估计    
目标姿态估计是计算机视觉研究领域中非常重要的一类问题。它指的是给定一幅图像或一段视频，然后去恢复其中人体关节点位置的过程。根据输入图像的类型，人体姿态识别算法可以分为两类：基于深度图的算法和直接基于图像的算法。相较于深度图对图像采集设备要求过高而带来的应用易受限的问题，基于图像的人体姿态估计算法具有更广的应用前景，并且在学术上也取得了很好的成果。目前，即便是针对比较复杂的场景下，基于图像的人体姿态估计算法也能达到很好的识别效果。
姿态估计在游戏领域的应用也十分广泛，可以应用到各类体感游戏中，增加游戏交互性。同时应用到动画制作中。
●     人体 
       
原文链接：
项目主页：___
结果视频展示：=
【摘要】
本文来自卡耐基梅隆大学的研究人员。文章提出了一种高效检测图像中多人姿态的方法。通过利用全局上下文信息和一种自底向上的信息处理流程，在保持高精度的同时，达到了实时估计。
【问题】
之前的许多方法存在以下的几个问题：当然待检测图像中人数过多时，计算效率严重下降；对于全局的上下文信息利用不足，导致对于一些人体接触、遮挡和肢体不全的情景性能不好。
【解决方法】
提出了一种基于人体局部检测与关联的处理流程，通过学习一个向量场来编码图像里人的身体的位置和方向。举例来说，当图像中有多个人时，同时检测每个人的胳膊和腿等部位，并且对于检测结果进行编码和计算它们之间的关联性，然后利用全局的上下文信息来重新优化检测结果。下图为文本提出的完全流程图。

方法的完整流程图
【结果分析】
●     优势：在两个公开的标准数据集——和  ——进行结果比较。与原有最好的方法相比，指标平均提升。在运行时间上，测试图像尺寸为时，机为  时，在同时检测个人的情况下，可以达到 。
●     不足：
❖   对于一些罕见的动作或者人的外表特征，检测失败；一些动作姿态检测不完整；
❖   对于一些人体部位重叠的情况，仍然存在漏检的情况。
      
原文链接：__
项目主页：_
【摘要】
本文来自德国波恩大学和澳大利亚阿德莱德大学的研究人员。文章创新性地提出了一种同时对视频中多人姿态进行估计和跟踪的方法。
【问题】
当前基于的方法有以下问题：
❖   整个流程依赖于单个的人体姿态估计，一旦 检测失败，则整个方法就无法复原
❖   方法复杂度正比于图像视频中的人数，随着目标个数增加，计算开销大大增加。
❖   基于的方法同样有计算效率低的问题，无法达到实时
❖   之前的方法在处理大幅度动作、尺度变化、快速运动、身体被遮挡和突然被截断等情况时，效果不理想。
【解决方法】
首先在空间上对每个人的人体关节进行联合检测，然后对于单人和多人在时间和空间上进行关节之间的关联计算，完成整体的动作估计；另一方面，对于每个人在时间维度上进行动作跟踪。
【结果分析】
●     优点：
❖   在公开数据集上，指标高于目前最好的方法。
❖   在算法运行时间上，单线程 上，每一帧需要花费。
❖   可以较好处理大幅度动作、尺度变化、快速运动、身体被遮挡和突然被截断等情况
●     不足：
❖   仍然无法达到实时
           
 
原文链接：
结果链接：_
【摘要】
本文来自西班牙高等科学委员会下属的自动机械与工业信息研究所。通过创新性地提出使用距离矩阵来表示人体动作数据，引入了结构信息约束，提高了预测精度。
【问题】
对于人体姿态估计问题假定有个关节，目前大多数方法采用一种向量化的表示方法，即将这一问题转化为到的回归问题。这类处理方法会忽略姿态的一些空间结构信息，导致估计不准确。
【解决方法】
使用欧式距离矩阵来表示和人体姿态，并将姿态估计问题转化为矩阵回归问题。具体的，使用一个神经网络来拟合到的回归。

整体处理流程图
【结果分析】
●     优势：在、和  三个数据集上进行效果评估。相比于当前最好的几种方法，估计误差明显减小，并且对于没有见到过的数据有较好得泛化性。通过引入了人体的空间结构信息约束和关节之间的相关性，从而对于遮挡、噪声有更好的鲁棒性。
●     不足：没有给出计算效率的分析
接《  技术快报》：计算机视觉篇下昨天趁着周末把服务器升级了一把，遇到的坑可不少：
  
  
坑：升级失败后，改用下面命令：
 
坑：若中间配置失败，再可以执行：
   
坑：若下载包资源失败，则修改资源文件列表：
 
例如这是腾讯服务器的：
      

      

      

      

      
坑：这时再返回来执行  ，而不是  
包下载完毕后会自动执行，一路回车，验证安装是否正确。
查看版本
 _ 
查看和：利用来看，一览无余，且这货基本是服务器标配置
也可执行的脚本命令查看： 放在一个文件中，在浏览器访问
坑：若这个程序报连接不上错误，则修改
找到文件夹下面的文件并打开，找到这两行代码：
 = 
 = 
将其改成你的数据库用户和密码，保存文件；
坑：若需要手工安装则执行：
     
坑：若提示的错误，则安装：
   
若提示的错误，则安装：
      
坑：若提示的错误，修改配置：的配置


_=____
最后打扫一下战场：
 
我期待以后的云提供一键升级服务。
值得一提的是：我拒绝了某些人提出的重装服务器的自杀式建议。再过几天国产第一艘航母就要下水了，我想自己编程再难也没难过造它吧

相关推荐
【腾讯云的种玩法】搭建属于自己的服务器【腾讯云的种玩法】从购买服务器到建站，从打造自己的网络领地作者：代明敖

一、小时前……
服务器生产部署、重装交付，是服务器运营的重要工作之一。或许有人会说，不就是安装或者重装个操作系统嘛，我光盘个小时搞定，，如果是仅仅一台机器，那么你赢了！而服务器运营面对的是级别的服务器，每天重装和部署都有约台的数量，是不是需要再重新考虑下这是否还是个简单的事情？生产部署和重装看似安装操作系统那么简单，实则非常复杂，服务器运营经过近十载的积累，伴随公司海量业务的发展而逐步成长，由年的刀耕火种到年的全程自动化无人值守交付，交付峰值从台周到台周，提升多倍。按照当前的自动化能力，当公司服务器过百万时，依然可以泰然处之。然而腾讯云黑石的出现，犹如平静的湖面投入一块石头，打破了海量业务下服务器运营的平静。
二、小时：知易行难
腾讯云是公司的重要战略，基于物理机售卖的黑石，是腾讯云的重要一部分，因此对黑石服务器的运营支撑是服务器运营的重要环节。俗话说”台上一分钟，台下十年功”，这句话用在黑石服务器运营上也非常贴切。如下图黑石官网的描述：“获取服务器时间将被缩短至小时”；黑石对外的这个服务承诺，服务器运营用了大半年的时间来逐步提升运营水平最终顺利达成对外承诺，坚定不移的做好专业服务伙伴，为腾讯云的发展保驾护航。
 
图一 腾讯云黑石首页
了解服务器运营或者熟悉公司资源交付业务的同学，可能都比较清楚，服务器生产交付的标准是天，即服务器从上架完成到交付到业务使用，运营需要不超过天的时间来完成操作系统的部署；但黑石承诺只需要小时就能交付设备，相对于公司海量业务，效率提升整整倍；面对黑石交交付带来的挑战，如何把交付时间从天缩短到小时，这是服务器运营面临的难题，也是黑石前期生产交付的主要矛盾；另外海量业务模式下，相同厂商同型号服务器硬件配置和软件配置都是完全相同的，举个例子， 相同厂商同机型的的配置是完全相同的，由厂商已经按照要求在出厂时设置完毕；但到了黑石业务模式，由于第三方公司对服务器性能和配置要求的差异，同机型的配置存在很大差异，因此小时完成交付不但包含了传统的生产部署操作，还要额外增加差异化的配置工作，来满足外部客户各种个性化的需求；对于服务器运营，这些操作系统部署以外的操作无疑是雪上加霜，小时内完成操作系统部署已经是一个很大的挑战，现在还要进一步实现差异化的系统配置。按照传统的方法，这些操作需要派单给现场由人工来操作，那么达成黑石对外承诺的小时交付基本上是纸上谈兵了。但作为专业的服务伙伴，服务用户和解决用户的问题，是我们的责任。如何协助云平实现黑石对用户的承诺，做好云平专业的服务伙伴，是服务器运营面临的最大挑战！
在黑石业务模式下，服务器运营面临的主要挑战有：

交付速度快

黑石业务要实现物理机类虚拟机的生产交付速度体验，即实现把海量业务下的天交付缩短到个小时内完成。与传统海量业务个工作日的相比，这是天翻地覆的变化，对运营生产交付的极限挑战。为什么说小时交付是极限挑战呢？我们先来看看海量业务的生产交付流程及各个阶段的，如下图二海量业务生产流程及：
 图二 海量业务生产部署流程及
注：各个阶段的处理时效，是指该阶段出现异常后相关环节的负责人需要在时效内完成；如果无异常自动化处理时间会低于上述的值。
从上图海量业务生产交付流程及各个环节时效来看，黑石要实现小时的快速交付，可能性是非常小的，主要困难是：
首先，生产交付的整个流程非常的长，有十几个步骤的操作任务要执行，在每个步骤都是全自动化完成的前提下，也未必能达到小时交付的目标；
其次，十几个操作步骤的任务执行，难免会有自动化执行异常的情况，任何一个异常都会导致无法实现小时交付。这时候需要的自动化系统，可是没有人能保证设计和开发的系统是不出问题的。
所以从天小时到小时这样效率提升倍的“硬骨头”，服务器运营也是第一次面对，心里基本没有把握，唯一的感觉是压力山大！

质量高交付质量

在海量业务模式下，用户对服务器的核心需求是海量，即业务需要大量的可用服务器，所以交付及时率是主要矛盾；在保障及时交付的前提下，我们通过各种交付检查手段，保证交付质量达到可用，剩下可能存在异常的服务器最多会导致业务出现毛刺，而不会影响业务正常的运行，因为海量业务自身有冗余设计，对服务器个体故障基本无感知，如服务器、机架、甚至是机房的故障，可能都不会对业务产生大的影响，系统都能快速完成灾备切换。
黑石第三方业务，往往都有以下两个特点：第一，业务普遍处于发展期，运营和容灾意识匮乏，更多的精力是在发展业务提升用户，或者说如何让产品活下去，并且架构缺少冗余设计，单点场景会比较多；第二，成本是用户非常关心的问题，为了降低业务成本，短期可能是损失健壮性和业务冗余性，综合这两点来看，用户对服务器故障感知特别明显，一台服务器宕机就有可能导致整个业务不可用。
由成千上万个电子元器件组成的服务器，是必然会出现故障的。根据业界公认的“浴盆曲线”理论如下图三浴盆曲线，服务器故障会经历“早期故障”、“中期平稳”、“后期故障”三个阶段，
 图三 浴盆曲线
因此设备交付初期业务刚上线时可能会触发相对较多的故障，如何降低浴盆曲线中的早期故障，把黑石交付质量由提升到，是压在运营团队心头的一块大石头。

个性需求多

腾讯海量业务下，生产部署功能比较单一，只需要按照既定的模板完成生产部署即可；但黑石业务从诞生开始，就区别于传统业务，有很多个性化需求。
举个真实的交付案例：当时滴滴打车进驻黑石时，需要台关闭超线程的机器。可是海量业务下没有过这样的需求，运营还没有自动化手段批量修改服务器的设置。传统的方法是派工单给机房现场人工进行修改，最终通过人肉耗时天多完成台机器的超线程关闭操作。
我们再看看黑石的自定义分区需求，这个也是与海量业务分区差异较大的地方。海量业务下我们所有的默认只有个分区，并且已经固化在操作系统镜像中；而黑石自定义分区如果使用海量业务的方法，不同的分区格式对应一个系统镜像，那么需要维护的系统镜像会是几何倍数的增长，已经推动可维护性和可操作性了。
因此，如何在海量业务的背景下快速满足黑石的个性化需求，也是摆在运营面前的一个难题。另外黑石的个性化需求远远不止上述的两个，请看列表：
网络架构特殊：，去，，，……服务器种类多：各种不同配置的自定义机型，操作系统种类多：，，，，……：用户可以选择是否安装，且还有、等功能性分区自定义：用户自定义分区大小及挂载点结构多样化：，……设置多样化：超线程、、……
三、明知山有虎，偏向虎山行
面对黑石业务带来的挑战，服务器运营积极探索，分析当前海量业务与黑石业务的差异，针对黑石的业务特点，对症下药，提出一系列创新的建设性方案例如首次提出资源池的概念，对当前的业务流程进行提炼和优化，并附以更多自动化工具的支撑；与服务器技术团队和厂商深入协作，建设部件性能基准以及推行压力测试，并积极学习和吸收业界经验，稳步应对黑石挑战：
、建设黑石资源池，统一资源生产环境，提高生产部署成功率
根据服务器运营的经验，生产部署过程中，最容易出现问题的环节，都是在部署前准备的操作，如机架开电、切换部署、开机等操作。例如，服务器机架开电操作，需要由机房驻场向机房运营商提交开电申请，运营商审核通过后才能安排专有人员进行开电操作；另外可能还会遇到机架超电等异常情况，这时还不能直接开电，需要再发起搬迁流程，把设备转移到其它电力负载较低的机架，整个过程耗时少则半天，多则天都未必能完成。如果黑石也沿用海量业务的流程，那么黑石达成小时交付的目标，基本落空了。
那么如何解决部署前可能产生的种种异常呢？有没有方法把部署前的各种异常提前识别发现，并加以处理，达到一个统一的环境，当用户购买设备后，直接发起部署操作呢？答案就是建设黑石资源池！
黑石资源池通过定时自动扫描发现约定的业务模块下的设备，然后把设备加入到黑石资源池，通过自动化流程实现设备接入到状态，并对设备进行多项健康检查，完全抹平服务器生产部署前的环境差异，从而实现用户购买时的快速部署交付。如下图三黑石资源运营框架：
图三 黑石资源池运营框架
通过建设上述黑石资源池，一方面实现把生产部署前期出错机率最大的环节提前识别并加以解决，设备以状态行，可以随时投入生产环节以快速生产；另一方面我们可以基于进行一系列的信息采集和及操作，如下文将提及的相关部件性能和压力测试。
、建立部件性能基准，推行性能测试和压力测试
如上所述，服务器故障是不可避免，但黑石用户又对服务器故障特别敏感，如何缓解这个矛盾呢？这个问题的关键是如何降低服务器故障率，提高服务器质量，提升服务器可用性。
根据服务器运营经验和服务器类电子元器件的故障规律，对服务器进行部件性能测试和模拟一定的业务压力进行压力测试，可以提前识别潜在坏件，甄别异常服务器，提升服务器质量。基于这个结论，服务器运营联合服务器技术，分两步走来实现服务器质量的提升。
第一步，构建腾讯服务器部件性能基准，所有服务器交付前进行部件性能测试。没有标准的情况下，部件虽然可以正常工作，但无法确定性能是否达标；性能的不达标，也很可能是故障的前兆。所以建设部件性能基准，推行部件性能测试是提升服务器质量行之有效的方法。目前实现了服务器三大基础部件、内存、硬盘的性能测试，并与标准进行比较。如下图四腾讯服务器部件基准数据所示：
图四 服务器部件性能基准
第二步，实施压力测试。部件性能测试保证单个部件是健康的，且性能达标，那么多个部件通过主板组合起来后，部件协同工作是否正常？整体性能是否达标？这还是一个未知数。压力测试紧跟部件性能测试，来验证整机是否正常，有没有潜在的问题。由于黑石资源池设备随时可能被用户购买，所以不能一次对所有设备进行压力测试，当前的压力测试策略是每天凌晨选择若干数量的设备循环进行压力测试。
、摒弃冗余节点，提升流程效率
黑石发展初期，黑石和海量业务使用同一套生产部署流程，后来发现由于黑石业务的个性化需求比较多，且与海量业务存在不兼容的情况，因此分离创建单独的黑石生产部署流程。黑石生产部署流程来源于海量业务流程，但又与海量业务流程有区别，黑石有资源池保证入口环境的统一性，因此原有流程的中的部分节点，如“机架开电”、“带外检查”、“交换机检查”等步骤已经不再需要，且已经成为提高黑石生产力的障碍。另外由于黑石部署都是由资源池设备发起的，资源池已经保障了设备成功安装，且保证机器已经开电、带外可用、交换机也已经开电且状态是正常的，抛弃这些为海量业务设计又不适用于黑石业务的节点，是提升黑石部署效率的捷径。请看下图五，优化前和优化后的黑石部署作业流程对比：
 图五 黑石部署作业流程优化前后对比
上图可以看到，优化后的黑石部署作业流程非常简洁，且完全对接黑石资源池的功能：资源池把设备接入并完成健康检查，部署流程直接从健康设备的开始进行后续安装操作，基本实现一气呵成，流程效率得到极大提升。
流程经过优化后，效率提提升，但新的问题又出现了。新的问题是黑石修改问题，主要表现在两个方面：第一，黑石机器的结构，在用户发起购买前是不知道的，所以无法提前构建，资源池不能解决修改问题；第二，传统模式下修改操作是在下执行的，而黑石部署的第一步就是，因此修改就需要重新接入，一方面降低了资源池的设计效果，另一方面修改逻辑中，会有删除、关机、开机进、修改、安装一系列步骤，虽然都是自动化完成的，但耗时也差不多需要个小时，且难以避免自动化失败的场景，耗时就不可估量了。如何解决修改的问题，运营侧创新性的实现了在下修改功能，即把传统的“删除、关机、开机进、修改结构、安装”优化为“修改结构”一步达成需求，实现由盘山公路到隧道一样的变革，效率得到很大提升。
、解耦部署系统，支持个性化
相比海量业务，黑石业务支撑了用户极大的个性化需求：包括已实现的机型硬件配置定制、配置指定，分区指定、类型穷举支持、指定等，以及正在规划中的用户自定义镜像部署支持，几乎覆盖了整个生产链路。 而海量业务下的流程体系，部署实现方式，工具系统在开发效率和功能上都难以支撑类似需求，为了更好的解决这个问题，我们在方面也进行了一些初步探索和实践。
这里以系统分区自定义举例说明，海量业务下，分区规划以及文件系统挂载文件由于母盘镜像定义，这种方式无法支持不同用户对于系统分区的独特需求。而在黑石业务下，我们将部署系统的分区方式从固化模式抽象成一个独立的部署功能模块，它可以接受指定分区挂载点以及对应的每个分区的大小，并具备校验和容错机制以防止需求不合理时造成的异常。 流程再整合该部署功能模块封装为接口供云平黑石系统调用。类似的思想也应用在了类型穷举，配置指定等方面，而这仅仅是在部署底层吸收了的一些思想，它实现了一些个性化需求的支撑，但从部署底层和的结合情况来看，还是属于传统的一种开发模式。
而实际上，运营侧和开发团队还一直在进行更深入的探索和实践中，比如部署从偏流程化，封闭化流程固化，新功能接入开发上线周期长改为更开放化，平台化即插即用，新功能接入无需代码改动，在部署底层和之间定义双方的交互界面和输入输出。这样运营侧新发布的功能模块可以更快速的接入平台，也可以更好的支持个性需求的快速迭代和发布。 
四、小时以后……
通过上述的各项努力，年中我们最终达成黑石对外承诺的物理机小时交付的目标，交付时效如图五所示：

图五 黑石小时交付趋势图
一路走来虽然很艰辛，踩了很多坑，也走了一些弯路，但与周边团队的协作及通力合作，达成目标的成就感，以及由到实现物理机快速交付跻身业界前列，是辛苦付出的回报，也是收获的最大快乐。短期的交付效率目标虽然已经达成，但提升交付质量的课题已经摆在眼前，这里只是小憩，稍作整顿和回顾，继续向新的征途出发。年延续年的架构和成本优化思路，运营管理部在年组织各大开展了大量的架构评审和成本优化工作。作为规划组的一员，在全年个规划产品的评审中我主要参与了其中个。在前期和业务产品，开发及运维的交流和准备材料过程中，发现虽然已经经过了一年的评审，沟通和交流，但大家对为什么要做架构评审，怎样做架构评审，其中的思路和流程都还存在一定的不了解的地方，所以这里自己先抛砖引玉，跟大家聊聊讨该如何做架构评审。
先来说说设备
设备是支撑公司业务运营的最基本实体，随着公司业务的不断发展壮大，公司的设备总数也于去年突破了台大关。评审一个业务的架构，首先得从其设备使用的合理性上来看。
总的设备架构评审思路可以简单归纳如下步：

设备需求驱动形态  确认设备需求动因和相关指标；
关键路径的技术架构  确认架构是否合理；
需求资源推算模型  资源预算和指标关联是否合理，架构分布是否合理。
资源优化计划  后续是否可以释放部分资源，降低成本。

第一点比较好理解，设备的需求动因，我们需要描述清楚涉及设备的关键业务指标以及业务指标的变化情况，通常这些指标在做年度预算的时候能够定义清楚。如果当时没有清晰的定义，我们这里可以根据业务的实际资源需求情况来定义清楚关键指标。后面点是一个架构评审的关键所在，我们这里重点展开来讲。
我们谈一个产品的架构，最开始当然先要从一张总架构图开始讲起。比如下面这个手的消息交互架构图。

一个清晰的架构图至少需要具备如下要素：

描述总体架构关键模块构成和各模块对应的设备数目；
业务请求交互图，描述业务关键路径上的模块交互流程，需包含请求量包量及对应的设备数；
描述设备需求中关键路径的构成情况和模块之间的交互逻辑。

定义出关键路径和关键业务模块后，这些模块需求和架构是否合理，我们需要把这里面的内容给评委展开来重点解释。
针对每一个关键模块，我们首先需要：

描述在总体系统架构中该一级模块的主要核心功能；
描述该核心模块的处理业务逻辑分布，如重要业务逻辑的资源占比情况。

比如下面手 模块的描述

定义出核心关键模块之后，我们需要进一步解释其资源使用的合理性。这里我们主要针对最常见的处理类和存储类两类模块来说明，其他比如吞吐量类，缓存类的模块可以依此类推。
针对处理类模块，我们通常需要说明：

给出核心模块的资源模型，如单机每秒建立连接数，每秒包处理能力；
描述核心模块的当前瓶颈所在；
描述核心模块的设备类型；
描述核心模块的最大支撑能力，如单机峰值；
根据预估的业务指标结合模块单机处理能力来评估所需的设备数。

而对于存储类的模块，我们通常需要说明：

给出核心存储单元的资源模型，如每个存储单元所占用的字节数，每个存储单元包括哪些字段信息，主要字段的访问频次，每份数据存储份数等，并根据单份的模型结合业务后续预估的指标来估算总体的存储量；
描述核心存储单元的当前瓶颈所在。 

同时，针对架构分布上，由于公司资源的地理分布不平衡性，某些特定的地理区域由于历史和储备的原因，资源会较为紧缺，所以我们在架构评审的过程中也要对业务模块的物理分布情况来评估其合理性，比如如下两点：

描述总体现有架构模块的物理分布情况和容量模型，包括架构是否有化，其分布，数据的异地存储份数说明，以及容灾方式；
描述新增预算资源的分布模型以及是否可以异地化部署的评估。 

在过架构和模块的现状后，业务自己通常也会发现一些自己架构上的问题，这些可能是历史原因的遗留问题，也可能是技术进步发展了有一些更优的解决方案，所以我们在架构评审的最后可以针对这些问题来提出进一步的 优化，给自己定一个更优的目标，追求技术上更进一步。主要逻辑可以分为下面几步：

描述可能的柔性策略、优化手段和方法包括技术上和运营上的；
描述优化后的系统架构图和模型；
描述优化后的目标和成果

而在优化手段上，我们也可以结合公司其他业务常用的优化手段，梳理总结出一套可能的优化方法，供大家参考。

资源的最大化整合和复用：比如运用虚拟化，等技术，来讲设备的利用率发挥到最大优势，充分压榨单机的处理负载，提高单机的处理能力。
新技术和新处理框架：比如采用新的处理框架，从协议改为直接处理，从原来的同步改为异步处理，以及充分利用并行能力和可编程硬件相比软件处理的高效性来提高编码和压缩的效率等等，来提升单机的效率。
新协议和新格式的利用：这块在存储类服务中最场景，比如用压缩效率更高的来替代传统的，然后又采用更高的编码格式的图片来替代，这些新格式的出现对于日益增长的海量数据又是一个重要的优化手段。
存量和长尾业务的规整：腾讯公司到现在也经历了年的春夏秋冬，各种业务浮浮沉沉保守估计也有上千了，对于这种存量和长尾型的业务，我们如何对其进行适当缩容和最小化运营，甚至是推动其退隐下线，也是一个必要的优化手段。
提升资源管理和流转效率：比如资源直供模式，闲置设备，闲置时段的离线计算使用，比如如何有效的利用存储类设备的资源来进行计算，这些也都是架构评审优化中值得考虑的问题。

好了，前面关于设备上的架构评审流程和方式讲了这么多，相信如果大家都按这么思路来理解架构评审，再加上自己对业务和技术的充分理解，跟过的架构评审将不再是个问题，更多的是对大家技术的展现了。
设备先讲到这里，有机会我们继续来解析如何做带宽的架构评审。  ！

相关推荐精细化容量管理的设备成本优化之路榨干运营成本：一亿之后再省两亿常用机器性能评估工具本文总结自 在  连续三年做的转型主题演讲。
作者简介：

许峰

年软件开发、测试、管理经验。前文思海辉欧美事业群交付副总裁。热爱。专注帮助传统企业的转型，专注思想及实践的传播分享。中国首批  讲师，沙盘模拟《凤凰项目》《挑战埃及》培训师。

导读：作为一家典型的零售企业，从年开始在个别团队尝试实践，结果一路发展壮大，到现在位列家来源：采用领先企业的第三名第一名是，第二名是，甚至超越了，和这样的互联网或软件产品公司。所以，传统企业一样可以把做得很出色

公司背景：塔吉特百货公司英语： ，总部在美国明尼苏达州的明尼阿波利斯，是美国僅次於沃尔玛的第二大零售百貨集團。在年财富强企业排，亦是标准普尔指数成份股。也有非常庞大的组织，包括个数据中心，数千名员工，以及从大型机到手持设备的复杂而分散的系统。

缘起：年
的之旅可以追溯到年。可以说是由一个对公司现状不满意的小组开始的，这就是的开发小组。
是对获取内部数据如此复杂及耗时不满的一个替代尝试。但该小组 尤其是负责人女士 很有理想，他们不仅希望提供统一的接口供其他系统调用，而且还要用和原来不同的开发方法来完成，尤其是敏捷和的相关实践。
所以从年开始，就有了第一次对持续集成，基础设施暨代码，社会化编码，还有文化的探索。

年：开始从一个小组尝试一些的实践
几个重点：

·     从开始可以说是开启的一个很好的选择，女士也认为基于服务的架构  是的基础。
·     把做好很困难，这里尤其涉及到思维习惯的转变。但这个是下一步的基础，所以他们花了几个月的时间建立起了这一习惯。的建立使该小组可以做到频繁发布。
·     关于基础设施暨代码：没有从容器开始当时也没有，更多的是在版本控制系统里把生成和配置环境的代码维护起来，作为部署的一部分实践管理起来。
·      社会化编码：这里指的是采用敏捷里的相关实践，比如工作可视化，提交实践，还有 而不是等。
·     文化方面：强迫自己脱离舒适区，不断试错以及对失败的不同态度，不接受平庸的文化，划出的工作时间用来学习和尝试新技术新方法。另外，领导要保护好自己的组员，让他们可以自由创新，而不担心后果。

草根生长：年
到了年，之前一年这一个小组所做的尝试开始显现出威力。从开发出来数量，被调用的次数、范围，以及交付速度每周次发布上都在组织的更大范围内被注意到。

年：团队成长及其所用实践被更多团队了解的一年
几个重点：

·     基于项目的成功，该小组开始思考把作为搭建企业系统的平台级调用而非只是数据读取接口。这样，采用版本管理的方式就不足够了，他们开始建立的环境目标：企业。
·     持续优化部署实践。任何成为部署障碍的事情都是他们去解决的对象。经过后继四年的努力，他们的部署流程更加一致、安全并且可重复。
·     之火在其他小组开始蔓延：几个有远见的团队开始合作，一起推动实践。

声势初显：年
到了年，在这一年里，之火在开始真正燃烧。他们组织了几次组织内部分享大会，另外也专门为中高层经理开了专场，并请到了像这样的业界大拿做嘉宾演讲。这使得企业高层开始重视，并给予组织层面的支持。
同样，也从企业走出去，积极参与外部相关社区活动，包括，骇客大赛，年也是第一次参加大会，此后三年他们年年都作为主讲嘉宾参加。这一做法也使得部门的招聘工作变得容易，因为技术人才都希望为新形态的企业服务。

年：新纪元的黎明– 广泛传播理念
另外这一年团队自己本身的交付成果也来了一次大爆发。包括数目达到个，每周可以发布多次，而在加发布次数增加的同时，事故数量却在下降，这和   中的调查是一致的。这也使得该小组底气十足，用业务结果来说话，让公司高层看到不是一小撮技术极客的玩具，而是有实实在在的、巨大的业务价值。
到了年底，的一些实践已经在组织中很多团队被使用，而且也得到了管理层的认可，但还不是的企业级标准实践。年的一次人事变动，让企业级的成为现实。
高层全力支持：年
年迎来了新的， 。很惊喜地看到敏捷和实践在已经有了一定的群众基础，于是开始大力推广。
这一次，终于把草根阶层里的提到了组织层面，要求的全部采用敏捷和，并给出最后期限：到年底，所有团队都必须是敏捷团队。同时，推动组织架构调整，从项目导向的团队重组为产品导向的团队。

年：更多的改变– 架构模块化和向公有云迁移
几个重点：

·     从以项目导向的组织变成产品导向的组织，每个产品团队从端到端负责一个产品或服务的开发。这也是现在大多数采用比较成熟的组织的做法。
·     所有开发以及运维相关的实践全部向敏捷和转型，这是组织层面自上而下的决定。
·     更有计划有策略地设定优先级：比如花时间解决技术债，并把以前的巨石架构模块化。不再只是草根阶层随意性的实验，而是更有策略的集体行为。
·     全面拥抱公用云。

平台化、微服务化：年
到了年，由于组织架构向产品化团队的转型，团队的任务也从提供数据调用接口转型成开发平台所需相关服务的开发和维护。这一点，笔者在以前服务过的客户身上也看到同样的转型。其实，就是建立企业自己的层应用，把底层的基础设施准备，环境配置，部署的发起等服务化。

年：持续进步 – 基础设施平台化
几个重点：

·     不可变基础架构。这里就涉及到引入容器技术。
·     融合私有云和公有云，提供统一平台级接口和调用服务
·     增加监控相关的工具实施。
·     目标是为开发团队提供全部自我服务的层功能。一个衡量指标是当一个新团队第一次采用该层服务后，有多快能够开始把代码发布到产品环境去。目标是个小时。
·     微服务化。

 – “道场”
最后重点介绍一下在非常成功的 – “道场”。道场是一个浸入式学习、体验和实践训练，一般持续个星期。某个想转型的团队会到一个专门的场地工作，有全职的敏捷教练或者导师全程指导。
在这个星期内，团战每天系统学习新的，和相关的方法、技术和工具，在有专人指导的情况下实践所学，并从实际的工作中学习成长。现在已经有三个专门的场地，分布在三个大的开发中心。这一“道场”训练，快速的帮助很多团队迅速转型，并能在最短时间内产生出理想的结果。

针对高管的一天“道场”
他们甚至还专门组织了给高管的天快速“道场”，连都要坐下来写代码。这一方式帮助一线员工和管理层之间互相理解，形成有效的透明、分享、持续学习的文化。
总结
总结下的转型之旅：

的转型之旅时间表
几个重点：

·     从为什么开始。是通过来提升企业的灵活性，竞争力和客户满意度。没有业务需求的很难成功。
·     有志者事竟成。不要过多担心你的企业是不是具备转型条件。事实证明，这些所谓的条件都是人创造出来的。从自身和自己的团队做起，用星星之火，可以燎原的心态来做。
·     开始的时候不一定要有个宏大的计划，先从一两个团队开始，做出成绩，并用成绩说话。
·     要有包容的心态，不要把变成一个小群体的玩具。积极传播、影响和吸引更多的人进来学习、实践。并且从中成长。文化的本质是开源文化。
·     技术实现的路径并不绝对。比如就是在才开始容器的应用，而前几期讲到的在实践一开始就把容器的应用作为重点。
·     浸入式的“道场”对组织快速转型起到了很重要的作用。“道场”给的理论学习和实践提供了一个完美结合的空间。企业要发起大规模转型的时候可以考虑。
·     高层的支持不是启动的必要条件，但要形成组织层级的行为，这一支持甚至推动是必不可少的。

可以说是传统企业向转型的代表。从草根开始，最后完全改变了企业的数字，完全是开源的精神原则。可谓转型不论出身，只有你想不想做。

本文转自 时代社区编译 | ·、爱心心、_校对 | _

下个月机器学习领域的顶会就要在大洋彼岸开幕啦，那么这次的又有什么值得关注的亮点呢？在新作中提出了优化的新概念 ，通过最小化使用不同的 的同一个的预测差异，提升对于不同 的不变性，来对进行优化。模型在对比实验中取得了非常惊艳的效果，同时在图像标注和半监督任务上也表现不俗，下面就跟随小编对这篇文章进行一发膜拜吧。

摘要
作为神经网络中的一类十分重要的架构，主要用于语言建模和序列预测。然而，的优化却相当棘手，比前馈神经网络要难的多，学界也提出了很多技术来解决这个问题。我们在我们中提出了一项叫做 的技术，主要通过利用来实现这个目标。具体来说，我们首先用不同的 对两个一模一样的进行训练，同时最小化它们预测的差异。通过这种方式，我们的正则项会促进的表示对 的不变性。我们证明了我们的正则项的上限是线性期望目标，而且线性期望目标已经被证明了可以解决在训练和推理阶段的差异导致的较大差异。我们在两个基准数据集  和上进行了序列建模任务以评价我们的模型，并且获得了十分惊艳的结果。我们也证明了这种方法可以为图像标注 和半监督任务带来显著的性能提升。
 前言
像网络   和门控循环单元    这样的循环神经网络都是处理诸如语言生成、翻译、语音合成以及机器理解等序列建模任务的流行架构。然而由于输入序列的长度可变性，每个时刻相同转换算子的重复应用以及由词汇量决定的大规模密集嵌入矩阵等问题的存在，与前馈网络相比，这些网络架构更加难以优化。也正是由于同前馈神经网络相比，在优化问题上遇到的这些挑战，使得批归一化以及它的变体层归一化，循环批归一化，循环归一化传播，尽管确实带来了很大的性能提升，但其应用依然没有像它们在前馈神经网络中对应的部件一样成功等 。同样的，的朴素应用等，也已经证明在中是无效的等，。因此，的正则化技术到目前为止依然是一个活跃的研究领域。
为了解决这些挑战，等人提出将仅用于多层中的非环式连接。 ，会在训练期间在整个序列中使用相同的。等，在权重矩阵上应用了操作。  等以类似的方式随机选择使用前一个时刻隐藏状态，而不是使用当前时刻隐藏状态。类似地，作为批归一化的替代，层归一化将每个样本内的隐藏单元归一化为具有零均值和单位标准偏差的分布。循环批标准化适用于批标准化，但对于每个时刻使用非共享的统计等，。
等人和等从另一方面证明激活正则化和时域激活正则化也是正则化的有效方法。
在我们中，我们提出了一个基于的简单正则化，我们称之为 。这个方法将最小化两个网络预测损失的等权重加权和这两个网络由两个不同在同一个上得到，并将两个网络的预测结果的差作为正则项相加。我们分析证明了，该方法的正则化目标等于最小化来自不同的 的预测结果的方差。该方法将会提升预测结果对于不同的不变性。同时，文章也讨论了我们的正则项和线性期望等、以及激活正则化等，的相关性，并且通过实验证明了我们的方法与这些相关方法相比带来的性能提升，第五部分的 将进一步解释这些方法。
  
在神经网络中是一种强大的正则化方式。它通常在密集连接的层上更有效，因为与参数共享的卷积层相比，它们更容易受到过拟合的影响。出于这个原因，是系列一个重要的正则化方式。然而，的使用在训练和推理阶段之间是存在的，因为推理阶段假设是用线性激活的方式来校正因子，因此每个激活的期望值都会不同。小编注：为了更好的理解这部分内容，大家可以参考      ，这篇文章从理论上分析了的模式和一般的求期望模式的。然后提出了将这个作为一种正则化方式，也就是说的优化目标就是要尽可能小。另外，带有的预测模型通常会随着不同 而变化。然而，在这种情况下理想的结果就是最后的预测结果不随着 的变化而变化。
因此，提出 的想法就是在训练一个神经网络模型时，保证在不同 下预测结果的变化尽可能的小。比如，假定我们有一个模型θ，输入是，θ 是该模型的参数，然后让表示预测模型，即给定一个在时间点的输入样例， 是
当前输入是 ，其中  是关于输入的一个函数，隐藏层的状态是跟之前时刻有关。同样的，是跟整个输入目标样本对在第时刻的损失值相关的。
在 中，我们采用两个相同的来同时前馈输入样本。这两个共享相同的模型参数θ，但是在每个时刻有不同的   和。这样在每个时间点，会产生两个损失值
因此， 整体的损失函数就可以由下面公式表示，

其中κ是正则化系数，是的维数，是 正则化项，具体表示如下，
我们采用蒙特卡洛采样来估计，其中，和计算值使用的是同一表达式。因此，额外的计算可以忽略不计。
我们注意到，如下面所示，我们正则化项的目标等价于最小化在不同 下，预测函数的方差附录中有证明
备注  假定 和均是独立同分布的， 和是上述的预测函数。
因此，
 相关工作
 线性期望相关工作
  分析研究显示下述两者之间的预期误差在样本上是有上限的，即在所有的 下的模型的期望值与使用平均的期望值之间的误差。基于这一结论，他们提出了明确地最小化差异我们在我们的该符号表达中采用了他们的正则式，
其中，是 。但是，基于可行性考虑，他们提出在实践中使用下列正则式进行替代，

特别地，这个式子是通过在网络中的两次前馈输入分别使用和不使用 ，以及最小化主要网络损失该损失是在有的情况下的和前面指定的正则项但是在无的网络中没有反向传播梯度来实现的。  的目标是最小化网络损失以及期望差异，这个期望差异是指来自独立的 的预测值和来自期望的 的预测值之间的差异。同时，我们的正则项目标的上限是线性期望，如下式所示附录中证明：

结果表明，最小化目标可以间接地最小化我们的正则项。最终如前文所述，他们仅在无的网络中应用了目标损失 。实际上，在我们的研究中参见第节，我们发现通过网络无反向传播目标损失 会让优化模型更难。但是，在该设置中，同时反向传播目标损失 能够获得包括性能增益和收敛增益的网络收益。我们认为由于在所用实例中，网络权重更有可能通过反向传播更新来达到目标，所以我们的正则项收敛速度会更快。尤其对于权重   更是如此，因为在这种情况下，权重将不会在训练的迭代中获得更新。
  – 相关工作
为了实现在半监督分类任务中提高性能的目标，  提出了 –。他们提出的模型和我们提出的模型相似，除了他们仅在其中一个网络中应用了目标损失 ，并且使用的是依赖时间的权重函数而我们使用常量，可以等价于是我们模型的深度前馈版本。他们实例的直觉是利用未标记的数据来最小化两种预测上的差异，即两种使用不同 的同一网络的预测值。而且，他们也在监督任务中测试了他们的模型，但是无法解释使用这一正则项带来的提升。
通过对我们的实例进行分析，我们证明了，最小化该正则项在 –中也使用了同最小化模型预测结果备注中的方差是等价的。此外，我们也证明了正则项同线性期望命题之间的关系。在第节，我们研究了基于没有在 –中使用的两种网络损失的目标的影响。我们发现在两个网络中应用目标损失 将使得网络获得关键性的更快的收敛。最后，我们注意到时域嵌入  ，提出的另一模型，声称对于半监督学习来说，是比 –更好的版本在自然语言处理应用中相当的棘手，因为保存所有时刻的平均预测值会十分消耗内存因为预测值的数目往往非常大数以万计。还有一点，我们证明了在监督学习的实例中，使用时间依赖的权重函数来代替一个常量值是没有必要的。因为标记的数据是已知的，我们没有观察到提到的问题，即当在早期训练的中太大时，网络会陷入退化。我们注意到寻找一个优化的常量值比调整时间依赖的函数更加容易，这也在我们的实例中进行了实现。
和 –的方法相似，我们的方法也和其他半监督任务相关，主要有  和  。由于半监督学习并不是本文要关注的部分，因此我们参考了的更多细节。

 实验
 语言模型
在语言建模的情形下，我们在两个基准数据集 数据集等，和数据集等，上测试了我们的模型。预处理操作参考了等用于语料库，并且用到了 等，用于数据集。
对于这两个数据集，我们都采用了等人描述的 层架构。 。 用于的模型中的参数数量是万，而的参数数量则是万，这是因为词汇量更大，我们要使用更大的嵌入矩阵。 除了这些差异之外，架构是相同的。

 词级任务

我们使用混淆度指标来评估我们的模型，并将我们获得的结果与现有的最好结果进行比较。表显示了我们的结果，在现有上，我们的方法达到了最先进的性能。

词级任务

在语言建模任务的情况下，我们的表现优于目前的最新技术水平。 表列出了最终结果。关于实验的更多细节可以在节中找到。
 图像标注
我们也把 应用到了图像标注任务上。我们使用著名的  模型作为等，。这里要强调的是，在图像标注任务中，图像编码器和句子解码器架构通常是一起学习的。但既然我们想把重点放在在中使用 的好处上，我们就使用了冻结的预训练 等，模型作为我们的图像编码器。这也就意味着我们的结果不能与其他最先进的方法直接比较，但是我们提供了原始方法的结果，以便读者可以看到我们的良好的表现。表提供了最终的结果。
我们认为，在这个任务中，κ值较小时，效果最好，因为图像标注编码器在开始时就被给予了所有信息，因此连续预测的方差会小于在无条件的自然语言处理任务中的方差。 可能在这里是有利的，主要是因为它对不同的平均梯度进行了平均，从而更新权重频率更快。
   模型简化测试
在本节中，我们的目标是研究与我们方法密切相关的现有方法。      ，Π   和    我们所有的 小编注： 是为了研究模型中所提出的一些结构是否有效而设计的实验都是采用一个单层，使用相同的超参数和模型结构。
 线性期望 
第二部分已经讨论了我们法方法和方法的联系。这里我们进行实验来研究使用正则化和我们的正则化性能上的差异。除了，我们还研究了一个的改进版。就是跟的用法相似，将应用在两个相同的上在原作者的实验中只是在一个上用了。因此我们得到了一个没有任何正则化方式的基准模型。图画出了这几种方法训练过程的曲线。与其他方法相比，我们的正则化方法在收敛性上表现的更好。而在泛化性能上，我们发现和相似，而基准模型和表现得更差。有趣的是，如果一起看训练和验证曲线，似乎还有待进一步的优化。
 Π
因为Π和我们的算法相似即使它是为前馈网络中的半监督学习而设计的，所以我们为了明确我们算法的优势，分别从定性和定量的角度研究了它们在性能上的差异。首先，基于  任务，我们运行了单层和层来在语言建模上对两种算法进测试比较。图和显示了测试结果。我们发现我们的模型比Π收敛速度明显加快，我们相信这是因为我们采用两个网络Π相反反向传播目标损失，导致了更多的采用基于目标梯度的参数更新。

尽管我们设计的算法是专门来解决中的问题，但为了有一个公平的对比，我们在半监督任务上也与Π做了对比。因此，我们使用了包含类由大小图像组成的数据集。参照半监督学习文献中通常的数据拆分方法，我们使用了张标记的图片和张无标记图片作为训练集，张标记的图片做验证集合张标记的图片做测试集。我们使用了原版的层残差网络结构，网格搜索参数
，
率在{，，，}，然后保持剩下的超参数不变。我们另外测验了使用无标记数据的重要性。表给出了结果。我们发现我们算法的表现和Π几乎一样。当无标记数据没有使用时， 仅仅比普通的表现得要稍微好些。
激活正则化和时域激活正则化分析
  的作者们研究了激活正则化的重要性，和在中的时域激活正则化，如下所示，

表：基于模型在改变的半监督任务数据集的准确率。我们发现我们提出的算法和模型有同等的表现。当未标记数据没有被使用，传统会破坏性能，但是 提供了略好的结果。这意味着当缺乏数据和不得不使用额外的正则方法时，我们的方法是有利的。

图：研究：使用词级模型的单层参数的训练左和验证右混淆度。显示了基准模型、时域激活正则化、预测模型、激活正则化和 我们的算法的学习动态曲线。我们发现与对照的正则项相比，收敛速度更快，泛华性能更好。
其中，是在时刻时的输出激活因此同时取决于当前输入和模型参数。注意和正则化应用在的输出上，而我们的正则化应用在的输出上。但是，因为我们的正则项能够分解如下：

并且，封装了一个项和点积项，我们通过实验确定了在我们的方法中的提升并不是单独由正则项决定的。目标也有一个相似的争论。我们在上运行网格搜索，包括在  中提到的超参数。我们在提出的正则项中使用。而且，我们也在一个正则式为正则项上进行了比较，以进一步排除仅来自于正则项的任何提升。基于这一网格搜索，我们选择了在验证集上对所有正则化来说最好的模型，另外还报告了一个未使用已提及的种正则化的基准模型。学习动态如图所示。与其他方法相比，我们的正则项在收敛和概括期间都表现更好。当描述的任意正则项被应用时，平均隐藏态激活减少如图所示。
    语言模型比较
正如小节所述，由于等人的影响，我们要确保 能够超越现有的方法不仅仅是因为广泛的超参数网格搜索。因此，在我们的实验中，我们保留了原始文件中提到的绝大多数超参数，即嵌入和隐藏状态大小，梯度裁剪值，权重衰减以及用于所有层的值词向量上的，层间的输出，最终的输出和嵌入。

当然，也进行了一些必要的变化：

和的系数必须改变，因为 也影响的激活如小节所述  我们没有进行网格搜索来获得最好的值，而是简单地去除了和正则项。
由于我们需要两倍的内存，所以的被减小了一半，从而让模型产生大致相同的内存量需求，并且可以安装在同一个上

最后一项变动的地方是改变的非单调间隔超参数。我们在∈{}上进行了一个网格搜索，并且在取最大值和的时候获得了非常相似的结果。因此，我们的模型使用普通优化器的训练时间要长于原始模型。
为了确保我们的模型效果，我们在数据集上通过使用不同种子的原始超参数不进行微调运行了个学习程序来计算置信区间。平均最佳验证混淆度为±，最小值为。测试混淆度分别为±和。我们的得分分验证混淆度和分测试混淆度比最初的得分好。
由于计算资源有限，我们在数据集对 运行了一次单独的训练程序。在这个实验中，我们使用数据集的最佳超参数κ= ，非单调间隔 = ， 减半。
我们证实使用会对有好处等，。然而，这是一个非常耗时的做法，因为在这个附加的学习过程中可能会使用不同的超参数，所以通过广泛的网格搜索而获得更好的结果的可能性更高。因此，在我们的实验中，我们使用与官方存储库中实施的相同的程序甚至没有使用 。表中列出了的重要性。
我们认为，运行网格联合搜索所有超参数可能会获得更好的结果改变率可能是尤其有利，因为我们的方法就明确地使用了。然而，我们这里的目的是排除仅仅因为使用更好的超参数而表现更好的可能性。
 结论
在论文中，我们提出了一个叫做 的简单正则化方法，通过作为正则项来减少模型在不同的 上预测结果的方差。通过实验证明了我们的模型具有更快的收敛速度，同时在基准语言建模任务上取得了最先进的成果。 我们也分析研究了我们的正则项和线性期望  等，之间的关系。我们进行了一系列的 研究，从不同的角度评估了模型，并从定性和定量的角度将其与相关方法进行了仔细比较。

论文链接   
本文来源于  科技大本营微信公众号最近我负责开发了一个跟相机有关的需求，新功能允许用户使用手机摄像头，快速拍摄特定尺寸：或：的照片，并支持在拍摄出的照片上做贴纸相关的操作。由于之前没有接触过相机开发，所以在整个开发过程中踩了不少坑，费了不少时间和精力。这篇文章总结了相机开发的相关知识、流程，以及容易遇到的坑，希望能帮助今后可能会接触相机开发的朋友快速上手，节省时间，少走弯路。
一中开发相机应用的两种方式
 系统提供了两种使用手机相机资源实现拍摄功能的方法，一种是直接通过调用系统相机组件，这种方法快速方便，适用于直接获得照片的场景，如上传相册，微博、朋友圈发照片等。另一种是使用相机来定制自定义相机，这种方法适用于需要定制相机界面或者开发特殊相机功能的场景，如需要对照片做裁剪、滤镜处理，添加贴纸，表情，地点标签等。这篇文章主要是从如何使用相机来定制自定义相机这个方向展开的。
二相机中关键类解析
通过相机实现拍摄功能涉及以下几个关键类和接口：
：最主要的类，用于管理和操作资源。它提供了完整的相机底层接口，支持相机资源切换，设置预览拍摄尺寸，设定光圈、曝光、聚焦等相关参数，获取预览拍摄帧数据等功能，主要方法有以下这些：

：获取实例。
：绑定绘制预览图像的。是指向屏幕窗口原始图像缓冲区 的一个句柄，通过它可以获得这块屏幕上对应的，进而完成在屏幕上绘制的工作。通过可以将和连接起来，当和连接后，获得的预览帧数据就可以通过显示在屏幕上了。
设置相机参数，包括前后摄像头，闪光灯模式、聚焦模式、预览和拍照尺寸等。
开始预览，将底层硬件传来的预览帧数据显示在绑定的上。
停止预览，关闭底层的帧数据传递以及上的绘制。
释放实例
     这个是实现相机拍照的主要方法，包含了三个回调参数。是快门按下时的回调，是获取拍照原始数据的回调，是获取经过压缩成格式的图像数据的回调。

：用于绘制相机预览图像的类，提供给用户实时的预览图像。普通的以及派生类都是共享同一个的，所有的绘制都必须在线程中进行。而是一种比较特殊的，它并不与其他普通共享，而是在内部持有了一个独立的负责管理这个的格式、尺寸以及显示位置。由于线程还要同时处理其他交互逻辑，因此对的更新速度和帧率无法保证，而由于持有一个独立的，因而可以在独立的线程中进行绘制，因此可以提供更高的帧率。自定义相机的预览图像由于对更新速度和帧率要求比较高，所以比较适合用来显示。
：是控制的一个抽象接口，它能够控制的尺寸和格式，修改的像素，监视的变化等等，的典型应用就是用于中。通过方法获得 实例，通过后者管理监听 的状态。
接口：负责监听状态变化的接口，有三个方法：

 ：在创建后立即被调用。在开发自定义相机时，可以通过重载这个函数调用、，来实现获取相机资源、连接和等操作。
       在发生或变化时调用。在开发自定义相机时，可以通过重载这个函数调用来开启相机预览，使得预览帧数据可以传递给，从而实时显示相机预览图像。
 ：在销毁之前被调用。在开发自定义相机时，可以通过重载这个函数调用，来实现停止相机预览及释放相机资源等操作。三自定义相机的开发过程
定制一个自定义相机应用，通常需要完成以下步骤，其流程图如图所示：
检测并访问相机资源 检查手机是否存在相机资源，如果存在，请求访问相机资源。
创建预览类 创建继承自并实现接口的拍摄预览类。此类能够显示相机的实时预览图像。
建立预览布局 有了拍摄预览类，即可创建一个布局文件，将预览画面与设计好的用户界面控件融合在一起。
设置拍照监听器 给用户界面控件绑定监听器，使其能响应用户操作如按下按钮 开始拍照过程。
拍照并保存文件 将拍摄获得的图像转换成位图文件，最终输出保存成各种常用格式的图片。
释放相机资源 相机是一个共享资源，必须对其生命周期进行细心的管理。当相机使用完毕后，应用程序必须正确地将其释放，以免其它程序访问使用时，发生冲突。图 定制自定义相机的过程对应到代码编写上可以分成三个步骤：第一步：在中添加相关功能使用的权限，具体声明有以下这些：第二步：编写相机操作功能类。采用单例模式来统一管理相机资源，封装相机的直接调用，并提供用于跟自定义相机做交互的回调接口，其功能函数如下，主要有创建\释放相机，连接\开始\关闭预览界面，拍照，自动对焦，切换前后摄像头，切换闪光灯模式等，具体实现可以参考官方文档。第三步：编写自定义相机，主要是定制相机界面，实现交互逻辑，如按钮点击事件处理，资源切换，镜头尺寸切换动画等。这里需要声明一个对象来实时显示相机预览画面。通过及其接口来一同管理屏幕和相机资源的连接，相机预览图像的显示关闭。四 开发过程遇到的一些坑
下面再讲讲我在开发自定义相机时踩过的一些坑： 设为竖屏时，预览图像颠倒度。


说明这个问题之前，先介绍下手机上几个方向的概念：屏幕方向：在系统中，屏幕的左上角是坐标系统的原点坐标。原点向右延伸是轴正方向，原点向下延伸是轴正方向。相机传感器方向：手机相机的图像数据都是来自于摄像头硬件的图像传感器，这个传感器在被固定到手机上后有一个默认的取景方向，如下图所示，坐标原点位于手机横放时的左上角，即与横屏应用的屏幕方向一致。换句话说，与竖屏应用的屏幕方向呈度角。
图 相机传感器方向示意图相机的预览方向：由于手机屏幕可以度旋转，为了保证用户无论怎么旋转手机都能看到“正确”的预览画面这个“正确”是指显示在预览界面的画面与人眼看到的眼前的画面是一致的，系统底层根据当前手机屏幕的方向对图像传感器采集到的数据进行了旋转处理，然后才送给显示系统，因此可以保证预览画面始终“正确”。在相机中可以通过设置相机预览方向。在默认情况下，这个值为，与图像传感器一致。因此对于横屏应用来说，由于屏幕方向和预览方向一致，预览图像不会颠倒度。但是对于竖屏应用，屏幕方向和预览方向垂直，所以会出现颠倒度现象。为了得到正确的预览画面，必须通过将相机的预览方向旋转，保持与屏幕方向一致，如图所示。
图 相机预览方向示意图红色箭头为预览方向，蓝色方向为屏幕方向相机的拍照方向：当点击拍照按钮，拍摄的照片是由图像传感器采集到的数据直接存储到上产生的，因此，相机的拍照方向与传感器方向是一致的。
 预览图像、拍摄照片拉伸变形
说明这个问题之前，同样先说一下几个跟相机有关的尺寸。尺寸：即自定义相机应用中用于显示相机预览图像的的尺寸，当它铺满全屏时就是屏幕的大小。这里显示的预览图像暂且称作手机预览图像。
：相机硬件提供的预览帧数据尺寸。预览帧数据传递给，实现预览图像的显示。这里预览帧数据对应的预览图像暂且称作相机预览图像。：相机硬件提供的拍摄帧数据尺寸。拍摄帧数据可以生成位图文件，最终保存成或者等格式的图片。这里拍摄帧数据对应的图像称作相机拍摄图像。图说明了以上几种图像及照片之间的关系。手机预览图像是直接提供给用户看的图像，它由相机预览图像生成，拍摄照片的数据则来自于相机拍摄图像。图 几种图像之间的关系下面说下我在开发过程中遇到的三种拉伸变形现象：、手机预览画面中物体被拉伸变形。、拍摄照片中物体被拉伸变形。、点击拍照瞬间，手机预览画面会停顿下，此时的图像是拉伸变形的，然后预览画面恢复后图像又正常了。
现象的原因是和的长宽比率不一致。因为手机预览视图的图像是由相机预览图像根据大小缩放得来的，当长宽比不一致时必然会导致图像变形。后两个现象的原因则是和的长宽比率不一致所致，查了相关的资料，发现其具体原因跟某些手机相机硬件的底层实现有关。总之为了避免以上几种变形现象的发生，在开发时最好将、、三个尺寸保证长宽比例一致。具体实现可以先通过和获得相机硬件支持的所有预览和拍摄尺寸，然后在里面筛选出和的长宽比一致并且大小合适的尺寸，通过来更新设置。注意：市场上手机相机硬件支持的尺寸一般都是主流的或者，所以尺寸不能太奇葩，最好也设置成这样的长宽比。
 各种

前两个的原因是：相机硬件在聚焦和拍照前必须要保证已经连接到，并且开启相机预览，有收到预览数据。如果在还没有执行 或者未调用 之前就调用或，就会出现这个运行时异常。对应到自定义相机的代码中，要注意在拍照按钮事件响应中执行或前，一定要检验有没有设置预览并开启了相机预览。这里有个方法可以判断预览状态：是预览帧数据的回调函数，它会在收到相机的预览帧数据时被调用，因此在里面可以设置是否允许对焦和拍照的标志位。还有一点要注意，在执行过程中会执行来获取拍摄帧数据，表现为预览画面卡住，而如果此时用户点击了按钮的话，也就是调用，也会出现上面的，因此在开发时，可能还需要屏蔽拍照按钮的连续点击。第三个则涉及图像的裁剪，由于要支持：或者：尺寸镜头，所以会需要对预览视图进行裁剪，由于是竖屏应用，所以裁剪区域的坐标系跟相机传感器方向是成度角的，表现在裁剪里就是，屏幕上的方向，对应在拍摄图像上是高度方向，而屏幕上的方向，对应到拍摄图像上则是宽度方向。因此在计算时要一定注意坐标系的转换以及越界保护。
 前置摄像头的镜像效果
相机硬件有个特殊设定，就是对于前置摄像头，在展示预览视图时采用类似镜面的效果，显示的是摄像头成像的镜像。而拍摄出的照片则仍采用摄像头成像。看到这里，大家可能会有些怀疑，不妨现在就试试自己手机上的前置摄像头，对比下预览图像和拍摄出照片的区别。这是由于底层相机在传递前置摄像头预览数据时做了水平翻转变换，即将方向镜像翻转度。这个变化对之前竖屏预览的方向也会造成影响，本来对于后置摄像头旋转度即可使预览视图正确，而对前置摄像头，如果也旋转度的话，看到的预览图像则是上下颠倒的因为方向翻转了度，因此必须再旋转度，才能显示正确，如图所示，大家可以结合之前相机预览方向的示意图一起理解。图 前置摄像头的预览方向示意图        此外，由于拍摄图像并没有做水平翻转，所以对于前置摄像头拍出来的照片，用户会发现跟预览时所见的是左右翻转的。这个在一定程度上会影响用户体验。为了解决这个问题，可以对前置摄像头拍摄的图像在生成位图文件时增加一个水平翻转矩阵变换。
 锁屏下相机资源的释放问题
为了节省手机电量，不浪费相机资源，在开发的自定义相机里，如果预览图像已不需要显示，如按键盘切换后台或者锁屏后，此时就应该关闭预览并把相机资源释放掉。参考官方文档，当变成可见时，会创建并触发接口中回调函数。而变成不可见时，则会销毁，并触发回调函数。我们可以在对应的回调函数里，处理相机的相关操作，如连接、开启关闭预览。 至于相机资源释放，则可以放在的里执行。相应的，要重新恢复预览图像时，可以把相机资源申请和初始化放在的里执行，然后通过创建，将和相连并开启预览。但是在开发过程中发现，对于按键切后台场景，程序可以正常运行。对于锁屏场景，则在重新申请相机资源时会发生，说相机资源访问失败。那么原因是什么呢？我在代码里增加了调试， 检查了代码的执行顺序，结果如下：        在自定义相机页面按键时的执行流程：

程序运行按键 
调用的顺序是 
调用了方法 
然后再切回程序 
调用的顺序是 
调用了方法 
而对于锁屏，其执行流程则是：
只调用方法 
解锁后调用方法 
中的所有方法都没有执行 

问题找到了，由于锁屏时，的回调方法没有执行，导致相机和预览的连接还没有断开，相机资源就被释放了，所以导致在重新申请相机资源时，系统报。根据上面的文档，推测是锁屏下系统并没有改变的可见性，于是我尝试在和时通过手动设置的属性，结果发现可以正常触发回调函数了。由于在切后台或者锁屏时，用户本来就应该看不到，因此这种手动更改的可见性的方法，并不会对用户的体验造成影响。

文章来自公众号：空间终端开发团队


相关推荐
深度了解  ，你准备好了吗？
视频创业那些坑
关于图片资源瘦身的奇思妙想自从吴一凡创意视频上线后，越来越多的创意都通过视频的方式展现，如果视频时长比较长，清晰度高，会导致视频体积比较大，这样在播放视频的时候回导致黑屏一段时间，有么有好的优化方案呢？
视频精简下减少时长？创意不同意，要不把视频压缩下，挖槽那么模糊，创意不同意，好吧，还有其他的优化方案吗？
  是苹果公司实现的基于的流媒体传输协议，可实现流媒体的直播和点播。原理上是将视频流分片成一系列下载文件。特点是将流媒体切分为若干  片段比如每秒一段，然后通过一个扩展的  列表文件将这些  片段集中起来供客户端播放器接收。
支持
 
 
怎么把文件切分成若干片段？
我这里使用了，去官网下载你需要的系统版本，解压到本地\，配置环境变量\\，窗口输入  如有信息则说明成功，可以进行接下来切分了。

、首页需要切分的视频必须是视频编码为，音频编码格式的，可通过  命令来查看文件编码
 
、如果不是格式，可用如下命令转
       
、将切分为切片
           _  _  _  
_每隔十秒切一个文件
 
切片完成后入下所示：
 
前端页面可以用标签引入扩展文件将这些片段集中来供客户端播放了。
  =
案例原来用的时，那种同步压缩修改、实时动态刷新页面的感觉真的太棒了。但如果使用的话，配置非常繁琐，所以，一番折腾后，于是有了的配置方案，效果见下图，项目地址：_


目的
我使用开发，想开发时对所有资源进行压缩并同步到浏览器端，搜索一遍，都不是太符合我的项目要求。于是看着文档结合终于折腾完毕。
配置
下面说下我的配置方法：
我的目录结构：
├──      
├── 
│   └──    启动
├──       编译压缩目录部署目录
│   ├── 
│   ├── 
│   ├── 
│   ├── 
│   └──    第三方库目录安装
├──   前端安装库
├──    配置文件
├── 
├──         开发目录 
│   ├── 
│   ├── 
│   └──      
├── 
│   ├── 
│   └── 
└──        
    ├── 
    └── 
文件内容：
{
   
   
   
   
   {
     
     
     
     
     
     
     
  }
   {
     
     
     
     
     
     
     
     
     
     
     
     
     
     
  }
   {
      \   \   
  }
   
   
}

文件
 
  = 
  = 
  = 
  = 
  = 
  = 
  = 
  = 
  = 
  = 
  = 
  = 
  = 
  = 
  = 

 删除文件
  {
       
}

 压缩
  {
   
      { }
      
}

 压缩
   {
   
      {
            __   
      }
      
      
      
}


 压缩
   {
     
        
        
        {   }
        
}


 压缩
  {  
           引入所有需处理的
    {       }      压缩图片
     如果想对变动过的文件进行压缩，则使用下面一句代码
     {       } 
    
     {  图片处理完成 }
}


 浏览器同步，用端口去代理的端口
   {
   {
     
         
          
         
  }
}

 开启服务
   {

    = 

   {
     
  }   {
           
      
      {
      
       =  
    } 
  }
} 

  {

}

{
   将你的默认的任务代码放这

     监听所有文档
     

     监听所有档
     

     监听所有图片档
     
     监听
     

    创建实时调整服务器  在项目中未使用注释掉
    = 
    监听  目录下所有文档，有更新时强制浏览器刷新需要浏览器插件配合或按前文介绍在页面增加监听代码
    {
    
  }
}

文件
  = 
  = 
  = 
  = 
  = 
  = 

  = 
  = 

  = 

   
 __ 
  

       
__  


{   }

__ 

 
 

       
   {
    =   
   = 
  
}

  

   
   
  ===  {
      {
     || 
     {
       
       
    }
  }
}

   
     
    {
   || 
   {
     
     {}
  }
}


 = 

然后先在根目录下执行安装： ，使用时先运行 将文件压缩、打包、编译，然后再执行开启自动更新服务器。


相关推荐腾讯云上网络编程二之环境配置起因
作为“云”的概念，已经流行了很久。从使用的角度上看，似乎就是：写一个，然后可以直接传到服务器上，用户就能通过某个访问你写的了。——这确实极大的节省了开发和运维的工作量，因为这几乎完全不用去部署安装任何服务器端的软件，甚至数据库也给你装好了。但是因为各种各样的原因，在国内的使用并不非常广泛，有可能是因为没有好的服务提供商由于伟大墙的原因导致某些服务无法访问。另外，作为一个游戏服务器端的开发者，也在试图从的概念中，学习如何提高游戏开发、运营效率的方法。所以就有了以下的研究。

本文主要的研究对象是出品的 ，以及的两个产品。实际上微软、也有类似的，由于时间精力原因只是粗粗浏览，并未深入。另外国内如阿里云也有一些近似的服务，但由于名气不大，也不在这里描述了。
作为一个，我们可以注意到，主要会分成几个层面来看，能比较准确的把握其特性。否则纷繁的技术名词，各种支持方案，会让人眼花缭乱。这几个层面就是：

应用场景：一款希望解决的重点问题
开发支持：是一种允许用户的代码运行的服务，那么可以运行怎样的代码，怎样方便用户上传自己的代码或程序，如何管理这些代码，是一个重要的问题。
运维管理：最让人感到方便的，就是几乎都号称“无需用户干预”的自动化运维，不需要用户自己去部署服务器、配置软件等等，但这种能力到底是怎样，也是一个非常重要的部分。
关联配套：一个在上运行的程序，是完成不了太多的任务的，起码需要有一个数据库之类的存储软件。实际上的商业应用中，除了数据库以外，还可能需要大量其他的配套程序，才能让你的业务逻辑程序运行完整，比如，甚至这样的程序。由于号称“帮你运维”一切，所以很多都直接把这些服务也安装部署好给你用，你只要用服务商提供的接入参数，直接使用即可。那么服务商提供怎样的配套服务，有什么能力，是服务里面一个至关重要的特性，也是各种服务商“争奇斗艳”的主战场。


  

应用场景
自己的服务，是具备一整套“基础设施”的，包括应用如的运行框架、、等等广为人知的服务器端软件。所以  的设计目标，就是让用户可以很方便的使用这一整套“基础设施”。从某种意义上来说，为了使用的配套服务，可能会比托管运行自己的应用程序，更吸引人。的基础设施，一般都是以“分布式”为卖点，提供超大承载量，和高度可用性。如果要自己去重建这一整套体系，对于一般的公司来说都几乎是不可能的。但实际上真正需要用到这么大的承载量，也很可能不是“一般的公司”。不过慕名而来的使用者，在的保证下获得信心上的安慰，也是一种重要的价值。
开发支持
不愧是以技术著称的公司，其运行容器，支持\\\等等几乎所有主流的编程语言，及这些编程语言在应用程序方面的标准框架，如  。看到这里，不禁叹息于，游戏领域并没有什么“应用框架标准”——所以游戏服务器程序的模型真是五花八门无奇不有，这也让游戏服务的提供变得异常繁复困难。
提供的开发工具，可以帮助开发者很方便的测试和部署代码到上。这些开发工具包括一套结合的插件，以及一组命令上传部署工具。用户可以使用这些工具，好像开发测试本地程序一样来使用。当然使用之前还是需要配置自己在上的帐号之类的参数。


另外一个很有特色也许是缺点的地方，就是开发者只能在“沙箱”里运行自己的程序，因此你不能用到代码去操作、本地文件、线程等等“原生资源”。因为有这样的约束，所以开发者上传的可以被认为是“无损”的自动部署到不同的硬件、网络环境上。同时，也提供了大量的配套服务，用来补偿沙箱环境带来的功能缺失。
运维管理

的运维管理从代码部署开始就是全套的。首先是支持从这类代码管理库拉取程序部署，其次是可以部署到提供的全球机房，期间提供自动扩容和负载均衡。其中比较值得注意的是，它的运维环境还支持负载灰度和资源配额，也就是可以设置各种参数，来限制缓存空间、实例数、最大线程数、存储空间、使用带宽等等。这些配额并不是简单的基于的功能继承而来，而是可以针对应用容器，或者各种配套服务为目标来设置。
另外一个很棒的功能是所谓功能。几乎所有云服务商都会带统计功能，但是 因为是针对这种全托管沙箱服务做统计分析的，所以可以获得很多具体的服务统计的细节指标，而不仅仅是操作系统层次的、内存、带宽这种大路货。我们自己部署任何一个服务，对于特定的服务进程，也会想要详尽的统计分析数据，用以监控问题，如果是用，这些服务都是提供的，当然统计也是它的应尽职责。

作为一个 的容器，在运维配置工具上，提供了全套界面的操作软件——   ，可以配置诸如、静态资源、类型、根目录、等几乎所有的配置内容。用了多年的 配置文件终于可以束之高阁了。当然其他的管理服务，也都提供了的配置管理工具。如果你不想手工的去配置这些，也可以使用提供的接口，去用代码操作这些服务配置，这样你可以自己写一个喜欢的管理软件，或者是写个自动化的工具去做这类的配置工作。

关联配套
提供的配套服务，都是那些大名鼎鼎的系基础服务，分为两大类型，数十种细类：
存储服务

  ：对象存储服务
  ：在上的，由于是关系数据库，所以不能自动扩容
  ：以接口使用的分布式文件系统

辅助服务

定时任务：类似这种
：最常见的后端缓存服务
：一种“数据块”存储服务
 ：身份鉴权认证服务
各种服务，包括电子邮件、短信、语音等等……
全文搜索服务
图形处理的库
各种常用的服务器端编程库


从上面来看，最值得关注就是存储类服务，毕竟是处理大数据的互联网鼻祖。由于一般的商业互联网服务，都很依赖一个容量大、方便扩容的数据存储层，所以这套东西是非常有价值的。可惜作为游戏领域，数据大倒是大，就是其数据关系一般比较简单，就是玩家的存档数据而已，所以游戏开发商如果用这些、为基础的服务，从延迟性和成本上看，好像都不是特别有必要。
另外从辅助服务来看，细节到连都提供，更不用说各种服务器开发库，只有你想不到，没有他没准备到的。这对于开发者来说是一个很方便的地方，因为一来不需要到处找各种开源库，二来也无需费口舌去和同事统一各种开发库，只需要用的就好了。
接调研与下

本文来源于 韩大微信公众号  从年月日发布，过去了将近一年的时间，但是在工作中发现大家对 的接受程度并不高，这只是一个感觉，俗话说“没有调查就没有发言权”， 这两天通过微信小程序在微信群里做了一个调查，参与的人数大概人，从结果看大家都在等待  ， 期待  能够在、月间按时发布。
这次调查的问题就是针对大家对 的使用情况的调查，分为种情况，我直接上微信投票结果图：使用  的人数只有，计划使用  的比例达到， 没有计划去使用 的比例只有。从这个结果看大家还是非常期待  的。
 作为 的下一代平台，其中变化最大的就是  当前  的大多数热点话题都是围绕它的跨平台体验，虽然这是一项巨大成就，但如果你是常规  用户，编写了大量基本   代码，并打算继续使用熟悉的  和  环境，那么这就不是一个加分项。 这也就很好的解释了目前采用  的用户比例不高的原因。
回顾 年前的 团队在设计  框架时，采用了的大多数最佳实践，并在新框架中采用了这些做法。在此过程中，他们还引入了许多新内容，如编译代码和托管代码、自动回发和服务器控件。  采用同样的套路演进。常见最佳实践如初始加载配置数据、依赖关系注入、 包、基于声明的身份验证和  改进是 的原生特性。
 还具有不同的启动过程、更为模块化的请求响应中间件，以及用于定义控制器和视图的更为灵活的基础结构。  还是跨平台框架，可方便你开发并在 、 和  上部署应用程序。这样一来，  会强制你编写更优质的代码，即默认强制实现关注点分离，当然你也可以通过自律实现此目标，自律的方式在非常少数的。
对于任何形式的新项目产品的开发，  绝对是首选，  的已经和  对齐，这也就很好的解释了大多数用户计划采用  。然而，作为全新的框架，一些初始成本是不可避免的： 所有团队成员都必须精通此框架。此外，所有成员还必须精通“模型视图控制器 ”应用程序模型。作者：徐西宁，年毕业于华中科技大学，先后供职于上海三家知名和非知名外企，精通   和    大会讲师，开源项目前端架构师。

我叫小马，码农的马，我是一个码农。

作为码农，我曾经有一个梦想：发财。很快，现实给了我几个耳光，我明智地放弃了这个想法。

作为码农，我还有第二个梦想：用优雅的代码解决实际问题！

我的工作是用做开发。老板说，很简洁，很高效，是开发的很好的选择。

老板虽然经常忽悠我，但是，这一次他没有。用做开发真的很高效，实现的速度飞快。我感觉离第二个梦想近了一步。

开发的迭代很快，每次有新的，或者有 ， 我都需要重新部署测试服务器，交给小去测试。
小，，女，测试的高手，代码的白痴。
小总能找出我代码中的，让我明白我还没有做到用代码优雅地解决问题，这让我很恼火。同时，因为她不懂代码，不知道我的代码的依赖环境，所以，重新部署测试服务器的活，就一直落在我身上。

虽然小明眸善睐，我也愿意有机会跟她多唠几句。但是，部署测试服务器这事频繁发生，我也有忙不过来的时候。于是，我写了一个文档，当我实在忙的时候，小以及其他人也可以照这个文档来做部署。
版本部署步骤：
     连接到测试服务器
     运行命令查看进程列表，杀掉我们接下来要重新部署的
     到文件夹
      到 
      最新的代码
     确认已经被正确安装，并且版本=
     到文件夹，用安装依赖包
     运行
     运行
在我眼里，这个文档就两步：
     随便搞搞
     搞定
在小眼里，这个文档是天龙步：
     连接到测试服务器
     。。。
     。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。

  。。。。
  终于搞定
在新来的实习生看来，这个文档是迷踪步：

当大家看不懂这个文档，或者照着文档操作碰到问题的时候，还是会来问我，这显得我比较重要。但是，我的时间不断地被打断，这让我很难专注敲代码，更别说敲出“优雅的代码”。
于是，我把这个文档的步骤用脚本实现出来，这样，大家就不用阅读那个天龙步的文档，只要跑一下这个脚本就好了。生活一下子美好了很多。

哪知道，快乐的日子永远是短暂的，留下的只是无穷无尽的痛苦和长叹。
用脚本实现了自动化部署，也有人抱怨说脚本不会用。于是，我写了一个文档，教大家如何用这个脚本。
码农的世界就是这么残酷，我写脚本的本意就是不要再写文档，现在，我既要维护脚本，还要维护文档。

事实证明，这个脚本还是能发挥作用，节省了大家很多时间。大家喜欢这个脚本，也提出了更多需求，于是，我花了更多的时间，让这个脚本能处理更多的情况，变得更强大，当然也更复杂。我在码之外，还需要腾出更多时间维护这个脚本。

运维的兄弟小也开始用这个脚本在生产服务器上进行部署。但是，他面临的条件更加险恶，因为生产服务器上还运行着一些历史版本，这些历史版本跟现在的版本的依赖环境还有一些冲突，小需要更加小心翼翼，战战兢兢，如履薄冰。
虽说那是小的活，但是，作为一个有责任心的码农，我也不忍心看着兄弟挣扎不是？
都是劳动人民，我们要团结友爱。我们的目标是把麻烦解决好，而不是推卸出去。 

写更高质量的脚本，写更完善的文档，显然并不能解决这个问题。我的解决方案是：！
是一个轻量化的虚拟平台，可以让我很容易地把我的程序、我的程序配置、我的程序的依赖环境都封装在一个独立的程序包中，这个程序包被称为  任何安装了的系统上无论是   ， 都可以轻易地运行我的程序，不用再操心配置，不用再操心环境依赖以及跟现有环境之间可能的冲突，能够保证程序可运行，以及在不同环境下行为的一致性。
因为的引入，测试小可以很轻松地搞定测试的环境，运维小可以轻松地搞定生产环境的部署，而我，能够有更多的时间写“优雅的代码”。
这才是多方共赢！从此，小马，小和小幸福地工作在一起！

我叫小马码农的马我是一个码农我拥抱”腾讯云沙龙继月上海站，将于月日来到成都站，与游戏厂商和游戏开发者，畅聊游戏实时社交互动。期待您的光临！
游戏社交化是近年来游戏行业发展的重要趋势，实时互动的实现和社交平台的能力是游戏社交化的两大关键。游戏中玩家的沟通协作从最初的文字交流，逐渐发展为音、视频结合的多场景下的实时互动，是游戏中社交关系建立和维持的关键因素。另外，游戏社交需依托于平台，如何构建玩家间的社交网是各大游戏厂商的重要考虑点，这对平台的能力提出了很高的要求。
此站沙龙将和来宾分享在游戏音视频领域，腾讯的技术积累和布局，还邀请到腾讯运营专家，分享如何借助移动首次开放的社交资源和能力，帮助游戏提升用户价值。
 
腾讯游戏云产品总监王永和将分享腾讯云游戏生态产品规划及最新进展。腾讯云游戏业务中心除了为游戏提供灵活而稳定的部署解决方案外，同时也秉承腾讯公司”开放“的战略理念，将腾讯内部领先的游戏开发技术和丰富的游戏服务资源，向外部游戏开放，并共享大平台优质渠道资源、以及提供丰厚的专项扶持金，助力您的游戏业务腾飞。
腾讯互娱研发部资深产品经理张程将介绍服务于百款腾讯精品手游大作的专用语音组件。作为游戏语音领域的绝对领先者，团队在语音核心技术研发，以及如何贴近游戏玩法进行技术应用等方面均有深入体会。本次分享将配合数款游戏的典型应用案例，揭秘研发逻辑，为你阐述是如何做到一款“懂游戏的语音引擎”，同时此次分享也会揭开关于游戏视频服务的面纱。
腾讯游戏云资深架构师贺广平将通过《部落冲突》等全球同服游戏席卷海内外的案例，来剖析腾讯云如何帮助游戏厂商更好的应对全球化挑战。本议题从全球化游戏语音功能为切入点，全面介绍腾讯云为全球同服游戏架构提供的相关解决方案。
手游运营能力开放业务负责人梁育榕，将针对手游上的社交能力、用户规模、运营效果，介绍腾讯游戏如何运用社交能力为玩家构建完整的生态闭环。同时，手游将通过腾讯云首次向广大游戏厂商开放核心社交资源，帮助游戏在手游平台深度挖掘用户价值。
参会指南：

报名方式：识别下方二维码，或访问 填写报名问卷。我们将在会前发送确认短信给参会嘉宾。如有关于沙龙参会与合作的问题，欢迎联系和。

访问沙龙官网 ，了解最新沙龙资讯和更多往期回顾。导语
公司目前有几十万台左右服务器，腾讯监控平台平均每天采集亿监控数据，本文将从当前存储架构存在的问题出发，介绍使用大数据平台组件存储监控数据的实践历程。
背景
近几年开源的大数据处理系统已经逐步发展到一个比较成熟的阶段了，各类大数据处理的场景都有了相应的解决方案，如同  在当今互联网公司中的关系数据存储广泛应用地位一样。
公司目前有几十万台量级的服务器， 系统按  分钟粒度采集监控数据，平均每天采集  多亿的数据点。本文将从当前存储架构存在的问题出发，介绍从尝试使用到自行设计存储方案来存储  服务器海量监控数据的实践历程。
 当前存储架构分析
我们首先看下当前的  的  分钟粒度数据存储架构。 上报的数据，通过  从  数据表中查询索引和路由规则 ，分发到不同的数据存储结点上。数据节点  收到数据后先缓冲到内存中，内存的数据定期  到文件系统中。

这套架构优点很明显，设计简洁、有最新数据缓存、数据分布式存储、可横向扩展，同时完全自研，各自实现细节可控。但同样存在一些问题：
数据节点  程序异常，会导致内存缓存数据丢失，进而丢失监控数据，需要从  端或者对等集群恢复；
数据节点磁盘故障或机器故障，持久化的  也会丢失，数据同样需要从对等集群中恢复，数据访问入口需要人工介入切换集群；
数据格式和占用空间固定，不具备监控粒度扩展性，空的数据点也要占据存储空间，数据不支持压缩；
索引和路由规则这类依赖外部  系统，这些  的可用性影响整个系统。
 存储引擎优势
 是  生态栈中的分布式列存储数据库，基于  模型和  存储引擎，用于海量数据的随机读写，在业界的大规模监控系统的时序数据存储中已有成熟应用案例，如某度和某宝 。
图   的存储原理
我们看下使用  存储有何优势：
数据高可靠，高可用。数据在写内存的同时，会写一份  到  中，如果某台  异常，内存中的数据会从  中自动恢复。持久化数据保存在  中，默认持有  个副本，无单点丢失数据风险。
高性能。 存储引擎保证了  超高的写性能，实际上前面介绍的  自研存储系统也是一种简化版的  存储引擎，因而同样有如此高的性能。
天然的水平伸缩，高可扩展性。存储层 ，数据服务层  均支持自由伸缩扩容。
数据表支持压缩，空列不占存储空间。
 尝试及瓶颈分析
在准备使用  存储  监控数据之初，我们曾尝试使用基于  的开源时序数据库  来直接存储服务器监控数据。但  到  的时候整个  集群就已超负荷运转、响应缓慢了，完全无法满足如此大规模的存储需求。
我们仔细分析了  在超大规模时序数据存储上存在的主要瓶颈：
所有  跟  都要经过  表的转换，此设计本意是为了压缩  大小，但引入较大的计算资源开销；
数据写入的  机制及原始  设计存在较大的性能问题，这在后面部分会详细分析；
所有的数据都放在同一张表里，不利于基于时间对数据进行维护操作，比如对一个月前非热点数据进行抽样存储，且无法控制  数，也就无法控制 ，对性能影响较大；
基于这些原因，我们最终决定直接使用  进行  服务器监控数据存储。
 监控存储设计实践
 的使用在整个  生态栈中属于较为复杂的一个类别。 监控存储设计结合了业界使用  的一些成熟的实践经验，同时参考和改进了  在使用  时的比较好的设计思想，以支撑  监控数据的大规模读写。
   预切分
 中的数据会按  所处范围分布在各个  中，新建表的时候只有一个 ，并随着  变大开始分裂。这在过程中会消耗大量在网络、磁盘  等资源，对集群会有较大性能影响。同时由于开始期间只有少量 ，数据的读写很容易全落在单台  上，造成  现象，严重影响读写性能。因此对存储表进行  预切分处理是  使用中十分重要的一步。
这里我们将每天的数据表预切分为  个 ， 以{，  … }，即二进制的  为 ，第一个   范围为 …，第二个   范围为 …，以此内推。结合接下来这节中的   设计就可以均匀地将数据分散在各  中。
   和列设计

 设计由   服务器     监控特性   的方式组成。
 是使用服务器  进行  后对单表初始  数进行求余所得的一位字节，用来将不同服务器的监控数据均匀分布在表的各个  中；
 第二部分为服务器 ，服务器监控数据查询通常是查询指定服务器的某些特征，因而将服务器  放在第二部分可以大幅提高查询效率；
 实际上是一个 ，用于将一段时间内的数据存放在同一行；
_ 为特性 ，区分具体监控指标。

这里使用一个字节  作为列族，列族名称本身并没什么含义，主要强调只使用一个列族存储数据，尽量小的名称作为名字。使用多列族每个  会对应有多个 ，会加重内存消耗，在此场景下不适用。
列名在  中称 为时间偏移，与  中的  一起组成  标识数据点的精确时间。
  基于列的 
在介绍列  之前，我们先看下  数据的具体存储结构：
表结构与存储结构
如图所示为表结构以及对应的存储结构示例，在  或表格存储这类底层采用  的数据库中，表数据会按列存储。每行中的每一列在存储文件中都会以  的形式存在于文件中。其中  的结构为：行主键 列族 列名， 为列的值。该种存储结构的特点是：
、每行主键会重复存储，取决于列的个数；
、列名会重复存储，每一列的存储都会携带列名；
、存储数据按 排序，相邻的 会存储在相邻的块中。
可以注意到，在  的物理存储中，每一列都会存储该列的  和列族信息，在列很多的情况下这些重复的信息将占用大量的存储空间。因此这里参考  的做法，将同一  内的所有列合并压缩为一列注意这里说的列  与  本身的  是完全不同的， 的  是指将多个小的  合并为一个大的 。
 的列  由数据量大小和时间间隔共同触发，在并发写操作巨大的时候会对  产生很大的读写压力，并且会阻塞写操作，性能表现较差。 版本加入的  机制更是每一次写操作产生一次读操作，对  利用很不经济，写入量大时会对整个集群的读压力造成巨大影响。

基于这些原因， 监控数据在每天凌晨对前一天的数据表进行全表扫描，并对每行数据的列名和  进行合并，压缩为一列。在现网实际环境中可以看到，列压缩后的数据表比压缩前占用存储空间减少接近，如下图。

   性能调优
 性能调优是个比较复杂的事情，网上可以看到很多专门讲  调优的文章。这里仅挑出几个比较立竿见影的点来分享。
 和  大小。尽量调大  的  大小，如写入量远大于查询量，可以增大  与  的比例，如    。原因是  基于   的存储引擎，数据会先缓存至  再刷入磁盘
 压缩。对数据表启用  压缩，可以减少磁盘 ，增大写入性能
 自身的  线程数。 在  和  的时候会对  进行排序操作，适当增大  线程，可更加充分利用 ，增加性能。具体可将  调节为 。
 调优。 参数设置不当会触发    这类严重影响性能的问题，具体可参考这篇文章《最佳实践－ 调优》
总结

基于上述设计和优化后，  监控数据存储方案比直接使用  存储性能提高了  倍， 台  峰值写入速率可达  ， 则到  的时候整个  集群就已经无法正常工作了。
目前此套基于  的监控数据存储系统已经上线提供服务，后续计划在入库  之前加入缓冲层进行列的预 ，可进一步成倍提升整体性能。 发展至今已是个比较成熟的开源分布式数据库，其高性能，高可用性及高可扩展的特性，可为海量数据的存取提供强大动力。第一部分    说明
意义
是基于开发的一套快速实现数据库表增删改查操作的工具，核心思想是做到针对数据库表的每个字段做到精确配置，通过生成字段配置并通过修改配置的方式来实现增删改查功能，无需编写数据库操作代码。
现状
国外有类似的生成器产品：，，，，。这些产品各有其特点，但也有一共同点：都是基于进行开发这在一定程度上决定于语法的灵活性及其弱类型性。是其中的做的较好的，但也存在如下不足之处：

不支持自定义表单控件；
不支持多数据库；
验证规则不完善，不支持异步验证；
代码冗余度极大。

第二部分    设计
模型
有下面个核心的构件  模块和，对  模块有继承依赖的关系，由 和 组成； 模块是手工编写的代码，而是生成的代码；  模块实现操作，实现扩展功能。下图表示了这两个构件的组成和关系

图概念与构件
下面对图中设计的概念、构件、模块关系以及与流程做详细阐述。
  模块  模块实现核心操作，一切对 中的请求，最终转交至  模块进行处理。  模块会开放一些预处理和后处理接口交由实现，这些接口会在，，上都有体现。  模块主要包括如下文件





  模块读取 实现真正的操作。

 不但实现了  接口代码，而且具有自己配置文件 。每一表示以一张数据库表为主表，具备功能的代码文件合集包括对应的  代码。譬如，生成的一个， 主表为数据源表，名字为，那么 应包含下面代码文件：

 
 
_
_



代码文件命名取决于的名字，故为保证生成的代码文件不冲突，取的名字 ， 作为的唯一标识。每一个的信息都被保存在数据库中。一次新建 操作将会新建上述所有代码文件，更新相关文件，并插入一条记录到数据库。一次更新 操作将只会更新文件。 由代码和 代码组成，下面分别进行阐述：

代码：用来实现扩展接口。请求应最先路由到 的中的控制器。并且  应与  的代码有继承关系。
 代码：实现对主表增删改查参数的配置。该文件放置在目录下，以 的格式定义。它包含对所有字段的表单，列表，视图，关系等参数的配置，以及全局的参数配置。

并不表示具体某一个模块，而是代指一类模块，这种模块可以由生成，或者由开发人员手工建立。它主要用来实现  的接口，主要包括下述几部分：    接口假设模块的 为，   的为，则应继承自。请求会先路由到，而实际的处理者是。会实现开放的下列接口。

：该接口在查询器执行查询之前调用，传递的参数为查询器引用。用来在查询之前，绑定特殊的查询参数。
：该接口在查询器执行之后，渲染视图之前调用。传递的参数为视图参数引用，其中包括查询出的集合。用来对查询的 集合做后处理，或者对视图绑定一些专有的参数。
：该接口在请求中查询器执行查询之前调用，传递的是查询器引用。用来绑定查询需要的特殊参数。
：该接口在中查询器执行之后，渲染视图之前调用，传递的是视图参数引用，其中包括查询器查询出的。用来做渲染前的预处理。
：该接口在中，保存编辑的之后调用，传递的是保存在数据库中，最新的数据库记录持久化的。用来对做一些复杂的后级联处理。
： 该接口在请求中， 查询器查询之后调用，传递的是视图参数的引用。用来对视图显示做预处理。

     接口 代码中的也继承自，实现 类开放的一些接口可以完成扩展。：该接口用来格式化某个字段。本产品基于，其已经具备类似的接口，就是。但这样的接口的优先级比字段优先级高，这在特殊的情况下为开发带来了不便，所以再设计一个类似的接口，该接口的优先级低于字段本身。
     接口视图的扩展接口与前两者不同，主要体现在子视图与视图块上，也就是在 模块的视图基础上，扩展视图组件。默认  视图生成的是一个表格或者一个表单，占满页面。而接口将提供在该表格上下左右扩展页面组件的能力。
    每一个对应一个文件，其中包含对主表各个字段的配置参数，以及布局参数。
模块关系请求路由到的，代码实现  开放的接口，而由  去真正实现对数据库的操作。每一个的信息应该被记录在数据库表中，以便给关联菜单，控制权限，记录操作日志等等。一些主要模块之间的关系如下图所示。

图模块关系
从图中可以看到，由管理模块根据用户配置来生成一个 ，当用户的请求到达 时， 会讲请求转交 进行处理，  模块再以对数据库进行操作。
 与 流程项目的方案，将真正的操作交给了  去执行，参数由或者请求参数与 构成，而的代码只是去实现  开放的一些预处理或者后处理接口。图是最核心的流程图，包含的生成和处理请求的过程，图是 中的生成和处理请求的流程图。
图  代码生成和处理的流程

图  代码生成和处理的流程
对比两者，可以看到两者的最大区别，是复用一份代码，而不是像那样为每一个生成一套可以当独执行的代码。这样做的好处是提高了复用性并通过  实现预处理后处理接口达到扩展性的目的。
数据源
数据源是的默认数据源，其类型为，数据库名为，，数据源信息保存在代码文件中，文件内容如下：
   
     =
         
             = 
             = 
             = 
             = 
             = 
             = 
             = __
             = 
             = 
             = 
        
           
 
其中数据源有下述数据表：    _ 表：表示后台左侧树形菜单，每一个可点击跳转的菜单项必须与一个进行关联。    _ 表：记录了信息，每一条_表的记录代表了生成的一个。    _ 表：保存着使用后台程序的用户。    _表：表示对后台用户的分组信息。    __表：记录了每个、不同后台用户组与各种操作权限的三维权限信息。    _表记录了每个用户的操作日志。
数据源管理模块
需要支持多数据源，多种类型数据库。数据源信息保存在_表中。考虑到数据库操作是频繁操作，如果将数据源信息保存在数据库中，则每次数据库操作将多一次数据源查询操作，这样做浪费性能。那么不应该把数据源信息保存在数据库中，而应该保存在代码文件中。数据源管理的信息包括数据源名称数据源的唯一标识，默认的数据源名为、数据库类型、地址、端口、数据库名、用户名、密码等等信息。因为数据源管理模块并不对表进行增删改查操作，所以数据源管理模块并不是一个模块。该模块的代码完全手工编写。
 管理模块
将以基于名字为“”的作为生成的用户接口，该模块称作管理模块，换言之管理模块本身就是一个，该的主表即是数据源中保存信息的数据库表，改的名字为“”。 管理模块包含创建，更新和删除 的所有代码文件以及数据库记录。的新建和删除需要更新全局的路由。
 路由路由定义在一个独立的代码文件中，为一个以名字进行减号分词并全部小写的字符串为键譬如：名字为，则键值为、以中类的类名为值的字典，路由是全局的。
 新建更新新建将在数据库中生成一条记录、生成所有的文件、并更新路由。更新操作只修改配置文件。新建与更新都使用相同的编辑视图，此编辑视图是对 的图形化配置界面。
 删除删除将删除所有的 代码，删除 代码，删除数据库表记录，并更新路由。
  模块
  模块是处理请求的实际处理者它由下述几部分组成：
参数解析初始化初始化，实例化一个的对象作为初始化查询器。加载 ，对未设置的值进行设置默认值，对参数进行汇聚。
表单主要包括新建和更新功能。根据主表主键是否设置判断是新建还是更新操作。下图是模块的流程
图 执行流程
 分两部分，第一部分渲染页面给用户填写。第二部分为保存。渲染页面需要考虑的有控件和有外键关系的字段要怎么处理。控件需要支持类型包括、_、_、、、、、、、以及，自定义控件应该继承类，自定义控件的渲染由控件的方法完成。渲染需要判断有关系的字段做辅助加载。比如对文章表进行编辑，表有一个字段为_，表示文章的栏目，对应栏目表的字段。这时需要对_使用，，控件进行加载，方便用户输入。比如使用控件，那么应该将作为的，将作为中的。这样做也是为了方便用户输入。此步骤与中搜索时有共性，因此代码可复用。 保存需要考虑一些自定义控件的保存，自定义控件的数保存由自定义控件类的方法完成。 保存还需要考虑关系的保存，默认应该级联更新附属表。 表单在用户输入完成点击保存之后，要分下面几步：

根据字段配置的验证规则进行验证；
应判断  中的进行分析，进行必要的级联操作；
并要调用自定义控件的方法；
最后才应更新或新建主表数据；
跳转：更新或新建成功跳转至，失败跳转至。
 还需要开放对应的预处理和后处理接口。

列表是一个分页，按照  中的字段配置显示分页数据。支持列表搜索，排序，勾选删除，导出等功能；

分页展现数据以模块得到的作为查询器，结合分页，查询出基本的数据列表。分页类型为全页刷新类型非异步分页；
搜索：支持在 中定义了不等于的字段作为搜索条件。搜索关系为逻辑与的关系。并反映在参数上。搜索输入控件根据字段的 来定。在 中定义为，，控件的字段，在中都将使用控件作为输入控件；
 排序：以在 中定义了 不等于 的字段作为可排序字段。排序只支持按单一字段排序，降序方式含升序和降序；
 多选操作主要支持多选删除，多选复制操作任何删除操作都需确认；
 数据每行记录的支持的操作按 中的配置给出，默认支持编辑，删除，查看三项操作；
 也要开放预处理后处理接口给  。

查看 暂时以为基础，提供预处理后处理接口，但不允许编辑。
第三部分    实现
目录结构
代码按照前段资源、、、等概念进行了分目录存放。下面表格中给出了主要目录的说明：
 配置文件
配置文件定义了的参数，该文件保存在下，是以 进行蛇形分词得到的字符串命名的文件譬如：一的名字为，则配置文件为_。配置参数以数组格式返回。考虑到数组在表格中呈现的美观性，对参数以配置中的=形式，以点分形式表示。
表中每个字段的表单配置说明如下表所示：表中每个字段的列表配置说明如下表所示：表中每个字段的关系配置说明如下表所示：
 模块实现
模块涉及的代码文件极其作用如下说明。

：模块的控制器，是操作核心的逻辑代码。主要分析请求参数和参数，调用层，渲染视图层，实现呈现、搜索排序、呈现、保存等功能
：模块中的模型，是模块中模型的基类。未与表格关联。定义了一些公共的默认属性，以及一些静态的数据库操作方法，比如拉取数据库表字段列表
：模块中的默认参数配置文件，但模块中的配置文件未定义某些参数时，将使用中的默认参数
：模块中的列表视图文件，用来呈现数据列表
：模块中的数据记录编辑视图文件，用来呈现数据编辑的表单。

 管理模块实现
是一类由生成的模块，它有一组模板定义在目录下：

_
_



前面设计中指出，管理模块本身是一个名为“”，主表为_，且手工建立的，故其代码组成也是符合规范的，笔者编写的代码主要为扩展代码。管理模块对应了下述代码文件：

：控制器代码，其实现模块的接口，以及扩展的接口；
：管理模块的模型；
_： 视图代码，其在原有的 模块的表单下部，扩展了一组，其中第一个中显示了所有字段的详细配置，通过以上扩展就能实现在生成的表单页面中对进行配置；
_： 视图代码；
_：字段配置表格视图代码；
__：扩展链接视图代码；
： 文件。

第四部分    部署到腾讯云
环境要求
本文将基于环境进行部署，详细部署环境要求：

   
  必须安装
 必须安装
   
、等服务器

腾讯云主机
部署机器可以在腾讯云上购买，在腾讯云首页云产品基础产品计算云服务器中可以购买机器，另外可以单独购买数据库机器，这里讲数据库与服务器部署在同一台机器上
图 腾讯云主机
购买完成之后，可以在腾讯云控制台中看到购买的机器，复制公网
图 腾讯云控制台
腾讯云支持 登录和账密登录，这里用 以账号密码的形式登录
图 配置
 
图 配置
登录上机器之后，我们需搭建运行环境，在此为测试，所以将服务器软件，数据库软件等都装在同一台机器。安装环境可以使用自动话的脚本安装，在腾讯云服务市场镜像服务全能环境  或者 腾讯云服务市场运维服务环境配置中，都可以找到很多自动化安装  、等等的基础运行环境 。比如、在此我使用一键安装包，安装步骤参考地址，可以看到，腾讯云机器的下载速度是非常快的
部署配置
安装完之后，参考的配置我们就可以开始配置了首先，需要将放置到的 或者中，这里以 为例。本文中的根目录为编辑文件，修改节点：

{
      _
      _ =
    _ 
       
      

    _      
     

      {
        _   _
    }

      \|
    {
              _  =   
            _  =
            _  
            _ 
            _ 
             
             
    }

     _
    {
        _ 
        _   
    }

      \|||||
    {
              
    }

      \|
    {
              
    }

      \
    {
         
    }

    _    
}
修改项目文件所属用户，保证 进程对文件有读权限，本文部署环境中， 进程为用户进程；同时需要给部分目录完全的写入权限，执行下列命令：
 
 –  
 –  
 
 –  
      
建立数据库，在中创建名为的数据库，并 根目录下的，具体执行如下命令
 首先进入
 – –__
 进入之后
      
 
 
至此部署完成，通过浏览器访问页面 为主机域名或地址即可以访问到。
第五部分    案例
设定：在不编写代码的基础上，以生成一个简单可用的博客后台，博客后台有表和表，位于数据源。
  

         
    _   
       
       
       
    _     
    _   _  
    _      
    

  

         
       
     
           排序字段
    _ 
    _     
    
新建
准备好数据库表即可新建，下面新建名为“”的。进入管理新建界面，按图填写保存。
图 新建页面
编辑新建的 ，可以看到在下部多出一个含有表格的。
图  字段配置页面
现在对于表的所有字段都是默认配置，分别查看和，可以看到和都能正常读取数据库数据。
图  列表页面

图 表单页面
上面两图呈现的和并不具有可用性，因此需要对字段做配置。
配置
首先修改字段的中文名、是否包含在、是否包含在等属性。
图  字段配置页面
保存之后，再次刷新列表和。对比图、图发现内容发生了变化
图 列表页面

图 表单页面
下面对每个字段做更详细的配置以得到更符合我们需求的页面，修改控件类型：摘要字段为多行文本类型，正文字段为富文本类型，_字段为下拉列表类型，_修改时间为日期类型。修改_栏目外键的关系为所属关系，并填写如下：
图  字段详细配置表单
修改摘要字段、标题字段为不可排序与模糊搜索，修改_搜索方式为“=”搜索
效果
刷新列表，可看到如下两个控件：和控件。

图  列表搜索日期与下拉列表控件
输入搜索条件为修改日期：、栏目：、摘要：收到。结果按阅读次数排序。得到下面的列表结果。
图  列表搜索与排序
点击其中一条记录进行编辑，测试功能。
图 编辑表单
修改之后点击保存也是正常可用的。整个配置过程，只需几分钟，但却实现了上述功能。工具演示地址

相关推荐
腾讯云从零部署站点
项目部署指南
云服务器实例概述作者 | 吴昊
有哪些接入方式？
腾讯云直播接入方式有两种：
一种是频道模式，主要针对中小客户，用户可以在管理台或通过来对频道进行管理，如创建频道，删除频道，查询频道信息等。典型的接入流程：用户创建频道，拿到推流进行推流，并用获取到的下行播放地址进行播放。频道模式的客户，如果仅使用管理台，可参考。如果使用，可以参考里对各接口的描述。
另一种是直播码模式，主要针对有一定开发能力的客户。腾讯云提供一个通道能力。典型的接入流程：用户通过人工审核并下发配置后，拿到一个上行路径如，和一个下行路径如。然后用户自行生成并管理频道，后台接收到一个合法的上行地址上行路径频道后，用户用相同的下行地址下行路径频道即可播放。
两种分别可以提供什么功能？用户根据需求如何选择？
频道模式
通过管理平台或进行频道操作、水印管理
提供多码率原始码率、普清、高清，多协议、、
提供播放器代码
通过创建录制或截图任务，并通过获取结果
支持推流和播放，需要线下配置
直播码模式
用户自己生成频道也即直播码、流，并自己生成推流地址和播放地址
提供推流和播放防盗链
提供多码率原始码率、普清、高清，多协议、、
支持录制和截图
支持主备流，需要线下配置
支持推流和播放
注：
高清：分辨率    码率 
标清：分辨率    码率 
直播码接入流程有哪些？
腾讯云自定义直播码接入方式为有开发能力的客户提供推流和播放的管道，用户自定义直播码并进行管理
防盗链是一种保护用户视频内容安全的功能。通过使用防盗链功能，用户可实时自行生成可用于播放器环境或访问的播放链接，该链接在用户指定时间内可用，从而有效保护视频内容。由于防盗链采用动态生成方式，该功能开启后，原有播放器代码和文件将不可用。
开通直播码需要哪些信息？


下行协议、码率
推流路径
播放路径
推流鉴权
播放鉴权

是否开通录制需要开通点播
是否开通截图提供_和_
什么是防盗链？直播中防盗链规则有哪些？
防盗链是一种保护用户视频内容安全的功能。直播防盗链分为上行防盗链和下行防盗链。
上行防盗链。用户可保护自己的推流地址不被其他非法客户使用。
下行防盗链。用户可实时自行生成可用于播放器环境或访问的播放链接，该链接在用户指定时间内可用，从而有效保护视频内容。
防盗链的基本逻辑如下

图：防盗链基本逻辑
如何开通和使用防盗链？
准备工作：开启服务和获取密钥
该功能目前需要人工手动开启。开启后，用户可获取密钥，该信息为系统随机生成字符。用户需妥善保管该该密钥。
第一步：生成推流地址并推流
推流地址格式示例如下：
==
为用户的
是推流路径
为直播码，为保持唯一性，需要加上作为前缀
参数字段生成方法如下：
=示例：为校验串，算法为：  _  ，字母小写。
其中，
：为用户的密钥；
_：直播码
：该链接有效的截止时间戳。通过  到有效截止时间秒数表示，服务器会根据该时间判断该链接是否有效，并转换为进制。例如希望该链接有效期至 ，则的计算方式为：   至 的秒数，即，转换为进制表示；该计算有标准函数可使用。
为有效的截止时间戳，如上所述
推流软件首选第三方软件。
第二步：生成加密播放地址
播放格式类似为：
协议：
==
 协议：
==
协议：
==
多码率
各协议支持普清分辨率 ，码率 、高清分辨率 ，码率 、             原始码率 三种码率。
以为例，示例如下
普清：_==
高清：_==
、同上
字段生成方法如下：
为校验串，算法为： =    ，字母小写。
其中，
：为用户的密钥；
：直播中有三种出流协议，在计算时和分别都取的是文件名，取的是去掉后缀的文件名。如：

_
_
：该链接有效的截止时间戳
第三步：根据加密播放地址发起请求
视频请求方根据以上计算结果，组成链接，发起请求至腾讯云以及其
第四步：腾讯云进行验证并判断是否播放。

腾讯云首先会根据明文中有效的截止时间戳判断当前时间是否过去，如果未过期则根据链接中明文可见，用户密钥用户在管理控制台生成时，腾讯云在后台维护的相同副本，以及=链接中明文可见，在或腾讯云侧生成’ =    ，；如果 = ’，则允许播放；否则禁止播放。如果系统判断防盗链链接不正确，默认将返回页面。

如何使用录制功能？
接入流程
 申请开通直播的基础上，开通点播。
录制规则
开始推流时，即启动录制任务，直至直播结束
录播按时间进行分片，最大大小为小时；
录播时，发生断流，则停止录播生成一个分片
断流恢复后启动新的录播分片任务，重复的过程，直至整个任务结束
录制分片请求格式：点播
通过或者回调的方式获取一个_对应的录制分片列表
通过拼接的播放下载录制分片
如何使用截图功能？
接入流程
在申请开通直播的基础上，需要申请截图需要的平台权限，并获取账号信息。
截图规则
开始推流时，即启动 截图任务，直至直播结束
频率周期为，按照系统绝对时间；
截图大小：分辨率宽自适应高；
截图对象：实时直播流；
截图生成文件：文件名为直播码推流绝对时间戳任务启动时间戳截图相对时间长宽
存放部分：截图后，对应文件上载至系统；时间在内；即内，用户可通过查询下载，账号、容量购买、下载部分由客户独立完成；
图片格式：__文件名
通过或者回调的方式获取截图消息
通过拼接的播放下载截图
注：并发高的用户需要将属性设置为。
直播码用户可以使用哪些接口？
接口定义

其中为用户密钥，目前需要人工手动开启。
 获取截图消息
接口名：
__
输入说明


完整的访问地址示例：
  _==__====
获取录播分片
接口名：
__


获取频道状态
接口名：
__

暂停恢复频道
 接口名：
__

 查询在线
接口名：
__

查询频道列表
接口名：
__


可以提供哪些通知回调功能？
推流上下线
录制分片
截图地址
接口定义
公共参数

其中为用户密钥，目前需要人工手动开启。鉴权为字节字符串，可通过联系客服人员进行开启和分配。
事件类型_
目前支持的类型
          断流
          有输入流
      录制分片回调
      截图图片地址回调
其它参数

 
数据格式采用 
部分
{“””””””_”“_””””_”””}
接入流程
提供回调接口地址及接口方式
进行联调

相关推荐直播应用的后台服务器性能测试实践 点对点直播导语
区别于传统测试的重路径，识别类评测更重数据。识别类的输入不被限制在软件可控范围内，而是包罗万象各种可能。不同的输入数据组合，得出来的评测结论也会截然不同。手机浏览器探索三地评测团队在评测数据方面积累了一些经验，特地写此文章来和大家讨论下分享。
关于探索
在开始正文前，先来介绍下什么是探索。如下几个图所示，打开浏览器，首页上部天气区域按住向下滑动，就可以进入识别界面，定帧后会出现识别结果。可以是花草猫狗等的科普类名称识别，也可以是商品识别后的购买链接推送，还可以是一些效果广告。总之这是一个入口级别的功能，为用户打开了新世界的大门。当然了，作为当前主打的识别功能，识别准确率是我们要考虑的重要评测指标。

关于识别率的获取，首先映入脑中的问题是输入什么数据来获取识别率？这样一个看似简单的问题，细分析起来却很复杂。比如数据应该贴近用户真实情况，那么用户的使用场景是怎样的？这些场景的比例设置如何？怎么获取这些数据呢？是否可以使用线上数据？针对这四个问题，探索评测团队进行了多轮的分析和实践，将分为场景分类、场景比例、数据生成、数据标注四个部分来进行讨论。
本文基于实物识别进行展开，其它方面的识别例如语音类识别仅供模型参考。
一场景分类
数据场景的设计类似于传统测试中的用例场景设计，需要考虑用户实际可能会遇到的场景。可以分为几个维度，每个维度设置两端极限值，在两个极限值之间均匀选取。



维度
释义




远景—近景
发起识别的焦距可以调整，类似照相，需要有远景到近景不同焦距的数据，可以根据需要定制目标物体在镜头中的大小比例。


正面—背面
这种适用于特地对象的物体识别，从正面到背面，中间还有侧面横切面之类的也需要数据覆盖到。


纯粹—复合
这个维度是对背景干扰的考虑，从纯粹的物体到有各种干扰的背景条件下的物体识别，定义识别等级。


全局—局部
识别物体从完整进入摄像头到部分进入摄像头，都要覆盖到，因为实际上用户很少在第一次识别时关注到物体的完整性


真—假
寻找一些接近的物体来做混淆辨识测试，例如假二维码，外形接近的汽车等等，用于测试识别的精准度。


物种分类
这个比较好理解，就是要涵盖可识别的物种不同的分类，例如各品种的猫、狗、花草等等。



当然，除了上表之外还有很多其它维度，读者朋友可以自行补充。不是每次测试都要把所有维度覆盖全面，与项目组讨论选取几个更具指导价值的维度即可。结合实际案例举例如下图所示，分别是测试可乐、花草、二维码的数据场景。

二场景比例
在确定了要有哪些场景分类后，就到了量的问题了。
可以各种场景比例都配比为，这样可以看出每种场景下的识别能力差异，有针对性的提高。但是有个新的问题，比如项目组就想知道当前花草的识别率能达到一个多少，我们固然可以说各种情况下的不同值，但是综合来看呢？这就涉及到了每种场景的计算权重比例。注意这是权重比例，是在计算时使用，而不是实际执行时的具体数据数量。
场景比例需要考虑四个方面：产品目标、场景概率、用户习惯和上报统计。
以浏览器识别来看，如下图所示，从产品目标来说当前宣传引导主要是拍花识草，产品定位更倾向于花草，因此树干类的权重就要降低一些；从场景概率来说，以常见物种为主，像“尸香魔芋”之类的玄幻物种用户基本拍摄不到因为我们目前还是以真花为主，电视剧中出现的假花识别不在范围内，另外一个近拍为主，对于远景用户有心理预期，较远距离识别的概率低；从用户习惯来看，之前这个识别入口主要是用来进行二维码识别的，所以还存在大量用户识别二维码的需求，二维码的权重要高或者单列一个独立指标，另外用户对发生识别行为的动力中有一种分享心态，因此对那些比较名贵的花朵、珍稀动物比较倾向，我们可以去植物园动物园之类用户常发生分享的地方采集数据，这部分的计算权重也要高；最后一个方面是上报统计，如果说前面的几个方面都是版本发布前的合理预估，最后一个方面就是真实数据的指导了，通过上线后大量的用户数据上报可以进行分类统计，来观察各种场景构成的比例，指导后面的数据场景比例。

最后权重比例如上图最右侧所示，权重最高的是常规测试数据，极简模式和高复杂度的数据权重都较低，呈现一个纺锤型的统计比例。
结合具体案例如下图所示，按照场景分类进行比例分配。图中的数据看起来都是整数，只是为了方便记录，实际统计的时候进行舍入过了。二维码中特殊形状、背景易混淆和伪二维码都属于高复杂度的，权重较低。植物中花、叶、树都比例有定义外，每个分类的远景近景也都有比例。

三数据生成
通过场景分类和比例，基本上数据方案就已经定下来了。接下来面临的问题是从哪里获取这些数据。我们将数据集合分为三类：原生数据、构造数据和用户数据。这三类数据怎么生成的接下来会介绍。
如下图所示通过网络爬取所需数据，加上通过众测平台人工采集的数据，经过数据清洗检查是否符合各项数据要求，比较好的数据图可以直接作为原生数据一般指图片清晰，目标物体大小居中，一部分图片可能还需要二次加工才可以使用的，也就是所说的构造数据。构造数据主要是通过画中画和条件中心两种形式进行构造，画中画是通过两张以上的图片拟合到一起例如物体旁边加上二维码，形成背景干扰，或者扣取的形式从原图中取目标对象例如一幅画中存在多种花，可以扣取出来形成多个数据源；条件中心是指通过对图片进行压缩达到扫描尺寸有些图片过于大超出识别边界，可以做适度压缩，或者按照目标对象在图片中的位置进行分类，组成居中、左侧、右侧等不同识别位置。如果版本已经发布，通过上报数据进行标注，可以获得更加真实的用户数据，标注数据的内容会在第四部分讲解。

结合项目节奏动态来看，如下图所示，从数据采集或者网络爬取到数据清洗、分类定级场景分类和识别定级、构造数据、测试后调整需要补充数据源或者去掉一些数据再到最后的线上数据标注，形成一套不断循环代谢的动态数据。

四数据标注
在第三部分提到了用户数据是通过对上报数据进行标注来获得的，本部分就具体看下是怎么标注的。首先被标注的上报数据分为两类：有真假结果上报的数据和无法获知正确性的数据。
有真假结果上报的数据，是指类似二维码识别这种，有“真”“假”结果上报判断的数据。标注方法如下图所示，将线上数据报上来的判别为真的二维码和判别为假的二维码再经过一轮人工检查，找出其中的真真 ，数据的真实类别为真，最后上报得到的结果也为真，假真 ，数据的真实类别为假，最后上报得到的结果却为真，假假 ，数据的真实类别为真，最后上报得到的结果却为假，真假 ，数据的真实类别为假，最后上报得到的结果也为假。其中和数据可能会混入扫物结果里或者判断为无法识别，这部分数据需要单独去捞取。有人可能质疑，在二维码这种数据中，可能存在不是二维码而识别成二维码的情况吗？答案是存在的，比如用户本来是要扫商品，结果正好面对摄像头的那一面有二维码，这属于误入了二维码界面，而没有去到本来进入商品界面。这种图片就不能直接进入二维码测试集合，而是要经过处理，或者放到扫物用例结合里作为高复杂度的数据用例。
最后汇入测试集合的时候按照纺锤型的模式进行权重配比。这种标注的损耗率比较低，标注完后还能存有的数据有一些是废图，比如模糊的或者目标物体识别错误的。

无法获取正确性的数据是指花草或者猫狗这类数据，这些识别结果上报后，无法获知我们识别的是否正确，经过预分类处理后，还需要人工来进行精准标注。人工对比定妆照或者寻求专业人士的来帮忙标注。这里要注意是多态的保留，例如花朵的多角度图片，这是为了保持数据的多样性，从而满足场景分类中各个维度需求。这种标注高损耗，万张图片标注下来只有余张可用图片。耗时也比较长，后期我们采用多竞品对比的方式先进行一轮自动化标注，方便人工针对性的确认，这样就将精准标注简化为类似第一种有真假结果上报的数据标注了。例如多个竞品都标注为“加菲猫”，那么只需要人工对比定妆照确认是该图是否加菲猫即可，不必在整个库里寻找。

关于评测类数据篇就介绍到此。总结一下，从场景分类、场景比例、数据生成、数据标注这四个方面来看，共同之处就是以用户实际为依据，科学计算，不断更新。在数据获取和处理的方式上还要持续提升效率。下篇我们会给大家展示识别类评测在测试方法上总结，敬请期待。作者 |邵梦超编辑 | 顾乡
背景：
   平台的某个数据库上面有近千个连接，每个连接对应一个爬虫，爬虫将爬来的数据放到里供后期分析查询使用。前段时间经常出现查询缓慢，占有率高的现象。通过 后发现，大量的连接卡在了执行     这样的语句上面。难道并发执行     会导致负荷直线上升吗，下面我们做一个实验。
实验：
   先创建一张表：
  `` 
  ``   
  ``   
    ``
 =  =；
   再编写一个压测测试脚本，分别在并发为、、、，，，，，的情况下测试执行次          =语句。
 
   
_
 

=

 
    =
     
         =  =   = = = =
         = 
        =
        =_=
           
            
        
        

    =  ``       =
     =      
    
    = 
     

=
=    
 
  运行结果如下图，随着并发数的增加执行语句耗时呈现先下降后增加的趋势，与之相对应的是使用率随着并发数增加不断增加。可以看出，当并发数大于一定的时候，系统发生了雪崩，性能急剧下降。而在图上没有标出来的是，当并发数大于的时候，直接返回了         错误，已经无法正常执行语句了。
分析：
  通过来分析造成上述雪崩的原因，发现是卡在了___函数上面。
           = 这个语句先在表中找到是否存在=的行，因为是主键，所以很快就定位到这一行上面。接下来需要执行操作，在执行之前需要获取该行的锁。由于大量的连接都在执行这个操作，因此在抢夺行锁上产生了大量的竞争，因为行锁的分配也涉及了自旋锁。很多连接就卡在了自旋锁上面，白白的消耗了资源。
解决方案：
   其实最好的解决方案就是不要将这些爬虫直接连到上面，通过一个中间层维护一个的连接池，这样既能满足实际业务需求，也不会造成死锁。当然对于这个具体场景也是有简单的优化方案的。造成死锁的原因是大量连接对行锁进行争夺。既然这个行锁是性能瓶颈，那我们可以通过增加行锁来减少争夺的成本。
  我们稍微改造一下表结构，添加一个联合主键、_，每个连接都执行     {_}     =。这样每个连接都有了属于自己的行锁，不会互相争夺而产生死锁了。最后只需要执行一下就可以获取最终结果了。
  `` 
  ``   
  `_`   
  ``   
    ```_`
 =  =；
 压测测试结果如图，随着连接数的增加，耗时减少至稳定，使用率增加至稳定。

相关推荐
 论坛使用云数据库可能遭遇随机的“    ”异常【干货合辑】你有什么独家数据库优化技巧？基于的云数据库搬迁实例解析《大话  》系列文章通过通俗易懂的语言并结合基础实验，用最简单的描述来讲解  中的重要概念。让读者对分布式存储系统有一个清晰的理解。
引言
这篇文章主要介绍了  在  底层的存储方式，解释了  的实际占用容量和  大小的关系，用几个文件的例子演示了文件在  更恰当的是 中的存储位置，最后组装了一个  ，给出了一些 。
是什么
   ’                      
上面是官方的阐述，简单的说就是：

 就是  里的块设备，一个  的块设备的功能和一个  的  类似，挂载的  就可以当磁盘用。
这个块可大可小。
 这个块在 里面是被切割成若干小块来保存，不然  的块怎么存的下。
精简置备，我认为的很容易被人误解的  的一个属性， 的集群是能创建无数  的块的。说白了就是，块的大小和在  中实际占用的大小是没有关系的，甚至，刚创建出来的块是不占空间的，今后用多大空间，才会在  中占用多大空间。打个比方就是，你有一个  的 盘，存了一个的电影，那么  大小就类似于 ，而  就相当于在  中占用的空间。

，和下面说的块，是一回事。
实验环境很简单，可以参考一分钟部署单节点这篇文章，因为本文主要介绍，对  环境不讲究，一个单  的集群即可。
创建一个的块 ，因为是默认是 的块，具体和 的区别会在下文讲到：
   
     
      _
          {=}
                 
            
                
                    
                   
      
    
  
         
        
    __ 
     
   

              
                    
                   

   的指令如果省略   参数，则会默认 ，而这个 是默认生成的。

对刚刚的 的几行输出简单介绍下：
         
        
    __ 
     

 就是这个块的大小，即=， = 共分成了个对象，每个对象，这个会在下面详细介绍。
  是个编号，是， 是，也就是  =    = 。
__ 这个是块的最重要的属性了，这是每个块在中的唯一前缀编号，有了这个前缀，把服务器上的都拔下来带回家，就能复活所有的了。
  格式有两种，和，下文会讲。

观察建前后的 输出，会发现多了两个文件，查看下：
              

     

_
再查看这两个文件里面的内容：
       
      _ _
      
                    |   |
                    |  |
                    ||
                    ||
                    ||
     _ 
                    ||
这时候我们再创建一个  叫，再次对比查看
      
     


_
      _ _
     _ 
                    ||
                        ||
多出了个文件，很容易联想到这个文件的内容是和内容类似的，唯一不同的是保存了各自的__。然后，_里面多出了这个块名字。可以得出以下的推论：
每个块刚创建 时都会生成一个这样的文件里的对象，里面保存了这个块的。同时，_会增加刚刚的创建的，顾名思义这个文件就是这个里面的所有的索引。
为了简单试验，删掉刚刚的只留下
    
   
 使用
建好了块，我们就开始使用这个块了：
    

    
=              =    = = 
         =                       =   = =
         =                       =        =
     =                       =   = =
         =                       =   = 
   =               =   = =
      =            =   = =
         =                       =   =  =
 =                   =   = =
    
    
   
文件系统        容量  已用  可用 已用 挂载点
                 

                
我喜欢记点东西，比如上面的就是刚格式化完的系统的大小，算是一个特点吧。先别急着用，集群发生了点变化，观察下：
   
                

      | 














_
比刚刚多了个文件，而且特别整齐还！观察这些文件的后缀，可以发现，后缀是以进制进行编码的，那么从  是多大呢，就是十进制的，这个数字是不是很眼熟：
         
可是这里只有个文件，并没有个啊，这就是的精简置备的一个验证，刚刚创建的时候，一个都没有呢，而这里多出的个，是因为刚刚格式化成时生成的。我们着重关注索引值为  这两个碎片文件  
       
       
    |
                    ||
                    ||
                    ||


    
     月   
      月   
   
          
     
   
    
          

    
                    ||
                    ||
                    ||
                    ||
                    ||
太长了自己看
    |  | 

这里的每一行输出都是很值得思考的，首先我们导出刚刚提到的两个对象，查看第一个对象，开头就是，可以验证这是刚刚留下来的，这时候查看文件大小，发现并没有那么大，别担心一会会变大的，值得关注的是第个对象，输出居然是  ，进一步验证了刚刚的足迹，这和整个块的信息是一样的，我猜测把文件系统核心信息就保存在块设备的最最前面的。而后面的第个对象里面的输出是，我不负责任得猜想这个可能是传说中的。抛去猜想这里给到的结论是：
在使用块设备的容量后，会按需生成对应的对象，这些对象的共同点是：命名遵循 __，     ，而这个区间的大小正好是所有对象数的总和。
现在让我们把塞满：
   = = 
 正在写入 设备上没有空间
记录了 的读入
记录了 的写出
字节 已复制， 秒， 秒

   
                
                    
这里写了将近的数据，重点在后面的 ，如果理解了前面说的内容，这个对象自然是由_和还有个对象构成的，因为我们用完了这个块的所有容量，所以自然就生成了所有的的小对象。
写入文件
我们把环境恢复到被填满的上一步，也就是刚刚和  这里。向这个块里面写入文件：
     
     
     
       
这里我之所以只导出了这个对象，是因为我之前已经导出过所有的对象，经过对比后发现，在写入文件之后，只有这个文件的大小增大了之后，很快找到了写入的内容。
     
                    ||
                    ||
                    ||
                    ||
                    ||
                    ||
                    ||
                    ||
                    |`|
                    ||
                    ||
                    ||
                    ||

                    ||
                    ||
                    ||
                    ||

                    ||
                    ||
                    ||
                    ||

                    ||
                    ||
                    ||
                    ||
这里我们找到了文件名和文件的内容，这很！因为是将这些文件和他们的内容组织成这样的格式的，再关注下每一行前面的编号，这里同样是进制编码，如果之前我对 == 的猜测是对的话，所有的即都出现在索引范围为 的区间，这个的单位是转换过来就是，这个小内的所有的都保存在前区间。而文件出现的第一个索引为第二个在第三个在之间相差了 也就是   == ，还记得时的输出吗？    
   
=              =    = = 
         =                       =   = =
         =                       =        =
     =                       =   = =
         =                       =   = 
   =               =   = =
      =            =   = =
         =                       =   =  =
 =                   =   = =
也就是这里的 = 使得文件之间间隔了，很抱歉我的知识还是一片空白，所以这里很多东西都靠猜，等我补完这一课会回来再做更正的。所以这里我们的结论就是：
其实是一个完完整整的块设备，如果把的块想成一个层楼的高楼的话，可以想象成住在这个大楼里的楼管，它只能在大楼里面，也就只能看到这层的房子，楼管自然可以安排所有的住户文件文件名，住在哪一层哪一间，睡在地板还是天花板文件偏移量，隔壁的楼管叫做虽然住在一模一样的大楼里  ，但是它们有着自己的安排策略，这就是文件系统如果组织文件的一个比喻了，我们就不做深究，明白到这里就好了。然并卵，拆迁大队长跑来说，我不管你们是怎么安排的，盖这么高的楼是想上天了？，然后大队长把这层房子，每层砍了一刀，一共砍成了个四层，然后一起打包带走了，运到了一个叫做的小区里面，放眼望去，这个小区里面的房子最高也就四层填满的，有的才打了地基还没写内容。
这一节最主要的目的就是说明，在眼里，它并不关心这个是做什么用处的，统统一刀斩成大小的对象，而使用这个的用户比如，它只能从里面操作，它可能将一个大文件从三楼写到了五楼，但是不管，直接从四楼砍一刀，文件分了就分了，反正每个小四层都有自己的编号，不会真的把文件给丢了。
最后再来个小操作=：
    

   
   = =  = =_
记录了 的读入
记录了 的写出
字节 已复制， 秒， 秒
        
                    ||
                    ||
                    ||
                    ||

    



需要执行     _后才能看到修改的效果。

，至少我是这么觉得的，我们通过查看为的小文件，得知了这个文件内容在这个小内保存的位置为，因为前面还有一个小文件即，那么这个在整个内的偏移量为===，也就是说保存在的偏移量为的位置，这时候用工具，直接向这个位置写入一个，再查看的内容，果然，被修改了！
  组装
受到这篇文章启发，我们开始组装一个，所谓组装，就是把刚刚的个小碎片从集群中取出来，然后利用这个文件，重建出一个的块，这里的实验环境没有那篇文章里面那么苛刻，因为集群还是能访问的，不像文章里提到的集群已死，不能执行指令，需要从里面把碎片文件一个个捞出来。


一点思考： 使用 这种方法太慢了，有一个事实是，可以从任何一个  导出这个集群的，我有一个为证实的猜想，能否将这个注入到一个活的集群，然后这两个集群的    的输出如果一样的话：
集群     ，得到块名所存储的位置，前往集群找到之。
集群 读取文件读取。希望你还能记得这个块的大小。
集群 做个循环，读取    _的输出，可以获取在集群的某个的某个下面，这样就可以直接定位而不需要从 结果来过滤了。
只是猜想，未证实，这两天证实过再回来订正。

通过这个实验可以直接通过获取所有的的存储位置，不需要平移了，十分方便快捷。

我们很快就可以把那个文件拿出来了，现在开始组装：
  
总用量 
      月   
       月   
       月   
       月   
       月   
     月   
     月   
     月   
       月   
       月   
       月   
       月   
     月   
组装的基本思想就是，先搭建一个层的大楼，然后，把刚刚的个四层根据它的安插到对应的楼层，缺少的楼层就空在那就好了，脚本来自刚刚的文章，我对其进行了一小部分的修改，使之适合我们这个实验，脚本将输出一个名为的块：

    这是刚刚的的大小
_=

   
__=

={} 
=  生成的块名
={} 
=
_={} 
_= 

_=  {}  |   |  { }
  {_}    
        {}  
  


           
         
 = ={} = = ={_} 

 _    {}  
  _= {_} |  _ { } |   ={_}  ={__}  {  }
   = ={_} ={} ={_} ={__} 

从上面的脚本就可以看出，这是一个填楼工程，将其填完之后，我们来看得到的文件：
   
          
     
    
     
     月   
这时候，我们挂载会出现一个小问题，重复：
    
 文件系统类型错误、选项错误、 上有坏超级块、
       缺少代码页或助手程序，或其他错误

       有些情况下在  中可以找到一些有用信息 请尝试
        |   这样的命令看看。
   |
          
原因很简单，还记得我们刚刚操作时的  吗 块是的克隆，所以的是和的是一样的，这时候我们 即可：
    
    
   
    
    


神奇吧，我们用碎片文件组装了一个完完整整的块，能和里出来的一样使用，并且数据也是一样的，相信如果理解了前几节的内容，对这个实验的结果就不会很意外了。
     
众所周知，有两种格式：

  以及之前默认都是这种格式，并且__ = 
  默认是这种格式，并且__ = 

关于的问题将在下节解释，这里我们只讨论这两种格式的在底层的存储有什么区别，首先安装一个版本的环境或者改配置项，方法很简单：
    
    
 向  发送信号失败 没有那个进程
                    
             月        
             月        
 ：未挂载
      
  

   
     
      _
          {=}
                 
            
             
                
                    
                   
   
   
创建一个块，并观察集群多出了哪些文件
      
    
  
         
        
    __ _
     
         
     
     
__
_
_
_

    
   
                
            |   
        
      
      
      
      
    

     
_
_
_
多出了四个文件，在关闭属性后，少了一个__文件，我们查看剩下的三个文件内容：
      _ _
      _ _
      _ _
    _ 
    _ 
    _ 
                    ||

可以发现，_不再保存所有的名称，相比于的 ，采用_的形式保存了这个块的，而另一个文件_显示的保存了这个，我们再向这个块写入点文件：
   
   
                
     |
_
_
_
_
_
_
_
_
_
_
_
_
_
_
_
_
可以发现，生成的个小文件的后缀和 的是一模一样的，只是命名规则变成了_之所以后缀是一样的是因为对于的块总是会这样构建文件系统，所以对于  ，这些小除了命名规范不一样外，实际保存的内容都是一样的，下面对这两种格式进行简要的对比总结：



格式
_







 
保存了所有的名称

在中
形如 


 
空
_
在中 并_显示输出
形如 _




、   
最常见的使用问题，一般出现于 的 操作，需要关闭如下属性即可，注意顺序：
      
      
      
      
、的要删几个月
是的，之前看到调试的发现，  的时候，是从的开始一个个得往后面删，所以 的块有两千六百万个碎片组成，虽然实际上并没有用到这么多，但是一个个删的话，还是相当慢的，如果是 我们可以 | __ |  这种思路删除，再删掉文件，再执行  就可以很快删掉了。这里有一篇很详尽的文章介绍了删除方法。
、为什么总是的块
__ = 这个配置项决定了切块的大小，默认值为，参考了这篇文章我得到了和的几个关系


























大概关系就是这样，暂时没找更详细的介绍， 能看到更详细的信息。

  =      也就是的次方。

、  编号
配置项为__ =   这个值是由几个属性加起来的：

     
   
  
   
   
   
  
  

所以=就是 |   |   | |这些属性的大合集需要哪个不需要哪个，做个简单的加法配置好__就可以了。总结
这篇文章还是有点残缺的：

碎片在底层是以\_____这种命名方式保存的。
的猜测为证实。
的平移注入是否会产生相同的  结果。
答案：会产生相同的结果，但是不需要平移，只需要一个就好了。



最简单的话来总结下：从内部看，是一个整体，从外部看，是若干的碎片。
  
大话系列文章
《大话》之那点事儿《大话 》之  那点事儿《大话  》之  那点事儿

本文来自： 公众号导语
在客户端自动化中，如果需要对进行操作，控件识别和操作是最基础的能力。在标准控件中，我们可以通过来找到窗口，来找到子窗口和按钮，在测试页面，我们通过___、____、___等等来找到页面元素。但是，在大多数应用程序中使用的都是非标准的控件，无法通过来找到某个按钮，也无法通过某个来找到某个输入框。一般来说，应用程序必须嵌入一定的或者开发时支持一定的“后门”，自动化程序才能根据相应的协议来识别控件。但是没有这些条件怎么办呢？这时候就要使用一些了。
首先了解到的的是 ，根据截图来做自动化，截一截图就能写个自动化脚本，岂不是很爽？ 

图 ：根据截图编写的王者荣耀登录  脚本
 有很多优点，例如

基于 ，可使用  语法来写脚本
良好的可视化脚本编辑器
可手动调整匹配度和操作偏移位置

那么问题来了，为什么要手动调整匹配度？
根源是是因为  是基于图片像素级对比的，而在实践中，像素级对比往往存在很多缺陷，图片文件必须与屏幕上的呈现完全一致才能匹配上，实践中必须手动调低匹配度才能匹配到元素，但又不能太低，太低则会匹配多个元素，所以如果使用  一定会存在不停地调整图片的匹配度的烦恼。
几种像素级匹配不适用的场景：

图像稍有缩放，无法匹配
图像稍有变形，无法匹配
图像有细微改动，匹配率降低

图： 手动调节匹配度
另外，虽然  虽然是开源项目，但由于对  方面了解不多，想要修改匹配方法或者增加一些功能比较困难，于是萌生了自己实现基于图像对比的自动化的想法。想要实现这个想法，必须要解决两个问题：
、  匹配问题：即在一张大图中找到一张小图、  操作问题：即封装各种操作，包括各种鼠标操作和键盘操作
匹配问题
一、  图片 
首先查到的是根据图片的  来查找相似图片。各种  算法的原理都很相似。比如  ：
、  先将图片缩放至 或 、  将图片灰度化、  计算所有点的颜色深度均值、  用  表示小于均值，用  表示高于均值，得到一个元素都是  或  的 。如 …。、  计算两个矩阵汉明距离元素相同是 ，不同是 ，值越大越不相似，越小越相似。
其它类似的  算法还有 ，差别就在于不是直接计算平均灰度值来得到 ，而是通过一定的变化后再计算。
 中已经有人写好了相关的库 ，直接使用即可。
图：使用  计算两张图的差异
唯一的问题是性能。比较一次就要  多毫秒，想要在一张  的图片中查找一张  的图片，如果每次移动一个像素则比较次数为 ，也就是说  秒才能找到最佳匹配，显然性能比要求差了几个数量级。尝试了其它几种  算法，速度都在这个数量级上。看来各种  算法还是比较适合用于以图搜相似图，或者是以缩略图搜原图，而不适用于在大图中找小图。
二、  模板匹配
 模板匹配是一种最具代表性的图像识别方法。在大图待识别图像  滑动小图模板  进行匹配，滑动的意思是每次从左向右或者从上向下移动  个像素，最终找到最佳匹配。
图：模板匹配原理图
 中支持多种匹配算法：
平方差匹配 =__

标准平方差匹配 =___

相关匹配 =__

标准相关匹配 =___

相关匹配 =__

其中
标准相关匹配 =___

从  到  算法是越来越复杂，得到的结果是越来越好，计算量会越来越大，但在实际测试中发现，这几个匹配算法速度差别不大，如果没有特殊需求，一般直接使用___即可。使用时唯一需要注意的是 _ 和 __ 计算结果越小越匹配，其它的都是越大越匹配。
模板匹配的缺陷：
首先模板匹配是直接使用的在大图中切割和小图一样大小的图像来进行比较的，匹配算法 也是固定位置对应固定位置进行计算，所以  和  的方向必须一致。
更重要的是，模板匹配一定会返回一个最佳匹配。模板匹配的返回值都是 到 ，根据模板匹配的返回值，很难确定匹配度是多少。所以，使用模板匹配，你不能确定目标图像中是否存在模板图像。
  在一群牛中找到了一只羊的最佳匹配
三、  特征识别
人眼在识别物体时，会根据图像的局部特征来判断整体，比如图像的边缘轮廓、角、斑点等等。在  维基百科中可以查到，针对不同的特征形态有很多不同的特征检测算法。
 维基百科中的特征检测  
最著名的特征检测算法莫过于  和  了。
 特征点检测
使用以下代码来源：可以画出一张图片的  特征点。
 
   
 = 
= _
 = 
 = 
==_____
_
使用  画出的  特征点
 特征点包含很多属性：坐标，邻域范围，方向，关键点强度的响应等。
 特征点计算更快，速度比  快  倍。 使用方法与  基本一致，但在实践中发现  找到的特征点比  少太多，因而没有采用。
四、特征匹配
 提供两种匹配器
 和     。区别在于：

 暴力查找所有可能，找到最佳匹配。  
 快速查找相对较好的匹配，但不一定是最佳。

为了获得更好的效果，我们使用 。
另外，常用且有效的消除错配的措施有两种：
、第一个是  作者提出的：
取一幅图像中的一个  关键点，并找出其与另一幅图像中欧式距离最近的前两个关键点，在这两个关键点中，如果最近的距离除以次近的距离得到的比率  少于某个阈值 ，则接受这一对匹配点。
这个阈值  小，最后得到的匹配点就越少，质量越高。阈值越高，匹配点就越多，质量就会越差。因为使用上不涉及尺寸、旋转、亮度等的变化，实践中使用  推荐的  是合适的。
、第二种方法是 随机抽样一致性去噪。
随机抽样一致性 算法，可以在一组包含外点的数据集中，采用不断迭代的方法，寻找最优参数模型，不符合最优模型的点，被定义为外点。具体用法可以查看   
图 使用  去噪
经过过滤，最终可以得到一组匹配点对，数量为 。如果小图的特征点数量是 ，那么我们可以认为匹配度是  = ， 高于一个阈值，我们即可认为是匹配到了。
好了，终于解决了第一个问题：匹配问题。总结一下，使用模板匹配 可找到最佳匹配位置，前提是图片方向一致。使用  特征点匹配 去噪算法，可找到两张图的特征点匹配度。事实上，在一般的自动化项目中，图片方向是一致的，模板匹配是适用的。我使用的是模板匹配  特征点匹配来实现的，并没有用到 ，原因在于模板匹配已经找到了最佳区域，大图中的最佳区域与小图进行特征对比即可，对比区域限制了， 不会找到更多的外点。
操作问题
操作问题的实现并不复杂，都是按照业务需求对  的一些封装。但为了达到傻瓜式编写用例脚本的目的，应尽量封装得好用：
、 实现  的常用操作和  没有的常用操作，包括但不限于：




等待消失
各种点击
长按
滑动
键盘操作

、操作可以  偏移 、尽量减少脚本使用  判断另外为了提升效率，我把操作区域限定在一个窗口区域内，由于没找到   窗口消息的方法，所以使用了比较挫的实现方法：通过一个线程不断更新窗口区域。目前已实现的窗口操作类结构如下：
 
    _ = 默认超时时间
     _____
     __更新窗口并不断截图
     = 
     _= 
     键盘输入
      = _
      = _等待消失
      = 
      = 
     __ = _ = 
     __ = _
      = 
     __ 
大致脚本代码如下： 
 = 腾讯手游助手
 

 = 
__
__

__ = 
__ = 
 如需要登录就登录一把
        __
        
        
        
        
  = 
        
__

  = 
        
        __ = 
  = 
        
操作问题虽然实现起来并不困难，但如果想要使脚本更加健壮必须要在实践中不断优化。基于  的自动化稳定性经常会遇到各种问题：比如窗口被遮挡、 发生变化、窗口被隐藏等等。基于图像对比的脚本更是如此，比如执行一次点击后，希望知道是否操作成功，也是非常困难的一件事情，需要脚本层去解决。所以我认为基于图像的自动化比较适用场景为：
、  比较稳定
、 操作流程比较简单
、或者弱业务流程的自动化，如随便点击测试 后记
虽然模板匹配 特征点识别相似的图片，但依靠某种算法的特征点还是太薄弱了，能否依赖机器学习的方式，让机器自动识别 、、  等等，让机器拥有一定的泛化能力？让机器拥有学习的能力，可以自动地操作界面，根据反馈来识别操作控件，最终达到完全自动地测试程序的 ，到时候才是真正的自动化测试吧。
 附：图像对比的  代码
运行环境：  版本去除了  等代码，需要另外安装库才支持，非常麻烦， 安装方法： 中  下载指定版本，解压后拷贝\\\\\ 至  中即可
参考资料：
  安裝與簡易使用 特征提取分析    在腾讯云的云主机上部署一个博客，马上让你写博客的姿势变得更加极客。
搭建流程
先明确一下它的运作流程：本地有个  程序，里面包含了  文件夹， 文件夹， 将  里的文件渲染为静态的  文件放到  下，然后我们用推送到服务器的，服务器用 把仓库里的文件同步到网站根目录，而  的作用就是反向代理。

服务器环境：安装、、创建用户 

本地搭建环境：安装、，生成本地静态网站

使用自动化部署发布博客


一、安装、创建用户
在服务器上用权限运行下面命令
  
 

二、安装和配置
  
  
    设置为开机启动

修改的配置文件
 

那块改为
 {
                _
                _
        _   你的域名
         
                 网站根目录

          {
                _   =
        }

          \|||||||||||||||||||||||||||||| {
                _  __   
        }
}

然后执行
 
 
    设置权限

作为服务器上的网站根目录。
三、本地搭建环境
安装用 运行命令：
    

初始化，比如我要在下搭建博客
 
  

之后继续安装和，一个用于自动部署，一个用于本地简单的服务器。
 
   
  

执行：
  或者 
  或者 

就可以访问看到博客了。
四、自动化部署
自动化部署就是可以不用在服务器上执行操作，只要本地  推送上去，服务器就会通过  自动把内容同步到网站根目录。
登录
为了以后每次发布时不用输入密码，我们需要创建证书登录，如果自己电脑里没有公钥我们的公钥在这里：_，则创建公钥：
    

有则跳过上面这步，然后复制公钥到服务器，下面这个命令就是把公钥内容读入剪贴板。
  _

切换为用户，添加公钥后记得要赋予文件相应权限：
 
 
 
 _
粘贴然后保存
  _
  

在自己电脑终端输入 你的域名验证是否配置好登录。
新建仓库，配置
接着上一步用户目录，在服务器上创建一个裸仓库
   

然后
 
写入以下内容保存

 = =  

再赋予它权限
  

本地打开_，最后面的修改为：

     
     你的域名
     

我们试试能不能自动部署：
     

现在，打开域名看看吧。
接下来安装主题和配置的其他功能就是后话了。

相关推荐
使用  和  快速搭建个人博客【腾讯云的种玩法】利用腾讯云搭建个人博客最近在做腾讯云大数据可视化项目，天天跟各种柱状图、饼图、面积图等打交道。
饼图能直观的表现一堆数据中各项所占比例，是非常常见的图表之一。本文尝试来讲讲如何在浏览器里绘制饼图。

准备工作
要展示的数据
这是某地扶贫项目的数据

雨露计划

金融扶贫

产业扶贫

基础设施



这是一个优秀的库，支持和绘图，能简化绘图工作中涉及的大量计算、动画，可以称之为绘图引擎。

我们开始吧
首先把数据整理成代码友好的格式
  = 
     { 雨露计划  }
{ 金融扶贫  }
{ 产业扶贫  }
{ 基础设施  }
 
定义画布大小
 画布大小
   =  
然后用生成一个元素并挂载到下面，这个讲作为后续绘制的画布。
 初始化一个元素
  = 
     
      
      
简单提一下返回的是一个元素，确切说是封装的一个数据结构，所有后面的 和 是作用于这个元素的，而非一开始选中的。

一个数据项用一个扇形来表示，多个数据项的和就是一个完整的圆。所以绘制饼图其实就是绘制与各数据项对应的扇形。每个扇形都有一个起始角度和结束角度。
我们需要算出每个扇形的起始和结束角度，打包了这一工作，称之为布局器。 

 准备一个布局器，此布局可根据原始数据计算出一段弧的开始和结束角度
  =  =  
  将原始数据经过布局转换
  = 
创建布局器，
 = 设置布局器的取值过滤器
典型的链式调用。

我们来看下经过布局器转换的数据长什么样子


 存放原始数据
 排序索引，的布局器默认会按数据大小来倒排
  表示弧的开始角度
  表示弧的结束角度
最小角度为，最大为π约等于〒▽〒。
默认情况下，索引为第弧的起点在从点方向，索引为末尾的弧终点在点方向，这两个弧首尾相接闭环
  来自源数据的值，因为代码 = 设定了数据源是属性
相邻弧间的夹角，这里未设置，所以是

有了各个扇形的角度数据，可以绘制了，里没有现成的”扇形”元素，所以需要借助标签来定义任意路径以绘制扇形。
用标签来定义路径是一个比较吃力的事情，需要根据路径的复杂度多次调用、、等多种命令，路径的不在本文讨论范围内。
所以我们直接用提供的“弧生成器“来生成路径。 
 根据画布大小算一个合适的半径吧
  =      
 准备一个弧生成器，用于根据角度生产弧路径
  = 
同样链式调用，传入了内径和外径，内径传最后得到饼图，传非最后得到环形图，这很容易理解。
是一个柯里化返函数，它接受含有、、属性的对象，返回值为的属性。

万事俱备，接下来，要把绘制上了。
不过在这之前我们还得再准备一个元素来作为容器打包每个弧的，为什么这么做呢，后面揭晓。
  = 
然后执行一长串操作

     
     
     


   =  调用弧生成器得到路径
玄乎的来了
暂时理解为容器上执行返回了全部元素，实际上这些还不存在，也不知道会有多少个
绑定预先准备好的经过布局器转换后的数据，既然绑定了数据，那返回的对象内部就知道了需要多少个
前面两行已经说了这些元素还不存在，但是已经知道需要多少个，就是选择这些还不存在的空，所以用于根据数据的条数来选择元素，与它类似的还有和，分别对应已经存在和需要删除的元素，当然这里用不到。具体参见这里。
前面选择了这些尚未存在的，那总得将他们补齐使之真的存在。
  = 最后遍历这些元素，给他们赋上属性，属性值是调用弧生成器的结果。

至此，组成饼图的各个扇形已经绘制好了。看看：

得到了这样一个结果，嗯。
各位看官应该也看出来了，前面我们并没有设置各个路径的坐标偏移量和填充颜色。
先解决坐标偏移量。

“位置是相对的” 观察和各的在页面上的位置。


路径都绘制出来了，但是只显示出了饼图的第四象限。
原因是在一般的平面绘制时，我们都以坐标为原点的，并且为了简化计算复杂度，都直接计算路径的相对坐标，刻意不将绝对坐标带进计算，然后通过位移画布或者容器来一步达成位移。
前面已经准备了一个所有的父级元素，来把它移动到画布中间。
 `{  } {  }`

饼图已经正常展现了。

接下来着色
设定颜色比例尺，对于饼图来说，此比例尺的作用是根据饼上的某一节的序号得到一个对应的颜色值。
  =  
在绘制处设置属性

     
     
     
     
        {
 设置填充颜色
 
}
       = 

饼图已经画好，接下来添加一些文字标签上去。
 先算一个总数
  =   = 

 同样，搞一个来承载文字标签
  = 
 `{  } {  }`

 生产每一个文字标签的容器
  = 
     
     
     
       {
 将文字平移到弧的中心
     
}
      
      
      {
 显示百分比
       
}
完成图

至此，基本饼图画好。

还有一些事情没做，
鼠标与扇形的交互，、等；
文字标签不友好，很多饼图都实现了在饼外用线连接的标签，单单是连接线就要涉及很多问题的处理，比如某些算法下实现的饼图对应不同数据的时候可能会导致线于扇相交，很难看或者是要求连接线只能在饼的两边等等；
这些问题将在后续送出。是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用已加密的通道协议 来达到保密、发送端认证、消息准确性等私人消息安全效果。本文主要讲述如何在  下连接  服务。
安装客户端

：
    

     
连接服务

：
           

          

是创建的连接名称

是的地址

是用户名

是密码，也可以没这个参数，命令稍后会自动询问。这样可以保证账号安全

 是表示需要加密，不必指定加密方式，命令会读取配置文件中的加密方式

是表示创建连接完后马上连接


连接断开
建立好之后，可以通过     和     连接和断开服务
     连接名称为服务
     断开名称为服务
报错解决办法
连接 超时执行下面命令：
 
连接 ，报如下错误：
  
   
     
    
 
解决办法：
 
将下面字段添加到文件中用户权限可更改





连接成功：
              重新启动
      
       
      
        
        
       
连接成功没网：
需要将连接设置成默认路由！

查看路由表
 
   
                              
                                             
                                      
                                      
                                    
解决办法：
删除原来的默认路由：
  
将连接设置成默认路由：
    
联网成功：
      
    _= = = 
    _= = = 
    _= = = 
    _= = = 
    _= = = 
    _= = = 

查看路由表
 
解决办法：
将连接设置成默认路由：
     
联网成功：
    _= = = 
    _= = = 
    _= = = 

相关推荐连接服务腾讯云消息队列在环境下的使用在云服务器上搭建网站时，许多个人开发者喜欢使用  操作系统。据  的一项调查， 占据了网站服务器市场的 ，而且还在呈上升趋势。由于其较高的使用率，腾讯云等云计算厂商均提供了  操作系统的镜像。
本文将介绍在云厂商购买  服务器之后，为了确保服务器的安全，开发者应该要做的一些配置。完成本文的操作之后，服务器的安全性将得到更好的保障。
新建云服务器实例
在开始配置之前，我们先新建一个云服务器实例。新用户可领取免费代金券，获得个月左右的免费使用时间。如果已经使用代金券，可考虑使用笔者的推荐链接来购买服务器。
这里，我们选择计费模式选择为「包年包月」。对于需要长期运行的网站应用来说，包年包月的模式还是比较划算的。机型选择标准型中最低配，即 核、 内存。


选择存储与网络时，建议将系统盘选择为云硬盘，除了可以获得免费赠送的空间之外，还方便以后根据需求升级  的  和内存。其他的使用默认设置即可。

接下来需要设置一些  相关的信息，如主机名和登陆密码。一开始，你的账号下只有默认项目，

如果你不希望手动设置密码，可以选择「自动生成密码」，腾讯云会向你的注册邮箱发送相关登陆信息。安全组暂时选择为默认安全组，将暴露所有端口到公网和内网。
 登陆
在登陆刚启动的  实例之前，我们需要知道服务器的公网 ，以及  用户的密码。如果你选择的是自动生成密码，那么请查看邮箱。接下来，我们在本地使用如下命令登陆到服务器。
    请将  替换为实际 
按照提示进行操作，输入  用户验证所需的密码可以从腾讯云发送的邮件中找到。如果这是你第一次使用密码登陆服务器，登陆成功后系统还会提示你更换  密码。
 用户
 用户是  环境下的超级管理用户，拥有非常大的权限。由于  用户权限过大，不建议大家日常使用  账号进行服务器操作。因为有可能会出现让你加班、甚至被开除的意外。
因此，我们接下来创建一个新的用户账号，在日常工作中使用。
创建新用户
以  账号登陆服务器之后，我们就可以添加以后经常使用的用户账号了。本文中，我们将创建一个名为  的新用户，你可以根据自己的情况选择合适的用户名。
  
系统会要求你回答一些问题，最重要的就是设置该用户的密码。对于其他问题，并不是必须的，可以直接按回车键完成。
添加  权限
现在  用户还只是一名普通用户，不具备系统管理权限。我们需要为该用户添加  权限。这样，就可以在每个命令前加上  以管理员权限执行了。
安装 
由于   系统默认没有安装  包，因此我们先通过  安装。
首先，更新  包目录：
  
然后使用下面的命令安装 ：
   
现在可以使用  和  命令了。
赋予  权限
为了给新用户添加管理权限，我们需要把新用户添加到  用户组。 操作系统中，属于  用户组的用户默认可以使用  命令。
在  用户下 ，运行如下命令，将  用户添加到  用户组：
     
上面的命令中， 选项指的是将用户添加到对应的用户组中，只能配合  选项一起使用。 后可以指定多个用户组名称。如      。
添加公钥验证
推荐给新用户添加公钥验证，一来可以避免每次登陆时都要输入密码，二来需要私钥才能登陆可以提高安全性。
生成密钥对
如果没有现成的  密钥对由公钥和私钥组成，很容易就可以生成。只需要在本地机器上输入如下命令即可：

假如本地用户的名称为 ，接下来应该会看到如下输出：
    
        _
如果你以前没有生成过密钥对，按回车接受默认设置即可。如果有旧的密钥对的话，这样会覆盖以前的密钥对，建议更改为别的文件名。系统还会提示输入口令，为了简单起见，我们直接回车使用空口令。如果你输入了口令的话，那么在  登陆时，除了需要提供密钥之外，还需要输入口令才能登陆。
命令运行结束后，会在本地用户的根目录中的  目录下创建一个私钥 _ 和一个公钥 _。记得别公开分享你自己的私钥。
复制公钥
赋值公钥有两种方法，一是通过  脚本自动赋值到远程用户，二是手动安装。

 脚本

如果本地机器上安装了  脚本，那么就可以使用该脚本将公钥安装到任何有登陆权限的用户。
运行该脚本，同时指定用户名和服务器的  地址：
  
按提示输入登陆密码后，你刚才生成的公钥就会自动赋值到远程用户的 _ 文件中。接下来就可以使用对应的私钥登陆服务器了。

手动安装公钥

使用如下命令打印你刚刚生成的公钥_：
  _
打印出来的公钥大致应该是这样子的：
  
然后，以新用户身份登陆服务器：
  
登陆成功后，应该会进入该用户的根目录。接下来创建一个叫  的新目录，然后使用如下命令限制目录权限：
 
  

 表示只有目录的所有者才能读、写和执行。
现在使用  文本编辑器在  目录下创建一个名为 _ 的文件。
  _
在  中按  进入插入模式，然后    粘贴之前赋值的公钥。然后按  回到正常模式，在英文输入法下键入  保存并退出文件。
并使用如下命令限制文件的权限：
  _
 表示文件所有者可读、可写。
之后，你就可以使用私钥验证登陆服务器了，不必重复输入密码。
禁用  登陆
在开始配置服务器的时候 ，我们提到了最好不用使用  账号登陆服务器。为了确保不会出现这种情况，我们可以修改   的配置，禁止远程登陆值  账号。
以上面配置的管理员用户身份，使用  命令打开配置文件：
   _
如果想禁止远程  登陆，找到下面这行文本：
 
将其修改为
 
并保存文件。由于我们已经创建了一个管理用户，而且可以视情况增加权限，禁止  账号登陆反而可以让服务器更加安全。
最后，只需要重启  服务即可让新配置生效。
   
本地配置 
完成以上配置之后， 以后我们每次只需要   即可登陆服务器。
不过这样还是有点麻烦，每次都得输入用户名和  地址。为了进一步简化操作，我们对本地的  登陆进行配置。
打开  文件，然后添加如下配置：
 
 
 
 _
之后，只需要执行   即可登陆服务器。大数据、云计算时代，出现了许多新型的数据库类型，包括 、、、等，各个数据库的特性各有千秋，而且如今各家云厂商提供数据库时，都会进行一些调优，比较起来比较困难。
这时就需要一套标准化的测试工具，为此雅虎在  年推出了    ，雅虎云服务基准测试，提供了一个标准的框架和工作负载集，可以便捷地比较不同「键值」存储数据库和云数据库的性能。 于  年开源，目前的版本为  。
  简介

 项目包括两大块：

 客户端：可扩展的工作负载生成器。
核心负载：一组工作负载场景，由负载生成器执行。

我们可以利用  对多个数据库运行基准测试，然后进行对比。一般来说，可以在相同硬件配置下安装多个数据库，每个数据库执行相同的工作负载。之后就可对测试结果进行数据可视化，判断哪个的性能更好。
  安装
安装过程比较简单，官方已经提供了编译好的二进制包。
   
  
 
执行方式如下：

 运行工作负载
运行工作负载，主要包括六个步骤：

设置好测试数据库系统
选择合适的数据库接口层
选择合适的工作负载
选择合适的运行时参数客户端线程数、目标吞吐量等
加载数据
执行工作负载

接下来，简要介绍一下每步操作中可能要注意的一些问题。
 设置好测试数据库系统
数据库系统可以配置在单机或集群上，根据希望测试的场景选择。在  客户端运行之前，必须先创建数据表，因为客户端不会主动请求创建。
 选择合适的数据库接口层
数据库接口层是一个  类，负责执行  客户端生成的读取、插入、更新、删除等操作，并转换成对应数据库的  情况。运行  客户端时，需要在客户端指定类的名称，而且命令行中设置的参数会传入到数据库实例中。
 选择合适的工作负载
工作负载定义了加载阶段 中要加载到数据库中的数据，以及事务阶段 阶段将要对数据集执行的操作。
通常，工作负载由以下组件构成：

 类的子类
参数文件

 选择合适的运行时参数
选择好工作负载类型后，可能还需要指定一些具体的参数，这些参数可以通过命令行提供，包括：

：客户端线程数。客户单默认执行单一工作者进程。
：每秒操作的目标数量。客户端默认会执行尽可能多的操作。
：对于运行时间较长的负载，客户端定期报告状态很有必要，可以显示测试是否崩溃。

 加载数据
工作负载有两个执行阶段：加载阶段定义插入哪些数据，以及事务阶段定义对数据集执行哪些操作。如需加载数据，要运行  客户端，让其执行加载阶段。
例如，加载标准的测试数据集：
     
 执行工作负载
加载好数据之后，即可执行工作负载。具体来说，就是让客户端运行工作负载的事务部分，示例命令如下：
          
这里，我们通过  参数，让客户端运行事务部分，而不是数据加载部分。
以上是使用  对数据库系统进行基准测试的大致流程。针对具体的数据库系统，具体的测试步骤如何进行，我们在后续的文章中再来介绍。
参考资料


相关推荐
腾讯云大数据套件索引插件使用总结
：谷歌家的东西可能也没有想像的辣么美
重新发现中国制造每天分钟，用去食堂吃饭的时间解决一个知识点。

重要性
今天来复习下两阶段多路归并排序。单独讲一次算法，是因为我觉得这个算法太重要了，不仅仅是对数据库而言。遇到一个不可能完成的大问题，将它划分成许多个小问题，分别求解，再将一系列小问题的解汇聚成大问题的解。这种”由大化小，分而治之“的思路，其实在计算机的许多领域都有闪耀。
问题
假定我们有一张表，行吧，每行记录有个。这样，整张表粗略地估计为。现在要求我们将这整张表的记录排个序。假设块的大小为，也就是说，一个块中只能填行记录，整张表占据个块。可供数据库排序使用的内存设为，这样能放入内存的只有块。
如果所有记录都能放内存里面，那我们在学校里学的什么  都能排上用场了，想怎么排怎么排。但我们通过计算已经发现了，绝大多数记录都躺在磁盘上呢，这怎么办？
算法
解决思路就是我们第一阶段划分成一个个小部分，让小部分在内存中各自排好序，第二阶段再合并成大的结果。
具体来说，我们将个块中的个块装入内存，排好序，将结果写到磁盘上。这个整个一阶段要花多久呢？对于个块，每个块都要一次读一次写，这样就有次磁盘。假设每个块的读写为毫秒取个中间值，那么第一阶段总耗时就是分钟。第二阶段中，我们将块读出，进行合并。但是我们换个角度，考查每个块的话，我们会发现，每个块都恰好是一次读一次写，同第一阶段一样。所以，整个过程的耗时可估算成分钟。
块的大小
细心的同学应该已经发现了，在这个算法中，如果我们调大块的大小，那么磁盘次数就会减少。那么块是不是越大越好呢？当然不是。块太大的话磁盘上会有更多未利用的空间。当然，中的大小也是可以指定的，默认好像是，具体就看同学怎么定了。
相关阅读十分钟入门关系型数据库一：三范式 分钟梳理关系数据库基础知识二：存储结构分钟梳理关系数据库基础知识三：树分钟梳理关系数据库基础知识五：查询优化与连接算法作者介绍： 赵伟 腾讯数据库开发者

 这里的是指广义的，包括，，，等的   是一个暗坑无数的功能，可能导致主备机数据不一致，以及其它问题，所以在中我们使用。这里就列举几条的坑。
在此之前，先说说的有点。与   相比，它可以避免传输大量的日志从而减小网络和存储系统文件的负载。另外，某些时候在备机上面重新执行语句反而会比逐条执行的要快，一个极端的例子是，如果一个表没有主键，然后一个语句需要删除更新大量的行，那么使用将是噩梦，因为备机处理每一条这样的都会导致全表扫描从而大大降低备机的性能所以在中我们默认强制创建含有主键的表。但是使用的话，一次执行即可更新删除全部行，这样就快了很多。
下面正式开始批评了。
首先，由于模式下，语句到了备机需要被重新执行，与相比，就增加了重新执行语句的额外开销，包括解析，优化和执行语句。则直接调用的存储引擎接口 来执行行的插入、删除和更新，完全跳过了的优化器的处理逻辑。
语句到了备机需要被重新执行，在多种情况下就会导致主备机数据不一致，比如一个语句调用了用户定义的函数，调用了返回随机值的函数，在数据表中使用了自增列，以及使用了上下文数据 比如用一个表的行数作为某个插入字段值，或者在语句中使用了子句等等。
另一个一致性陷阱在于使用等非事务存储引擎。在完全使用等事务存储引擎的情况下， 是 的，也就是说，无论任何时刻  了，或者 了，或者机器断电了， 都可以恢复数据到之前的状态，确保事务的持久性和一致性，确保所有之前提交的事务的改动都存在，因为自身支持事务，可以恢复，并且在近年版本的和中，可以使用到数据来完成恢复。尽管组提交时候并没有刷盘日志但是一旦使用了非事务存储引擎，那么一个事务的完整性就不存在了，也不是 的了。在和上面都是这样。虽然的各个分支和版本在实现中做了很多努力来避免一些问题，并且给用户强制了一大堆暗坑无数的但是无法完全解决这个问题。当发生了之后，只要一个事务读取 并且或者 写入到了表，那么这个事务的改动可能部分存在，部分消失，并且与数据表也可能会有各种不同，然后，用户的数据就无法使用了。
第三，在使用并且隔离级别是 时候，如果设置_为，那么会拒绝后续的插入更新删除操作，错误信息是：
             _ =                             
但是在设置这两个变量的时候却并没有报错。这个组合也是会导致在并发执行时候的数据一致性问题。所以，还是推荐大家使用和或者其他支持事务的存储引擎的搭配，我们一直用它：

相关推荐字符集中文乱码剖析 占用空间一键查询实践数据库的高可用性分析本文为年月《程序员》原创文章，未经允许不得转载，更多精彩文章请订阅《程序员》。
责编：仲培艺，关注数据库领域，寻求报道或者投稿请发邮件。

导语
 的  自从问世，就备受关注，其性能和实现架构是被关注的热点。年， 发表了一篇论文，披露其实现的一些技术细节。本文在此背景下，对  系统的实现从整体架构、存储、事务处理三个方面进行深入探讨，基于其论文和相关资料讨论具体实现细节，又跳出其外、从数据库内核技术实现的角度对做了一定的推测。接着对  用技术构建起的强大云数据库服务能力进行探索。最后总结了一些问题，以期有更多的讨论和思考，一起来探索  云数据库的技术未来。
 深度探索
年，在上发表了论文《          》。
这篇论文，描述了的云数据库的架构。基于的对于单点写多点读的主从架构做了进一步的发展，使得事务和存储引擎分离，为数据库架构的发展提供了具有实战意义的已实践用例。其主要特点如下：

实践了“日志即数据库”的理念。

事务引擎和存储引擎分离。

数据缓冲区提前预热。

日志从事务引擎中剥离，归并到存储引擎中。

储存层可以有个副本，多个副本之间通过协议可以保障数据的“自愈”能力。

主备服务的备机可达份，提供强大的读服务能力。



持续可靠的云数据库的服务能力。

数据存储跨多个区：提供了多级别容灾能力。

数据容灾能力：数据冗余、备份、实时恢复等多种能力集成到云服务，提高的数据的保障能力。

万能数据库的概念呼之欲出。
之所以有这样的设计，是因为认为：网络已经成为数据库最大的瓶颈。




 的整体架构
认识的整体架构，需要先理解的物理设施，而论文中对基于的物理设施着墨不多，所以我们先来掌握物理设施与整体架构的关系。
 物理设施与架构
的计算节点和存储节点分离，分别位于不同的  中。这是架构最亮眼之处。
如图，用户的应用，通过 接入，然后可以读写位于不同 的数据库。而不同的分布于全球的不同的中如图，截止到年初，全球有个区域即，有个可用区即，每个至少有个。而每个由两到多个数据中心组成，数据中心不跨，每个内部的数据延迟低于。文档称，之间的延迟低于通常小于。
数据库的部署，是一主多从的集群架构，图的  是写数据的节点，只能有一个这点说明还是传统的数据库架构，不是真正的对等分布式架构，这点也是一些批评者认为缺乏真正创新之处。而  是只读的从节点，由零到多个备节点组成，最多可以有个。主从节点可以位于不同的最多位于个，需要个但需要位于同一个内，节点通过   来交互。
是由位于每个节点上的称为 的来提供主从集群的状态监控、以应对主节点 的问题以便进行调度、以及某个从节点 需要被替换等问题。这样的监控服务，称为 。
 
图 整体架构
 
图 的分布图
数据库的计算服务和存储分离，数据缓冲区和持久化的“数据”对于实则是日志和由日志转化来的以为单位的数据，而不是直接由数据缓冲区刷出的存储的数据位于 中，这样和计算节点在物理层面隔离。一个主从实例，其物理存储需要位于同一个中，这样的存储称为 集群，其是由一个个使用了的 组成。
 核心技术与架构
提倡“    ”，这是其设计的核心。围绕这个观点，传统数据库的组件架构，发生了一些变化。
对于，每一个存储节点，如图，由两部分构成。
 第一部分：
第一部分是“”，这是一个重要的关键点，可惜论文没有描述其细节。
如同传统数据库架构的数据缓冲区，向事务层提供数据。传统数据库架构的数据缓冲区，向上起着消耗存储的加载数据到内存供计算层读写数据的作用、向下起着消耗的写出脏数据到存储层以实现数据持久存储的作用。对于一个写密集的系统，大量随机写花费了很多时间，系统的性能因此经常表现为存储层的瓶颈。 尽管技术缓解了每个写操作刷出脏数据的冲动，尽管的使用缓解了存储层的瓶颈，但是，毕竟存储层的与的时间消耗还是巨大的，尤其是对于随机写密集的系统。
的设计，消除了脏数据刷出的过程，数据缓冲区的作用，只是加载数据供上层使用，而脏数据不必从数据缓冲区刷出到物理存储上，这对于随机写密集的系统而言，是一个福音，性能的瓶颈点被去掉了一个如图，在“”和“”之间，竖线的箭头，应该是指向“”的，以表示数据只是加载到中，不存在脏数据的刷出操作。
但是，观察图，“”是位于了存储层内还是计算层内？论文没有明示。
从图观察，似乎“”是存储层和计算层所共用的一个组件，那么就可能存在这样的一个两层设计：位于存储层和计算层各有一部分“”，这两部分“”组合成为一个逻辑上的“”，而逻辑意义上的“”似乎在认为，其更像是属于计算层的。如下文引自论文原文：

                                      

位于存储层内的“”，更像是一个分布式的共享文件系统，为了提高性能也许是一个分布式内存型的共享文件系统，为主从架构的数据库提供高速读服务，此点妙处，论文没有点出，这里权做推测。存储层如果能为所有的主备节点提供一致的缓冲数据，则有更为积极的意义，可以对比参考的如的。
而位于计算层内的“”，是单个数据库实例读数据的场所，独立使用。
提供了一个“自动恢复”缓冲预热的功能，其官方宣称如下：
 “自动恢复”缓存预热
当数据库在关闭后启动或在发生故障后重启时， 将对缓冲池缓存进行“预热”。即， 会用内存页面缓存中存储的已知常用查询页面预加载缓冲池。这样，缓冲池便无需从正常的数据库使用“预热”，从而提高性能。
 页面缓存将通过数据库中的单独过程进行管理，这将允许页面缓存独立于数据库进行“自动恢复”。在出现极少发生的数据库故障时，页面缓存将保留在内存中，这将确保在数据库重新启动时，使用最新状态预热缓冲池。
源自：
“在出现极少发生的数据库故障时，页面缓存将保留在内存中”，这句话很重要，一是其表明数据不用很耗时地重新加载了，二是数据库实例崩溃前的数据内存状态被保留着，三是数据库崩溃重启不必再执行“故障恢复”的过程即使用日志重新回放以保障数据的一致性了事务的中的特性。
那么，页面缓冲是一直保留在哪个节点的内存中？是存储节点还是计算节点？如果是位于计算节点，那么备机节点发生数据库故障时，这样的机制不会对备机节点起到保护作用。如果是位于存储节点，则存储作为一个服务，服务了一主多备的多个节点，则能更好的发挥“自动恢复”缓冲预热的功效存储节点的一直存在，向上层计算节点的提供数据批量加载服务，但也许不是这样，而是提供一个接口，能够向计算层的提供高速读数据的服务，论文没有更多的重要细节披露，权做推测。由此看来，“”层的两层设计，当是有价值的价值点是“自动恢复”缓冲预热，由存储层提供此项服务，与预写日志功能从事务层剥离是关联的设计。
这就又回到前面引用的论文中的那段英文，其表明 ：的设计，把日志、持久化存储、系统故障恢复、物理备份与物理恢复这些功能模块，归属到了存储层。由此就引出了的另外一个重要话题存储层的设计如下的第二部分和下一节内容。
对于计算层的“”，其实现将被大为简化。脏数据不再被写出，脏页面不再需要复杂的淘汰策略进行管理，消除了后台的写任务线程，同时也消除了线程的工作，数据缓冲区的管理大为简化，即降低了系统的复杂度又减少了时间的消耗、还避免了因执行后台写等任务带来的性能抖动，解耦带来的功效确实宜人。额外需要做的一项新工作是：           。而计算层的“”变成单向的读入，此时需要解决的，仅仅是什么样的数据可以从存储层的被读入的问题，而论文原文描述：

              “ ”                                

是存储层的最小一致点参见节，标识了可用日志的最低范围，比还老的数据页不再可用，所以显然如上的论文原文是错误的。如果有比当前数据页还新的数据页被从日志中恢复，则其一定更大，所以页面换入的条件是：存储层中存在页面的值更大的；页面被换出的条件是：中的页面的小于等于。而且，这一定是发生在备机需要更新其计算层的时刻，而不是主机需要更新其计算层的时刻。存在此种情况，其原因已经很明显，主机修改数据，形成脏页，这样的脏页数据的后像才能作为日志的一部分被主机刷出；而主机不会刷出脏页，所以被修改后的数据页应该一直在内存中，而被修改过的数据页如果反复被修改，则意味着主机中的相应脏页数据一定是最新的，没有必要从存储层的中读入“绕道恢复后的数据页”。如果以上猜想不成立，除非生成日志时，存于日志中的数据页部分采取先复制然后其上的数据项被修改这样的方式。可是多做一次复制，又有何必要呢？
 
图 存储结构图 
另外，如果“”确实存在两层另外一个证据，参加图，而如节所述，存储层也在处理日志、并依据日志生成页数据，则存储节点也存在处理数据的能力，就类似于的。这样导致的一个可能是，两层的“”还是可能存在差别的。存储层的“”能够帮助做谓词下推的工作，然后把较少的数据传回计算层的“”，由此实现类似的的智能扫描 的功能。是否如此，或者的体系结构和功能模块在未来继续演变的时候，是否会在存储层内的“”做足文章，可以拭目以待。不过，目前制约存储层内的“”起更大作用的因素，主要在于分布式事务的机制的选取和自身的事务实现机制。详细讨论参见节。
 
图 存储层的“  ”与计算层的“”构成的两层数据缓冲结构
 第二部分：
第二部分是“”，日志和持久化存储。日志与传统数据库对于预写日志的利用方式与不同，这点是实现计算与存储分离的核心下一节详述存储层实现细节。
如图所示，对于日志数据，从  写出到一个存储节点，每个至少有份数据，写出的日志数据会自动复制到个中的个存储节点，当其中的多数节点回应写日志成功，则向上层返回写成功的。这表明写日志信息采用了多数派协议。
的事务模型符合协议，当日志成功写出，就可以在内存中标识事务提交成功，而写日志信息是一个批量的、有序的操作，再加上去除了大量的缓冲区脏数据的随机写操作，因此的整体性能得到大幅提升。
借用官方论文的一组对比数据，可以感性认识存储和计算分离的所带来的巨大好处，如图所示，的每个事务的花费是的倍，而事务处理量是的倍，相差明显。
 
图 主从复制日志存储图
  
图 与主从复制架构性能数据对比图
对于主备系统之间，如图所示，主备之间有事务日志和元数据 的传递。也就是说备机的数据是源自主机的。如图所示的主备之间的紫色箭头，表示主机向备机传输的是更新了的元数据，绿色箭头表示日志作为数据流被发送给了备机这个复制，应该是异步的，相关内容请参考节。所以备机的数据更新，应该是应用了主机传输来的事务日志所致。这是论文中表述的内容，原文如下：

                           

但是，日志的应用功能是被放到了存储层实现的，如原文描述：

                       

而官方的网站用图描述了备机的数据，是从存储节点读入的。
鉴于以上几点，备机数据获取和更新的这个细节，算是个谜。
“”如果确实分为两层，在存储层提供从日志中恢复成为数据页的形式而被缓冲，则主备系统之间应该没有必要再传输日志数据，对于备机而言，直接从统一的存储层的“”中获取数据即可。
与此相关的一个问题是：为什么备机节点，可以多达个呢？难道仅仅是应对读负载吗？ 或者，作为故障转移的目标，需要这么多备机做备选吗？这又是一个谜。
 
图 主备机数据流图
 其他组件
从图中可以看到，物理备份和恢复的数据，是直接存储在 ，即  上。物理备份和恢复的模块功能被从事务引擎中剥离到了存储层。
从图和中可以看到，日志信息的持久化存储，也是落在了上。
是提供的对象存储服务。提供了高耐久性、高可扩展性以及安全的解决方案来备份和归档用户的关键数据。在云服务中，数据库提供商业逻辑的支撑，提供了数据的持久存储支撑。其作用不可小视。
另外，论文提及了 、    、 等特性，对于创造极高的云数据库服务能力很有帮助，本文不再展开讨论，请参阅论文和相关资料。
接《  深度探索二》作者 | 张耀琦编辑 | 顾乡

张耀琦，现腾讯即通应用部工程师一枚；数学出身，博客专家的专栏；目前爱好钻研机器学习。

讨论  的两个来源：偏差和方差。估测偏差和方差。对比说明偏差和方差对真正  的影响。不同的  原因有不同的处理方式。

引用课程：_

先看这里，可能由于你正在查看这个平台行间公式不支持很多的渲染，所以最好在我的  上查看，传送门：无奈脸

 博客文章地址：

回顾
第二篇中神奇宝贝的例子：

可以看出越复杂的 再测试集上的性能并不是越好
这篇要讨论的就是  来自什么地方？
 主要的来源有两个，偏差 和 方差
估测

假设上图为神奇宝贝值的真正方程，当然这只有 制作《 》的游戏公司知道。从训练集中可以找到真实方程\{} 的近似方程 {}。
估测 和 
估测变量  的平均值

假设的平均值为 \，方差为 \{}估测平均值怎么做呢？

首先拿到个样品点：{{} {} \ {}}

计算平均值得到  = \{}{} \_{} {} \ \

但是如果计算很多组的  ，然后求  的期望

这个估计呢是无偏估计。
然后分布对于 \ 的离散程度方差：

这主要取决于，下图可看出越小越离散

估测变量  的方差
首先用刚才的方法估测 ，

然后再做下面计算：

就可以用{}来估测 \{}

这个估计是有偏估计
求 {}的期望值：

用靶心来说明一下  和  的影响

靶心为真正的方程 \{} ，深蓝色点为{} ，是实验求得的方程。求{}的期望值\{} = {}，即图中浅蓝色的点。
\{} 和 \{}之间的距离就是误差 ，而\{} 和 {} 之间的距离就是误差 。幅图的对比观察两个误差的影响。
就是射击时瞄准的误差，本来应该是瞄准靶心，但就造成瞄准准心的误差；而就是虽然瞄准在 \{}，但是射不准，总是射在 \{} 的周围。
为什么会有很多的 {}
讨论系列中的案例：这里假设是在平行宇宙中，抓了不同的神奇宝贝

用同一个，在不同的训练集中找到的 {}就是不一样的

这就像在靶心上射击，进行了很多组一组多次。现在需要知道它的散布是怎样的，将个宇宙中的画出来

不同的数据集之前什么都有可能发生—||
考虑不同的

一次  的  就比较小的，也就是是比较集中，离散程度较小。而次  的  就比较大，同理散布比较广，离散程度较大。
所以用比较简单的 ， 是比较小的就像射击的时候每次的时候，每次射击的设置都集中在一个比较小的区域内。如果用了复杂的 ， 就很大，散布比较开。
这也是因为简单的受到不同训练集的影响是比较小的。
考虑不同  的 

这里没办法知道真正的 \{}，所以假设图中的那条黑色曲线为真正的 \{}

结果可视化，一次平均的 \{}没有次的好，虽然次的整体结果离散程度很高。

一次  的  比较大，而复杂的次 ， 就比较小。
直观的解释：简单的  函数集的  比较小，所以可能  里面就没有包含靶心，肯定射不中。而复杂的  函数集的  比较大，可能就包含的靶心，只是没有办法找到确切的靶心在哪，但足够多的，就可能得到真正的 \{}。
  

将系列中的误差拆分为  何 。简单 左边是  比较大造成的 ，这种情况叫做 欠拟合，而复杂 右边是  过大造成的 ，这种情况叫做过拟合。
怎么判断？
分析


如果没有很好的训练集，就是过大，也就是
如果很好的训练集，即再训练集上得到很小的，但在测试集上得到大的，这意味着可能是比较大，就是。

对于和，是用不同的方式来处理的
大，
此时应该重新设计  。因为之前的函数集里面可能根本没有包含\{}。可以：
将更多的  加进去，比如考虑高度重量，或者  值等等。或者考虑更多次幂、更复杂的 。如果此时强行再收集更多的  去训练，这是没有什么帮助的，因为设计的函数集本身就不好，再找更多的训练集也不会更好。
大，
简单粗暴的方法： 

但是很多时候不一定能做到收集更多的。可以针对对问题的理解对数据集做调整。比如识别手写数字的时候，偏转角度的数据集不够，那就将正常的数据集左转度，右转度，类似这样的处理。
选择

现在在和之间就需要一个权衡
想选择的，可以平衡和产生的，使得总最小
但是下面这件事最好不要做：

用训练集训练不同的，然后在测试集上比较，的比较小，就认为好。但实际上这只是你手上的测试集，真正完整的测试集并没有。比如在已有的测试集上是，但有条件收集到更多的测试集后通常得到的都是大于的。
 交叉验证

图中的测试集是已有的，是没有的，不知道的。  就是将训练集再分为两部分，一部分作为训练集，一部分作为验证集。用训练集训练，然后再验证集上比较，确实出最好的之后比如，再用全部的训练集训练，然后再用的测试集进行测试，此时一般得到的都是大一些的。不过此时会比较想再回去调一下参数，调整，让在的测试集上更好，但不太推荐这样。心里难受啊，大学数模的时候就回去调，来回痛苦折腾
上述方法可能会担心将训练集拆分的时候分的效果比较差怎么办，可以用下面的方法。
  折交叉验证
将训练集分成份，比如分成份。

比如在三份中训练结果 是最好，再用全部训练集训练。貌似数模也干过，当年都是莫名其妙的分，想想当年数模的时候都根本来不及看是为什么，就是一股脑上去做

相关推荐
机器学习入门系列，简介机器学习从入门到出家效果广告点击率预估近期实践：深度学习作者介绍：，腾讯高级开发工程师。工作多年，长期从事后台的开发、架构设计、优化等方面的相关工作。

对技术人员来说，知其然还需知其所以然——搞清技术的底层机制、弄明白问题的深层次原因、知悉解决方案的适用场景，是每个开发人员应有的技术素养，也是个人发展上积累功底、产品生命上维持稳定所必须的。
问题背景
机器人模拟测试是对各类已有的压力测试方法做了一个平衡， 通过高还原真实玩家的用户行为，模拟高并发场景，从而得到类似很多人同时游戏的测试效果。
其中通过模拟机器人测试有四个优势：

高还原游戏玩法，深度模拟真实用户行为；

并发性不受限制，从到，压力能够自主设置；

可以反复执行，便于性能调优回归；

实现小时不断监控。


在开发提交代码之后，版本在自动编译之后就跑新的测试，这样每天都能进行性能监控，在调优方面，完全的进行一个重复性测试，可以不断的进行回归和调优。这个方法的问题就在于机器人模拟需要专人开发，对测试者的开发能力，分析能力都有一个比较高的要求。

而要开发一款进行服务器性能测试的机器人，需要通过建模、分析、开发三个步骤，那么今天我们就要来介绍一下，具体在开发服务器性能测试机器人的时候，如何让它表现的更像人？有更加平稳和正常的表现？
为了让介绍的内容更加形象和具有说服力，我从我们自己的产品开始介绍，扒一扒腾讯服务器性能测试在开发机器人的过程中遇到的一些坑。
平台的服务器压测，支持用户在一个测试用例中定义递增的机器人数量，通过逐步增压的方式，来探索服务器的实际承受能力。从下图的机器人压力曲线图可以获取直观的概念：

曲线统计的是每个时刻连接到服务器并且进行业务数据收发包的在线机器人个数，由曲线看上去，可以感受到压力是平稳递增的中间有微小下跌，是因为当前的模式下，会在不同的阶段更新和重启机器人，这个也是后面会优化之处。然而，为了在测试结果报告中画出这样一张合理的图，也是经历了几番折腾，总结一下，还是蛮有意思的。
优化历程
对于上图描述的同一个压力逐渐递增的测试用例，经过了许多版本的迭代才能得到最终的效果，最早版本的机器人压力曲线，统计生成后出现了这样的问题。
问题：模拟机器人在开始的十几秒内，压力还算有些头绪，后面某个时刻，就经历了急剧的下跌，之后就完全无规律可循了。
分析：经过定位，这个阶段的问题是，我们的压力测试工具在响应包较大时，会出现接收缓存区数据被并发写入而数据污染的情况，导致程序掉。经过快速的修改调试，问题终于被修复。，压力曲线应该会比较平稳了吧。
然而理想很丰满，现实很骨感，模拟机器人依然存在问题：在大概二十秒内的时间，还是比较平稳地增增减减，维持在一个稳定的水平。然后到二十秒后，又会出现急剧地下降，压力上不去，大概半分钟后，反扑，上升，没多久再急剧下降。
分析：首先查看压力工具的运行逻辑，一切正常；程序，没，一切正常；日志错误，没有，一切正常。那压力为何上不去呢？查看系统的各种运行时数据，终于发现了问题所在：
原因：由于咱们的机器是部署在合作伙伴腾讯云这里的，机器拿到后也并未进行大的配置调整，所以系统默认可用的端口范围还是比较小的，如下图：

而作为一个模拟机器人的压力机，必然会在短时间内并发和服务器建立大量的连接，所以本地的端口号是必须大一点的，直接改文件，增加范围，搞定：

原因：其实就是经典到有些老生常谈的 问题了。因为我们压力机的机器人，会并发建立很多短连接，并且每次都由机器人主动断开短连接，所以导致系统中存在大量的连接。直接结果就是没法建立新的连接，在线机器人数量上不去。

这里简单地提两个要点：
、是在连接的主动发起方才有的状态，一句话概况，它是为了防止“主动断开连接方发送的最后一个包异常，导致被动关闭防会重发请求，影响该四元组上的下一个连接的正确性”这一问题而设计的，通过主动关闭方等待，即两倍的报文生存期的时长来避免。如此，报文一来一回的时间都等完了，大概率保证了确实没异常了。继而，系统中也就常常会出现大量的连接。

、解决的方法，一般是把两个内核参数：__、__都改为，前者指启动 连接的快速回收，后者指让 的四元组可以快速用于新连接。
然而两个优化都是有需要注意之处的：
对于第一个参数，当它置后，为了解决设计时出发点的风险，新来的连接请求在如下情况会被拒掉：同一客户端在某时间窗内的新连接时间戳变小。虽然一般是不会存在这种情况的，但是，对于而言，则天然容易出现这个问题：连接服务器 连接服务器   先被  同一 请求到了服务器  请求被据。
对于第二个参数，一般认为，它不太能解决纯服务端的资源占用问题，因为四元组虽然能用了，但资源还是没释放；但对于有客户端性质的情况是适用的，如连接的服务端进程。了解了这些之后，我们的压力机，既不存在要响应过来的客户端请求的情况，又不存在服务器端的特点，所以天然是非常适合用这两个内核参数的优化的。
经过这一轮系统参数的优化后，在线机器人数量基本稳定了：

因为是短连接，所以在线机器人的数量曲线并不是水平的，但至少可以一直保持较高的并发。更进一步，我们在产品的实现层面又做了优化，开放长短连接配置给用户，同时对于协议的简单模式，仿照真实的浏览器行为，将默认行为置为长连接。这样，就会出现文章开头的理想曲线了：

总结感受
其实本文中的优化只是非常小的一个点，也没有什么惊心动魄的过程与艰深晦涩的理论，几轮优化着手点涉及的概念范畴也杂，但却是一个真实的逐步解决问题的典型。
在这个网络发达，信息爆炸的时代，基本上对于每个技术点或者问题，都可以迅速地获取到大量资料。关键是对于技术的实现原理和问题的解决方案，却不能仅仅知其然，还必须知其所以然——搞清技术的底层机制、弄明白问题的深层次原因、知悉解决方案的适用场景，是每个开发人员应有的技术素养，也是个人发展上积累功底、产品生命上维持稳定所必须的。
而腾讯的压力测试团队正是运用了沉淀十多年的内部实践经验总结，通过基于真实业务场景和用户行为进行压力测试，推出一套面向游戏业务的综合性应用性能管理解决方案，该方案旨在帮助游戏开发者发现服务器端的性能瓶颈，进行针对性的性能调优，降低服务器采购和维护成本，提高用户留存和转化率。
目前腾讯服务器性能测试已经正式对外开放，业务场景模拟，持续压力触达服务器极限，帮助寻找服务器性能问题！点击立即体验！ 是常用的机器学习算法之一，因其出色的特征自动组合能力和高效的运算大受欢迎。这里简单介绍一下  算法的原理，后续再写一个实战篇。
、决策树的分类
决策树分为两大类，分类树和回归树。
分类树用于分类标签值，如晴天阴天雾雨、用户性别、网页是否是垃圾页面；
回归树用于预测实数值，如明天的温度、用户的年龄、网页的相关程度；
两者的区别：

分类树的结果不能进行加减运算，晴天 晴天没有实际意义；
回归树的结果是预测一个数值，可以进行加减运算，例如  岁  岁= 岁。
 中的决策树是回归树，预测结果是一个数值，在点击率预测方面常用 ，例如用户点击某个内容的概率。

、 概念
 的全称是    ，梯度提升决策树。
要理解 ，首先就要理解这个 。
 是一族可将弱学习器提升为强学习器的算法，属于集成学习 的范畴。 方法基于这样一种思想：对于一个复杂任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家单独的判断要好。通俗地说，就是三个臭皮匠顶个诸葛亮的道理。
基于梯度提升算法的学习器叫做   。理论上， 可以选择各种不同的学习算法作为基学习器。 实际上是  的一种情况。
为什么梯度提升方法倾向于选择决策树作为基学习器呢？也就是  为什么要和  结合，形成   决策树可以认为是  规则的集合，易于理解，可解释性强，预测速度快。同时，决策树算法相比于其他的算法需要更少的特征工程，比如可以不用做特征标准化，可以很好的处理字段缺失的数据，也可以不用关心特征间是否相互依赖等。决策树能够自动组合多个特征。
不过，单独使用决策树算法时，有容易过拟合缺点。所幸的是，通过各种方法，抑制决策树的复杂性，降低单颗决策树的拟合能力，再通过梯度提升的方法集成多个决策树，最终能够很好的解决过拟合的问题。由此可见，梯度提升方法和决策树学习算法可以互相取长补短，是一对完美的搭档。
至于抑制单颗决策树的复杂度的方法有很多，比如限制树的最大深度、限制叶子节点的最少样本数量、限制节点分裂时的最少样本数量、吸收  的思想对训练样本采样，在学习单颗决策树时只使用一部分训练样本、借鉴随机森林的思路在学习单颗决策树时只采样一部分特征、在目标函数中添加正则项惩罚复杂的树结构等。
演示例子：
考虑一个简单的例子来演示  算法原理。
下面是一个二分类问题， 表示可以考虑的相亲对象， 表示不考虑的相亲对象。
特征维度有  个维度，分别对象 身高，金钱，颜值

对应这个例子，训练结果是  的，全部正确， 特征权重可以看出，对应这个例子训练结果颜值的重要度最大，看一下训练得到的树。
 ：

 ：

、原理推导
 目标函数
监督学习的关键概念：模型、参数、目标函数 
模型就是所要学习的条件概率分布或者决策函数，它决定了在给定特征向量时如何预测出目标。
参数就是我们要从数据中学习得到的内容。模型通常是由一个参数向量决定的函数。
目标函数通常定义为如下形式： 
其中， 是损失函数，用来衡量模型拟合训练数据的好坏程度；Ω称之为正则项，用来衡量学习到的模型的复杂度。
对正则项的优化鼓励算法学习到较简单的模型，简单模型一般在测试样本上的预测结果比较稳定、方差较小奥坎姆剃刀原则。也就是说，优化损失函数尽量使模型走出欠拟合的状态，优化正则项尽量使模型避免过拟合。
 加法模型
 算法可以看成是由  棵树组成的加法模型：

如何来学习加法模型呢？
解这一优化问题，可以用前向分布算法  。因为学习的是加法模型，如果能够从前往后，每一步只学习一个基函数及其系数结构，逐步逼近优化目标函数，那么就可以简化复杂度。这一学习过程称之为 。具体地，我们从一个常量预测开始，每次学习一个新的函数，过程如下：

在第  步，这个时候目标函数可以写为：

举例说明，假设损失函数为平方损失 ，则目标函数为：

其中，称之为残差。因此，使用平方损失函数时， 算法的每一步在生成决策树时只需要拟合前面的模型的残差。
 泰勒公式
定义：

泰勒公式简单的理解，就是函数某个点的取值可以用参考点取值和  阶导数的来表示，而且这个公式是有规律的比较好记。
根据泰勒公式把函数在点处二阶展开，可得到如下等式：

则等式 可转化为：

假设损失函数为平方损失函数，把对应的一阶导数和二阶导数代入等式 即得等式。
由于函数中的常量在函数最小化的过程中不起作用，因此我们可以从等式 中移除掉常量项，得： 

  算法
一颗生成好的决策树，假设其叶子节点个数为，
决策树的复杂度可以由正则项来定义，即决策树模型的复杂度由生成的树的叶子节点数量和叶子节点对应的值向量的  范数决定。
定义集合为所有被划分到叶子节点的训练样本的集合。等式 可以根据树的叶子节点重新组织为  个独立的二次函数的和：

定义，则等式 可写为：

因为一元二次函数最小值处，一阶导数等于 

此时，目标函数的值为

综上，为了便于理解，单颗决策树的学习过程可以大致描述为： 枚举所有可能的树结构  用等式 为每个  计算其对应的分数 ，分数越小说明对应的树结构越好 根据上一步的结果，找到最佳的树结构，用等式 为树的每个叶子节点计算预测值
然而，可能的树结构数量是无穷的，所以实际上我们不可能枚举所有可能的树结构。通常情况下，我们采用贪心策略来生成决策树的每个节点。 
 从深度为  的树开始，对每个叶节点枚举所有的可用特征 针对每个特征，把属于该节点的训练样本根据该特征值升序排列，通过线性扫描的方式来决定该特征的最佳分裂点，并记录该特征的最大收益采用最佳分裂点时的收益 选择收益最大的特征作为分裂特征，用该特征的最佳分裂点作为分裂位置，把该节点生长出左右两个新的叶节点，并为每个新节点关联对应的样本集 回到第  步，递归执行到满足特定条件为止
 收益的计算
如何计算每次分裂的收益呢？假设当前节点记为 分裂之后左孩子节点记为 ，右孩子节点记为 ，则该分裂获得的收益定义为当前节点的目标函数值减去左右两个孩子节点的目标函数值之和：
根据等式 可得：

其中，项表示因为增加了树的复杂性该分裂增加了一个叶子节点带来的惩罚。
最后，总结一下  的学习算法： 算法每次迭代生成一颗新的决策树  在每次迭代开始之前，计算损失函数在每个训练样本点的一阶导数和二阶导数  通过贪心策略生成新的决策树，通过等式 计算每个叶节点对应的预测值 把新生成的决策树添加到模型中：
保持简单
易经中说道易则易知，简则易从，就是越是简易的东西，越是容易被理解和得到执行。很多机器学习模型都会尽量让学习到的模型尽量简单，尽量减少参数，越是简单的模型，通用性越好，也是这个道理。
 和  的区别：
：

 它的非线性变换比较多，表达能力强，而且不需要做复杂的特征工程和特征变换。
 的缺点也很明显， 是一个串行过程，不好并行化，而且计算复杂度高，同时不太适合高维稀疏特征；
传统  在优化时只用到一阶导数信息。

：
它有以下几个优良的特性：
 显示的把树模型复杂度作为正则项加到优化目标中。  公式推导中用到了二阶导数，用了二阶泰勒展开。 用牛顿法貌似也是二阶信息 实现了分裂点寻找近似算法。 利用了特征的稀疏性。 数据事先排序并且以  形式存储，有利于并行计算。 基于分布式通信框架 ，可以运行在  和  上。最新已经不基于  了 实现做了面向体系结构的优化，针对  和内存做了性能优化。导语 来了，不要慌，浏览器帮你解决 

年月日以后，所有需要访问网页的都要面临一个问题：。
  是苹果在ＷＷＤＣ 提出的， 在推进网络通讯安全的一个重要方式，按照苹果的要求非的网络访问是被禁止的；当然现阶段我们可以通过在里面中添加  字典并且将  设置为 来禁用 。
不过在 中，明确表示将收紧的访问，从年月日起，所有提交的默认不允许使用 来绕过的限制，这样对于浏览器、手、空间等需要访问大量第三方站点的应用来说，提前解决的问题就迫在眉睫。
是怎么让你访问不了的？
要完美解决的问题， 需要找到一个方法既能够访问站点，又能不使用 来绕过苹果的审核；
首先我们看是通过什么办法让不能使用的，我们打开进行尝试；发现打开之后通过和都不能使用请求，因此我们怀疑是通过自己的网络组件和来控制的访问。
因此我们进一步验证这个想法，我们用了浏览器的组件，打开之后通过协议访问请求，发现能够成功访问网站。
最后我们确定 是通过自己的网络组件来控制访问的，因此只要能自己实现协议或者不用协议就能绕过的限制。
但是怎么应对苹果的这个策略呢？不到两个月的时间重写一个并且稳定下来几乎就是一个不太可能完成的任务，而我们浏览器组件已经在浏览器线上稳定运行好几年，灰常成熟和稳定，得到过千万级别用户的验证，是一个快速接入和上线的理想选择。下面我们介绍一下浏览器的组件；
浏览器 －解决问题
– 通过接管的网络层请求，将请求通过协议发送到浏览器的后台代理服务器；后台代理服务器再通过骨干网络去对方服务器抓取数据；
的架构图如下：
这种实现方式有如下几个优势：
解决的问题：
浏览器使用的协议是基于底层自己实现的网络通信组件，没有使用任何提供的网络组件，并且也不是协议，所以能够完美解决防止的问题，并且协议本身是二进制协议，安全性强于；
省流加速：

通过和浏览器后台的长链接减少延时；

 也压缩减少数据传输；

并发网络请求提高效率；

指定请求优先级加快网页展示；

后台还做了就快接入、图片压缩、资源缓存、广告过滤


解决运营商网页劫持；
和浏览器后台代理之间是协议通道，运营商劫持代价很高，所以不会劫持；后台的代理服务器和网站的之间是通过骨干网络访问也避免了运营商劫持；
解决的劫持
和浏览器后台代理通过连接，请求到了后台的代理服务器才进行解析，不给运营商劫持机会；
集成了浏览器多年来对解决的
协议本身是支持加密的，相对来说，安全性也是可以得到保障的；
前进后退缓慢问题、 修复等等，后续还会增加的过网络层，等问题的修复；
现在已有手Ｑ、京东、微云、空间等接入了，为他们解决了，网络劫持的问题。

相关推荐
还有  天，苹果就要关上  大门了
借助腾讯云开启全站及问题解决分享
实现全站访问唐云兵：在腾讯从事后台开发年多，手个性装扮和动漫后台。喜欢了解一些后台优秀组件设计，喜欢徒步和羽毛球。最近学习和实践个性推荐。

一 背景
去年年底开始做手个性装扮的个性推荐的事情，进行了一次分享，主要讲了个性推荐的一些理论和我们的一些实践。本文重点从理论上出发，会提及少量个性装扮的实践。
为什么要做个性推荐这个事情，比较常见的答案就是要做精细化运营。对于个性装扮业务也是一样，因为个性装扮的物品越来越多，表情就有多套，加上原创开放平台的上线，各种作品迅猛增加。用户手机端展示的区域有限，为了能让用户在有限的展示区域里面尽量看到自己最喜欢的东西，所以启动了个性推荐。
二 衡量算法效果
在做个性推荐之前，我们需要先了解衡量这个事情效果的方法。《推荐系统实践》这本书上有讲到好多评估推荐效果的理论指标，其中使用频率最高的还是准确率、召回率和覆盖率。
准确率其实就是推荐给用户的东西里面有多少东西是用户用了的。如果推荐的东西绝大部分都被用户使用了，那就是推荐得准；如果推荐的东西用户都不喜欢，不使用，那就是推荐得不准确。公式如下：

在离线训练挑选模型的时候通常都会使用这些指标来指导我们选择哪个算法模型。推荐算法在线上运营的时候，我们更多的就是看一些实际的业务指标了。比如拉开通的数据对比、拉活跃的数据对比、下载的数据对比。在我们个性装扮的业务场景里面更多的是希望用户能点击看详情或使用，所以我们重点关心的指标是点击曝光率——用点击量除以曝光量。关于衡量指标和数据上一定要有对比，保留一部分流量走原来的逻辑，大部分流量走推荐逻辑，这样就可以进行数据的对比，而且可以在后续的运营和算法更新中，检查算法是不是出问题了。更好的一种做法是保留对比逻辑的那部分小流量也不是固定的某些用户，这样能避免这些用户无法使用体验较好的逻辑，也能避免因为流量用户划分的因素对数据的影响。
三 协同过滤
推荐最早最经典的算法就是基于物品的协同过滤算法。使用的地方也很多，典型的就有亚马逊网站。其基于的一个理念是：一个用户可能会喜欢跟他曾经喜欢过的物品相似的物品。比如说你比较喜欢《机器学习》这本书，《深度学习》和《机器学习》比较类似，是不是你也很大可能喜欢《深度学习》。
怎么来定义物品是相似的呢？比较自然的想法是看物品的属性信息，比如类型、标签、描述等。也有一些推荐算法就是这么来做的，但是根据这些判断比较依赖标签等信息的客观和完整，不好确定物品之间的相似性。可以参考的一个思路就是对物品的属性数据，根据文本相似度来衡量物品的相似度。
相比这个比较自然的想法，还有一个经典的思路就是协同，根据用户已经产生的行为来计算物品之间的相似度。这个相似度基于的一个假设是：喜欢物品同时喜欢物品的人越多，那么和的相似度就越高。这样一来根据用户的行为数据计算物品的相似读就有一个公式：
这样的话计算出来的物品相似度是基于用户行为空间的，并不是基于物品属性空间的。经典的案例就是啤酒和尿布，这两个在物品属性空间上风牛马不相及的物品，在用户行为空间上就是相似度特别高的。下面的图就是示例如何从用户行为数据得到物品之间相似度的数据：

上面的公式在有一种场景时比较不合理，就是物品是一个热门物品，这样的话物品和所有物品的相似度都很高。热门物品往往没有非热门物品更能体现一个用户的喜好。所以对上面的公式进行优化就有：

从上面的步骤，我们得到了物品之间的相似度，那么怎么给一个具体的用户进行推荐呢，哪个物品又更应该推荐在前面呢？我们可以通过用户对自己已有的物品的喜欢程度和这些物品相似度高的物品进行计算得到一个用户对一个推荐物品的喜欢预估，公式如下：

公式中的值怎么选取可以根据工程实际来确定一个比较合适的值。值在非极端情况下，差一点点对结果影响很小。
比如说用户有一本《中文版》喜欢度是，有一本《编程之美》喜好度是，下面的示例就是怎么计算即将推荐的物品的先后排序。

这里是在用户行为空间找物品的相似度，然后根据用户已有的物品推荐行为空间上的相似物品。基于物品属性空间相似度的推荐思路其实差不多。
这里其实还有两个问题，一个就是用户冷启动，一个就是物品冷启动。
从预估用户对推荐物品的喜欢程度的公式可以看出，如果用户拥有或喜欢的物品集合是空集，那这个公式就无从算起。针对用户冷启动有很多解决方案，我们通常简单有效的方法就是对冷启动用户推荐热门物品。另外一个思路就是从其他的一些特征比如用户的性别、年龄、教育程度、文化、职业等找到相似的用户，然后推荐相似的用户用的多的物品。
物品冷启动就是一个物品新上架的时候，还没有任何用户使用，这个时候在用户行为空间是找不到跟这个物品相似的物品的。所以对这种物品也就无法用上面的方法进行推荐。一个比较简单有效的方法就是在产品逻辑层面增加一个新品模块，新上架物品在新品模块展示推广。也有一些其他的思路，就比如利用物品的属性空间上物品的相似度来进行推荐。
说了基于物品的协同过滤推荐算法，必然少不了要提及基于用户的协同过滤算法。基于用户的协同过滤算法基于的一个理念是：一个用户会喜欢与相似的用户所喜欢的东西。比如你和都是喜欢看科幻片的人，喜欢看《西部世界》，你很大可能也喜欢看《西部世界》。那这里的相似的用户又是怎么定义和衡量的呢。一个比较自然的想法就是用户的属性，比如用户的性别、宗教信仰、年龄、教育程度、文化、职业等。同样的也可以在用户的行为空间上来定义和衡量用户的相似——使用共同物品越多两个用户越相似。
在用户的行为空间上通常使用距离来衡量用户的相似度，典型的距离计算公式有公式和余弦相似度，公式分别如下：

距离公式

余弦相似度公式
通常会使用余弦相似度公式进行用户相似度的计算。基于一个假设：对非热门物品的喜欢更能代表喜欢的一致，可以得到一个改进的余弦相似度公式，如下：

得到用户的相似度之后，可以通过如下的公式计算用户对即将推荐的物品的喜欢程度预估，公式如下：

这个公式里面也有一个值需要确定，可以根据工程实际来确定一个。下图是数据集在不用值下的测评性能。

从图中我们可以看到，值只要在合适区间内，值大小差一点对结果影响很小。同时值不是越大越好。
协同过滤算法在推荐系统上是很经典和适用很广泛的算法。同样有很多库可以帮助我们使用协同过滤算法，比如里面库就有算法，比如  ™             也能帮助我们快速的实现一个协同过滤算法。不同的库网上能找到不同的参考代码，这里贴部分实现的关键实现部分代码。

四 的尝试
上面都是传统经典的推荐算法，很多时候会跟其他推荐算法混合到一起使用，有的时候会借鉴这些算法的思想，衍生出一些新的推荐算法，比如在我们表情商城就有参考的思想，用进行物品之间的相似度计算，然后推荐的。
用进行推荐的一个处理思想是：把每个表情当作是一个词，用户下载和使用表情的序列当作一句话，使用全部用户的行为数据，用算法模型计算出每个词表情物品之间的距离相似度然后进行推荐。


网上可以下载到源代码，有兴趣的可以从代码上深入了解。
表情商城的推荐部分流量就是使用进行的。同时更多的场景使用的是进行推荐。先给出下效果如下图

下篇详细分析推荐和深度学习在推荐上的实验。导语：作为一个数学专业毕业的前端开发，有必要好好谈谈这个话题

一、数据结构及查找算法的实现
递归大法
递归 顾名思义，就是自己调用自己。一个经典的应用场景就是树查找。
  {
      
    
     ===   
      =     {
          =  
          
    }
     
}
 
首先设定树的根节点是，通过 循环获取每个子节点并调用函数自身，如果到叶子节点还没有找到，则返回 ，然后再次进入循环，  ，继续下一个子节点的查找。
这里首先是查找子节点，一直到叶子节点，如果没有才进入兄弟节点查找，因此，这里是一个深度优先的查找方式。
递归的有点是代码简单易懂，一目了然；然而，效率较低，因为每一次遍历都是从根节点开始一层层遍历到叶子节点，再原路返回查询结果；而且，函数同时承担了查找方式职责和遍历查找的实现职责，违反了代码设计中“单一职责”的原则。
、非递归：另一种深度优先算法
非递归有很多形式，我仅使用一种最常用的来展示非递归在树查找中的实现。
设计思路：修改的查找方式，如果有子节点，则下一个元素就是它的第一个子节点，否则，判断是否有相邻节点，如果有返回他的相邻元素。如果即没有子节点也没有相邻节点，就返回父节点的下一个相邻节点，然后重新进入循环队列。
 =
    我是 

  {
     {
        ===   
        = 
   }
}

  {
     {
         
    }
     {
         
    }
      {
         {
              
        }
    }
     
}


 
上面的实现按照我们的设计思路完成查找下一个元素，并将代码封装在中，这同样是一种深度优先的查找方式。
这种方式在浏览器查找元素中得到大量使用，不过首先使用_保存了所有元素，然后通过的方式实现查找，这个 以为做为， 以  作为 ，而查找唯一元素的方法的时间复杂度是，这就是我们常说的使用查询是最快的查找方式的原因。源码如下：
  = _
 = _{
           
    
}
在通过、，以及中通过单个和查找中同样使用了非递归。看看“”别人家的”代码
本体函数：
  = 
   = 
   {
    __
     = 
            
  }
 首先获取符合条件的第一个节点，然后不断获取下一个节点，直到将他们存放在一个里面，下次获取就不用重复查找了。
函数实现下一个节点的查找
  = 
   
     =   
 
 先获取第一个节点，如果不符合，则找到下一个节点，下面就是我们刚才提到的通过非递归的方式实现下一个元素。
   函数， 即上面使用实现的方法。
 
     
    == 
     
   
     
    
复杂选择器查找的实现稍微复杂一些，但关键的查找依然使用了上面方法。
、哈希结构及相关算法
现在有如个问题：后端接口返回一组图片，图片的，现在需要根据图片从这组图片中找到指定的图片展示出来。这个问题就可以抽象成：在由{     }组成的数组中根据指定的找到对应图片的。
遍历查找
   {
       =     =    ==  
     
}
上面使用了倒叙查找，某些情况下会比正序查找快些，但最坏情况下时间复杂度仍然为；
使用实现查找
是最常用的数据结构之一，然而，中并没有这种数据结构。通过使用的动态添加属性可以实现基于的查询。
一般接口给的数据以数组为主，为了将数据变成我想要的那种{       }形式，需要对接口数据处理一下。
假设数据结构如下：
  = 
    {
          
          
    }
    {
          
          
    }

我们想要的是当输入‘’，得到 ‘’。
  {
    _ = {}
}

 =   { 处理接口数据
      =      {
      _ = 
    }
     _
}


 =   { 根据获得
      ===   _ {
         _
    }
}

  =  


_
  
 这里简单介绍一下哈希查询。
哈希表就是一种以 键值 存储数据的结构，我们只要输入待查找的值即，即可查找到其对应的值。
哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。
使用哈希查找有两个步骤：

使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突。

处理哈希碰撞冲突。


由于 数据类型就是基于 实现的，所以，当使用使用对象的键查找值时，浏览器引擎已经在底层通过哈希函数将每个键转化为数据的索引，并使用内建的哈希碰撞处理函数处理了碰撞冲突。
在上面的例子中_对象每一个拥有一个独一无二的，在底层，我们其实是通过这个获得想要的的。
如上所示，哈希查找算法需要一定的时间和空间，在计算机内存足够大时，哈希查找的时间复杂度趋近于，是一种极有效率的查找算法！如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。如前所述，浏览器一般使用哈希查找实现查找唯一元素，中数据结构就是一种哈希表结构。
二、排序算法及实现
刚才说了一下和查询相关的算法，但是编程中算法应用最广泛的领域当属排序。具体到前端，我们经常遇到切换排序方式，实现按需展示的需求，比如，根据“最新”、“最热”、“评价最高”等来展示相关资讯；在网上商场中通过切换标签按“价格”、“评分”、“销量”、“时间”等展示相关商品等。
常见的设计是前端将排序条件作为请求参数传递给后端，后端将排序结果作为请求响应返回前端。但在实际生产中，受限于服务器成本等因素，当单次数据查询成为整体性能瓶颈时，也会考虑通过将排序在前端完成的方式来优化性能。
排序算法
排序算法是计算机科学中的一种最基础的算法，相关描述可以参见算法介绍。但为了下面叙述方便，我这里简单介绍一下算法中重要的几个方面。
为了下面叙述方便，我这里简单介绍一下算法中重要的几个方面。
一般我们会根据排序的方式来区分算法，比如我们常见的冒泡排序、插入排序、快速排序、归并排序等。一般使用算法复杂度时间复杂度和空间复杂度来评价一个算法，并根据实际需要对几种可选算法方案进行取舍。
时间复杂度越低意味着实现一个算法所需要的时间越少，这个算法就越有效率、越有价值，空间复杂度越低意味着实现一个算法占用的计算机内存越少，性能越好。
有时对算法进行取舍时还要考虑一个因素：稳定性。算法一般根据分为稳定性算法和不稳定性算法，没有中间值。稳定算法是指具有相同键值的元素在排序前后的位置是不变的，而不稳定算法正相反。举个栗子：对学生排序时我们规定：先按年龄排序，年龄相同的按学号排序；如果我们采用稳定算法排序时每次排序后年龄相同学号不同的学生的位置是不变的，采用不稳定算法排序时则不能保证相同的结果，因此每次排序后还要再对年龄相同的学生按学号排序。
关于各种算法其时间复杂度和空间复杂度的计算是另外一个大话题，我会在以后的文章中补充。
一图胜千言：
图一
排序在前端的应用及实现
既然说到前端排序，自然首先会想到的原生接口 。由于较低的时间复杂度，目前大部分浏览器都通过使用归并排序和快速排序实现方法。
从上图可以看出，在平均时间复杂度上两种算法相同，在空间复杂度上，由于归并排序是，快速排序是，所以归并排序的空间复杂度高，但如果不经过改造，归并排序一般是一种稳定排序，在考虑稳定性的情况下占有优势。
我们首先试着使用通过快速排序实现！
快速排序实现方法
算法思路：

先从数列中去除一个数作为“基准”理论上可以随便选取一个数

实现数组分区：将比这个”基准数“大的数放到“基准”的右边，小于或等于“基准数”的数放到“基准”的左边；

再对左右区间重复第二步，直到各区间只有一个数算法实现：



      
 

经典 快速排序 的 实现

  =  = {
     =  {
         
    }
      =    重要！！   算法思路中第一步 基准为位置 理论上可以任选
      =  
      = 
      = 
      = {
           {
            
        } {
            
        }
    }
       连接 左数组、基准数和右数组
}

    = 
 

  {
    经典排序时间
    
    经典排序时间
}
  
 上面是一种经典的快速排序方法只不过是版本的算法的实现，简单易懂。但是我们发现，上面的实现使用了和两个数组存放左右两边递归的数据，因此必须分配一块内存！所以，这其实使用实现的快速排序。算法的空间复杂度为，与理想的相差很大。
在对性能要求高的环境下，必须进一步优化算法，实现排序。

      
 
  {
        {
          = 
         = 
         = 
    }
        {

          =  选取固定 基准 为 

          =   = 
          ==  {
              =      {
                
            }
              =      {
                
            }
               {
                  
            }
        }
           将基准数归位
          返回基准点
    }
        {
         
           {
             =    获得 基准的 位置
                  对基准位置左边的元素进行排序
                  对基准位置右边的元素进行排序
        }
    }
        
     
}

  {
    排序时间
    
    排序时间
}


  = 
      

 
上面的实现，充分利用对数组元素进行原位交换找到最正确的，在保证时间复杂度的前提下使空间复杂度降低到。
然而，可能大家早就已经注意到，在图一中快速排序在最坏情况下时间复杂度退化成。这是什么意思呢？原来，在快速排序中，算法核心是找到一个基准——将经过比较交换的数组按基准分解为两个区域然后通过递归继续分解、比较和交换——这也是我们上面实现算法时一直在做的。我们考虑一种情况：我们对一个未知的但已经是正序的数组进行快速排序，如果我们像刚才的做法一样选择第一个或最后一个元素，那么每次都会有一个数区是空的！递归的层数将达到，最后导致算法的时间复杂度退化为。因此，考虑到这种情况，我们必须在选择时，进行处理。
我们可以尝试通过随机数选择一个，但依然存在选择的随机数是最左或最右的可能。我们可以再引入一个既不可能为最左元素也不可能为最右元素的元素作为的备选。比如，中间位置的元素！经过处理后我们的中间元素为大小介于最左元素和最右元素的中间值。
我们在上面的代码的基础上增加这个逻辑。

      
 
  {
        {
          = 
         = 
         = 
    }
        {
          =      
           {
              
        }
           {
              
        }
           {
              
        }
          =  这时  为左中右三个关键字的中间值

          =   = 
          =  { 从序列的两端交替和中间元素比较
                {
                
            }
                {
                
            }
             =  {
                  
                
                
            }
        }
           
         
    }
        {
         
           {
             =   
                 {
                    
            }
               {
                  
            }

        }
    }
        
     
}

  {
    排序时间
    
    排序时间
}


  = 
  

 
在我们一步步完善代码后，由于增加了确定“基准”元素的逻辑，运行时间虽有所增加，但在大数量的情况下，考虑到可以有效避免最差数据组合的算法退化，这种时间增加几乎可以忽略不计。
讲到前端排序，我们自然而然地想到的方法。然而方法的实现在各个浏览器中却不尽相同。采用了稳定的算法实现，而的引擎则采用了我们刚才研究的快速排序，正如我们刚才的分析，采用了同样的方法来规避快速排序最差数据情况下算法退化的情况，只不过在更大数据量的情况下做了进一步处理。比如当数据量小于时，采取中间元素作为基准点，超过后，对以外的的元素每隔一个固定的值比如个取值的索引，然后取这些索引的中位数作为基准点的位置。多个数取中位数很简单，这里不做解释，如果感兴趣可以扒来的代码研究。然而快速排序又是一种不稳定的排序，记得早在实现了算法不多久，就有人发现的这个问题，的解释是，快速排序是排序，内存占用少，引擎性能好，二期快速排序在实际计算机执行环境中比同等时间复杂度的其他排序算法更快不命中最差组合的情况下。
归并排序实现方法
对于采取稳定算法实现的浏览器，大多数采用了归并排序实现，比如。归并排序和快速排序的共同点是都采用了“分治”和“递归”的思想——将数组分成两部分然后递归处理。
归并排序，顾名思义，就是将已经排序好的子序列合并成一个序列，这个过程也成为“二路归并”。
以图释义：
图二
算法实现很简单，这里也简单实现一下。

      
 
  {
      = 
           {
        取出最小值，放到结果集中
           
            
        
            
    }
      合并，即“二路归并”
}

 {
      ===    设定 递归结束的标志

    将数组分成两部分
      =   
      =  
      = 

    递归调用并合并
      
}

  = 
          
  {
    排序时间
    
    排序时间
}
 
 由上面的算法也可以看出，归并排序必须递归将数组分成两部分存放，因此其空间复杂度为。
到这里，我们基本通过快速排序和归并排序实现了的方法。事实上，即便在我们处理各种复杂算法的时候，这两种排序也因为其优势成为最经常采用的排序算法。值得一提的是，另一种排序，插入排序，在样本数量较少时具有更好的效率，也值得应时而用。比如的引擎就在数据量小于时采用了插入排序，充分体现了对于性能优化的极致追求。
事情上，每种算法都有自己的优势和缺点，我们要做的是充分分析需求采取最合适的算法，这在复杂多变的前端尤其重要。比如，在对于稳定性要求高的排序中，采用不稳定算法实现的排序结果往往不尽相同，而对于内存、性能要求高的环境中，我们则更倾向于选择空间复杂度低的算法。
参考文档

排序算法
_

=
_=
_=



前言
开门见山，先来看下效果吧。

看到这么酷炫的效果图，不得不赞叹一下我们的设计师。然而，站在程序员的角度上看，除了酷炫之外更多的是复杂。但是，上面我们所看到的还只是最简单的一种形态而已。更加复杂的情况是当存在多个人脸的时候进行主次脸动画的切换，摄像头移动的时候动画的追踪，多个动画的之间的时序控制等问题，总之，展示加上各种业务逻辑使得这个动画变得异常复杂。今天我们要讲解的是剔除业务逻辑之外的单纯上的实现。
为什么是
选择一种方案的同时要给出为什么不选择另一种的理由是什么。没错，为什么这里不用自定义来完成绘图呢？既然自定义也可以实现一般的动画效果，为什么还要引入呢？可以把理解为一个经过系统优化的，可以用来高效执行一些帧数比较低动画的对象，但是对于灵活性更高的动画来说，并不是最好的选择。同时，对于普通的它们都是在应用程序的主线程中进行绘制的，我们知道在系统上我们不能够在主线程做一些耗时的操作，否则会引起。对于一些游戏画面，或者摄像头预览、视频播放来说，它们的都比较复杂，而且要求能够进行高效的绘制，因此，它们的就不适合在应用程序的主线程中进行绘制。这时候就必须要给那些需要复杂而高效的视图生成一个独立的绘图表面，以及使用一个独立的线程来绘制这些视图的，所以华丽登场了。
，它拥有独立的绘图表面，即它不与其宿主窗口共享同一个绘图表面。由于拥有独立的绘图表面，因此的就可以在一个独立的线程中进行绘制。又由于不会占用主线程资源，一方面可以实现复杂而高效的，另一方面又不会导致用户输入得不到及时响应。 一般与配合使用，需要重写以下三个方法：

    {
}    

          {
}    

    {
}
我们可以通过的函数可以获取对象，然后在子线程中通过 来获得 ，绘制完毕之后调用来释放，并把绘制的内容显示出来。
你所知道的
所谓属性动画：改变一切能改变的对象的属性值。内部的工作机制是通过寻找特定属性的和方法，然后通过方法不断地对值进行改变，从而实现动画效果的。提供了、、等几个方法来对属性进行插值操作，这几个方法都是设置动画作用的元素、作用的属性、动画开始、结束、以及中间的任意个属性值。动画更新的过程中，会不断调用更新元素的属性，所以使用更新某个属性，必须得有方法。经常配合进行使用：
  ==  {
     =    
     
    
}        
  ==  {
     =    
     
    
}        
  ==  {
     =    
     
    
    
}        
  ==  {
     =  
      =  
    
    
    
    
    
}
实用又强大的三角函数
大家有没有注意到转圈动画里面有一对小三角形呢？再细心点你会发现，这是个正三角形，并且其中的一个顶点正对着大圆的圆心，然后随着大圆一起转动，有木有？标题也说了，这里所有的元素都是自绘的，所以这两个三角形它不是设计同学给的资源，而是在上面绘制出来的，那么这里问题就来了：

如何确定三角形所在的位置？总不能把它画到圆外面去吧

如何确定三角形三个顶点的位置？总不能把它画歪了吧



这里先抛一下数学思路，后面会进行更详细的讲解。

绘制三角形
  数学问题：已知圆心 半径和角度求圆周上点的坐标？
  解：假设圆心的坐标为 ，那么圆的方程是＋＝
  根据方程可以求出圆上的各点坐标
  又已知角度，则圆上点的坐标分别是 
 
  拓展：已知正三角形中心点的坐标和其外接圆的半径，求其他三个顶点的坐标？
  解：可画出该三角形的外接圆，然后可把问题转化为求圆上三个点的坐标，又因为是正三角形，所以每个点的角度已知。解法同上。
 
人脸识别动画完全解析
所有的动画元素可以分解为以下几种，这里我们主要讲解第一种——扫描控件，因为这个是难度最大的

先来粗略看下扫描控件的设计稿这还不是全部的，一共有好几张，看不清的同学可以放大来看



转圈动画是整个动画的核心，我们先来看下，其实它是分了好几层圆圈，圆弧，圆环，圆点，然后组合在一起根据各自不同的方向和速率进行转动，同时还伴随着值的淡入淡出以及值的放大缩小，还有颜色的改变。，几乎平时接触到的动画里所有能改变的元素都掺和了进来。，，，，，，
重点来分析下那个大蓝圈暂且叫它为大蓝圈：由两个半圆弧组成，颜色为渐变蓝最后变为白色，中间夹着对称的两个三角形，然后在不同的时间段里以不同的速率进行旋转和缩放。嘿嘿，画圆弧是件很简单的事情，调用方法就可以了，圆弧的起始结束角度设计稿都有给了。这里的难点是在圆弧的不同部位绘制出渐变蓝色以及阴影效果。对于渐变颜色的填充，我们可以使用提供的 来实现，参数填入圆心的坐标，颜色数组，颜色的比例。最后调用方法即可。

         {}
  =  {       } 蓝圈的渐变颜色  =  { } 渐变颜色占的位置  =  
  =     
    这里居然需要减°来矫正

阴影效果可以调用提供的 来实现，参数填入阴影半径以及 。最后调用方法即可。
     {}
现在来看下大蓝圈上的三角形如何绘制出来，我们只分析左上角那个，右下角那个处于对称位置。以顺时针轴正方向为°角，那么根据设计稿的初始状态，可计算出左上角三角形的初始角度是位于°左右，右下角三角形的初始角度是°左右。这里我们的最终目标是求出三角形三个顶点的坐标，然后用线条连起来使其成为一个三角形，但是根据这些条件我们直接计算三角形的顶点坐标是做不到的。现在我们来分解下：先根据三角函数求出三角形的中心坐标，然后又由于这个是正三角形，再根据三角函数求出各个顶点的坐标。
由于三角形是在圆周上，假设圆心 ，半径，和三角形所在的角度，其实这几个变量都是知道的，圆心坐标则是人脸的中心点，可以通过人脸识别后的矩形坐标返回，半径则是设计稿给的初始半径，角度就是刚刚我们计算出来的°，那么根据三角函数可得该三角形的圆心坐标则是  = ，  =  。下一步计算三角形三个顶点的坐标。思路还是一样的：画出该三角形的外接圆，三角形的中心坐标即是外接圆的圆心，问题可转化为求外接圆上三个点的坐标，是不是又回到了上面的求解过程？是的。我们已知了这个外接圆的半径设计稿给出，圆心坐标，现在要知道的是三角形三个顶点的角度，然后我们就可以分别算出它们的坐标了。我们知道这是个正三角形，而且其中一个顶点指向大圆圈的圆心，暂且把这个顶点命名为。画出三角形的外接圆，即顶点相对于外接圆的位置就是右下角那个三角形相对于大蓝圈的位置，因为这两个三角形是对称的，顶点是相对的。也就是说顶点相对于外接圆的角度是°。如图：

那么这样就好办了，第一个顶点的角度为°，第二个顶点的角度为°° = °，第三个顶点的坐标为°°=°，再次运用三角函数可求得三个顶点的坐标，然后调用，，等方法把三角形的路径描述出来，最后调用把三角形绘制出来，三角形的绘制过程就到此结束了。
绘制三角形
  数学问题：已知圆心 半径和角度求圆周上点的坐标？
  解：假设圆心的坐标为 ，那么圆的方程是＋＝
  根据方程可以求出圆上的各点坐标
  又已知角度，则圆上点的坐标分别是 
 
  拓展：已知正三角形中心点的坐标和其外接圆的半径，求其他三个顶点的坐标？
  解：可画出该三角形的外接圆，然后可把问题转化为求圆上三个点的坐标，又因为是正三角形，所以每个点的角度已知。解法同上。
 
 =             
 =             
  =    取对称的角度，因为这是在三角形小圆里面的角度，不是大圆的角度
  =    正三角形，所以加°
  =   
  =  {
     =   }  
  =  {
     =   }  
  =  {
     =   }  
问题转化求三角形三个顶点的坐标看上面的数学解析
 _ =             
 _ =              
 _ =              
 _ =              
 _ =              
 _ =              
  =  
_ _
_ _
_ _

  
   
 
好了，最难的一块绘制完了，其他的外圈，内圈，透明圈等等也都问题不大了。嗯，接下来，我们应该让它动起来。为了让动画旋转起来，我们可以用一个变量运用到上面，然后在绘制的时候加上的变化值即可。，，等等都一样，需要在绘制的时候把这些值给加上去。
  ==  {
     =    
     
    
}
  ==  {
     =    
     
    
}
  ==  {
     =    
     
    
}
        
        
        
        
        
        
人物名称的绘制以及指示线条以及下面的资料浮窗就不说了，调用，，等等就可以实现其实线条的位置以及角度也需要运用三角函数进行计算，下面简单分析下右边小图片的波纹效果。

其实这里又有一个需要自绘的三角形，有没有感觉到崩溃？没关系，还是按照我们上面的套路，改变下初始角度就可以了，算法在手，三角形我有！其实波纹效果的绘制也比较简单，调用，然后通过不断地去改变圆圈的值和值，从而达到波纹的效果。见如下代码
  ==  {
     =     
     
    
    
}
  ==  {
     =  
    
    
}
  ==  {
      =     
      
     
     
}
  ==  {
       =  
      
      
}

    
     
到此，整个动画绘制完毕。现在服务器主要是居多，客户端一般通过上传文件到服务器，最开始的设想很简单，直接将图片转化为字节流，写入到的，随后发送出去即可。
但当这种方法出现问题，服务器根据文件名这个表单中的字段来判定是否接收到文件，我上面那种简单的方法从而使得每次服务器反馈说没有接收到图片文件，从而发送失败。由此推断是表单传输出了问题，由于历史原因，有很多表单传输的方法。当前官方推荐的是，但是利用构建表单的方式，没有成型的封装方法。比如对于的表单提交，简简单单几句话搞定：
          =  
         
         

             
          =   
的没有这么简单的封装形式，需要完整的请求体模拟，用起来相对不方便，不过这样能够对单提交的本质原理有更加清晰的理解。
端
在端上传图片总是失败的情况下，后台开发哥们帮忙实现了端的请求，是可以正常处理请求的，页面如下：选择文件之后，按浏览器的，便可出现开发者工具界面，在一栏可以看到具体的请求和响应，分析其请求头和请求体，来构造中相同的参数，就可以实现文件的正常上传。下面就根据端的请求来模拟实现的提交方法。
请求头分析
首先来看请求的消息头：

 
==

 =




          
 
根据请求头，去构建的相关参数：
  =  
  =  



 启动方法

 设置请求头内容
 
  =
请求体分析
下面来分析消息体 ，内容如下：
=
  = =
 

ÿØÿà
ÿÂ
Û{½óþÔ¾ÅæÑÏÙËºÍ’Ÿ¡˜ÈæÒ²Ä‘`•«©Ä¯”ÑÏ–³¶¬‚æ¶‹ ´Øƒ•ôÁÕåêå«—Œ¬¢«’úï’õøÔ™Ò°¢Ë“—Ê
…………………………………………
Ü‚È…ªÅ·Èª•‘ôë»Äç‹¬Û‹Ë=…™²òÇÇÌë«Ž™µ¼ÉÛçÙ®—´ù¿²šôí´
­¦ÃÒ…§ÑÙÄªÙúÜÉŽ½Ì‰ªˆêªÙ ’Ô—Ý_´àƒÔÿÙ

从消息体内容可以看出，请求消息体本质上就是字节数组或字符串。内容主要分为三部分： 
 开始和结束字段 开始和结束都有明确的字段字段的具体内容是由消息头中字段进行定义的：
 
=
这里面设置的和消息体中的必须保持完全一致，才可以确保消息能够得到服务端的正常解析。 
 表单信息 包含、、和等四个表单变量，必须要填写正确的字段，服务器才可以对相关变量进行正确解析 
 图片 中的乱码数据，就是文件的二进制表示了 
 换行回车\\所以构造的原理，就是按照这种顺序和特定的字段，进行模拟即可，代码如下：
 =  
  =  
  =  
=
\\
  =\\ =
\\
 
\\
\\     

 取得本地图片的字节流，向流中写入图片字节流
 = 
 =  
 =  

 =   
    {
      
     = 
     =  
     =   
}
\\ 

\\ 
\\
完整上传图片的代码
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
 

   {

      = 

      = 
      = 

       
      =     
      = 

      = 
       =   

      = 

     对包含中文的字符串进行转码，此为。服务器那边要进行一次解码
          {
          
    }

        {

         {
              =  
             =  

             允许向流中读写数据
            
            
            

             启动方法
            

             设置请求头内容
             
            
                      =

             =  
             =  

              =  
            
            \\
              =\\ =
            \\
             
            \\
            \\     

             取得本地图片的字节流，向流中写入图片字节流
             = 
             =  
             =  

             =   
                {
                  
                 = 
                 =  
                 =   
            }           
            \\ 
            
            \\ 
            \\ 

             端返回的信息
              = 
              ==  {
                  = 
                  =  
                  =  
                  = 
                  =  =  {
                      
                }

                
                
                  
            }

              =  {
                
                
            }
        }    {
                
            
        }    {
                
            
        }
         
    }
}
遇到的主要的坑：
这个问题花了五个小时时间，花费时间长主要原因如下： 

的多种表单提交方案 有、和，前两种方案，官方已不在推荐，而且很容易出现版本兼容性问题。所以需要采用，但是这种方案没有成型的表单提交接口，所以在上传图片时，服务器对表单解析很容易出问题。 
的工具，中的图片内容看不到，影响了对图片上传的理解。 最后采用浏览器来分析请求协议：图片中的内容一目了然，所以就知道如何去构造图片表单提交的内容了，所以这次非常感谢这种强大的工具，帮忙定位核心问题。

最终总结：
由于凝聚的开发者众多，很多问题都在网上有着成熟的解决方案，很快的利用网上方案就可以实现快速验证和功能的快速编写，但从另一个角度，这种编程习惯也会降低开发者的编程能力。从这次文件传输的调试过程中，自己也越发发现从根本原理来分析问题，才是追溯问题本质，提升对知识原理的理解深度的最佳途径。
附注：本文是参加腾讯云马拉松创意大赛，我们组作品的一个技术解决方案，源码链接。

相关推荐
动态库压缩壳的实现
探索第一篇——概念
深度了解  ，你准备好了吗？一、是什么？
说到，大家会联想到，而这里的却不仅仅是，而是。

 团队在收购了  团队，建立了轻量级日志系列 ，最终将    命名为  ，并将整个产品线的版本提升至 。
族谱：

成员介绍：
、
 基于，是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，风格接口，多数据源，自动搜索负载等。
、
 基于，是一个开源的用于收集分析和存储日志的工具。
、
 基于，也是一个开源和免费的工具，可以为  和  提供的日志分析友好的  界面，可以汇总、分析和搜索重要数据日志。
、
是公司开源的一款采集系统监控数据的代理，是在被监控服务器上以客户端形式运行的数据收集器的统称，可以直接把数据发送给或者通过发送给，然后进行后续的数据分析活动。
由如下组成

：是一个网络数据包分析器，用于监控、收集网络流量信息，嗅探服务器之间的流量，解析应用层协议，并关联到消息的处理，其支 持   、、、、、、、等协议；
：用于监控、收集服务器日志文件，其已取代  ；
：可定期获取外部系统的监控指标信息，其可以监控、收集 、、、、、、、、等服务；
：用于监控、收集系统的日志信息；整理自网络

二、用来做什么？
网管系统在日常运行过程中会产生各类日志数据，比如、以及系统等。以往我们对于日志一直又爱又恨。爱的是日志可以在异常时帮助我们定位问题，恨的是日志散布在各个角落，非常不好管理，而且我们一般都会做定期删除处理，也不便于回溯。
所以，我们急需一个可以集中收集、分析并输出表报的日志平台，毋庸置疑，就是最佳“人选”。既解决了日志集中收集难题，又可以灵活的组合分析、输出运维数据报表，而且整个系统还可以平行扩容。
三、架构设计
、引入
网管这边需要收集、系统以及慢日志。最开始将日志上报链路设计为：

后面发现每台服务器都要安装，实在太臃肿，从而引入了。
是成员之一，基于语言，无任何依赖，并且比更加轻量，非常适合安装在生产机器上，不会带来过高的资源占用，轻量意味着简单，所以并没有集成和一样的正则功能。
会将收集的日志原样上报，若日志源程序支持格式输出比如或，那么可以直接上报。但是，还有很多程序不支持修改日志格式，比如慢日志、系统日志等。因此，我们使用作为中间处理和转发组件。
此时，上报方案变为：

、引入
在实际应用过程中发现存在一些问题：
①、数据丢失：由于经常有新的日志类型加入，因此的规则文件会经常需要修改并重启，重启时就可能丢掉一些数据；
②、热点问题：随着日志源的持续增加，难以避免会出现日志上报热点问题。
因此，这里引入，实现了发送端和接收端负载解耦，并且解决了重启丢数据的问题。
、引入
自研程序日志上报有种可用方案：
方案①：自研程序生成日志文件读取
方案②：自研程序生成日志数据上报
对比分析个方案，会发现都存在问题，方案①会生成额外日志文件，实在冗余；方案②在上报时使用的是连接，可能会产生阻塞问题。
因此，最终在开发同学支持下引入了自研的，使用的方式收集数据，然后写入，从而解决了日志上报可能引起程序侧阻塞的隐患。
最终架构设计如下：
开源程序：负责从日志源读取数据上报到，并按照日志类型指定，通过从读取日志，并通过插件进行数据处理后上报到，最终通过展示；

自研程序：自研程序可以自己控制日志格式，所以这里不再需要落地日志文件，而是直接按需生成结构化日志数据，先上报到自研的规避应用阻塞，然后转发到，之后的路径则和开源程序日志收集方案一致。
好了，架构方面就简单介绍到这里，剩余内容请阅读后续系列文章。作者：

之前我们已经发过几篇  和修复的文章， 由于接口跟系统几乎一样，相信大家都比较熟悉，不熟悉用法也可以到   官网看一下。但是，我们也有一些特色功能和优化大家可能不容易注意到， 现在就单独拿出来说说。
加密接口
 使用了  的  层库，但没有直接使用   的封装层。  封装层中很多设置需要手写  语句实现，比如设置  迭代次数兼容老版本  、设置   等操作。

对于开发者来说，这需要了解  底下的  指令，更重要的是要搞清楚这些指令正确的调用顺序。 哪些是需要在设置  之前执行的？哪些是只有设置了  之后才生效的？开发者往往必须仔细查阅  的文档来了解这些细节。
 对这个部分做了改进，封装了  用于设置加密参数，设置好了传给  工厂方法就好了，不需要考虑  语法和调用顺序。

使用  另一个好处是，同样的结构可以传给  用于恢复损坏 ，不需要两套 接口了。由于  底层不使用 ，原来  的形式不能满足需要。
另外， 将  类型的密码改为  类型，可以支持非打印字符作为密码比如   方式，原来字符类型密码只要转换为  的  数组即可，和   兼容。
数据迁移
 提供了 _  函数用于导出数据到挂载的另一个 ，可以用于数据迁移。 但这个函数用于  的  并不方便。
 主要帮助开发者做  版本管理，通过它打开  数据库，会读取 _ 字段来判断是否需要升级，并调用子类实现的 、 等接口来完成创建或升级操作。 _ 由于是导出而非导入，就跟  等接口不搭了，因为要关闭原来的 ， 打开老的 ，执行  到新 ，再重打开。
为了方便使用， 就做了扩展，将 _ 扩展为可以接受第二个参数表示从哪里导出， 从而实现了导入。

如此就可以不关闭原来的数据库实现数据导入，可以兼容  的接口了。详细可以看我们的 。
全文搜索分词器与动态  加载
  自带了一个  分词器，名为 ，用于实现  全文搜索。 分词器的使用与  自带的 、 等分词器一样，创建虚拟表的时候带上名字即可：

 分词器与官方  分词器类似，但对中文象形文字分词以及  库加载做了特殊处理。  对中文的分词是基于词库的， 系统不同版本会附带不同版本的 ，捎带不同版本的中文 词库，当然也会带来不同的分词结果，这个对于统一产品体验是非常不利的。
另外， 自带的中文词库并非非常完整，组词效果也一般，但若自带一个完整好用的词库， 又需要非常大的空间，这个空间会体现在  体积上。最终，我们做了折中， 中文字全部单字成词，其他文字则使用  默认规则。
 还有一个严重的问题是动态库和自带的数据文件体积很大，超过 ，编译进  里相当不划算， 最好能直接加载系统自带的  库。但加载系统库有另一个障碍： 库不同版本会在函数名称后面 带上版本号后缀，直接编译时连接行不通。
为了克服这个障碍， 做了一个兼容层 ，通过系统带的数据文件推断  版本， 通过  动态加载不同的符号名称，然后通过宏来模拟直接调用方便开发。最终实现效果便是在不需要自带  库的前提下使用  库的断词、归一化等功能，为最终  包省下  以上空间。
有了  兼容层，要实现  框架自带的  相关功能就简单了，比如 排序。 但是， 目前没有接入主要是没有相关需求，有这方面需要的话，可以到我们的  提  哦。
日志重定向与性能监控
 和  框架在运行中会产生日志，这些日志默认会打印到系统日志，但这可能不是 所有开发者都希望的行为。比如担心日志里带有敏感信息，直接输出到系统不妥，或者希望将日志写到文件 用于上报和分析， 提供接口来完成日志重定向。

要实现高性能日志持久化，可以考虑使用我们  里面的  组件。微信终端跨平台组件  系列一  高性能日志模块
 还提供了性能监控接口 ，实现接口并绑定到  可以在每次 执行  语句或连接池拥堵的时候得到回调。

 也开放了  方法，可以打印出数据库的当前状态，包括连接池内所有连接 被持有的状态以及最近执行的  语句和耗时，对排查性能和死锁问题也有很大帮助。
优化  实现
在  发布时，我们的一篇文章上提到  实现优化。对于 查询获取  → 遍历 → 关闭 这种简单的场景，我们通过  直接操作  底层的查询，避免  的重复分配带来的损耗。
可以看一下我们发布时的文章： 微信进化之路  开源与开始
需要注意的是   未关闭前会占用一个数据库连接，使用完需要尽快关闭，否则会一直占用 造成别的线程无法请求到连接。遍历  过程中同一线程不做其他  操作，遍历完关闭，配合  使用，是最佳实践。

本文来源于： 微信公众号

相关推荐
微信移动端数据库组件系列：基础篇一微信移动端数据库组件系列：数据库修复三板斧二微信移动端数据库组件系列：原理篇三现在什么都是，看电影，打游戏，估计打车，很快就会面世。那么作为前端开发的标准语言，和能不能也搞出点大新闻呢？刚好最近在做一个活动时，就遇到了需要播放全景视频的需求，顺便就研究了一下，一个用于在浏览器中绘制图像的库，这篇文章算是做个笔记，也希望能帮助到那些想快速入门的同学。
最小环境
首先，在正式学习前，有几个概念需要说明的。在底层其实还是调用中的 来实现绘图的。但和我们一般绘制图像不同，在底层使用的是的 来实现绘图。 本身更多是直接对的操作，用起来相当不直观，为此在顶层对绘图所需的各种元素例如场景，摄影机，灯光，几何图像，材质等进行了封装，如果我们需要使用来绘图，只需要创建一个最小绘图环境即可，这个最小绘图环境包含了三个要素：
场景包含所有需要显示的物体以及其他相关元素的容器
摄像机决定场景如何投影到画布之上
渲染器用于最后绘制的画笔
具体的代码如下：
 =__

     {    }  ‘’

      =    创建场景

      =         创建摄影机
     = 

      =    创建渲染器
       设置画布大小
      设置像素比，针对高清屏
       设置默认背景色

      把画笔插入到中


简单的几句代码，就可以建立起一个最小绘图环境，之后只要我们向这个环境中放入需要显示的对象，这些对象就会被绘制在画布中，显示在屏幕上。
对象
有了环境，我们还需要告诉，到底需要显示什么物体。为此，我们首先需要定义这个用于显示的物体，然后把他加入到场景中即可。
 =__

     {    }  ‘’

      =      创建一个长方体，用来定义物体的形状

      =  {   }  创建一个材质，用来定义物体的颜色

      =     使用形状和素材，来定义物体

    

     


先看看效果

怎么感觉好无聊，哈哈哈，但不管怎么样，我们已经可以绘制出东西来了。
形状和材质
估计大家看了上面的代码，一定会有一些疑问，那个是什么鬼，和又是用来干嘛的。其实在定义一个物体时，需要提供两个信息，第一是形状信息，也就是这个物体上每一个点，每一个面的坐标信息，第二是材质信息，用于告诉物体的颜色，纹理，反光等信息。有了这些信息，才知道要如何渲染这个物体。而上面的   ，就是告诉，我要显示一个长宽高各为的长方形。而 {  }，就是要告诉，这个长方体是红色的。最后根据形状和素材，  ，生成需要显示的物体。
上面提到在中如果要生成一个长方体，则需要定义一个，那除了长方体，还可以生成形状呢：
长方体
圆形平面
圆柱体
方形平面
环形平面
球形
文字
圆环
圆管
另外上面写到的，其实是指一个直接就能显示颜色的材质。什么叫直接显示颜色呢？这里要涉及到里的灯光设置。物体的材质由于确定物体的颜色，纹理，以及反光等属性。要反光，首先需要有一个光源：
 =__

     {  }  ‘’

      =  
     = 
     = 
     = 

    


这里我们定义了一个白光源，具体的效果如下：

为了可以看清楚效果，我在场景中加入了一个绿色平面，可以看到，这个绿色平面上的反光是从下到上减弱，可见，这个光源是在画面的下方。
如果我把光源的强度减弱，那么平面上的反光也会跟着减弱：

但不知大家有木有发现，绿色平面上的反光是减弱了，但红色的那个长方体，还是一样的红，完全没有变化。其实这就体现出不同材质的区别了，在红色长方体上，我采用的是这种材质，而在绿色平面上，我采用的是另一种称为的材质，这种材质的特点是漫反射强烈，主要用来模拟真实环境下的物体，例如木材，石料等物质的反光情况。另外还有另外一种材质叫，这种材质主要是镜面反射强烈，用来模拟镜子，金属等拥有高光的物体就比较合适。
和两种材质，都是需要光照才能看到的，如果场景中没有光源，你将会什么都看不到。相反我们在红色长方体上采用的材质是，这种材质即使没有光，也可以看到，你可以想象为它自己发光吧，如果用技术一点的话来说，就是和两种材质需要根据场景光线的数值来计算显示在屏幕上的颜色，而则忽略光线的作用，是什么颜色，就直接显示什么颜色，但也由于这种材质忽略了光照的作用，那么它也不会有任何阴影的效果。所以这种材质就叫，用来做演示就十分合适。一下就是提供给我们用到的其他材质

漫反射材质
镜面反射材质
根据物体上每一点到摄像机的远近来显示颜色，远的显示黑色，近的显示白色
根据物体上每一面的法向量方向来显示颜色
纹理贴图
如果绘制物体时，只能使用纯色，那也未免太单调了，没关系，提供了接口来帮忙解决这个问题。的材质，除了可以设置颜色，还支持纹理贴图，我们可以把一个图片，覆盖在物体上作为他的纹理，这样就可以利用这些贴图来模拟更真实的场景
 =__

     {   }  ‘’

      =  ‘’

      =  {   }


上面的代码中，我们通过来加载一个图作为纹理，并且把这个纹理通过属性映射到了材质上，加上材质后，整个物体就更加真实了

动画
能绘图了，但如何加入动画呢？其实很简单，在之前的代码中已经讲解过，是通过渲染器来绘图的，你可以想象成拍照。我们在场景中摆好灯光，摆好道具，渲染器咔嚓一下，就把当前的画面绘制下来了。那如果要做成动画，只需要在渲染器来个定时连拍就可以拉。具体如下。
 =__

      {
        
        
         
    }

      {
           
    }


这里我们通过接口，来做定时刷新，每次进入方法，都会先去执行方法用于更新场景，然后让渲染器拍照 ，最后等待下一次。在方法中，我们可以修改场景中所有物体的参数，例如，我们可以试着让盒子在屏幕中转动：
 =__

      {
         = 
         = 
    }


最后的最后，其实还有很多额外的能力，例如刚刚我们使用图片作为纹理，那么我们也可以使用视频作为纹理，把这个纹理贴到一个盒子上，通过陀螺仪来控制摄像机的拍摄方向，就可以作出一个全景视频啦。也支持粒子系统，模型数据导入，自定义着色器等一系列高级功能，大家也赶快掌握起来吧。计算着色器是一个完全用于计算任意信息的 着色器阶段 。虽然它可以渲染，但它通常用于与绘制三角形和像素无关的任务。
概述
计算着色器与其他着色器阶段的操作不同。 所有其他着色器阶段都有一组明确的输入值，一些是内置的，一些是用户定义的。 着色器阶段执行的频率由该阶段的性质指定 例如顶点着色器对每个输入顶点执行一次尽管有些执行可以通过缓存进行跳过。 片段着色器执行是由从光栅化过程生成的片段定义。
计算着色器的工作方式截然不同。 计算着色器操作的“空间”主要是抽象的 每个计算着色器都可以决定这个空间是什么意思。 计算着色器执行的数量是由用于执行计算操作的函数定义。 最重要的是，计算着色器没有用户定义的输入，并且完全没有输出。 内置输入仅定义执行特定计算着色器调用的“空格”位置。
因此，如果计算着色器想要将某些值作为输入，则由着色器本身通过纹理访问 ， 任意图像加载 ， 着色器存储块或其他形式的接口来获取该数据。 类似地，如果计算着色器要实际计算任何东西，它必须明确地写入图像或着色器存储块。
计算空间
计算着色器操作的空间是抽象的。 有一个工作组的概念 这是用户可以执行的最小的计算操作量。 或者换句话说，用户可以执行一些工作组。
执行计算操作的工作组的数量由用户调用计算操作时定义。 这些组的空间是三维的，所以它有多个“”，“”和“”组。 任何这些可以是，所以可以执行二维或一维计算操作，不用执行三维。 这对于处理粒子系统的图像数据或线性阵列或其他任何东西都是有用的。
当系统实际计算工作组时，可以按任何顺序执行。 所以如果给出一个工作组  ，可以先执行组  ，然后跳到组  ，然后跳到  等等。因此，计算着色器不应该依赖于处理单个组的顺序。
不要认为单个工作组与单个计算着色器调用相同 有一个原因叫做“组”。 在单个工作组中，可能会有许多计算着色器调用。 计算着色器本身定义了多少，而不是执行它的调用。 这被称为工作组的局部大小 。
每个计算着色器都具有三维局部大小同样，尺寸可以为，以允许或局部处理。 这定义了将在每个工作组中进行的着色器的调用次数。
因此，如果计算着色器的局部大小为  ，然后使用数量为  的工作组执行，那么您将获得个单独的着色器调用。 每个调用都将有一组唯一标识该特定调用的输入。
这种区别对于进行各种形式的图像压缩或解压是有用的 局部大小将是图像数据块例如×的大小，而组计数将是图像大小除以块大小。 每个块都作为单个工作组进行处理。
工作组中的个人调用将并行执行。 区分工作组数和局部大小的主要目的是工作组中不同的计算着色器调用可以通过一组共享变量和特殊函数进行通信。 不同工作组中的调用在同一计算着色器调度中无法有效地进行通信。 不是没有潜在的死锁系统。
调度 
计算着色器不是常规渲染管道的一部分。 因此，当执行绘图命令时 ，不涉及连接到当前程序或管道的计算着色器。
初始化计算操作有两个函数。 它们将使用当前活动的计算着色器通过或 ，遵循用于确定阶段的活动程序的通常规则。 虽然它们不是“ 绘图命令” ，但它们是“ 渲染命令” ，因此可以有条件地执行它们。
   __  __  __
__ 参数在三维中定义了工作组计数。 这些数字不能为零。 对可调度工作组的数量有限制 。
对于来自存储在缓冲区对象信息的工作组计数，可以执行调度操作。这与顶点数据的间接绘图类似：
  
参数是当前绑定到 ___ 目标的缓冲区的字节偏移量。请注意， 对工作组计数的相同限制仍然适用 然而，间接调度绕过了的常见错误检查。 因此，尝试使用超出范围的工作组大小进行调度可能会导致崩溃甚至硬锁，因此在生成此数据时要小心。
输入
计算着色器不能有任何用户定义的输入变量。
计算着色器具有以下内置输入变量。
  _
  _
  _
  _
   _
_  该变量包含传递给调度函数的工作组数。
_  这是此着色器调用的当前工作组。 每个组件将在半开放范围，_上。
_  这是工作组中着色器的当前调用。 每个组件都将在半开放范围， _ 上。
_  该值在这个计算调度调用的所有调用中唯一标识计算着色器的此特定调用。 这是数学计算的一个简单的手段：
_  _  _
_  这是_的版本。 它在工作组内识别此调用的索引。 这个数学计算很简单：
   _ =
           _ 。    _ 。    _ 。   
           _ 。    _ 。    
           _ 。   
局部大小
计算着色器的局部大小在着色器中定义，使用特殊的布局输入声明：
  __ = ， __ = ， __ =  
默认情况下，局部大小为，因此如果只需要一维或二维工作组空间，则只能指定或 和 组件。 它们必须是大于的积分常数表达式。它们的值必须遵守以下限制  如果没有，编译器或链接器错误发生。
局部大小作为编译时常量变量可用于着色器，因此您不需要自己定义它：
  _ 
共享变量
计算着色器中的全局变量可以使用共享存储限定符声明。 这些变量的值在工作组中的所有调用之间共享。 不能将任何不透明类型声明为共享，但聚合数组和结构都可以。
在工作组开始时，这些值未初始化。 此外，变量声明不能具有初始化器，因此这是非法的：
   =  没有共享变量的初始化器。
如果要将共享变量初始化为特定值，则其中一个调用必须将变量显式设置为该值。 由于以下原因， 只有一个调用必须这样做。
共享内存一致性

主要文章： 内存模型＃不相干的内存访问

共享变量访问使用非相干内存访问的规则。 这意味着用户必须执行某些同步才能确保共享变量可见。
共享变量都被隐式声明为相关的 ，所以不需要而且不能使用限定符。 但是，仍然需要提供适当的内存障碍。
通常的内存障碍集可用于计算着色器，但它们也可以访问 这个障碍专门用于共享变量排序。的作用就像，为各种变量排序内存写入，但它只为当前工作组排序 读写。
虽然工作组中的所有调用都被称为“并行”执行，但这并不意味着可以假设所有这些调用都是以锁步执行的。 如果需要确保调用已经写入某个变量，以便可以读取它，则需要同步带有这个调用的执行，而不仅仅是发出内存障碍您仍然需要内存屏障。
要在工作组内的调用之间同步读取和写入操作，您必须使用  函数。 这将强制在工作组中的所有调用之间进行显式同步。 在所有其他调用达到这一障碍之前，工作组内的执行将不会运行。 一旦执行完  ，以前在组内所有调用中写入的所有共享变量都将可见。
对于如何调用 有一些限制。 然而，计算着色器在使用此函数时并不像  那样受限。  可以从流控制调用，但只能从均匀流控制中调用。 导致对进行评估的所有表达式必须是动态均匀的 。
简而言之，如果执行相同的计算着色器，无论它们获取的数据有多么不同，每次执行都必须以完全相同的顺序命中完全相同的调用集。 否则可能会发生严重错误。
原子操作

主要文章： 着色器存储缓冲区对象＃原子操作

可以对整数类型的共享变量还有向量数组结构体执行多个原子操作。 这些函数与着色器存储缓冲区对象原子共享。
所有原子函数返回原始值。 术语“  ”可以是或 。
     
将添加到 。
     
的值不低于。
     
的值不大于。
     ，   
 和  按位进行与运算
     
 和  按位进行或运算
     
 和  按位进行异或运算
     
将的值设置为。
     ，   ，   
如果的当前值等于，则将设置为。 否则保持不变。
限制
可以在单个调度调用中调度的工作组数由 _____ 定义。 必须使用_进行查询，索引处于闭合范围，表示最大工作组计数的，和分量。 尝试使用超出此范围的值调用是一个错误。 尝试调用更糟糕 它可能导致程序终止或其他坏结果。
请注意，所有三个轴的最小值必须为。 所以你可能有很多的工作空间。
局部大小也有限制 有两套限制。 对于局部尺寸维度有一般限制，以与上述相同的方式查询_____ 。 请注意，这里的最小要求要小得多：和为，为。
还有一个限制：工作组中的调用总数。 也就是说，局部大小的，和组件的乘积必须小于_____ 。 这里的最小值是。
计算着色器中所有共享变量的总存储大小也存在限制。 是_____ ，以字节为单位。 所需的最小值为。 没有指定类型和共享变量存储之间的精确映射，尽管您可以使用布局规则和  大小作为一般准则。

后记：可惜  才支持这个新特性，而还只支持到。这是一篇很难写的文章，因为我希望这篇文章能对大家有所帮助。我不会给大家介绍机器学习，数据挖掘的行业背景，也不会具体介绍逻辑回归，，，神经网络等学习算法的理论依据和数学推导，本文更多的是在流程化上帮助大家快速的入门机器学习和数据建模。
本文主要分为四个部分限于时间关系会分为上下两篇：
上篇：

准备篇，主要涉及环境搭建以及基本知识。
应用篇，我会以上的为例，从数据源获取，数据清洗，特征处理，模型选择，模型输出与运用。

下篇：

优化篇，介绍了几种优化的方法。
思考篇，提出几个困扰我的问题，希望能得到大家的帮助吧。

一 准备篇
环境搭建
整个的实验环境是：     。 
 基础
这里只能大家介绍下面会用到的知识，有兴趣的可以去具体的学习。给大家推荐一本参考书：《   》。有基础的可以直接跳到应用篇。
主要会用到 和两种数据结构。像是一维的数组，而更像是一种二维的表结构。
的构造方法：
=
 = ====
 

取数据，通过取数


的构造
以字典的形式构造
 = {}

由 构建
 = =

从中读取了两列构成新的。
的操作
 增加列
_=
 删除列
 = =
 查找数据行
_
结果如下：

的统计方法
  配合 处理列，如将的列进行分段。
 _ =         
 输出统计信息，非常强大


给出了个统计量，对我们的数据处理特别有用。有个问题，直接使用方法只能统计数值类的列，对于字符类的变量没有统计。加个参数就行。
=

 缺失值处理 对缺失值一般填充。
以填充缺失值

丢掉任何包含的行 

删除全为的行
=
二 应用篇
 数据读取
本例以作为数据源。大家可以在附件获取到数据。
 = __
_ = __
_ = _
 = 
 = 
 
 =
 _
 _=

数据的初始统计信息：

 数据清洗
 缺失值处理。和列存在少量缺失值，分别处理。
用众数填充缺失值
_=_
用均值填充缺失值
_=__
 删除缺失率较大的列初步处理时列的缺失率达到了，删除改列。
_ = _  =
 特征处理
特征处理是基于具体的数据的，所以在特征处理之前要对数据做充分的理解。特征处理没有固定方法之说，主要靠个人的经验与观察，通过不断的尝试和变换，以期望挖掘出较好的特征变量。所以说，特征处理是模型建立过程中最耗时和耗神的工作。
单变量特征提取。
根据的长度，抽象出_特征 
__ = _
观察列

通过观察列数据，可以发现名字中带有性别和婚否的称谓信息。提取这些信息可能是有用的特征。
__ = _     
多变量的组合 代表兄弟姐妹和配偶的数量 代表父母和子女的数量因此可以将和结合获得家庭成员的数量
__ = _  _ 
名义变量转数值变量

_=_{}

_ = _     ==  
数据分段
根据统计信息和经验分段
根据的统计信息进行分段
_ = _ 
按照经验分段
_ = _ 
简单的数据处理后，我们得到了如下维数据：

 模型选择与测试
初步选取了种模型进行试验





模型参数：
随机森林
    _ = {
        _ 
        _ 
        _ 
         _ 
        _ 
        __ 
        _ 
         
    }
       随机森林
    _ = {
        _ 
        _ 
         _ 
        _ 
        __ 
         
    }

      
    _ = {
        _ 
        _ 
    }

     
    _ = {
        _ 
         _ 
        _ 
        __ 
         
    }

     
    _ = {
         
         
    }
模型选择代码：
 = 
        _ _
        _ _
        _ _
        _ _
        _ _
    

     =     
     = 
     =   
        
           
         = 
         = 
           
            _ = 
               
                __ __ __ __ = \
                    ___ _ _= _=
                __ __
                _ = __
                _  _ == __
            _
          =

    = 
     
      
    
选择结果如下：

从上图可以看出，的一般表现要优于其他算法。初步选择算法。模型的在训练集上的表现：
 ______
    _
     = __

    _ _
     __  
         __

     _
        _
        _

     _
        _
        _
     

_ _ _ _  _
训练集的混淆矩阵如下图：

测试集的混淆矩阵如下图：

到此，初步的学习模型就建立起来了，测试集的准确度为。由于时间关系，优化篇和思考篇将放在下篇文章与大家分享，敬请期待。
如有任何错误或疑问，欢迎大家留言。期待与大家共同成长，共同进步！吴锐，开源爱好者。曾在阿里巴巴搬砖，目前就职于腾讯担任高级工程师，专注于创造高效代码。

 引言
互联网的发展为的发展带来了巨大的机遇。不论是视频点播，直播或者技术都需要做为传输内容的载体。老牌服务商网宿年上半年业务的营收比上年同期增长达到。
但是作为云基础服务中关键的一环，一直是各个云服务器提供商的必争之地。腾讯云如果需要在竞争中取得一席之地，就需要能够从容应对云上这些复杂的内容进行处理。原有服务器的存储引擎在处理视频文件，以及复杂的协议内容上出现了瓶颈，改造迫在眉睫。
 问题
对于视频这种大文件，原有盘的存储容量无法保证热点文件存储在缓存中，因此盘这种大容量磁盘被应用到了边缘节点中用来缓存视频大文件，以保证边缘节点的命中率。
但是原有服务器存储引擎在盘上的表现并不理想，如下图所示，在上只能跑流量，并且也处于比较高的水位，这限制节点的服务能力。

图 在上的处理能力
另外，在某些业务场景下服务器会导致毛刺的出现，定位发现是原有存储引擎的一些限制以及处理流程的问题导致的。不能挡在业务前进的路上，存储引擎的改造势在必行。老的存储引擎为，新改造的存储引擎因为历史原因命名为。下文就将老存储引擎成为，新引擎成为。

图 的毛刺
 硬件层
首先我们考虑是否完全充分利用了磁盘的性能，什么读写方式才能将磁盘的性能最大化。在调研了磁盘相关的构造后发现，经过对齐之后的写操作能够带来巨大的性能优化。
不管盘或者盘都有最小的操作单位，可能是，，。如果读写过程中不进行对齐，底层的硬件或者驱动就需要替应用层来做对齐操作，并将一次读写操作分裂为多次读写操作。
如下图是在同一台服务器上进行测试的结果。每次操作块大小为的吞吐能力仅为的。每次操作的块大小变大了，性能反而出现了明显的下降。
这是十分反直觉的，并且也说明了对齐的重要性。因此的第一个优化就是将写入的数据都进行对齐。目前不论盘或者盘的都为的倍数，因此写入数据时按照进行对齐。当然，这个参数是可调，方便后续调整。

图 块大小吞吐量测试

图 块大小吞吐量测试
 系统层
接下从系统层开始考虑从系统层面开始优化。
第一，在运营过程中发现在内存吃紧时，即使 中还有空闲内存时，内核会使用的内存，或者是回收内存带来额外的开销等问题；
第二，文件系统的元数据也会有的开销。而的存储引擎自己进行缓存数据的管理，完全可以使用裸盘进行读写。消灭文件系统的开销。如下图所示，中支持越过文件系统直接使用裸盘读写，来完全解放磁盘性能。
 
图 处理流程
直接使用裸盘带来的另一个好处是可以使用内核提供的异步功能。异步可以解放，进一步提高服务器的处理能力。目前已经支持异步。但是异步在没有完成之前，写入缓存会占用内存空间。需要对这部分内存进行限制，防止消耗过多内存影响服务器正常处理。
 应用层
最后再来考虑从应用层面优化。主要优化点有：
 文件分片存储
存储文件时候使用连续的存储空间。当需要淘汰老文件，挪出空间来存储新文件时，就需要将整个老文件从缓存中删除。对小文件这并没有什么问题。但是如果为了存储一个的小文件而将一个的文件从缓存中删除，这明显得不偿失的。
因此，在中，所有大文件都会被分成一个个的数据分片进行存储。这样在淘汰时也只需要淘汰一个的数据分片，在需要时也只需要拉取一个的数据分片即可。这解决了在淘汰大文件时引起大量回源流量的问题。
同时，分片存储也带来了另外一个好处，就是的缓存可以支持变长文件。这在客户源站只支持中的分块传输  ，这种不知道文件大小长度的情况下就十分有用。
由于在存储之前需要知道文件的确切大小，因此之前的做法是先在内存中接受并缓存数据，等到接受完毕确定文件大小后，再存储到缓存中。可以将数据直接写到缓存中，降低了内存和开销。

图 存储与淘汰方式

图 存储与淘汰方式
 元数据与文件数据隔离
另外在运营中发现，在某些场景下，元数据频繁的被读写。导致元数据的读写开销变得十分明显。而元数据与正常文件数据是存放在同一块磁盘中，这影响了正常文件数据的存取。
因此，在中可以将元数据与文件数据分开存储。元数据可以存储在能力较强的盘中，而文件数据则单独存储在数据盘中。在小文件场景下，甚至可以将元数据存放在内存文件系统中，完全规避元数据的开销。
 小文件忽略缓存头部
第三个优化点在于提高小文件的存储效率。在缓存文件的同时会将和文件相关的一些信息，如头部，和等信息，作为头部存储在缓存文件的开头。这部分数据大小为几。在小文件业务，大量文件的长度也就为几，缓存头部就占据了将近一半的存储空间。部分业务并不需要这些缓存信息，因此可以将这部分缓存头部省略，进一步提高存储利用率。
 单盘容灾
最后，运营海量服务器的场景下，坏盘变得频繁。
如果运维收到告警后，人肉处理就需要比较长的响应时间，甚至影响服务器上业务的运行。新版本的支持将坏盘自动从缓存中剔除坏盘，坏盘问题不会中断业务的正常运行。坏盘在被剔除之后，缓存会在剩余的其他磁盘上重新分布，不影响正常文件存取。
 总结
在进行优化之后，将老版本的与新版本的在同机房选择了两台机器，使用相同业务进行压测对比。流量提升，负载降低，消耗降低 。

相关推荐
如何依托腾讯云完成海量数据的存储和备份发布更新文章、提交审核评论自动清理腾讯云缓存发现页是直播短视频的主要曝光平台如下图，内容以运营人工筛选为主，瀑布流式展示。

为了兼顾短视频质量和时效性，短视频排序采用了重力算法：

为短视频的质量分，通过观看，点赞，评论，转发等数据加权求和计算，为短视频发布时间戳，位基准时间，取发现页最早发布的短视频创建时间戳，单位均为秒。为时间系数，根据发现页短视频的平均更新间隔，取小时。该算法的效果是，发布时间接近，质量分高的短视频靠前，随着时间推移，短视频不断下沉，削弱头部曝光产生的马太效应。
为了提高内容的新鲜感，我们希望用户在每次下拉刷新以及翻页的时候，都能看到新的短视频，同时在短视频列表头部加入新的短视频时，能得到优先展示，如下图所示：

左图为首屏显示的短视频，如在此时，短视频列表顺序发生了更新，和插入了的前面，我们希望在下次刷新的时候，优先插入、。实现这个需求最简单的方法是保存用户最近观看过的全部短视频作为过滤器，每次返回列表的时候，从头部开始遍历，去掉用户看过的短视频。显然，过滤器的容量，决定了短视频列表的最大展示深度。根据产品需求，发现页需要展示最近一个月的短视频，大约个，平均每个短视频的长度为字节，这个过滤器如果用传统的 等手段实现，存储成本和过滤效率都比较低，针对这个问题，我们采用了一个简单而强大的数据结构布隆过滤器。
 布隆过滤器是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。 的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合 。因此， 不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下， 通过极少的错误换取了存储空间的极大节省。
下面我们具体来看 是如何用位数组表示集合的。初始状态时， 是一个包含位的位数组，每一位都置为。

为了表达={ …}这样一个个元素的集合， 使用个相互独立的哈希函数 ，它们分别将集合中的每个元素映射到{…}的范围中。对任意一个元素，第个哈希函数映射的位置就会被置为≤≤。注意，如果一个位置多次被置为，那么只有第一次会起作用，后面几次将没有任何效果。在下图中，=，且有两个哈希函数选中同一个位置从左边数第五位。   

在判断是否属于这个集合时，我们对应用次哈希函数，如果所有的位置都是≤≤，那么我们就认为是集合中的元素，否则就认为不是集合中的元素。下图中就不是集合中的元素。或者属于这个集合，或者刚好是一个 。

我们使用和实现了一个可以序列化成整形数组的布隆过滤器，可以利用支持的简单数据结构进行存取，在本地实现高效的过滤运算，一个能保存个短视频的布隆过滤器，只占用不到的空间，的效率都比较高。
因为布隆过滤器容量有限，且无法删除元素，需要配合重建策略使用。我们用维护了一个最近观看的个短视频，当布隆过滤器空间利用率超过百分之的时候，清空并使用这个进行重建，避免了极端情况下的重复问题。
短视频瀑布流刷新涉及到大量的图片下载，在图片加载期间，会显示默认底图如下图：
 
为了优化图片加载体验，尤其是网络条件较差时的展示效果，我们采用了预加载图片主色调的方法，即离线计算好短视频封面的主色调值，使前端在完成图片下载前用主色调代替默认的底图，平滑图片的加载过程：
  
关于图片主色调的提取，我们尝试了多种算法，最终参考了《基于分割与均值聚类的主颜色提取算法》这篇论文，实现了短视频封面图片主色调的提取，基本方法如下：

提取图片的空间值，转化为空间值
对空间下的像素点进行均值迭代。
选择点数量最多的一个聚类，将聚类中心的空间值转换为空间值。

以上几点是我们在直播发现页瀑布流迭代优化中的一些尝试和技术总结，希望能给大家在开发流类型应用时提供一些参考，如有意见或建议，可与本文作者联系。导语
作为最基本，最重要的基础概念之一，在开发中经常会和他打交道。本文从为什么出现开始，介绍了相关的方方面面，包括的基本定义及使用、回退栈的内部实现、通信、、的使用、嵌套、懒加载等。
博客文章地址：
下文中的源代码地址：
基本概念
，简称碎片，是  提出的，为了兼容低版本，库中也开发了一套 ，最低兼容 。
过去库是一个包，版本开始，将库模块化为多个包，包含：  等，这么做是为了减少包大小，你需要用哪个模块就引入哪个模块。
如果想引入整个库，则 ，如果只想引入库，则。

因为库是不断更新的，因此建议使用库中的，而不要用系统自带的。而如果要使用库的，必须要继承是的子类。

官方的定义是：

                                                                     

根据上面的定义可知：

是依赖于的，不能独立存在的。
一个里可以有多个。
一个可以被多个重用。
有自己的生命周期，并能接收输入事件。
我们能在运行时动态地添加或删除。


 系统只针对平板电脑，且闭源，那时候针对手机和针对平板是两套源代码，后来 时整合了手机和平板的源码，因此市面上很难看到 系统。

的优势有以下几点：

模块化：我们不必把所有代码全部写在中，而是把代码写在各自的中。
可重用：多个可以重用一个。
可适配：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。


核心的类有：

：的基类，任何创建的都需要继承该类。
：管理和维护。他是抽象类，具体的实现类是。
：对的添加、删除等操作都需要通过事务方式进行。他是抽象类，具体的实现类是。

 内部嵌套的能力是 提出的，库可以兼容到。通过能够获得管理子的，在子中可以通过获得父。
基本使用
这里给出最基本的使用方式。首先，创建继承的类，名为：
    {

       _ = _

      
      

        {
         =  
         = _  获取参数
    }

            {
          = _  
          = 
        
         
    }

         {
          =  
          =  
        _ 
           设置参数
         
    }
}
有很多可以复写的方法，其中最常用的就是，该方法返回的布局，需要注意的是的第三个参数是，因为在内部实现中，会把该布局添加到中，如果设为，那么就会重复做两次添加，则会抛如下异常：
                  
如果在创建时要传入参数，必须要通过 方式添加，而不建议通过为添加带参数的构造函数，因为通过方式添加，在由于内存紧张导致被系统杀掉并恢复时能保留这些数据。官方建议如下：
                        
我们可以在的中通过获得传进来的参数，并在之后使用这些参数。如果要获取对象，不建议调用，而是在中将对象强转为对象。
创建完后，接下来就是把添加到中。在中添加的方式有两种：

静态添加：在中通过的方式添加，缺点是一旦添加就不能在运行时删除。
动态添加：运行时添加，这种方式比较灵活，因此建议使用这种方式。

虽然能在中添加，但是这只是一个语法糖而已，并不是一个，而是和同一层次的。
这里只给出动态添加的方式。首先需要有一个容器存放，一般是，因此在的布局文件中加入：

    =
    _=_
    _=_

然后在中，通过以下代码将添加进中。
  ==  {
    
           
        
        
}
这里需要注意几点：

因为我们使用了库的，因此需要使用获取。
是对众多操作中的一种，还有 等，第一个参数是根容器的的，即””，第二个参数是对象，第三个参数是的名，指定的好处是后续我们可以通过  = 从中查找对象。
在一次事务中，可以做多个操作，比如同时做。
操作是异步的，内部通过加入处理队列。对应的同步方法为，内部会有操作，如果开发人员使用不当比如操作在之后，可能会抛出异常，而方法则是不会抛出异常版本的方法，但是尽量使用，而不要使用。
是可选的。拥有回退栈，类似于的任务栈，如果添加了该语句，就把该事务加入回退栈，当用户点击返回按钮，会回退该事务回退指的是如果事务是，那么回退操作就是；如果没添加该语句，用户点击返回按钮会直接销毁。
有一个常见的问题，即重叠问题，这是由于被系统杀掉，并重新初始化时再次将加入，因此通过在外围加语句能判断此时是否是被系统杀掉并重新初始化的情况。

有个常见的异常：
       
     
     
     
     
该异常出现的原因是：在后调用。首先，在之后，之前调用。在之后，之前。
因此避免出现该异常的方案有：

不要把事务放在异步线程的回调中，比如不要把事务放在的，因此可能会在之后执行。
逼不得已时使用。

生命周期
的生命周期和类似，但比的生命周期复杂一些，基本的生命周期方法如下图：

解释如下：

：和相关联时调用。可以通过该方法获取引用，还可以通过获取参数。
：被创建时调用。
：创建的布局。
：当完成时调用。
：当可见时调用。
：当可见且可交互时调用。
：当不可交互但可见时调用。
：当不可见时调用。
：当的从视图结构中移除时调用。
：销毁时调用。
：当和解除关联时调用。

上面的方法中，只有在重写时不用写方法，其他都需要。
因为是依赖的，因此为了讲解的生命周期，需要和的生命周期方法一起讲，即的各个生命周期方法和的各个生命周期方法的关系和顺序，如图：

我们这里举个例子来理解生命周期方法。功能如下：共有两个：和，在初始化时就加入，点击中的按钮调用替换为。
当在的中被添加时，日志如下：
  
  
  
   
  
  
  
  
  
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
可以看出：

的都是在的中调用的。
的在的之后调用。

接下去分两种情况，分别是不加和加。
、当点击的按钮，调用替换为，且不加时，日志如下：
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
 
  
  
  
  
  
  
  
  
可以看到，最后调用了和。
、当点击的按钮，调用替换为，且加时，日志如下：
  
  
  
  
  
  
  
  
  
  
  
  
 
  
  
  
  
  
  
  
  
可以看到，被替换时，最后只调到了，并没有调用和。当用户点返回按钮回退事务时，会调，因此在事务中加不加会影响的生命周期。
有一些基本方法，下面给出调用这些方法时，生命周期的变化：

 …。
 …。
 相当于旧调用，新调用。
 不调用任何生命周期方法，调用该方法的前提是要显示的已经被添加到容器，只是纯粹把 的为。
 不调用任何生命周期方法，调用该方法的前提是要显示的已经被添加到容器，只是纯粹把 的为。
 。从布局中移除，但是仍然被管理。
 。

实现原理和 
我们知道有任务栈，用户通过将加入栈，点击返回按钮将出栈。也有类似的栈，称为回退栈 ，回退栈是由管理的。默认情况下，事务是不会加入回退栈的，如果想将事务加入回退栈，则可以加入。如果没有加入回退栈，则用户点击返回按钮会直接将出栈；如果加入了回退栈，则用户点击返回按钮会回滚事务。
我们将通过最常见的用法，讲解 的实现原理：

      
    
    
上面这个代码的功能就是将加入中，内部实现为：创建一个对象，该对象记录了这个事务的全部操作轨迹这里只做了一次操作，并且加入回退栈，随后将该对象提交到的执行队列中，等待执行。
类的定义如下：
       {}
从定义可以看出，有三重含义：

继承了，即是事务，保存了整个事务的全部操作轨迹。
实现了，作为回退栈的元素，正是因为该类拥有事务全部的操作轨迹，因此在时能回退整个事务。
继承了，即被放入执行队列，等待被执行。

先看第一层含义，返回的就是对象，代码如下：
   {
      
}
类包含了一次事务的整个操作轨迹，是以链表形式存在的，链表的元素是类，表示其中某个操作，定义如下：
    {
      链表后一个节点
      链表前一个节点
       操作是或或或或等
      对哪个对象做操作
}
我们来看下具体场景下这些类是怎么被使用的，比如我们的事务做操作。函数的定义：
        {
       _
     
}
方法就是创建对象，并加入链表，定义如下：
          {
     =   设置的
     =  =   设置的容器
      =  
     = 
     = 
    
}
是将创建好的对象加入链表，定义如下：
   {
      ==  {
         =  = 
    }  {
         = 
         = 
         = 
    }
    
}
“”是将变量记为，在中会用到该变量。是异步的，即不是立即生效的，但是后面会看到整个过程还是在主线程完成，只是把事务的执行扔给主线程的，内部是，实现如下：
   {
     = 
      {
         = 
    }  {
         = 
    }
      将事务添加进待执行队列中
     
}
如果为，则调用将事务添加进回退栈，类的变量 就是回退栈。实现如下：
    {
      ==  {
         =  
    }
      = 
    
     
}
在中， 是将加入待执行队列中，定义如下：
      {
      ==  {
         =  
    }
    
      ==  {
        
         调用执行待执行队列的事务
    }
}
就是前面说的待执行队列，就是主线程的，因此是在主线程执行的，的内部就是调用了，即把中所有积压的没被执行的事务全部执行。执行队列中的事务会怎样被执行呢？就是调用的方法，方法就是执行的生命周期函数，还有将视图添加进中。
与对应的是，有以下几种变种：

：将回退栈的栈顶弹出，并回退该事务。
   ：为 的参数，通过能找到回退栈的特定元素，可以为或者___，表示只弹出该元素以上的所有元素，___表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。
是异步执行的，是丢到主线程的执行，是同步版本。

我们通过讲解来更清晰地了解回退栈的使用。功能如下：共有三个：  ，在初始化时就加入，点击中的按钮跳转到，点击的按钮跳转到，点击的按钮回退到。
在的中，将加入中：

      
    
    
按钮的内容如下：

      
    
    
按钮的如下：

      
    
    
按钮的如下：
 ___
这样就完成了整个界面的跳转逻辑。
这里补充一个点，是经常用到的方法，他是的方法，是抽象类，是继承的实现类，他的内部实现是：
    {
     
     
        {
          =    =  {
              = =  {
                  = 
                  =    {
                     
                }
            }
        }
          =    =  {
              = =  {
                  = 
                  =    {
                     
                }
            }
        }
         
    }
}
从上面看到，先从中查找是否有该，如果没找到，再从中查找是否有该。是已经添加到的的集合，不仅包含，还包含虽然不在中，但还在回退栈中的。
通信
向传递数据
首先，在中定义接口，并让实现该接口具体实现省略：
   {
        将从传递给
}
在的中，将参数强转为对象：
    {
    
        {
         =  
    }  {
          
                    
    }
}
并在合适的地方调用将””从传递给。

由于通过接口的方式从向进行数据传递比较麻烦，需要在中定义，并让实现该，通过注解的形式免去了这些定义。
在中添加依赖：
 
 
首先定义方法，这里为__，接着在中定义接口：
 = __
    {  方法名任意
      _
}
最后，在中，通过以下形式调用”=__”的方法该方法可能在中，也可能在任何类中：
__  调用对应的方法，为参数值
向传递数据
向传递数据比较简单，获取对象，并调用的方法即可，比如要将一个字符串传递给，则在中定义方法：
    {
      = 
}
并在中调用即可。
之间通信
由于之间是没有任何依赖关系的，因此如果要进行之间的通信，建议通过作为中介，不要之间直接通信。

是 提出的，代替了，用于实现对话框。他的优点是：即使旋转屏幕，也能保留对话框状态。
如果要自定义对话框样式，只需要继承，并重写，该方法返回对话框。这里我们举个例子，实现进度条样式的圆角对话框。
     {
    
            {
        __ 消除区域
           将背景变为透明
          点击外部不可取消
          = __ 
         
    }

        {
          
    }
}
进度条动画我们使用实现，动画从这里找到。使用非常方便，只需要下载动画文件，然后在中写入：

    _=_  大小根据文件确定
    _=_
    _=_   文件
    _=    循环播放
    _=   自动播放
然后通过下面代码显示对话框：
  = 
 

为了实现圆角，除了在中把背景设为透明，还需要对加入背景：
 =
     =
    
        =

接 《基础：，看这篇就够了  下 》本文作者： 



 全称是   。它的目的就是让你的网页越来越快。主要内容可以参考：。不过，它上手的难度也是有的。它本身是基于  而发展出  ，所以，要使用  你就必须学会如何使用 ，然后， 里面还有很多坑要踩。而其中最大的坑就是，如何处理文件资源的缓存，这个一直都是  领域的心病。当然，在  中，这也是有点困难的。不过，为了大家能更快的掌握  这里，鄙人写了一个关于处理  事件的路由分发库 。
这里也主要介绍一下它。
下载
  
 由于是在  中使用，所以一般的  模块 写法是不能用的。推荐是直接到 _找到 文件夹，复制其中的 到你的 的工作目录。然后直接引入：
使用
使用  缓存功能其实很简单，你不需要写啥，，事件。因为这些和你要操作的缓存都不是直接关系。最简单就是直接监听 即可。
  ={
     
}
 不过，如果你要做的是比较大业务，单单使用一个  就有点 “势单力薄”。所以，本库还是基于最小业务原则的出发点来进行创作的。
通过导入之后， 会  作用域下绑定一个  对象。接着，你就可以在该对象上绑定相关的路由处理。
路由绑定
利用  对象进行路由绑定和   类似，所以上手起来也不是特别大的问题：
 ={
     
   
}
={
     
   
}
={
    
   
}
 它以链式的方法，来提供  形式的路由注册。常用方法有：

 监听所有方法，不论是啥，。
 监听指定  方法的请求。
 监听指定  方法的请求。 
 监听指定  方法的请求。
 监听指定  方法的请求。

使用格式如下 种方法使用都一样：
={
 
}
 其中， 参数分别为：

 为  方法的回调参数。 ={
  
}

 等同于 

如果想对不同的路由做相同的监听，可以直接传入数组，或者通过连接不同的内容。
={
    
} 

={
     
}
 当然，这里不仅仅只提供了路由绑定的功能，还提供了缓存的做法。
缓存文件
缓存的方法也绑定在  对象上，它的使用如下：
 ={
     
  
}
 它的格式为：  

 为你缓存文件方式的文件夹的名字。你也可以理解为数据库中的 。只是为了区分缓存文件的一个目录而已。如果你不写的话，默认为 。所以，使用方式也可以为：={
   

}

 就是你注册路由的  参数。直接传进去就好。

上面，大致介绍了路由注册这一块内容，但是，如果使用你注册好的路由分发系统呢？
投入生产
路由系统真正接入  是通过 方法来进行监听的。具体使用为：
 ={
    
  
}
={
     
  
}
={
    
}

  {
    
  
}
 注意， 只能传入  参数，其它的就不要乱传了。
英文文档

反馈
如果在使用库的同时，遇到什么问题，可以去  提一提。鄙人一定会及时处理并回复。
作者




原文链接：作者介绍：周科，腾讯工程师，动漫主力开发，从事过开发，参与过手阅读、手趣味来电等项目，对底层原理有深入理解。

前言
说起壳可能有的同学并不太了解，简单的说，计算机软件领域所说的壳实际上是一种软件加密技术。与自然界中的壳类似，花生用壳保护种子，乌龟用壳保护自己的身体，而我们写的程序为了在一定程度上防止被逆向分析，也可以给它加壳。壳主要分为两大类：加密壳和压缩壳，加密壳侧重于防止软件被篡改，而压缩壳则侧重于减小软件体积。其实，在上已经有许多壳了，但或者可以说上的壳相对而言就少了一些。本文就主要讲讲动态库文件压缩壳要如何实现。
一、压缩
说到压缩，我们可能首先会想到一些常用的压缩工具，例如、、等等。使用这些工具可以实现文件的压缩吗？答案是肯定的，但如果我们使用这些工具去压缩，在使用上却会有一些不方便，主要体现在以下几个方面。

程序中需要引入额外的解压代码；

压缩解压算法不能随意切换；

需要先解压成原始文件后才能被调用。


那么，如何才能避免这些麻烦呢？在计算机领域有一句名言“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”。这里我们就可以通过加中间层的方式去解决这个问题，请看下图。

图上的就是我们要增加的中间层。我们知道，是格式的二进制文件，所以要实现对的压缩，就要自己实现一个加载器去加载压缩后的。这里的本质上也是一个文件，只不过它里面被写入了我们压缩后的数据。它的作用主要有三个。

代替原始被应用程序加载；

内存中解压出原始；

将原始加载到内存中。


有人可能会说这样每次使用前还要在内存里解压，那不会变慢么？事实上，虽然多了解压的过程，但由于的体积减小，加载时的耗时也会减小，所以这里速度上并不会慢多少有兴趣的朋友可以做做实验。
上面的图示中我们把的压缩过程分成了压缩与合成两个步骤，接下来就分别说说这两个步骤是怎么做的。
 压缩
关于压缩算法的选择，因为压缩的过程是在上进行的，所以压缩时内存占用和压缩的速度并不重要，我们主要需要关注压缩率和解压速度。对于各种压缩算法，其实已经有人做过对比试验了，看下面两张图。


我们的文件属于二进制文件类型，可以看到算法的压缩率是非常给力的，解压速度说不上特别快，但也能接受。再结合官网上对其特性的介绍，算法是非常适合在嵌入式系统中使用的。

虽然在的基础上又发展了更高级的、等算法，但由于使用这些算法需要引入更多的代码，会导致体积增加，所以这里我最终还是选择了算法。
 合成
由于的本质也是一个，要把原始压缩之后的数据嵌入，需要对格式有一定的了解。网上有很多分析格式的文章，写得都很不错，文末的参考资料中有相关链接。这里主要讲一下我们插入数据会涉及到的一些知识点。这是一张经典的文件格式视图。

我们需要把中嵌入的数据加载到内存中解压并执行，所以这里只需要关注的执行视图，执行时是按照段，各个段的信息定义在程序头部表里来加载的，所以头部中与节区相关的内容我们就可以随意修改。
此外，为了简化数据插入的过程，我们这里把要嵌入的数据放在最后一个段的末尾，这样做的好处是，不会涉及内各种跳转地址的修正，只需要调整最后一个段的大小，就能够方便的被加载到内存里去。“      ”看了半天文字，似乎略显枯燥，我们来看看 和 的定义片段就能知道要怎么做了。

定义中标记为斜体的内容就是我们需要修改的地方，可以看到数据插入后，我们需要修改 中的文件大小和加载到内存里的大小即可。同时，头部中与相关的有个字节，足够让我们存储插入数据的大小和偏移了，这样可以方便在加载后快速找到我们要解压和执行的数据。
综上，一个的压缩过程就可以用一个简单流程图来描述。

二、加载
中的加载全靠，所以要理解的加载过程，需要对有一定的了解。虽然各个版本的实现都不尽相同，实现的语言也从变成了，不过也是大同小异，乌云上有一篇讲解 源码的文章，写得挺好，不过乌云上的文档现在貌似访问不了了，文末参考资料放了转载到酷推上的链接。这里我就简单罗列一下加载的过程。

打开文件；

解析头获得段的偏移、大小、虚拟地址等等信息；

根据解出来的信息申请足够的内存；

将文件中可加载_的段依次映射到申请的内存上，并找到_表数据的起始地址；

根据_表中的数据，找到字符串表、符号表、重定位表、初始化反初始化函数地址，并执行函数的重定位；

执行初始化函数；


加载完成之后会返回一个结构，所有相关的信息都存在里面，会把这个结构用一个链表维护起来。基于加载的过程，我们要实现自己的加载器就比较容易了，主要有三步。

根据头部信息，找到我们插入的数据，并解压到内存中；

参考的实现，把读文件的地方，改成从内存取数据，完成的加载；

最后还需要将我们加载构造出来的的内容拷贝至的。


至此，我们就成功的把原始的加载到内存中去了。至于为什么需要上面的第步，是因为如果我们的被其他程序链接，查找符号时会从维护的链表中去搜索，所以原始对应的的必须出现在维护的链表中，不然是找不到的。
加载的过程图示如下。
三、一些问题
至此，原理部分就介绍完了，在实现的过程中也遇到了一些问题，在这里总结一下。当然我的解法不一定是最好的，但可以解决问题，希望能给大家一些参考吧。
：如何让我们解压和加载的代码自动执行？：通过加载的流程，我们知道加载之后会执行初始化函数，所以我们需要自动执行的代码可以放在 中。
：如何拿到里维护的链表？：并没有提供接口让外部拿到这个链表，但我们可以利用加载的特性，通过打开一个基础的例如：，函数返回的内容实际上就是其对应的的节点，我们就可以用这个节点作为链表的“头”节点。
：为什么在 上测试时一跑起来就？：我的代码是参考的的，而的数据结构在开始发生变化，记录在内存里基地址的变量跟以前不一样了，需要判断版本将基地址赋值给正确的变量。
事实上，目前还有一些问题需要解决，例如一些奇奇怪怪的兼容性问题、如何让体积更小等等。本文主要是抛砖引玉，如果各位读者有什么想法和建议，欢迎一起探讨。
四、参考
 压缩算法对比文件格式总结 学习笔记

文章来源公众号 小时光茶社 问题描述
假设有三个表___，创建的时候字符集分别为。表结构为






















中字的十六进制表示为： ； 进制表示为：  。
问题
执行下列语句：
   

  _  中   此处中为格式

   _
结果是乱码，还是正常显示？
问题
执行下列语句：
   

  _  中  此处中为格式

   _
结果是乱码，还是正常显示？
问题
执行下列语句：
   

  _  中  此处中为格式

   _
结果是乱码，还是正常显示？
原理篇
字符集介绍
为了解释上述问题，首先要了解字符集为何物。字符集也叫字符编码，就是将字符集合一一映射成一个数。以下简单介绍一下几种字符集：
基础编码：
表示所有的大写和小写字母，数字 到、标点符号， 以及在美式英语中使用的特殊控制字符。 
编码：
单字节编码，编码范围是，和保持一致，之间是控制字符，之间是文字符号。 
编码：
使用一字节和双字节编码，–范围内是一位，和  保持一致。双字节的第一字节范围是不含和。
编码：
使用一至四字节编码，–范围内是一位，和  保持一致。其它字符用二至四个字节变长表示。
字符集编码转换举例：
 ±   
两个重要的点

区间，上述字符集是一致的，也就是说英文字符无需转码。

不同编码，字符集合不完全一样，存在某字符集的字符无法映射到另外一个字符集。


比如编码中的中文字符，转成编码时，就找不到对应的二进制编码。做字符集转换的时候，中文字符，很多就转成号，这种大集合转成小集合，基本是不可逆的。
执行过程
对一个  的执行过程，字符集转换，一般涉及到一下三个步骤：

收到请求，将请求数据从 __ __。

内部操作，将数据从__ 表创建的字符集。

结果输出，将数据从表创建的字符集  __。


当执行   相当于把__ ____ 统一设置为。
终端显示字符集
此外如果你用终端来显示的话，如果不想乱码的话， 也需要设置成正确的字符集。
问题详解
问题
执行下列语句： 
   

  _  中   此处中为格式

   _
结果是乱码，还是正常显示？
答：结果是正常显示。
执行流程如下：

  ；相当于把__ ____ 统一设置为。

__告诉 ，传入的是一个编码的，也就是单字节流，中这个输入，其实当作了 传入。

因为__  __    __为      ， 编码完全一致，数据没有做任何转换，所以输入是 ，最后的输出也还原为 。

如果你的的显示字符集设置为，那么最后的输出 就会显示成中。


问题
执行下列语句：
   

  _  中  此处中为格式

   _
结果是乱码，还是正常显示？
答：结果是乱码。
执行流程如下：

  ；相当于把__ ____统一设置为。

__告诉 ，传入的是一个  编码的，中这个输入，当作了 传入。

因为__  __    __为     ， 其中 的时候，因为中这个字符在字符集里找不到，就会转换成号，然后，号在字符集里面也是，最后输出就是，即号。


问题
执行下列语句：
   

  _  中  此处中为格式

   _
结果是乱码，还是正常显示？
答：正常显示。
执行流程如下：

  ；相当于把__ ____ 统一设置为。

__告诉 ，传入的是一个编码的，中这个输入，当作了 传入。

因为__  __     __为     ， 其中 的时候，输入中  会当作两个字符进行转换，转换为   ，然后的时候，会把 转换成  转成 ，最后输出 。负负得正，之所以数据没有失真的原因是因为小集合往大集合转，再转回来，操作可逆。

如果你的的显示字符集设置为，那么最后的输出 就会显示成中。


终极解决方案
从上面的问题执行流程来看，有没有终极解决方案呢？其实很简单，表创建的字符集和 都设置成同一个字符集，就基本可以满足输入数据不会在转换过程中失真，也就是说输入是什么，输出就是什么。建议有中文的都设置成字符集，一劳永逸。

相关推荐腾讯云下定时监测进程终止后自动重启的方法   实现解析  数据加密功能解析
 是什么
软件库是一个利用简单的编程模型在大量计算机集群上对大型数据集进行分布式处理的框架。
特点：部署成本低、扩展方便、编程模型简单。
 实现了在行业标准的服务器上进行可靠、可缩放的分布式计算，让你能够以较低的预算跟踪数  以上的数据，而不必需要超级计算机和其他昂贵的专门硬件。
 还能够从单台服务器扩展到数千台计算机，检测和处理应用程序层上的故障，从而提高可靠性。
 的组成部分  
、          、               、          、           
我们平常接触比较多的也是 、、；具体的场景，，比如通过客户端访问集群， ，，我们看提交的任务的执行情况。
 架构
的发展    


在   时代， 的两大核心组件   和 都存在着单点问题，这其中以的单点问题尤为严重。因为保存了整个的元数据信息，一旦挂掉，整个就无法访问，同时生态系统中依赖于的各个组件，包括、、以及等也都无法正常工作，并且重新启动和进行数据恢复的过程也会比较耗时。这些问题在给的使用者带来困扰的同时，也极大地限制了的使用场景，使得在很长的时间内仅能用作离线存储和离线计算，无法应用到对可用性和数据一致性要求很高的在线应用场景中。 由一个和多个 组成， 的执行过程由一个和多个 组成。
针对中的单制约的扩展性问题，提出了联盟，它让多个分管不同的目录进而实现访问隔离和横向扩展，同时它彻底解决了单点故障问题。它将中的资源管理和作业控制功能分开，分别由组件和实现，其中，负责所有应用程序的资源分配，而仅负责管理一个应用程序，进而诞生了全新的通用资源管理框架。基于，用户可以运行各种类型的应用程序不再像那样仅局限于一类应用，从离线计算的到在线计算流式处理的等不仅限于一种框架使用，也可以供其他框架使用，比如、、。
图 
图 
 
 

这个图里面有的构成，以及相关项目的一些构成，比如、。它们都是依赖于之上的，比如  会转换成 程序去执行。
 原理及过程
传统的分布式程序设计如非常复杂，用户需要关注的细节非常多，比如数据分片、数据传输、节点间通信等，因而设计分布式程序的门槛非常高。的一个重要设计目标便是简化分布式程序设计，将所有并行程序均需要关注的设计细节抽象成公共模块并交由系统实现，而用户只需专注于自己的应用程序逻辑实现，这样简化了分布式程序设计且提高了开发效率。

  先将对应的  迭代解析成一个个  对，依次调用用户自定义的函数进行处理，最终将临时结果存放到本地磁盘上，其中临时数据被分成若干个，每个  将被一个   处理。
  执行过程如图所示。该过程分为三个阶段①从远程节点上读取中间结果称为“阶段”；②按照  对对进行排序称为“阶段”；③依次读取  ，调用用户自定义的  函数处理，并将最终结果存到上称为“ 阶段”。
一般的场景是需要多个进行迭代计算如， 过程都会有写磁盘的操作，而且两个之间还需要访问。
任务提交
 

   原理
大家因为相互选择走到了一起，然后成就了彼此。但不是天生就是为了彼此。

通过或者、或接口的外部接口提交，经过编译器，运用中的云数据进行类型检测和语法分析，生成一个逻辑方案然后通过简单的优化处理，产生一个以有向无环图数据结构形式展现的任务
整个编译过程分为六个阶段：
、定义的语法规则，完成词法，语法解析，将转化为抽象语法树 ；、遍历 ，抽象出查询的基本组成单元；、遍历，翻译为执行操作树；、逻辑层优化器进行变换，合并不必要的，减少数据量；、遍历，翻译为任务；、物理层优化器进行任务的变换，生成最终的执行计划。
  转换为 举例：

   转化为 ，可以在里先看下的执行计划，每个都是由一个组成，当然，一个也可能没有。 两个之间，上一个的数据会写到上。
、计算框架 
对于需要多个作业迭代计算的场景，因为每个都要读写会造成磁盘和网络的浪费，而作为一个框架，可以将多个有依赖的作业转化为一个作业，从而提高性能。

 基于内存的计算框架
、核心概念 
 弹性分布式数据集，  ，是一个容错的、并行的数据结构，可以让用户显式地将数据存储到磁盘和内存中，并能控制数据的分区。还提供了一组丰富的操作来操作这些数据。对于数据的处理，都是围绕着进行的。只能通过在稳定的存储器或其他的数据上的确定性操作来创建。
 ==
  = 
、的操作：转换和动作
 操作是延迟计算的，也就是说从一个 转换生成另一个  的转换操作不是马上执行，需要等到有  操作的时候才会真正触发运算。 行动算子：这类算子会触发  提交  作业。
、执行过程
宽窄依赖

窄依赖允许在一个集群节点上以流水线的方式计算所有父分区。例如，逐个元素地执行、然后操作；而宽依赖则需要首先计算好所有父分区数据，然后在节点之间进行，这与类似。第二，窄依赖能够更有效地进行失效节点的恢复，即只需重新计算丢失分区的父分区，而且不同节点之间可以并行计算；而对于一个宽依赖关系的图，单个节点失效可能导致这个的所有祖先丢失部分分区，因而需要整体重新计算。
、 与对比，提升效率的地方
是一个和一个组成一个，当然也有没有的，如简单的不涉及到的查询也类似，每一个宽依赖需要，类似的地方就是两个的分界线。

可以看到 的思想跟 的很像，不像那样必须成对的一起出现，可以在阶段做很多事情，减少不必要的网络和写的时间。同时一个内，数据的处理也是基于内存的，减少了本地磁盘的。
、  结构化的
在中，是一种以为基础的分布式数据集，类似于传统数据库中的二维表格。与的主要区别在于，前者带有元信息，即所表示的二维表数据集的每一列都带有名称和类型。这使得 得以洞察更多的结构信息，从而对藏于背后的数据源以及作用于之上的变换进行了针对性的优化，最终达到大幅提升运行时效率的目标。反观，由于无从得知所存数据元素的具体内部结构，只能在层面进行简单、通用的流水线优化。
、 使用
的前身是，而的前身是中的。
受限于络子，目前好像只能用开发。 的任务，如果支持 的语法，会使用引擎执行任务。
参考资料
 项目介绍架构            的基本原理 的编译过程美团 基本架构及原理简单之美 | ：基于内存的集群计算容错抽象 、和的区别前言：很多人说盛大盒子太超前了，所以失败了，事实真的是这样的么？在笔者眼里，盒子不是太超前了，而是太落后了。而首富陈天桥之所以押注“盒子”，完完全全是因为野心太大，而之所以失败，是因为对行业的趋势判断严重失误。
风险提示：文中数据来源网络，未经考证，仅供参考。文中事件来源网络，未经考证，仅供消遣。文中观点来源个人，未经考证，仅供闲聊。
——游戏的流量需求——
今天，我们来聊聊曾经的首富陈天桥的“盒子野心”。
之所以要聊陈天桥，是因为陈天桥是依靠互联网成为“首富”的第二位，是因为“传奇”当时在行业内的地位和影响力以及开拓的道具收费这种完全适合中国市场的商业策略，以及此后的起点中文网。
年网易老板丁磊依靠股票市值成为中国首富，年，轮到了陈天桥。
对比一下网易、盛大、腾讯的年财报：
网易：营收亿人民币同比，净利润亿人民币同比；
盛大：营收亿人民币同比，净利润亿人民币同比，同时在线最高万人网络数据，未能证实，但量级差不多；
腾讯：营收亿人民币同比，净利润亿人民币，同时在线最高万人；
从中可以清晰看出，盛大的营收、利润、增长率都是最高的，唯独同时在线人数远远不及腾讯。
上一篇说了，当时，流量还没有今天这么值钱，尽管腾讯坐拥万的同时在线人数，然而，并没有带来与用户规模同等级别的营收和利润。
当时，网络游戏是最赚钱的，所以盛大的利润最高，尽管从用户规模上盛大远远不及腾讯，甚至不及网易。
所以了，很正常的逻辑，只要继续扩大游戏的用户数，盛大就能够继续保持领先。
不好说腾讯是否受到了盛大的启发，总之，腾讯此后做的跟盛大的初衷是一样的：增大游戏的用户数。只是，腾讯是从另外一个方向，将自己已有的强大流量导入到游戏，进而获得更多的营收和利润。
盛大由于本身缺乏流量，要做的自然是从另外一个方向：找到一种能够引起游戏用户量继续暴涨的方式。
——盛大盒子，最强大的流量入口——
那么，为什么盛大选择了“盒子”，一种跟电视机紧密结合的产品？
这个选择不是没有依据的。
首先，笔者能够想到的最早的游戏，就是小霸王游戏机，将电视机屏幕作为输出设备。所以，将游戏放到一个“游戏机”里，跟电视结合起来，一方面是对电视功能的扩展，另一方面，是对用户购置成本的降低。
其次，、等产品在中国的发展，发出这样的提示：中国的购买力有限，更广的用户群体没有实力购置功能完备但成本高昂的电脑，而更愿意花更低的成本购置某些功能简化的“类电脑设备”。
再次，从统计数据看，年中国电脑销量万台，其中个人购买的只有万台，而同一年中国彩电销量达到万台，播放机销量万台，这两种设备显然大部分都是个人用户购买的。
所以，从量级上，年电脑销量尤其是个人用途的电脑销量跟电视机销量完全在两个不同的层次。
再来看另外一组数据，年组装电脑的售价基本在人民币以上，农民工月收入普遍在元以下，也就是说：买个电脑需要半年的收入，如果刨除其它日常消费开支，估计得一年的时间能够凑齐一台电脑的钱。
没错，看到这些数据，如果是我，我也会想到：如果要最大规模的扩大用户流量，最好的方式就是把游戏做到盒子里，然后卖盒子。
这样做的意义在哪里？这样做的意义在于：依靠盒子打入所有拥有电视机用户群体，获得同时期远远高出电脑用户群体的用户流量。
今天，大家问：为什么没有想到手机呢？当时手机也很火爆啊！
年手机确实很火爆，然而，年的手机配置太低了，只能玩贪吃蛇，高配的手机比电脑还要贵，最关键的是，网络不行啊！
也有人会问：“为什么年的腾讯没有靠盒子也能做那么大的流量？”
因为：腾讯的很多流量是共用的网吧电脑。其实这个特点，同样适用于盛大的游戏。电脑硬件销量和电脑用户流量在早期的中国是不匹配的，这也可以说明为什么大部分的电脑不是卖给了个人，但网民的数量却实实在在的上涨了。
年，虽然陈天桥成为了首富，然而电视媒体上，最多的广告依然是电视机、。这是热点，也是当时范围最广的群体的购买力能够够得着的。
所以，从盒子的角度切入最广大的电视机用户群体，这是非常具备野心也是非常理智的决策。
——技术、产业、经济——
非常理智的决策为什么会导致非常糟糕的结局呢？
谈政策因素都是单纯的找借口，于事无补！因为，索尼的在中国卖得最火的时候，中国是禁止的；苍老师在中国最火的时候，中国是禁止岛国动作片的；类似的案例还有很多！
什么意思？意思是：只要用户有需求，而且需求够强烈，别说政策了，连法律都不好使！
 那么，盛大“盒子”到底失误在何处？
 我们再来看一组数据，大家就都知道失误在何处了。
年，组装电脑的价格跌入人民币以内，农民工月收入达到元；
年，组装电脑的价格跌入人民币以内，农民工月收入达到元；
这说明什么？只要是外出打工的，基本上一个月收入买台电脑，不会太心疼的。
事实的销量呢？继续看。
年中国电脑销量达到万台。
当初远超电脑销量的电视机呢？在年达到峰值万台后，年一下子跌落到万台，
播放机的销量，在年开始下滑，年回落到比年还差，只有万台。
之前我们的假设是：一个家庭，可以没有电脑，电视机总是会有的。
后来的实际情况却是：一个后家庭，电视机只有一台甚至没有，笔记本电脑几乎两口子人手一个，更不要说后期的平板和智能手机。
这是种巧合么？年之前的彩电销量一直高速增长，打从盛大开始做盒子，年彩电销量首次下滑而且大幅下滑。
被这个巧合坑苦的不仅仅是盛大，还有做电视机的长虹。长虹大规模囤积关键零部件，以打击对手，没想到，最后，打击的却是自己，囤积的零部件非但未能阻止对手，甚至成为压垮自己的关键，因为，液晶电视的时代来临了，老的零部件几乎没有任何价值。
同样的，盛大低估了技术发展对产品周期的推进速度，低估了技术革新对价格的快速降低。
最主要的是，低估了中国经济发展带动的最广大群体的收入水平的大幅提升。
——完全是意外——
今天看来，广电对盒子类产品的监管是很无厘头的，我有电脑可以搞定一切，谁还会用盒子搞别的？
不过，这样，反倒为盛大提供了很好的借口，甚至，靶子。
或许，从陈天桥的个人发展历程可以看出一些端倪：为什么首富非要跟广电死磕？本来么，有人跳出来拦住你，换个方向就是了，也刚好躲过这个坑，为什么非要硬闯死磕呢？
 、从性格上，许多人尤其是牛人，做事情是很执着的，只要认准的事情，越是有人拦着，越是死磕到底；这种性格无所谓好不好，而是看用到什么地方。牛气如苹果乔布斯也犯过类似的错误比如当初孤注一掷搞电脑。
、从陈天桥的经历上看，政府关系相比其他互联网大佬，是做得非常好的，没有人像他这样获得过如此之多的荣誉具体的可以百度。
 于是，一个看似完美无缺的人，自认为能够解决所有问题，在死磕的过程中，却被自己从来没有想到过的意外因素给耽搁了。
简单说就是：人算不如天算，总有你算不到的。
有些研究企业经营的文章这样描述最为成功将企业长久繁荣作为成功的第一指标的企业家特点：
、相比同行，他们对新事物的预见能力、对新方式的开拓能力，是落后的，而不是领先的；
、相比同行，他们对新事物的接受意愿、对新方式的学习意愿，是主动的，而不是不屑的；
、相比同行，他们更多的关注企业内部的问题以及业务发展过程中冒出的细小机会，而不是看别人又靠什么赚了大钱，或者干脆弄个惊天动地甚至开天辟地的产品；
如果有人认为这是在为腾讯的“抄袭”行为背书，那就大错特错了，这些研究成果是美国的研究人员针对上百年来美国的真实企业案例做出的总结。
概括的说，意思就是：聪明的企业走的很快，但往往容易因为快而误入歧途；笨的企业走的很慢，往往是一边学习别人一边自己摸索，但能够走的更远。
最典型的，比如：沃尔玛。具体的可以看沃尔玛创始人沃尔特的传记。沃尔特的许多策略都是跟别人学的，而不是自己首创的。
跟别人学有个好处：所有人的优点都愿意学，反正不是自己首创的。
关注自己有个好处：无论自己第一还是第二，总有问题等待解决。
——高处不胜寒——
 年，陈天桥成为大陆首富，盛大成为行业霸主，众星拱月，大家翘首以盼，希望业界领袖能够找到新的突破口，再次引领行业走向。
而当年，所有的数据指明：盒子战略是最为明智的选择。
为什么同样做游戏的腾讯，在成为游戏行业霸主之后，没有进军盒子或者游戏机市场？
其一当然是因为盛大已经替腾讯趟过了这个坑；
其二是因为腾讯在游戏行业处于霸主之时，电脑的普及率已经够明显了；
其三是因为，马化腾团队从一开始就见证了“机”是如何在某些人一路看好的形势下逐步走向没落的。
如果要开拓一个新的领域，一定要找一个“未来长期看好的”领域，无论是新创业的小团队还是二次创业的大企业。最好不要去碰目前已经非常火爆的领域——火爆不了多久的，这是规律。
电脑的普及一定是趋势，只不过在年看来，这个趋势需要的周期远远超过电视机以及盒子。
其实，无论做不做盒子，保持在电脑游戏领域的领先地位，这是一定要做的。
问题可能在于：短时间内利用盒子一统江湖的诱惑太大了，大到在某些决断的时候比如腾讯游戏异军突起的时候盛大竟然未能保持领先位置。
或许，正是因为腾讯在电脑用户群体中强大的流量优势，迫使盛大必须依靠盒子占据新的流量入口。
然而，网易近两年的业绩提升，则说明：只要游戏自身的竞争力足够强大，流量并不能决定胜负。
更何况，如果有用户需求存在，哪个硬件产品愿意得罪用户的需求而禁止安装？如果有厂商这么做，他的竞争对手一定会用事实告诉他：你错了。
其实，从盛大文学同样可以证明：盛大的眼光是非常独到精准的。
或许正是因为这样的自信过于强烈因为一直以来都被证实是正确的，才导致一旦某个眼光不够精准的时候，代价过于惨烈！
 这样的代价，除了企业自身的财务以及人力，还有企业家自身的心态。
这个逻辑同样可以印证以上美国学者的研究成果：辉煌得最长久的企业，都不是最“聪明的”。
——盒子，流量陷阱——
总之，即便在今天，各种盒子一大堆，甚至安装网络的时候免费派送，但是，用户在盒子上也仅仅是看看电影、电视剧。
无论是从硬件成本还是用户习惯上，盒子都很难跟电脑拼搏大型游戏的流量入口。
更何况，中间杀出个和，连笔记本竞争起来都吃力，更不要说依托电视的盒子。
从业务形态上，并不是谁持有硬件谁就持有流量，比如微软依靠操作系统取代硬件设备获得了最大的流量；
甚至，连拥有操作系统优势的微软，与相比，都没有流量优势。
最核心的流量，依然是用户的兴趣和需求，利用硬件、利用操作系统、利用搜索、利用应用分发市场，都不见得能够获取到最终的用户流量。
你觉得流量掌握在你的手里，其实，流量最终只掌握在用户自己手里。
当初某人说：有本事你家的产品不要进我家的卖场！
 某人用行动回答：有本事你家的卖场不要卖我家的产品！
【水滴的声音】关注互联网企业文化、团队管理。
本篇为《互联网陷阱——流量战争》的第二篇。以下为相关文章：《 互联网，流量的战争 》一网站主题：

经典游戏的版本，可以在设备上面运行，在无聊的休息时间，输入网址，即可畅玩经典游戏。如吃豆人、水果忍者、俄罗斯方块等。
根据游戏热度，对游戏进行排名推荐。
玩家，开发者可以在该网站的论坛上，进行讨论。
博客主，论坛版主也可以在自己的网站上面嵌入经典小游戏。

整体网站界面
其中的一个游戏
二项目架构：

前端：库
后端：      _  
网络：小游戏资源在上面，加快下载速度。

如上图所示：服务器负责处理静态文件请求和转发请求到后面逻辑。、、构建一套基于框架的处理架构。负责网站数据的存储，简单可靠。不考虑备份问题。综上，根据架构和网站需求，进行服务器选型。
三服务器选型
根据业务特点我的网站业务用户量未知，开始应该比较小，没有复杂的计算，网络带宽相对比较重要，个人网站，需要经济实惠

服务器选型原则
部署地域
操作系统版本
磁盘大小和网络类型
服务器访问安全策略制定

网站为英语用户使用，网络部署选择在北美系统中，对比较熟悉。选择版本。磁盘数据，应该不会用很多，日志和数据是大头。日志可以定期删除，的使用也比较少，如果超出了，在找地方备份，或者用数据库服务器。初期，由于位置访问流量有多少，所以我选择按流量付费，以免造成浪费。只暴漏端口，登录和传输文件后续如果需要等端口，再新建安全组。
配置概览 
四运维软件
运维：

：直接使用终端
：使用

： 
五建站流程：

注册域名国内需要备案
解析
购买腾讯云服务器
程序部署
运维管理
测试发布

六疑问：

我的网站主要消耗在网络上面，资源富裕，这种情况下，我怎么利用起来 
广点通的广告合作，是否可以更快捷集成到腾讯云上前沿技术中心发布《 行业全景热度观察》，并指出在国内热度持续， 年第三季度的全球  公司融资总额已高达  亿美元，仅比前两季度之和低  亿美元；而与  年同期相比则增长了  余倍。截止  年第三季度末，全球已出现了逾  家  技术公司，较上季度末增长了约 ，且各细分领域的创业者和资本仍在不断涌入该领域。仅就“”和“人工智能”，可以观察到在此波  热潮中，人们对这个英文缩写的认知度正逐渐提升，渐渐达到了中文“人工智能”的程度，甚至超过了“”。而另一方面，关于“机器学习”和“深度学习”的讨论则依然局限在学术界。















本文来源于  新观察微信公众号 导语：公司项目，越来越多的系统在计划上云。如何监控云上的系统运行，是每个系统上云的过程中都会碰到的一个问题。在这里，我们以公司的某个项目为例，向大家详细阐述该项目上云后的日志监控方案，详细讲解如何通过集群，实现每天百日志的监控。
此项目原本是一个包含众多业务流的一个  监控系统，在迁移到腾讯云之后，希望接入更多的业务，日志监控压力也随之剧增，每天的日志数量将达到百  以上，为满足这个项目的日志监控需求，特意在腾讯云的  上配置了一套  集群。
 系统介绍
我们在  项目这个配置的  系统主要包含四个部分 ，， 以及 。其中

 主要负责日志的收集，能自动感知日志文件中增加的  条目。
 主要负责日志文件的转发，并且在转发过程中对日志进行过滤和整理。
 可以看作一个高效的集群化的数据库，可以直接通过  对其进行访问，在  中，主要负责  的存储，也是整个 系统的核心。
 可以看作  的一个前端页面，其将用户的操作转化为  的查询指令，并将从  查询到的数据进行图形化展示。

  集群预览
在物理机上，可以通过多台服务器构建一个  的集群，在腾讯云上，配置  集群的另一种方式就是通过  管理一个包含多个  的 。

  集群配置
集群化的  系统的关键就是配置集群化的  系统，通过配置  的集群，实现海量日志的存储，和快速查询。
配置  集群，我们主要参考了  上的一个样例 。
我们将  节点，分为    三种类型，分别负责不同的任务，其中

 节点  只复杂集群的管理，不存储日志数据，也不接受  请求
 节点  主要负责接受  请求，不存储日志数据
 节点  主要负责数据的存储，不接受  请求

在这，我们给出我们的配置文件供大家参考和借鉴
首先，给出  的集群配置方法
  
 {_}  

  
 {_}  
 {_}  
 {_}  
 {_}  
___ {___}  

 {_}  

  
   
   

  
_   

  
 {_}  
   
      
 {__}  
 {___}  

  
  
 {_}  
__ {__}
其次是配置 ，只需要提供  的访问 ，就能直接与  进行直接交互如果配置了  插件，还须提供相应的用户名以及密码才能访问。
   

   

   
 
最后是配置  以及 
在  中设置日志文件的路径，并在输入的日志数据上加上标签，方便  对日志进行分类，对不同的日志类型进行不同的处理。

 _ 
    
         
         
    _ _
      


     {_       _   }

 

     
     
在这里， 根据日志的标签，对不同类型的日志，执行不同的处理如果配置了  插件，还须提供相应的用户名以及密码才能访问。
 {
         {
                 = 
                _ = 
        }
}

 {
            {
                 {
                         = 
                        _ =  
                }
                 {
                         = {  =  }
                }
        }
}

 {
            {
                 {
                         = 
                        _ = 
                         = {}{ }
                         = 
                         = 
                }
        }  {
                 {
                         = 
                        _ = 
                         = { }
                         = 
                         = 
                }
        }
}
在  上运行所需的  文件
想要实现  集群在  上的运行自然少不了相应的  文件，我们使用的  文件主要参考了 、等仓库。空间中的一个点的坐标，可以用来表示。
对这个点的坐标变换有三种操作：缩放、平移、旋转。 缩放之后，点的坐标变为平移之后，点的坐标变为；旋转会比较麻烦一点，在后边的详细内容中描述。
上面的操作其实可以用矩阵运算来简单的表示，但是用矩阵表示变换的时候会有一个问题：用一个矩阵可以同时表示点的缩放、旋转，但是没办法表示平移了。 此时需要引入一个齐次坐标的表示方法，将点的坐标表示为。
缩放矩阵
点在、、轴的缩放分别为、、，那么缩放可以用下面的矩阵来表示：






























   = 
旋转矩阵
首先看一下点绕着、、三个坐标轴旋转一定角度时，坐标的表示方法：

用矩阵来表示：

那么当点绕、、轴分别旋转、、角度时，旋转矩阵=，得到矩阵如下：






























平移矩阵
点在、、轴的平移分别为、、，那么缩放可以用下面的矩阵来表示：






























   = 
综合变换矩阵
综合上边的三个矩阵，可以得到最终的变换矩阵： =






























简写为






























不同的编译器在内存管理方式上的不同，会导致有的情况下使用行优先的写法较好，有的情况下使用列优先的写法较好。我这边实践的过程中接触的是列优先的写法：






























得到这样一个矩阵之后，围绕、、三个轴所做的选择、缩放、平移操作，所影响的矩阵中的位置就一目了然了
左右手系转换
假如我们得到了一个右手坐标系下的变换矩阵，需要把它转换为左手坐标系下的变换矩阵，那么可以将其绕一个平面翻转，假设选择绕平面翻转。
分析一下翻转之后的结果：变为；变为；变为；其他不变。
正弦和余弦函数的曲线：

将这些变化代入上面得到的最终版变换矩阵，可以得到
 =   =    =   =   = 
将变换矩阵中这些位置的值都乘以，即可得到绕平面翻转之后的左手系变化矩阵。






























也可以换一种思路，当用右手系变换矩阵变换完成之后，将坐标沿着平面做个翻转，这个翻转可以用一个缩放矩阵来表示：






























 得到新的矩阵，转换为列优先的写法：






























也就是说，把第三列都乘以就可以了
上面两种思路可以得到等价的坐标系转换结果。写在前面：
本文主要介绍的是自己的一些经历，以及读过的一些书，实际应用的经验并没有介绍，包括现在很多机器学习的书一般也是侧重于理论，结合实践的时候会发现和模型比起来，数据清洗、特征工程的实际效果更明显，而这方面很难有系统的理论知识，怎么办呢？读  ，去搜索自己应用领域有关的、大公司的经典的 ，里面对数据清洗、样本筛选、特征构造、系统搭建这方面会有详细的介绍，在正式出版的书里，这块很少，所以读书只是基础，结合工作场景去应用才知道“纸上读来终觉浅，绝知此事要躬行”。
另外如果碰到比较抽象的问题而难以理解的时候，有一个诀窍是，多和生活联系起来，很多计算机上的难题在生活中是有类似的事情和成熟的解决方案，比如优化与爬山；“世事洞明皆学问，人情练达即文章”，共勉！
正文：
年高考发挥失常，花了五分钟填了两个志愿，华科光电华科计算机，感谢当年光电专业超高的分数线把我刷掉了，我被调到了计算机；收到通知书以后，原本比较坚定的复读的打算变的动摇，家境有比较糟糕，于是抱着早点读完，早点出来挣钱的想法读完了四年华科计算机；老实说，我不是一个特别爱动手的人，本科四年把所有  语言的书几乎都读了一遍，但动手能力还是很一般；保研以后，因为家里断了我所有经济支持，我花了比较多时间去挣生活费，所以专业也不算学的很好，只是晚上坚持把和算法导论英文版啃完了，顺便把  网络编程、 设计新思维、 源码剖析看完了，算是有一点基础吧。
找工作的时候，固执的想找一个后台开发，美其名曰可以多年钻研，沉淀技术；实际上回想起来不过是胆小，怕跟不上变化太快的技术节奏有多少人和我一样？进入鹅肠以后，确实是做了几年的后台开发，从一个小白到负责浏览器后台日活千万的图片转码服务，这中间的摸索、挫折、被叼不足为外人道也，工作三年左右，我先后接触过浏览器后台几乎所有的模块，对公司海量学习、柔性可用也有一些理解，也隐隐看到了传统后台的天花板，下一步该做什么呢？一定要去造轮子、写框架吗？
恰好这个时候，我们成立了一个小说的项目组，而大家都知道我是一个骨灰级网络小说爱好者，起点阅读记录是亿，阅仙称号，于是我有机会去做小说项目；在这个项目里我们碰到了一些文本处理的难题，比如怎么自动聚合同一个章节的多个数据源并挑选一个最优的候选源，怎么识别内容不对的源；在这个过程中，和搜索转岗过来的  有了比较多的交流，开始知道什么叫词袋模型、什么叫  、什么叫朴素贝叶斯、 聚类；将这些算法应用到小说业务场景，确实取得了不错的效果，于是一扇新的大门缓缓开启。
我开始阅读信息检索导论，这本书是介绍搜索的一本书，但其中涉及到很多基础的机器学习算法，比如谱聚类、 聚类、 等等；中间转做过一段视频，不是很成功，最后又开始转为商业化，一开始我们想做点击率模型，后来因为是 模式，对点击率要求不高，就开始做商业画像；这个过程中，读过的基本比较重要的是李航博士的统计学习方法，里面把浅层学习的几个算法都从数学上给出了比较严谨的推倒，也是看这本书的时候意识到自己的数学基础还不是很好，虽然我对数学还是比较有兴趣，但是出来几年，很多也都忘了。
读这本书过程发现，机器学习对数学分析、概率论、线性代数以及优化理论都有不低的要求，于是开始回过头来重读数学分析，穿插着看了周志华的机器学习俗称西瓜书；深度学习方面第一本书才刚刚付梓，但是网上有些博客还是有的，我读了一篇  性质的博客。再回过头来看，人工智能是一个很大的概念，机器学习知识其中一部分，机器学习可以有各种定义和解读，可以说是让计算机从大量数据中自动学习规律，并应用；可以从信息压缩角度理解为，讲大量数据压缩陈成模型等等，他的应用也很广泛，应用在文本方面就是自然语言处理；应用在图像方面就是图像、模式识别；应用在推荐上就是推荐系统；应用在视频上可以做动作捕捉、实体识别等等；应用在汽车上可以是自动驾驶；在商业上，是广告排序。
 五花八门的应用，又混杂了数学、统计、编程等知识，看起来就像一只凶悍的刺猬，作为一个只熟悉后台开发的码农？该怎么入手呢？复杂的问题，答案往往简单；大抵可以从这么三个方向入手：数学、文本或搜索、编程；我个人的经历实际是从文本处理入手，但并不推荐所有人都走这条路，如果你的工作和文本处理搭不上边，大可不必学习太多和文本相关的奇技淫巧。直接从数学的统计或者概率入手，可能会更直接。
下面我按照我的一个学习大概历程给一个书单吧，不一定是最全的，也不一定是最合理的，仅供大家参考：
 《 统计学习方法 》：李航博士是华为诺亚方舟的首席科学家，前不久一次会上见到了本尊，这本书的特点是：算法齐备、推倒严谨，薄薄的一本书几乎涵盖了浅层学习所有的算法，并都从数学上给出了较为严谨的推倒，适合有一定数学基础的人入门使用，过程中发现自己数学上的不足，再回头去补；
《 数学分析新讲 》：北大张筑生老师的，一套三册，我花了大约一年的时间才读完，非常费劲，但是很值得，比普通的高等数学要周全的多，唯一小有瑕疵的地方是实数连续统的描述用了计数法，不过这里可以参考陶哲轩的实分析，他是从 公里体系出发来论述；费尔金斯的大作里则是用戴德金分割来论述的，都对比一下会很有意思；
《 最优化导论 》：看完数学分析以后再看中的推倒会发现还是有很多地方不甚了了，举个例子牛顿法或者说可以用在多种算法的推导上，那牛顿法、海瑟矩阵到底是怎么回事呢？这时候就是该祭出这本书的时候了，这本书我觉得是补齐了从数学到统计学习方法之间确实的一环，里面主要介绍一些优化理论；简单来说，机器学习里一个很大的困难是函数没有解析式，那么对函数求解最优解是不可能像二次函数一样通过公式直接求得的，必须通过迭代的方式逐渐去逼近最优解，就像爬一座山，不能一下子看到山顶，但是我们可以看到比现在更高的地方，于是先爬一小段，到了那个位置再往上看，又能看到最高的地方，于是又换个方向再爬一段，最终我们一定可以爬到山顶；最优化导论的几个算法几乎都可以往这个例子里面套，不过是观望和路线指定的策略略有差异罢了。
《 机器学习 》：周志华，大家都知道有一个写过的机器学习，但实话说，那本书的内容真的比较陈旧了，不如读周老师这本西瓜书，因为全书都在用西瓜举例；这本书和有不少重合的地方，区别在于这本书是从机器学习自身出发，弥补了偏数学理论，而工程实践严重缺失的不足，这本书则从基础概念讲起，让你对机器学习有一个基础的、正确的理解，打个比方就和陈近南给韦小宝的那本绝世秘籍的目录差不多，读完这本书，你并不会马上获得很高的算法设计调优的能力，但是你拿到了入场券，你可以选一两个方向或一两个算法去深入研究 。
《     》：这就是我提到的深度学习的一篇优秀的，配有代码，深入浅出的介绍了神经网络、算法、深度学习的一些基本概念，适合入门；深入的话可以看看三位大神合著，最近刚出版的那本 ；美刀的价格不便宜，好在有电子版
小结：上面本书基本可以做一个很好的入门了，之后的路该怎么走，相信读完了的同学一般都会有自己的看法，任何一个领域，良好的入门手续才是比较难的，入门以后登堂入室的路怎么走其实大家都会有自己的主见。接下来的书单我并没全部读完，仅供进一步参考，这里也不再排序。
 《 线性代数 》：我读完了浙大版的线性代数，但很遗憾，这本书过于简单，对矩阵分解、奇异值分解等机器学习里的常用只是没有涉及，网上比较推崇的是的两本书，一本是     另一本事   ；我是准备配合视频读前一本
《 概率论后续 》是随机过程、统计模拟、时间序列这方面的资料，包括贝叶斯分析、吉布斯采样、 方法：统计这块我的感觉比较差，理解比较慢，推荐陈希孺的两本书吧，一本是概率 一本数理统计；贝叶斯的书我之前的文章有提到，大家可以去找找；吉布斯  建议看博客
《 实分析 》：陶哲轩
《 微分流形 》：陈省身
《 点集拓扑 》：北大教材
《 泛函分析 》
这几本书是进阶版了，大部分可能用不到，想研究流形优化、核方法的同学可以挑战一下
《  》：模式识别与机器学习，非常翔实的一本书，也是经典，可惜我没有读完，只看了前几章；
《 凸分析 》：最优化导论的升级版，应该是目前优化理论的集大成者；
《 数学之美 》：吴军博士的书，消遣的时候翻一翻吧
《   》：三位大神版本
以下推荐几本智能相关的书，博大家一笑
《 心智社会 》：马文明斯基的巨著，他自己的总结挺好：没有心智社会就没有智能，智能源于笨拙。这本书主要是探索人的思维的本质，很有意思的论述；
《 弗洛伊德 》：马文明斯基推崇的心里学家，我也没怎么看，只翻了一点点梦的解析
《 上帝掷骰子吗，量子物理史话》：推荐读一读，对量子、意识有一点了解；
《 周易》：配合孔子的十翼看看，中国玄学、文化起源的神书；
《波若波罗蜜多心经》：心浮气躁的时候默念一下
总结：这部分比较随性，有深入研究的书，也有一些看似不着调的书，归根到底，所有的神秘都会归结于灵魂、意识，佛学说“法不外求”不是没有道理的，毕。月日，腾讯云正式启动 “腾讯云采购节”大促活动，活动期间旗下云服务器、云数据库、域名等多款核心产品大幅降价，最低折扣达折，优惠方式也涵盖了新用户礼包、大额返券等多种形式。
在行业采购最旺盛的节点，腾讯云推出史无前例的降价优惠活动，不仅表明了腾讯云释放多年积累的技术红利、反哺行业和消费者的决心，更是显示了腾讯云进军云计算中长尾市场的战略意图。

据腾讯云官方发布内容显示，本次腾讯云采购节活动主打云服务器、云数据库、域名三类产品，覆盖多种型号配置，优惠产品性能与优惠幅度都极具市场竞争力。
云服务器方面，腾讯云此次提供了近百款可灵活挑选配置的云服务器产品，最低优惠达到折，在性能全面增强的腾讯云第二代服务器极高的性价比上再度优惠，价格优势较为明显。

在云数据库方面，腾讯云数据库产品所有配置均参加活动，提供高达 的强悍性能。基于引擎的数据库全线降价折，其中更有款特价数据库低至折。

而域名注册方面，腾讯云针对“”“”，“”，“”等大备受开发者青睐的域名作出降价调整，推出了行业抄底价格。

此外腾讯云还针对性推出免费套餐——包括云服务器、数据库在内的多款云资源个月免费体验；云校园——学生群体元特价等全方位整合优惠项目，目标直指云计算行业差异化市场，着力推动云行业市场规模的二次创造。
据了解，采购节中主打的第二代云服务器自推出以来，一直是腾讯云的爆款产品——采用英特尔®至强®  处理器，整数和浮点运算性能相比以往提升；搭配  内存，性能提升；全面搭配网络增强，包转发率最高可达。而在此次采购节中，高性能搭配丰厚优惠，称腾讯云第二代云服务器性价比之王名副其实。
得益于平台优势和技术积累，腾讯云正试图通过将高性能产品捆绑优惠价格发掘云计算行业的中长尾市场，而此次腾讯云采购节的推出，无疑将进一步规范云计算行业价格、降低云端产品平均使用成本，也将成为引导云产品市场发展、形成良好云生态的关键力量。此配置细则是在  环境下配置教程，有新内容会及时补充。
环境配置：



操作系统
 企业版




内存




软件版本：



 










——



选择自己语言版本的 下载地址， 这里我选择的是 版本  本身没有平台依赖， 和  都可以。
一 环境依赖
下载 
使用   需要生成两个库文件， 库文件需要依赖  库文件。
首先，下载 下载链接  的  版本，这里根据自己的环境进行选择，如果请求采用  方式，请务必选择带  的版本。本案例中选择如下。 

下载完成后直接解压。 
安装 
 的版本必须选择支持自己开发环境的，本案例中开发工具选择 ，直接下载最新版本  即可下载地址，
下载完  进行安装，安装完成后打开 如下： 
说明： 

这里选择之前下载的  解压后的路径；

这个   是生成的  库文件的路径，这个自己建一个就好。

这里选择自己对应的开发工具版本，先点击 选择你开发工具版本本案例选择的是 这里注意一定要对应，如果没有，建议选择其他版本的 我之前用的 并选取   版本，没有找到对应的开发工具，后来直接升级成 ，下载最新的  即可。


注意事项： 

这里如果不实用  的话，建议把勾去掉。 

这个选项务必打勾，待会后面生成静态库要使用。 
配置完成后，点击  生成  的库文件， 依赖于  所以生成  的库供 调用。
二 生成库文件
建空项目
使用  平台新建项目建议选择空的项目，用于生成    静态库和动态库文件： 

建好项目后，导入附件  目录下所有源文件和头文件包括  文件夹下的头文件，还有之前下载  解压后里面的  文件，导入完成后，项目结构如上图。
之后项目名上右击→属性→配置属性→常规： 

生成静态库，选择配置类型为。  
之后导入  头文件

之后选择 →常规→附加包含目录： 

自己下载的  解压后的路径

 的下有  文件，所以这个路径也需要加进来。 



导入生成的  库文件

这个附加库目录是之前生成的  库文件路径，这里我提供自己生成的一个库文件，直接拿去用即可。 

操作：库管理器→常规→附加依赖项→_这个是我自己生成的  库文件，相同环境下可以直接拿去用→确定。
并且这里注意加上于处理器项： 

生成静态库
项目名上右击→生成，即可生成    静态库文件。 

生成动态库
更改项目配置类型： 

之后的操作流程跟静态库的流程基本相同，注意检查下所有的附加项和附加依赖项是否添加完整！这里务必检查下，因为更改配置类型后，部分项需要重新添加。
 配置类型下附加库目录和附加依赖项分属不同的编辑页面： 


至此，所有配置修改完成后，直接项目名→右击→生成重新生成的话会把之前的 库删掉。 
 
三   使用
在需要使用  的项目中，添加    的头文件路径和库文件路径，并在附加依赖库中输入    静态库。
生成的动态库路径需要添加到系统  路径中，也可以将生成的动态库复制到程序的当前路径下。 
备注：附上 _ 对  的基本操作，之后可以根据自己的业务做相关的开发。同时附上我自己生成的库文件。

相关推荐腾讯云  消息队列在  环境下的使用腾讯云  消息队列测试 腾讯云分布式高可靠消息队列  架构作者：

一开始，在  端，并没有任何可以接触到  的内容。以前，我们想要执行  只能借助 。但现在，伟大的  又或者说  推出了关于  操控  的草案。最出名的就是两个 




我们一步一步来了解一下。先来看一下经典  的使用。
复制操作
 复制
我们需要先了解一下，基本的复制过程：

选中
复制   ||   

实际效果就是：

而， 也是遵循这一过程来实现这样的效果。如果我们想使用  执行  的话，那么应该先选中你想复制的元素。
这里另外还会使用到一个新的  。具体来说就是：

 用来获得当前选中的元素的内容。一般而言就是用鼠标选中页面上的内容。
 用来将选中的内容直接变为  文本。

基本使用就是：
 输出选中的文本

我们一般只是使用该  进行辅助作用。最常见的做法就是动态创建  元素，然后动态制定 。执行  进行选中，然后执行  即可。
 总的代码就是
  {

   动态创建  元素
    = 

   获得需要复制的内容
   

   添加到  元素中
  

   执行选中
   注意 只有  和  可以执行  方法
  

   获得选中的内容
      = 

   执行复制命令
  

   将  元素移除
  

}
看个实例。
任意复制
当然，如果你想不动态添加  元素，想直接  的指定  元素的话，应该怎么做呢？这里就需要使用到  新提供的  相关方法。当然，上面的  也是其中之一。用到的  有

 用来创建选中容器。返回一个  。 该  的兼容性，也是挺好的，手机端和  端都支持。

 返回   上挂载的方法。用来添加选中元素。只能添加一个




 这个方法是挂载到  方法下的，用来执行元素的选中。！很重要



上面  就这么一些 
直接看  吧。
这里，我贴一下关键代码
      =   
    =   
   选中需要复制的节点
  
   执行选中元素
  
   执行  操作
  =   
   {  
      =       
         
  }  {  
         
  }
 移除选中的元素
  
这里需要额外提醒一下，不能自动执行上述  操作。即，在没有任何用户交互操作下，是不能执行  等交互行为的。所以，这里需要用到  事件来辅助当然，你也可以使用其他事件来进行代替。
使用  复制
首先  是最近提出来的，所以它的兼容性还是需要等待时间去验证的，目前的兼容性是支持一些简单的 。
如果，你的浏览器支持   的话。那么 复制操作就变得异常简单。
 当然，下面的代码应该放在某个交互的  事件中。
  =   {
             
              
        }
        
如果没有的话，就只能使用在  的  事件中返回的   来设置或者获取相关的信息。我们获得  对象只能通过事件回调来实现：

 只能通过  上的 事件来获取

  {
     设置信息，实现复制
      
     
}

 该  还挂载两个常用的 

  设置相关的数据信息，主要用于  和  的相关事件中。

 就是基本的  。最常用的就是 。具体内容可以参考  
 就是对应   放入的具体数据内容


 一般用于  事件中。用来获取  里面的内容。不过，需要制定正确的解码格式就是设置好正确的  。并且，该方法只能在  事件中使用。




上面感觉就是简单的介绍一下 ，接下来正式说一些干货。如果使用  实现自定义复制内容。这样，你不仅仅可以复制页面上简单的  文本，还可以复制图片信息等。
看代码
 在指定  上绑定交互事件
{}{
     添加  内容
       {
             = `{}`
             
            
        }
     执行  命令
    
     移除绑定事件
    
}
   相关
前面看起来也挺简单的。当然，有同学会想，不是还有其他事件比如   吗？是不是也可以这么做呢？
额
一开始，我也是这么想的，但现实往往会给您一个轻轻的爱抚。因为，为了防止你恶意的获取用户信息，在  中，一般而言你是不能通过  触发  事件。不过，在手机端中，规矩是，你可以在可编辑的元素中触发  和   只能在有效的 选中 元素中，触发 。
根据上面的说法，我们可以通过利用  的相关方法，来具体应用到实践中。比如，防止用户粘贴信息。这特别适用于那些做题页面，防止你查资料然后  相关答案。
   {
            
        }
当然，还有更狠的，直接禁止 ，， 事件。
  ={
     ={
        
    }
}
方案总结
 现在能完美提供给我们的应该就是  事件的使用，对于市面上的  差不多也是运用上述的知识点。根据上面的描述，可以了解到，想要实现复制功能有三种渐进退化方案。以下兼容性由高到低：

 模式



 直接操作


现在  比较火，这里我简单的写了一个  组件。具体的使用  已经写清楚了，如果有什么不懂的地方可以 我。

原文链接：前言
想不想让家里的设备联网？想不想远程控制家里的空调？单身狗想不想一回家就吃到热腾腾的饭菜？除了购买现成的产品，你还可以这样做哦！
为了让设备联网，硬件不能少吧，除了必要的单片机，继电器及其他电路元件以外，能通过上网且又能够简便开发的设备不能少吧？为了解决这个问题，苦苦找了好久，终于找到了这两个芯片。

搜索下，发现这是一个转串口的模块，那么，为了实现让我们的设备上网，这个可不能少！同时这个玩意支持的协议简直不知道高到哪里去了，详细的话请大家呢参考官方技术资料吧！
这个呢，同样也是转串口，他的好处是网上资料多，推荐初学者使用这个。相关资料详见

以上两个芯片咱们第一期教程暂时不涉及，所以大家先不要着急购买
正文
那么，废话不多说，今年的主题是，让我们看看这个东西如何使用。
是一款纯开发的开源高性能的  服务器框架。被广泛的用于手机、移动通讯，微信小程序，手游服务端、网络游戏、聊天室、硬件通讯、智能家居、车联网、物联网等领域的开发。 支持长连接，支持、等协议，支持自定义协议。拥有异步、异步、异步、异步消息队列等众多高性能组件。摘自官网
查下资料，咱们的模块支持服务，但是该用什么协议呢？为了确保咱们的数据稳定，我建议大家使用协议，今天的教程也是按照协议制作。
运行环境要求
只是一个代码包，如果环境满足要求，下载后即可使用，实际上没有安装过程，对环境的要求如下：

版本大于或等于可以运行命令
 

查看版本 

系统要求安装了和扩展可以在命令中运行
   | 

检测本地环境是否满足。


如果满足以上条件，请继续
安装
 系统安装教程
        

  

提示
  

时按回车
 =  

  

安装完成
 系统安装教程如果不是用户请用 后面加命令
       

  

提示
  

按回车
 =  

  

安装完成
安装完成之后呢，接下来打开服务器，怎么打开呢？请向下观看。
测试
创建_

 \
_ 

 创建一个监听端口，不使用任何应用层协议
_ =  

 启动个进程对外提供服务
_ = 

 当客户端发来数据时
_ =  
{
     向客户端发送 
       
}

 运行


运行
 _ 

显示
  
 
  
   

 

这样，一个的服务器就搭建完成了！下一期，我会给大家带来模块和计算机的通讯，谢谢大家！懒癌还不知道什么时候写下一期 是什么？
 是一个分布式的代码管理容器，本地和远端都保有一份相同的代码。 仓库主要是由是三部分组成：本地代码，缓存区，提交历史，这几乎是所有操作的本质，但是为了文章更加简单易懂，就不围绕这块展开了，有兴趣的可以去了解下。开门见山，我们直接来说说  有哪些常见的操作。
 有哪些常规操作？
我们简单说说有哪些常规操作，能够让我们应付简单的开发需求。
克隆代码
✦ 克隆远端代码

  
✦ 查看本地的代码状态

 可以明确的呈现出本地仓库的状态
 哪些文件发生改动，哪些文件已经提交到本机
 以及一些操作指示。
 
✦ 同步远端分支变化

 拉取指定分支的变化
    
 拉取所有分支的变化
  
 拉取所有分支的变化，并且将远端不存在的分支同步移除【推荐】
  
✦ 同步远端代码变化。
 都是先  ，然后执行合并操作
 不同的是，  执行的是  ，   执行的是 
    
    
关于   和   各自的优劣，后文会详细介绍。
这部分主要介绍了关于代码克隆，同步远端代码变化的相关操作。接下来，我们看看关于本地代码的一些操作。
操作 
首先我们要明确一个概念：就是每个  都是一份完整的代码状态，用一个  来唯一标志。
从某个角度上来说，维护的就是一个树，分别保存着不同状态下的代码。所以你对代码的任何修改，最终都会反映到  上面去。
✦ 新增 
 添加文件到缓存区，然后提交到本地仓库
  
   提交备注
✦ 撤销 
 会将提交记录回滚，代码不回滚
  

 会将提交记录和代码全部回滚
   

 将部分代码文件回滚
   
✦ 合并 合并 ，本质上合并两份不同状态下的代码。
  提供了两种合并  的方式
  
  
那么   和   到底有什么区别呢？是两个分支处理冲突后，新增一个  追加到上。是将分支上的记录追加到主分支上，值得注意的是，这个时候他的其实已经发生变化。

相对来说，  处理冲突更直接，而  能够保证清晰的  记录。合并  的时候，通常会发生冲突。可以全局搜索特殊字符比如，找到需要处理的代码位置，然后认真分析应该保留哪一部分代码。
在团队协作的时候，分支是必不可少的。那么应该如何对分支进行操作呢？
操作分支
所谓的分支其实就是一个指向  的指针，你可以去里去看看。

通常情况下，我们建议分支至少能够明确的标记功能名称，如果能标记用户就更好了，比如。✦ 查看分支

可以同时看到本地分支和远端分支，配合上前文介绍的    可以第一时间查看到最新的分支信息。✦ 新增本地分支其实就是创建一个指针指向某一个 。
       
 从当前分支新增一个新的分支
 一般情况下，我们应该从或者其他稳定分支来新增分支
     新建分支
    切换分支
✦ 删除本地分支其实就是移除一个指向  的指针。
 删除本地分支，如果本地还有未合并的代码，则不能删除
   
 强制删除本地分支
   
✦ 新增远端分支通常情况下，我们是新建本地分支，然后更新到远端的方式来新增一个远端分支

   
✦ 删除远端分支同样，我们也是通过更新到远端的方式来删除一个远端分支

 等同于    
   
简单汇总一下
上面说的可能有些分散，这儿简单总结一下有哪些经常使用的操作：
   查看本地代码状态
    添加代码到缓存区
   提交内容的备注  提交代码到本地仓库
     不加就是普通切换分支
    同步远端分支状态
      远端代码到本地，并且以的方式合并代码
     更新本地代码到远端
以上几条命令已经能够应付日常的操作，稍微复杂一些的场景后文会介绍
基于基本操作，在实际项目中，我们应该怎么利用  实现协作呢？
 有哪些比较好的实践？
 有一些成熟的开发流程，比较主流的有两种：基于功能分支的开发流程 和 开发流程。相对来时，我更推荐前者，如果是复杂的大型项目，推荐开发流程。接下来，简单介绍下这两种协作模式。
基于功能分支的协作模式
基于功能分支的开发流程其实就是一句话：用分支来承载功能开发，开发结束之后就合并到  分支。他的优点是能够保证分支的整洁，同时还能让分支代码逻辑集中，也便于 。
分支命名规范
推荐使用如下格式：。这样既便于知道分支覆盖的功能，也便于找到分支的负责人。以后清理分支的时候也很方便。
开发流程
✦ 从  切出一个新分支

   
✦ 开发一些新功能，然后提交建议较多频次的提交代码到本地仓库，以便能够更灵活的保存或撤销修改。此外为了保证提交日志的清晰，建议备注清楚的注释。
 
    挑选需要提交的文件，或者全部提交
   提交备注
   
✦ 如果功能开发完成，可以发起一个流程✦ 如果代码测试通过，合并到 ，然后准备上线
 冗余版 合并到 
   
    
  
    处理冲突
  
  
   

 精简版 合并到 
  
      将的代码更新下来，并且处理冲突
     将本地代码更新到远端
有几点需要注意：不要在合并代码，保证的可用性很重要。确保在正确的分支执行正确的操作。无论是处理冲突还是更新远端代码，请保有敬畏之心。
到此，一个正常的基于功能分支的开发流程就完成了。接下来看看另外一个开发流程。
 开发流程
 比前文讲的基于功能分支的开发流程要复杂得多，它更适合大型的复杂项目。它围绕项目发布流程定义了一个严格的分支模型，所有的开发流程都是围绕这个严格的分支模型进行。而这个模型约定了每个分支的角色，以及他们如何沟通。
我们先来看看  开发流程中几个约定的分支，以及他们各自承担的角色是怎么样的？
✦ 分支：用于存放线上版本代码，可以方便的给代码打版本号。✦ 分支：用于整合  分支。✦ 分支：某个功能的分支，从  分支切出，并且功能完成时又合并回  分支，不直接和 分支交互。✦ 分支：通常对应一个迭代。将一个版本的功能全部合并到  分支之后，从  切出一个 分支。这个分支不在追加新需求，可以完成  修复、完善文档等工作。务必记住，代码发布后，需要将其合并到  分支，同时也要合并到  分支。✦ 分支：紧急修复的分支，是唯一可以从  切出的分支，一旦修复了可以合并到  分支和  分支。
从每个分支的功能和约定可以看出，它流程多约束多，对于小规模应用并不适合。当然  有一些辅助工具  可以自动化的完成这些任务，对于大型项目也很有帮助。
前面讲了  有哪些基本操作，然后介绍了两个主流的工作流程。接下来我们看看  有哪些特别的技巧值得一提。
 有哪些小技巧？
 操作除了基本的代码管理功能，还有一些小技巧能够让你眼前一亮。
 ，查看操作记录
这个我一定要放在第一个介绍，因为它曾经数次解救了我的代码

仔细看上图， 记录了你所有的  命令操作，对于复原某些莫名其妙的场景或者回滚误操作有极大的帮助。试想一个场景：你使用     把本地开发代码回滚到了一个之前的版本，而且还没有推到远端，怎么才能找回丢失的代码呢？你如果使用   查看提交日志，并不能找回丢弃的那些 。而   却详细的记录了你每个操作的 ，可以轻易的让你复原当时的操作并且找回丢失的代码。当然，如果你丢失的代码都没有提交记录，那么恭喜你，你的代码真的丢了。
压缩提交记录
这也是一个很实用的功能，前文提过，我们在开发中的时候尽量保持一个较高频率的代码提交，这样可以避免不小心代码丢失。但是真正合并代码的时候，我们并不希望有太多冗余的提交记录，而且  合并代码的时候，会把每个  都处理一下，有时候会造成冗余的工作。所以，压缩日志之后不经能让  记录非常整洁，同时也便于使用  合并代码。
那么，如何压缩记录呢？✦ 使用   找到起始 ✦   ，切记不要用 参数✦ 重新     ✦     ，因为会有冲突，所以需要强制覆盖远端分支，请务必谨慎。✦ 合并到  中，然后更新远端 。
此外还有两种压缩日志的办法：  ：追加  到上一个  上。  ：通过交互式的 ，提供对分支  的控制，从而可以清理混乱的历史。
从实际应用来说，三种日志压缩都很优秀， 更简单，  更细腻。
 ，合并代码
前文简单介绍了 和   的区别，坦率讲，他们各有优劣。 能让你的  记录非常整洁，无论是线上回滚还是  都更轻松；但却是一个有隐患的操作，使用时务必谨慎。  操作更安全，同时也更简单；但却会增加一些冗余的  记录。
这儿简单说说  的合并流程和注意事项吧。看下图
有三个点需要注意：✦  先找出共同的祖先节点✦ 从祖先节点把  分支的提交记录摘下来，然后  到  分支✦  之后的  其实已经发生了变化尤其是第三点，经常会让人误操作，所以务必注意。
试想一下，开发过程中，如果我们频繁的   分支，会有什么后果呢？
当你不断   的时候，其实你本地的  都变成了  ，再要和远端  分支保持一致，你的本地分支  记录已经不堪入目了。
另外要注意，绝不要在公共的分支上使用 ！！！
所以，为了安全，团队可以考虑采用 。
 ，方便
 不仅提供了代码托管以及代码开发的帮助，还提供了代码审核类似的功能。当我们在功能分支开发完成之后，可以发起一个   请求，选择需要对比的两个分支
它会创建一个  ，制定相关人员来对代码进行 。通常情况下，团队应该鼓励交叉 ，涉及到公共代码的时候，一定要让相关人 。
 ， 的生命周期
这个大多数人应该都，听说过，操作有它自身的生命周期，在不同的生命周期，我们可以做一些自动化的事情。
举两个简单的例子：✦ 的时候我们可以做 ✦ 的时候，我们可以做利用  类似的工具做持续集成
当然还有更多的声明周期，具体可以参考  钩子
    ，管理第三方模块
这两个命令通常用来管理公用的第三方模块。比如一些通用的底层逻辑、中间件、还有一些可能会频繁变化的通用业务组件。当然，两者还是有区别的。  主要用来管理一些单向更新的公共模块或底层逻辑。  对于部分需要双向更新的可复用逻辑来说，特别适合管理。比如一些需要复用的业务组件代码。在我之前的实践中，我也曾用来管理构建系统逻辑。
 ，简化  命令
我们可以通过配置   来简化需要输入的  命令。比如前文的   需要输入很长的  命令，我们可以配置  文件来解决。
    
    

     =    =   \
         
     =    =   \
             =  \
            =   \
         
总结说点啥？
该文首先介绍了  常规操作✦ 包括克隆代码、操作 、操作分支等。其实  常规操作的命令并不多，请看第一部分的简单总结。
其次介绍了  开发流程✦ 该部分主要介绍了两种主流的开发模式：比较轻量的 基于功能分支的开发流程 和适合复杂项目的  开发流程 ，两种模式各有使用的场景，对于常规使用，前者就已经足够了。
最后介绍了一些  实用技巧✦ 主要包括： 操作，压缩日志， 的注意事项，利用   做 ，利用   做一些自动化工作等。前言
【弱联网优化】作为海量之道系列课题的基础方法论之一，望文生义，想必定是卖弄移动网络信号不佳时如何优化的奇技淫巧。恭喜你，感觉靠谱，不过我们还想多聊一点其它话题。
移动互联网颠覆着我们的生活方式，这个每时每刻伴随着我们的网络到底有哪些特点，又是如何影响我们接入信息世界的体验呢。以下场景如似曾相识，敬请对号入座：
上班路上收到朋友分享的一张美女图片，缩略图目测衣服用料相当节俭，立马兴奋点开欲详细钻研，却发现怎么脱也脱不下来，不对，是“拖”不是“脱”，仰望苍天，欲哭无泪。
进电梯前收到女友一条消息：“你到底爱不爱我！”，当然马上回复“必须的必！”，电梯门关闭了，北风那个吹，菊花那个转，等到春暖梯开，满屏都是女友的问候“在吗！”、“这都要想那么久！”、“跟哪个聊天呢！”、“我生气了！”、“你是好人，再见！”，看着自己的回复刚刚发送成功，停在最后一行，整个互动信息一气呵成，都是眼泪。
和朋友聚餐，菜端上先拍照分享，再大快朵颐，明明坐在对面，偏偏还得用手机聊天，世界最远的距离，莫过于我们坐在一起，却只能用手指切磋。
有因有果，有道有术，不入虎穴焉得虎子，不扯了，进入正题。
 移动网络的特点
我们看到移动网络和移动互联网时代用户的行为有如下三个典型特点：
        移动状态网络信号不稳定，高时延、易抖动丢包、通道狭窄；
        移动状态网络接入类型和接入点变化频繁；
        移动状态用户使用高频化、碎片化、非流量敏感；
为什么？参考【图一 无线网络链路示意】，我们尝试从物理上追根溯源：

【图一 无线网络链路示意】
第一、直观印象是通讯链路长而复杂，从移动终端设备到应用服务器之间，相较有线互联网，要多经过基站、核心网、网关好消息是网关正在被依法取缔等环节，这就像送快递，中间环节越多就越慢，每个中转站的服务质量和服务效率不一，每次传递都要重新交接入库和分派调度，一不小心还能把包裹给弄丢了；
第二、这是个资源受限网络，移动设备接入基站空中信道数量非常有限，信道调度更是相当复杂，如何复杂就不展开了，莫文蔚那首歌词用在这里正合适：“我讲又讲不清，你听又听不懂”，最最重要的是分配的业务信道单元如果秒钟不传数据就会立马被释放回收，六亲不认童叟无欺；
第三、这个链条前端无线端是高时延除某些场景外、低带宽除某些场景外、易抖动的网络，无线各种制式网络带宽上限都比较低而传输时延比较大参见【表一 运营商移动信号制式带宽标准】，并且，没事就能丢个包裹玩玩，最最重要的是，距离基站的远近，把玩手机的角度、地下室的深度等等都能影响无线信号的质量，让包裹在空中飞一会，再飞一会。这些因素也造成了移动互联网网络质量稳定性差、接入变化频繁，与有线互联网对比更是天上人间的差别，从【图二 有线互联网和移动互联网网络质量差异】中可以有更直观的感受；

【图二 有线互联网和移动互联网网络质量差异】
【表一 运营商移动信号制式带宽标准】数据来自互联网各种百科，定性不定量，仅供参考；



移动运营商
通信标准
信号制式
备注




中国移动


属网络，基于，理论峰值速率 实际最高 ，图标“”，时延  ；


中国移动


属网络，基于，理论下行峰值速率 、上行峰值速率 ，图标“”，时延  ；


中国移动


属网络，理论下行峰值速率 、上行峰值速率 ，图标“”，时延；


中国移动


属网络，基于，包括和，理论下行峰值速率 、上行峰值速率 ，图标“”，时延；


中国移动


属网络，理论下行峰值 ，上行峰值 ，时延  ；


中国电信

 
属网络，基于，理论下行峰值速率、上行峰值速率 ，图标“”，时延  ；


中国电信


属网络，基于 ，理论峰值下行 、上行 ，图标“”，时延；


中国电信

  　
均属网络，理论下行峰值速率 ，上行峰值 速率，理论下行峰值速率 ，上行峰值速率 ，时延  ；


中国联通


属网络，基于，理论峰值 ，图标“”，时延  ；


中国联通


属网络，基于，理论下行峰值速率 、上行峰值速率 ，图标“”，时延  ；


中国联通


属网络，基于，包括和，理论下行峰值速率 、上行峰值速率 ，图标“”，时延；


中国联通

  
均属网络，理论下行峰值速率 ，上行峰值 速率，理论下行峰值速率 ，上行峰值速率 ，时延  ；




  
论峰值速率 ，时延  ；




  
理论峰值速率 ，时延  ；



【表一 运营商移动信号制式带宽标准】
第四、这是个局部封闭网络，空中信道接入后要做鉴权、计费等预处理，网络甚至还要做数据过滤后再转发，在业务数据有效流动前太多中间代理人求参与，效率可想而知。产品研发为什么又慢又乱，广大程序猿心里明镜似的；最最重要的是，不同运营商之间跨网传输既贵且慢又有诸多限制，聪明的运营商便也用上了缓存技术，催生了所谓网络“劫持”的现象。
如果我们再结合用户在移动状态下的基站之间，或者不同网络制式之间频繁的切换，情况就更加复杂了。
 移动网络为什么“慢”
我们在移动网络的特点介绍中，很容易的得到了三个关键字：“高时延”、“易抖动”、“通道窄”，这些物理上的约束确实限制了我们移动冲浪时的速度体验，那么，还有别的因素吗。
当然有，汗牛充栋、罄竹难书：
        解析，这个在有线互联网上司空见惯的服务，在移动互联网上变成了一种负担，一个往复最少，还别提遇到移动运营商故障时的尴尬；
        链路建立成本暨三次握手，在一个高时延易抖动的网络环境，并且大部分业务数据交互限于一个的往返，建链成本尤其显著；
        协议层慢启动、拥塞控制、超时重传等机制在移动网络下参数设定的不适宜；
        不好的产品需求规定或粗放的技术方案实现，使得不受控的大数据包、频繁的数据网络交互等，在移动网络侧链路上传输引起的负荷；
        不好的协议格式和数据结构设计，使得协议封装和解析计算耗时、耗内存、耗带宽，甚至协议格式臃肿冗余，使得网络传输效能低下；
        不好的缓存设计，使得数据的加载和渲染计算耗时、耗内存、耗带宽；
现在终于知道时间都去哪了，太浪费太奢侈，还让不让人愉快的玩手机了。天下武功，唯快不破，我们一起踏上“快”的探索之路吧。
 移动联网快的四个方法
在移动互联网时代，对我们的产品和技术追求提出了更高的挑战，如何从容和优雅的面对，需要先从精神上做好充分的准备，用一套统一的思考和行动准则武装到牙齿：
        不要我等，一秒响应；
        可用胜于完美；
        水到渠成，润物无声；
听起来很抽象，也不着急解释罗老师说：除了亲人和法院，其它人误会，都懒得解释，耐心看完整篇文章再来回味，定有醍醐灌顶，昏昏欲睡之功效。
从来就没有什么救世主，只有程序猿征服一切技术问题的梦想在空中飘荡。屡败屡战，把过往实践中的经验教训总结出来，共同研讨。针对移动网络的特点，我们提出了四个方法来追求极致的“爽快”：快链路、轻往复、强监控、多异步。
下面逐一展开研讨。
接海量之道系列文章之弱联网优化 二这是【 开源项目贡献指南】系列第十章，原文【  ——     】

了解开源的法律含义
向世界分享你们具有创造性的工作，这是一个多么令人激动和有价值的经历。这也意味着你们必须担心一堆你们不清楚的法律问题。幸运的是，你们不必从头开始。我们已经涵盖了你们的法律需求。在你们行动前，请确定阅读了我们的免责声明。
为什么大家非常担心有关开源的法律问题？
很高兴你们提问！当你们进行创造性工作例如写作，图形或代码时，默认情况下该作品属于专有版权。也就是说，法律承认你们是你们作品的作者，他人在没有经得你们同意的情况下不能使用你们的工作。
一般来说，这意味着没有人可以在没有你们授权的情况下使用，复制，分发或者修改你们的工作。
然而，开源有着不一样的情况。因为作者希望他人使用，修改以及分享他们的工作。但因为法律默认依然是专有版权，所以你们需要一个明确说明这些权限的协议。
如果你们不应用开源许可协议，那么对你们项目做出贡献的人也都将成为其工作的专属版权所有者。这意味着没有人也包括你们可以使用，复制，分发后者修改他们的贡献。
最后，你们的项目可能具有你们不知道的许可证要求的依赖关系。你们的项目社区，或者你们的雇主法务也可能要求你们使用特定的开源许可协议。
公开的项目是开源的吗？
当你们在上创建一个新项目 时，你们可以选择将仓库设置成或者。

让你们的项目公开与许可你们的项目是不同的。公开项目是由的服务条款保护，它允许他人浏览以及你们的项目，但是没有权限参与你们的工作。
如果你们想让他人使用，复制，修改你们的项目，或者参与贡献你们的项目，那么你们的项目就需要包含一个开源许可协议。例如，即使你们的项目是公开的，但没有你们的授权，人们是不能合法在他们的代码中使用你们项目中的任何部分。
请告诉我该如何保护项目
你们很幸运，开源许可协议已经标准化了同时使用简单。你们可以直接复制粘贴一个已经存在的许可协议到你们的项目里。
 ， 和都是非常流行的开源许可协议，但是也有其它选择。你们可以在上找到这些许可协议的全部文本，同时说明了如何使用他们。
当你们在上创建了一个新项目，你们会被要求添加一个许可协议。

一个标准化的许可协议可以作为没有法律培训的人员的代理，以准确地知道他们可以和不能用软件做什么。除非绝对要求，否则应避免使用定制，修改或非标准术语，这将成为他人使用代码的障碍。
—  “           ”

哪个开源许可协议适合我的项目？
如果你们是小白，那么使用 ，不容易出错。它很短，很容易理解，并允许任何人做任何事情，只要他们保留许可证的副本，包括你们的版权声明。如果你们需要，您们能够根据不同的许可协议发布项目。
然而，为项目选择合适的开源许可协议这取决于你们。
你们的项目非常可能有或将有依赖。例如，如果你们开源了一个的项目，你们将可能使用来自  的库。你们依赖的这些库都有它们自己的开源许可协议。如果他们的许可协议“允许”对使用，修改和分享给予公共权限，而对有关项目的许可协议没有要求，这样你们就可以使用任何你们想要的许可协议。共同允许许可协议包括， ，和。
另一方面，如果你们的依赖中有一个的许可协议是“强硬的”他们也给同样的允许，但条件是有关项目得使用同样的许可协议，那么你们的项目将使用与之相同的许可协议。许可协议包括，和。
你们也会想到考虑希望你们的社区使用以及贡献你们的项目：

你们是否想让你们的项目成为其它项目的依赖？在你们的相关社区最好尽可能使用最流行的许可协议。例如，是 使用的最流行的许可协议。


你们的项目是否想吸引大企业？大型企业可能需要所有贡献者的明确专利许可。在这种情况下， 适合你们。

你们的项目是否想吸引不愿自己的贡献用于其它同类型软件的贡献者？和适合你们。


你们的公司可能为自己的项目准备了特定的许可协议。例如，它可能需要许可许可证，以便公司可以在公司的闭源产品中使用你们的项目。或者你们的公司要求强大的许可协议同时要求贡献者赞成，这样项目只属于你们公司，没有人能在有关的软件中使用你们的项目。或者你们的公司可能有与标准，社会责任或透明度相关的某些需求，其中任何一个都可能需要特定的许可策略。与你们公司的法律部门谈谈。
当你们在上创建了一个新项目，它给你们提供了选择许可协议的机会。包括上面提到的可以使你们的项目开源的许可协议。如果你们想要了解其他选择，可以通过查阅找到适合你们项目即使它不是软件的许可协议。
如果我想更换项目的许可协议，该怎么办？
大多数项目绝不需要更换许可协议。但是情况偶尔有变。
例如，随着你们项目的壮大，它添加了新的依赖或用户，或者你们的公司改变了策略，或者其他的要求要更换不同的许可协议。如果你们在开始项目的时候没有添加许可协议，那么再添加一个许可协议和更换许可协议是一样的效果。当你们要添加或者更换项目的许可协议时，需要考虑以下三件事：
这件事很复杂。确定许可协议的兼容性和合规性，以及谁拥有版权，这会变得复杂和混乱。为新的发布和贡献选择一个新的且合适的许可协议与重新许可已存在的贡献是不同的。一旦你们有任何想改变许可协议的想法，请首先让法律团队知道。即使你们已经或者能获得可以更换许可协议的权限，请考虑者会给项目的其他用户和贡献者带来怎样的影响。将更换许可协议视为“管理事件”，只有通过与项目的利益相关者进行明确的沟通和咨询，才更有可能顺利进行。请谨记，从一开始就为你们的选择和使用合适的许可协议。
你们的项目已经有了许可协议。如果项目的现有许可证与您要更改的许可证兼容，则可以开始使用新许可证。这是因为如果许可协议与许可协议兼容，你们将遵守的条款，同时遵守的条款但不一定反之亦然。因此，如果你们目前正在使用许可型的许可协议例如，则可以更改为具有更多条件的许可协议，只要你们保留许可协议的副本和任何相关的版权声明即继续遵守许可协议的最低条件。如果你们现在的许可协议不是许可型的例如，或者你们还没有许可协议以及你们不是版权的唯一所有者，那么你们不能将许可协议改为。基本上，只要是使用的许可型的许可协议，版权所有者能事先更换许可协议。
你们的项目已经有版权所有者。如果你们是你们项目的唯一贡献者，然后你们或者你们的公司是项目版权的唯一所有者。你们可以添加或更换任何你们或者你们公司心仪的许可协议。不然你们需要取得其他版权所有者的同意。他们是谁？他们是已经参与你们项目提交的人。但有些情况是项目版权掌握在这些人的雇主手中。在某些情况下，人们只是做了微小的贡献，但没有硬性规定，在一些行代码下的贡献不受版权保护。对与这样的情况该怎么办？对于一个相对较小以及年轻的项目来说，取得所有贡献者对更换许可协议的同意是可行的。。但对于大项目和老项目来说，你们必须寻求很多贡献者以及他们继承者的共识。花费了多年重新授权，和相关软件。
或者，你们可以让贡献者事先同意通过额外的贡献者协议  见下文在某些条件下更改某些许可协议，这些更改将超过现有的开源许可协议。这会改变许可协议改的复杂性。如果在执行许可协议更改时，你们仍然想要和项目利益相关者进行沟通，你们需要从你们律师那得到更多帮助。
我的项目需要额外的贡献者协议吗？
可能不要。对于大多数的开源项目，一个开源许可协议可作用于所有贡献者和用户。
贡献者协议会给维护者带来额外的管理工作。这些协议增加了多少工作得取决去项目和实施。简单的协议可能要求贡献者确认和点击，在项目的开源许可协议下他们有权利贡献。更复杂的协议可能需要法律的审查和贡献者的雇主的签字。
此外，贡献者协议有时被认为对项目社区不友好。他们也增加了人们参与社区的障碍。

我们已经删除了的。这样做降低了贡献者的参与门槛，从而吸引更多的贡献者。—  “  ”

一些情况下你们可能想要为你们的项目考虑一个额外的贡献协议：

你们的律师想要所有的贡献者明确接受贡献者条款，或者因为他们觉得只有开源许可协议还远远不够。如果这是唯一的问题，那么有肯定项目开源许可协议的贡献者协议就足够了。个人贡献者许可协议就是一个很好的轻量级的个人贡献者协议。对于一些项目来说，   是一个很好的先择。

你们的项目使用的开放源许可协议不包括明确的专利授权如，你们需要所有贡献者的专利授权，这些可能适合用于你们公司的专利组合或者项目的其他贡献者和用户。 个人贡献者许可协议是一种常用的附加贡献者协议，其具有与许可中的专利许可相同的专利许可。

如果你们的项目使用的是许可协议，但你们也需要分发项目的专有版本。那你们需要每个贡献者分配版权给你们或者授予你们许可权。贡献者协议就是这中类型的。

你们认为你们的项目在其有效期内需要更换许可协议，以及事先得到贡献者的同意。


如果实在需要在您的项目中使用额外的贡献者协议，请考虑使用诸如助手之类的集成，以最大限度地减少贡献者的分心。
我的公司的法律团队需要知道什么？
作为一名公司的雇员，如果你们在发布一个开源项目，你们首先需要让法律团队知道。
即使只是一个个人项目，请考虑让他们知道。你们可能和公司有一个“员工知识产权协议”，这给了公司一些对你们项目的控制权，特别是当项目和公司的业务有着很多的联系或者你们使用公司的资源发展项目。你们的公司应该很容易给许可，也许已经通过一个员工友好的知识产权协议或公司政策。如果不是这样，你们可以谈判例如，解释你们的项目为公司的专业学习和发展目标服务，或者你们在找到一个更好的公司前停止你们项目的工作。
如果你们的开源项目是为了你们的公司，绝对需要让他们知道。根据公司的业务需求和专业知识，你们的法律团队可能已经制定了有关开放源代码许可协议以及可能还有其他贡献者协议的政策，以确保您的项目符合其依赖关系的许可协议。如果不是这样，你们的法律团队应该渴望与你们合作，把这个东西搞清楚。你们需要思考这些事：

第三方资源：你们的项目有其他人创建的依赖或者使用他人的代码？如果这些是开源项目，你们需要遵守第三方资源的开源许可协议。首先，选择与第三方资源的开放源许可协议一起使用的许可协议见上文。如果你们的项目修改或者发布第三方开源资源，那么你们法律团队还想知道你们符合第三方开源许可协议的其他条件，例如保留版权声明。如果你们使用了其他没有开源许可协议的代码，那么你们可能会要求第三方资源的维护者添加一个开源许可协议，要是你们得不到许可，你们只能停止使用他们的代码。

商业机密：请考虑项目中是否有公司不想对外公开的东西。如果是这样的话，你们只能开源项目的一部分，得保护好公司的商业机密。

专利：你们公司是否申请了与你们项目有关的专利？如果开源源代码，这会对公司的专利进行公开披露。可悲的是，你们可能被要求等待或者公司会重新思考应用程序。如果你们期望从拥有大量专利组合的公司的员工那里得到贡献，们的法律团队可能希望你们使用来自贡献者的明确专利授权的许可协议例如 或或其他贡献者协议见上文。

商标：认真检查你们的项目名没有与已经存在的商标冲突。如果你们将自己公司的商标用于项目，请检查它有没有造成冲突。是在自由和开源项目的背景下理解商标的实用指南。

隐私：你们的项目是否收集了用户数据并存储到公司的服务器？你们的法律团队可以帮助你们遵守公司政策和外部法规。


如果你们发布了公司的第一开源项目，为了能通过，以上这些绰绰有余不要担心，大多数项目不会引起重大关注。
长期来说，你们的法律团队可以做更多的事情，以帮助公司从开源中获得更多，并保持安全：

员工贡献策略：考虑制定一个公司策略，指明你们的员工如何为开源项目贡献。明确的政策将减少你们员工的迷惑，并帮助他们为公司的最佳利益向开源项目做贡献，无论是作为他们工作的一部分还是在自由时间。的 和开源贡献策略就是很好的示例。


放弃与补丁相关的只是产权以构建员工知识库和信誉。它表明，公司关心员工的发展，以及让员工有种被赋权和自主的感觉。所有这些好处还导致更高的士气和更好地保留员工。
—  “       ”


发布什么：如果你们的法律团队了解并支持你们公司的开源策略，他们将是你们最好的帮助，而不是阻碍你们的努力。

合规性：即使你们公司没有发布任何开源项目，他们也会使用别人的开源软件。提早意识这个过程可以避免麻烦，产品延迟发布和诉讼。


当你们在上创建了一个新项目，你们会被要求添加一个许可协议。

组织必须具有适合“允许”和“”类别的许可协议和合规性策略。首先，记录适用于你们所使用的开源软件的许可条款包括子组件和依赖项。
—   “       ”


专利：你们的公司可能希望加入开放发明网络，一个共享的专利防御池，以保护成员使用主要开源项目，或探索其他替代专利许可。

管理：特别是当如果将项目转移到公司以外的法律实体是有意义的。孙云清，年加入腾讯，一直负责图片存储服务的研发。专注于图片云计算领域，专注于用户需求，从图片存储到下载加速，图片处理到违禁图审核，数据降冷到冷热流量调度，打造一站式图片服务平台。

图片是互联网的重要元素之一，各应用各网站基本上都离不开它，以图片作为关键场景的产品一直层出不穷。腾讯架构平台部希望为用户提供快速便捷且功能强大的图片服务，一直专注于图片云计算领域，专注于用户需求，打造了图片存储服务平台。十年海量请求的技术锤炼，从基础服务到业务深度合作，从基础架构到精细化运营，我们一直在路上。目前公司内已接入的业务场景近千个，公司外接入腾讯图片云的上万个，每日上传图片数几十亿级，累计存储量百级，文件数万亿级。
一、服务为王
平台服务。图片平台以稳定可靠的图片存储及加速下载为基础，配套以强大的图片处理、自动化的违禁图审核功能，并针对业务模型做冷热流量调度、存储数据降冷等一系列成本体验优化，为图片客户提供了一套完整的解决方案。其中强大的图片处理功能涵盖了各类应用场景，有图片缩放、裁剪、旋转，图片水印，格式转换，信息获取等。鉴于图片丰富的表现力让违禁图十分活跃，图片平台联合信息安全部建立了上传即可触发的自动审核及禁图流程，业务无需参与即可轻松享有。
服务可靠性。背靠部门强大的存储系统，通过底层的多设备多份存储保证了可靠性，数据安全性达到个，服务可用率达到个。下载结合使用，有效降低了时延，全国遍布的加速节点，节点间互相容灾，保障了下载可用性。同时通过源站上传下载接入层的调度，实现了源站数据和服务的间容灾。
业务场景可靠性。针对不同场景，图片平台拥有多种自适应能力，保障服务稳定。高频访问更新的头像场景，有热排队、防空及防热策略，全网节点缓存快速更新及时间戳校验机制。重图片质量的电商场景，支持大图处理，并有大图专用处理池保证效率，配有锐化等图片处理手段提升商品图视觉体验。体量庞大的社交分享场景，支持数据多地分布，园区调度。重要节日及重大事件下的高突发，可通过高性能写缓冲层挡住压力，再缓慢落地底层。面对图片处理万台级设备的扩张需求，年开始使用架构平台部的弹性计算服务，通过调度部门内设备的剩余资源，化来建设图片处理的弹性大集群，简化了运营工作，同时让突发的图片处理请求无需人工干预也能平稳度过。
二、成本和体验并行
除了提供稳定可靠的服务，图片平台还在成本和体验优化上持续深耕细作，不断开花结果。
上传下载加速。上传和下载的多节点就近接入大幅降低了用户延时，流量调度带来了成本和体验的双丰收，下载节点的协议栈优化也继续提升了下载体验。其中上传就近接入，常规的按请求力度，对于存储多园区有状态分布的业务来说，专线带宽的消耗会很显眼。像相册业务，索引量很大是多地分布的，做到多地完全备份太耗费成本，同时为方便单个用户的拉列表操作，所以异地容灾未触发时，单个用户的索引会全部在特定的一个园区里。假设某广东用户，就近连接到深圳接入点，但索引却在上海，那就需要深圳接入点通过内网专线将请求转去上海点。为了在体验提升基础上，也把成本做到极致，图片平台实现了索引和数据分离的就近上传方案，轻重分离，各自路由。无园区归属限制的较大的图片数据落到本园区，很小的索引数据根据实际分布落到所属园区。从而最大程度减免了专线带宽消耗。方案落地空间相册后为业务节省了上百毫秒的延时及数十的专线带宽。
数据降冷存储。为保证数据安全性，底层采取三份存储策略。鉴于大部分数据有访问频率随时间推移越来越低的特性，即数据越来越“冷”。让冷数据通过牺牲访问性能来换取存储成本的纠删码便在存储领域活跃起来。我们选用的架构平台部存储系统的的纠删码结构，相比三份存储可靠性相当，存储成本节省了一半以上。图片平台每个业务独立且详细的运营数据为各业务制定降冷计划提供了依据，根据被访问数据的创建时间分布，来生成降冷的时间和资源的关联模型。同时根据业务特性，降冷过程中，套图内部分尺寸可被缩减，进一步节省空间。

图片大小的持续压榨。不同等级质量业务可选，满足不同需求。并在原格式基础上持续挖掘，去除图片元信息，绛色处理及相同帧合并等，小细节也能省出大流量。为了同等尺寸及同级视觉效果下让图片更小一点，时刻关注业界最新技术，先后引入了、图片格式， 图片可比节省到，又比节省近，在上的节省更为可观，可节省。经过上述不断优化，图片大小保持在行业内优势明显。

三、深入业务
业务的图片存储和处理需求可能是相同的，但业务场景特性差异很大。结合业务特点，深入业务的深度合作，可以让成本和体验优化走的更远更好。
冷热流量调度。统一的全域名下载加速是通用的加速手段，但业务的不同场景的访问特点可以差别很大，可能存在有更优的调度策略。比如社交网络分享类业务，普遍热点和时间关系紧密，访问集中于最近几天尤其密集于最近一天上传的图片。针对朋友圈图片的分析结果是，三天前的数据命中率急剧下降，太低，这部分数据放在节点影响节点命中率，放大了业务总带宽成本，有必要把它分离出来。通过直通车调度，三天内的热数据下载调度去节点，三天外的热数据下载调度去源站，现实冷热分离。这样的冷热调度可以让业务分布点命中率从提升到。提升了冷数据的访问延时也节省了总带宽成本。
像素的纷争。平台为业务提供各尺寸访问的详细运营数据，分析各尺寸访问分布及对应引用页面，以此参考来调整业务使用方式或尺寸处理方式。不浪费一点不必要的像素，合适的时机采取必要的柔性，根据成本选择尺寸落地还是下载时实时处理，低碳服务，环保运营。分别在微信公众号实施了过大尺寸合理降级，在聊天图片上实施了高峰期大图代替原图，在相册实施了尺寸落地存储改为下载时从大图实时压缩出等，通过以上种种业务精细化运营手段，为业务节省了百级带宽，几十级存储成本。
四、技术突破和创新
 图像编解码的应用。和可以显著节省带宽，但它们的缺点也很明显，压缩计算复杂度是的倍以上。使用进行编码工作，耗费资源很大，带宽成本降低了，但图片处理成本上去了，成本优化便打了折扣。基于先后开发了高吞吐量的和图片压缩功能，从系统功能划分、系统流水线设计、逻辑主频提升综合考虑，实现了单台服务器的转码性能提高到普通图片处理实体机的倍，编码延时减少了，减少了用户等待延时。
渐进式图片传输。在常规做法纷纷落地之后，仍可另辟蹊径，利用的压缩模式，设计了上传和下载双路流式传输系统，传输最低要求数据即可响应用户成功，减少等待时间，并在网络状况差时，可丢弃部分不重要细节，换取传图功能可用性。带来了上传延时的提升，及失败率的下降比例。
 图片智能调整质量。通常一个业务会选择一个统一的图片质量因子，然而人眼对不同图片的质量因子敏感度及关注度是不同的。图片平台引入图片内容识别，并制定了一套策略，根据主题内容来给图片定合适的质量因子。比如，主题是人脸的图片需要保持较高质量因子，二维码和大文字等图片则相当比例可以把质量因子降的很低，也不影响阅读和使用。通过如此种种策略，不影响用户体验却缩减了图片大小。下图是一个质量因子从下降到的二维码主题图片。

 未来，仍需继续前行，为业务提供更优质的服务，助力业务更好发展。架构平台部的图片平台将持续在存储、下载及处理上投入，通过应用系统的冷存储技术持续降低存储成本，通过合理流量调度扩大流量占比降低回源流量，通过图片格式研究继续稳定图片大小的行业优势，通过、等手段进一步提升图片处理在各类请求上的处理延时及成功率，树立业界标杆。

文章来源公众号：腾讯架构师背景
随着、微软  和苹果  陆续宣布停止支持 ， 公司也正式宣布将在年年底停止对  的支持，这就使得国内大多数使用  来支撑音视频等业务的公司面临着巨大的技术变革的考验。然而，在  端技术不断向前发展，等标准逐渐成熟的大环境下，端开发者抛弃  来构建交互性更复杂的应用不再是一件困难的事情，反而会变得更加简单。
业务场景
目前，团队主要专注于直播、点播等视频相关的  业务上，客户端通过集成 ，能够获得更流畅播放体验并显著降低分发成本，适用于互动直播、电视内容直播、赛事直播、在线视频、短视频等业务场景。支持  等系统平台，支持  等架构。对于  来说，团队要做的是应用将已下载的音视频分片数据推送给订阅了该分片的对端用户，意在不影响用户播放体验的同时降低的成本，同时拉开与竞品之间的距离，增大业务在价格方面的优势。
接下来，本文将从实战的角度来介绍如何使用 标准中 相关  来实现  功能。

  是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点的连接，实现视频流和或音频流或者其他任意数据的传输。 包含的这些标准使用户在无需安装任何插件或者第三方软件的情况下，创建点对点的数据分享和电话会议成为可能。
纵观建立连接的过程主要是以下几步：
     连接双方交换 ，会话描述协议，用于描述“会话状态”，包含一系列的连接属性：要交换的媒体类型音频、视频及应用数据、网络传输协议、使用的编解码器及其设置、带宽及其他元数据；
     内置了 框架，负责候选项发现、连接检查、持久化等等，这部分工作对开发者是不可见的：开发者需要做的只是在初始化  对象时指定 和  服务器；
     若连接成功，最后就是  之间的数据分享过程了。
上述过程基本上就是进行实时通信需要经历的过程，整个过程说起来很简单，但实际上端与端之间通常存在有很多层的防火墙和  设备阻隔着，需要经过一系列繁琐的信令交换，网络地址转换、打洞等过程。幸运的是，除了信令交换之外，其余的工作都已经帮我们实现好了，开发者可以将绝大多数的精力放在主要的业务逻辑上。
信令通道和会话协商
在建立连接和会话协商之前，我们需要一个信令或信号通道来交换信息，不幸的是， 并没有为我们实现这部分的工作，而是将发送信号和协议的选择交给应用，无论是通过 、还是其他任意的传递方式，只要能顺利到达对端即可。
 
在拥有了信令通道之后，就是会话协商的过程了，这个过程中交换的是会话描述协议信息，即  信息。当用户向对端用户发起  连接时，将创建一个称为提议的会话描述信息，该描述信息包含用户之间“对话”的配置信息，这有点像是在告诉对端用户：我将要去你家坐坐，你是不是得准备点茶点招待我啊？在对端用户收到提议方的会话描述信息后，将会回复一个应答的会话描述信息，告诉发起对话方：茶点准备好了，恭候您的大驾光临！
下述是具体的提议和应答交换过程，如有  和  两个用户：
      调用  创建一个提议描述 ；
      调用  设置得到的 信息；
      通过信令通道将 信息发送给 ；
      收到  的描述信息后调用 记录对端用户的会话描述信息；
      调用 创建一个应答描述 ；
      调用 设置得到的  信息；
      通过信令通道将 信息发送给 ；
      收到 的描述信息后调用 记录对端用户的会话描述信息；
  
得到了对端用户的邀请确认后，双方此时就需要交换一下双方住址了，为了尽可能避免对方走错路错过了茶点最佳的品尝时间，双方都开始收集自己的详细地址信息，详细到走路怎么走，骑单车怎么走，打车又是怎么走，不得已时可能约上一个大家都熟知的地方相见。回到实际编码中来，要顺利的建立端到端的连接，两端之间必须能收发数据包，但通常端与端之间存在有很多层的防火墙和  设备阻隔着，需要经过一系列繁琐的网络地址转换、打洞等过程，总结来说这是一个寻找连接通道的过程，幸运的是， 已经代替我们完成了这部分的工作。当需要连接的两端设置好本地和远端的会话描述后，本地  代理就会自动开始发现本地端所有可能的候选  和端口的过程： 
     查询本地内网的  地址；
      代理向  服务器查询，本地的外网  和端口号；
     如果端到端连接失败，数据将通过  服务器转发数据。
 代理每发现一个新候选项就会自动回调 事件通知应用。此时，通过信令通道将该候选项  发送给对端 ，对端收到该候选项后则通过调用  来增加端与端之间连接的通道方式，反之亦然。值得称赞的是，连接成功建立之后并不代表  代理的工作已经结束了，实际上此时  代理会继续收集本地候选项，意在找到一个更稳定的连接路径，这个过程对我们是不可见的。下图  代理的工作流程：

应用数据通道
实际上  并不单单仅限于  之间分享音视频流，也支持任意应用数据交换，，，，等，而这仅仅只需要以下几步即可：
     实例化一个  对象；
     调用 ，实际上这一步只需在发起对话方创建即可；
     接下来就是一系列的提议、应答和候选项通过信令通道交换的过程；
     最终建立连接成功后，对端  会收到触发 的事件回调，其中事件中的  就是  间的数据通道，此时对话两端就可以通过这个“通道”来分享数据了。
初见  与  基本上是类似的，都支持 、、、 事件回调，但两者之间仍然有一些区别， 是在  的基础上构建的可靠有序的消息交付，而  是基于  的，当然也可以通过配置来指定是否有序和可靠性，提供了更多的灵活性配置，可自行搜索相关文章来了解。
现有  库
前文花了较多的篇幅来介绍  在建立端对端连接的相关过程，虽然没有贴出相关的代码，但相信大家在有了建连过程的基础后再自行搜索相关代码来看，会有事半功倍的效果！实际上，市面上已经有多家公司或组织已经封装了各自的  库，目前了解到的有：、、、等。
本文出现的初衷也正是为了了解这些库在实现  功能上有无独到之处，通过前文的描述我们知道， 的核心要求就在于穿透  设备，只有穿越了它才能真正建立起端对端的连接，目前  设备有两种类型：对称型和锥型，而  需要的是锥型 。从这些库对穿透这块的代码上来看并没有什么与众不同之处，更多的是在  无法穿透时配置了  来中转数据。但是十分幸运的是，根据  提供的穿透数据来看：

的时间可以直接连接

的时间要使用中继器


在调研过程过程，也发现了一些比较有趣的网站，是基于  实现的在线视频通话和在线文字聊天 ，有兴趣的可以在浏览器中打开一下的网站：

在线视频通话：

在线文字聊天：


总结
在写这篇文章前花了一个星期来学习相关的知识包括：  、、信令服务、 服务器、 服务器等，但由于这部分的技术不是临时抱佛脚就能了解透彻的，是一个持续学习深入了解的过程。有点遗憾的是没在本文中介绍  的相关知识，实际上这部分内容可以单独拎出来讲解，等有空了再写一篇关于  的文章吧。
随着  前端标准越来越成熟，浏览器能做到的东西越来越多，也许会逐渐替代客户端，这不得不说这很符合互联网的特点，相信有一天会出现一个标准，我们不再需要手机，不再需要安装软件，不再需要各种类型账号，实际上我们自身就是一个特定的 ，将来所有的交互都是基于这个  来提供不同的个性服务，无论我们走到哪都能得到所需的服务。想想都是满满的期待啊！最近遇到一个需求
应用层往中间件发送信息的时候，经常出现莫名奇妙的异常，为了定位该中间件发送客户端的，需要抓取异常瞬间的系统运行参数  和 等

当发生异常时已经将发送失败的信息打印到了日志文件中。
异常不定期的发生。

针对这个问题，手动的跟踪肯定不现实。因此，需要通过脚本监控日志文件的变化，且在变化的瞬间捕获系统运行参数。

系统参数

 
    

的文件监控工具 
提供的两个命令行工具：
：通过 等待被监控文件上的相应事件并返回监控结果，默认情况下，正常的结果返回至标准输出，诊断类的信息则返回至标准错误输出。它可以在监控到对应监控对象上指定的事件后退出，也可以进行持续性的监控。
：通过 收集被监控文件或目录的相关事件并输出统计信息。
在此次需求中，需要使用
命令使用简介：
尤其适用于在脚本中等待某事件的发生，并可基于特定的事件执行相应操作。如将其用于脚本中监控某指定目录中的文件上的修改、新建、删除、属性信息的改变，而后使用命令将某事件对应的文件同步至其它主机上。其常用选项如下：
 ：的默认动作是在监控至指定文件的特定事件发生一次后就退出了，而使用此选项则可实现持续性的监控；
 ：递归监控指定目录下的所有文件，包括新建的文件或子目录；如果要监控的目录中文件数量巨大，则通常需要修改__内核参数，因为其默认值为。
   ：指定要监控的特定事件，默认是监控所有的事件；此处包括   _ _   _ _    _等；
 ：当在选项中使用时，选项则可以用来指定自定义的符合规范的时间格式，此时间格式可用的格式符可以通过的手册页获取；后常用的参数是 ；
 ：自定义的输出格式，如   ；常用的格式符如下：
：显示被监控文件的文件名；
：如果发生某事件的对象是目录，则显示被监控目录的名字；默认显示为空串；
：使用选项中自定义的时间格式；
例如，要监控目录及其内部所有文件上发生的_事件，则使用如下命令：
          _ 

此命令在监控到某文件上第一次事件后就会退出，如果想一直监控，则需要为命令添加选项。
更详细的使用介绍 系统监控工具 关于原理 基于机制的实时文件监控
安装
 =   

编写脚本并运行
 编写脚本

=
    
=  |   |    |  { } 
 
 
    
 
      
      
     
 == 
  



文件一旦变化，打印 和 
  需要先获取  的 

如果需要循环监听文件变化 可以给添加参数 并通过管道添加循环

 =    
     
 =  |   |    |  { } 
  

 
   _    |   

             
     == 


保存成脚本文件 
 上传到服务器
 

将命令符修改为 可选  由于使用的是系统，需要将文件转码
 

 添加可执行权限
  

 运行
   

参考文献


用法简介及以之结合实现主机间的文件实时同步

 高效、实时的文件系统事件监控框架