作者：

最近一直在做有关内存方面的优化工作，在做优化的过程，除了关注内存的申请量以及的情况之外，我们经常需要想方法找出是那些对象占用了大量内存，以及他们是如何导致的，这意味着我们需要获取对象申请的信息大小，类型，堆栈等，我们这篇文章来介绍下几种获取对象申请信息的方法。
 
 是 自带的一个功能，我们可以在中打开使用：

如上图，点击红框按钮，然后操作，开始 ，当认为需要结束的时候，再次点击按钮，稍等片刻，即可以在 中出在 这段时间 内 新申请 对象的信息：

这种使用方式相当直观，可以看到申请对象大小，数量，还有堆栈等，通过这些信息，我们可以作为我们接下来进行内存优化的参考
但是，对于这种获取申请对象信息的方法，会存在几个问题：
、获取的信息过于分散，中间夹杂着不少其他的信息，不完全是申请的，可能需要进行不少查找才能定位到具体的问题；、跟一样，无法做到自动化分析，每次都需要开发者手工开始结束，对于某些问题的分析可能会造成不便，而且对于批量分析来说也比较困难；、虽然在 的时候，不会对手机本身的运行造成过多的性能影响，然而在停止 的时候，直到把数据出来之前，会把手机完全卡死，时间过长甚至会直接。
对于这几个问题，特别是自动化分析来说，是否能够直接在代码上发起 的请求并获得数据来分析呢？
在代码中发起 请求
自然是可以的，不然为什么会有这个标题。。。
我们可以把 的源码下来，在 中可以找到对应的地址。在下来之后，我们可以在中看到 具体是如何发起和停止 的：
发起和停止：

获取并解析数据：

可以看出来这应该是一个异步的过程，在发起请求之后，系统会开始记录，然后再次发起停止请求之后，请求获得内存申请的数据通过这一行，然后再预先注册好的回调当中，获得数据已经准备好的通知，然后再获取数据，进行分析
对于这里发起和停止的数据，以及注册的回调，大概涉及到了，，等几个接口，这几个接口均不是 中自带的类，而是在这个库中包含的，在 源码目录中有其源码，另外，在目录中也有其预先好的包。
这个库的作用，是用来建立电脑和手机上连接的，然后让其对手机发起一些请求，例如刚才的，还有 ，，甚至可以直接发送，自定义和手机上的通讯当然这个接口并非是开放的。
更重要的是，这个库是对外开放的，并且放到了当中，可以让开发者直接获取到这个库，不过似乎并没有大肆宣传这个，甚至连文档都没有。
既然如此，我们也可以仿照上面的代码，用代码发起一次请求，并进行分析：

代码比较长，我们主要做了这些操作：
、初始化，并获取连接上的第一个设备对应的；、获取这个设备上这个进程上对应的实例；、注册回调，并在回调中获取回来的数据，并调用进行解析；、发起和停止 。
最后在分析的时候，我们获得了一组，存储了申请对象的信息：

因为现在可以用代码发起 请求了，那我们就可以接入自动化分析，并过滤掉我们不需要的数据。
但是这样，也还是会有问题：
、这种方法会占用端口，这意味着可能在使用的时候，需要停止掉其他地方对的使用；、在停止 之后，的调用还是会卡死手机，当然其实对于自动化分析来说，这里问题应该不大，但是对于使用者来说，还是造成了些许不爽。
对于上面的第二个问题，我们先来分析下上的是如何响应发过来的 请求的
 的  如何响应   请求  
我们先来看下虚拟机是怎么响应这个请求的，下面仅以的代码为例
首先，虚拟机在收到 的请求之后，在对包进行解析之后，最后会在这个类中进行处理，这个类在当中，其中有这么两个方法：

很明显，这两个方法是用于开启和关闭 ，并且获得申请对象信息的数据的，然而是的方法，对应的代码在_____这里：

而，，这几个方法，经过几层的调用之后，最后是调用到了这里的方法：

从上面的代码可以看出，在开启了 之后，在全局变量下，将其中的指向了一块新的申请的内存区域，另外指向最新申请的对象信息的，则是总的记录的数量，另外则是整个 所允许记录的最大申请对象信息的数目，在这个版本下，这个值默认是，也可以在手机中的中指定项的值。这里很明显看出来，是用来记录新申请对象的信息的，而申请对象的时候，只要开启了 ，每次都会往这里添加一个记录，具体代码在这里：
首先这里是新申请对象地方，在中：

而在方法，则是在中定义：

分析到这里，对 的响应过程就非常清晰了：
、在收到 的请求的时候，首先给全局变量中的字段指向一段新申请的内存，申请内存的大小，由指定；、后续每次新申请对象的时候，只要不为，那就会不断的往指向的内存区域中写入的新申请对象的信息，包括类型，大小，线程号，堆栈。
而这个变量则具体是一个全局记录虚拟机中状态的全局变量，定义和声明都在中：

而的定义，则是在 中：

可以看出来这里拿到的信息，跟直接使用的是一样的
另外，可以看到的声明是为的，这意味着我们或许可以 直接 获取到这个变量，一颗赛艇！
不影响手机本身性能的情况下获取申请对象信息
从上面的代码分析可以看到，类型为的这个变量被声明成了，并且为非变量，这意味在的中，我们可以直接在符号表中获取到这个变量，简单来说，测试的代码如下：

上面的 是指源码中的头文件， 另外这段的代码需要打包在某个当中，然后在开启 之后之前介绍的随便一种方法都可以，运行这段代码，那么_中就是申请对象的数据了，可以直接读取里面的字段，打印出来大概是这样的：

由于是直接读取本身记录对象信息的结构，没有了结束 时候把数据出来的请求，这意味着完全不会影响手机本身的性能，而且对于对象信息的获取，也能够更加的及时，例如说每隔把数据拿出来分析。相对来说，对于之前使用的方案，定时请求这么高的频率，很有可能跑一会直接就把手机卡死了。
但是对于这种方案，会存在兼容性问题，这里可以看到，我们获取变量的方式是用系统调用直接拿出来，然后强转成类型，然而由于不同版本的虚拟机中的的定义不一样，可能会造成拿出这个符号之后，对应的字段并不是真正的在这台机器上的字段，出现数据的错乱，或者压根为 。就目前的简单测试来，暂时只有 系统的 能够正常操作，估计这里要适配大部分机器的话，工作量应该不少。
：
、关于 在层的响应，目前暂时只有的分析，而对 的处理似乎更加复杂，尚在研究中。、这篇文章中的示例代码，可以从我的上拿到： 。

本文来源于： 微信公众号作者：姚夏冰

环境
系统：  版本：部署方式可以采用方式部署，当然你也可以用方式部署，现在官方文档内容详实，采用手动部署也没问题。
 简介
 是什么？ 顾名思义就是针对虚拟机的备份，它可以指定虚拟机备份类型，备份保留的数目；这个功能在 版的时候就有了。那 到底是怎么做到备份虚拟机的？下面为大家拨开层层迷雾。
 功能介绍
首先，我们手动来体验下的功能。、使用小镜像启动一台的测试虚拟机。
、查看 命令行参数，可以看到支持的备份类型，也支持保留备份数目。
、对虚拟机进行，备份类型采用备份，备份保留份数；结果看到虚拟机在处于_状态，这正是虚拟机做快照的状态，而且通过 可以看到备份，那么可以得出一个结论： 底层是调用 来实现备份。_指定为之外的，会发生什么呢？备份类型指定为，照样能创建成功。
、通过查看具体信息，类型是，_是快照。

、再对虚拟机进行备份类型为的两次，因为备份保留份数为，所以最老的备份将被删除，可以看到老的备份被删除了。
通过以上实验说明， 近似快照，备份类型可以随便指定不局限于／，至于备份恢复也跟快照恢复一样，用这个备份去重新启动一台新的虚拟机。
 代码分析
上面介绍了 的功能，接下来我们从代码层面深入理解。、使用参数，可以打印出调用过程，有助于我们理解 的调用逻辑；信息的前面几步一般都是获取，检测资源是否存在，最后一步才是我们关注的。
、上面红框中的 入口在这里，对请求的解析，还有校验 ，然后继续调用__。
、进入_。
、进入__。
、进入_，最终创建了数据库记录。
、进入__。 计算节点上的_，真正做快照备份是在这里。
、__备份保留处理逻辑，_实际只是一个标识而已，指定为或，并不是周期备份。大致流程如下：
总结
、 实质是调用 来实现备份。、  _只是个标识而已，不同的_对应不同的。、  ，如果超过，会按照 _时间，删除较老的。
参考文献
______ 

本文来自：  公众号序言
效率很高，在等诸多比赛中使用广泛，并且取得了不少好成绩。为了让公司的算法工程师，可以更加方便的使用，我们将更好地与公司已有的存储资源和计算平台进行集成，将数据预处理、模型训练、模型预测、模型评估及可视化、模型收藏及分享等功能，在平台中形成闭环，同时，数据的流转实现了与完全打通，让整个机器学习的流程一体化。
介绍
的全称为  ，是的一种高效实现，中的基学习器除了可以是也可以是线性分类器。
什么是？

    又叫    ，是一种迭代的决策树算法，该算法由多棵决策树组成，所有树的结论累加起来做最终答案。它在被提出之初就和一起被认为是泛化能力较强的算法。的核心在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。与随机森林不同，随机森林采用多数投票输出结果；而则是将所有结果累加起来，或者加权累加起来。

对的改进
  避免过拟合
目标函数之外加上了正则化项整体求最优解，用以权衡目标函数的下降和模型的复杂程度，避免过拟合。基学习为时，正则化项与树的叶子节点的数量和叶子节点的值有关。

  二阶的泰勒展开，精度更高
不同于传统的只利用了一阶的导数信息的方式，对损失函数做了二阶的泰勒展开，精度更高。  
第次的损失函数：  

对上式做二阶泰勒展开 为一阶导数，为二阶导数：  

  树节点分裂优化
选择候选分割点针对进行了多个优化。正常的树节点分裂时公式如下：

树节点分裂时，虽然也是通过计算分裂后的某种值减去分裂前的某种值，从而得到增益。但是相比，它做了如下改进：

通过添加阈值进行了剪枝来限制树的生成
通过添加系数对叶子节点的值做了平滑，防止过拟合。
在寻找最佳分割点时，考虑传统的枚举每个特征的所有可能分割点的贪心法效率太低，实现了一种近似的算法，即：根据百分位法列举几个可能成为分割点的候选者，然后从候选者中根据上面求分割点的公式计算找出最佳的分割点。
特征列排序后以块的形式存储在内存中，在迭代中可以重复使用；虽然算法迭代必须串行，但是在处理每个特征列时可以做到并行。


整体上，通过上述的个优化，加上其易用性，不太需要编程，目前是体系中最受欢迎的工具。但是值得留意的是，当数据量很大，尤其是维度很高的情况下，的性能会下降较快，这时推进大家可以试试腾讯自己的，其比性能更好噢

体系中的介绍
在体系中以两种形式存在

提供出了拖拽式的组件，来简化用户使用成本
提供出了依赖，来让用户享受 的流畅

 平台上的个组件：

组件基于社区版，以作业形式运行在机型的集群上
组件基于社区版，以作业形式运行在机型的集群上
组件基于社区版，以作业形式运行在机型的集群上

目前来看，的版本，性能比的好，建议大家优先选择。
 公司库中的个依赖：

封装社区版的，在机型上进行的编译
封装社区版的，在机型上进行的编译
封装 、 、 等功能

中的组件介绍
中组件根据集群的机型区分成：组件和组件。将以前的组件进行了升级，体现在了：

数据源之间的打通、作业调试更友好、方式更丰富、数据处理的上下游延伸更广、支持在线服务等方面。


数据源之间的打通

消除了不同集群上的权限问题
与打通，数据流转更顺畅，开发成本更低 
用户可以不再编写程序生成格式的数据文件，而是通过或者 生成特征表，通过选择特征表的某些列_=，由组件后台生成类型的输入
可以针对分区表，借助作业定时调度机制，可以进行作业的例行化调度运行




作业调试更友好

以作业的形式，而非直接的作业的形式运行，用户对作业的运行情况更清楚
可以查看作业的进度
可以查看各节点上的日志信息     




方式更丰富

输入的数据集来源，可以为之前的上格式的文件形式。也可以为一张表，用户通过选择表中的某些列，由组件在后台生成格式的输入。
训练阶段增加了特征重要度、、的输出、以及种类型的输出：文本格式用户可以直接查看、的二进制格式用户可以下载到本地，利用加载后在线预测、的二进制格式用户可以在环境中，利用加载后离线批量预测
模型输出的种格式举例 




  数据处理的上下游延伸更广
 与平台深度整合

可以拖拽的组件：数据切分、模型评估，实现数据处理的上下游功能
可以利用的功能：参数替换、并发设置，进行批量调参  

  支持在线服务

可以利用的模型服务，进行模型导出、模型部署、在线预测 


总结
是机器学习的利器，虽然小巧，但是功能强大，以其被实战检验过的高效，吸引了很多使用者。我们针对用户痛点进行了诸多改进，实现了用户在平台中更加方便的使用，大大减少了用户的开发成本，同时，我们也开放出了 ，让逻辑复杂的业务可以在自身系统中嵌入，更加直接的对接系统。后续有进一步的需求，欢迎联系团队，我们将提供更好的机器学习和数据服务。上周四，腾讯云技术社区继续推出了【云端架构师养成】系列分享的第二期：云端负载均衡上手与实践，邀请到的嘉宾是负责该产品的产品经理方坤丁与工程师龚飞斐。

本期分享大纲：

什么是负载均衡
负载均衡的实现
腾讯云负载均衡：简介、技术方案等
腾讯云负载均衡：类型及适用场景
腾讯云负载均衡：产品性能、技术原理
典型案例
实战教学

本期视频回放：

本期分享 ：
详见本文附件。
下期主题预告：微信也在用的消息队列服务
往期回顾：
云端架构师养成之一：高性能云硬盘入门与实战空间相册的旅游相册，它以照片拍摄时间为主线，还原了旅游行程中的故事，清晰展现了用户行程景点位置及拍摄的美景。景点位置查询作为旅游相册一个重要功能，可以帮助用户找回旅途中的足迹。腾讯内部搜索平台部成立不久便托管了景点搜索业务，支持用户景点输入智能提示、国内外景点搜索。
一现状
旅游相册搜索业务自年月上线后，从最开始的仅支持国内景点搜索到国外景点数据补充，再到针对性地修补景点数据，从数据层面做了大的修补。搜索点击率也随之逐渐提升。时隔数年，再次拾起，希望可以通过总结整理，达到知识分享、提升的目的。
二架构设计
搜索智能提示主要用于用户输入景点检索串时，实时进行相关结果快速提示的场景。一方面可以补充提示用户所要输入的位置信息，另一方面可以引导用户搜索精确化，从而提高景点搜索结果准确度及结果点击率。针对以上业务特性，搜索业务架构有别于其他通用搜索，主要体现在数据补充、离线索引、在线检索三个模块。
数据补充
 目前数据分为三个来源：

国内数据：由腾讯地图提供的数据，包括国内各省、市、区等行政区，旅游景点等。
台湾和国外数据：由相册业务侧负责抓取 中文、英文、其他语言都有。 
国外景点数据：由搜索侧抓取国外景点，范围按洲、国家、省从大到小，根据抓取到的景点名称调用  获取对应信息。这种补充方案依赖于地图的准确性及景点名称规范性。

离线索引
离线索引主要功能包括接收原始数据，建立倒排、顺排、属性、等索引，离线打分。基于地图数据更新周期较长、同步集中的特点，搜索业务采用了定期全量推送加每天增量推送的更新方式。为支持用户输入景点的实时检索，我们设计了两套索引结构：前向匹配切词索引、普通分词索引，保证用户检索结果可以前缀命中或分词命中检索串，从而提升用户检索体验。
前向匹配切词索引

末级信息按前向匹配生成索引，例子：“中国湖南长沙岳麓山书院”，生成的索引为“岳”“岳麓”“岳麓山”“岳麓山书”“岳麓山书院”。
非末级信息做数值过滤，例子：“中国”“湖南”“长沙”作为的数值过滤。
生成全拼拼音索引并按前向匹配索引，如“”生成       。
外文名称按单词粒度处理。
需控制倒排链的最大长度。
英文也做前向匹配切词。

普通分词索引

末级信息按普通分词生成索引，例子：“中国湖南长沙岳麓山书院”，生成的索引为“岳麓山”“岳麓山书院”“中国”“湖南”“长沙”。
非末级不索引

行政区特殊索引
为支持行政区名检索，离线索引对每个文档的省、市、区行政区名建立了特殊索引：首先建立行政区名到行政区名字母映射表，查表得到对应行政区字母缩写，再通过添加特殊前缀标记的方式，把带特殊前缀的行政区字母标记添加进这篇文档的顺排词表。支持行政区识别检索效果如下： 
离线计算
行政级别权重  类别权重  主副点行政级别权重：国家  省  市  县  末级类型权重：旅游景点   其他主副点：主点  副点，比如 银科大厦  银科大厦停车场，简单比较方法是词长越短越重要
在线检索
 
预处理

去空格、归一化 
混拼拼音汉字参杂转换为全拼音 
切词 去行政区、去类别、整串、普通分词例子：南山世界之
去行政区：提取“南山”为行政区，“世界之”为真实检索串 
去类别：提取“汽车站”、“火车站”、“机场”等为类别 
整串：“南山世界之” 
普通分词：“南山”、“世界”、“之”在线检索主要功能包括索引数据加载，检索语法树构建，结果求交集相关性排序等。用户检索请求经检索语法分析，可以扩展为三种检索语法：

去行政区前缀检索：
带行政区名的检索串识别到行政区后，行政区名作为分类过滤条件结合去行政区后的检索串进行前缀索引检索。效果如下： 
普通前缀检索：
无行政区名的检索串直接进行前缀索引检索。效果如下：
普通分词检索：
获取分词结果后进行分词索引检索。效果如下： 
排序策略

直接使用离线打分结果
洗脸
行政区、景点、前向匹配切词结果、普通分词结果各占几条
行政区  类别
前向匹配切词结果  普通分词结果
末级相同时，当前城市优先。如用户在深圳，搜索“世界之窗”“深圳世界之窗在”长沙世界之窗“前暂无实现 

三质量优化
零结果分析
根据业务侧提供的会话级检索词，即用户选中推荐地点时落下的检索串。会话级零结果数占每天会话级检索量接近四分之一抽样会话级零结果检索串分析如下：



检索串类型
示例




时间相册主题
年的我


相册主题
一個人的旅途


地点缺失
上海普陀区梅川路步行街


输入有误
巴黎罗浮宫



相册主题类：
包括时间相册主题、相册主题类型的检索串。用户在地点框误输入相册主题，输入与景点搜索无关，检索串格式比较混乱
地点缺失：
用户输入带范围描述词的地点，比如：东莞莞城区西城楼附近、哈尔滨松花江江边。有些地点没有索引进来，比如：柳城太平安乐湖、康巴什赛马场
输入有误
少数输入拼写错误，比如：巴黎罗浮宫
结论：
导致零结果的检索串中相册主题类型占了绝大部分；地点缺失问题主要是用户不能确定景点位置导致；数据缺失问题比例相对较小。
解决方式：
产品侧策略：通过产品侧对用户的输入做引导，帮助用户区分相册描述、景点位置输入框，提升检索串质量。数据补充策略：针对地点缺失的问题，通过抓取旅游网站著名景点数据补充。在线处理策略：后续考虑引入纠错，解决拼写错误等问题。引入纠错及补充著名景点数据前后，搜索零结果率有所下降，效果如下：
结果曝光各类型数比例
 
结论：
从各类型结果曝光情况看出，非旅游景点、非行政区的结果检索得到的数最多；搜索结果整体趋向景点、地址搜索的场景，由于对风景名胜等景点相关的数据离线打分权重相对较高，导致其他类型数据召回效果并不理想。
解决方式：
针对特定类型如机场、火车站、汽车站等检索需求，离线索引会对这类文档建立分类类型特殊索引，在线检索对检索串语法分析时，可以识别出其分类意图及分类类型，转化为分类过滤条件下发。效果如下： 
经历了空间相册等业务的高速发展，景点搜索应用积累了丰富的应用场景与应用经验，不断提升性能及优化用户体验，足够成熟后已作为“腾讯云搜”产品的能力之一开放给广大的开发者用户。

相关推荐
腾讯云搜使用说明本文尝试通过数据校验方法解决如下几个问题：

数据没有校验，系统处于裸奔状态，导致后期维护成本高；
编写一堆校验代码，混杂在业务代码中，导致代码可读性降低；
交付的时候提供一大段接口描述文档，但用户还是要揣测文档意思。

 背景介绍
 无处不在的
是一种轻量级的数据交换格式，基于的一个子集 但采用完全独立于语言的文本格式易于人阅读和编写，同时也易于机器解析和生成。这些特性使成为理想的数据交换语言 几乎所有与网页开发相关的语言都有库。目前蓝鲸，甚至公司内绝大多数系统的交互都采用格式。
 令人头疼的数据校验
由于比较灵活，没有固定的，使用作为数据交换格式时，我们经常遇到数据校验的问题。一个简单的数据往往需要写一大段代码来校验数据格式是否符合预期，导致代码膨胀，可读性不好。
如下是一段系统新增自定义变量的请求参数，大致分成几部分请求账户、操作者、添加到的目标业务和环境类型，最后是要添加的变量列表。
{
        系统账号
        系统密码
        操作者
        操作者的信息
        业务
        环境类型
     {
            变量作用域
            变量名称
            变量值
    }
    {
            变量作用域
            变量名称
            变量值
    }
}
为了校验参数的正确性，往往的做法是写如下一段代码用表示请求参数
 参数数据类型校验
   
         

 校验是否在参数字段中
    
        
 校验值的类型
   
         
 校验值是否为空
  
         

 校验参数字段
    
        
   
         

   
       
             

完整的将校验代码写下来需要极大的耐心，校验代码很简单，但是又不太好复用，当耐心消耗殆尽的时候，我们就开始铤而走险了，先不去做校验其实我们都明白这有多不好。如果不进行数据校验，系统相当于裸奔的状态，随时可能出问题，尤其是出现偶发性的数据异常时，往往排查难度非常大，如果异常发生在一个逻辑复杂的功能模块中，问题定位花的时间差不多能赶上代码编写的时间了。第三方接口格式的变更，如果没能及时通知到调用方，也会导致潜在的风险。
 用校验数据会是什么样呢
如果用的做校验，代码会少点，下面是用对案例数据编写的校验函数：
 
     
         = 
         = 
         = 
         = =
         = _=
         = =  

     
         = =\|\|\\\{}\|\|\\\
         = 
         = 

     = =
       
             

      _
          

        
          

       
            

       
       
             
         = =
          _
              

      
咋看之下，代码要简单很多了，用一个可以把一层的简单数据类型都校验了，但仔细看看剩下的代码，会发现几个问题：

用表单校验首先需要保证数据是类型
循环结构需要单独编写代码实现
层次关系用校验不了，如果层次很深，校验代码就退化到了直接编码校验

 当前较为流行的框架的解决方案—— 
回想作为目前较为流行的一个跨语言开发框架，使用起来就不需要这么繁杂的参数校验，究其原因是因为在接口定义的时候严格定义好了接口的输入输出参数及其类型。 的 也是需要编写一个  文件，定义程序中需要处理的结构化数据。可见，为了提供可靠的数据，得先有关于数据格式的描述数据模式，如果对数据校验的时候，先整理出数据模式，是否也能写个通用的检验算法，运用模式对数据进行校验呢？
 模式探索——建立数据校验的基石
作为的一个子集，支持的数据类型也是可枚举的，基本数据类型有 容器类型由和。容器中容纳的元素是基本数据类型或容器，因此我们只需校验基本数据类型和对容器的结构进行校验，容器中的元素可以采用递归的方式进行校验。由于基本的数据以的形式存在，可以针对各个字段指定应该满足的规则，形式如
 {
    _ _
    _ _
    
}
基本数据类型比较好校验，可以单独定义一些规则用于支持，比如字符串类型，可以定义一个规则名指定最大长度 定义规则名指定其格式 甚至定义规则指定字符串应该遵循的正则规则。
 {
     
     
     
     
     
}
容易类型的其实也可以按照规则规则值的方式来指定校验规则，容器内的元素用递归的方式指定校验规则。比如一个格式的校验规则就可以写成：

{
     
     
     
      
}
另外还需要有字段专门用来指定容器内的元素及其对应的校验规则，可以用记录
{
     
     
     
      ，
     {
        _ __
        _ __
    }
}
 一个简易的数据校验算法实现
如下代码就是基于上述数据格式定义规则实现的校验算法：
 
    


 __ _
     _ == 
           
                     _
     _ == 
            
                     _
    
           


  _
     只对类型进行校验，保证长度不超过_
      
           _
                    _


 _ 
    
    格式数据校验
     
     
    
    
        
          == 
            __ 
          == 
             
          == 
             _ _  
                __ _
        
               
 
稍微看下上述校验算法，会发现原来实现一个通用的校验规则其实挺简单。目前开源社区已经有了基于这种方式校验工具 其官方文档 中提供了相对完备的数据校验规则以及更好的使用体验。比如提供了   组合规则方便我们组合出更严格的校验规则，另外还提供了方式命名一套复杂的校验方案，使用时用引用这个命名的校验方案数据模式复用_。更多关于数据校验的特性还请大致浏览一遍官方文档。
使用对本文开始提供的例子定义的校验模式为：
{
     
          
     {
         {    }
         {  }
         {    }
         {  }
         {      }
         {
             
             {
                 
                   
                 {
                     {
                         
                         \|\|\\\{}\|\|\\\
                    }
                     {   }
                     { }
                }
            }
        }
    }
}
 应用分析
最后，回过头来总结一下用—有哪些好处：

在输入输出的地方做参数校验，将非法输入拦截在入口， 将数据校验逻辑从业务逻辑中分离开来

用户数据校验，用户无论是从前端还是提交过来的数据，如果能通过校验发现参数问题，给用户明确提示的同时，也可以避免低效沟通
入口数据校验保证数据准确性，将可以保证逻辑代码尽量精简，不需要对非法输入进行处理
第三方接口提供的数据服务，并不总是可靠，将这种无效的数据拦截在系统之外。可以减少不必要的定位


作为描述语言使用当我们的系统作为平台给应用方提供接口的时候，往往需要写上一大段接口文档，描述哪些字段是必填的，应该怎么填，用户仔细阅读完文档可能还是不知道参数是怎么填，即使提供了也很难覆盖全面，运用定义数据模式正像用数学符号表达数学问题一样，非常简洁，但是又能准确表达意思。背景
近两年来构造原生应用异常火爆，在中用来替代页面可以明显提升用户体验，但是在一些场景是需要配套版本的，比如分享、或者报错时的降级方案等。如果适配再去实现一套的页面会增加开发和维护成本，同一套代码能不能跑在浏览器了？ 由于的页面都是基于基础组件和或者自己实现的，页面的代码是完全可以复用的。 端实现同样的基础组件和，打包文件时做好组件映射，这样同一套业务代码可以运行在三端。
配套基础组件
业内也有这方面的实践，淘宝和和都开源了组件和代码就不需要自己去实现了，我选用的是淘宝的，详情见 这个项目官方差不多停止维护，自己拷贝了一份来维护。
实践解决问题
项目目录结构，为项目的入口文件，和分别为和打包入口文件。

组件的代码大概这样
 {}  
 {  }  
 {  }  
   
   
    {
        {
         
       }    
     {
         {    } = 
         
            
                 ={} ={}{合唱推荐}
                 ={}
                    {  =  ={} ={} ={} ={} ={  }}
                          
            
        
    }
}
  = {
     {
         
    }
}
 = ={
   {
     
  }
}
遇到和有差异时需要自己区分平台写差异代码，对于比较小的差异可以通过来区分例如
_ {
      =  
      ==  {
           
           
    }
  }
差异较大的建议区分平台抽象为组件，通过打包时映射到对应的组件上，例如路由组件用的是 用

实践过程中有遇到些问题，列举两个影响和改动较大的问题
  为了保持和布局保持一致，页面固定一屏高度采用  局部滚动布局，下滚动到页面顶部或者底部有回弹效果这时如果再向相反方向滚动页面导致页面无法滚动，如下图：

解决方案：去掉固定一屏高度和局部滚动的布局，采用常规的布局。这样会影响固定顶部、底部、遮罩层的布局，端需要增加样式，和端的样式需要区分开。
 兼容问题，采用布局，端分为个版本，、、。 版本主要是兼容安卓以下的设备，需要对属性兼容例如属性的映射和补充缺失以及添加厂商前缀。详情见=


 属性和值映射
  = {
       
       
       
       
       
       
       
       
       
       
}
  = {
       
       
       
       
}    
属性补充，组件增加兼容低版本样式_属性， 例如
 _  {
      
          ={} ={} _={{  }}
     
}
处理样式生成的时添加_里面的样式
  ==   _ {
        _ {
          = _
            {
            
          }
           = 
    }
  }
优化
生成的页面在体验方面有些不太理想，比如文件大小、首屏可见时间等，所以在某些做了些优化。
  支持后端渲染直出提升首屏渲染可见时间，常规的静态页面渲染要经过下载、执行，组件渲染、数据加载、组件更新等耗时时间较长，如下图所示，在无缓存笔记本环境下，大小为，下载执行耗时

由于兼容判断是依赖浏览器环境，后端渲染需要去掉这些依赖补全全部的兼容样式，服务端渲染首屏主要耗时在后端渲染耗时较短内基本可以返回内容。
 按需加载组件减少不必要的依赖从而减少文件大小 { }           
按需前所有组件压缩后按需后常用的组件压缩后…等
 常用组件打包压缩后大小有依然不够理想 占了，可以用类库替代，从文件大小考虑最后用替换掉，迁移也相对容易。是的规范的一种简单高效实现体积非常小，包含特性：、、、、、，精简掉的特性：、  。由于去掉了合成事件，所有的事件都是绑定到上，对应的的触摸手势事件需要用原生事件替代，组件上的手势事件改为原生的事件。
 _ = {
  
  
  
  
  
  
  
  
}
设置组件属性的时候会加上事件
 ==  == {
   =  == = 
  = 
   {
         
 }
  {
       
 }
 _ || _ = {} = 
}
的事件是直接绑定到节点上的，当事件过多时建议采用事件代理来减少事件监听。性能测试数据参考

打包压缩后的大小为

打包压缩后大小为

 生成的页面样式都是内联到属性上，这些样式属性可以从代码里提取出来生成文件，这样就可以缓存页面的也可以减少一些兼容的计算。
实现方式是编写 插件，利用静态抽象树来找出调用函数的参数，根据这个参数过滤出可以直接提取的样式对象并删除这些样式对应的节点，用过滤出来的样式对象生成样式文件，然后遍历节点的属性并给节点加上对应的属性， 关于插件编写可参考 里面的 和教程相当详细。
抽取文件的主要流程如下图：注：无法转化为样式字符串的是指需要通过表达式计算得出的样式。举个例子：
转换前的对象

  = {

     {

         

         

         

    }

     {

         _

         

    }

      {

         

         

         

         

         

         

         

         {   }

    }

}



 ={}

     ={}查看特权

         ={}

            

转换完成后的 类名经过处理

_ {

     

     

     

     

     

     

     

     

     

     

}

 {

     

}

_ {

     

     

     

     

     

     

     

     

     

}    

转换过后的代码

  = ____________   {

     {

         _

    }

}



_________

    ____________   

    {

         _

          }

    _________

        ____________   

        {

             

              }

        \\\\

    

    _____________________    {

         _

          }


优化前后对比
环境为桌面 
 页面加载和执行耗时如下
优化前

加载和执行耗时
优化后

加载和执行耗时主要缩减组件大小 大小从缩减到
组件渲染和首屏时间如下
优化前

优化后

组件渲染时长从降到，首屏可见事件从提前到了
线上数据
优化后页面是从月日开始 总资源加载耗时

页面开始导航到可交互耗时一、      基本概念
         直接光照、间接光照

直接光照：光源直接照射到物体上，并反射到眼中的光照。
间接光照：光源先照射到其它物体上，并经过一次或多次弹射，最终抵达到观察物体，反射到眼中的光照。
         漫反射、镜面反射、环境反射

 
漫反射：照射到物体表面的光线在各个方向均匀地反射出来，反射强度跟入射角相关，跟观察角度无关。
镜面反射：当入射角和反射角越接近时光照越强，因此不同观察角度反射强度不同，传统的无法计算。
环境反射：无法被光线直接照射到的区域，通过光线在物体之间的弹射而被照亮。在不使用全局光照进行计算时，通常简单地指定一个纯色。
  光照图、带方向的光照图
光照图：将光照的反射信息预先计算好并存储在纹理上，渲染时直接采样这张纹理模拟实时光照。
带方向的光照图 ：类似于传统，但是额外生成了一张光照图用来保存光源的照射方向以及这个方向的光照强度贡献比例，以便能在使用光照图的同时计算。
 示例场景全静态光照投影

光照图

带方向的光照图

         间接光照图
和传统光照图类似，但只在光照图上存储间接光照的信息，而不存储直接的光照信息。
只有间接光照的渲染效果

间接光照图

          
由于无法对场景中的人物等动态物体像静态物件一样烘焙光照图，计算间接光照。如果场景中仅有静态物体存在间接光照效果，动态物体会显得十分突兀。而 则是用来为动态物体计算近似的间接光照效果，一般成组地批量使用，分布在场景中。
图中木桶等杂物没有计算间接光照

 使用球型和谐函数编码记录一定空间区域内的光照信息，占用的数据存储空间很小，只有个，并且在中解码的计算开销也很小。但由于没有存储物体表面逐像素的光照数据，因此无法像光照图一样表现出物体的光照细节。
具体的算法可参考文档：
  和红黄色两盏点光，尚未烘焙。

烘焙 后的动态物体光照效果

         
通过额外绘制物体在光源空间的深度图来实现投影效果，质量较高，但性能开销大。
基于实时计算投影效果

光源空间的深度图

         
预先计算光线到物体表面的遮挡关系，并存储到纹理中。渲染时通过采样此纹理计算光照投影区域。
图为一张 位图，每个通道分别用来记录一个光源是否能直接照射到物体表面。当使用时最多能同时记录同区域内盏光源的投影信息，如果超过这个值则不会生成，而是将光源作为静态光照直接烘焙到上。


         预计算实时全局光照  
通常情况下，如果要实现全局光照的效果，为了性能考虑游戏只会实时计算物体的直接光照，而间接光照则会被预计算并烘焙到光照图中。而在开启预计算实时全局光照时，会预计算静态物体之间的光线弹射传播路径，并使用这些信息在运行时生成低分辨率的间接光照图。这样可以在改变光源位置、方向、颜色时，也能实时计算物体的间接光照效果。
但这样需要在 中保存额外的光照传播路径数据，还需要在运行时生成光照图，产生额外的内存开销和渲染计算量。并且由于用于保存这些信息的光照图分辨率较低，如果直接复用普通光照图的纹理坐标进行采样，会出现很严重的瑕疵，因此必须为其生成单独的纹理坐标。
有关预计算全局光照算法的更详细的说明可参考文章：

         光照图纹理坐标
模型原始的纹理坐标有可能把不同的面映射到相同的纹理区域，而在采样光照图时，由于不同面的光照结果不同，所以必须要求模型的每一个面都映射到单独的光照图区域。为了解决这个问题，我们可以在建模工具中预先生成好展开的纹理坐标，保存到通道中。也可以使用自带的纹理坐标展开算法自动为模型生成光照图纹理坐标。
在生成光照图纹理坐标时，每一块不连续的模型几何面映射区域叫做一个纹理坐标图块 。在采样光照图时，为了避免图块之间因为采样的过滤插值而造成溢色，我们需要在图块之间保持一定的间距。但是这么做会造成光照图空间的浪费。为了避免生成的光照图纹理坐标独立图块数量过多，的纹理坐标生成算法可以自动地将相邻面片的图块拼合在一起。
未合并的纹理图块

根据面片相邻关系合并的纹理图块

而在生成预计算实时全局光照信息的光照图时，系统会自动将纹理坐标的采样边缘对齐到半个像素的位置，因此即便不同的纹理坐标图块之间不保留空白像素，也不会产生溢色问题。
半像素对齐的光照图纹理坐标

但是实现的预计算实时全局光照的算法要求光照图的每个图块最小也要有像素的采样。如果分割的纹理图块过多，浪费的纹理空间依然会很大。因此还为预计算全局光照图提供了额外的纹理坐标简化算法，可以将指定间距、夹角容差范围内的面片对应的纹理坐标图块进一步合并到一起。
但当开启纹理坐标图块简化时，要求拼合后的每个图块的边缘保存分离的光照方向信息，而光照方向信息又是以像素的为单位保存的，所以最小纹理坐标图块的尺寸则变成了像素。
二、      新版本变更
在以上版本中，官方已放弃了原先的  ，如果将灯光设置为的纯静态光照烘焙模式则无法实现任何的光照效果。而新加入的的混合光照模式则得到了大幅改进。当使用光照模式时，引擎提供了四种新的光照混合选项，分别为： 、 、和，这四种选项在混合实时动态光照、静态烘焙光照，实时投影及烘焙投影时采用了不同的处理方法。
三、      逐光源设置
每个光源使用的光照模式通过在编辑页面中修改光源组件的属性值指定。

每个光源可以设置不同的光照模式。场景中可以同时存在纯实时光照、纯静态烘焙光照和动静混合光照。如果同时有多个光源都指定为或，那么它们需要烘焙的直接或间接光照信息会被混合起来保存在同一张光照图上。
当光源被指定为模式时，还需要在全局光照设置选项中为所有光源统一指定具体的混合模式。详细说明可参见章节——混合光照模式。
用来调整光源的整体强度。
 用来单独指定间接光照的强度。
四、      全局光照设置

         环境光照设置
  指定一个用于渲染天空盒的材质。应使用采样 的特殊。
  指定作为太阳的主光源。将使用该光源的方向来计算光晕特效的位置。
 
环境光源选项


 –使用天空盒作为环境光源。

 –使用 、、指定天空、水平线、地面三个颜色作为环境光源，并进行插值过渡。

 – 使用一个纯色作为环境光源。


 仅当  开启时可选，否则强制烘焙环境光。

 –使用球型和谐函数实时计算环境光

 –将环境光烘焙到光照贴图上。


 
环境反射光源


 – 使用天空盒作为反射光来源。

 –使用指定的 作为反射光来源。



环境反射的分辨率覆盖原始天空盒材质纹理尺寸


 – 不压缩

 –压缩

 –根据纹理格式设置自动选择


 
反射强度控制系数，取值范围从到。默认为，即真实的反射强度。

当场景中存在类似镜子的反射物时，场景可以被反射的最大次数。如设置为，则环境反射贴图中的镜面则不会被绘制，显示为黑色。
         实时光照设置 
  
是否开启预计算实时全局光照。
如开启则会烘焙间接光照传递信息贴图，占用额外的内存，并影响渲染性能。
如关闭则将全局光照结果烘焙到光照图中。
         混合光照设置 
  
控制是否烘焙全局光照。如关闭，则和光源均不会生成光照贴图。

光照：
等同于版之前光照烘焙模式，将直接光照和间接光照都烘焙到光照图上，但不会有镜面反射的高光效果。
投影：
 如光源为模式，在距离内，动态物体可使用在动态物体上产生投影，但动态物体只在静态物体上产生主光源造成的投影。并且必须通过  指定一个强制的投影遮挡区域间接光照颜色。在距离外动态物体不产生投影。
静态物体在静态物体上的投影使用计算，在动态物体上的投影使用计算，均不受影响。
 
光照：
直接光照实时计算，间接光照烘焙到光照图。
投影：
无论对动态物体还是静态物体均使用基于的实时投影。但限定在可视距离内，该距离外无投影效果。

光照：
直接光照实时计算，间接光照烘焙到光照图。
投影：
所有静态物体投射到静态物体的投影都使用预烘焙的图计算，不考虑距离。
所有静态物体投射到动态物体的投影使用计算，不考虑距离。
所有动态物体投射的投影在距离内都使用计算，在外无投影。
 
光照：
直接光照实时计算，间接光照烘焙到光照图。
投影：
在距离内，全部使用基于的实时投影。
在距离外，动态物体无投影。静态物体在动态物体上的投影使用 ，静态物体在静态物体上的投影使用。
         光照图设置 


 – 使用第三方组件计算全局光照，生成光照图。

 – 使用渐进式光照图烘焙算法。当勾选 光照图选项时，无需点击生成光照图按钮，后台会在场景发生变化时自动生成光照图。并且会优先计算编辑器窗口中显示的模型。


 
间接光照计算分辨率，影响光照图上间接光照的表现细节和精度，会极大地影响光照图烘焙时间。在测试期间建议将其设置为之类的极小值。
 
光照图分辨率。是纹理像素和场景模型世界空间的表面积尺寸之间的比值。此值越大对于相同的模型生成的光照图越大，细节也越多。
 
对于模型表面在光照图上不同的展开区域，之间间隔的像素单位尺寸大小。用于避免当两块不相邻的面片在光照图上被映射到同一区域时，由于纹理采样插值会导致互相溢色。通常纹理分辨率越高此值也应该指定得越大。但过大会降低光照图的空间利用率。
 
单张光照图的尺寸。注意该值是在计算光照图时输出的最大尺寸。实际的光照图尺寸还受到光照图导入纹理格式设置尺寸的影响。
 
是否压缩光照图。
 
烘焙光照图时是否计算环境遮挡。如开启则在模型的沟槽和边角处会产生自然的黑暗区域。
 
是否在计算全局光照弹射的最后一步使用与光照图相同的分辨率。如不开启在某些情况下光照图会产生错误的黑块，强烈建议开启。
 
 –传统的单张光照图，无法产生镜面反射高光效果。
 –生成两张光照图，一张用于存储直接和间接光照，另一张用于存储主要光照贡献方向和比例，以便计算镜面反射效果。但是必须指定为非的光照模式。
 
间接光照强度。取值范围到。可用于手动减弱或加强间接光照效果。
 
材质反照率增强系数。取值范围到。可用于加亮材质本身的颜色。
 
指定一个光照图计算参数配置表，内含更具体的光照烘焙计算参数。通常情况下只需在预制的配置方案中选择即可。
五、      模型设置
如果一个物体想要烘焙静态光照图或，则它必须在编辑器中被标记为静态物体。动态物体只能使用计算实时投影，使用接受投影。
所有继承于的渲染器组件都有属性组进行光照相关的设置：

 ：

  不接受 的光照。

  – 采样物体周边最接近的 ，并混合它们的光照结果。

    – 当物体较大时，由最接近物体的 组成的四面体已不足以覆盖整个物体，因此使用一个虚拟包围体来采样更大范围内、更多的 ，并插值它们的光照参数用于计算光照。


 ：

 – 不作为遮挡物产生投影。

 – 作为遮挡物产生投影。三角形背面不产生投影

  –三角形正反面均作为遮挡物产生投影。

  –不渲染物体，只作为遮挡物产生投影。三角形背面不产生投影


 
其它遮挡物是否能在此物体上投影
 
是否为该物体烘焙光照图或图
  
预计算实时全局光照图纹理坐标优化控制参数

   – 是否为预计算实时全局光照图优化纹理坐标。如开启此选项，不同的图块可以被移动、缩放或分组到不同的光照图中，较接近的图块还会被合并到一起。但如果不开启此选项，则不同的图块不会被合并，但依然可以改变位置和分组。

  – 合并图块的面片之间允许的最大距离。世界空间尺寸

  – 不同面片之间允许合并图块的最大夹角。

 –在导入模型时，由于模型面数较多等原因有可能会把模型拆分成多个，进而导致模型的图块也会被拆分。模型拆分的分割线通常会在面片的法线差异较大的地方产生，如果开启了这个忽略法线的选项，在生成光照图纹理坐标时，就不会在拆分模型的同时拆分图块。

   –指定用于预计算全局光照的纹理坐标图块的最小尺寸， 像素不拼合，或 像素允许拼合。


 

   – 为当前模型生成的静态光照图的纹理占用表面积缩放值，该值越大则当前模型的光照图分辨率越高。

  – 勾选后强制在进行全局光照计算时包含当前物体。否则该物体有可能被忽略，造成一些瑕疵。

  – 为当前物体指定单独的光照图计算参数配置表，如果为  则使用在全局光照设置中选定的光照图计算参数配置表。一般可根据渲染质量使用引擎自带的默认配置组，如需自定义参数，建议参考文章：

  –静态光照图的烘焙结果参数，不可修改，仅用来查看内部引用的资源信息。其中 标识该物体使用几号光照图，和表示在这张光照图中的缩放和偏移量。

  –预计算实时全局光照图的烘焙结果参数，不可修改，仅用来查看内部引用的资源信息。


六、      修改引擎源码增加功能
         多通道烘焙采样
引擎原始的投影遮罩区域图强制使用位格式纹理保存，为了实现投影区域渐变的软边过渡，因此对于每个光源必须使用位数据记录投影遮挡灰度信息。每个通道用来记录一个光源的投影遮挡信息，最大同时记录光照图渲染区域内的个光源。
但对于游戏场景来说，大多数情况只需要有一个方向光作为主光源产生投影，并不会占用全部个通道。对于地形之类的物件，必须要求使用一张整体的光照图，否则在不同的纹理坐标图块之间必然会出现接缝问题。而在一些低端的移动设备上，并不支持尺寸以上的单张贴图。这会造成投影精度完全达不到美术的要求。即便不考虑地形，图所占用的内存空间也太大，其中的空间都是浪费掉的。
为了提高投影图分辨率，节省内存占用，我修改了引擎烘焙及采样图的代码。并在光源属性设置页面增加了一个选项   。
 
如果勾选了这个选项，且要烘焙的光照图中仅有这一个光源需要烘焙投影，则会把图的实际烘焙计算尺寸设置为光照图的倍，即倍的面积。然后在输出图时，将这张倍分辨率的图等分为份，分别存储到原始尺寸图的个通道中。
在实时渲染时，引擎同样会检测这张图是否只对应唯一的一个烘焙投影的光源。如果是，则会使用单独实现的变体来根据纹理坐标决定采样哪个通道的投影遮罩信息。
多通道存储的图

多通道采样核心修改代码


  

{

                

     = 



     



      

    {

         = 

         = 

    }

    

    {

         = 

    }



      

    {

         = 

         = 

    }

    

    {

         = 

    }



     

}



      

{

 ___

      = 





      = ____ _ 



 ___

      



      _



}据最新报道显示，继  和  之后， 成为下个数据勒索目标，从月日凌晨开始，已有成百上千个开放在公网的  数据库被劫持，删除了数据库中的存储数据，攻击者留下勒索信息，要求支付比特币以赎回数据。
问题分析
遍观  和  以及现在的  数据库勒索，可以发现都是基线安全问题导致被黑客劫持数据而勒索，原因在于这些服务都开放在公网上，并且存在空密码或者弱口令等使得攻击者可以轻易暴力破解成功，直接连上数据库从而下载并清空数据，特别是不正确的安全组配置导致问题被放大。
其实类似问题已不是第一次，近期云鼎实验室观测到多起案例，攻击呈现扩大态势，不仅仅是勒索，更多的是服务器被入侵，从而导致数据被下载。基线安全问题已经成了  漏洞之外入侵服务器的主要途径，特别是弱口令等情况。错误的配置可以导致相关服务暴露在公网上，成为黑客攻击的目标，加上采用空密码等弱口令，黑客可以轻易入侵这些服务。
安全自查
值此事件爆发之际，建议对自己的服务器进行自查，避免相关数据丢失等问题，具体自查方式可参考如下：、排查服务器开放的端口及对应的服务，如无必要，关闭外网访问；可以使用  直接执行  服务器在服务器外网执行，可得到以下结果即为开放在外网的端口和服务。

、重点针对这些开放在公网上的服务进行配置的检查，检查相关服务是否设置密码，是否弱口令。
、如无必要，均不要使用  或者其他系统高权限账号启动相关服务。
安全建议及修复方案
一、采用正确的安全组或者  等方式实现访问控制；
二、关闭相关服务外网访问和修改弱密码：
、
 配置鉴权下面以版本为例，给出 设置权限认证，具体步骤如下：
启动进程是加上参数或在的配置文件中加上 = ；
带  启动的 ，如未创建用户，会允许本地访问后创建管理员用户。创建步骤如下：
 切换到  库；
 创建管理员用户，命令如下和可以根据需要设置：
{     }
 使用管理员用户登录后，根据角色创建您需要的用户
 关闭公网访问可通过的_参数进行配置，只需将绑定为内网即可，如下：
启动时增加_参数： _ 
在配置文件中添加以下内容：
_ = 
其中为您机器的内网
、
 配置鉴权
修改配置文件，增加 “ 密码” 项配置配置文件一般在在连接上的基础上，通过命令行配置，   
 关闭公网访问
配置选项，限定可以连接服务器的，修改  的默认端口
 其他
配置 配置项 “_”，重名相关命令，这样即使存在未授权访问，也能够给攻击者使用 指令加大难度不过也会给开发者带来不方便
相关配置完毕后重启服务
、
 配置鉴权
安装默认要求设置密码，如果是弱命令，可通过以下几种方式修改密码：
 语句
```
以登录后，
 ；
   =新密码  =
 
 语句
   以登录后，       =新密码
命令
    旧密码 新密码```
 关闭公网访问
启动参数或者配置文件中设置= 绑定内部；
以账号连接数据库，排查表中用户的字段值为或者非的用户，修改为或者指定或者删除没必要用户。
、其他服务请参考以上方式或者官方文档进行配置
参考链接

《避免  被勒索详解，腾讯云上更安全》

《下一个猎杀目标：近期大量数据库遭勒索攻击》

《知名搜索引擎成为勒索软件敲诈目标》

《 未授权访问配合   文件利用分析》



相关推荐腾讯云下定时监测进程终止后自动重启的方法轻松在云端部署、使用数据库数据库的高可用性分析导语
   可以将您的应用纳入  搜索中。如果用户安装了您的应用，他们就可以启动您的应用，并直接转到他们正在搜索的内容。  可帮助您的应用用户在其设备上查找公开和个人内容，甚至提供查询自动填充功能以帮助他们更快速地找到所需的内容，从而重新吸引这些用户的关注。
介绍
如今随着手机的普及以及谷歌强大的搜索引擎，谷歌搜索相关市场份额在互联网占有率非常高，这为它打造它独有的搜索生态圈提供了强大的支撑，如 、 、  等系列应用都整合搜索信息，可以很方便应用其 相关应用搜索所需信息，如你可以通过 搜索附近餐厅， 搜索音乐软件，既然人家“朋友圈”那么广，那么是不是通过人家广交朋友来打造自己的”朋友圈”哈哈，为了向大家开放它独有的“朋友圈”，谷歌在年大会开放了  功能，其可以让用户利用谷歌搜索生态来打开的指定内容 一样，详情可以点击  比如我直接在 搜搜电商平台上的相关商品，点击其信息，就直接打开我的应用了手机已安装该应用，并跳转到指定应用如图所示：

 图：搜索 

图： 跳转页面 
不过我发现有几个关键点哈，如果你的应用没有安装，则不会打开你的应用，而是直接打开页面，如果手机已经安装了应用，在搜索应用则页面会显示“已安装”。那么可以应用的 做什么呢？

在谷歌应用搜索中，显示指向应用内容的链接，方便用户点击链接直接打开应用并直接跳转到指定应用，这有利于提升的指标。
在搜索中搜索应用安装，其安装按钮会显示在首页搜索结果旁边，以便用户能够方便地安装应用。
可以通过 统计后台，分析用户搜索 行为以及页面搜索占比，这有利于结合定位投放广告，提高广告收入。

开发入门
环境搭建
添加  和   库添加至项目中，具体链接：
要将 库添加至你的项目，请转到应用的 脚本并添加一下依赖项
 {
  
              
   
  
}
合理安排应用内容的链接恰当组织您的网站和应用的结构，使指向您的网站网页的网址与指向您的  应用视图的网址相同。 搜索会抓取您的这些网站链接，然后利用它们将用户直接导向至您的应用。
在平台创建项目并注册其应用信息，以获取_ 配置文件如图

图： 下载配置文件 

图： 加载配置文件
当搜索显示爬取的公开内容信息时，用户点击其信息，将会交给匹配的处理。
在添加处理的配置：

   =
   =_
   =
   =
   =
    =_ =
        = 
        = 
        = 
              
        =
           =
           = 
   

启用个人内容索引，这样方便在自己设备上看到相关内容搜索，类似于搜索历史，出于隐私保护，该个人内容索引只存在于用户设备上，不会上传到服务器。
建立个人搜索内容索引，核心代码如下
     {
   
       {
         =  

            {
             = 
             =  {
                 = 
                          
                       
                       
                       

               
           }
       }

           {
             =  
            = 

                 
           
       }
   }
}
配置：
 =
  =
  =
   
        =_ 
   

当然为了解用户需求，需要采集用户搜索公开内容行为来提升产品用户体验以及满足用户更多需求，因此可以用采统计用户行为，也可以采集用户搜索个人内容行为这里有兴趣可以去官网看，不太代码了。
记录用户搜索公开内容行为核心代码：
    
       {
       
         =  {
          
          
       }
    }

       {
          =  
               
               
               
               
               

        
    }

       {
        
    }
   {
     =  {
       
   }
   
}
那么如何调试你的应用支不支持搜索链接跳转呢？这里可以用多种方法，其具体链接：
可以用类似命令行测试：
       \
  _
实践
那么引入了 ，再结合阿里开源框架的，那么可以很好的管理页面跳转，同时可以通过降级或拦截器来处理跳转失败问题，其假设其跳转协议为协议格式域名跳转页参数。具体处理流程如图
 
图：处理流程 
当然这些需要建立规范的路由映射表，如图

图：路由映射表 
定义路由映射
 = 
  
要求处于登录状态
 = = _
  
定义统一处理 的核心代码
    {
        
        处理  
        
        
    }

        {
          = 
          = 
         _   =  {
                获取参数
                 =
                页面跳转
                ={
                    携带参数跳转
                    
                } {
                      {

                        
                            {
                            找不到做降级处理
                        }

                    }
                }
        }
    }
定义拦截器
做页面跳转拦截操作
 = 
     {
    
          {
        拦截，检测条件
        ==_{
            
        } {
            
        }
    }

    
        {

    }
}
总结
引入了 功能，需要产品梳理每个模块对应的页面，以便能规范建立页面映射路由表，这有利于后面维护和修改，同时此功能有助于产品了解用户的需求，这有利于产品进一步提升和改进，还有一点，就是谷歌应用会对相关搜索页面进行排名，对热点搜索可以适当投放广告，增加广告的曝光率，从而进一步提高广告收入。
参考文献
==在不久前的      中，公布了一个让页面滑动更流畅的新特性  。该特性目前已经集成到版本中。上使用  特性前后的效果对比 链接地址从效果对比视频中可以明显看到，使用  特性后，页面的滑动流畅度相对使用之前提升了很多。
看完  特性这么给力的效果后，相信大部分童鞋脑海中都会产生以下几个问题：

  是什么？

为什么需要  ？

  是怎么实现的？


接下来，我们将围绕上面的这个问题来深入理解  特性。
  是什么？
                                          { }         
  是提出的一个新的浏览器特性：开发者通过一个新的属性来告诉浏览器，当前页面内注册的事件监听器内部是否会调用函数来阻止事件的默认行为，以便浏览器根据这个信息更好地做出决策来优化页面性能。当属性的值为的时候，代表该监听器内部不会调用函数来阻止默认滑动行为，浏览器称这类型的监听器为被动监听器。目前主要利用该特性来优化页面的滑动性能，所以  特性当前仅支持相关事件。
如下面的代码中，页面通过调用来添加一个事件的监听器，并通过设置属性的值为来声明监听器是被动监听事件，即内部不会调用事件的函数。
为什么需要  特性？
  特性是为了提高页面的滑动流畅度而设计的，页面滑动流畅度的提升，直接影响到用户对这个页面最直观的感受。这个不难理解，想象一下你想要滑动某个页面浏览内容，当你用鼠标滚轮或者用手指触摸屏幕上下滑动的时候，页面并没有按你的预期进行滚动，此时你内心往往会感觉到一丝不爽，甚至想放弃该页面。之前做了一项试验，他们将页面滑动的响应刷新率从降低到的时候，发现用户的参与度急速下降。
由前面对  特性的介绍可知，  特性是让开发者来告诉浏览器，当前页面内注册的事件监听器是否属于被动监听器，以便让浏览器更好地做决策来提高页面的滑动流畅度。那么浏览器为什么需要知道是否被动监听器这个信息呢？浏览器知道这个信息之后，它要做什么决策呢？要回答这个问题，有必要先了解一下目前浏览器的线程化渲染框架，它是  特性的基础。
在介绍浏览器的线程化渲染框架之前，我们先来简单了解本文涉及到的浏览器的一些概念。

绘制：将绘制操作转换成为图像的过程比如软件模式下经过光栅化生成位图，硬件模式下经过光栅化生成纹理。在中，绘制分为两部分实现：绘制操作记录部分 和绘制实现部分。绘制记录部分将绘制操作记录到中，绘制实现部分负责将进行光栅化转成图像；

图层 ：在中，页面的绘制是分层绘制的，页面内容变化的时候，浏览器仅需要重新绘制内容变化的图层，没有变化的图层不需要重新绘制；

合成：将绘制好的图层图像混合在一起生成一张最终的图像显示在屏幕上的过程；

渲染：绘制合成=渲染；

线程 ：浏览器的主线程，负责接收到系统派发给浏览器窗口的事件，资源下载等；

内核线程 ：内核及引擎运行的线程，如树构建，元素布局，绘制 ，执行等逻辑在该线程中执行；

合成线程 ：负责图像合成的线程，如绘制，合成等逻辑在该线程中执行。


，了解完上面的几个概念后，我们正式开始线程渲染框架的介绍。
浏览器的线程化渲染框架
我们回顾一下传统的单线程渲染框架，如下图所示，内核线程几乎包揽了页面内容渲染的所有工作，如执行，元素布局，图层绘制，图层图像合成等，每项工作的执行耗时基本都跟页面内容相关，耗时一般在几十毫秒至几百毫秒不等。
对于这种单线程渲染框架，存在两个明显的问题：

流水线的执行方式，后面的工作必须等待前面工作执行完成才能处理，无法将相互独立的工作并行处理；

内核线程负责的工作太多且耗时，一旦遇上内核在执行耗时较长的工作，用户的输入事件是将无法立即得到响应的。


对于第个问题，浏览器很难控制页面从内容变化到布局渲染整个过程的耗时即新生成一帧内容的耗时，中间任何一项工作的执行都可能导致整体过程耗时变大，过大的耗时会导致页面内容的刷新率偏低，从而形成视觉上的卡顿。如浏览器收到中断信号通知的时候，意味着页面需要立即对内容进行渲染，但这个时候内核线程可能还在执行一些业务的代码，导致页面内容的渲染无法立即开始，如果页面无法在下一个中断信号到来之前完成对内容的渲染，则页面会出现丢帧，用户感觉到页面操作出现卡顿。
注：信号中断的频率，一般跟设备屏幕的刷新率对齐，比如设备的刷新率为  ，那么大概会触发一下中断信号。浏览器和系统等都是通过中断信号来通知页面启动内容的渲染。
对于第个问题，由于内核线程负责的工作太多，这将导致内核线程经常处于忙碌状态，无法快速处理外界的输入消息，表现为用户操作了页面，但是无法立即得到响应。
为了优化第个问题，浏览器对内核线程负责的工作进行拆分，通过多线程并发处理提高渲染效率减少丢帧，如内核线程仅负责树构建、元素的布局、图层绘制记录部分 、的执行，而图层绘制实现部分、图层图像合成则是交给合成线程负责处理。这种多线程负责页面内容的渲染的框架，在中称为线程化渲染框架  。
如上图所示，在的线程化渲染框架中，当内核线程完成第帧的布局和记录绘制操作，立即通知合成线程对第一帧进行渲染，然后内核线程就开始准备第帧的布局和记录绘制操作。由此可以看出，内核线程在进行第帧的布局和记录绘制操作同时，合成线程也在努力进行第帧的渲染并交给屏幕展示，这里利用了多核的特性进行并发处理，因此提高了页面的渲染效率。由此也可知，实际上用户看到的页面内容，是上一帧的内容快照，新的一帧还在处理中。
要优化第个问题，对浏览器来说非常困难的。只要输入事件要在内核线程执行逻辑，那么遇到内核线程在忙，必然无法立即得到响应。如用户的大部分输入事件都跟页面元素有关系，一旦页面元素注册了对应事件的监听器，监听器的逻辑代码必须在内核线程中执行引擎是运行在内核线程，因此这种输入事件经常无法立即得到响应的。
由上面的分析知道，用户的输入事件无法立即得到响应，是因为需要派发给内核线程处理。那有没有一些输入事件是可以不经过内核线程就能被快速处理的呢？答案是肯定的。
在中，这类可以不经过内核线程就能快速处理的输入事件为手势输入事件滑动、捏合，手势输入事件是由用户连续的普通输入事件组合产生，如连续的事件可能会生成等手势事件。手势输入事件可以直接在已经渲染好的内容快照上操作，如滑动手势事件，直接对页面已经渲染好的内容快照进行滑动展示即可。由于线程化渲染框架的支持，手势输入事件可以不经过内核线程，直接由合成线程在内容快照上直接处理，所以即使此时内核线程在忙碌，用户的手势输入事件也是可以马上得到响应的。大家可以搞一个简单的验证一下浏览器的这个特性：如在一个有滚动条的页面内通过执行一段死循环的代码之类的，这个时候再去尝试上下滑动页面，你会发现此时页面仍能流畅地滑动。
由此可知，浏览器对于手势输入事件的响应是非常快的，因为它可以不需要经过内核线程，直接由合成线程快速处理。然而手势输入事件的产生可能需要内核线程，这会导致对手势输入事件的优化效果大打折扣。由前面介绍知道，手势输入事件是由连续的普通输入事件组成，而这些普通的输入事件可能会被对应的事件监听器内部调用函数来阻止掉事件的默认行为，在这种场景下是不会产生手势输入事件。如连续的事件默认可以产生事件，但是如果监听器内部调用了函数，那么这种情况下则不应该产生手势事件的。浏览器只有等内核线程执行到事件监听器对应的代码时，才能知道内部是否会调用函数来阻止事件的默认行为，所以浏览器本身是没有办法对这种场景进行优化的。这种场景下，用户的手势事件无法快速产生，会导致页面无法快速执行滑动逻辑，从而让用户感觉到页面卡顿。
而团队从统计数据中分析得出，注册了相关事件监听器的页面中，的页面内部都不会调用函数来阻止事件的默认默认行为。对于这的页面，即使监听器内部什么都没有做，相对没有注册事件监听器的页面，在滑动流畅度上，有的页面增加至少的延迟，的页面甚至增加以上的延迟。团队认为对于统计中的这的页面来说，他们都是不希望因为注册相关事件监听器而导致滑动延迟增加的。点击这里 可以体验页面注册后导致的滑动延迟，如上图。
如果能让开发者来明确告诉浏览器，监听器内部不会调用函数来禁止默认的事件行为，那么浏览器将能快速生成手势输入事件，从而让页面响应更快。
介绍完这里，大家应该明白浏览器为什么需要  特性了。接下来，我们来看看  特性是怎么实现的。
  的实现
为了更好地理解  特性，我们接下来了解一下它的实现过程。如上面代码所示，假定页面中注册了事件的被动监听器，此时用户开始滑动鼠标滚轮来滑动页面。如上图所述，用户的鼠标滚轮事件_由操作系统内核捕捉后，操作系统会将该事件派发给浏览器的线程处理。线程内部将系统的_事件转换为的事件后，接着通过通道派发给合成线程的输入事件处理器处理。
合成线程的输入事件处理器收到事件后，内部先会查询事件监听器的类型属性，然后根据监听器的类型属性值来进行不同逻辑的处理。
目前中监听器的类型属性值主要有四种：，，，，如下代码所述。
在中，和类型属性的处理逻辑是一样的，这个不难理解，只要存在一个非类型的事件监听器，那么都有可能阻止事件的默认行为。接下来，我们了解一下不同类型属性监听器的实现逻辑。
场景  类型
当事件监听器的类型属性为时，意味着当前页面内没有注册对应事件的监听器。对于这种场景如上图中的 分支，合成线程会马上发送一个的消息给线程，线程收到的消息后，会判断该事件是否被消费，即调用了，如果已经被消费，则什么都不做。否则，线程会产生一个滑动手势事件如果当前不是在滑动过程，手势事件为，否则为，并滑动手势事件通过通道派发给合成线程处理，合成线程收到该滑动手势事件之后，直接对内容快照进行滑动处理，并展示给到屏幕上。这种场景下，由于没有涉及到内核线程处理，用户的输入响应会非常及时。
场景   或 类型
当事件监听器的类型属性为或时，意味着当前页面至少存在一个非类型的事件监听器。对应这种场景如上图中的 分支，合成线程无法知道对应的监听器内部是否会调用函数来阻止默认行为，此时合成线程只能将该输入事件派发给内核线程处理    。等内核线程执行完监听器的处理逻辑后  ，再发送一个的消息给线程，线程收到 的消息后的处理逻辑跟场景一致。这种场景下，手势输入事件必须等待事件监听器逻辑处理完成后才会产生并派发给合成线程处理，由于事件监听器逻辑的执行时机不确定，将非常容易导致用户的输入事件无法立即响应。
场景  类型
当事件监听器的类型属性为时，意味着当前页面只存在类型的事件监听器。对于这种场景如上图中的 分支，合成线程首先会发送一个的消息给线程，执行跟场景中一样的逻辑，同时将该事件派发给内核线程处理，执行跟场景相似的逻辑，但是在  完成后，不会再发送 事件的消息。这种场景下，实际上是场景和场景的组合，两个场景是并行处理的，因此用户的输入事件能会被立刻响应，也不会受到内核线程的事件监听器处理逻辑影响。
对于场景和场景的滑动，在中称为 模式，而场景则称为 模式。
总结
经过上面的分析，我们了解到了  特性是什么，  特性产生的背景及  特性的实现逻辑，这其中涉及到了的多线程渲染框架、输入事件处理等知识。

文章来自公众号：小时光公众号 


相关推荐
开发性能优化核心定义介绍篇
腾讯工程师的前端书单
插件网络相关接口的应用接《 ：云时代的数据库  中》
 性能测试结果
在这一节中，我们分享自年月 之后在生产环境运营的经验。首先介绍标准的工业基准测试的结果，接着是一些来自客户的性能测试结果。
 标准基准测试的结果
我们使用标准的基准测试工具和类似测试工具来进行测试，对比了和在不同场景下的性能表现。我们在带有  的实例上进行测试，除非特殊说明，这些实例的规格为 内存，    处理器。实例上的 设为。
 随实例规格扩展
在这个测试中，我们发现的吞吐量可以随着实例规格线性增长，在最高实例规格上吞吐量是或者的倍。而目前是基于的代码库的。我们在 系列实例，，，，上运行数据量大小张表的只读或者只写的基准测试。系列的每个实例的和内存数量是下一个比它大的规格的一半。


测试结果度量的是每秒钟读写的语句数量，如图和图所示。的性能随着实例规格的提升而翻倍，在最大的的实例规格上可以获得 和 ，是的 和  的五倍。
 不同数据集大小下的吞吐量
在这个测试中，我们发现的吞吐量远大于，即使使用更大的数据集且包括之外的数据。表展示使用的纯写入测试，使用大小数据集可以比快倍。即使是使用包含外数据的测试集，也比快倍。

 随用户连接数扩展
在这个测试中，我们发现的吞吐量可以随着客户端的连接数量而扩展。表展示了运行 基准测试的结果，测试中连接数从到再到。可以从 扩展到 ，的吞吐量在个连接左右时达到峰值，然后随着连接数扩展到而急速下降。

 随副本数扩展
在这个测试中，我们发现读副本的延时比低很多，即使处在更高的负载情况下。表展示了，随着负载从 到 ，读副本的延时从增长到。相反，读副本的延时从增长到。在负载情况下，的副本延时比低几个数量级。副本延时通过一个被提交的事务在副本上可见所需要的时间来度量的。

 随 扩展
在这个测试中，我们发现相对于，在像基准测试中有  的负载下也能表现的很好。我们在、、上运行 类似工具，运行实例规格为挂载为的。表展示了可以保持相对 的倍到倍的吞吐量，负载从数量、个连接，到数据、个连接。

 客户真实负载的测试结果
在这一小节中，我们分享一些客户在生产环境从迁移到的测试结果。
 应用程序在的响应时间
一个互联网游戏公司将生产环境的服务从迁移到实例的上。在迁移之前，网络事务的平均响应时间为。与之对应的，迁移之后的平均响应时间为，差不多有了倍的提升，如图所示。

 中执行语句的延时
一个教育公司主要业务是帮助学校管理学生的笔记本电脑，将他们的服务从迁移到了。和单条记录语句在迁移前的中位点和分位点如图和图所示。

在迁移之前，分位延时在到之间，比中位点差得远了。本文之前介绍了，应用程序会遇到这种少数性能极差的情况。在迁移之后，分位的延时显著降低，接近中位点延时。

 多个副本下的复制延时
如的所指出的，副本经常远落后于他们的写副本，会引起非常奇怪的。对于上面提到的那个教育公司，副本延时有时可能飙升到分钟而影响到应用程序的正确性，所以这些副本只能作为一个备机。与之相对的，在迁移到之后，个副本集的复制延时从未超过，如图所示。复制延时的显著改善让这家公司转移了一大部分应用程序的负载到只读副本上，既节约了成本又提高了可用性。

 心得
我们遇到过运行各种各样的应用的客户，从小的互联网公司到大型的组织机构。他们很多的使用场景都是标准的，这里我们重点放在在云服务中比较常见的场景和期望，而这些导致我们走向了新的方向。
 多租户和数据库聚合
很多我们的客户都经营服务，自己使用或者为他们自己的客户提供模型的服务。我们发现这些客户依赖的应用程序很难被改变。因而，他们通常将自己的很多客户集中在某一个实例上，使用库或者表来作为租赁的基本单位。这种模式可以节约成本：由于他们自己的客户不太可能同时使用，这样可以避免为每个客户申请一个单独的实例。举个例子，我们有些客户称他们自己有超过的客户。
这个模型与著名的多租户应用场景有很大的不同，他们将数据打包到一个统一的表中，按行来租赁。因而，我们发现很多客户有很多张表。生产环境中数据库表超过是非常常见的。这给一些管理元数据的组件，如字典，带来很大压力。更重要的是，这些客户需要保持高吞吐量和连接数，存储容量按使用扩展和收费，因为很难提前预知需要多大的存储，减少抖动，这样一个租户的峰值对其他租户的影响很小。支持所有的这些特性，而且很适合应用。
 高并发自动扩展的负载
互联网的负载通常需要应对突发事件引起的网络流的尖峰。我们有个重要客户在一个很火的全国电视节目时，遇到过一次远超过平时负载吞吐量高峰的流量，不过没有对数据库构成压力。为了支持这样的突发流量，数据库需要同时能处理很多并发的请求。在这种场景下也能处理的很好，因为它的底层存储系统扩展性极好。我们有很多客户每秒钟的连接数超过次。
 演进
现代应用程序框架如  深入集成了工具。因而，应用程序可以很方便的改变数据库的，然而却让们很难把握会如何演进。在应用程序中，这些称之为迁移，我们听到一线的称他们一周可能会有几十次迁移，或者会提前准备好策略来让未来的变更会比较容易。这些问题在中被放大，因为提供自由的变更语义，使用整表拷贝的方式来实现大多数变更。既然频繁的是一个现实问题，我们在中实现了高效的在线，为每一个数据页关联一个版本，通过的变更历史来解码单个数据页，用的方式按需将单个数据页更新到最新的。
 可用性和软件更新
客户对云上的数据库的一些迫切的期待与我们如何运营系统和如何给服务器升级可能是相互矛盾的。由于我们的客户主要用来作为一个服务支撑线上应用程序，任何的干扰都可能导致严重的后果。因而，很多客户对我们更新数据库软件的容忍度是非常低的，即使在六周内只计划的服务暂停时间也不行。我们近期发布了一个   特性，使得我们可以在保证已有的数据库连接不受干扰的情况下，更新服务器。
如图所示，的原理是，首先找到一个没有活动连接的实例，将实例的应用程序状态导出到持久化存储中，给引擎升级，然后导入应用程序状态。在这个过程中，用户的不受影响，对引擎的升级是无感知的。

 相关工作
在本节中，我们介绍其他人的贡献以及它们如何中采用的方案关联的。
存储计算分离。尽管传统的数据库系统都会被构造成一个庞然大物，近期有一些数据库方面的工作将内核解耦为不同的组件。举个例子，就是这样的系统，它分离了提供并发控制的事务组件，和提供恢复功能构建在的数据组件，其中是一个无锁、日志结构的缓存和存储管理器。和这些系统将事务的方法抽象成一个可扩展的服务，数据库系统的实现可以使用这些抽象。实现了一个多版本的分布式平衡树，将并发控制和查询处理器分开。比、、和在更低的层次将存储解耦出来。在中，查询处理器、事务、并发控制、 和访问方式是与日志、存储、故障恢复解耦的，后者被实现为可扩展的服务。
分布式系统。在分区的条件下，正确性和可用性的折中，以及序列化是不可能的是理论里有名的结论。更近一些的，的理论在中证明得到结论：一个高度可用的数据库系统在网络隔离的情况下不可能提供强一致性。这些结论以及我们对云级别规模的复杂且相互关联故障的经验，促使我们定下即使在一个不可用的条件下仍然保持一致性的设计目标。
等人研究了高可用事务，既不会受网络分区导致的不可用的影响，又不会导致高的网络延时。他们的工作说明了   不是兼容的。提供所有这些隔离级别，基于一个简化的前提：在任意一个时间点，只有一个写副本在生成日志，这些日志的在同一个有序空间里分配。
的提供外部一致的读和写，全局一致的指定时间点的读。这些特性可以让提供全局的一致的备份，全局的一致的分布式查询处理，全局的原子的更新，即使是在有事务正在执行的情况下。就像所描述的，是为读负载高的场景定制的，在读和写的时候依赖于两阶段提交和两阶段锁。
并发控制。 弱一致性以及隔离模型在分布式数据库中是众所周知的，也导致了乐观复制技术和最终一致性系统的出现。集中式系统的一些方案包括，经典的悲观锁方式，如中的的乐观锁方式，如中的分片模式，中的时间戳序列模式，还有。的存储服务为数据库引擎提供了一个本地盘的抽象，让引擎来决定隔离级别和并发模式。
日志结构的存储。日志结构的存储在年首先出现在中。最近的以及中的相关工作，还有在存储引擎栈中以多种形式使用了日志结构的技术，像一样，它们通过只写数据页的变更来减少写放大。和实现的都是纯粹的日志方式，并跟踪事务确认回复的最大的。
故障恢复。传统的数据库都依赖于类似的恢复协议来实现故障恢复，近期很多系统为性能的考虑选择了其他的路径。举个例子，和使用某种更新日志来重建它们的内存状态。类似的系统，使用 和状态机复制技术来避免故障恢复。介绍了使用每页的日志记录链来加快按需的的以加快恢复速度。跟一样，不需要恢复，这是因为只会将已经提交的更新写入存储。因而，不像，里的事务数量是受限制的。
 结论
我们在云环境下将设计为一个高吞吐量的数据库，不牺牲可用性和可持久性。主要的思想是避免传统数据库庞大复杂的结构，将存储和计算解耦。具体来说，我们将数据库内核最下面一小部分移到一个独立可扩展分布式的负责日志记录和存储数据的存储服务中。由于这时所有的都通过网络，我们最根本的限制变成了网络。因而，我们将重点放在缓解网络开销、增加吞吐量的技术上。我们依赖的技术有：多数派模型—可以处理在大规模云服务环境下复杂关联的故障，避免最差性能点的惩罚，通过日志处理来减少整体的负担，异步的一致性来避免沟通复杂且代价昂贵的多阶段同步协议，离线故障恢复，在分布式存储中建立检查点。我们的方案能得出一个简化的复杂度降低的系统，可以很方便的扩展，并为以后的演进奠定基础。
 致谢
在此，我们对开发团队的所有成员的努力表示感谢，包括现有的成员，以及我们优秀的同事们 ， ，       。我们要特别感谢我们的客户，他们在生产环境使用我们的服务，并且给我们分享他们的经验和期望。同时，我们也要感谢评审们的宝贵意见。作者：
团队：腾讯移动品质中心

前言
的使用本身十分容易，配置好环境后，即可选择自己熟悉的语言快速的编写脚本。花费力气引入设计模式增加首次构建难度，主要是为了以下两点：
、减少维护成本。
产品往往界面变动频繁，如果每次更新后都需要花大量时间更新用例，自动化测试的收益大大降低。长期使用问题会越积越多，最后导致自动化方案破产。良好的设计模式能够减少重复代码，将元素操作与用例实现隔离开来，增加用例层的可读性，减少元素属性变化带来的测试用例重构工作，使得用例维护更加容易。
、增加用例稳定性。
现在的前端存在大量与元素操作，如果采用简单的面条代码编写用例，需要重复地去解决前端的等待和元素刷新等操作带来的、、等异常。
一、 设计模式简介
 设计模式是官网推荐的一种自动化构建模式。设计模式对网页进行一个简单抽象，将每个页面设计成一个类，页面元素定位、元素操作、用户行为都被封装进对应的类。编写测试用例时不再直接操作页面元素，而是调用对应页面类的方法。使得测试人员在编写用例时能更多的关注业务逻辑，而不是页面结构与元素。

举个简单的例子，假设待测产品包含两个页面：登录页、个人中心。需要编写一个测试用例，实现用户登录并且点击签到按钮的过程。
用传统的线性方法实现时，用例逻辑、元素查找、元素等混在一起。如果是做冒烟测试或者简单页面的测试可以选择这种方式：

采用 模式实现该用例的简要步骤如下：
第一步，为每个页面创建一个，页面内包含此页面元素的定位和行为：

第二步，调用创建的页面来编写用例：

虽然初始构建工作量更大，但是在产品变更频繁时，使用模式的优点明显：
、测试用例的代码和页面元素操作的代码分离，用例可读性；
、同一个元素的定位器不会出现在多个用例中，元素变更时只需要修改元素所在页面类；
、登录的方法可以复用于多个用例中，如果产品登录流程发生变动，只需要修改登录页登录方法的实现。
为了在页面里更好的管理定位器和减少元素查找的代码量，提供了类，使得我们在实现页面类时只需要用注解描述元素定位即可。调用元素的各个方法时，工厂类会自动根据定位器实时查找元素，在减少代码量的同时还能够帮忙避免刷新带来的不稳定，详细使用见官网。
二、 基于控件的实现
既然设计模式这么棒，那为什么不直接拿来用呢？原因是在自动化工程的建设过程中，作者发现不同页面之间的元素存在复用，页面并不是最小的单元，控件才是。这也是目前许多产品的特征，基于一套开源或者自研的前端控件库，页面结构由控件组成。同一控件的不同实例结构类似，用户在页面上的操作可以看作是对各类控件动作的组合。
对这种类型的产品如果直接采用 模式构建自动化测试，会导致在页面里重复对同一种控件的内部元素进行解析和操作，造成了大量重复代码并且加大了维护的难度。因此本次自动化测试工程的构建从控件出发，对每个控件的属性和方法进行封装，通过不同控件方法的组合来模拟用户操作，通过对用户操作的组合实现用例的自动化。如下图，自动化测试框架现在从下往上分为三层。

控件层，对前端所用控件在自动化工程中的抽象，继承自基类，基类中包含返回元素引用的方法、查找子元素的方法、等待元素加载的方法等。派生的控件类包含各自特殊功能的实现，如小说目录包含翻页、按钮功能包含点击、导航栏包括后退等。
工具类层，包含两部分。
第一部分是一个控件查找类，可以根据、 等返回对应的控件。
第二部分是按照功能区划分的类，以本产品为例，按照找书、读书、个人中心等功能区创建了、、等工具类。这些类继承自，各个内通过对各种控件方法的组合对用户常见动作进行模拟。
用例层，继承自，内包含了用例执行前准备、用例结束后数据清理、失败截图、管理等功能。的划分按照产品用例类别进行划分，每个中包含多个用例，用例的编写依靠对工具层用户行为的组合。控件层和工具类层的实现在下一章结合具体问题给出。
基于这种模式，最后实现的用例如下：

三、提高测试稳定性
异步和元素更新给自动化测试的稳定性带来了巨大的挑战，下面列举了常见的几个问题和它们在该模式下的解决办法。
、查找元素时遇到
出现此问题一般是因为的查找操作在元素加载之前就已经结束。许多测试脚本在这里会选择用来等待元素加载，但是等待时间如果选大了浪费，选小了元素可能还没来的及加载。这种问题在此设计模式中可以用工具类集中解决，在根据定位器查找控件时，等待控件元素在页面出现，然后再返回对应的控件。

这里举的例子为每个控件都创建了一个查找方法。如果被测产品的控件提供返回控件名的方法，可以在查找到元素后，用调用该方法返回控件名称，然后通过反射返回对应控件的实例。这样能实现一个查找方法查找多种控件。
、
这是测试脚本常见的异常，出现此问题的原因一般是所操作的元素被刷新了。如下图的搜索页面的提示词，红框圈出来的提示词在页面中的层级一致，元素属性一致，但是从左图到右图，该提示词所在的元素其实是被刷新过，两个看起来一样的元素在看来有着不一样的 。就像两个人即使长得一样，但是身份证不一样，并不是同一个人。

现实现这样一个用例：
搜索“雪”，检查第一个提示词。
然后再输入“中”，检查第一个提示词。
 问题写法如下：

上图代码在第二次调用时，元素已经被刷新，所指向的元素已经不是最初的那个元素了，因此会抛出异常。这类解决思路是，在输入“鹰”之后，重新查找一次该元素，于是有以下代码：

但是上面的代码运行过程中还是会有一定概率抛出
，抛出异常时的执行顺序如下图。脚本输入“中”之后，前端准备更新提示词，在更新完成之前第二次查找提示词元素的脚本已经执行了，这是还是指向=的元素，然后前端完成更新，测试脚本调用。因为此时=的元素已经不在页面上了，所以程序出错。

下面看一下这个问题在该设计模式下的处理方法：
首先在控件基类中定义一个方法，此函数根据控件的定位器查找控件，并等待控件可见。

然后编写控件的类，控件包含一个检查文本的方法，该方法在默认等待时间内循环检查控件的文本。
如果元素查找和获取元素文本都发生在刷新之前，那么获取的文本是刷新前文本，循环继续。
如果刷新发生在元素查找和获取元素文本之间，则抛出异常。异常被处理，程序继续循环，下一次即可正常获取文本的值。
如果元素查找和获取元素文本都发生在刷新之后，程序获取到最新值，检查通过。
如果刷新超时，不通过。
这样当刷新后，测试程序马上获取到更新后的文本。如果超过规定的响应时间，也认为是待测产品异常，用例不通过。

下面是用自定义控件实现用例的代码，通过实时查找实现了控件变量的一次声明多处调用。

、   
出现这个问题一般有三种原因：
该元素处于非点击状态
该元素被其它元素遮挡
该元素处于浏览器窗口外
为了规避第一种情况，在实现控件的点击方法时，应该先等待其变成可点击状态。
对于第二种情况，在浏览器上这种被遮挡的元素本来就不应该对其进行操作，应该尽量避免操作被遮盖的元素。
第三种情况是使用时特有的异常，点击视野外的元素时有一定概率触发异常，官方傲娇的表示不修复此问题。为了提高这里的稳定性，在点击之前应该利用的移动到待点击元素。
综上，一个安全的点击事件应该长这样：

获取更多测试干货，请搜索微信公众号：腾讯移动品质中心！
版权所属，禁止转载！前言
机器学习技术为现代社会的许多领域提供了强大的技术支持：从网络搜索到社交网络的内容过滤，再到电子商务网站的产品推荐。机器学习技术正越来越多的出现在消费级产品上，比如照相机和智能手机。 机器学习系统可用于识别图像中的对象，将语音转换成文本，选择搜索结果的相关项，以及匹配新闻、帖子或用户感兴趣的其他东西。 类似的应用越来越多，它们都使用了一种叫做深度学习的技术。
深度学习也称为深层结构学习、层次学习或深度机器学习是基于对数据中的高级抽象进行建模的算法，它属于机器学习的分支。最简单的例子，你可以有两组神经元：接收输入信号的神经元和发送输出信号的神经元。当输入层接收到输入时，它将输入的修改版本传递给下一层。在深层网络中，输入和输出层之间有很多层层并不是由神经元构成，这里只是为了帮助你思考，这些层允许算法使用多个处理层，这些层包含了多个线性和非线性变换。
近来，深度学习技术使得机器学习发生了革命性的变化，并出现了很多伟大的成果。 它们大大改进了语音识别、视觉对象识别、对象检测以及许多其他领域如药物发现和基因组学的技术。 “深度学习”这个术语最早由引入机器学习，由等人引入人工神经网络。 深度学习的进一步普及得益于由 发明的被称为“”的卷积网络架构的出现。“”在年的比赛中击败了其他所有的图像处理算法，开创了在图像处理中使用深度学习架构的先河。
深度学习架构

生成式深度架构，旨在描述用于模式分析或合成目的的观测数据或可见数据的高阶相关特性，以及描述可见数据及其关联类的联合统计分布的特征。在后一种情况下，使用贝叶斯规则可以将这种类型的架构变成辨别式深度架构。

辨别式深度架构，旨在直接提供模式分类的辨别力，通常通过描述基于可见数据种类的后验分布来描述。

混合式深度架构，其目的是辨别，但通常辅以通过更好的优化或规则化的生成架构的结果，或者是其辨别标准被用来学习类别中的任何一个深度生成模型的参数


尽管深度学习架构的分类很复杂，但在实践中经常用到的有深度前馈网络、卷积网络和循环网络。
深度前馈网络
前馈网络，通常被称为前馈神经网络或多层感知器，它是典型的深度学习模式。
前馈网络的目标是逼近某个函数。例如，对于一个分类器，=表示的是将输入映射到类别。前馈网络定义了一个映射 =θ，并学习能产生最佳逼近函数的参数θ的值。
简单来说，网络可以定义为输入、隐藏和输出节点的组合。数据从输入节点流入，在隐藏节点中进行处理，然后通过输出节点产生输出。信息流经从评估的函数，通过用于定义的中间计算，最后到输出。该网络中没有反馈连接，其中模型的输出反馈到自身，因此模型被称为前馈网络。该模型如图所示。

图：前馈神经网络
卷积神经网络


在机器学习中，卷积神经网络或是一种前馈人工神经网络，其神经元之间的连接模式是受动物视觉皮层组织的启发而发明出来的。
个别皮质神经元对受限区域的刺激响应称为感受野。不同神经元的感受野部分重叠，这使得这些感受野像瓦片一样平铺。
单个神经元对其感受野内的刺激的反应可以用卷积运算近似地数学化。卷积网络的灵感来自于生物学，是多层感知器的变体。它在图像和视频识别、推荐系统和自然语言处理中具有广泛的应用。
是第一个卷积神经网络，它推动了深度学习领域的发展。自年以来， 的这项开创性工作多次成功迭代后成为了。当时的架构主要用于字符识别，如阅读邮政编码、数字等等。

图：一个简单的卷积神经网络模型
有四个主要组件，如图所示：

卷积层
激活函数
池化层
完全连接层

卷积层
卷积层基于术语“卷积”，它是对两个变量执行数学运算，以产生第三个变量。 它与互相关类似。 卷积层的输入是一幅      的图像，其中是图像的高度和宽度，是通道数，例如，对于图像， =  。 卷积层有大小为    的个过滤器或内核，其中小于图像的维度，并且小于等于通道数，并且每个内核都可以不同。
激活函数
要实现复杂的映射函数，需要有非线性的激活函数，这样引入非常重要的非线性属性，使之能够近似于任何函数。激活函数对于压缩来自神经元的无界线性加权和也是非常重要的。这对于避免在处理层次上积累高值非常重要。有很多经常被用到的激活函数，比如、和。
池化层
池化是一个基于样本的离散化过程。它的目标是对输入表示图像、隐藏层输出矩阵等等进行降采样，减少其维度，并允许对包含在子区域中的特征进行假设。
这样做的部分原因是为了提供一种抽象的表示形式来避免过度拟合。同样，它通过减少要学习的参数个数来降低计算成本，并为内部表示提供基本的转化恒定性。
比较突出的池化技术有：最大池化，最小池化和平均池化。

图：过滤器的最大池化示例
完全连接层
术语“完全连接”意味着上一层中的每个神经元都连接到下一层的每个神经元。完全连接层是传统的多层感知器，它使用激活函数或输出层中的任何其他类似函数。
循环神经网络
在传统的神经网络中，我们假设所有的输入和输出是相互独立的。但是对于许多的任务来说，这是一个很糟糕的假设。如果你想预测一个句子中的下一个单词，你最好知道哪些前面的单词是什么。 之所以称为循环，因为它们对序列的每个元素执行相同的任务，而输出依赖于先前的计算。还有一种理解的方法，我们可以认为它有“记忆”的，它会捕获到截至目前计算出来的所有信息。
中有循环，这使得在读入输入时能够跨神经元传递信息。在图中，_是某种输入，是的一部分，_是输出。有一些特殊的类型，比如、双向，等等。

图：模型
可用于、机器翻译、语言建模、计算机视觉、视频分析、图像生成、图像字幕等，这是因为在中可以放置任意数量的输入和输出，并让它们一一对应、多对多对应。它架构存在多种形式，如图所示。

图：描述了对矢量序列的操作
应用
在深度学习领域已经有了很多的研究，并且有很多特别的问题都使用深度学习模型得到了解决。这里有一些深度学习方面的优秀应用：
黑白图像彩色化
深度学习可用于参照照片中的对象及其上下文来对图像进行着色，就像人类进行着色一样。这个应用需使用非常大的卷积神经网络和监督层，通过添加颜色来重现图像。
机器翻译
文本翻译可以在没有对序列进行任何预处理的情况下进行，它允许算法学习单词之间的依赖关系及其与另一种语言之间的映射。大型循环神经网络的堆叠网络可用于机器翻译。
照片中物体的分类及检测
该任务是将照片中的对象归类到已知的对象组中去。在样例评测中，通过使用非常大的卷积神经网络能够获得非常好的结果。  等人在分类中取得的突破性成果，被称为。
自动手写生成
给定一个手写示例语料库，然后为给定的单词或短语生成新的笔迹。在笔迹样本被创建时，笔迹将作为一系列的坐标提供给笔。通过这个语料库，算法会学习笔的运动与字母之间的关系，然后生成新的示例。
自动打游戏
在这个应用中，模型将学习如何仅基于屏幕上的像素点来玩电脑游戏。这在深度增强模型领域中是一个非常难的任务，因为这个，现在是的一部分赢得了很高的声誉。
生成模型聊天机器人
使用基于序列的模型来创建聊天机器人，该机器人在很多真实的对话数据集上进行训练，并学会生成自己的答案。要了解更多的详细信息，请访问这个链接。
总结
从本文可以得到这样的结论：深度学习模型可以用于各种任务，因为它能够模拟人脑。截止目前，专家们已经在这方面做了大量的研究，而且在不久将还有许多研究工作要做。尽管目前还存在信任问题，但在不久的将来，这个问题将会变得更加明朗。

文章来源于全球人工智能微信公众号作者：廖海珍
团队：腾讯移动品质中心

背景
自动化建设是质量和效率提升的一个基础手段。从各产品业务测试的角度上，在自动化测试上有了一定的积累。从整个品质中心上，各个组都在支撑多产品的质量保证工作。出于提升自动化建设基础服务的专业度和深度，同时减少重复建设的成本，年品质中心成立联合项目，有组织性协作开展中心层面自动化体系和自动化平台的建设工作。
本人在月份加入自动化建设团队，角色。主要负责项目的管理，运作等。以下是在项目实践中几点经验教训的总结。主要分两个方面，一个是技术上，一个是运作管理上。供各位有相关工作的同学做参考。
若对总结有异议，欢迎共同探讨。
技术上
经验一，系统分层实现。
我们整个自动化平台主要有四个子系统，任务系统，用例系统，资源系统和报表系统。以下是整体的架构图。

前期的想法很简单，每个人认领一个系统开发，这样各自比较独立，只需要沟通好对应的接口即可。这样的做法，起初确实能快速的把整个自动化平台搭建起来了。但是随着规模和用户使用上来，出现了一个问题，即慢慢的由原先任务系统对用户有页面交互外，用例和资源系统逐渐出现较复杂的交互页面。如用例系统需要用户配置用例工程代码路径，用例选择更复杂的能够配置是否需要并发，怎么并发。资源系统需要能够展示资源列表，配置标签组等。
而这些由系统各自开发人员开发，就会带来一个问题：一个系统开发需要掌握后台和前端两块的开发，而每个人的经验不一样，有些没接触过，有些接触过又各自熟悉语言不一样，这样就导致前端页面的交互开发速度慢，风格不一致，且选取实现的语言也会不统一。这是早期为了快速实现功能遗留的技术债，没有合理的做系统分层。因此在今年上半年，随着前端人力的加入，慢慢的将前端的开发专人负责，分层实现。
这样带来的好处是：一是页面交互体验，不涉及接口的变动，可直接由专人修改；二是，在开发效率上，专人专职，熟练度和深度都有提升，交付速度也能随之提升。
分层后人员分工简单如下：

经验二，适当采用公司或外部的三方公共服务。
这一点，我们在早期开发时，就快速达成结论，不用临时的本地系统和数据库，防止随着代码工程规模的变化，增大改造成本。如，，等，都在各系统开发时就直接使用公司或外部的三方服务。三方服务上，经验是，主动去和有经验的人请教，这样可以节省大部分盲目网上查看资料的时间。这里感谢期间请教万松，各种问题，省得走一些弯路。当然，真正采纳使用还是需要花时间和精力去熟悉细节。
经验三，增强产品思维，同时做好基础质量的保证。
开发中，很多想法和使用都是理所当然或是希望提供更灵活的操作给到用户，也就出现了用户使用很茫然，体验不佳的情况。在我们没有专业的产品设计时，很多时候就需要自己跳出开发实现的细节，增强自身产品的思维，从用户的角度去设计实现。还有整体后台的基础质量也应该抓起来，从代码到各纬度自动化测试都尽力覆盖到，保证发布无严重质量问题。这一块我们做的比较薄弱，希望能不断加强。
管理上
经验一，迭代开发，日常工作模版化，共同分担。
因为团队比较特殊，都是各组抽调一二人联合支撑平台建设，因此出现四地的局面，这样导致异地沟通成本极高，每次组织一次讨论或晨会都是很耗时间，而且沟通效率也大打折扣。我们采取的方法是，首先大家节奏要一致，两周一个迭代开发，迭代开始会有总结和开工会，全员了解本次迭代的重点工作内容。其次，日常的工作，如晨会，周报，缺陷情况，发布情况，迭代规划等事项分别各人承当一个，责任田制，互相配合，共同分担。而非一人管理，即没有成长，而其他人又处于被动状态。 
经验二，主动和各业务测试团队共同建设，防止闭门造车，偏离价值。
相较于去年的平台建设，今年更多的关于业务侧自动化的使用，从需求入手，共同建设自动化测试体系。 
经验三，主动思考和邀请各团队和老大们共同讨论。
在整体的目标规划上，也更积极的主动和思考，同时请教各团队和老大们的意见，希望整体的工作更贴近业务的价值。
获取更多测试干货，请搜索微信公众号：腾讯移动品质中心！导语
在过往的服务型的架构下 我们都会采用如  等等 来进行服务间的合约变换   服务编排   以及服务与第三方软件间的整合。 而在微服务的架构下 我们是否应该继续采用如  等等 
前言
在微服務的核心概念中   主要是在微服务与微服务外部的使用者界面、系统或设备之间构建   与  。
所以 在微服务的架構中 架构师规划   如  …等等 以使微服務間可进行  合约变换   服务编排   并使微服务可整合第三方软件     应该是个合理且正确的架构方案。 

图一    主要是在微服务与微服务外部的使用者界面、系统或设备之间构建   与  
本文
但是 在微服务的架构中 规划所谓的   往往却会为微服务的架构 引入下列的问题
 性能 
微服务架构最主要的特点便是 能使产品的架构能够 “水平扩展”。所以 架构师应将不论是微服务之间的调用或是来自微服务外部的使用者界面、系统或设备的调用 都应当成是 “分布式远程调用”。
因此 假如 在已是 “分布式远程调用” 的微服务架构下 再置入个 “远程调用” 的   则产品的整体性能将会受到某种程度负面的影响。
 复杂度
微服务的分布式架构的复杂度是相当高的。所以 架构师在微服务的架构下 置入   时 则会使原先只会发生的微服务的分布式远程调用 便会需先发生   的远程调用 然后 才会发生微服务的分布式远程调用。毫无疑问的 这将使当发生运维问题时 如 某笔交易的资料丢失时 增加问题定位的难度与时间。因为 整体架构的复杂度已因   的置入 而更往上提升。
 边界上下文   
当架构师在微服务的架构中置入   时 则表示各微服务都可将自身部分的功能 业务流 上升至   中做处理。如此的作法 将使各微服务可能会在   中 发生共享。也就是说 当各微服务的边界上下文   不仅包含了各自的某一端到端的业务场景 功能 、数据 数据库 外 更包含了  时 将使得微服务的边界上下文   的界定 变得相当的棘手 甚至不可行。也就是说 各微服务的边界上下文   将因包含了   而使得各微服务间会发生共享 使得各微服务 很难再维持完全自主性的运作。
 部署流水线  
当各微服务都可将自身部分的功能 业务流 上升至   中做处理时 则表示当部署某一微服务时 也需同时部署   而部署与配置   往往需耗时整晚 甚至是数天。
 开发与测试
当架构师在微服务的架构中置入   时 则表示不论是开发或测试人员都必需花费时间去学习   如   …等等。
 可靠性与坚固性
当来自微服务外部的使用者界面、系统或设备的调用 都需经过   时 则就意味著当   无法运作时 则将使得微服务都将无法被调用。
既然   会为微服务的架构引入上述的问题 则身为个架师 在微服务的架构下 针对合约变换   服务编排   整合第三方软件     的设计原则、方法是什么
   设计原则
不置入   而完全以可独立自主的微服务 个别处理合约变换   服务编排  整合第三方软件    。
  设计方法
合约变换  
微服务  只能接受 。所以 当外部的使用者界面、系统、设备或其他微服务传送  至微服务  时 微服务  便需所谓的合约变换   将  转换为  或将  转换为 。
合约变换   有两种作法

由另一个微服务  专注将合约变换   做到最好。当整个产品中 多数的微服务都需合约变换   时 便需采用此方案。

在既有微服务  新增一新的  处理合约变换   。当采用此方案时 需注意 原微服务  是否会因为新增此合约变换   而变的过于复杂。




图二 由另一个微服务  专注将合约变换   做到最好 

图三 在既有微服务  新增一新的  处理合约变换   
服务编排  
当微服务的架构中 没置入  时 便没有一个指挥者会指挥著 现在应调用微服务  然后 接下来应调用微服务 … 等等。
微服务的特点便是每个微服务都有个明确的边界上下文   而可自主的运作。所以 在微服务的架构中 可直接采用服务编舞   的方式 由微服务自身决定需调用那个微服务 而不需经由某一个指挥者 来指挥接下来应调用那一个微服务。

图四 服务编舞    由微服务自身决定需调用那个微服务 而不需经由某一个指挥者 来指挥接下来应调用那一个微服务
整合第三方软件    
我想 大家也许已经知道该怎么做了 针对每一个对第三方软件的调用 开发一个  。由   调用第三方软件。也就是说 第三方软件 可藉由  所提供的单一共同的协议  如  进行分布式的调用。
这种架构上的作法 也可应用在既有系统 还没法转移到微服务的架构时 可针对每一个对既有系统的调用 先开发一个  。然后 再逐步将既有系统的功能、场景转移到相对应的   中。如此 当既有系统的功能、场景转移到相对应的   中后 也不必再重新修改 原先会调用   的外部的使用者界面、系统、设备或是微服务。

 图五    
结论
轻装上阵 一直是微服务架构下的一个核心的设计原则。
 我们遵循著 轻装上阵 的设计原则 针对在微服务架构下 如何设计

合约变换  

服务编排 

整合第三方软件   


提出设计上的思路与作法。
期望大家在微服务的架构下 当在设计合约变换   服务编排  与整合第三方软件    时 能参考本文的作法 以使自身的微服务可 輕裝上陣 永保微服务的可扩展性。作者：徐嘉伟，腾讯前端开发 高级工程师
商业转载请联系腾讯获得授权，非商业转载请注明出处。
原文链接：

 导读
一项指标的变好，总少不了相应优化策略的实施。优化并不是简单的一蹴而就，而是个不断迭代与推翻的过程。更深层的优化方案，往往是在某种思维策略之下，对问题场景和基本策略优缺的深刻理解后做出的当下最优的权衡结果。本文笔者从前端高并发优化这一具体点出发，逐步向大家阐述笔者在优化的“术”之上思维层面的一些思考。希望能给各位带来共鸣和感悟。
背景：
之所以会以前端高并发这一主题入手，一来是本人曾负责过一些超高并发量的业务手红包，在这方面算是有些经验。二来是相对于业务功能优化这类光前端层面的逻辑就涉及产品、设计等多方人员合作讨论而完成的优化即逻辑本身并非纯出自前端人员的脑子，前端高并发这种前端层面逻辑纯由前端人员全把控的优化，或许作为前端的我，能得出来的思考观点会更深刻和更通用一些。
一、普遍的优化思路
说到优化，大家在收到“优化指标”任务的时候。通常会做两件事情——分析“优化指标”对应的痛点、寻找解决痛点的技术方案并施行。那这样是否就足够了呢？我的答案是否定的。在我的认知里这只是第一层的优化，虽然在结果上往往我们使用更优的技术后确实可以达到更好的优化效果，但却又不那么完美，优化效果还可以做得更好。那究竟缺了什么呢？下面，我会逐步阐述我的优化思路。首先，普遍的优化思路是基础，我们先来看看在普遍的优化思路下，基本的前端高并发策略是怎么样的？
二、分析本质痛点
高并发场景，与普通场景的核心区别是并行的访问量激增。因此，前端高并发策略本质要解决的是由访问量激增带来的问题。那访问量激增带来的是什么问题呢？
我们先来看一张正常的访问流图：
正常情况下，从用户端到后台的数据流动是很均衡的，用户的访问量在后台可承受的范围内。
而在高并发场景下，若不进行任何的高并发策略应对，原访问流图会变成这样前端到后台红色部分的请求会被后台拒掉甚至可能会击垮后台：
图中可以很明显地看出高并发的痛点：数据流动过程两端失衡了。解决这一痛点，需要把两端重新回到数据流动的平衡状态。可以从两方面着手，一方面是后台层面尽可能地提供更大的承载能力如增加机器等；另一方面则是在前端层面尽可能地加强其作为用户与后台之间的“门”的精简过滤能力。
加强前端“门”的精简过滤能力后，我们期望看到的访问流图是这样的：
虽然用户并发量很大，但在前端高并发策略下，两端失衡这一痛点得到了解决。那这些高并发策略都有哪些呢？我们来一个个地寻找。
三、寻找可行技术方案
前端“门”的角色要加强的是两方面的能力，一个是精简，另一个是过滤。
精简
首先，我们先看精简的技术方案。如果把后台的承载能力比作成一个“圆”，那前端和后台之间的通道就相当于一个以此圆为出口宽度的水管，其中的水可以理解为中的请求。而这样的圆在中，实际有两个，一个是最大并发数、一个是最大流量。对应的则是我们并行请求中的请求数和请求大小，精简这两者，即可在“圆”的面积固定的情况下，提供更多的“水”进出。
所以，在精简的技术方案上，需要能针对并行请求中的请求数和请求大小进行精简。
、请求数精简
当请求数从逻辑层面已无法再精简时如去掉一些无用请求，这时我们往往会将焦点聚焦到纯技术方案上。
请求数精简的方案，目前大致方案如下，核心为：合并。
图中列出的是中常用的资源类型还有别的如视频、音频，不一一列举。可以看出，就图中列出的目前的技术，对于请求数的减少，可以说要多极致可有多极致。极端情况下，一个业务只有一个请求也是可以做到的。
、请求大小精简
同样的，当请求大小从逻辑层面已无法再精简时如去掉一些无用函数、代码，这时我们往往会将焦点聚焦到纯技术方案上。请求大小精简的方案，目前大致方案如下，核心为：压缩。
可以看到，就目前的技术，对于请求大小的精简，每种资源都可以进一步的压缩精简。
过滤
上面说的是前端“门”精简能力的技术方案，那下面我们再来看下前端“门”过滤能力的技术方案。还是刚刚水管的比喻，前端的过滤，可以理解为在前端“门”上加了一层可反弹特定水的网，用于把无须进入的水反弹掉不知道这个比喻于水而言是否恰当，总之要表达的就是类似这么个道理。能把“水”反弹的方式有很多种，一种是被动式的，即只允许特定量的水通过，超了的部分就进不来了，这策略一般用于后台，叫“过载保护”；另一种则是主动式的，通过对数据时效性的牺牲把数据往更前的一端进行储存。在前端层面，一般叫“本地缓存”，当请求时发现前端有缓存的内容，就不用再去访问服务器了。
所以，在过滤的技术方案上，前端可以通过缓存来完成。
、缓存过滤请求
请求过滤的方案，目前大致方案如下，核心为：缓存。
通过具体的前端缓存技术，可将原本需要通过到达后台的请求直接从前端缓存处获取而达到“过滤”的效果。
四、普遍优化思路下的基本策略
完成上述两步——分析本质痛点、寻找可行技术方案，接下来大家普遍的做法是选择其中的合适方案，然后用到我们的项目中。对于合并，我们会把同类型的文件统一做下合并；对于压缩，我们会把没压缩的代码都统一做下压缩；对于缓存，我们统一启用较长的 、使用缓存、使用离线包。整体策略下来，虽然在一定程度上会有效果，但是我认为这往往又是不够的。要做到更彻底的优化，就需要对优化方案和优化场景本身做更深入的思考和策略调整。而这，往往是需要靠相应的思维模式驱动的。下面我来分别说说我总结出来的一些适用于更深层优化的思维，其中会着重谈谈差异化思维。
差异化思维
差异化思维，讲求的是在深入理解技术与场景后，对技术与场景进行差异化分解，以达到每个差异场景的进一步技术最优。
从前两步中——分析本质痛点、寻找可行技术方案，我们了解到高并发应对在前端技术层面可以从合并、压缩、缓存三方面着手。一个很浅显的道理是，这些策略做得越彻底，前端层面能挡掉的并发量就越多。但事实上，往往我们却又并不能这么做，而只能选取其中一种比较折中的方案。
比如，考虑到对页面访问耗时的影响，我们并不会把整个项目资源合并成为一个请求。原因在于，从本质上来说，每项纯技术策略，有其优点的同时，就必然会带来或多或少的缺点，正所谓万物有利必有弊。而当这个弊端成为了影响项目核心能力如体验方面能力中的页面访问耗时的时候，即使是能更好地提高并发能力的方案，在利弊权衡之后往往最终也并不会采用。这就是我前面说的只选择折中的优化方案时优化不够彻底的原因。
在利弊权衡之下，往往我们会选择一个折中方案如下图那样中选择的策略：
而更彻底的优化应该是，了解每个方案所导致的弊端影响，由弊端影响对项目场景进行差异化分析，按各场景对弊端影响面的容忍程度，实行策略方案的差异化。对于能接受弊端影响的场景，使用最优方案；而对于不太能接受弊端影响的场景，使用较优方案；依次类推到使用折中方案。从而做到差异化的精细优化。优化后的总体策略方案会变成类似下图的形式，原有项目只是单纯的使用折中策略，而差异化处理后，会抽离出部分项目模块使用更优的策略和策略。
下面，我会使用这种思维，对上面两步得出的前端高并发中的三种策略——合并、压缩、缓存进行进一步的差异化优化。
差异化的合并策略
代码合并，合并到一定程度其弊端就会逐步放大显露。
弊端有：单个请求过大，造成对页面首屏渲染耗时的影响；动静请求合并后＋，缓存时效性的要求会大大地提高缓存时效性取决于各合并资源中要求最高者，木桶原理。
根据每个弊端的影响，下面针对具体场景进行差异化分析。
、“资源首屏体验相关度”差异化分解
对于合并后单文件过大，其影响的是页面首屏渲染耗时。那我们可以从影响点出发，对页面网络资源请求按首屏体验相关性影响点进行差异化拆分，从而最大程度地减少合并对体验的影响。最简单的我们可以把资源分成两部分——高相关性资源首屏和低相关性资源非首屏。每部分资源单独策略处理，尽可能地做到极致的合并，提高并发能力。当再次遇到合并后文件太大而影响渲染耗时时，则在本级中再进一步分级，以此类推。如对于、首屏渲染相关的和图片资源，可作为高相关性资源，把图片进，然后再全部内联进页面，与页面合并。对于非首屏相关的和图片资源，作为低相关性资源单独合并。这样即可在不影响页面首屏渲染耗时体验的同时，又保证了最大程度的减少并发请求数。
、资源时效依赖度差异化分解
对于动静请求合并＋，其影响的是缓存时效性，导致缓存时效性要求变高。那我们也可以从影响点出发，对页面请求按时效依赖度影响点进行差异化拆分。最简单的我们可以把页面分成两类——高时效性要求页面入口不可控，本来就不做缓存和低时效性要求页面入口完全可控，可通过修改页面离线包等方式做更新，可缓存。对于高时效性要求的页面，动静请求合并后不会对该类页面有影响，此类页面可将和进行合并。而对于低时效性要求的页面，这类页面是可以缓存的如使用离线包，则不进行和合并。
针对具体场景，差异化地采用相应最优的合并策略，优化效果将会再进一步地提升。
差异化的压缩策略
同样的，代码压缩，也有其弊端。弊端有：压缩程度越高，代码可读性越差，不便于线上问题的定位；虽有更优的压缩算法，但算法本身又存在自身的局限性。
、“资源可读依赖度”差异化分解
对于代码可读性的影响，市面上其实已有代码层面的解决方案，如项目支持模式切换此解决思路就是一种差异化思维，按使用场景差异化分成代码可读性要求高场景和代码可读性要求低场景，如线上的代码属于代码可读性要求低的，采用极端压缩版的代码；开发模式下的代码属于代码可读性要求高的，采用非压缩版的代码，两种模式可参数化切换、等。
、“资源平台支持程度”差异化分解
对于各压缩算法的局限性或者说各压缩算法下的产物的局限性，如图片资源有多种格式，而每种格式又有其局限性，其影响的是其所不支持局限外的那部分平台，会导致那部分平台无法使用。那我们从影响点出发，可以对该网络资源按平台支持程度影响点进行差异化拆分。我们可以按压缩算法的压缩效果进行方案的排序，从高到低地对方案的平台支持程度进行差异化判断筛选，支持则使用当前算法类型格式，不支持则判断使用下一种算法类型格式。
例如对于图片资源，图片的格式丰富多样，多样的格式实际来源于每种格式使用的压缩算法的不同，都有其擅长的领域。这时，我们不能只用一种最普遍适用的格式，而应该利用上面的差异化思路来加载图片。按照各图片格式的压缩程度，对于支持公司内叫的平台请求格式图片，不支持的则再去判断是否支持；支持的平台则请求格式的图片，若不支持则再往下判断。而针对图片格式的擅长领域，对于色彩丰富的图片采用格式、色彩较简单或需要透明通道的采用格式，按最适合的进行图片格式差异化选取。甚至对于图片的尺寸尺寸与压缩无关，但目的都是为了减少请求大小，故用于类比，我们也可以采用这个差异化思路，如根据当前客户端的分辨率，返回最适大小的图片给客户端，从而做到高分辨率客户端请求返回高分辨率图片，低分辨率客户端请求返回低分辨率图片。
针对具体场景，差异化地采用相应最优的压缩策略，优化效果也将会再进一步地提升。
差异化的缓存策略
与上面的类似，缓存策略同样也有相应的弊端。弊端有：缓存时间越长，数据的准确性就越差，会存在缓存数据虽有效但已与最新数据有较大差异的问题。
、“资源时效依赖度”差异化分解
针对资源有效性受缓存时间长短的影响，我们可以对资源进行时效性分级。可大致分成更新可控资源和更新不可控资源。此处的可不可控指的是资源更新后页面能否实时感知到更新。对于前端开发人员部署的、、图片等资源，均可作为更新可控资源，设置极长缓存，因为这类资源更新的同时可以将版本信息实时同步给前端页面如拉取的文件改名了、改时间戳了等。而对于无法实时同步版本信息给前端页面的资源，可作为更新不可控资源。对于这部分资源，我们可以再根据业务对各资源的时效性要求程度进行差异化分级。
以手中的项目中用到的头像资源为例，此场景下头像是一个对项目更新不可控的资源。用户通过使用手或 修改自身头像后，各项目对于这个修改是无感知的，并不会实时地收到更新通知除非双方在接口层面上做同步通知。此时，如果头像缓存时间设置较长，就会出现用户更新了头像，但在项目中看到的头像还是旧的的情况。但如果不缓存，在高并发场景下势必对头像服务器造成极大的并发压力。这时，就需要对这一更新不可控资源做进一步差异化分解。
对于手中社交性较强的项目如手红包、手 收款等，其中虽然有很多头像，但是各头像对时效性的要求还是有差异的。最简单的我们可以把头像分成两类，高时效性头像和低时效性头像。稍作分析后，其实可以发现，对于使用者而言，用户自身主人态的头像变更是最敏感的，如果用户在手或 上修改完自己的头像后，进入该后发现自己的头像没有变是不太能容忍的。此时，用户自身的头像可作为高时效性头像。而对于其他用户客人态的头像的时效性，变没变，使用者其实倒不会太过在意，所以对于非用户自身的头像可作为低时效性头像。最后在策略上，对于高时效性头像，缓存一个较短时间；对于低时效性头像，则缓存一个相对较长时间。实现起来也很容易，可将差异化逻辑放在前端判断然后加时间戳决定缓存时间即可。
针对具体场景，差异化地采用相应最优的缓存策略，优化效果也将会再进一步地提升。
五、更多“维”的优化
在差异化思维的指导下，高并发优化策略得到了更进一步的完善。该思维的核心思想是针对方案的优缺与实际场景进行差异权衡。从通用性角度来看，这项思维也适用于工作上的很多事情，是一项通用化的思维，而并不仅仅局限于使用在解决前端高并发这个问题点上。同时，也并非所有的方案都只采用差异化思维就能完美地解决问题。差异化思维只是众多思维中的一种，实际上，还有很多思维。一个优秀的优化方案往往是在多“维”的思考权衡下的最终产物。
边界放大思维
比如，边界放大思维，指的是我们在做一项事情的时候，视野不应只停留在自己所能完全把控的领域，而应该把边界放大，从更外围的视野来思考这个问题的解决方案。
如前面说到的缓存策略，其实有一个当前的缓存策略弊端需要通过使用边界放大思维来优化。这个弊端是：当前浏览器缓存技术有其自身的局限性，缓存的有效性依赖于用户的二次访问程度。弊端的核心问题在于：缓存时机与用户首次访问相耦合。这使得在一些超高并发的活动中活动类与业务类不同，活动类大部分是第一次访问的用户，缓存带来的效果并没有想象中大。
这是在纯前端技术层面无法解决的。但当我们把思维边界放大，扩展考虑到承载的平台时，这个弊端也许就能获得解决。因为这个弊端核心要解决的是资源的缓存与页面访问解耦的问题，而承载平台方尤其终端是有这个能力完成的。如在手中，这个解决方案叫“离线包”。离线包支持被动缓存的同时，也支持主动缓存。可将页面内容无须用户主动访问而通过预下载或主动的方式缓存到用户手客户端上。首次访问的用户也可直接命中缓存。这样即可大大提高缓存的有效性。春节期间，手各高并发无不使用这项技术来提高页面的高并发能力。
逻辑全面性思维
再如，逻辑全面性思维，指的是我们在做一项事情的时候，视野不能只停留于逻辑的局部，而应该看到逻辑的全状。如逻辑有正常状态，也有异常状态，我们不能只考虑正常状态。逻辑有双向也有单向，对于双向的逻辑，我们不能只考虑其中的正向。
其实，前面我说的所有前端高并发策略包括前面画的图，都仅仅只考虑到了数据流的正向逻辑段，即数据从用户端流向服务端的过程。而数据流的反向逻辑段其实是没有考虑的即数据从服务端回到用户端的这一段逻辑情况。而在高并发场景下，数据的反向逻辑段往往也会作为逻辑中非常关键的一环。没考虑数据流反向逻辑段的高并发策略，优化数据再好也只能说完成了一半。下面是数据流动的全逻辑过程红色部分是数据流动的反向逻辑段：
在数据流的反向逻辑段中，前端在这层逻辑中的角色变成了数据接受方，而接受的数据可能存在多种状态，前端需要对这些状态都做好相应的处理。在高并发下，若后台过载了，那就会有部分数据返回异常。此时，最简单的我们可以分成两种状态——成功、失败，成功状态页面正常展示，异常状态则需要尽可能做到体验降级而非完全不可用。如静态资源请求失败了，前端可以进行这样的一层异常逻辑处理：将当前异常用户的静态资源域名临时切换到备份域名如页面域名或备用域名，这样可以将本来应该白屏无法使用的体验降级到访问速度较慢的体验，同时也给了错误率超过阀值时的机器扩容提供调整时间。当然，若再结合上面的差异化思想，我们还可以将当前服务器的总体状态进行差异化分级如当前负载程度，通过配置返回等策略告知页面当前服务器并发情况的程度，前端针对这些状态做差异化处理，逐步降级。如当并发超过一定限度时，前端可以考虑将一些非核心但访问量较高的的页面入口逐步屏蔽掉，到最后仅保留核心的入口，从而保障项目核心功能不受高并发影响。
五、结语
本文算是笔者从事年前端工作以来的一些思考。基于前端高并发策略这一优化点，向各位逐步阐述笔者在其“术”方面和“思维”方面的一些思路。受限于自身的经历和视野，观点也许有其局限性。希望文中提到的策略和思维，能给能作为读者的你一些收获。文章篇幅较长，文字较多，感谢耐心阅读！

关于腾讯 
腾讯是腾讯游戏官方推出的一站式游戏测试平台，用十年腾讯游戏测试经验帮助广大开发者对游戏开发全生命周期进行质量保障。腾讯提供：适配兼容测试；云端真机调试；安全测试；耗电量测试；服务器性能测试；舆情监控等服务。
点击地址：立即体验！作者：，腾讯移动客户端开发 工程师
商业转载请联系腾讯获得授权，非商业转载请注明出处。 
原文链接：

 导读
   为整个生态系统的  元素带来了一种更加大胆、动态的新风格。 本文介绍了在方面做了哪些更新，有些更新可以为用户提供更加完美的体验，但也有的可能会给目前的带来异常。
前言
前几天发现在做的在系统上动画有异常，在其他系统的设备上都是正常的，动画的操作是观察的变化后执行的，异常动画发生在 之后，也就是说 之后，的发生了几次变化。查了下资料发现原因是中默认开启了，在         中有介绍，因此研究了下这个，本文作为一个总结，下文的第三部分会有对上述的动画异常的原因分析及解决方式。
本文内容包括：集成了搜索的大标题栏、横向选项卡栏、 和 以及 和 的更新和功能更强大的滑动操作。
一、在’ 中加入的新功能
通过新增的文件管理：开始介绍，在这个中能够看到中’ 的一些新特性：在浏览功能上的大标题视图向上滑动后标题会回到原来的效果、横屏状态下上的文字和会变为左右排列。我用的模拟器体验了一下这个的竖屏和横屏，如下图所示：
向左的箭头让模拟器横屏
横屏时，在上，上的图标较小， 较小，这样垂直空间可多放置内容。如果有人看不清楚 上的图标或文字，可以通过长按 上的任意，会将该显示在上，这样可以清楚的看清和。对  和  同理，长按也会放大显示。如下图显示：

、
是   和   的父类，要想实现上面介绍的效果，只需要为 设置属性，在中也支持这个设置，对于的需要设置另一个新增的属性：，关于这部分更详细的讨论，可以参考   ：   
、控制大标题的显示
在  中新增了一个属性将该属性设置为， 就会在整个中显示大标题，如果想要在控制不同页面大标题的显示，可以通过设置当前页面的的属性；

、 集成 
把你的赋值给，就可以实现将集成到。

、和滚动交互
滚动的时候，以下交互操作都是由负责调动的：

所以，如果你使用 ，组装和体验，你不会得到的集成、大标题的控制更新和 效果，因为这些都是由控制的。
、  — 
在   中，当苹果进行所有这些新特性时，也进行了其他的优化，针对  和  做了新的自动布局扩展支持，自定义的  、自定义的都可以通过来表示尺寸。 需要注意的是，你的需要在内部设置，所以如果你有一个自定义的标题视图，你需要确保任何约束只依赖于标题视图及其任何子视图。当你使用自动布局，系统假设你知道你在做什么。
、   
自定义视图的为是因为你有一些模糊的约束布局。要避免视图尺寸为，可以从以下方面做：
●  和  提供位置
● 开发者则必须提供视图的，有三种方式： 
① 对宽度和高度的约束；
② 实现 ；
③ 通过约束关联你的子视图；
二、管理 和 
、 
基于约束的 ，使我们搭建能够动态响应内部和外部变化的用户界面。 为每一个都定义了。指的是控件显示内容部分的边缘和控件边缘的距离。 可以用或者属性获得的是视图内部的一部分。允许获取或者设置结构的。则获取到只读的对象。
在新增了一个属性：  ，该属性是结构体类型的属性：

是结构体类型的属性：

从上面两种结构体的对比可以看出， 属性用 和  取代了之前的  和 。
  属性的说明如下：

例子：当你设置了 = ；当在一个   语言下的值会被设置在的左边，可以通过 的属性读出该值。如下图所示：

还有其他一些更新。自从引入 ，当将一个添加到时，会修复的的为定义的一个值，这些调整对外是封闭的。从开始，这些不再是一个固定的值，它们实际是最小值，你可以改变你的的为任意一个更大的值。而且，新增了一个属性：，如果你设置该属性为，你就可以改变你的 为任意你想设置的值，包括，如下图所示：

、安全区域 
如下图：照片应用程序

从 以来，我们在整个操作系统中都有这些半透明的，苹果鼓励我们通过这些绘制内容，我们是通过 的属性来做这些的。   开始，在 中引入的 和  在   中被废弃了，取而代之的就是的概念，是描述你的视图部分不被任何内容遮挡的方法。 它提供两种方式：或来提供给你的参照值，即  或者  。 区域如下图所示：

如果有一个自定义的，你可能要添加你自己的，增加的值，可以通过一个新的属性：来改变的值，当你的改变了它的值时，有两种方式获取到回调：

三、   的新特性
、  
如果有一些文本位于滚动视图的内部，并包含在导航控制器中，现在一般会传入一个给其最顶层的的，在中进行了一个很大的改变，不再通过的属性了，而是新增了一个属性：，下面的两张图的对比能够表示表示的区域：


新增的属性用来配置的行为，该结构体有以下几种类型：

、  ：在 中默认启用
这个应该是最大的改变。我们知道在引入 之后，我们可以通过实现相关的属性来展示动态的内容，实现了属性后，得到的初始是个估算值，是通过  的个数得到的，并不是最终的，就不会一次性计算所有的的高度了，只会计算当前屏幕能够显示的个数再加上几个，滑动时，不停地得到新的，更新自己的，在滑到最后的时候，会得到正确的。在测试中，创建到显示出来的过程中，的计算过程如下图：

在下是默认开启的，   都默认开启，所有 高度默认值从之前的  改变为：

如果目前项目中没有使用属性，在的环境下就要注意了，因为开启之后，是使用属性的，这样就会造成和值的变化，如果是有动画是观察这两个属性的变化进行的，就会造成动画的异常，因为在估算行高机制下，的值是一点点地变化更新的，所有显示完后才是最终的值。因为不会缓存正确的行高， 的时候，会重新计算，就有可能会引起的变化。下不想使用的话，可以通过以下方式关闭：前言中提到的问题也是通过这种方式解决的

下，如果没有设置的值，也没有设置的值，那计算初始值是   的个数，如下图：和都是默认值 而 = ；则初始 =    = ；

、 ： 扩展
  引入属性，用以设置  的分割线边距，在   中对其进行了扩展。可以通过新增的枚举类型的属性来设置属性的参照值。

下图清晰的展示了这两种参照值的区别：

、  和  
有以下几点需要注意：
●  被自动地关联到   ，因此，默认情况下，表视图的整个内容避免了其根视图控制器的安全区域的插入。
●  和 的   在安全区域内；因此你应该始终在   中使用操作。
● 所有的  和  都应该使用，包括   和 、  和 。
、滑动操作 
在之后，苹果官方增加了的右滑操作接口，即新增了一个代理方法 和一个类，代理方法返回的是一个数组，我们可以在这个代理方法中定义所需要的操作按钮删除、置顶等，这些按钮的类就是。这个类只能定义按钮的显示文字、背景色、和按钮事件。并且返回数组的第一个元素在的最右侧显示，最后一个元素在最左侧显示。从 开始有了一些改变，首先是可以给这些按钮添加图片了，然后是如果实现了以下两个 新增的代理方法，将会取代 代理方法：

这两个代理方法返回的是类型的对象，创建该对象及赋值可看下面的代码片段：

创建对象时，有两种类型，如果是置顶、已读等按钮就使用类型，操作按钮可使用类型，当使用该类型时，如果是右滑操作，一直向右滑动某个，会直接执行删除操作，不用再点击删除按钮，这也是一个好玩的更新。

滑动操作这里还有一个需要注意的是，当高度较小时，会只显示，不显示，当高度够大时，会同时显示和。我写测试的时候，因为每个的高度都较小，所以只显示，然后我增加的高度后，就可以同时显示和了。见下图对比：

总结
大概介绍了 的方面的一些更新，大部分内容都用代码测试过了，有些更新确实是很实用，可以适配下 ，有的更新可能会给现有造成，所以学习下这些内容还是很有必要的。
参考：

、             

、 自动调整和布局

、       

、       

【腾讯 预审工具】
为了提高苹果审核通过率，腾讯专门成立了苹果审核测试团队，打造出预审工具这款产品。经过两年的内部运营，腾讯内部应用的审核通过率从平均提升到。
现将腾讯内部产品的过审经验共享给各位。在腾讯质量开放平台上可使用预审工具，点击链接： 咨询体验！
如果使用当中有任何疑问，欢迎联系腾讯        企业：
预审服务
【扫描工具】上传包、图片、视频、应用描述即可进行测试； 多维度自动扫描提审材料的被拒风险；小时内反馈全面的扫描报告。
【专家预审】腾讯专家为您遍历所有功能模块；全面暴露内容被拒风险；跟进问题直至上线需提供官方拒绝邮件。
【专家咨询】资深预审专家一对一服务； 咨询时间灵活可选，按需购买；有的放矢解 决审核问题。
【优化】专业团队多维度深度剖析的现状；围绕目标用户群筛选高 度关联的关键词；帮助提升在苹果应用商店中的曝光率。 月  日，腾讯云在 「云未来」峰会上推出了战略新品——智能云，宣布将腾讯积累近  年的  能力向政府、企业和开发者开放，其中首批开放计算机视觉、智能语音识别、自然语言处理的三大核心能力。腾讯云技术社区陆续推出了系列文章，向普通开发者分享如何快速接入并使用这三大  能力，节省自身的开发成本，同时极大提升开发效率和用户体验。
本文将为广大云开发者介绍如何接入腾讯开放的自然语言处理能力，即  文智自然语言处理。
、什么是文智？
腾讯文智自然语言处理  基于并行计算、分布式爬虫系统，结合独特的语义分析技术，一站满足 、转码、抽取、数据抓取等需求。基于文智  可实现搜索、推荐、舆情、挖掘等功能。
腾讯云文智中文语义平台以  模块的方式提供服务，多种编程语言都可以轻松使用。
、文智  使用注意事项
在调用文智  时，开发者需要提供以下公共参数。

公共参数是用于标识用户和接口鉴权的参数 每次请求均需要携带这些参数 才能正常发起请求。




名称
类型
描述
必选






接口指令的名称，例如 
是




区域参数，用来标识希望操作哪个区域的实例。可选 广州 上海香港等
是




当前  时间戳
是




随机正整数，与  联合起来 用于防止重放攻击
是




由腾讯云平台上申请的标识身份的  和  其中  会用来生成 
是




请求签名，用来验证此次请求的合法性
是



、调用示例
这里将以一个简单的情感分析任务为例，介绍腾讯云  文智模块的使用。
、首先请在腾讯云官方  下载地址
下载或更新最新版本的 本文以  为例：  地址 推荐
 修改  文件，修改点如下
 ， 改为自己腾讯云上相应的值，这里查看：。
修改  参数
== =
改为：
 = =李亚鹏挺王菲：加油！孩儿他娘。
这是文智情感分析接口所需要的参数。
修改  的值
=
改为：
 = 
这是文智文本情感分析的相关接口。
其他所有地方的  改为 ，即替换为文智模块。
修改后的  如下：

__  _
_ 

 =         = 你在腾讯云上的 
                    = 你在腾讯云上的 
               = 
                 = 

 = _ 

 = =李亚鹏挺王菲：加油！孩儿他娘。

 = 

  ===  {
     = 
          
         
       _   
}  {
    _
}

    
    
 
执行上述代码，就可以得到对 李亚鹏挺王菲：加油！孩儿他娘。 这句话的情感分析结果。
相关阅读
腾讯云技术社区还发布了《文智背后的奥秘》系列文章，详细地解读了文智服务背后使用的技术：

【 文智背后的奥秘 】系列篇 ：情感分类
【 文智背后的奥秘 】系列篇 ：文本聚类系统
【 文智背后的奥秘 】系列篇 ： 自动文本分类
【 文智背后的奥秘 】系列篇：关键词智能提取
【 文智背后的奥秘 】系列篇：结构化抽取平台
【 文智背后的奥秘 】系列篇  分布式爬虫之 
【文智背后的奥秘】系列篇——海量数据抓取
【文智背后的奥秘】系列篇：基于  的人名识别作者： 

简介
服务器集群系统即  是章文嵩在国防科技大学博士期间开发的一个开源项目，该项目也是中国开源少有的几个成功项目之一，该项目已经进入到内核，在国内外被广泛的使用。章文嵩博士目前就职到淘宝，继续主持的相关工作。各大互联网公司都在对进行修改和使用，因此产生了不通的变种，比如百度的淘宝的腾讯的目前我还不太了解。其基本原理都是在层，对数据包进行过滤、修改和伪装。
转发模式
原生的三种转发模式：






原理： 地址伪装，通过修改源包的地址进行投递示意图

 原理 通过修改源目的实现，进入时出去时示意图

原理 通过 实现，进入时加上头部 示意图

 介绍：一种新型新型的转发模式，的加强版，由吴佳明等在章文嵩带带领下实现  原理 通过修改改源目的实现，但是比更彻底，进入时出去时由示意图 
和原理对比
▲包修改示意图      在入包时，进行目的地址转换，出包时进行源地址转换，为了让出去的数据包，经过，需要添加策略路由。
包修改示意图
 ▲实现原理
在入包时修改目的地址，同时把源地址改为内网地址，这样包就可以完全无限制的在整个内外路由，出包时修改源地址为地址，目的地址为真实的地址从而实现回包到目的地。
优缺点对比

•优点：性能好，直接回包• 缺点：

、 必须在一个中，这在多网络环境中限制非常大
、 必须绑定，麻烦且风险大
、不支持端口映射


• 优点：

、 可以在整个内网中，没有的限制
、支持端口映射

•  缺点：

、 的网关必须是机器，如果不是，则需要配置静态路由


• 优点：性能好，直接回包• 缺点

、 配置复杂，需要配置模块
、 绑定，风险大
、不支持端口映射


• 优点：

、数据包可以在整个内外中任意路由
、交换机和路由器无需任何特殊配置

• 缺点： 无法获取 
结论
 从上面几种模式来看，无疑是一种最好的转发模式，他无需要对路由器，进行特殊操作，就可以完成整个代理转发。其实在具有一定网络规模的环境中，无论是要求在同一个，还是要配置静态路由，对网络拓扑配置都是极大的破坏，而且绑定风险极大，而且实现自动化困难。从实际应用来看，都没有很大规模的应用案例，相反，已经被大范围的使用，包括阿里，小米，汽车之家，等很多互联网公司，规模都是很大。鉴于的操作复杂性和风险，建议考虑作为替代方案。我们尝试维护过一个免费的代理池，但是代理池效果用过就知道了，毕竟里面有大量免费代理，虽然这些代理是可用的，但是既然我们能刷到这个免费代理，别人也能呀，所以就导致这个代理同时被很多人使用来抓取网站，所以当我们兴致勃勃地拿他来抓取某个网站的时候，会发现它还是被网站封禁的状态，所以在某些情况下免费代理池的成功率还是比较低的。
当然我们也可以去购买一些代理，比如几块钱提取几百几千个的代理，然而经过测试后质量也是很一般，也可以去购买专线代理，不过价格也是不菲的。那么目前最稳定而且又保证可用的代理方法就是设置拨号代理了。
本篇来讲解一下拨号代理服务器的相关设置。
友情提示：完成本节内容需要有两台主机支持，固定的主机推荐腾讯云 拨号主机推荐云立方。
什么是
大家可能对比较陌生，全称叫做   ，非对称数字用户环路，因为它的上行和下行带宽不对称。它采用频分复用技术把普通的电话线分成了电话、上行和下行三个相对独立的信道，从而避免了相互之间的干扰。
有种主机叫做动态拨号主机，这种主机在连接上网的时候是需要拨号的，只有拨号成功后才可以上网，每拨一次号，主机就会获取一个新的，也就是它的并不是固定的，而且量特别大，几乎不会拨到相同的，如果我们用它来搭建代理，既能保证高度可用，又可以自由控制拨号切换。
经测试发现这也是最稳定最有效的代理方式，本节详细介绍一下拨号代理服务器的搭建方法。
购买动态拨号主机
所以在开始之前，我们需要先购买一台动态拨号主机，这样的主机在百度搜索一下，服务商还是相当多的，在这里推荐一家云立方，感觉还是比较良心的，非广告。
配置的话可以自行选择，看下带宽是否可以满足需求就好了。
购买完成之后，就需要安装操作系统了，进入拨号主机的后台，首先预装一个操作系统。

在这里推荐安装系统。
然后找到远程管理面板找到远程连接的用户名和密码，也就是远程连接服务器的信息。
比如我这边的端口分别是 ，用户名是。
命令行下输入：
   
然后输入管理密码，就可以连接上远程服务器了。
进入之后，可以发现有一个可用的脚本文件，叫做，这是拨号初始化的脚本，运行它会让我们输入拨号的用户名和密码，然后它就会开始各种拨号配置，一次配置成功，后面的拨号就不需要重复输入用户名和密码了。
运行脚本，输入用户名密码等待它的配置完成。

都提示成功之后就可以进行拨号了。
在拨号之前如果我们测试任何网站都是不通的，因为当前网络还没联通，输入拨号命令：

可以发现拨号命令成功运行，没有任何报错信息，这就证明拨号成功完成了，耗时约几秒钟。接下来如果再去外网就可以通了。
如果要停止拨号可以输入：

停止之后，可以发现又连不通网络了。
所以只有拨号之后才可以建立网络连接。

所以断线重播的命令就是二者组合起来，先执行再执行，每拨一次号，命令观察一下主机的，发现主机的一直是在变化的，网卡名称叫做。

所以，到这里我们就可以知道它作为代理服务器的巨大优势了，如果将这台主机作为代理服务器，如果我们一直拨号换，就不怕遇到被封的情况了，即使某个被封了，重新拨一次号就好了。
所以接下来我们要做的就有两件事，一是怎样将主机设置为代理服务器，二是怎样实时获取拨号主机的。
设置代理服务器
之前我们经常听说代理服务器，也设置过不少代理了，但是可能没有自己设置吧，自己有一台主机怎样设置为代理服务器呢？接下来我们就亲自试验下怎样搭建代理服务器。
在下搭建代理服务器，推荐和，配置都非常简单，在这里我们以为例来讲解一下怎样搭建代理服务器。
安装
当然第一步就是安装这个软件了，在这里我使用的系统是，所以使用来安装，如果是其他系统如可以选择等命令安装，都是类似的。
命令行执行安装指令：
   
  
   
运行完成之后就可以完成的安装了。
配置
安装完成之后还需要配置一下才可以用作代理服务器，需要编辑配置文件，它一般的路径是。
可以看到有一行
 
在这里可以设置代理的端口，默认是。
然后继续向下找，有这么一行
 
这是被允许连接的主机的，如果想任何主机都可以连接，那就直接将它注释即可，所以在这里我们选择直接注释，也就是任何主机都可以使用这台主机作为代理服务器了。
修改为
  
设置完成之后重启即可。
  
验证
好了，这样我们就成功搭建好代理服务器了，首先查看下当前主机的，比如当前我的主机拨号为，在其他的主机运行测试一下。
比如用命令设置代理请求一下，检测下代理是否生效。
   

如果有正常的结果输出并且的值为代理的地址，就证明配置成功了。
好，那到现在，我们接下来要做的就是需要动态实时获取主机的了。
动态获取
真正的好戏才开始呢，我们怎样动态获取主机的呢？可能你首先想到的是也就是动态域名解析服务，我们需要使用一个域名来解析，也就是虽然是变的，但域名解析的地址可以随着的变化而变化。
它的原理其实是拨号主机向固定的服务器发出请求，服务器获取客户端的，然后再将域名解析到这个上就可以了。
国内比较有名的服务就是花生壳了，也提供了免费版的动态域名解析，另外也提供了解析接口来动态修改域名解析设置，，但是这样的方式都有一个通病，那就是慢！
原因在于修改后到完全生效是需要一定时间的，所以如果在前一秒拨号了，这一秒的域名解析的可能还是原来的，时间长的话可能需要几分钟，也就是说这段时间内，服务器已经变了，但是域名还是上一次拨号的，所以代理是不能用的，对于爬虫这种秒级响应的需求，是完全不能接受的。
所以根据花生壳的原理，可以完全自己实现一下动态获取的方法。
所以本节重点介绍的就是怎样来实现实时获取拨号主机的方法。
要实现这个需要两台主机，一台主机就是这台动态拨号主机，另一台是具有固定公网的主机。动态主机拨号成功之后就请求远程的固定主机，远程主机获取动态主机的，就可以得到这个代理，将代理保存下来，这样拨号主机每拨号一次，远程主机就会及时得到拨号主机的，如果有多台拨号，也统一发送到远程主机，这样我们只需要从远程主机取下代理就好了，保准是实时可用，稳定高效的。
整体思路大体是这样子，当然为了更完善一下，我们要做到如下功能：
远程主机：

监听主机请求，获取动态主机
将主机记录下来存入数据库，支持多个客户端
检测当前接收到的可用情况，如果不可用则删除
提供接口，通过接口可获取当前可用代理

拨号：

定时执行拨号脚本换
换后立即请求远程主机
拨号后检测是否拨号成功，如果失败立即重新拨号

远程主机实现
说了这么多，那么我们就梳理一下具体的实现吧，整个项目我们用实现。
数据库
远程主机作为一台服务器，动态拨号会定时请求远程主机，远程主机接收到请求后将记录下来存入数据库。
在这里远程主机我使用腾讯云，需要有固定的。

因为是一直在变化的，更新了之后，原来的就不能用了，所以对于一个主机来说我们可能需要多次更新一条数据。另外我们不能仅限于维护一台拨号主机，当然是需要支持多台维护的。在这里我们直接选用形式的非关系型数据库存储更加方便，所以在此选用数据库。
既然是，是什么是什么首先我们能确定就是代理的值，比如，那么是什么？我们知道，这个是针对一台动态拨号的，而且这个值会不断地变，所以我们需要有一个不变量来唯一标识这台主机，所以在这里我们可以把当做主机名称。名称怎么来？自己取就好了，只要每台主机的名字不重复，我们就可以区分出是哪台主机了，这个名字可以在拨号主机那边指定，然后传给远程主机就好了。
所以，在这里数据库我们选用，就是拨号主机的名称，可以自己指定，就是代理的值。
所以可以写一个操作数据库的类，参考如下：
 
     ____ =_ =_
         = = = =_
        _ = _

      
         {}{}=_ =

       
          

      
         

首先初始化连接，我们可以将设计成这种形式，冒号前面是总的，冒号后面是主机名称，这样显得结构更加清晰。
然后指定和方法，用来存储代理和获取代理。
请求处理
拨号主机会一直向远程主机发送请求，远程主机当然可以获取拨号主机的，但是代理端口是无法获得的，我们在拨号主机上设置了或者，但是服务器不知道是在哪个端口开的，所以端口也是需要客户端传给远程主机的。远程主机接收到请求后，将解析得到的和端口合并就可以作为完整的代理保存了。
所以现在我们知道拨号主机需要传送给远程主机的信息已经有两个了，一是拨号主机本身的名称，二是代理的端口。
通信秘钥
为了保证远程主机不被恶意的请求干扰，可以设置一个传输秘钥，最简单的方式可以二者共同规定一个秘钥字符串，拨号主机在传送这个字符串，远程主机匹配一下，如果能正确匹配，那就进行下一步的处理，如果不能匹配，那么可能是恶意请求，就忽略这个请求。
当然肯定有更好的加密传输方式，但为了方便起见可以用如上来做。
所以客户机还需要传送一个数据，那就是通信秘钥，一共需要传送三个数据。
所以我们需要架设一个服务器，一直监听客户端的请求，在这里我们用实现。
的安装也非常简单，利用安装即可：
  
定义一个处理拨号主机请求的方法，在这里我们使用请求，参考如下。
 
         = __ = =
         = __ = =
         = __ = =
          ==   
             = _
             =     
              
             
            _
          = 
             
          
              

远程主机获取请求的，也就是上面我们所说的通信密钥，保证安全。是拨号机的代理端口，是拨号主机的名称。然后我们再获取请求的_，也就是拨号主机的。然后将和端口拼合就可以得到拨号主机的完整代理信息了，将其存入数据库即可。
代理检测
在远程主机端我们需要做一下代理检测，如果某个代理不可用了，会及时将其去除，以免出现获取到代理后不可用的情况。

注意：在这里在拨号主机端验证是不够的，因为可能突然遇到某个拨号主机宕机的情况，这样拨号主机就不会再向远程主机发送请求，而最后一次得到的代理还会存在于数据库中，所以在远程主机端统一验证比较科学。

验证方式可以定时检测，也可以每收到一次请求检测一次，用获取到的代理来请求某个网站，检测一下是否能访问即可。如果不能，将其从数据库中删除。

远程主机已经将拨号主机的和端口保存下来了，那也就是说，所有的可用的代理已经在远程主机保存了，我们需要提供一个接口来将代理获取下来。
比如我们可以提供这么几个方法，获取所有代理，获取最新代理，获取随机代理等等。
 
     = 
     = {   }    
     

 
     = 
     

 
     = 
     =     
     

 
     

然后用搭建服务，如果可以的话还可以绑定一个域名，更加便捷，举例如下：
获取随机代理：

获取最新代理：

获取所有代理：

请求接口获取可用代理即可，比如获取一个随机代理：
 

 __
    
         远程主机的服务地址
         = 
         
     
         

这样我们拿到的都是稳定可用的，而且过段时间重新请求取到的就会变化，是一直动态变化的高可用代理。
拨号实现
定时拨号
拨号需要每隔一段时间就拨号一次，我们可以直接执行命令行来拨号，那在里我们只需要调用一下这个拨号命令就好了。利用模块调用脚本即可，在这里定义一个变量_为，这就是拨号的脚本。
 
  = _

通过方法可以获取脚本的执行状态和输出结果，如果为，则证明拨号成功，然后检测一下拨号接口是否获取了地址。
执行命令可以获取当前的，我这台主机接口名称叫做，当然网卡名称可以自己指定，所以将接口的提取出来即可。
 _ =_
      = 
      == 
         =   \\\\\\\ 
         =  
         
             = 
             

如果方法正常返回，则证明存在，拨号成功，接下来向远程主机发送请求即可，然后一段时间重新再次拨号。如果方法返回的值为空，那证明不存在，我们需要重新拨号。
请求远程主机
发送的时候需要携带这么几个信息，一个是通信秘钥，一个是代理端口，另一个是主机的标识符，用发送即可。
_ ={   _  _}

所以整体的思路实现可以写成这样子：
 
         
               
              = _
              == 
                 
                 = _
                 
                      
                    
                        _ ={   _  _}
                            _
                     
                            _
                    _
                
                      
            
                   
            

这样我们就可以做到定时拨号并向远程主机发送请求了。
代码
       在这里提供一份完整代码实现，其中模块是在动态主机运行，模块在远程主机运行，具体的操作使用可以参考。
前言
额，这里不支持语法。就截图了。。。
下面介绍的方法均是用于求解回归问题，其目标值预计是输入一个变量的一个线性组合，用数学语言表示的 \{}是预测值，则有
                            \{}\   = \_{}  \_{}_{}  \_{}_{}
在这里称向量\=\{}  \{}为    \{}称为_

普通最小二乘法
线性回归中使用系数\=\{}  \{}拟合一个线性模型，拟合的目标是要将线性逼近预测值_{\} 和数据集中观察到的值两者之差的平方和尽量降到最小，写成数学表达式为

\{\}{}||_{\}||_{}{}

线性回归中的方法接受数组和作为输入，将线性模型的系数\存在成员变量_中
    _                        导入线性模型
  = _                    为线性回归
                   对输入输出进行拟合
_= _= _= =
_ 是否备份     _ 是否保存截距      _ 任务数量    是否标准化
  _                                            系数矩阵模型的权重
 
  _                                    训练后模型截距

                                   训练后模型预测

                                          训练是否标准化

  _                                    获取模型训练前设置的参数
  _  _= _= _= =
普通二乘法的系数预测取决于模型中各个项的独立性，假设各项相关，矩阵的列总体呈现出线性相关，那么就会很接近奇异矩阵，其结果就是经过最小二乘得到的预测值会对原始数据中的随机误差高度敏感，从而每次预测都会产生比较大的方差，这种情况称为重共线性，例如，在数据未经实验设计就进行收集时就会发生重共线性。
还有一个线性回归的例子
   
   
    _

 读取自带的数据集
 = _


 使用其中的一个
_ =   

 将数据集分割成 和 
__ = _
__ = _

 将目标值分割成 和 
__ = 
__ = 

 使用线性回归
 = _

 进行 和 的，即是训练的过程
__ __

 打印出相关系数和截距等信息
 \ _
    
    
       __  __  
       
    __ __

 使用画图
__ __  =
__ __ =
         =





普通最小二乘法的复杂度
此方法使用的的奇异值分解来求解最小二乘如是矩阵，则算法复杂度为{}{\}，假设 导语
  意在使游戏中的个体具备真实的运动行为，通过对力的施加与整合，使游戏个体具备类生命体般的运动特征。这项技术并不基于寻路或者别的宏观算法，而是基于个体局部周围空间的信息，单个的行为实现起来非常的方便，它们组合在一起又能有非常复杂的行为方式。

实现所涉及到的所有运算都可以用向量计算来实现，而系统产生的力会运用在游戏个体的速度和位置更新上，所以最好是用向量来表示物体的速度和位置。
虽然说向量表示方向，但是在其表示位置时又会被忽略。上图表示一个个体在位置，，并且它的速度是 。它的移动用欧拉积分表示为

 =   
速度向量的方向控制个体移动的朝向，速度向量的长度控制个体的移动速度。长度越大，个体移动得越快。速度向量会被截取在一个范围里。

 =     _
 以上的算法是一个基本行为，但不带任何输出的力，可以注意到，在该公式作用下，游戏个体的移动方式是直线型的，如果的位置变了的话，个体会立即响应，并且会以新的方向，以直线的形式向目标位置靠近，这会给人一种从当前路径突兀的变换到新路径的感觉。
如果只考虑速度方向的力，就会有这种突兀的行为，  的核心理念就是通过施加多个力 来影响个体的移动，个体的运动方向根据这些力的合力得出。
就行为来说，每帧向游戏个体施加一个额外的转向力来调整速度，会使路径变化没有那么突兀。如果目标位置变了，个体也会根据新位置慢慢的转变自己的速度向量。
行为被分解为两个力：目标速度，和转向速度。

目标速度始终朝向目标位置，转向力是目标速度减去个体的当前速度得出的，它的物理意义就是向着目标位置给个体一个推力。

_ =     _
 = _  
计算了转向力之后，它必须和原先版本的速度方向合成，再施加给个体。这个每帧施加的额外转向力会使得个体以平滑的方式靠近目标点。

最终的计算方法为

 =   _
 =   

 =      _
 =   
 转向力会被截断在一个范围，防止其超过个体最大可承受力。被截断的转向力会除以个体的质量，因为不同重量的物体运动快慢是不同的。

之前描述的行为基于两个力，一个是目标速度，一个是朝目标位置的推力。

_ =     _
 = _  
_在这里就是离目标位置的最短路径，根据目标点的位置和个体的位置相减得出，代表了一个以个体位置为起点，朝向目标点的力。

行为也用到这两个力，区别是它们被调整为使游戏个体远离目标位置。

行为中 _ 根据个体的位置和目标点的位置相减得出，产生了一个以目标点为起点，朝向个体的力。
最终合力的计算几乎和行为一样：

_ =     _
 = _  
 在行为中，_ 代表了个体逃离目标的最短路径，转向力会将个体推向目标速度方向。
比较在行为 和 行为里 _ 的关系，会得出以下的关系：

__ = __
同样在计算完转向力之后，它也必须和个体的速度向量合成来作用于个体。因为这一次转向力始终将个体推离目标位置，这将会产生一条逃离路径。

目前，不管多远距离目标位置都会影响到个体，可以通过添加一个影响范围来只在个体靠近目标点时作用。

我们看到行为使个体向目标位置移动，当个体移动到目标点后，算法仍旧作用在个体之上，对它施加转向力，这会导致个体在目标点周围来回移动。
行为会规避个体移动超过目标点的现象，当个体靠近目标点时，它会使个体减速，最终停在目标点上。
行为被分成两个阶段，第一阶段是个体还远离目标点时，它的工作方式和之前介绍的行为一样，第二阶段是个体靠近目标点时，在减速范围内。

当个体进入到减速范围内，它会持续减速直到停在目标点上。
当个体进入到减速范围内，速度会线性的衰减到 ，通过加入一个新的转向力来达到这个效果，这个转向力最终会变成  ，意味着最终个体在目标点上，不会再有任何别的力施加了。

 =    _
 =   

    {
      
     =   
     =       
    
}
 为了确保个体在它完全停止前线性的减速，速度不能直接设为 ，减速计算将会根据 个体到目标点的距离，和减速区域，得出一个线性的结果。

_ =   
 = _
    {
   _ = _  _    
}  {
    _ = _  _
}
 = _   如果距离比大，这意味着个体离目标点还远，那它的速度将保持为_。
 如果距离比小，这意味着个体已经进入到减速区域，那以为着它应该减速。
表达式    会从变化到 ，这种线性的变化会使速度平滑的变到。


 = _  
 =      _
 =   
 根据之前说的个体 运动的表达形式，如果_降为，那么转向力会是

，那么它和速度方向的合力为 ，个体就不会运动了。


游戏中的个体常常会有随机性的巡逻情景。通常这些个体在等待某些事情发生，比如说发现玩家然后开战，或者寻找某些东西。当这些行为呈现在玩家面前时，它们必须在视觉感官上市真实可信，富有乐趣的。
如果玩家能够很容易的分辨出游戏的运动路径，或者别的不真实的移动行为，这会增加玩家的挫败感。最差的情况，玩家可以很清楚的预判的移动行为，这最终会导致一个枯燥的游戏体验。
 行为意图产生一种真实可玩的移动行为，使玩家以为游戏是真实的生命体在游戏中巡逻。
基于 有几种方法来实现的特征。最简单的是使用前面提到过的行为，在游戏进行行为的时候，它会朝着目标不断前进，如果目标点每隔几秒钟改变一次，那么游戏就永远也到不了目标点，在游戏场景中不断的改变目标点，会让游戏不断的去追踪目标。
实现代码：


    {
      =  
     =  {
          
   }
    
}

    {
    = 
    =   _
    =   
    =      _
    =   
}
 尽管这是一个不错的解决方法，但是最终的结果并不是那么让人信服。有时候游戏会完全翻转他们的行动路径，因为目标点正好随机到了身后。游戏的行为看上去更像是“哎呀，我忘记了我的钥匙”然后是“好吧，我就顺着这个方向走”。
行为
另一种实现方式是每帧产生一个 小而随机的 移位力来作用在游戏当前移动方向之上。因为速度向量代表了个体移动的方向，所以任何微小的改变会影响到个体的行进方向。
每一帧施加一个微小的 移位力会规避游戏突然改变自己路径的突兀感，比如游戏上一帧是朝上方运动并朝右转向，那这一帧该游戏对象同样是朝上方运动并朝右转向，区别只是角度有一点不同。
有很多种方式实现这种思路，起中一种简单的方式是在游戏的前方加一个圈，圈的半径以及角色到圈的距离越大，施加在角色身上的推力就越强。
要计算力，第一步是要得出圈的中心位置，因为圈必须是在角色的正前方，所以我们可以利用速度向量作为方向。
  
 = 

_
 上面的向量是速度向量的拷贝，它被归一化后乘以了一个放大系数。

下一步是计算移位力，它负责使个体左转和右转。因为这是一个用于扰乱的力，所以它其实可以指向任意方向，我们暂且用一个和轴平行的力来表示。

  
 =   
_
 
 =   _  _  
 移位力被创建出来，并且根据圈的半径被放大，和前面提到的一样，圈的半径越大，移位力就越大，是一个缩放因子，它定义了移位力该倾斜多少，这里使用了一个随机值来让它每帧都不一样。为了更好的理解原理，我们假设移位力是在圈的中心计算的。因为它的向量长度等于圈的半径，所以它看起来如同这样：

在计算完圈的中心和，移位力的大小之后，将他们整合在一起就是力。

  
 = 
 从视觉上来看，它应该是这样：

力可以想象成以游戏为起点，指向圈上的某个点向量，具体这个点的位置会决定施加在游戏身上的力是朝左还是右，是强还是弱：

力越和速度向量平行，游戏转变得就越少，力和之前介绍的和力一样，会将游戏推向一个方向。但是不同的是前者是根据圈上的一个随机位置来决定推向哪，而后者是根据一个目标位置。

    {
     
    = 
   
   _
     
    =   
   _
    
    =   _  _  
    
    = 
    
}

     {
      = 
    =   
    =   
}

追踪是指朝着移动目标运动并试图抓住它，这里说的“抓住”很重要，如果只是朝着目标运动，那基本上只是重复目标的运动轨迹。在追踪的时候，追踪者必须做出一定的预判，如果能够预判出目标接下去几秒的位置，就能够调整自己当前的速度来抓住它。

如同章节里说的，运动用欧拉插值法来表示

 =   
 如果游戏个体的位置和速度是可知的，那就可以预测它在未来一段时间  之后的位置。假设被预测的物体是以直线方式运动的，并且我们只预测，三次之后的位置。那么游戏个体被预测的位置就是：

 =     
 预测的关键是找到合适的  的值，如果这个值太大了，那么追踪者会追踪一个太过靠前的幽灵，如果太小了那么追踪者实际追踪当前个体位置，没有预测成分，变成追随行为。
追踪行为和行为工作方式基本差不多，位移区别是追踪的目标不是目标本身而是目标未来的位置。
假设游戏中的个体都叫下面的伪代码实现了基本的追踪原理：

     {
     = 
    =     
   
}
 在计算完追踪力后，同样它必须和当前速度相加。

    {
   = 
   =   _
   =   
   =      _
   =   
}
 
追踪者会顺着橙色的路径，追捕目标。
当是一个常数时，会有一个问题：在离目标点很近的距离下，追踪的准确度会变得很差。这是因为当追踪者靠近目标后，追踪者还是以常数时间后的位置进行预测。这和真实的追踪行为相违背，真实的追铺在靠近物体后会停止预测，并且以物体当前实际位置作为目标点。有一个简单的方式来改进我们上面的追捕逻辑，就是用动态的来替换之前恒定的。

 =   _
 新的根据两个角色间的距离计算得出，新的的意义是，得出根据追踪者的最大速度，需要多少个来逮住目标。距离越长，就越大，这个时候追踪者就会预测得比较远，相反追踪者会预测最近的时间位置。

     {
     =   
     =   _
    =     
   
}
整合
每一个行为会产生一个力，他们会作用在速度向量上，这个合力的方向和大小会驱动个体实现一些行为如，，等，大致的计算方式如下：

 =       
 =   _
 =   

 =      _
 =   
 因为力是向量，向量能和别的向量叠加。真正神奇的事情是它能和任意数量的向量叠加。

 =  
 =   
 =   

 =   _
 =   

 =      _
 =   
 整合后的力最终会形成一个代表了所有分力的合力。在上面的代码中，最终的力会使游戏角色在某些东西的同时躲避另一些东西。
看一下下面的合力的例子：

这种将单个行为整合在一起的方式可以产生非常复杂的运动行为。想象一下如果是通过编码来实现会有多困难，这些计算可能需要计算距离，区域，路径，图结构等，如果你关心的事情还是动态的，那基本上每一帧都要去计算这些东西。
而行为中，所欲的力都是动态的，它们本身就是在游戏的每一帧计算的，因此它们能够顺应环境的变化。
为了同时能够方便的使用多个行为，一个用于管理的很有必要。目的是能够创建一个黑盒，使得所有游戏中的个体都能够具备的能力。
会持有游戏个体的一个引用，这个游戏个体姑且称为 会提供给这个个体一堆方法，比如 和 。每一次方法被调用，会更新其内部的属性产生一个力。
在处理完所有的调用后，会将力赋给作为其速度向量。

有一堆方法，每个代表了一个行为，每个行为都需要外部的一些信息来使自己工作，比如行为需要外部提供一个目标点，追踪行为需要目标更多的一些信息，如当前位置和速度。空间中的位置也可以用向量表示，这在大多数游戏引擎中非常常见。
在追踪行为中的目标实际上可以是任何东西。为了让更通用，所接收的必须遵循一定的规则，提供一些查询接口。
假定描述了游戏中可以使用行为的所有个体。只要实现这个接口，就能够被接收。

  
{
      
      
      
      
}
 现在可以以一种通用的方式和个体进行交互了。由两个基本属性和一堆方法构成。

  
{
       
       

      
        {
           = 
           =   
    }

            
          =   {}
         {}
        {}
         {}
         {}

        
             
        {}

         
        {}

       
          =   {}
         {}
        {}
         {}
         {}
}
 在实例化的时候必须接收一个对的引用，会在之后改变的速度向量。
每个行为被表示为两个方法，一个的一个的。拿来作为例子：

      =   {}
      =   {}
 的方法用来告诉应用这种行为。这个方法没有返回值，它的参数和行为本身有关。在之后的方法里会返回一个经过计算的向量值，这个向量值会存放在的属性中。
      =   {
     
}

         
      =   {
      
      

     = 

     = 
    

      =  {
          
    }  {
        
    }

     = 

     
}
 别的行为也是类似的实现方式。

     {
    
}

     {
     = 

       =   

       = 
    

     = 

     
}
 每次行为方法被调用，返回的向量会被加到的属性中。这个属性就代表了所有行为的结果。
在所有行为被调用之后，会把的值赋给的。
   {
       = 
       = 

     _
      

    
     

    
}作者：，腾讯适配测试负责人、专家兼容测试负责人商业转载请联系腾讯获得授权，非商业转载请注明出处。原文链接：

一、项目背景
《乱世王者》是一款历史架空背景的战争策略手游，最大程度的还原策略游戏的精髓的同时加入了元素，玩家将化身为在这个乱世中的一方诸侯，从招兵买马、武将的养成到安邦治国，逐步走向问鼎天下的争霸之路，在同类游戏中位于佼佼者，它的成功取决于紧密的游戏逻辑、精细的游戏画面以及优秀的游戏品质。
二、游戏品质
《乱世王者》做为腾讯首款战争策略手游，无论游戏性以及品质都达到了一个令人满意的程度，在正式上线一周内便成功达到畅销排行前三的佳绩。传统的策略游戏中融入、主播引导、互动等模式，将其完美的糅合在一起，同时三国名将悉数登场、名城复古重现以及各个经典战役元素，使得游戏策略性、代入感和可玩性都更加吸引人。
三、测试过程
游戏品质离不开质量控制，《乱世王者》也一样，游戏的每个部分都进行专业测试，其中负责支持了兼容性测试部分，为了保证兼容性方面的质量从轻测版本到运营上线做了数十次全量兼容测试，目的就是保证产品在兼容性方面的质量。
特殊机型纳入测试范围：除了正常的按照腾讯大数据平台排名选取的 和 全机型泛覆盖之外，还加入了新上市的热门机型，如三星 系列以及苹果的帧数 系列。从使用人群和机型热度方面入手，扩大硬件的覆盖范围。三星是属于大分辨率机型，此前市场上该分辨率机型较少，基于多年测试手游兼容性的经验，我们认为这种特殊的分辨率可能会导致很多游戏产生兼容性问题。因此在正常的机型列表之外，特别加入的测试，例如系列手机上高分辨率导致的显示不全以及画面超框的问题。在游戏上线前，提前修复可能产生的兼容问题，保障产品质量。
游戏功能覆盖策略：丰富的游戏内容带来的便是庞大的测试对象，随着内容不断丰富和完善，只能针对性的制定个性化的用例，进行某一模块及机型的测试，从游戏功能部分进行拆分，例如：游戏中运营活动、新功能副本、周期限时活动等等游戏特色之处进行分模块话测试，更是将界面、社交功能如好友、分享等进行分别测试，将兼容性测试化整为零，使得测试覆盖面更加完善。
系统版本：系统版本不兼容导致游戏问题影响比较致命，一般是无法安装或者无法运行，针对这个现象兼容性测试中心专门配有低系统版本以及最新发布的系统版本机型号，低版本例如 系统、 系统，新发布系统如 、 。
在 系统正式版本还没有上线之前，兼容性测试中心已经将手机系统提前升至  版并投入到测试中，提前将系统在游戏中所遇到兼容的问题如横屏不匹配、话音不同步等反馈给项目组，进行优化调整修复。以便 系统上线后，保障用户对游戏的体验。
 图片来自网络
除了 系统，还有新推出的 系统，目前只有小部分机型才可以升级系统，但是，这些小部分机型也在兼容测试中心的测试机型列表上，足以看出兼容性测试为用户的游戏体验创造了良好的环境，规避了用户体验差的风险。
 奥利奥…图片来自网络
兼容性典型问题
 经历了多个版本测试后，兼容性的问题基本都以及得到了修复，较明显且通用的问题如下：
、虚拟键盘机型问题。在虚拟键盘关闭后，游戏不能自适应恢复屏幕画面。导致虚拟键盘收起位置被空白占据，整个画面上移压缩引起画面显示异常
、游戏特有的系统兼容问题。小部分机型出现背景花屏且无法定位到活动人物，导致部分用户无法参与该活动。
 低配机型的性能问题。尽管游戏容量较大，在运行时候需要的性能资源还是有一定要求，但都能在测试机型上正常进行游戏，部分内存机型会出现切换后台时被系统优先前台程序模式将进程终止，由于是系统优化自身的一个机制，所以也是大部分大型游戏在低配机型上难以避免的情况。
最终效果
在项目测试阶段，兼容性测试团队累积为《乱世王者》挖掘出了个兼容性问题，其中个严重及以上问题，将 、无响应、问题等揭露出来，提前进行修复或对问题进行评估，规避了适配风险，为游戏正式开启不删档运营，为用户良好的游戏环境提供了坚实的支持和保障。

关于兼容性测试团队
腾讯兼容性测试团队积累了年的手游测试经验，旨在通过制定针对性的测试方案，精准选取目标机型，执行专业、完整的测试用例，来提前发现游戏版本的兼容性问题，针对性地做出修正和优化，来保障手游产品的质量。目前该团队已经支持所有腾讯在研和运营的手游项目。
服务目前已经对外开放，欢迎前来使用：。 兼容性测试团队期待与您交流！ ， ！
如果对使用当中有任何疑问，欢迎联系腾讯企业：原文：             作者： 翻译：文章来源于：程序师

译者注：经过多年的沉寂之后，今天的正在复出。缘由如何？ 这对数据社区有什么影响？看看本文的分析。以下为译文。

自从可以利用计算机做事以来，我们一直在收集的数据以指数级的速度在增长，因此对于数据存储、处理和分析技术的要求也越来越高。在过去的十年里，由于无法满足这些要求，软件开发人员就抛弃了它，也就因此而渐渐发展起来：，，，等等。

然而，如今正在重新复出。云端的主要供应商们现在都提供了广受大众欢迎的托管关系型数据库服务：例如 ，谷歌 ，的数据库将于今年发布。用亚马逊自己的话来说就是数据库结合了和数据库，因此该产品一直是“历史上增长最快的服务”。在和之上的接口继续蓬勃发展。就在上个月，推出了支持。

在这篇文章中，我们将研究现在为什么会复出的原因，以及这对未来的数据社区工程和分析意味着什么。
第一章：新希望
为了理解为什么会卷土重来，让我们先了解一下最初设计它的原因。

好的故事都是起源于世纪年代
我们的故事始于世纪年代早期的研究，那时关系型数据库就诞生了。当时的查询语言依赖于复杂的数学逻辑和符号。 和 两个人刚刚完成哲学博士学位，对关系型数据模型印象深刻，但是发现查询语言将成为其发展的一个主要瓶颈。于是他们便开始设计一种新的查询语言用他们自己的话说：“让那些没有接受过数学和计算机编程方面正规训练的用户更容易使用”。

两个查询语言的比较 © 
仔细想想这件事。在互联网出现之前，在个人电脑出现之前，当编程语言首次被引入世界时，两位年轻的计算机科学家意识到，“计算机行业的成功很大程度上依赖于培养一种除了训练有素的计算机专家以外的用户。”他们想要的是一种像英语一样易于阅读的查询语言，这也将包括数据库管理和操作。
其结果就是在年首次将引入世界。在接下来的几十年里，将被证明是非常受欢迎的。随着诸如 、、、、 、、等等关系型数据库接管了软件行业，也成为了与数据库交互的卓越语言，成为了一个日益拥挤、竞争激烈的生态系统的通用语言。
遗憾的是， 从来没有机会见证的成功。个月后他便死于脑动脉瘤，只做了一个最早的演讲，当时他只有岁，留下了一个妻子和一个年轻的女儿。
有一段时间，似乎成功地完成了它的任务。但后来互联网发生了。
第二章：的反击
在和都在开发的同时，令他们没有想到的是在加州的第二组工程师正在研究另一个正在萌芽的项目，该项目后来会广泛扩散并威胁到的存在。这个项目就是阿帕网，年月日，它诞生了。

的一些创造者，最终演变成今天的互联网来源一直发展的都很好，但是直到年，另一个工程师出现并发明了万维网。

发明网络的物理学家来源
像那些茂密的野草一样，互联网和网络蓬勃发展，极大地扰乱了我们的世界，但对于数据社区来说，它还造成了一个特别的麻烦跟以前相比，新的数据源以更高的数量和速度生成数据。
随着互联网的不断发展，软件社区发现，当时的关系型数据库无法处理这一新的负载。因此出现了一阵骚动的力量，就好像一百万个数据库突然过载了。
然后，两个新的互联网巨人取得了突破，并开发了他们自己的非关系型分布式系统来帮助解决这一新的数据冲击：由谷歌发布的年出版和年出版，以及亚马逊发布的  出版。这些开创性的论文导致出现了更多的非关系数据库，包括基于文件，，受和文件的启发，年和。因为这些新系统基本上都是从零开始编写的，所以它们也没有使用，导致了运动的兴起。
开发者社区的软件工程师们也接受了，而且跟当时的出现相比，接受的群众范围更广了。这个原因很容易理解：是现在流行的；它承诺了规模和权力；这似乎是项目通往成功的捷径。但后来出现了问题。

典型的被诱惑的软件开发人员。不要学这家伙。
开发人员很快发现，没有实际上是非常有限的。。每个数据库都提供了自己独特的查询语言，这意味着：学习更多的语言并在同事之间传播知识增加了将数据库连接到应用程序的难度，导致代码之间有很强的耦合性缺乏第三方生态系统，需要公司开发自己的操作和可视化工具。
这些语言是新的，但也没有完全开发出来。例如，关系型数据库已经运行很多年了，像为添加必要的特性例如这些工作早都已经完成了语言的不成熟意味着在应用程序级别就会有更多的复杂性。缺乏也导致了反规格化，从而又导致数据膨胀和僵化。
一些数据库添加了自己的“类”查询语言，比如的。但这常常会使问题变得更糟。如果使用跟别的东西完全一样的界面，如果越常见，实际上会导致心理产生更多的疑问：工程师压根就不知道支持什么，不支持什么。

类的查询语言就像《星球大战》假日特别节目。接受不模仿。而且总是避免《星球大战》的特别节目
社区中的一些人在早期就看到了的问题例如德维特和斯通布雷克在年就发现了。随着时间的推移，通过使用过程中个人经验的辛苦积累，越来越多的软件开发人员也同意了这一点。
第三章：的回归
最初被黑暗势力所诱惑的软件社区开始看到了光明，也上演了英雄回归的一幕。
首先是上的接口之后也是，导致该行业兴起了，表示“不只是”  。
紧接着兴起了：完全接纳了的新的可扩展数据库。来自于麻省理工学院和布朗大学研究人员的年出版是最早的扩展数据库之一。谷歌再次引领了风向标，根据他们的 论文出版于年其作者包括原始的作者开创了地缘重复的界面的数据库，其次再是这样的其他先驱者。
与此同时，社区开始复苏，添加了一些关键的改进，比如数据类型，以及 中的新特性的：对分区和复制更好的本地支持，支持对的全文搜索，以及其它更多的特性定于今年晚些时候发布的版本。其他如以及其他的公司今年发布的找到了新方法从而针对特定数据工作负载的扩展。

事实上，我们开发的过程与这个行业的发展轨迹是密切相关。早期的内部版本使用了我们自己的类查询语言“”。是的，我们也没能抵挡住黑暗一面的诱惑我们感觉能够构建自己的查询语言应该会非常强大。然而，尽管这似乎是一条简单的道路，但我们很快意识到其实需要做更多的工作。我们还发现自己需要不断地去查找合适的语法，去查询那些已经可以用进行查询的内容。有一天，我们意识到构建自己的查询语言毫无意义。最关键的还是要接受。这是我们做出的最好的设计决定之一。顿时，一个全新的世界出现了。现在尽管我们的数据库才问世个月但是用户却可以在生产环境上使用我们的数据库，还有很多其他的美好事物可视化工具与常见的的连接器各种工具和备份选项丰富的在线教程和语法解释等等。
信谷歌，得永生

图：为什么正在击败，这对未来的数据意味着什么谷歌已经在数据工程和基础架构领域领先了十多年了。我们应该密切关注他们正在做的事情。
看看谷歌的第二大论文，就在四个月前发布的成为一个系统，年月，你会发现它支持我们的发现成果。
例如，谷歌开始的时候是在上面构建，但后来发现不用会造成很多问题强调了我们下面的所有引用

虽然这些系统提供了数据库系统的某些优点，但它们缺少许多应用程序开发人员经常依赖的传统数据库特性。举一个关键的例子就是一个健壮的查询语言，这意味着开发人员必须编写复杂的代码来处理和聚合应用程序中的数据。因此，我们决定将变成一个完整的系统，查询执行与的其他架构特性紧密集成例如强一致性和全局复制。

在论文的后面，他们进一步抓住了从过渡到的基本原理

的原始提供了对单个和交叉表的点查找和范围扫描的方法。虽然方法提供了一个简单的启动扳手的方法，并且在简单的检索场景中继续有用，但是在表达更复杂的数据访问模式和将计算推到数据上提供了重要的附加价值。

本文还描述了的采用是如何在扳手上不停止的，但实际上扩展到了谷歌的其余部分，这里的多个系统现在共享一个通用的方言

扳手的引擎共享一个共同的方言称为“标准”与其他几个系统在谷歌上钻包括内部系统如和小孔等和外部系统如…
对于谷歌的用户来说，这降低了跨系统工作的障碍。一个开发人员或数据分析人员编写了针对数据库的，可以将他们对该语言的理解转移到，而不必担心语法、空处理等细微的差异。

这种方法的成功不言自明。已经成为主要谷歌系统的“真相之源”，包括和谷歌游戏，而“潜在的云客户对使用非常感兴趣”。
考虑到谷歌首先帮助发起了运动，很值得注意的是，它现在正在接受。导致一些人最近想“谷歌在年的假时间里发送了大数据产业吗”
这对数据的未来意味着什么将变成细腰
在计算机网络中，有一个概念叫做“细腰结构”。
这个想法的出现解决了一个关键问题在任何给定的网络设备上，想象一个堆栈，底层的硬件层和顶部的软件层。中间可能会存在各种网络硬件同样，也存在存在各种各样的软件和应用程序。需要某种可以确保无论硬件发生了什么情况，软件仍然可以连接到网络的方法同样的也能确保无论软件发生什么，网络硬件都知道如何处理网络请求。

在网络中，细腰的角色由互联网协议扮演，它是为局域网设计的底层联网协议和更高级别的应用程序和传输协议的公共接口。这是一个很好的解释。而且在一个广泛的简化中，这个公共接口成为了计算机的通用语言，使网络能够相互连接，设备可以通信，而这种“网络网络”可以发展成为今天丰富多样的互联网。
我们认为已经成为数据分析的细腰。
我们生活的时代，数据正在成为“世界上最有价值的资源”《经济学人》，年月。因此我们看到了专业数据库、时间序列、文档、图表等，数据处理工具数据总线等呈现出了寒武纪大爆发式的情形。我们也有了更多需要依靠这些数据基础设施的应用程序无论是第三方数据可视化工具 框架或定制的数据驱动的应用程序。

像网络一样，我们也有一个复杂的堆栈，底层的基础设施和顶部的应用程序。通常，我们最终会编写大量的胶水代码来完成这个堆栈工作。但是胶水代码可能很脆弱需要精心的运维。我们需要的是一个公共接口，允许堆栈的各个部分彼此通信。理想情况下，这个行业已经标准化了。它能让不同层之间的通信阻碍能够降到最小。
这就是的力量。和一样，也是一个公共接口。
但实际上比复杂得多。因为数据还需要支持人类分析。而且，创建者最初给它设定的目标之一就是可读性要高。
是完美的吗不，但社区中的大多数人都已经了解了这门语言。虽然已经有工程师在开发更自然的语言界面，但是这些系统最终会连接到哪里还是。
所以在堆栈的顶部还有一层。那一层就是我们人类。
回归
回来了。不只是因为在组装工具时编写胶水代码的做法十分令人反感。不仅仅是因为学习各种各样的新语言是困难的。也不只是因为标准会带来各种优点。
也因为这个世界充满了数据。它包围着我们，束缚着我们。起初，我们依靠人类的感觉神经系统来处理它。现在，软件和硬件系统也变得足够智能，可以帮助我们。随着收集的数据越来越多，我们也可以更好地认识这个世界，系统的复杂性、存储、处理、分析以及对这些数据可视化的需求只会继续增长。

数据科学家尤达大师
我们可以生活在满大街的系统都是如纸一般脆弱，接口量达到数百万个的世界里。 或者我们可以再次选择，这样我们生活的世界也可能会变得越来越强大。网上相关例子基本都是 ，然后个人去看了看官网，看了半天没找到合适又简单的，，由于界面不适合项目里面的，要是修改他的样式我还可能出现更多的错误，于是打算自己手写一个，一个是锻炼自己的能力，第二是通用，易于修改，下一次要用到的时候自己拿来主义即可。
下面是代码
       
 =

 = = = 
无标题文档
 = =

_ {   }
_  {     }
_{  }
{ }
{ }
{}


 =_


      = {
             
                {    首页     }
                {    车辆买卖   
                    
                         {    新车   
                            
                                {    奥迪     }
                                {    别克     }
                            
                         }
                         {    二手车    
                             
                                {    宝马     }
                                {    悍马     }
                            
                          }
                         {    改装车     }
                    
                }
                {    宠物     }
          
        }

          {
            生成树菜单
               =  =
              
             _
             隐藏显示树菜单
             _ 

              { 
                  == {
                        
                     
                 }  == {
                     
                      
                 }
             }
        }

        _为数据
        为要组合成的容器
         _  {
                _ {
                如果有子节点，则遍历该子节点
                 _   {
                    创建一个子节点
                      =  =  
                    将的文本设置好，并马上添加一个空白的子节点，并且将这个添加到父亲节点中
                    _
                    将空白的作为下一个递归遍历的父亲节点传入
                    _ 
                }
                如果该节点没有子节点，则直接将该节点以及文本创建好直接添加到父亲节点中
                 {
                   _
                }
            }
        }



代码使用了递归，方法还是借鉴他人，然后加以修改完善，最终得到一个自己使用的灵活例子。作者：陈星百，腾讯移动客户端开发 工程师
商业转载请联系腾讯  获得授权，非商业转载请注明出处。
原文链接：
 导读
做了大概半年多  应用了， 由于双眼  渲染的原因，对性能的优化要求比较高，在项目的进展过程中，总结了一些关于移动平台上  的性能优化经验，供分享。

一、移动平台硬件架构
移动平台无论是  还是  用的都是统一内存架构， 和  共享一个物理内存，通常我们有“显存”和“内存”两种叫法，可以认为是这块物理内存的所有者不同，当这段映射到 ，就是通常意义上的内存；当映射到 ，就是通常意义上的显存。并且同一段物理内存同一时刻只会映射到一个 。

即使是在同一物理内存上 ，之前的   规范中  和  之间的内存是不能共享的， 和  的  是需要拷贝的。后面出来的  与  的  可以共享内存。
了解了移动平台的硬件架构，就知道了    带宽    内存 都有可能成为移动平台  应用性能瓶颈。
二、移动平台  应用的画面渲染过程
、 通过调用绘制命令称为一次  来告诉  开始进行一个渲染过程的。一个   命令会指向本次绘制需要渲染的信息，这些信息包括：顶点数据、纹理数据、 参数光照模型、法线方向、光照方向等等，简单地说就 画什么，用什么画，怎么画。
、 接收到   命令之后就会开始进行一次单元渲染，关于  的单元渲染的过程是这样的简单示意图：
从显存中取出拷贝的顶点数据和光照模型。
通过顶点处理器 对顶点数据进行一系列的变换和光照处理，包括裁剪处理。 简单的想想，游戏中的各个物体的坐标都是参照游戏中的世界坐标系的，而实际显示的画面是玩家视角或者摄像机视角，这中间就有许多坐标系的转换。这些活就需要顶点处理器来做，最终我们得到了我们所需要视角的画面。
到这一步，画面还只是一些多边形，而实际显示在屏幕上的是一个个像素，这里就需要光栅处理器  进行光栅化，从而将画面变成一个像素图，把所有的顶点对应到一个一个的像素位置。
对这些像素进行上色，通过片元处理器 中的像素着色器 按照  光照模型，根据纹理对应位置颜色，计算元颜色，再经过深度计算、透明测试计算出每个像素的最终颜色。
把结果输出到图像缓存中，全部完成后拿去显示。
三、 应用性能优化之 
 的优化非常重要， 的表现直接决定了  应用的帧率，应用的耗电量，发热量。我们来看看相比于普通的 ， 应用的  都承担了什么责任：、业务逻辑 、网络通信 、 操作 、 、 逻辑 、 内存回收 、垂直同步等待。
业务逻辑、网络通信、 操作
这一块的优化和普通的  差不多。
关于业务逻辑：有些不同的是  脚本中有一类  方法、、 等，这一类方法是在每帧刷新的时候调用的是比较影响每帧耗时的，为了严格控制这一部分的执行时间，需要注意的以下几点：、尽量不要再  函数中做复杂计算，如有需要，可以隔  帧计算一次，对于纯数学计算，可以开辟新线程来计算 为什么一般避免使用多线程 实际上大多数游戏引擎也都是单线程的 因为大多数游戏引擎是主循环结构 逻辑更新和画面更新的时间点要求有确定性 如果在逻辑更新和画面更新中引入多线程 就需要做同步而这加大了游戏的开发难度。 绝大多数类是不支持子线程的，所以一般只有纯数学计算才会用到子线程去计算。
、关闭所有在  类中执行  的打印操作 中一次  打印有时长达 ， 数据。
、不在  类方法调用 、、 这几个耗时较长的方法。
、不在  类方法中使用临时变量。
关于网络通信、 操作：这些普通  的优化和注意点没有什么很大区别，有一点是， 工程中使用了资源动态加载，有些资源是保存在服务器端的，在有必要的时候才会通过网络  下去加载。这个资源动态加载需要注意一个问题：由于网络通信过程， 总是处于等待的状态，一般资源下载是多线程同时操作，为了尽快上屏显示资源在这个工程中是一些图片和英雄的  模型，但是资源有可能是在同一个帧周期中下载完毕的，如果直接加载的话，可能会出现  瞬时渲染过多三角形面，造成渲染时间 函数执行时间过长，，卡顿的现象。所以这里要注意，网络下载可以多线程多任务同时下载，但是在  主线程，要避免出现同时加载大型模型和大纹理的情况，最好使用队列的方式，保证一帧只渲染一个  模型。
关于 
为什么要把  放在  这一部分？虽然  是用来处理内存回收的，但是却增加了  的开销 一次开销可长可短，有时长达 。因此对于  的优化目标就是尽量少的触发 。

首先我们要知道所谓的  是  运行时的机制，而非  游戏引擎的机制，所以  也主要是针对  的对象来说的，而它管理的也是  的托管堆。 明白了这一点，你也就明白了  不是用来处理引擎的 贴图，音效，模型等等的内存释放的，因为  引擎也有自己的内存堆而不是和  一起使用所谓的托管堆。其次我们还要清楚什么东西会被分配到托管堆上？对，就是引用类型。引用类型包括：用户自定义的类，接口，委托，数组，字符串，而值类型包括：几种基本数据类型如： 等，结构体，枚举，空类型。所以  的优化也就是代码的优化。
那么  什么时候会触发呢？两种情况：、当我们的堆的内存不足时，会自动调用  来回收内存。、手动的调用 ，用 一般情况下，不建议手动去手动进行内存回收，因为容易出现问题。
检查整个工程代码，关于减少  这一方面的优化经验总结大概如下：、字符串连接的处理。因为将两个字符串连接的过程，其实是生成一个新的字符串的过程。而之前的旧的字符串自然而然就成为了垃圾。而作为引用类型的字符串，其空间是在堆上分配的，被弃置的旧的字符串的空间会被  当做垃圾回收，可以使用  来解决注意：没有  里才有！！ 在进行运算时如赋值、拼接等会产生一个新的实例，而  则不会。所以在大量字符串拼接或频繁对某一字符串进行操作时最好使用 ，不要使用 。
、尽量不要使用 ，而是使用 。 其实会涉及到迭代器的使用，而据传说每一次循环所产生的迭代器会带来   的垃圾。那么循环  次就是 。
、不要直接访问  的  属性。比如   ==“” 最好换成   “”。因为访问物体的  属性每次  也会分配  的堆内存会在堆上额外的分配空间。如果在循环中这么处理，留下的垃圾就可想而知了。
、不要实例化和对象，事先建好对象池，以实现空间的重复利用。
、在某些可能的情况下，可以使用结构来代替类。这是因为，结构变量主要存放在栈区而非堆区。因为栈的分配较快，并且不调用垃圾回收操作，所以当结构变量比较小时可以提升程序的运行性能。但是当结构体较大时，虽然它仍可避免分配回收的开销，而它由于传值操作也会导致单独的开销，实际上它可能比等效对象类的效率还要低。所以要注意选择。
、场景切换时，可以主动进行垃圾回收调用 ，从而及时去除游戏中已经不必要地内存占用。
  的优化
前面说过了， 是  调用底层图形接口的操作。比如有上千个物体，每一个的渲染都需要去调用一次底层接口，而每一次的调用  都需要做很多工作，那么  必然不堪重负。但是对于  来说，图形处理的工作量是一样的。
我们先来看看   对  的消耗大概是一个什么级别的量： 在  曾提出，  会吃满  的 ，的使用率。有一个公式可以和清楚得计算出在给定的  资源 与 帧率的情况下，最多能有多少个 。_ =   _  _  。_ ：  数量_   工作频率 单位_： 分配在  这件事情上的时间率百分比
：希望的游戏帧率
比如说我们使用一个高通 ，工作频率在  上，分配 的  时间给  上，并且我们  要求  帧，那么一帧最多能有  个 由于双  的存在，单眼  只能保证在  个以内。其实， 官方的建议是单眼  不多于  个。
所以对  的优化，主要就是为了尽量解放  在调用图形接口上的开销。所以针对  我们主要的思路就是每个物体尽量减少渲染次数，多个物体最好一起渲染。那么  次数的优化有哪些方案呢？
  批处理 即批处理，  即  的批处理，即把多次  合并成一次  的方案。
  动态批处理 引擎对于使用相同材质的物体会自动进行批处理，相同材质意味着  完全一样，这一部分主要是要注意那些破坏这一特性的人为因素，比如说：、批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于  顶点的网格物体，如果你的着色器使用顶点位置，法线和  值三种属性，那么你只能批处理  顶点以下的物体如果在这基础上还使用了 ，则只能批处理  顶点以下的物体；请注意：属性数量的限制可能会在将来进行改变。
、使用不同的缩放比例的物体， 将无法对这些物体进行批处理。比如和就不会动态批处理，但是和会动态批处理。
、拥有  的物体含有额外隐藏的材质属性，比如： 的偏移和缩放系数等。所以，拥有  的物体将不会进行批处理除非他们指向  的同一部分。接受实时阴影的物体也不会批处理。
、多通道的  会中断批处理操作为了达到特殊的渲染目的，可能某个物体要多遍渲染这是就要多个通道。
、在脚本中动态地指定了物体的材质，也不会进行批处理。
  静态批处理动态批处理虽然是自动的，但是限制非常多，不小心就会打破批处理，所以  在专业版中还提供了静态批处理，静态批处理要求是想批处理的物体一定是  的，静态的，不会改变位置和旋转角度以及缩放的，且必须材质一致。其原理是把物体的网格进行合并，变成一个静态的更大的网格物体，再使用一个统一的材质进行渲染。
知道了它的原理，它的某些坑就比较清晰了：、在一个平行光、环境光下，没有问题，但是如果你使用了多个平行光，点光源，聚光灯这种复杂的光源去照射物体，那么静态批处理就会被打断。项目中就遇到过，因为两边有两排英雄模型，所以场景中使用了两个不同平行光，场景中勾选的  物体并没有被合并 ，经过一番折磨才找到原因。
、如果静态批处理前有一些物体共享了相同的网格，那么每一个物体都会有一个该网格的复制品本来  只会保留一份，但是静态批处理会生成新的一个大网格，所以会保留所有物体的网格，最后合并，即一个网格会变成多个网格被发送给 。这样会造成内存的使用变大，需要注意这个问题，但是一般场景中使用相同网格的物体会比较少。
、对于那些  相同，纹理不同导致的不同材质无法进行批处理的物体比如项目中的场景环境，基座，地面，其实都使用了  自带的  可以通过纹理合并的方法来使得它们可以被静态批处理。这就引发了下面的事情： 总线带宽 完成一次 ，除了需要发一个  的命令之外，还需要把内存中顶点数据、纹理贴图、 参数通过  总线拷贝到内存分配给  的显存之中，注意这是拷贝，不是指针传递，速度不快。如果一次  传递的数据过大，带宽成为了瓶颈，那就会大大影响效率其它的  无法出发， 又处于闲置。这种情况最有可能出现在为了减少 ，疯狂的合并纹理上。在项目中， 的  调用占了很大一部分，也会最难优化的，为了减少  我们把  模块的静态部分一些  的底板，背景等不会发生变化的全部合并成了一个纹理，最后导致了  下降了，但是帧率却也下降了，内存使用也增加了，原因就是这个。在项目中，不会同时出现的元素不要打包到一起，保证单张合并纹理不大于  一般就不会有问题了王者荣耀最大纹理限制在了 。
 的优化大概就是这些，优化的目标其实是往一个目标上靠， 的  命令刚刚好能被  消化，不要让  等待带宽限制，也不要让  闲置。如果即使做到了这个，应用帧率还是上不去，那么就只能去削减场景，做有损优化了。

 内置   物理引擎，来模拟物理世界的一些效果，比如说重力、阻力、弹性、碰撞这些，其中使用了一些内置的组件来实现这些模拟，用的比较多的如：刚体 各种碰撞器 恒力   物理材质 铰链关节 弹簧关节 。
 除了提供了一些重要的组件之外，在  脚本中的生命周期中提供了一个专门为物理计算的刷新方法：。 跟  的区别在于，这两个函数处于不同的“帧循环”中， 处于  循环中，而  不是。所以这两个函数的使用也有了不同。 的执行受场景  的渲染的影响，三角形的数量越多，渲染所需要的时间也就越长。 的执行则不受这些影响。所以， 每个渲染帧之间的间隔是不相等的，而  在每个渲染帧之间的时间间隔是相等的。由于关系到物理模拟，所以一般涉及到物理组件，都需要放在  中进行计算。那么关于 ，一般的优化手段都有哪些呢？下面是一些经验及总结：
、将物理模拟时间步间隔设置到合适的大小。   是和物理计算有关的，所以若计算的频率太高，自然会影响到  的开销。同时，若计算频率达不到软件设计时的要求，有会影响到功能的实现，所以如何抉择需要具体分析，选择一个合适的值，一般大于 ，小于 。可以通过   来改变这个值。
、谨慎使用网格碰撞器 ，过于消耗性能，一般使用更简单的碰撞器，或者使用基本几何碰撞器合并的组合碰撞器。在这个项目中，把所有的网格碰撞体都抛弃了，都换成了  。
、真实的物理刚体很消耗，不要轻易使用，尽量使用自己的代码数学计算模仿假的物理。
、最小化碰撞检测请求例如   和  ，尽量从每次检查中获得更多信息。项目中涉及到物体的组件很少，关于  的优化肯定还有很多可以说的，需要再去学习了。

简单地说，这是  优化的最直接的一个方法。
科普： 垂直同步又称场同步 ，垂直同步信号决定了  从屏幕顶部画到底部，再返回原始位置的时间。从  显示器的显示原理来看，单个像素组成了水平扫描线，水平扫描线在垂直方向的堆积形成了完整的画面。显示器的刷新率受显卡  控制，显卡  完成一帧的扫描后就会产生一个垂直同步信号决定于屏幕的刷新率。我们平时所说的打开垂直同步指的是将该信号送入显卡  图形处理部分，从而让显卡在生成  图形时受垂直同步信号的制约注意是制约。
如果我们选择等待垂直同步信号也就是我们平时所说的垂直同步打开，那么在游戏中或许强劲的显卡迅速的绘制完一屏的图像，但是没有垂直同步信号的到达，显卡无法绘制下一屏，只有等垂直同步的信号到达，才可以绘制。这样  自然要受到操作系统刷新率运行值的制约。而如果我们选择不等待垂直同步信号也就是我们平时所说的关闭垂直同步，那么游戏中作完一屏画面，显卡和显示器无需等待垂直同步信号就可以开始下一屏图像的绘制，自然可以完全发挥显卡的实力。但是不要忘记，正是因为垂直同步的存在，才能使得游戏进程和显示器刷新率同步，使得画面更加平滑和稳定。
取消了垂直同步信号，固然可以换来更快的帧率，但是在图像的连续性上势必打折扣。

针对手游的性能优化，腾讯  平台的  工具提供了基本所有相关指标的检测，为手游进行最高效和准确的测试服务，不断改善玩家的体验。
目前功能还在免费开放中。，欢迎点击链接： 使用。导语
年“云未来”峰会即将在深圳盛大举行，本次峰会   技术专场将在月日下午举行。  专场给各家提供了针对  应用以及背后填坑之路作深度探讨的机会。现在让我们一起回顾下去年各位嘉宾在在现场分享了哪些云上的心得体会以及 云原生架构上的亲身实践。
本文是极客学院联合创始人  姚尚朗在年腾讯“云未来”峰会   专场有关《以 理念构建更健壮的在线教育平台》分享的回顾。
姚尚朗：《以 理念构建更健壮的在线教育平台》
极客学院进行了国内首个在线教育领域的 实践分享。极客学院是国内最大的职业在线教育平台，以 理念构建更健壮的在线教育平台，极客学院的联合创始人姚尚朗分享了腾讯云上如何实践 ，从早期的服务器单点到基于腾讯云的服务器集群，应用 的持续集成、自动化部署、业务微服务化的解决之道，成功解决了业务耦合高、逻辑复杂等一系列挑战。

姚尚朗提到在业务层面以及技术层面怎么解决在线教育所面临的挑战。首先要能匹配职业的特殊性，其次要能服务更多的人。
那么如何服务好更多的用户？这就是第三点能有更高性价比，姚尚朗介绍了其中的技术逻辑：“我要做教育这件事情，在服务单个用户的时候所消耗的时间成本和空间成本变得越来越低越好，这句话比较拗口，但是仔细想想应该是说得通的，就是因为成本的降低，我们可以更高性价比的服务更多的人，在线教育这件事情才有价值。如果我每年只服务人、万人，甚至万人，我觉得没有价值，跟传统的高校教育没有本质的区别。

最后重点提到要让”学习更有效”。我们所有的事情都围绕一个核心，我这件事情能不能帮大家在学习的时候省些时间，这个时间就会对应到我们的产品是不是快速的响应，用户需要的服务是不是能快速的提供。我们就是从这两个维度来做技术的搭建和运维。

接下来，姚尚朗在发言中提到极客学院从一开始创立到现在差不多迭代了个版本，并对这每个版本的所处的状况，所遇到的挑战，如何借助腾讯云的服务器集群解决这些问题，以及后期遗留了哪些隐患进行了详细的解说。






最后，姚尚朗做了总结：“极客学院已经上线年多，有万用户，在这个过程中，我们技术解决的问题是随着用户而升级的。从 几个层面来讲，从到虚拟机，到，到现在还有一个方面是持续交付，从到，到运维和测试。将业务方面和技术相结合。”


相关推荐云时代程序员的社会责任和机会本文是【开源项目贡献指南】系列的第一章，原文【  ——     】

为何要给开源项目做贡献？

给做贡献帮助我学到了很多后来在大学和实际工作中用到的技能，我觉得给开源项目工作对我的帮助和对项目本身的帮助相差无几。
— “       ”

给开源项目做贡献可以说是在你能想象的领域上学习，传授，累计经验的最有效的方式！为什么人们要给开源项目做贡献，原因太多了！
提高现有技能
不管是写代码，用户界面的设计，图形设计，写作，或者是组织，如果你想找点练习做一做，在开源项目上你总能找到能胜任的任务。
认识和你有同样爱好的人
气氛融洽开放的开源项目会让人数年之后仍然不忘回来看看项目进展。许多人在参与开源项目的过程中结识了一生挚友，友谊在会议的互相照面和深夜的线上闲聊中渐渐形成。
寻找导师或者教导别人
和他人一起合作一个项目意味着你得解释你是怎么做事情的，同时寻求他人的帮助。学习和传授知识的体验对每个参与其中的人来说都是令人愉快的体验。
做一个公开的产品帮你赢得声誉和职业机会
从开源项目的定义可以知道，你所有的工作成果都应该公开，这意味着你免费获得了一个向众人展示你能力的机会。
学习他人的技能
开源项目给参与其中的人们提供了锻炼领导力和管理能力的机会，比如解决冲突，组织团队的成员，辨别工作的轻重缓急。
你有权做出改动，就算是很小的
你不需要成为那种一直在给开源做贡献的人。你有在网站上看见手误吗，而且希望有人能修正它。在一个开源项目中，你自己就可以做到。开源帮助人们在生活和对世界的体验上感觉到更有力量，这本身确实是意见可喜的事情。
贡献是什么意思
如果你是一个刚刚开始的开源贡献者，这个过程可能会让你觉得很吓人。如何找到正确的项目？你不知道怎么贡献代码怎么办？如果改错了怎么办？
不必担心！有很多参与开源项目的方法，和一些让你走出困境的小技巧。
你不需要贡献代码
对开源贡献的一个普遍的误解就是你得贡献代码。实际上，通常和代码无关的部分才是最容易忽视的：通过参与非代码部分的贡献会给项目带来巨大的帮助。

我因为对 的贡献而著名，但是大部分人都不知道我在这个工具本身的开发上并没有做实质性的工作。我花在这个项目上的主要时间都用来整理文档和宣传品牌。
—–

即使你是一个开发者，非代码部分的贡献是一个很好的方式让你参与一个项目和认识社区的成员。建立这种关系会给你从事项目其他部分工作的机会。

我第一次接触  开发团队又叫做 是在年月号我给邮件列表发邮件让他们接受我的补丁的时候。我迅速的发现的这个项目的缺陷，并决定负责组织团队的邮件摘要。这给了我一个很好的机会去咨询他们对一个话题的解释，但是实际上更关键的是当有人提出问题的时候我能意识到那是不是需要修复的  。
—–

你喜欢策划活动吗

组织关于项目的研讨会或者线下聚会，就像 

组织项目会议如果他们有的话

帮助社区成员找到合适的会议主题并提交一份发言稿。


你喜欢设计吗？

重构项目的布局以增加其易用性

组织用户使用调查来重构项目的导航或者菜单

把样式指南放在一起以此来帮助项目有一致的视觉设计

设计  或者 新的，就像是的贡献者们做的一样


你喜欢写作吗？

编写或者改善项目的文档

创建一个文件夹展示项目怎样使用的例子

给项目编写教程，就像的贡献者们做的一样

为项目的文档做翻译


认真的说，文档真的是重要得一逼。目前的文档已经很棒了，这也是其杀手锏的特性之一。当然，还有一些章节需要大家的完善，即使是随便在哪儿增加一个段落都很感激。
你喜欢组织吗？

连接重复的 ，或者为某个添加新的标签来让事情变得井然有序

检查打开的 ，就像给做的那样

问一个明确的问题推荐讨论


你喜欢写代码吗？

找一个  去解决。就像给做的那样

询问项目所有者你是否可以帮忙写一个新的功能

使配置项目的过程自动化

改善工具链和测试


你喜欢帮助别人吗

在诸如  或者上回答关于项目的问题这里有一个关于例子

在打开的  中回答人们的问题

帮助调整讨论板块或者对话渠道


你喜欢帮助改善别人的代码吗

审查别人提交的代码

写一个关于项目如何使用的教程

帮助其他的贡献者，就像在项目上为做的那样


你不一定只能给软件项目做贡献！
虽然开源一般指的是软件项目，实际上你可以在任何项目上进行协作。有很多书籍，经验贴，列表，课程都是开源项目。比如：

策划了  系列的列表

持有一份关于前端常见面试问题的列表

 和 制作了一份关于海雀的有趣现象集锦


即使你不是你个软件工程师，给一个文档性质的项目做贡献也会让你迈进开源世界的大门。在没有代码的项目上做事通常没那么吓人相比与有代码的项目来说而且这个写作的过程会让你积累更多自信和经验。
投身于一个新项目
如果你打开一个项目的   。里面的东西可能让你觉得不解，不只是你有这样的感觉。这些工具需要很多的隐性知识，但是人们会帮助你搞清楚，你也可以问他们问题。— “     ”
对于那种不仅仅是修复一个手误的工作，给开源项目做贡献就像是在一个聚会上走近一群陌生人一样。当他们正在热火朝天的讨论金鱼的时候，你插进去开始讲骆驼他们会像你投来异样的眼光。
在你带着你的见解盲目的加入讨论之前，首先研究一下他们到底在讨论什么。这样会增加你的观点被注意到和听取的机会。
分析一个开源项目
每一个开源社区都不一样。
在一个项目上花费数年的事件会让你对这个项目了如指掌。但是当你迁移到另外一个项目中时，你会发现他们的词汇，规范和讨论的风格完全不一样。
话虽如此，很多开源项目还是遵循一个相似的组织结构。理解不同社区的角色和总体的进程会帮助你很快的融入一个新的项目。
一个经典的开源项目会有这样几类人：

作者： 创建该项目的人或者组织

所有者： 对该组织或者仓库有行政权的人通常和原始的作者不是一个人

 维护者： 那些负责宣传项目，管理项目组织的贡献者 他们也可能是作者或者所有者

贡献者： 每个给项目做出或多或少贡献的人

社区成员： 使用项目的人。他们可能在关于项目方向上的讨论中积极发表自己的观点


更大型的项目可能有针对不同工作的子社区或者工作组，比如工具链，工作分配，打造社区的舒适度和事件管理。查看项目网站上的“团队”页面，或者存放管理文档的仓库寻找这些信息。
一个项目也会有他自己的文档，这些文件放在项仓库目的一级目录。

：由于开源项目的定义，每个开源项目都要有一个开源协议。如果一个项目没有一个开源协议，那么他就不是开源项目。

：文件是给社区的新成员的使用手册。它解释了为什么这个项目是有用的和怎么开始使用这个项目。

：文件是帮助人们使用项目的，而文档是帮助人们对项目做贡献。但是不是每个项目都有文件，那么有这个文件就标志着这是一个开放的项目。

__：行动守则制定了参与者行为的基本规则，帮组促进了社区的友好，开放的氛围。但是不是所有项目都有 __ 文件，如果有的话那就标志着这是一个开放的项目。

 ：还可能有其他的文档，比如教程，预览，或者管理政策，尤其是在大型项目中会出现。


最后，开源项目使用下面这些工具来管理讨论。在你阅读本文的过程中，你会对开源社区思考和工作的方式有一个总体的映像。

 ：人们用来讨论和项目相关的问题的地方

  人们用来讨论和审查正在进行中的修改。

    论坛或者邮件列表： 有些项目会用不同的频道对应不同的讨论主题比如说，“我怎样才能…” 或者 “你们对于…的看法是”，而不是  报告或者功能请求。另外一些项目直接用   进行所有话题的讨论。

  匿名的聊天频道：有些项目用聊天频道比如或者来进行随意的讨论，合作，或者快速的修改。


找一个项目来做贡献
现在你已经知道开源项目是怎么工作的了，是时候找个项目然后开始贡献了！
如果你从来没有给开源项目做过贡献，那么从美国前总统约翰·肯尼迪的名言之中吸取一点建议吧：
不要问你的国家能为你做什么，先问问自己你能为自己的国家做什么。
给开源项目做贡献可以发生在任何级别的任何项目。你不需要过分在意你的第一次贡献会是什么，或是以什么形式。
相反，从你已经在用的项目或者你想用的项目开始。你贡献最积极的项目正好是那些你发现你会是不是来看一下的项目。
在那些项目中，尽管释放你的本能，去发现那些你觉得可以做的更好或者做的不同的东西。
开源世界不是一个排他性的俱乐部，它正是有那些像你一样的人创造的。“开源组织”是一个把世界上所有问题看成可以解决的梦幻之地。
你可以浏览一下项目的  文档，找找有没有挂掉的链接或者手误。或者你是一个新用户，而且你发现什么了东西不对，或者一个你觉得应该放在文档中的  ，与其直接忽视或者找别人修复它，还不如自己动手把他改过来。这就是开源的含义啦！
的不固定的贡献者所做的都是在文档上，比如更正手误，重新排版或者提供一种语言的翻译版本。
你还可以用以下的资源来帮助你寻找项目。

 

  

  



  

  


一个在你贡献之前的清单
当你发现了一个你想要贡献的项目的时候，对项目做一快速的浏览来保证这个项目适合接受你的贡献，否则你的工作得不到应有的回应。
这里提供了一份评估一个项目是否适合新的贡献者的清单
检查开源的定义
他有一份开源协议吗？通常情况下是一个在项目根目录下的叫  的文件。
项目接受贡献者的活跃程度
查看  分支上的提交活动。在上，你可以在仓库的主页上看到这个信息
最近一次提交是什么时候
项目目前有多少贡献者
人们提交的频率是怎样的？在  ，你可以通过点击顶部的 “” 来找到。
接下来，查看项目的  。
目前有多少  。
         
项目维护者对打开的  回复的速度如何？
在  中的讨论是否热烈。
 都是在最近的吗？
 被关闭了吗在  ，在  页面点击 “” 标签查看关闭的  。
对项目的   做同样的检查。
目前有多少  ？
项目维护者对打开的   回复的速度如何？
在   中的讨论是否热烈？
  都是最近的吗？
最近一次的   被合并是什么时候？在  ，在   页面点击 “” 标签查看被关闭的  。
项目是否足够开放
如果一个项目是友好和开放的那么意味着他们很乐意接受新的贡献者。
项目维护者对  中的问题的回复时候有帮助？
在  ，论坛，聊天室比如  或者 中的人们是不是乐于助人。 会被审查吗？
项目维护者对贡献者的   表示感谢了吗？

不管何时当你看到核心开发者做出的长篇大论式的，总结性的发言。不妨思考他们总结是建设性的吗？而且在保持礼貌的同时一步一步把讨论引向一个结论。如果你看到了讨论过程中出现摩擦，经常让人叹息的是他们把精力浪费在了争吵而不是开发上面。
—   

如何提交贡献？
假如你已经找到了一个你喜欢的项目，而且你已经准备好做一次贡献。终于！是时候谈谈怎么正确做出贡献啦！
接下篇《 开源项目贡献指南如何给开源项目做贡献 下》作者 | 涂小刚编辑 | 迷鹿

涂小刚，攻城狮一枚，有代码洁癖，热爱学习，热爱生活，痛恨酱油帝、跪舔帝。目前主要从事大数据平台与机器学习平台相关方向的工作，关注与

全称叫做弹性分布式数据集  ，它是一种分布式的内存抽象，表示一个只读的记录分区的集合，它只能通过其他转换而创建，为此，支持丰富的转换操作  如     等，通过这种转换操作，新的则包含了如何从其他衍生所必需的信息，所以说之间是有依赖关系的。
基于之间的依赖，会形成一个有向无环图，该描述了整个流式计算的流程，实际执行的时候，是通过血缘关系一气呵成的，即使出现数据分区丢失，也可以通过血缘关系重建分区。
总结起来，基于的流式计算任务可描述为：从稳定的物理存储如分布式文件系统中加载记录，记录被传入由一组确定性操作构成的，然后写回稳定存储。另外还可以将数据集缓存到内存中，使得在多个操作之间可以重用数据集，基于这个特点可以很方便地构建迭代型应用图计算、机器学习等或者交互式数据分析应用。
可以说最初也就是实现的一个分布式系统，后面通过不断发展壮大成为现在较为完善的大数据生态系统，简单来讲，的关系类似于关系。
特点
表示只读的分区的数据集，对进行改动，只能通过的转换操作，由一个得到一个新的，新的包含了从其他衍生所必需的信息。
之间存在依赖，的执行是按照血缘关系延时计算的。如果血缘关系较长，可以通过持久化来切断血缘关系。
分区
如下图所示，逻辑上是分区的，每个分区的数据是抽象存在的，计算的时候会通过一个函数得到每个分区的数据。
如果是通过已有的文件系统构建，则函数是读取指定文件系统中的数据，如果是通过其他转换而来，则函数是执行转换逻辑将其他的数据进行转换。

只读
如下图所示，是只读的，要想改变中的数据，只能在现有的基础上创建新的。

由一个转换到另一个，可以通过丰富的操作算子实现，不再像那样只能写和了，如下图所示。

的操作算子包括两类，一类叫做，它是用来将进行转化，构建的血缘关系；另一类叫做，它是用来触发的计算，得到的相关计算结果或者将保存的文件系统中。下图是所支持的操作算子列表。

依赖
通过操作算子进行转换，转换得到的新包含了从其他衍生所必需的信息，之间维护着这种血缘关系，也称之为依赖。如下图所示，依赖包括两种，一种是窄依赖，之间分区是一一对应的，另一种是宽依赖，下游的每个分区与上游也称之为父的每个分区都有关，是多对多的关系。

通过之间的这种依赖关系，一个任务流可以描述为有向无环图，如下图所示，在实际执行过程中宽依赖对应于图中的和，窄依赖中的所有转换操作可以通过类似于管道的方式一气呵成执行图中和可以一起执行。

缓存
如果在应用程序中多次使用同一个，可以将该缓存起来，该只有在第一次计算的时候会根据血缘关系得到分区的数据，在后续其他地方用到该的时候，会直接从缓存处取而不用再根据血缘关系计算，这样就加速后期的重用。
如下图所示，经过一系列的转换后得到并保存到，在这一过程中会有个中间结果，如果将其缓存到内存，那么在随后的转换到这一过程中，就不会计算其之前的了。


虽然的血缘关系天然地可以实现容错，当的某个分区数据失败或丢失，可以通过血缘关系重建。但是对于长时间迭代型应用来说，随着迭代的进行，之间的血缘关系会越来越长，一旦在后续迭代过程中出错，则需要通过非常长的血缘关系去重建，势必影响性能。
为此，支持将数据保存到持久化的存储中，这样就可以切断之前的血缘关系，因为后的不需要知道它的父了，它可以从处拿到数据。

小结
总结起来，给定一个我们至少可以知道如下几点信息：、分区数以及分区方式；、由父衍生而来的相关依赖信息；、计算每个分区的数据，计算步骤为：如果被缓存，则从缓存中取的分区的数据；如果被，则从处恢复数据；根据血缘关系计算分区的数据。
编程模型
在中，被表示为对象，通过对象上的方法调用来对进行转换。经过一系列的后，就可以调用触发的计算，可以是向应用程序返回结果   等，或者是向存储系统保存数据  等。在中，只有遇到，才会执行的计算即懒执行，这样在运行时可以通过管道的方式传输多个转换。
要使用，开发者需要编写一个程序，它被提交到集群以调度运行，如下图所示。中定义了一个或多个，并调用上的，则执行分区计算任务。

应用举例
下面介绍一个简单的应用程序实例，统计一个数据集中每个单词出现的次数，首先将从中加载数据得到原始，其中每条记录为数据中的一行句子，经过一个操作，将一行句子切分为多个独立的词，得到，再通过操作将每个词映射为形式，其中为词本身，为初始计数值，得到，将中的所有记录归并，统计每个词的计数，得到，最后将其保存到。

  {
     {
        {
         
      
    }
      =  
      =  
      = 
                    =  
                    =  
                   _  _
    
  }
}
结语
基于实现的相比于传统的 有什么优势呢？总结起来应该至少有三点：
提供了丰富的操作算子，不再是只有和两个操作了，对于描述应用程序来说更加方便；
通过之间的转换构建，中间结果不用落地；
支持缓存，可以在内存中快速完成计算。

相关推荐
【腾讯云的种玩法】  单机环境搭建与初步学习【腾讯云的种玩法】如何利用腾讯云搭建分布式应用最近要检查网卡流量，其实是有各种现存工具，非常容易实现 
但需要把这个东西与 集成起来搞报警什么的。
这些   网管  等等，就不那么实用了。
有个的集成插件，看了下很复杂，想着就自己写一个。
原理就是  这个文件，里面有统计相关的数据包
 的解释。
然后定期执行这个脚本，输出就是带宽以及匹配的性能数据
|       
_= _=  |_= _= _= _= _= _=
下面就是 有内容。没有额外组件。只有   基本命令
 

=
=` `
=_



  {
  
这是一个用来计算网卡流量的脚本，可用于的检测
  
` `  
是告警带宽阀值，=即只能输入数字使用

}

__  {
    |  {  {  =
 _=\_=\_=\ 
 _=\_=\_=\  }
}   
 
}

__  {

  == 
 

}

_  {
         |  {=
__=__
__=__
__=__
__=__
__=__
__=__}
{ _= _=  |_= _= _= _= _= _= __ __ ____________}
{__   || __         }

}



    
        =

        =


 



     

        __
        __
        _


        

直接复制下来可以在  等有 这个文件的进行执行。
第一次和第二次会执行失败，第三以后会执行成功。
如果要集成至 记得检查  这个文件的权限。需要相关用户对此有写权限。最近在某个项目中用到了从上手做开发到项目发布，一步步踩了不少坑。本文试图总结过去一个多月使用中的一些经验，也算是一点心得体会吧，拿出来与大家分享，欢迎多多交流。
简介

                              

这是来自官网的解释，这里我们不打算再照本宣科的把概念翻译一边了，仅就作者使用的心得体会来做出解释。熟悉或者的读者可能对此并不陌生。
与、这些框架一样都持有相同的开发理念，通过扩展原生的等结构化标签来作为其模版语言，此外进一步通过语法上的扩展提供了诸如双向数据绑定、交互数据模型等概念，从而使开发者从繁杂的操作中解脱出来，将更多的精力用于关注业务本身的内容。
此外，与类似的是，均提出了包括虚拟和组件化开发的理念，从而提高了代码的可维护性和性能。试图用一种极简的方式来实现以上这些框架带来的优势，因此，相比于和来说，更加轻量、简介和优美。
下面，在进一步探究之前，我们先看一下的几个核心概念。
组件化
组件化开发是最近两三年比较火的概念。通过使用来创建的组件，就像构建万丈高楼的砖块一样，拥有良好的封装性和复用性。每一个组件都拥有其独立的样式和数据域，并且完全与其它组件完全隔离。简单的讲，任何前端的界面都可以通过合理的规划，划分成拥有不同职责的组件。 关于组件化开发的概念我们不再进一步展开，感兴趣的同学可以进一步阅读这篇文章前端工程基础篇。
的插件化
正如你所知，的核心部分仅保留了包括数据绑定及组件化开发相关的内容。因此才保证了其极简的机制。此外，对于附加的功能也提供了高效灵活的插件化机制。对于大家耳熟能详的插件包括、、等。此外，也提供了允许开发者自己封装组件的机制。从而使你能更有效地抽象某些功能，为团队开发所用。例如，你可以将有关数据计算的逻辑抽象为独立的插件，提供给团队的人使用等。
和
如果你的项目非常简介，没有复杂的逻辑，那么你完全没必要引入。是用来在应用各个组建之间管理和共享应用的模块，如果你使用过那么你应该对不陌生，起到的作用与此类似。

也提供了非常高效的命令行工具，通过使用几个简单的命令就能快速构建基于的组件和应用，极大的减少了开发者的工作量，将开发者从繁杂的重复性的劳动中解放出来。关于，我们不再展开，读者可以阅读进一步了解的功能。
常用指令
提供了包括、、、、、、等内部指令，这里不再细说每一个指令的用法，读者可以自行参考文档。
需要说明的是和的不同，是通过更改元素的属性来实现隐藏与否的，而与不同的是，是通过完全移除元素来实现隐藏与否的。因此，如果你的隐藏内容的确需要反复，那么使用，这样性能更好。
与不同的是，是双向数据绑定，而是单向绑定的。
使用的时候，最好提供一个给。
数据传递
父组件通过传递数据到子组件 ，子组件通过来传递数据改变到父组件。对于简单的数据修改，可以通过这种方式实现。但是对于复杂的数据逻辑，建议通过来管理。例如：父组件传递到子组件：
 父组件中

     =


 子组件
  {
    
           然后就可以通过来使用了
    
}
子组件传递修改到父组件通过事件
 父组件中

     =


  {
     {
         {
             = 
        }
    }
}


 子组件

     =

  {
     {
          {
              
        }
    }
}
对于全局性的，可以通过来封装。例如用户登录信息，全局都用到的常量信息等。对于的内容比较多，大家可以看这里。 。
生命周期方法
提供了一套完整的组件的生命周期钩子方法，你可以在组件的生命周期的各个阶段做该做的事情。其完整的生命周期的方法图示如下：


前端开发不可避免的就是前后端交互，这里非常推荐。建议将涉及到前后端交互的所有放在一个独立的文件当中，方便管理。然后在需要接口的地方导入对应的方法即可。下面是一个示例：
   
   

  = {
      
     
}
  = ={
     {
         
    }  {
         
    }
}
 接口
   =  = {
      {}
}
 接口
   =  = {
      {   }
}

是基于用来解决前端路由的方案。提供了包括动态路由等功能。这里也给出一个示例：
  
  {
       
       
       
  }
  {
       
       
       
  }

示例中的可以知，我们可以传递参数并且在组件中过去。此外，我们可以传递多个参数，如’’等。这里建议不要超过个，因为传递的越来越多，就不再方便管理了。
组件刷新
作者在使用的过程中反复遇到过一个问题，就是组件刷新的问题。例如，作者的项目当中有用到菜单，打开不同的菜单对应不同的路由和组件。而如果在当前组件中，再次点击打开当前组件的菜单，则组件并不会刷新。
这就导致一个头疼的问题，因为用户点击菜单本身就是想刷新当前页面，而组件的数据并没有刷新，因此就看不到最新的数据。解决思路就是，在组件路由里增加了一个时间参数，然后在组件当中增加了对这个时间参数的。具体是实现如下：

     =  _=      增加当前时间戳_参数

然后在组件当中这个时间参数就可以了：

      {
        
         {
            _  {
                   
            }
        }
        
    }

总结
乱七八糟的写了很多，也算是对这段时间用的一个回顾。不得不承认，在使用的过程当中开始逐渐喜欢上了这个优美而简洁的框架。因此也愿意跟更多的人分享使用它的经验。也欢迎大家一起交流。
参考

官网 

《 》

在组件不变的情况下和不变的情况下刷新视图

其它参考资料作者：，腾讯游戏漏洞测试高级工程师

随着智能手机的全面普及和市场泛娱乐化，移动游戏行业发展迅猛，无论是市场收入还是用户规模，手游在游戏市场上已经占据了半壁江山。如此火热的市场吸引了大量外挂、辅助工作室等非法盈利团队，严重影响了游戏的收益、平衡，缩短游戏的生命周期，外挂对手游形成了这些危害：

图：手游外挂八大危害
为了避免这些损害，腾讯游戏内部的测试流程已经将“手游安全测试”设立为必经环节，腾讯大部分手游上线前都会进行手游安全测试，《王者荣耀》、《穿越火线：枪战王者》等六星级游戏更是每一个版本都主动寻求手游漏洞扫描。《梦幻诛仙手游》同样也是如此。
《梦幻诛仙手游》的加入
《梦幻诛仙手游》是由祖龙天津科技有限公司研发的一款角色、场景的回合制手游，该作由腾讯游戏运营，于年月日正式公测。
为了提前暴露游戏中潜在的安全风险，最大程度降低上线后外挂打击成本，《梦幻诛仙手游》测试团队选择与腾讯合作，使用手游安全测试专家模式，对游戏的客户端、服务器、以及通信协议方面的安全质量进行全面检测和把控，手游安全团队针对游戏核心玩法和游戏中高价值产出点重点进行漏洞挖掘。在顺利上线后，腾讯团队整理了《梦幻诛仙手游》安全测试过程中的一些思路和实践内容，对外分享。
一、技术难点
《梦幻诛仙手游》属于重度类型，游戏功能系统包含战力成长相关系统、交易系统、宠物系统、门派、上古战场、世界、跨服战、家园系统，各种类型副本以及运营活动等超过个功能系统，如何在短时间内全面地完成全量内容的安全漏洞挖掘是当时面临的最大挑战。手游安全测试团队一方面使用函数风险智能分析系统、盗刷漏洞扫描和拒绝服务攻击扫描对游戏进行一轮漏洞自动化检测，另一方面根据各功能风险性和优先级对游戏的战斗系统、交易所和战力成长系统进行深度分析和漏洞挖掘。
二、实现方案
测试目标
根据手游安全测试团队对腾讯游戏多年的测试经验，手游安全漏洞主要会出现在客户端、游戏逻辑和服务器三个层面，为了整体全面的发现手游外挂情况，测试团队将手游外挂的风险项细化情况如下：

测试前分析
前文提到不同手游玩法都会使用不同的技术实现，因此在《梦幻诛仙手游》安全测试之初，安全团队对游戏进行了一个详细的分析与拆解。
《梦幻诛仙手游》核心玩法包括回合制的与多人，经过对战斗过程中服务器与客户端间通信协议的分析，总结游戏特点为战斗实时性要求很弱，客户端的每次操作均有协议上报，属于服务器强校验游戏。鉴于以上特性，手游安全测试团队确定主要采用协议安全的测试方法为主，函数修改与内存修改测试方法为辅。
以《梦幻诛仙手游》某个版本为例，根据该版本的新增内容，手游安全测试团队相应的把测试重点聚焦在：
、经济系统，商会、商城、摆摊、交易行、背包出售。
、战斗力相关，角色属性，技能、装备、法宝、羽翼、宠物、仙侣等。
、进行、负值，数据溢出攻击，并发等漏洞挖掘方式。
测试中发现问题
根据测试前分析确定测试重点后，漏洞挖掘的工作其实就完成了一大半，之后利用安全测试工具对风险进行逐一验证即可。在游戏中发现以下几种类型的漏洞，均属于致命级漏洞：
、经济系统——致命级安全风险
各个交易系统服务器都对协议中各个字段都有校验，道具购买数量做了，负值判断，并且服务器对购买个数有上限限制，不同物品限制个数不同。由于购买逻辑，不同物品服务器处理逻辑不一致，导致积分兑换中通过购买可堆叠物品时未做个数限制，导致数据溢出引发服务器耗尽内存宕机。
【示例】
漏洞描述：积分商城使用竞技场积分购买藏宝图，修改协议中字段数量为一个很大的值，导致服务器内存耗尽，游戏无法登录游戏内无法进行任何操作。


修改购买数量为一个很大的值，导致服务器宕机
影响面分析：修改商城购买数量，导致服务器宕机，全服玩家无法游戏。
、角色属性系统——致命级安全风险
角色属性加点对各个正常逻辑字段均有校验，唯独对加点数值未做负值判断和溢出处理，导致修改次要属性为负值可以获取更多点数分配到主要属性，由于未做数据溢出保护，临界负值相加出现数据溢出，导致结果为超大正值，从而引发刷任意属性值。
【示例】
漏洞描述：梦幻诛仙有多种职业，每个职业有多种属性，根据职业的不同属性加点时配置不同的属性。服务器未做加点属性的负值做判断，可以通过发送负值任意将降低其他属性从而增强该职业的主要属性。 物攻职业削减法术属性以增强其他属性。


通过录制加点协议将某属性修改为负值，将增加的属性点分配到其他属性
影响面分析：任意修改角色属性，严重破坏游戏玩法。
、宠物系统——致命级安全风险
宠物属性加点同角色属性加点，对各个正常逻辑字段均有校验，唯独对加点数值未做负值判断和溢出处理，导致修改次要属性为负值可以获取更多点数分配到主要属性，由于未做数据溢出保护，临界负值相加出现数据溢出，导致结果为超大正值，从而引发刷任意属性值。
【示例】
漏洞描述：宠物加点协议发送一键异常值后导致宠物战力猛增，宠物直接战斗无敌。通过录制宠物加点协议，然后修改字段的值为 ，导致宠物战力值异常增大。


通过修改数值导致宠物战斗力异常增大
影响面分析：使用战力异常的宠物参加战斗可以横扫副本，严重影响游戏平衡，导致玩家可以大量获取收益。
三、解决方法
如何修复盗刷类漏洞？
√ 游戏研发初期，规范游戏通信协议定义，对协议结构中字段数和字段类型进行安全性检查
√  服务器处理购买、结算等物品发放请求时，需要加强对请求中各项信息合法性校验，另外运营侧可以接入运营经分系统，对各种道具和金钱的产出进行实时监控与告警。
如何修复宕机类漏洞？
√  因程序健壮性导致的服务器宕机漏洞被检测出之后，修复起来比较简单，针对性做好异常值处理就能够修复。
四、最终效果
在项目测试阶段，手游安全测试团队累积为《梦幻诛仙手游》挖掘出了个致命级漏洞，个高危级漏洞，个中危级漏洞，将游戏中潜在的盗号、物品盗刷、伪造身份、服务器宕机等各类致命级、高危级漏洞提前揭露出来，提前制定修复方案进行修复，并评估和验收结果与风险。
手游安全测试为《梦幻诛仙手游》线上运营提供安全保驾护航，项目上线后未发生安全方面的运营故障，为用户提供安全、公平、健康的游戏环境提供了坚实技术支撑和安全保障。

关于腾讯手游安全测试团队
腾讯手游安全测试团队从年初开始对手游安全领域进行探索和技术积累，旨在通过提前发现游戏版本的安全漏洞，预警风险，打造出业界领先的手游安全测试技术方案，在工具上已经支持所有腾讯在研和运营的手游项目。团队通过使用与正式服同样的游戏客户端和服务器，模拟外挂工作室制作外挂的过程，依靠自身的技术积累来提高专业程度，持续保持漏洞的发现率。
目前提供了专家测试服务，希望通过提前发现游戏版本的安全漏洞，预警风险，帮助提高腾讯游戏的品牌和口碑。
目前功能已正式对外开放！如需接入请联系企业：。或者点击链接： 申请预约！
商业转载请联系腾讯获得授权，非商业转载请注明出处。
原文链接：导语： 本文讨论了预估模型，包括工业界使用比较广的比较经典模型和学术界最新的结合的一些工作。

前言
谈到，都多多少少有些了解，尤其在互联网广告这块，简而言之，就是给某个网络服务使用者推送一个广告，该广告被点击的概率，这个问题难度简单到街边算命随口告诉你今天适不适合娶亲、适不适合搬迁一样，也可以复杂到拿到各种诸如龟壳、铜钱等等家伙事，在沐浴更衣、净手煴香后，最后一通预测，发现完全扯淡，被人暴打一顿，更有甚者，在以前关系国家危亡、异或争国本这种情况时，也通常会算上一卦，国家的兴衰、。其实和这个一样，以前经常和小伙伴吐槽，其实做机器学习、无论是推荐还是计算广告，都和以前的算命先生没什么差别，做的好的官至国师，不好的吃不了饱饭也是有的。要想把你模型做的好好的，必须要先了解那些前辈们都是怎么玩的。
架构
一个典型的流程如下图所示：

如上图，主要包括两大部分：离线部分、在线部分，其中离线部分目标主要是训练出可用模型，而在线部分则考虑模型上线后，性能可能随时间而出现下降，弱出现这种情况，可选择使用来在线更新模型：
离线部分：

·       数据收集：主要收集和业务相关的数据，通常会有专门的同事在位置进行埋点，拿到业务数据；
·       预处理：对埋点拿到的业务数据进行去脏去重；
·       构造数据集：经过预处理的业务数据，构造数据集，在切分训练、测试、验证集时应该合理根据业务逻辑来进行切分；
·       特征工程：对原始数据进行基本的特征处理，包括去除相关性大的特征，离散变量，连续特征离散化等等；
·       模型选择：选择合理的机器学习模型来完成相应工作，原则是先从简入深，先找到，然后逐步优化；
·       超参选择：利用、或者来进行超参选择，选择在离线数据集中性能最好的超参组合；
·       在线 ：选择优化过后的模型和原先模型如进行 ，若性能有提升则替换原先模型；

在线部分

·         ：设定简单过滤规则，过滤异常数据；
·       模型更新：当  收集到合适大小数据时，对模型进行，若在测试集上比原始模型性能高，则更新 的模型参数；
·        ：接受数据请求，返回预测结果；

 
最简单的模型也应该是工业界应用最广的方法， 算法简单易于调参，属于线性模型，原理如下图：

将模型建模为一个分类问题，利用预测用户点击的概率；通常我们只需要离线收集好数据样本构造数据集，选择好合适的特征空间，离线训练好模型，测试在离线数据集上的性能之后，即可上线，也可以适应数据分布随时间突变严重的情况，采用的策略来对模型进行相对频繁的更新，模型的简单能够保证这部分的需求能够得到保障。

优点是简单高效，缺点也很明显，它太简单，视特征空间内特征之间彼此独立，没有任何交叉或者组合关系，这与实际不符合，比如在预测是否会点击某件恤是否会点击，如果在夏天可能大部分地区的用户都会点击，但是综合季节比如在秋天，北方城市可能完全不需要，所以这是从数据特征维度不同特征之间才能体现出来的。因此，必须复杂到能够建模非线性关系才能够比较准确地建模复杂的内在关系，而就是通过特征的二项式组合来建模这类特征的复杂的内在关系二项式部分如下图公式：

然而理想是美好的，现实却是残酷的，有一个明显的问题，就是在实际场景中，大部分特征都是稀疏的，即大部分特征值为，对这些稀疏的特征做二项式组合，会发现最后大部分特征值都是，而在梯度更新时，当大部分为时，其实梯度并不更新，所以的方法在实际场景中并不能比较好地解决这类特征组合来建模更复杂线性关系的问题。
 
上面虽然理论上能够建模二项式关系，但是在实际场景下稀疏数据时，无法使用，而就是为了解决这里的短板的，的基本原理是将这些二项式矩阵做矩阵分解，将高维稀疏的特征向量映射到低维连续向量空间，然后根据内积表示二项式特征关系：

复杂度为，作者提出了一种简化的算法：

将复杂度简化为 然后就是来更新模型参数，使模型收敛这里还有很多其他替代的方法，在中有提到：

训练时间复杂度也是，也就是线性时间，通过对二项式稀疏进行低维连续空间的转换，能够有效地解决中存在的二次项系数在大规模系数数据下不更新的问题，另外由于训练预测复杂度均为线性，这样逻辑下由于要计算多项式核，复杂度是，由于的这几个特征，在实际场景中，也大规模的应用在中，尤其是在数据极其系数的场景下，效果相对于其他算法有很明星的改善。
 
全程是  ，相对于增加了信息，每个特征属于一个，举个例子：

而相对于，只有_相同个数的低维连续表示，而则不同，每一个对不同的有不同的表示，所以有__个不同的表示：

通常由于每个低维隐变量表示只学习特定的表示，所以的隐变量长度相对于的隐变量维度要小的多。的优化问题相对其比较简单，可以看看这篇，里面比较详细地描述优化过程，还有相关的伪代码

从年在上深度学习超过经典模型之后，在计算机视觉、语音、都有很多相关的工作，而在上，深度学习的建模能力也有一些应用，和就是其中的一些尝试，来源于      –       ，这里稍微描述下相关的做法：

网络底层由来进行参数初始化，的元素由中的低维连续空间向量表示来做初始化：

而构成的低维连续空间向量表示预先由在数据集上生成，模型在训练过程中，会通过来更新层参数，其他步骤和常见的没有什么区别，这里重点就是底层如何介入层参数的问题；

利用卷积网络来做点击率预测，看了文章，没有太明白其中的所以然，贴下网络结构的图吧：

有弄清楚这篇文章的小伙伴可以讨论下。

主要是在深度学习网络中增加了一个  ，用来建模特征之前的关系，如下图， 部分是，部分__用来建模二项式关系：

按层的功能分为  和  ，区别如下：

和类似，构造好网络之后，对输入数据做处理之后得到低维的连续向量表示，经过任意两个的进行    也为的一部分，所以可以建模线性关系，这里很容易发现，这部分特征大小会变大很多二次项数量级尤其是稀疏空间，和遇到的问题类似，变得很难训练，受启发，可以把这个大矩阵转换矩阵分解为小矩阵和它的转置相乘，表征到低维度连续向量空间，来减少模型复杂度：


更有意思的地方是和结合了，其实就是把和结合了，即将用神经网络的方式构造了一遍，作为的补充，原始的  ，的部分只是，构造线性关系，部分建模更高阶的关系，所以在  中还需要做一些特征的东西，如 的工作，而我们知道是可以建模二阶关系达到 的效果，就是把和结合，无需再对特征做诸如 的工作了，这个是我感觉最吸引人的地方，其实的部分感觉就是的一次描述，这里只描述下结构图，的部分前面都描述 部分：

部分：

相对于、，能够利用其部分建模更高阶信息二阶以上，而相对于  能够减少特征工程的部分工作，部分类似建模一、二阶特征间关系，算是和的一个更完美的结合方向，另外不同的是如下图，的和部分共享向量空间，和均可以更新部分，虽说部分纯是的工作，但感觉还是蛮有意思的。

其他的一些方法

：提出利用探索海量特征空间的特征组合，减少特征工程工作量，性能很好；

：阿里妈妈前端时间提出的一种增强模型，将的划分考虑进去来建模非线性关系，感觉类似于深度学习的机制，据说在阿里妈妈相关业务提升很多；


总结
前面讨论了一些常见的方法，重点介绍了 及其变种  ，还有和深度学习的结合，个人感觉的逻辑比较有意思，完全使用神经网络的思维模型重塑了，为后面扩展  的工作打下基础，减少了  中需要的一些基本的特征工程工作部分二次项工作，上面只是涉及到模型的算法部分，在实际中可以去探讨，并不能说明一定性能就好，另外由于架构的限制，综合考虑其他方面的因素，如请求时间、模型复杂度，也是最终是否采用相关算法的考虑因素，各位对此有兴趣讨论的小伙伴，欢迎回复讨论。作者 | 涂小刚编辑 | 迷鹿

涂小刚，攻城狮一枚，有代码洁癖，热爱学习，热爱生活，痛恨酱油帝、跪舔帝。目前主要从事大数据平台与机器学习平台相关方向的工作，关注与

测试准备
训练数据是通过   公开数据集生成器得到，在上大小为，个文件，添加如下两个参数以保证所有资源全部到位后才启动，训练时间为加载数据到训练完毕这期间的耗时。
 =

=
测试集群为个节点的机器搭建而成，其中一台作为，两台。除以上配置外，其他配置全部保持默认状态。公共资源配置、分区设置以及算法参数如下表所示，_视不同的测试用例不同

测试用例
在不使用的情况和使用的情况下，分别测试算法的训练时间以及时间占比，相关测试指标数据如下表所示：

从以上测试数据看来，让人有点出乎意料，一开始有点不太相信，但是多次测试后数据并没有多大的抖动，所以说的性能受多方面因素的影响，单单这块不同的方式以及不同的资源情况下，其性能差别就相差较大，下面分析其内在原因。
不使用时，不是瓶颈，在每次迭代时均要读一遍，访问有较大的开销。从加载训练数据后直接采用原生的：

当_为时，不足以住原始训练数据，从上看到的比例只有左右，导致频繁的 剔除重建，同时由于内存吃紧，可能引发较重的，从上看到时间占到总的运行时间的左右，已经成为瓶颈，其整体性能还不如不使用；

当_为时，也不足以住原始训练数据，但是其的比例有左右，同样存在 剔除重建，并引发较重的，时间占总的运行时间的左右，虽然比_为的情况有所好转，但是仍然不理想，只比不做好左右，但是内存却多用了，并不是特别划算；

当_为时，可以全部住原始训练数据，性能较优，占比较小，但是比不用要多用内存，有些代价。


一般来说，当我们内存不够时，可以选择__的缓存方式，但是测试发现__的缓存效果并不是特别好，从测试数据来看，还不如直接使用_的缓存方式，__的缓存方式带来的开销非常大，可能是因为每次都尽可能地数据到内存，不够再到磁盘，同时引发频繁。
交叉验证测试
为了排除偶然性，拿  中的  算法进行测试，分别测试各种方式下整体性能，在保证每种方式下都能住数据的情况下，得到如下测试结果。

总结
的并不是总是会加速任务运行，的方式不同，对任务产生的影响不同。并不是能用内存就用内存，而是要考虑是否有充足的内存住你的数据，否则可能适得其反。在内存充足时，优先考虑使用_，但是当内存不足以住你的中间数据时，建议直接用__=或_而不要用__，__可能会频繁地触发的内存管理，增加以及的开销。

相关推荐
集群部署与高可用性能测试报告作者介绍：黄辉，目前在腾讯云数据库团队从事后台开发工作，喜欢研究分布式数据库相关技术。

导语
是通过  来保证事务的原子性和隔离性，具体机制是怎样实现的，下面举些示例来做个简单解析以加深理解。
前提
表中隐藏的系统字段
的每个表中都有些系统隐藏字段，包括：

 对象标识符，生成的值是全局唯一的，表、索引、视图都带有，如果需要在用户创建的表中使用字段，需要显示指定“ ”选项。
 每条记录称为一个在表中的物理位置标识。
 创建一条记录时，记录此值为当前事务。
 创建时，默认为，删除时，记录此值为当前事务。
 标识在同一个事务中多个语句命令的序列值，从开始，用于同一个事务中实现版本可见性判断

机制
机制通过这些隐藏的标记字段来协同实现，下面举几个示例来解释是如何实现的


创建表，显示指定字段：
=      
 

插入几条记录
=    
  
=    
  
=    
  
查询当前表中的信息，为创建时的事务，默认为
=          
   |      |  |  |  |    | 

  |  |     |     |     |  |  
  |  |     |     |     |  |  
  |  |     |     |     |  |  
 
接下来，我们更新某个的字段，将中值为更新为，看看会发生什么
= 

=  _
 _

     
 

=     =    = 
 
查看详细信息
=          
   |      |  |  |  |    | 

  |  |     |     |     |  |  
  |  |     |     |     |  |  
  |  |     |     |     |  |  
 
可以看到为的=已经被修改了，值被更新为，另外、字段也被更新了，值代表了该的物理位置，值是创建时都已经写入，这两个字段都不应该被更改才对，另起一个来看下当前事务还未提交


=          
   |      |      |  |  |    | 

  |  |  |     |     |  |  
  |  |         |     |     |  |  
  |  |         |     |     |  |  
 
可以看到为的=还存在，只是值被标记为当前事务。 原来更新某个时，会新增一个，填入更新后的字段值，将原来的标记为删除设置为当前事务。同理，可以看下删除一个的结果

=      = 
 


=          
   |      |      |  |  |    | 

  |  |  |     |     |  |  
  |  |  |     |     |  |  
  |  |         |     |     |  |  
 
删除某个时也是将标记为当前事务，并不做实际的物理记录清除操作。另外和值递增为，表明了同一事务中操作的顺序性。在该事务未提交前，其他事务可以看到之前的版本信息，不同的事务拥有各自的数据空间，其操作不会对对方产生干扰，保证了事务的隔离性。
提交事务，查看最终结果如下：

= 

=          
   |      |  |  |  |    | 

  |  |     |     |     |  |  
  |  |     |     |     |  |  
 
但是，如果我们不提交事务而是回滚，结果又是如何？
=  

=     =    = 
 
= 

=          
   |      |      |  |  |    | 

  |  |         |     |     |  |  
  |  |  |     |     |  |  
 
标记并未清除，继续新增一条记录：

=    
  
=          
   |      |      |  |  |    | 

  |  |         |     |     |  |  
  |  |  |     |     |  |  
  |  |         |     |     |  |  
 
发现没有清理掉新增的，消除原有上的标记，这是为何？处于效率的原因，如果事务回滚时也进行清除标记，可能会导致磁盘，降低性能。那如何判断该的是否有效呢？答案是会把事务状态记录到 位图文件中，每读到一行时，会到该文件中查询事务状态，事务的状态通过以下四种来表示：

 ___= 正在进行中
 __= 已提交
 __= 已回滚
 ___= 子事务已提交

保证原子性和隔离性
原子性
事务的原子性要求在同一事务中的所有操作要么都做，要么都不做。根据的规则，插入数据时，会将当前事务写入到中，删除数据时，会将事务写入中，更新数据相当于先删除原来的再新增一个，增删改操作都保留了事务，根据事务提交或撤销该事务中的所有操作，从而保证了事务的原子性。
隔离性
事务的隔离性要求各个并行事务之间不能相互干扰，事务之间是隔离的。可读取的数据是小于当前的事务且已经提交。对某个进行更新或删除时，其他事务读取的就是这个之前的版本。
的优势

读写不会相互阻塞，写操作并没有堵塞其他事务的读，在写事务未提交前，读取的都是之前的版本，提高了并发的访问效率。
事务可以快速回滚，操作后的都带有当前事务，直接标记文件中对应事务的状态就可达到回滚的目的。

带来的问题
事务回卷问题
也需要事务来确定事务的先后顺序，中，事务被称为，获取当前
=  _
 _

     
 
事务由数字表示，当事务用完时，就会出现新的事务会比老小，导致事务回卷问题 。 的事务规则：

 ，无效事务
 ，表示系统表初使化时的事务
 ，冻结的事务，比任务普通的事务都旧。– 大于的事务都是普通的事务。当最新和最旧事务之差达到时，就把旧事务换成，然后通过公式    比较大小即可

垃圾数据问题
根据机制，更新和删除的记录都不会被实际删除，操作频繁的表会积累大量的过期数据，占用磁盘空间，当扫描查询数据时，需要更多的，降低查询效率。的解决方法是提供命令操作来清理过期的数据。作者： 

 内存优化是我们性能优化工作中比较重要的一环，这里其实主要包括两方面的工作：

优化，即降低运行时内存。这里的目的是防止程序发生异常，以及降低程序由于内存过大被机制杀死的概率。另一方面，不合理的内存使用会使大大增多，从而导致程序变卡。
优化，即降低程序占的体积。这里主要是为了降低程序占用的空间，防止由于空间不足导致程序无法安装。

本文的着重点为第一点，总结概述降低应用运行内存的技巧。在这里我们不再细述、等概念与应用的内存管理，如对这部分内容感兴趣，可自行阅读文末的参考文章。
内存泄露的检测与修改
内存泄露：简单来说对象由于编码错误或系统原因，仍然存在着对其直接或间接的引用，导致系统无法进行回收。内存泄露，容易留下逻辑隐患同时增加了应用内存峰值与发生的概率。它属于 是我们一定要修改的。
下面是造成内存泄露的一些常见原因，但是如何建立一套发现内存泄露、解决内存泄露的闭环方案，才是我们工作的重点。

一 内存泄露的监控方案
的开源库是一个非常不错的选择它通过弱引用方式侦查或对象的生命周期，若发现内存泄露自动 文件，通过库得到泄露的最短路径，最后通过展示。
内存泄露判断与处理的流程如下图 ，各自运行的进程空间主进程通过，分析使用的是单独的进程：

微信在推出之前已经有了自己的内存泄露监控体系，与大致有以下的区别：

在微信中，对于以上的机型也是采用通过注册接口，对于以下的机型我们会尝试反射中的对象。当然，现在微信也改成只支持以上，美美哒。
尽管使用了与分进程，但是依然会造成应用明显的卡顿 。而在三星等一些手机，系统会缓存最后一个，所以在微信，我们采取了更严格的检测模式，即泄露三次确认以及经过个新建的，确保不是由于系统缓存的原因造成。
在微信中，当发现疑似内存泄露时会弹出对话框，当我们主动点击时才会去做以及上传快照的操作，而是否误报、泄露链等分析工作也是放于服务器端。

事实上，通过对做简单的定制，我们就可以实现以下一个内存泄露监控闭环。 

二 对系统内存泄露的 
列出了一些由于系统原因导致引用无法释放的例子，同时对于大多数的例子，都会提供建议如何通过的建议去修复。在微信中，对、、、也采用了类似的方式详细可看参考资料。
三 通过兜底回收内存
泄漏会导致该引用到的、等无法释放，对内存造成大的压力，兜底回收是指对于已泄漏，尝试回收其持有的资源，泄漏的仅仅是一个空壳，从而降低对内存的压力。
做法也非常简单，在 时候从的开始，递归释放所有子涉及的图片，背景，，监听器等等资源，让成为一个不占资源的空壳，泄露了也不会导致图片资源被持有。
   …
   …
     = 
     =  {
       
   }        
   
   
   
总的来说，我们不是只懂得一些内存泄露解决方法就可以，更重要的是通过日常测试与监控，得到内存泄露检测与修改的一整套闭环体系。
降低运行时内存的一些方法
当我们能确保应用中不会出现内存泄露时，我们需要一些其他的方法来降低运行时的内存。更多的时候，我们其实只希望降低应用发生的概率。
 ：

 系统，当      新分配的大小 =   最大值时候就会发生。其中是放于中 。
 系统，废除了的计数器，类似的分配改到的 中申请，只要  新分配的内存 =   最大值的时候就会发生运行环境的统计规则还是和保持一致

一 减少占用的内存
说到内存，必然是这里的大头。对于内存占用，想说的有以下几点

防止占用资源多大导致  系统  里面隐藏的的反射打开后，申请的就不会算在中。对于 系统，可采用的库，即可把图片资源放于中。

图片按需加载即图片的大小不应该超过的大小。在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。对此，我们可以重载与，例如在 时，检测图片大小与的大小，若超过，可以上报或提示。

统一的加载器、都是比较出名的加载库，同样微信也有自己的库。加载库的好处在于将版本差异、大小处理对使用者不感知。有了统一的加载器，我们可以在加载时，若发生 方式，可以通过清除，降低 等方式，重新尝试。

图片存在像素浪费对于图，美工可能在出图时在拉伸与非拉伸区域都有大量的像素重复。通过获取图片的像素值，计算连续相同的像素区域，自定义算法判定这些区域是否可以缩放。关键也是需要将这些工作做到系统化，可及时发现问题，解决问题。


一个好的，可以将、或对图片加载的处理对使用者隐藏，同时也可以将自适应大小、质量等放于框架中。
二 自身内存占用监控
对于系统函数等函数是针对整个系统而已的，对于本进程来说，其内存距离的差值并没有体现，也没有回调函数供我们及时释放内存。假若能有那么一套机制，可以实时监控进程的堆内存使用率，达到设定值即关于通知相关模块进行内存释放，这会大大的降低。

实现原理这个其实比较简单，通过获得而即为当前真正使用的内存。  
  
  ；

操作方式我们可以定期前台每隔分钟去得到这个值，当我们这个值达到危险值时例如，我们应当主要去释放我们的各种资源的为大头，同时显示的去应用的加速内存收集。

__
三 使用多进程
对于，图库等，由于存在内存系统泄露或者占用内存过多的问题，我们可以采用单独的进程。微信当前也会把它们放在单独的进程中
四 上报详细信息
当系统发生的时，我们应当上传更加详细的内存相关信息，方便我们定位当时内存的具体情况。
其他例如使用 、、、等不再一一细述，对代码采用优化埋坑优化埋坑的方式并不推荐。我们应该着力于建立一套合理的框架与监控体系，能及时的发现诸如过大、像素浪费、内存占用过大、应用等问题。
优化
拥有的机制，不同的系统版本的实现可能有比较大的差异。但是无论哪种版本，大量的操作则会显著占用帧间隔时间。如果在帧间隔时间里面做了过多的操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。 
一 的类型
的类型有以下几种，其中__是同步方式进行，对应用帧率的影响最大。

__当堆内存不够的时候容易被触发，尤其是一个对象的时候，很容易被触发到，所以如果要加速启动，可以提高的值，这样在启动过程中可以减少__的次数。注意这个触发是以同步的方式进行的。如果后仍然没有空间，则堆进行扩张

_这个是被可以调用的，比如 一般线程的优先级比较低，所以这个垃圾回收的过程不一定会马上触发， 千万不要认为调用了，内存的情况就能有所好转

_当分配的对象大小超过时触发，注意这是以异步的方式进行回收的如果发现大量反复的 出现，说明系统中可能一直有大于的对象被分配，而这些往往是一些临时对象，被反复触发了。给到我们的暗示是：对象的复用不够。

__ 在系统之后被废了层的内存分配失败了，这类就会被触发。如果的纹理、、或者的使用没有释放，这种类型的往往会被频繁触发。


二 内存抖动现象
 内存抖动，内存抖动是因为在短时间内大量的对象被创建又马上被释放。瞬间产生大量的对象会严重占用内存区域，当达到阀值，剩余空间不够的时候，会触发从而导致刚产生的对象又很快被回收。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加的压力，从而触发更多其他类型的。这个操作有可能会影响到帧率，并使得用户感知到性能问题。

通过 ，我们可以跟踪整个的内存变化情况。若短时间发生了多次内存的涨跌，这意味着很有可能发生了内存抖动。
三 优化
通过 ，我们可以查看当前内存快照，便于对比分析哪些对象有可能发生了泄漏。更重要的工具是 ，追踪内存对象的类型、堆栈、大小等。手有做一个统计工具，对 的原始数据，按照类型堆栈的组合堆栈取栈顶的层统计某一种对象分配的大小、次数。同时按照次数、大小的排序，从多大到少小结合代码分析，并自顶向下的逐轮进行优化。

这样，我们就可以快速知道发生内存抖动时，是因为哪些变量的创建造成频繁。一般来说我们需要注意以下几个方面：
、字符串拼接优化减少字符串使用加号拼接，改为使用。减少，初始化时设置；这里需要注意的是，若打开中回调也会存在较多的字符串拼接。
  = 
  =  {
                 
                             
}
、读文件优化 读文件使用，初始设置，减少
、资源重用建立全球缓存池，对频繁申请、释放的对象类型重用
、减少不必要或不合理的对象例如在、中应减少对象申请，尽量重用。更多是一些逻辑上的东西，例如循环中不断申请局部变量等
、选用合理的数据格式 使用   来代替
总结
我们并不能将内存优化中用到的所有技巧都一一说明，而且随着版本的更替，可能很多方法都会变的过时。我在想更重要的是我们能持续的发现问题，精细化的监控，而不是一直处于哪个有坑填哪里的的窘况。在这里给大家的建议有：

率先考虑采用已有的工具；中国人喜欢重复造轮子，我们更推荐花精力去优化已有工具，为广大码农做贡献。生活已不易，码农何为为难码农！
不拘泥于点，更重要在于如何建立合理的框架避免发生问题，或者是能及时的发现问题。当前微信内存监控体系中也存在一些不尽人意的地方，在未来的日子里也同样需要努力去优化。

参考文章
内存管理优化安卓应用内存的神秘方法以及背后的原理性能优化之内存篇

本文来源于： 微信公众号 为什么要引入
你可能在之前的开发中遇到过以下问题：

以下简称的性能开销较大，而你又很难不使用；
想要按比例布局就要使用_属性，想要使用_属性就要使用以下简称或者以下简称，然后你在原先同级的每个布局外再嵌套一层布局以使用_；
按固定宽高比布局等更高阶的布局需求，原先的各类布局方式都不能很好的支持，可能需要通过代码，在运行中二次实现；
亦或者你只是想尝试下这款官方力推的新布局，看看它有什么新特性。

 准备工作
 确保 中已经下载了以下简称的支持库：

 中增加对的依赖：
 
 在使用到的文件头部添加标签：
=
 如果能正常联想出，并且其子能正常联想出的相关属性，说明已经成功依赖：


   上手
先定一个小目标：将  实现的需求，通过来实现一遍。虽然  已经支持将其他布局自动转换成：

但还是建议先亲自上手码一遍：

理解的布局规则；
自动转换的功能目前还不是很完善，可能所见非所得。自动转换后还是要手动下效果的。

 相对布局
最常见的使用场景：我要控件在控件父布局的上、下、左、右边，我要控件跟控件父布局间距 。：控件位于控件右侧：

实现


      _=_
      _=_

      
          =_
          _=
          _=
          =

      
          =_
          _=
          _=
          _=_
          _=
          =


实现


      _=_
      _=_

      
          =_
          _=
          _=
          =

      
          =_
          _=
          _=
          _=
          __=_
          =

看上去几乎没有什么差别。事实上，中所有的属性中都有与之对应的项目，稍加熟悉即可完成转换：



属性
属性




__
_


__
_


__
_


__
_


__
_


__
_


__
_


__
_


__
_


__
_  


__
_  


__
_  


__
_  



而相对于父布局的相对布局属性，的规则是：将父布局当做一个=””的对象来对待。也比较好理解：



属性
属性




__=””
_=””


__=””
_=””


__=””
_=””


__=””
_=””


__=””
_=””


__=””
_=””


__=””
__=””
_=””


__=””
__=””
_=””


__=””
__=””

__=””
__=””
_=””



 固定比例间距
_属性常见的使用场景：我要控件的左间距和右间距的比例为。：控件左间距和右间距的比例是：

实现可能并非最优写法


      _=_
      _=_
      =
      =

      
          
              _=_
              _=_
              _=

          
              =_
              _=
              _=
              =

          
              _=_
              _=_
              _=
      

实现

    _=_
    _=_

    
        =_
        _=
        _=
        =
        __=
        __=
        __=



在设置了各类居中属性的基础上，通过__和__两个属性，可以简单直观的完成间距比例的设置。
 固定比例宽高
原先，在未指定宽高具体数值的情况下，让  按照比例动态调整宽高比，实现起来比较麻烦。你可能需要等到  绘制出来后，拿到它的，获取固定边的长度，计算出被动边的长度，最后将 回去。而有了提供的_属性，一行即可搞定。
：控件按照宽高比展示，宽为固定边，高为被动边：

        _=_
        _=_

    _的表示被动调整的是高或是宽
    
        _=
        _=
        _=
        _=
        _=
        =
        __=
        __=

上面的示例中，_和_都设置为了，在布局中等同于_——的一个新属性常量。在中，子  无法使用_属性。
_搭配不同的属性有不同的意义：

设置_属性的情况下，代表该边长度由_动态调整；
 后面会提到中，代表该边长度由__或__动态调整；
其他情况下，等同于_，代表该边长度由各动态调整；

 

______

_系列是中新加入的属性。相对布局的两个控件，其中一方 == 时，另外一方将会根据_系列属性的值重新规划自己的间距。比较常用于在相对布局中保持各个控件的位置。
：控件在控件设置 == 后保持在原来的位置：

        _=_
        _=_
        _=

        
            =_
            _=
            _=
            =
            =
            =
            =

        
            =_
            _=
            _=
            _=
            _=
            __=_
            =
            =
            =
            =


 
是中新加入的控件与控件间的关系。组成的多个控件，可以在同一方向上更加方便的完成复杂的布局要求。
 组成
多个控件组成需要满足以下条件：

控件间的布局存在相互依赖关系你依赖我布局，我也依赖你布局；
两个以上的控件，相互依赖关系需要保持在同一个方向上都是水平方向上的依赖：_  _；或者都是垂直方向上的依赖：_  _；

听起来很绕。：控件、、在水平方向上组成：

     _=_
     _=_

     
         =_
         _=
         _=
         _=
         __=_

     
         =_
         _=
         _=
         __=_
         __=_

     
         =_
         _=
         _=
         _=
         __=_

示例中，控件和控件通过 __=”_”和__=”_” 达成了水平方向的相互依赖关系。控件与控件同理。同时，又由于控件与、控件与均是水平方向的关系，控件、、三者在水平方向组成了一条。
在的窗口下，组成的控件间会出现一条链条：

 设置 
水平方向最左边的控件和垂直方向最顶部的控件被成为 。通过对 添加属性，可以设置该条在水平或垂直方向上的：

__
__

属性一共有三种：、_、。再配合其他属性，最终可以组成五种 ：



 
设置方式




 
 = “”


  
 = “_”


 
 = “”


   
 = “”__ __


 
 = “” __ __ _ = “” _ = “”



官方的这张图已经比较清楚的展示了 各自的布局效果：

前四种 的设置和效果都比较简单，不再赘述。重点介绍下 ， 的设置方式相对比较复杂，以水平方向的为例：

        _=_
        _=_

        
            =_
            _=
            _=
            =
            __=
            __=
            __=
            __=_

        
            =_
            _=
            _=
            __=
            __=_
            __=_

        
            =_
            _=
            _=
            __=
            __=_
            __=



 设置为；
中控件设置了__参数；
中控件都需要将_设置为中提到的_；

除此以外， 还有以下特征：

 中的控件也允许在方向上使用_自适应控件宽  高，且布局时优先满足设置为_的控件；：将示例中的控件 _设置为_：



 中的控件既不设置_，也不在方向上将边设置为_，那么该控件将被隐藏；
如果 中的控件在方向上设置了，的距离将计算入该控件实际占有的布局范围；：将示例中的控件左右各添加 后，控件和的实际占有布局并没有被压缩：


 简单的性能测试
官方称，相较于，在  上的性能开销提升了：

为此，笔者也做了一个简单的性能试验来验证：分别用和构造了一个 × 的相对布局矩阵，布局矩阵中的控件均使用_自适应大小，并设置有，使用不断的绘制：

同时，使用 新加入的回调，监听在渲染时，在  上实际花费的时间。最终数据如下：
 
抛开绝对数值，相对，在  上大致减少了的时间，并没有官方宣传的那么明显。可能是测试的布局嵌套并不是很深，亦或者布局中的控件并不是很多。
 个人开发体验
使用开发也有一段时间了，个人觉得与、、这些老前辈相比，在按比例布局、线性布局上面的支持更加完善，相关开发痛点可以用较少的描述完成了。简单的相对布局上，抛开微小的性能优势，和几乎没有什么差距，两者可以无缝转换。较复杂的相对布局上，相较代码不够直观，写出来的可读性比较差，  相对布局属性的组合想要实现与嵌套相同的效果，往往需要更多的代码。许多人认为的出现就是为了替换，个人觉得倒是更适合替换，替换可能需要功能更加强大的才能解决。但不管怎么说，越来越多的使用是趋势。
不足之处，请多指教。
参考文献：


作者：朱伟鸿

前言
也许我们使用过编写过自动化测试脚本，也许我们也使用过来测试过应用的稳定性。但在使用过程中总觉得有或多或小的问题，用写脚本，总觉得有时候控件没法识别；用来进行稳定性测试，总觉得没法复现问题……本文将使用一个新的角度图像识别来看待这类型的测试问题。增加一种图像识别的方法来补充与的限制。
本文仅作为“抛砖”篇把图像应用到测试这个思路引出来，希望能引出更多的“玉”能参与其中一起研究。
二、图像识别及算法介绍
也许图像识别对于我们来说也不怎么陌生，或多或少都有所接触，但能把图像识别直接应用到我们测试工作中的同学好像并不是特别多。图像识别这名词官方的说法是“利用计算机对图像进行处理、分析和理解，以识别各种不同模式的目标和对象的技术”。其实说白了，图像识别重要的是“识别”二字。对于测试来说就是通过“识别”让计算机辅助我们测试，让计算机代替我们进行测试。
以下将就如何去“识别”的问题，介绍笔者在使用图像识别作为辅助工具所采用到的一些算法与算子。
 算法
算法的主要方法是提取图片中物体上的一些局部外观兴趣点的特征值与特征方向。这些兴趣点的特征值与特征方向与图片的大小以及旋转角度无关、而且对光线与微视角的改变容忍度相当高，而且算法对于部分物体遮蔽的侦测率相当高，而且在当前电脑硬件的速度下，辨识速度接近即时运算。
算法的主要特点是尺度不变，也就是图片放大缩小不影响匹配、图片旋转任意角度不影响匹配、图片亮度增减不影响匹配、拍摄视角高低不影响匹配。
 算法计算过程
由于算法计算过程涉及的数学知识比较多，本文不是主要以讲解数学知识为目的，所以计算过程只是笔者简略理解后得出的几个关键步骤。以下均为网上参考的资料。
图片去噪：算法采用去噪的算法是高斯模糊，先对输入图片进行一次高斯模糊处理。
构建高斯金字塔：高斯金字塔是把原图片经过连续变化尺度参数得到的一个图片组。
构建高斯差分金字塔：刚获得的模糊化后的高斯金字塔的每一层相邻两张图进行差分运算构建出差分金字塔。
提取空间极值点：通过对差分金字塔进行极值点分析，得到每张图的空间极值点。
获取主梯度方向：主梯度方向是极值点变化最大的那个方向为极值点的主梯度变化方向。
经过上述几个步骤后便可得出一张图在几个不同尺度下的特征点以及特征方向。
下图为使用主页面运算得到的特征点位置及特征方向。其中圆的半径大小为极值大小，半径指向方向为特征方向。

 算子
对于轮廓识别，有很多各种各样的算子。算子的作用是：能尽可能多地表示出图像的实际边缘；标识出的边缘尽可能与实际图像的实际边缘接近；图像中边缘只能识别一次且噪声点识别为边缘。
 算子的运算过程
与算法类似，本文并不针对算子很细节部分的运算过程作详细介绍，笔者根据自己的理解给出以下的计算步骤。
图片去噪：算子使用去噪的方法跟算法一致，同样使用高斯模糊来实现。
获取梯度：通过计算图片中每个点各个方向的梯度来获取图像中每个点的亮度梯度，以及亮度梯度方向。
边缘检测：采用双阈值算法。使用高阈值过滤大部分噪点，用低阈值保留图片大部分信息。
下图为主页以及使用算子算出的轮廓信息。如图所示能把图片中大部分轮廓部分都获取到了。


三、图像识别应用
 基于图像识别的控件点击方法
在使用的时候往往会遇到一个问题对于某些手机弹框是按钮并不能很好的识别，如下图。如果测试的过程中需要去点击“通用设置”按钮，实际上是没法通过来进行点击的。

因为对于上图的弹框是没办法很好的识别的，如下图。整个弹框在的里面是不存在的，整个主页被识别成一个。因此在我们测试中往往会采用坐标点击的方法来进行规避，但却衍生出适配的问题。换了一台手机分辨率变化了，脚本就没法进行了。

基于上述问题，广州测试组采用的是使用图像识别的方法来把“通用设置”的位置找到，并进行点击。因为算法具有尺度不变性，而且不受大小光照等方面的影响，所以可以采用它来进行匹配。具体算法的流程图如下所示。

算法主要有以下步，即可实现对未能识别的控件进行查找点击。
、预先把需要匹配的图片先保存起来
、截取当前屏幕
、算法输出目标图与屏幕截图的特征值特征变量
、通过算法进行特征值特征向量的匹配
、把偏离比较严重的噪点去掉
、求出点集合的中心点
、实现点击事件
本文以点击“通用设置”为例，通过算法求出原图与屏幕截图的特征值特征向量如下图所示。可以看出两者的特征值，特征向量是相当类似的。

匹配的过程如下图所示，可以看出匹配到的大部分值都处在“通用设置”的位置中。

通过上述的步骤，便可获取到“通用设置”在屏幕中的位置，再实现点击则可实现点击“通用设置”的方法了。
 深度遍历工测试工具
基于算子与的深度遍历测试工具
在使用进行随机操作的时候我们会发现，很多时候不能很好的模拟人去点击有用的关键的点，从而做了无用功浪费了很多时间测试效率也不高。同时，如果在点击的过程中发现又不能很好的知道之前操作过的路径，复现尤为困难。因此笔者在考虑是否实现一个工具可以模拟小白用户进行点击操作、又能记录操作过的路径、又能在更大程度的把应用都点一遍。
基于算子与的深度遍历测试工具其实能很好的解决以下的问题。首先介绍下这个工具的环境情况。如下图所示。主控程序在上运行，被控对象是手机，两者的交互的通讯是通过命令来进行交互。

 工具功能
深度遍历工具的主要功能有以下几个：
、实现随机点击功能，多点击有关键意义的点；
、时刻检查是否在点击被测应用，如果跳出返回并继续因为有可能在点击过程中发生应用间跳转；
、完整记录点击的路径，能复现点击的路径；
、每一步操作都有相应的截图，可以让测试者回看确认；
、应用实现报警，及时停止运行。
 测试工具工作流程
测试工具的工作流程图如下图所示。

测试工具的大致流程有以下个步骤。
、截图取出轮廓关键点
、取出布局文件，取出=的点加入关键点列表
、依次点击关键点，并判断是否有跳转
、有跳转则返回，重新开始导出关键点
、无跳转则把上一点标记为无用点，并继续点击
、无跳转且当前页面点击完，判断是否可返回未点击完的页面
、能返回未点击完页面则跳转返回
、不能返回未点击完页面则退出工具
 关键点定义
对于关键点的定义，不同测试人员有不同的见解。笔者认为关键点必须具备以下两个条件：
、可点击的一定是关键点；
、看上去像是可以点击且具有意义的位置。
按照这两个条件，笔者一方面把中= 属性的点都纳入关键点，另一方面把通过识别具有明确轮廓意义的点也纳入关键点，因为在笔者看来一般被轮廓包围的都或是一张完整的图片，或是一个具有完整意义的字等。
 遍历规则
测试工具遍历点击的规则采用的是深度优先的算法，也就是每点击一步，判断是否有跳转，如果有跳转且与之前出现过的页面各不相同，则重新创建一组新的关键点组，从第一点开始遍历。如果没跳转则从下个点继续点击，直到当前再无页面跳转且当前页面的所有关键点都已经被点击过了，则进行回退步骤。判断是否跳转的标准是在点击前后分别进行图片对比，观察图片的相似度来判断，若相似度小于某个阈值程序定义为则说明有跳转。
 返回规则
若出现当前页面所有点都已经点击过且再无出现新的跳转页面时，工具会判断当前工程是否还有未完成点击的页面，且判断当前页面能否跳转过去。判断的准则是从当前页面按广度搜索下一级跳转的页面，如果有未完成的页面则跳转，若一级页面无跳转，则遍历二级的子页面，以此类推，直到找到一条可回退的路径。
 路径记录
点击路径的记录有以下几个关键点需要记录到。
、当前页面信息：包括页面、完成状态、对应的的名字
、关键点信息：包括点、状态未点击、点击过了
由于表读写比较方便，而且易于显示，因此在记录路径的载体选择上，本工具采用的是作为记录的载体，具体记录的格式如下图所示。

 实现效果
以手机管家为测试对象，笔者使用此工具，在一个晚上中遍历了大概的图片，每一张图片都保证是不一致的，而且能把管家一二级页面都能遍历得，能基本实现遍历的自动化操作。

 不足与展望
虽然能够基本遍历管家一二级页面的，但工具依旧存在着以下不足还需要去优化解决。
、对于需要加载的页面，加载前和加载后会被认为是两个页面。这是由于页面加载需要时间，而虽然工具每次截图之前都有一个等待时间，但对于加载过长的页面就会导致加载前后两个截图不一致被认为是两个页面。
、运行时间过长。对于管家的图片是建立在遍历了个小时的运行时间下的出来的，因为每次截图需要时间，等待界面跳转需要时间，而且每个页面关键点也比较多，信息如此之多因此运行的时间较长。
、对于一些一次性页面，也就是点击同样一位置的同一按钮，首次与其他次点击进去的页面不一致的页面，由于路径表中记录了跳转的页面，因此在返回的时候就会出现对应不上的现象。
、图像识别的方法仅能作为与的一个补充，解决了的一些限制，不能很好的完全替代与。展望未来，基于图像识别的功能还是大有可为的，但却有以下可以优化的地方。
、降低运行的时间，可以通过对界面稳定性的判断，判断当前界面稳定，不在有与扫描等操作后执行跳转，这样可以减少很多无用的截图从而提高的效率
、在图像相似度的算法的运算速度上做优化，当前比较两张图相似度需要约，所以是比较浪费时间的。优化方向一方面可以在保证效果不变的情况下减少图片的大小，另一方面采取新的计算方法加快相似度的运算。
、优化文件读写的操作，由于在当前代码架构下会被多次重载与写入，多次操作导致系统耗时比较多，因此可以减少读写的次数达到优化运行时间的目的。
四、总结
对于图像识别用于测试的路子本文仅为抛砖引玉篇，希望能在后面能在图像识别中加入机器学习与神经网络等当前热门的技术，并将其应用到测试工具的开发中。希望本文能够激发更多对图像识别的同学多思考，并将图像识别能更多的应用于工作中去。

相关推荐用进行手写数字识别玩九宫格数独一：九宫格图片中提取数字本文作者： 吴浩麟 
随着、、等前端框架的流行越来越多的应用变成了单页应用，它们的特点是异步拉取数据在浏览器中渲染出。使用这些框架极大的提升用户体验和开发效率的同时缺带来一个新问题，那就是这样的网页无法被搜索引擎收录。虽然这些框架支持服务端渲染，但这可能又会增加开发成本。

有没有一个可用于任何单页应用的解决方案，让我们不用对代码做改变保持原有的开发效率？可以帮我们做到这点，它通过控制渲染出最终的返回给爬虫来实现。
介绍
前不久团队宣布支持模式，支持所具有的所有功能只不过因为不显示界面而更快资源占用更小。相比于之前的作者因为的推出而宣布停止维护的优势在于它又一个很强的爹会一直维护它优化它，并且在用户量、体验、速度、稳定性都是第一的，所以我认为会渐渐替代之前所有的方案。
如何操控
既然是以无界面模式运行的，那要怎么控制它和它交互？ 提供了远程控制接口，目前可以通过来用代码向发送命令进行交互。在启动的时候要开启远程控制接口，然后通过  连接到后再通过协议控制。具体操作见文档：

以模式和远程控制模式启动
连接到远程控制它
控制时支持哪些操作具体怎么用

原理与实践
原理
先会通过以模式启动和守护你操作上的，再通过操控去访问需要被的网页让运行这个网页，等到包含数据的被渲染出来时读取当前网页转换成字符串后返回。
怎么知道你的网页什么时候已经渲染出包含数据的了可以返回了呢？为了提升效率，默认会在时返回。对于复杂的场景还可以通过开启的选项，等到网页里调用了时返回。
只渲染出了还不够我们还需要检测出来着搜索引擎爬虫的访问，如果请求来着爬虫就返回渲染后的否则返回正常的单页应用所需。
综上，整体架构如下： 

实践
只需以下几行简单代码就可做到：
  = 
={
      =  {
        
    }
}
只是做了渲染出的工作，要实现还需要和服务器集成。为了方便大家使用我做了一个中间件，要集成到你现有的项目很简单，如下：
   = 
  =  

通过以上简单的两步，你的单页应用就被了。
应用场景扩展
除了用于通用解决方案其实可以用于通用服务端渲染，因为目的都是渲染出最终的再返回。针对通用服务端渲染我也做了一个中间件。使用做服务端渲染的
优势在于：

通用，适用于所有单页应用
对原有代码几乎无改动，最多再合适的地方加个，保持原有开发效率

缺点在于：

和、等只带的服务端渲染相比性能低经我测试大约   
渲染时占用资源高，一次渲染大约占用内存，当请求量大时服务器可能扛不住。但是可以通过缓存渲染结果优化。

总结
大家可能会说这个很像，没错思路是一样的，的优势在于：

开源可自己部署，要收费是商业产品
基于已经停止维护的

本文中所提到的相关项目都是开源的并且有详细的使用文档，它们的文档链接如下：

 

 
 

喜欢的给个，希望大家和我一起来改进它们让它们更强大。
阅读原文

原文链接：前言：
 中如果发生了一些错误， 还活着， 已经  住了，如何获取到  中的关键  信息呢？
分析：
， 

默认虚拟化出来的键盘，它的是，具有非常高的优先级。可见，在大部分情况下，不挂的情况下，都是可以响应键盘中断的。
，
提供了一组 ，用来触发特定的内核行为。在的文档中，有比较具体的描述，在这里截取几个关键的地方：

  ，用来打开关闭功能。简单一点，取就好。
配置好了之后，键盘中敲或者在中敲   ，再就可以看到一些帮助信息。
，
基于上述，那么可以给发送 来触发的。但是，如果也是，那么就会会被截获。不能发送到中。
所以可以使用提供的能力：
   _ _ _
上面的几个_，作者也记不住，每次都要去中查看。
，
我们希望把的重定向到中的某个文件中，一来方便阅读查看，二来中真的住了，我们也看不了。
所以，在启动虚拟机之前需要给配置设备，在的文档中使用这样的配置：
     =
       = =
       =
    
， 
在部配置完成后，启动就可以使用设备了。在中执行
 “ ”  ，就可以在的文件中出现这样的了。
修改的配置，编辑，修改的启动参数：
     ==  =
执行，再重启，就可以看到很多写到了对应的文件中了。
，
上述的步骤配置完成后，可以看到大量的的，但是依然不能看到的。因为 的关系。
在中，敲 可以看到的 。默认情况下，应该可以看到“            ”这样的显示。
的 在中实现，

我们只要关注第一个就行了，在中敲 “   ”  来调整一下。
接下来再触发就可以看到了。
，

作者这里为了复现一个问题，构造场景的时候，看到了类似的。在执行的时候，进程进入了状态了。也是符合预期的，因为作者是为了测试在中写数据的时候，做磁盘热拔的。
，
中的是，构造一次也挺有趣的，还有就是测试的 功能的时候很有用。
那么，是如何实现的呢？
中，

打开  ，在对空指针赋值，就了。其他也在这个文件中实现的，略有意思。作者 | 高剑林编辑 | 京露

高剑林，腾讯架构平台部，平台开发中心基础研发组组长。先后从事过通讯设备的开发和存储设备的研发工作。目前致力于一体化的涉及—从硬件和软件的结合，以及多个层面综合考虑系统设计，找出最优路径的设计思想。

以体系为代表的已经占有了桌面和服务器处理器的绝大部分份额，而且这个趋势还在不断增强。具有兼容性强、易编程、应用资源丰富、价格低廉的优势，但是在某些领域，存在天然的缺陷，以、为代表的硬件可以克服的缺陷，因此也拥有自己的市场。
 图解各类型芯片
从设计软件进行计算任务的软件工程人员的角度，可以将芯片分为、、和等类型。
对处理器芯片的特性和应用，理论上是软件人员具有最大发言权。但每一类芯片的使用和理解都不是一件简单的事情，以为例：即使从事环境的编程设计多年，也很难谈得上深入理解了的设计思想。能深入各种芯片编程的软件人员更是凤毛麟角，更别谈进行分析和比较。另外一个问题是软件和硬件设计已分离多年，软件设计人员，很难深入理解芯片的设计思路，即使操作系统的设计人员也一样。而芯片的设计厂商由于利益相关，往往只宣扬各自的优点，回避缺陷，在测试对比中选择有利的测试条件，产生对己有利的测试数据。测试数据的真真假假，更加混淆了技术人员的视听。
在对各种芯片比较和研究的过程中，我们认为不应该沉湎于具体芯片的架构和设计思路，而应该关注芯片的实际应用。有两个原因支持我们的思路。一个原因是芯片的架构非常繁复，熟悉各种芯片几乎是不可能的任务。另一个更重要的原因是技术的价值在于应用。不管何种芯片设计或者架构，最终决定芯片价值的是实际的应用。从应用的角度出发，应按照易用性和经济性两个维度考察芯片。
易用性指用芯片进行编程的难度以及相关编程资源的获取难度。这个指标技术人员虽然不怎么关心，但其实对芯片发展有重大，甚至是绝对的重要性。例如在的编程实践中，相关的编程资源非常难以获得，即使获得也往往是代价巨大。比如常见的图片，相关的编解码库往往需要付出数万美元的成本，这和领域大量的开源库完全不能相提并论。价格的昂贵还带来了测试和验证的繁杂。提供库资源的厂商往往需要旷日持久的沟通和谈判以及签署协议才能进行验证工作，这在很多研发项目运作中几乎是不可承受的。
经济性指提供相同性能情况下的芯片成本。芯片往往型号众多，比如芯片，既有上千美元甚至几千美元售价的高端型号，也有几美元计价的低端型号。脱离芯片成本谈论性能没有意义。需要指出的是，成本是综合的运营成本，而非单独的芯片购买成本。比如某款芯片如果性能等于十倍，那么它不仅仅是顶替了十颗，而是顶替了十台服务器的采购成本以及十台服务器的运营成本，考虑到实际的运营成本往往大于采购成本，后者可能更具有重要性。
 芯片的分类
对常用的处理器芯片进行分类，有一个明显的特点：需要软件支持，而则是软硬件一体的架构，软件就是硬件。这个特点是处理器芯片中最重要的一个特征。
  
上图可以从两个角度来说明：从的方向，沿着这个方向芯片的易用性越来越强，的编程需要编译系统的支持，编译系统的作用是把高级软件语言翻译成机器可以识别的指令也叫机器语言。高级语言带来了极大的便利性和易用性，因此用实现同等功能的软件开发周期要远低于芯片。沿着的方向，芯片中晶体管的效率越来越高。因为等芯片实现的算法直接用晶体管门电路实现，比起指令系统，算法直接建筑在物理结构之上，没有中间层次，因此晶体管的效率最高。
本质上软件的操作对象是指令，而则扮演高速执行指令的角色。指令的存在将程序执行变成了软件和硬件两部分，指令的存在也决定了各种处理器芯片的一些完全不同的特点以及各自的优劣势。
等芯片的功能是固定的，它们实现的算法直接用门电路实现，因此编程就是用门电路实现算法的过程，软件完成意味着门电路的组织形式已经确定了，从这个意义上，的软件就是硬件，软件就决定了硬件的组织形式。软硬件一体化的特点决定了设计中极端重要的资源利用率特征。利用率指用门电路实现算法的过程中，算法对处理器芯片所拥有的门电路资源的占用情况。如果算法比较庞大，可能出现门电路资源不够用或者虽然电路资源够用，但实际布线困难无法进行的情况。
存在指令系统的处理器芯片不存在利用率的情况。它们执行指令的过程是不断从存储器读入指令，然后由执行器执行。由于存储器相对于每条指令所占用的空间几乎是无限的，即使算法再庞大也不存在存储器空间不够，无法把算法读入的情况。而且计算机系统还可以外挂硬盘等扩展存储，通过把暂时不执行的算法切换到硬盘保存更增加了指令存储的空间。
处理器芯片各自长期发展的过程中，形成了一些使用和市场上鲜明的特点。领域存在大量的开源软件和应用软件，任何新的技术首先会用实现算法，因此编程的资源丰富而且容易获得，开发成本低而开发周期，而编程需要的资源通常很难获得，这些资源往往以 的方式授予和收费，授予的周期往往很长而且需要签署法律协议，而费用也很昂贵。导致的开发成本高而且周期很长。
 架构和编程设计
无论是体系为代表的繁杂指令系统还是精简指令系统，其核心都是执行一套指令系统。体系的不断更新换代，不断提升主频，采用更先进的工艺和新架构，目的就是为了更高性能地执行指令。因为系列的应用广泛，已经成为事实上的标准，本文所指的特指系列的。
从内部结构观察，大致可分为控制器和执行器，再加上存储管理部件以及总线接口部件。控制器不断从存储器取出指令，进行指令译码，执行器从译码完成的指令队列中取出译码指令执行。各个功能部件既能独立工作，又能与其他部件配合工作，下图给出了各个部件之间的指令操作流水图。

指令系统是计算机系统发展中的巨大进步。借助指令系统，高级语言的出现成为可能，大大方便了计算机的应用。但是事情的另一面是使用指令系统后，所有的计算任务都要翻译为指令，执行一个简单的计算任务可能就需要多条指令完成。从晶体管的角度来看，简单的计算任务可能就需要众多的晶体管共同参与。为提升性能，采用指令系统的，其性能设计出发点是增强指令执行的效率。
以前的架构设计一直围绕如何增强指令执行的效率，为此采取的措施是不断提升主频、加多流水线奔腾首次应用了双路流水，而现在的往往拥有以上的流水数目
以及增加的提升取指令的效率早期奔腾芯片拥有几十的缓存而至强的三级缓存超过，甚至可达到。近几年，的架构更加重视多核的应用，期望通过多核实现更高的性能。
设计出发点是增强指令的运行性能，因此的核心功能强大，占用的晶体管资源庞大，具有很高的运行效率，因此的多核不可能做到非常多。目前顶级的 具有十多个核心，而已经达到几千个核心。
对编程设计来说，如果线程完全独立的执行计算任务，线程间数据不存在共享和竞争关系那么并行效率可以达到线性效果。不过现实中的编程，有很大一类是单任务的并行化，即将一个繁杂的任务通过多核并行执行来加速，那么就面临两个困难：一个是将任务并行化之后面临多线程之间的切换代价。因为核心功能强大，因此操作系统切换线程时需要内部大量的状态寄存器置位，所以线程之间切换是代价很大的操作实测中，线程切换大概需要几十微秒，如果计算任务的执行时间小于这个数字，那么多线程执行对性能提升可能并无收益，甚至可能效率反而下降。
另一个问题是任务执行中数据的依赖关系。如果计算任务中某部分必须利用前面部分的计算结果，即存在数据依赖性，那么就必须等前面部分计算完成才能执行后面的计算，而不可能并行计算。数据依赖是计算中经常遇到的场景，编程设计需要调整代码结构尽量减少相关性提升并行性。
 的架构和编程设计
图形处理器这个概念最早是显卡厂商公司提出来，如它的名字所象征的意义，主要是为图形处理而设计。图形处理计算的特征表现为高密度的计算而计算需要的数据之间较少存在相关性。下图展示了和设计的不同之处。

图   架构和对比
如图所示，的设计出发点在于更适用于计算强度高、多并行的计算。因此，把晶体管更多用于计算单元，而不像用于数据和流程控制器。这样的设计是因为并行计算时每个数据单元执行相同程序，不需要繁琐的流程控制而更需要高计算能力，因此也不需要大的容量。           

图   内部结构
如上图所示，的架构围绕流处理器阵列构建的。 流处理器能同时并发执行上百线程。指令流水线化以利用单线程内的指令级并行，与核不同，指令顺序发射，没有分支预测和猜测执行。
流处理器以个为一组创建、管理、调度和执行并行线程，这个线程组称为束。束内包含的不同线程从同一程序地址开始，但它们有自己的指令地址计数器和寄存器状态，因此可自由分支和独立执行。
束每次执行一个相同的指令，所以如果束内所有个线程在同一条路径上执行的话，会达到最高效率。如果由于数据依赖条件分支导致束分岔，束会顺序执行每个分支路径，而禁用不在此路径上的线程，直到所有路径完成，线程重新汇合到同一执行路径。分支岔开只会在同一束内发生，不同的束独立执行不管它们是执行相同或不同的代码路径。
需要注意的是，的线程概念和的线程概念不同，有虚存概念，线程具有自己的线程空间和页表项，还包括的诸多状态寄存器。因此的线程功能更强大，切换线程的代价也更高，而的线程可以被看做一些计算指令构成的计算块，它们的调度、执行和切换要简单的多。从一个线程的执行上下文切换到另一个线程的执行上下文没有消耗，线程之间的切换是硬件切换，消耗的时间几乎可以不考虑。
计算任务中可能存在串行的部分。串行指不可并行、必须顺序执行的计算部分。这种串行部分极大的降低了任务的并行度和计算性能。在后续的实践例子中，就遇到了这样的串行部分。
单独的缺乏必要的环境，没有外部设备和操作系统的支持，不能和网络或者本地硬盘交换数据，因此在实际应用中，总是要和搭配使用，共同构成编程的环境，这种编程称为异构编程。异构编程不可避免管理的内存和管理的内存之间的数据交互，数据交互的效率极大程度上将影响的运行效率。
 的架构和编程设计
不采用指令和软件，是软硬件合一的器件。对进行编程要使用硬件描述语言，硬件描述语言描述的逻辑可以直接被编译为晶体管电路的组合。所以实际上直接用晶体管电路实现用户的算法，没有通过指令系统的翻译。
的英文缩写名翻译过来，全称是现场可编程逻辑门阵列，这个名称已经揭示了的功能，它就是一堆逻辑门电路的组合，可以编程，还可以重复编程。不能重复编程的也有，主要是基于反熔丝技术，主要用于军事用途。下图展示了可重复编程的内部原理图。
  
图   内部结构图
内部可以分为可配置逻辑模块、输入输出模块和内部连线等三个部分。是输入输出的接口，提供芯片和外界电路的连接，完成不同电气特性对输入输出信号的驱动和匹配。
是的基本逻辑单元。的实际数量根据芯片种类的不同而不同，以公司生产的早期 系列为例，每个包含两个。每个内部包含个查找表、个触发器和多路开关等资源。
数字逻辑电路从原理上，是通过时序部件和组合逻辑来完成一系列的功能，而通过芯片内部众多的单元提供了众多的组合逻辑和时序逻辑。因此通过配置就可以实现各种不同的功能。
本文关注的重点不是的硬件原理，也不是逻辑设计的技巧和语法，而是从并行计算的角度分析多种芯片和程序设计的特点。
  编程和编程的特点
编程和编程最大的不同之处是前者是软件模式，而后者是硬件模式。软件模式意味着代码之间是串行模式，代码之间有严格的执行顺序不考虑指令乱序执行的影响，而硬件模式则意味这代码之间是并行模式，每一条语句，经过编译在硬件领域，编译被称为综合之后就是一个真实的逻辑电路。通过一个具体的例子可以更准确观察到软件模式和硬件模式的区别：

对于上面软件模式的代码，这两条语句之间是串行执行的不考虑指令流水，经过编译之后，先执行第一条语句，完成变量的赋值运算，然后执行第二条语句，执行变量的赋值运算。
如果后续没有对变量和的再次赋值，那么变量将始终保持当前的赋值不变。

上面语句是硬件的赋值语句。和软件模式的执行方式不同，上面语句经过综合后，将形成两个逻辑电路，一个电路的输入是和，输出是，而另一个电路的输入是和，输出是。这两者之间是完全独立的，彼此并行而没有任何的顺序关系。
另外一点和执行模式不同的是，只要输入端、或者、有任何的变化，那么输出端或者也立即变化，不需要再次的赋值。从硬件角度很容易理解这一点，因为的硬件描述语句被生成为逻辑电路，它是实实在在的存在并且一直执行，而的指令被执行之后，除非被加载到执行单元再次执行，否则不会自动再执行。
使用编程，最大的难点在于将原有的串行思路转变为并行思路。由于人脑的思维模式更接近串行模式，所以用并行模式实现算法和功能的时候，通常困难比串行模式来得大。除此之外，还有如下特性不同：
硬件具有资源占用率的概念。编程最终要用逻辑电路实现，因此复杂的算法需要耗用更多的逻辑电路，如果使用的逻辑电路超过芯片的资源是无法实现的。这个特性和完全不同，的程序存储在外部存储中，执行时从外部存储载入内存执行。内存和外部存储的容量远远超过算法需要的存储量，基本不可能出现资源不够用的情况。
通常运行的时钟频率远小于的时钟频率。对编程的过程，实际是将芯片内部逻辑电路连接起来实现算法和功能的过程。从的结构可以发现，是固定排列的门电路阵列，逻辑电路固定的排列方式决定了编程过程有大量的冗余电路没有利用，走线也不能够充分的精简。因此当前主流芯片编程通常运行时钟频率为～，而的运行频率已超过的关口，现代主流的 的时钟频率甚至超过。

相关阅读：接认识多种处理芯片的特性和实战 下篇在远程主机上，我开启了 服务，用  可以打开，比如说用户名为 ，密码为 。不过用  客户端远程连接时却报了错误，比如  报了如下错误：
    ‘’’′ 
服务器是腾讯云

比较奇怪， 可以正常访问，而  为什么无法连接呢？可能的原因，应该就是  限制了，在连接时使用的是，而我们访问页面才使用的远程主机的 ，而  连接的是远程主机。
解决方法如下
首先修改的配置文件将
 = 
这一行注释掉要不然它永远限制了只能本机连接。
然后重启服务。
   
然后我们需要新建一个用户，然后授予所有  可以访问的权限就好啦。
在下面的  语句中， 即为用户名， 为你要设置的密码。
     

         

     

         
通过执行以上语句，便创建了一个用户名为 ，密码为  的新账户，再用新账号登录，就可以连接成功啦。

相关推荐
开发实践问，你能住几个？字符集中文乱码剖析 占用空间一键查询实践作者：唐郑望，腾讯后台开发 工程师商业转载请联系腾讯获得授权，非商业转载请注明出处。原文链接：

 导读
语言的三个核心设计  |  | 

   —— 

从到远离舒适区保持饥饿感
一、
是一门面向接口编程的语言，的设计自然是重中之重。中对于设计的巧妙之处就在于空的可以被当作“”类型使用，它使得这样的静态语言拥有了一定的动态性，却又不损失静态语言在类型安全方面拥有的编译时检查的优势。
一 
从底层实现来看，实际上是一个结构体，包含两个成员。其中一个成员指针指向了包含类型信息的区域，可以理解为虚表指针，而另一个则指向具体数据，也就是该实际引用的数据。
的结构如下：
其中  包含了一些关于本身的信息，_表示具体实现类型，在下文中会有详细描述， 是一个状态变量，是一个长度为的指针数组，在  的地址后面依次保存对应的函数指针。  包里面有一个表，通过这个表可以取得 ，跟则是为了保存表中对应的位置并设置标识。主要代码如下：

空接口的实现略有不同。中任何对象都可以表示为{}，类似于中的 ，而且{}中存有类型信息。
的结构如下：


提示：关于的更多信息，可以参考：

二_
关于的应用，下面举个简单的例子，是关于与数据库交互的。
首先在 库中创建一张任务信息表：
数据库交互最基本的四个操作：增删改查， 这里以查询为例：
来实现查询这张表里面的所有数据
其中
这段代码可以实现查表这个简单的逻辑，但是有一个小小的问题就是，我们这张表结构比较简单只有个字段，如果换一张有个字段甚至更多的表来查询的话，这段代码就显得太过于低效，这个时候我们便可以引入{}来进行优化。
优化后的代码如下：
由于{}可以保存任何类型的数据，所以通过构造、两个数组，其中的每个值指向相应值的地址，来对数据进行批量的读取及后续操作，值得注意的是是一门强类型的语言，而且不同的{}是存有不同的类型信息的，在进行赋值等相关操作时需要进行类型转换。
对于事务处理也提供了比较好的支持。一般的操作使用的是对象的方法，事务则是使用对象。使用的方法可以创建对象。对象也有数据库交互的和方法，与的操作类似。查询或修改的操作完毕之后，需要调用对象的提交或者回滚。
例如，现在需要利用事务对之前创建的表进行操作，代码如下

注意： “ = “ 跟 “ = “两个操作符不要弄混淆

如果不需要进行事务处理的话，对应的代码如下
可以与上面增加事务操作的代码进行对比，因为操作比较简单所以也就增加了几行代码，以及将对象换成了对象。

提示：关于对的更多支持，可以参考官方文档：

二、
并发：同一时间内处理 不同的事情并行：同一时间内做不同的事情
从语言层面就支持了并行，而则是并行设计的核心。本质上，就是协程，拥有独立的可以自行管理的调用栈，可以把理解为轻量级的。但是是操作系统调度的，抢占式的。是通过自己的调度器来调度的。
一
的调度器实现了调度模型，其中有三个重要的结构：，，
    
    
  
底层的数据结构长这样：
、 和  之间的交互可以通过下面这几张来自  的图来展现
上图中看，有个物理线程，每一个都拥有一个上下文，也都有一个正在运行的 。图中灰色的那些并没有运行，而是出于的就绪态，正在等待被调度。由来维护着这个队列。
图中的可能是被新建出来的，也可能是从线程缓存中取出来的。当返回时，它必须尝试获取来运行，通常情况下，它会尝试从其他的那里””一个过来，失败的话，它就把放在一个 里，然后自己会被放入线程缓存里。所有的会周期性的检查 ，否则 上的永远无法执行。
另一种情况是所分配的任务很快就执行完了因为分配不均，这就导致了某些处于空闲状态而系统却依然在运行态。但如果 没有任务了，那么就不得不从其他的那里拿一些来执行。通常情况下，如果从其他的那里要偷一个任务的话，一般就‘’ 的一半，这就确保了每个都能充分的使用。
如何从其他维护的队列中””到呢？这就涉及到算法，关于该算法的更多信息可以参考：
二_
举个简单的例子来演示下是如何运行的
这段代码非常简单，两个不同的异步运行运行结果如下：
然后做个小小的改动，只是将中的两个函数的位置互换，其余代码变：
会出现一件有意思的事情：
原因也很简单，因为返回时， 并不会等待其他非主结束。对上面的例子， 主函数执行完第一个后，创建了一个新的没来得及执行程序就结束了，所以会出现上面的运行结果。
三、
在相同的地址空间中运行，因此必须同步对共享内存的访问。语言提供了一个很好的通信机制，来满足之间数据的通信。与  中的双向管道有些类似：可以通过它发送或者接收值。
 
其中的结构如下
可以看到其实就是一个队列加一个锁。其中和可以看做生产者跟消费者队列，分别保存的是等待在上进行读操作的和等待在上进行写操作的，如下图所示。
写   的具体实现如下只选取了核心代码：具体可以分为三种情况：
— 有阻塞在上，而且为空，直接将数据发送给该上。
— 有空间可用：将数据放到里面。
— 没有空间可用：阻塞当前。
读 和发送的操作类似，就不帖代码展示了。
_
关于跟进行通信的一个简单的例子逻辑很简单
这里我们定义了两个带缓存的  和 ，如果把这两个都换成不带缓存的，就会报错，不过可以这样进行处理就可以了：
比较常见的操作还有 ， 存在多个的时候，可以通过可以监听上的数据流动。
因为  和  都为空，所以  和  都不会读取成功。 则  执行  语句。
这篇文章是对这段时间学习的一次小结，也算是抛砖引玉，文中如有理解不对或者描述错误的地方，也恳请大家批评指正，关于的学习，更希望能与大家多多交流，谢谢！

关于腾讯 
腾讯是腾讯游戏官方推出的一站式游戏测试平台，用十年腾讯游戏测试经验帮助广大开发者对游戏开发全生命周期进行质量保障。腾讯提供：适配兼容测试；云端真机调试；安全测试；耗电量测试；服务器性能测试；舆情分析等服务。
点击地址：立即体验！最近在尝试将创梦者数据库搬迁到腾讯云数据库。但是直接导出，然后再导入数据库出现如下错误。下面我就详细阐述下，面对数据库导入出现错误时我的解决思路和小窍门。

刚开始怀疑是版本问题，但是更改版本后依然提示错误。
于是想到了一个数据库管理工具：

将自建的数据和腾讯云数据库打开外网地址后分别链接到数据库管理工具：



链接完毕后，将本地数据库的表直接全选复制，然后粘贴到新表：


然后运行发现依然报错，用的数据库检查工具检测后发现：

不过目前我们的数据库已经搬迁成功了，就只剩下这两个表。我尝试过单独导出数据表，字符缺省各种办法，依然无效，应该是使用的自己编写的模板没有对文字进行格式化直接存进数据库导致的，当然这些都是后话，目前为止如果不删除数据表的前提，我们只能用非正常手段强行导入数据库。我们将这两个表打开然后导出为格式转储为会出现编码问题：

然后在目标数据库导入数据。

完工，但是由于数据库支持的数据类型有限，导入时会出现较大的偏差，所以我们需要自己重新设计数据类型和长度。

在后台运行数据库检测工具，查看原本数据类型。然后打开工具一一对数据表类型，长度，，主键进行修改。

至此本次数据库搬迁全部完毕。关闭腾讯云的外网数据库地址，修改三个配置表采用内网，端口即可：
\\_\\_\_\\

至此数据库搬迁完毕，数据访问快了一倍不止。

相关推荐
存储总量达的实例，如何完成迁移？
如何轻松在云端部署、使用数据库
腾讯云主机中无法远程连接的解决办法个人介绍：微软最具价值专家、认证讲师、无界工程师、场景式学习倡导者，曾在阿里仓储解决方案公司担任系统架构师一职，目前就职于互联网企业担任系统运维工程师，致力于改善生活的实践之路。

接上篇在腾讯云上创建您的  和在腾讯云上创建您的 我们准备好了存储，并让两台  节点子机成功连上了，相关的域环境配置也在第一篇在腾讯云上创建您的   的时候完成了部署，现在，让我们上正菜吧。 
在正式开始之前，讲一个题外话，腾讯云有非常高的安全要求，且有很多方面的安全保障，比如：安全组、项目隔离等机制，日常会通过端口流量仅流量来进行安全方面的过滤看是否输入输出、等流量来保障服务器安全。
对于这种情况，一般分为两种：

自主性软件对外扫描发出大量包

被入侵然后对外发出大量包


无论是哪点，你都可能会收到安全方面的警告邮件比如博主就遭遇了腾讯安全团队的邮件提醒：

然后子机状态变成：

这种时候，建议自查业务，看看是否被入侵并安装了发包端，然后起一台虚拟机专门作为连接实验环境的机器即跳板机，设置安全组的仅对跳板机放通即可，并且建议内网全放通策略：

题外话说完，接下来，我们正式开始搭建 本文参考，先在上下载最新的  并准备好您的相关：

涉及架构如下：

涉及如下：



编号
服务器名称
生产
存储
心跳
对外







无
无







无




















、登录两台节点机，分别安装：

、完成后在上创建账户，用作专门管理的管理员账户：

、分别加到节点的本地管理员：

、接着，使用之前准备好的这里不能采用产品，见《在创建您的 ——机准备篇》来进行绑定群集，打开上的服务器，添加对应 与：

、创建群集仍然使用域管理员进行创建因为涉及验证等，打开群集管理器，点击验证配置：

、输入两台作为节点的：


、完成验证后发现网络方面有错误存储驱动错误是正常的，因为驱动没有通过群集签名验证：

、点击查看报告后发现，原来是问题导致：


、将所有链接去掉，然后选择重跑验证试试，完成验证：

、接着点击完成，在弹出的创建群集框中，输入群集名称即在上创建的群集名称：

、将可用存储添加的勾去掉，我们选择手动添加：

、接着完成创建即可由于没添加存储，故会产生警告：

、接着我们点击群集网络管理，配置段为群集生产网络：

、段作为存储网络，选择不允许通过群集网络：

、将网段作为心跳网络：

、同时设置实时迁移网络为心跳网络最佳实践为独立一条迁移网络：

、在我们添加群集存储之前，我们需要对存储进行格式化并分卷：

、接着，我们就可以开始添加群集存储了：

、点击添加存储，将两块磁盘添加到群集中：

、将的数据盘作为 的数据盘，并添加到中：



、接着点击群集管理器上的群集名称，右键配置仲裁：





、确保各项资源联机状态即可可以通过切换群集磁盘来确认故障切换是否正常：


相关推荐【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群作者 | 王学禹
导语
 性能提升的方法之一是尽量减少  对比和冗余操作，从而减少组件重复渲染；刚开始使用  的时候只专注于对于逻辑的处理，导致很多地方会出现重复渲染或者修改很小的地方引发全部或者不相干的区块重新渲染的情况；这次准备逐步对写过的代码进行重新  ，记录一下对于性能优化的实践。
 按需渲染
在非技术层面，可以考虑对页面进行分块按需加载和渲染，即优先请求和渲染页面主体，延迟请求加载非页面主体内容；
如页面分为左右两个区块，左侧区块为页面主体；可以考虑先异步请求左侧数据并进行渲染，在左侧区块渲染成功之后再对右侧辅助区块进行请求和渲染右侧区块中进行数据请求；同时将左右两侧区块数据分别在各自组件最顶层进行维护，以后互不影响；
避免不必要的重复渲染
除去可以对页面进行分块渲染之外，结合的组件渲染机制，也可以在组件进行更新时进行更细致的优化，目前主要遇到以下两种情况：
组件组织结构
页面结构的组件化可以方便地进行页面数据的组织；按需渲染的实质是对数据进行分块维护。
比如前面提到的左右结构的页面布局，左侧和右侧的数据不会互相影响，就可以分左右两块进行维护；就好比一个个小国家，数据的流动维护在组件内部，从不或者很少与外界进行交流。
对于那些只用来展示，或者内部数据在生命周期内不会变动的组件我们就可以主动禁止掉组件的更新；
组件数据更新
对于内部数据可能会发生变化的组件，我们可以通过判断数据是否真的进行了更新从而决定是否进行重新渲染。也提供了相应的生命周期函数方法供我们使用。
一个很简单的想法是在函数中对前后的数据做深检查，遍历所有的属性，如果相等则不进行重新渲染；但是如果在数据结构很复杂的情况下，检查比较的代价是灰常昂贵的，可能性能反倒还不如干脆直接重新渲染。
因此理想状况下我们不希望在中对数据做深检查。在解决这个问题之前，还需要我们分清基本数据和引用数据的区别，比如：

 基本类型
  = 
  = 
 = 
 ===    

 引用类型
  =  
  = 

 ===   
对于比较复杂的数据类型，变更后直接用‘===’进行比较是没有用的，因为引用相同；如果可以在变更数据的同时产生一个新的引用不同的数据，那么我们就可以直接进行引用的比较从而判断数据是否有变化了，因此可以借助不可变数据结构的思想的帮助。
很好的解决了上面的需求，在数据发生变更后产生一个全新的 不可变数据，同时通过 的方案避免了 带来的过多消耗除了数据变化检测，还能很好的处理数据缓存、回退等；
因此在使用了 来管理我们的数据之后，如果引用数据发生变更，我们通过对比两者引用是否相同即可判断是否需要进行重新渲染；
对此，提供了来对 进行支持；
同时，也提供了去改进生命周期方法 ，自动对和进行浅比较 ，检查组件是否需要重新渲染；只有检测到前后或者前后发生变化时，才会调用  方法。
因此通过借助  浅比较，我们可以更好的避免组件的重复渲染，从而有效的提高性能。作者：朱灵子
 是一个  和  用来创建用户界面的  库。创造  是为了解决一个问题：构建随着时间数据不断变化的大规模应用程序。本文初探的顶层事件代理机制

顶级事件代理机制
采用的是顶层的事件代理机制，能够保持事件冒泡的一致性，可以跨浏览器执行，甚至可以在中使用的事件。
 实现了一个“合成事件”层，这个事件层消除了  与  标准实现之间的兼容问题。首先区分原生事件与合成事件，我们在  方法里面通过  绑定的事件就是浏览器原生事件，使用原生事件的时候注意在  解除绑定 ，所有通过  这种方式绑定的事件都是绑定到“合成事件”。
“合成事件”会以事件委托 的方式绑定到组件最上层，并且在组件卸载的时候自动销毁绑定的事件。
事件代理
在  节点上绑定事件比较消耗内存  则实现了一遍符合  规范的事件系统。接下来介绍该事件系统的实现原理， 事件 监听器被绑定到整个文档的根节点上。当事件被触发 浏览器会给出一个触发目标事件的  节点。为了在  的层级传播事件  不会迭代   的层级，而是依靠每个   各自独立的  来编码这个层级。我们能通过简单的字符串操作来获取所有父级  的父级内容，再把事件监听存储在当中。下面的例子展示了事件广播到整个 时的传播流程。







浏览器为每个事件和每个创建一个新的事件对象，我们可以从这个事件对象获取到事件的引用，但是这些事件对象也意味着高额的内存分配。为了减轻垃圾回收的负担， 在启动时就为那些对象分配了一个内存池，当我们需要用到某一个事件对象时就可以从这个内存池进行复用。
事件系统框图
      
  |         |    
      
        |           
                   
      
  |  |    
  |    |    
                               
        |                          ||
        |                          |         |     |
  |                            
  |     |      |                            
  |     ||                    |       |
  |            |        |              |       | |
  |  |        |              |     |   |  ||
  |     |        |              ||     |  | |
  |            |        |              |       |   |
  |     |              |                    
  |     |      |        
  |                            
        |                           |        ||
                                   |     |
                              
  |  |   
  ||   
  |             |   
  |             |   
     

 框图中的主要用于连接顶层事件侦听器，例如
  ‘’ ‘’ 

接下来是对事件系统原理框图的理解：

 用于捕获最原始的浏览器事件，它主要由负责，被注入后可以支持插件化的事件源，这一过程发生在主线程。
我们对各种事件进行去重复性处理以兼容不同的浏览器，这一过程是由工作线程来完成的。
最后我们转发所有的本地事件到这些本地事件由相关顶级类型来捕获，会注解每个事件，然后分派事件。
组件状态更新


中的代表父级分发下来的属性，代表组件内部可以自行管理的状态，并且整个没有数据向上回溯的能力，也就是说数据只能单向向下分发，或者自行内部消化。子组件改变父组件的办法只能是通过等事件触发父组件声明好的回调，也就是父组件提前声明好函数或方法作为契约描述自己的将如何变化，再将它同样作为属性交给子组件使用。
这样数据总是单向从顶层向下分发的，只有子组件回调在概念上可以回到顶层影响数据，这样一定程度上是响应式的。为了面临所有可能的扩展问题，最容易想到的办法就是把所有集中放到所有组件顶层，然后分发给所有组件。
跨浏览器执行的实现原理
基于构建，可以更快、更有效地完成操作。实现了一套完整的事件合成机制，能够保持事件冒泡的一致性，同时可以实现跨浏览器执行，甚至可以在中使用的事件。《    》中讲解了如何模拟  等事件的冒泡，还讲述了 与  等事件的模拟。除浏览器外都可使用支持冒泡的  来代替  事件，会在捕获阶段监听  事件。
 事件会在鼠标点击或者按回车键时触发，所以可以监听冒泡的  和  事件，并判断触发事件的元素是否为一个  元素的后代节点，然后手动触发  事件。在 浏览器下，如果作为 之一的事件不是挂载在元素上那么当鼠标在不是该节点或者该节点所对应的子节点元素上移动时，事件就不会被触发。根据不同的浏览器对事件、事件以及、事件的支持情况的不同，进行了有针对性的处理，以下为事件系统跨浏览器执行的部分代码实现：
        {
      = 
      = 
      = 

      = 
       =      {
        = 
          {
          ===  {
            {
              
          }    {
              
          }  {
             浏览器捕获鼠标滚动事件处理
              
          }
        }    ===  {

             {
              
          }  {
              _
          }
        }    ===  ||  ===  {

             {
              
              
          }    {
              浏览器支持的和事件
              
              
          }
           保证和事件只监听一次
           = 
           = 
        }    {
            
        }
         = 
      }
    }
  }


原文链接：项目背景
架构全称为      ，是一种强大的网站解决方案。是多个开源项目的首字母缩写。网站架构主要应用于动态网站的架构，这种架构具有通用性，跨平台，高性能，高负载，稳定等特性，是目前企业部署网站的首选平台。
同时，我们也看到了在国内的应用越来越成熟，相对于而言，对于静态文件的响应能力要远远高于服务器，所以近几年也兴起了架构。但是对于负载的网站而言，仍然是目前的首选平台。下图为网站架构案例结构图，通过基于域名的虚拟主机实现在一台服务器上运行论坛系统，论坛域名为。

项目目标

搭建服务器以提供域名对应地址的解析记录

搭建      动态网站平台

部署“云计算技术交流论坛“


项目分析

在服务器搭建域名解析。安装软件包以提供服务

服务器搭建动态网站平台。在服务器上安装，，， 等软件包。

在架构上部署论坛。


项目实现过程
搭建服务器

安装提供服务的软件包

     

编写主配置文件

  

  {
          
        }

    {
         
         
        }

编写地址库文件
  
  
              
                        
                       
                       
                       
                      

                         
                        
重启服务
   
测试服务
  
搭建      动态网站平台

给服务器安装操作系统，此处不再赘述。可参考本人自动安装操作系统技术博客。

：使用中最受欢迎的一个开放源码的服务器软件。软件包服务


安装软件包：
    
重启服务：
   
搭建虚拟主机并配置虚拟站点
                       创建虚拟站点网页根目录
    部署虚拟站点的主配置文件
                       固定格式以及监听端口
                    指定虚拟站点名
                指定虚拟站点网页根目录
                          固定格式

多线程，多用户的数据库管理系统。软件包，；服务：

安装软件包：
         
重启服务 
   
创建论坛管理员账户
                创建用户管理数据库
                     进入数据库
                   创建数据库
           
                                        授权为数据库以及论坛管理员

一种编程语言，最初用于设计生产动态网站。与，类似。软件包   

安装软件包
     
部署云计算技术交流论坛

解压___

  ___  

网页访问 项目展示结果如下：


点击我同意进行安装。

开始安装以及安装过程，如图



显示目录不存在，由于下的__目录不属于用户。将这些目录属主改为。

     {_}

安装数据库过程如图


初始化论坛系统及完善信息如图


输入数据库名 

数据库用户名

数据库密码

设置管理员帐号和管理员密码

安装完成后的论坛结果展示如下图



注意事项

注意需要安装的软件包不可少

需要将{_}目录属主改为。

注意填写数据库信息时不可出错。




阁主点评：云主机的玩法很多，本文作者在这里至少演示了两种：用于解析，和论坛部署。其中后者对于想搭建个人站点包括博客、论坛的人参考意义可能更大。我们梳理汇总了一系列的文章，制作了《如何从到搭建个人站点》专题，希望能够帮助朋友们快速地上线自己的第一个网站。

相关推荐
系统安装环境 安装配置服务器导语： 之间的边框存在共用问题，自然而然就存在冲突。既然存在冲突，那么就势必涉及到最后渲染哪一个样式的问题。本文就主要研究当冲突产生时，如何让浏览器按照自己意愿渲染冲突边框。在这篇文章中都有介绍，以及对表格的边框渲染原理进行了深度的剖析。

最近需求中有用到，并在做需求的过程中遇到 的问题，在空余的时间把遇到的问题进行探索一番，收获颇多，特此分享；
废话不多说，直接上干货！
表格行与列边框样式处理的原理分析
 、优先级最低 

结论
当且仅当两个相邻产生冲突的边框的为时，冲突边框才不会显示
 、优先级高于 

结论
边框的优先级高于样式的边框
、优先级 

结论
          默认值
、边框的溢出与属性有关 
结论上面两个角中水平方向紧贴着边框的边很重要，如若为，则边框会溢出垂直方向上不会发生溢出情况溢出的边框不会占用文本流的空间
理由具体实例可以查看优先级
 、较大者优先渲染 

结论较大者边框样式将被渲染
理由命名为“中”的单元格边框比其他边框都要大，因此渲染的是“中”单元格的边框，因而得出较大边框样式将被渲染，也符合里面对哪条边渲染的解释：“                ”
 、优先级 

结论优先级如下：，，，， 
理由可以到启用审查工具逐层去掉，，，， 边框，即可看到效果 、左上优先渲染原则 
结论水平方向上：当两个单元格只存在颜色不一致的情况下，发生冲突的单元格相对较左侧单元格的样式垂直方向上：当两个单元格只存在颜色不一致的情况下，发生冲突的单元格相对较顶部单元格的样式
 、四个角的渲染方式 






结论四个角重合之处采用组合层叠的方式进行渲染，而不是单一的选择某一种样式而四条边框则非重合单一选择某一条边进行渲染与，四个角重合之处不会采用组合层叠的方式进行渲染可以看出在下，四个角重合之处渲染优先级是，垂直方向上的两个相邻单元格，相对偏下的单元格的冲突边进行渲染
理由从“中”这个单元格的四个角可以看出，四个角除了会的底边是有其他叫层叠而来，而不是单一的去选择某种边框去渲染
 、表现形式 

结论宽度需要大于等于才能体现，否则，样式与无异会发生溢出，并且左右溢出值不一致
、与的表现形式 
结论  发生冲突边渲染情况可以得出   当 与 冲突并且在表格 非 第一行发生冲突时，两个冲突单元格的左上角和右上角以及冲突边的上角都存在问题从、、中可以看出，当 与 冲突且在表格 非 第一行发生冲突时， == ，  == 
理由例例可以到线上例子详细查看
、与的表现形式 
结论从发生冲突边渲染情况可以得出   从、、中可以看出，当 与 冲突且在表格第一行发生冲突时，两个冲突单元格的左上角和右上角以及冲突边的上角都存在问题从、、中可以看出，当 与 冲突且在表格第一行发生冲突时， == ，  == 
理由例例可以到线上例子详细查看
、与的表现形式 
结论发生冲突边渲染情况可以得出   两个单元格发生冲突以后，左上角都存在渲染问题当 与 冲突且在表格第一行发生冲突时，两个冲突单元格的左上角和右上角以及冲突边的上角都存在问题综合上部表现可以看出，当两个单元格发生冲突以后，处于表格的最后一行时，冲突边的上部角存在渲染问题综合上部表现可以看出，未发生冲突的边框的上部角会出现渲染问题
理由例例可以到线上例子详细查看
 、与的表现形式 
结论发生冲突边渲染情况可以得出   与可以相互转化，与可以相互转化
理由例例可以到线上例子详细查看
、与的表现形式 
结论发生冲突边渲染情况可以得出   
理由例例可以到线上例子详细查看
、属性对的影响 

结论上使用 属性，单元格只是边框，内容不变并不会左右调换，而是边框向后推了最后一个边框使用了渲染成第二个边框，倒数第二个边框渲染成倒数第三个边框，依此列推上使用 属性会使单元格左右调换，并且发生冲突的单元格相对较右侧单元格的样式
备注在上使用 属性，仅在下生效，其他浏览器下不会生效
结论：

 存在冲突情况， 不存在冲突情况理所当然；
 边框优先级最高，属性优先于所有其他边界的冲突；
 是边框样式的默认值，其优先级最低，只有当发生冲突的所有元素的边框属性都为时，边框才会被省略；
的值不相同时，窄边界将会被舍弃，较宽的边界会被显示；
的值相同时，样式优先级顺序为，，，，， ；
的值不相同时，最终显示的颜色优先级如下为，，，，，；
的值不相同时，但都是同一类型如：，水平方向由属性决定，若属则采用相对较左侧的元素样式，若属则采用相对较右侧的元素样式；垂直方向上则采用相对较靠近顶部的元素样式；
 相邻的边框存在冲突，但两对角的两个单元格是不存在冲突现象；
宽度渲染与设置值不一致；
宽度需要大于才能体现，否则，样式与无异；
水平方向上：当两个单元格只存在颜色不一致的情况下，冲突边界渲染的样式与上设置该属性有关。若属则采用相对较左侧的元素样式，若属则采用相对较右侧的元素样式；垂直方向上：当两个单元格只存在颜色不一致的情况下，较靠近顶部的边框样式将被渲染；
四个角重合之处采用组合层叠的方式进行渲染，而不是单一的选择某一种样式而四条边框则非重合单一选择某一条边进行渲染
上面两个角中水平方向紧贴着边框的边很重要，如若为，则边框会，溢出垂直方向上不会发生溢出情况，溢出的边框不会占用文本流的空间

另外发现一些兼容性问题：

水平方向上：当两个单元格只存在颜色不一致的情况下，冲突边界渲染的样式与上设置该属性在有效，在其他浏览器上设置无任何效果有关。若属则采用相对较左侧的元素样式，若属则导致渲染失常无法解释
四个角重合之处采用组合层叠的方式进行渲染，而不是单一的选择某一种样式而四条边框则非重合单一选择某一条边进行渲染与
在下，四个角重合之处不会采用组合层叠的方式进行渲染，四个角重合之处渲染规则是采用垂直方向上的两个相邻单元格，相对偏下的单元格的冲突边进行渲染
在和下，和渲染是一样的，和渲染是一样的；
在下，当 与 冲突且在表格第一行发生冲突时， == ，  == ，当 与 冲突且在表格 非 第一行发生冲突时， == ， == 


表格行与列边框样式处理的实战应用
上面分享了一些实用表格时，常遇到的一些冲突；
下面内容是对上述文章中提到的一些知识点加以运用，用到具体的例子上。
采用表格布局最远可以追溯到上个世纪年代，当时使用进行布局是没有办法的办法。从以后以为主的网页布局慢慢的退出历史舞台，而采用现在为大家所熟悉的  的布局方式。
网页布局方式退出历史舞台并不等于也退出舞台，有它自身的好处。目前大家使用多数用于数据展示，数据展示必然会涉及到数据的对比，突出重点数据的需求。因此则产生了类似下图的展示样式。


看到这个视觉稿，想必大家第一反应是高亮列的实现方式应该是在上面添加高亮边框即可，没什么难度的。如果你这样认为那就错了。
在上面直接添加，会在造成左侧边缺失，具体原因可以参考，如果要在高亮列的单元格直接实现缺失的左边框采用行内样式或者加权重的方法，也是实现不了的，暂时是没有什么办法的。如果有请联系笔者。
如果你查阅了上面推荐的文章，那么你就知道产生这种现象的原因。
解决方法是在高亮列的前一列的右边框添加高亮边框。
看到解决方法有没有一种很蛋疼的感觉，高亮列产生的问题，要跑到高亮列的前一列去解决。
今天我就针对这一类的问题进行研究并提供相关解决方法
解决上面的问题很简单

公共 
{  }
{
     
     
     
     
     
     
}
  {
     
}
{
     
}
公共 
{
     
      
     
     
     
     
     
}
 
 {
     
     
     
       
}
  {
     
     
}
 {
      
     
}
   {
     
}

  
  {
       
}
  {
       
}

  {
     
     
}

 =
    
         =
         =
         =
    
    
        
            
                 =
                    优势
                
            
            
                 =
                    云服务器
                
            
            
                 =
                    传统服务器
                
            
        
    
    
        
            
                 =弹性
            
            
                 =弹性扩展，灵活配置
            
            
                 =运维困难
            
        
        
            
                 =可靠
            
            
                 =稳定可靠，数据放心
            
            
                 =系统脆弱，数据丢失
            
        
        
            
                 =易用
            
            
                 =即买即用，快速部署
            
            
                 =费心麻烦
            
        
        
            
                 =安全
            
            
                 =立体防护，专业支持
            
            
                 =黑客入侵
            
        

主要知识点

利用选择器选择高亮列行
当边框样式为实线时，运用优先级比高的特点，覆盖样式
运用或的视觉上与一样的特点
运用，，，， 之间渲染优先级的关系

实现是如此，那实现又如何呢

公共 
{  }
{ }
{
     
     
     
     
     
     
}
  {
     
}
{
     
}
公共 
 
 {
     
     
}
 {
       
       
}
  {
     
}
 {
     
}
 {
       
}
  
  
 {
       
}
  
  {
       
}
 {
       
}

 =
    
        
         =
        
        
            
                优势
                云服务器
                传统服务器
            
        
        
            
                弹性
                弹性扩展，灵活配置
                运维困难
            
            
                可靠
                稳定可靠，数据放心
                系统脆弱，数据丢失
            
            
                易用
                即买即用，快速部署
                费心麻烦
            
            
                安全
                立体防护，专业支持
                黑客入侵
            
        
    

 而在这个中最核心的知识点就是利用上设置的优先级较低的特点。平时经常听到人们说别乱点链接，小心有病毒。还有长辈们转发的“天呐的阴谋，全是病毒”、“惊天大病毒，点了苹果手机就要爆炸！”、“现在转发热门连接会乱扣费！千万别点！”。

到底长辈们说的这些是对的还是错的，是真的还是假的？下面我用通俗易懂的语言为大家剖析。
攻击就是假装你去行骗
首先我们说说  ，它的中文名称是跨站请求伪造，也被称为：   ，缩写为：。
简单地说，就是利用了我们的登录状态或者授权状态请注意“利用”，并没有窃取到，然后做一些损害我们自身利益的事情。
举个例子，使用我们微信头像和昵称，然后去跟咱爸妈要钱。“爸，生活费不够了。你打到账户上”，咱爸看见头像和昵称以为是亲生的，他就转账。如此，行骗成功。

方式造成的攻击
长辈们说得对，链接确实不能随便点。我用简单的代码举个例子。
信任的网站
假设我们有一个银行账户，其中有一个登录页面和付款页面，这些页面都属于我们信任的网站网站是虚拟的。
在中设置进行登录：

      
        {_}
在通过身份验证后进行扣款，但是必须输入收款人和扣款金额：

   身份验证
     _ || _  {  
         
    }
   金额获取   
     _ {
         
    }   
   收款人获取
     __ {
        
    }   
     = _ 
     = _
    _ = __
   此处应该还有相关操作，省去一万字
      {}   {_}
刷新一下，进行登录实际的用户登录更为复杂，这里进行简单模拟了

在浏览器访问页面，转钱元给妈妈。
=_=

黑客网站
这时候黑客发现网站没有做任何防御措施，他立刻在自己的网站上伪造了一个页面，页面上有这么一个链接，他的收款人_变成了。

    
         =
    
    
         ==_= =_震惊！！史上尺度最大的照片！！
     

假设因为好奇心点击了该连接：

这样就转了元给了

为什么会出现这种情况，我们在别的网站点击链接居然能扣自己账户的钱？点击链接前，我们已经登录了信任网站，而这个=_=这个连接是我们自己发送的，会识别当前已经登录，然后转账，网站无法判断到底是谁让我们点击的。
从上面这个实例可知完成攻击流程：
、用户登录了信任的网站，并且保存登录状态
、黑客找出网站没有防御的链接，通过社会工程学伪装，诱导点击。
、只要登录状态保持，用户主动访问目标链接，则攻击成功。
有人说那每次访问其他网站，把之前的网站都注销。是的，这个办法可以，但这么做这现实吗？我们需要注销许多常用的网站，下次登录又要输入用户名和密码，极其反人类。这肯定不是最佳办法，防御措施应该让程序员考虑，用户别乱点链接是最重要的。

的攻击渠道不一定来自其他网站，也可以是广告邮件、空间、微信、等社交媒体或软件。试想一下，如果你的女朋友知道这个链接，她在上发给你：
=_=你点击后，那就转了元给女朋友，假设她将改成，后果真的不敢想象，你居然存了这么私房钱，跪搓衣板吧，钱也都到了你女朋友账户上。
好了，小白用户看见这里可以关闭，别乱点链接就对，该给女朋友的钱的还是一分不能少。
也能造成攻击
上面的可以说相当危险，更新资源的操作不应该使用方式，方式只应该用于读操作。更新操作一定要使用方式，特别涉及到钱的问题。
然而方式可以解决大部分的问题，还有剩下少部分的聪明的黑客，一样能够模拟请求，伪造身份进行攻击。
假设 我们修改为取：

     _ {
         
    }   
     _ {
         
    }   
     __ {
        
    }   
     = _ 
     = _
    _ = __
        {
          {}   {_}
    }
访问=_=，提示没有

但是道高一尺魔高一丈，聪明的黑客也改进了代码，使用提交，并且改为：

    
         =
    
    
         = =
             = = =
             = =_ =
             = =点击中大奖
        
     

点击中大奖，如下又转了元给女朋友：

抓包结果如下，可以看到 =和=_=都已发送过去。
  
 
 
 =

=_=
如此一来，不管哪种访问方式都可能受到攻击。所以，这并不是和谁更安全的问题，只是提高了攻击门槛和成本其实也就多几行和。
划重点，那么能够攻击的根本原因是：服务器无法识别你的来源是否可靠。
防御的思想
那么防御的方法有很多：
、比如加上验证码。但这么做很繁琐，并且影响用户体验。
、比如转账需要二次密码验证，现在很多银行就这么搞的。
、确认来源是否可靠推荐
不管防御方法还是，都是让用户自身再次确认授权。
这种安全防范的事儿，更应该由程序验证。
根据验证是否可靠性思路，可以有以下几种方法：
验证  字段
协议里面定义了一个访问来源的字段，这个字段叫。黑客伪造的链接或表单是在其他网站上，所以我们可以判断是否为自身网站，如果是，则允许访问，如果不是，则拒绝访问。
从我们的网站访问抓包发现是不存在的
_=
从黑客的网站访问，抓包发现来自黑客网站
_=  
然后代码里判断：

  _=  {
    可能是攻击，拒绝访问
}  {
    允许访问
}
所以我们只需要拦截就可以判断是否为攻击。
但是这种方法是有缺陷的，上面实验尝试过，如果对方在上发送给你一个链接呢？点击的时候属于主动点击，此时一样没有。程序会把它归属为安全请求，那么就被绕过了。并且如果某些低版本的浏览器存在漏洞比如，很有可能被篡改，所以这个方法并非十全十美。
服务端验证请求的一致性
攻击的核心原理就是利用用户验证信息储存中，发送请求，使得服务器无法判断真伪，而之所以能够拦截，就是因为它是攻击过程中几乎不可能伪造的东西。
实现原理：在服务端生成一个随机的，加入到请求参数中，服务器拦截请求，查看发送的和服务端的是否一致，若一致，则允许请求；若不一致，则拒绝请求。
新增表单页面，将存入不要存在中，你懂的：

_
_ = ___生成随机
_= _

 
 =

     =
    


    转账
     = =
         = =
        _ = =_
         = = =  _ 
         = =
    


在获取，与中存储的判断是否一致：

    _
      _ {
         
    }   
      _ {
         
    }   
      __ {
        
    }   
      _ || _ =  _ {
        
    }   
     = _ 
     = _
    _ = __

        {
          {}   {_}
    }
查看页面：

请求成功：

每次访问表单页面，都应该生成一个：
 = = =
我们再尝试从黑客网站进行访问，显示””证明在验证时被拦截：

这样子就已经有效防御攻击。该方法可以用于链接和表单等请求，属于同一个原理。
注意：网上很多文章并没有生成唯一的或者随机性较大的，都是同一个，这是有问题的，如果黑客看到该，一样可以伪造请求，进行攻击。
防御
实际上 防御的思想也可以利用上面的验证方式。
在上看过一篇文章说防御时，在  头中自定义属性并验证。
它是这么说的：

把  以参数的形式置于  请求之中，而是把它放到  头中自定义的属性里。通过  这个类，可以一次性给所有该类请求加上  这个  头属性，并把  值放入其中。这样解决了上种方法在请求中加入  的不便，同时，通过  请求的地址不会被记录到浏览器的地址栏，也不用担心  会透过  泄露到其他网站中去。

个人觉得不需要如此麻烦，易用性也不太好，直接对进行一次封装，加入一个_的选项，就把也发送过去，否则不进行验证，原理和上面是一样的。
最好将赋值给的一个全局变量，整个网站都可以使用。
总结
防御原则：

方式不能用于更新资源的操作

方式请求加上随机验证


 年的十大安全威胁已经公布了我们可以看看年和年稳稳排在第八位。

总之，是一种常见的安全威胁，它攻击特点是利用用户身份信息伪装，发送请求，造成危害。这种攻击成本极低，但网站和用户不注意，很容易受到伤害。当然，更令人欣赏的是黑客利用社会工程学欺骗大众，这才是最重要的。
如果大家对社会工程学感兴趣，推荐一部电影——《我是谁：没有绝对安全的系统》，非常精彩。

互联网安全你攻我防，你枪我盾，没有永远灵验的方法，只有学会攻击，才能抵御攻击。每天分钟，用去食堂吃饭的时间解决一个知识点。

存储介质
数据库系统涉及的存储介质中，有代表性的有以下几种：

高速缓存最快，也最贵。我们在使用的过程中一般接触不到，但数据库的实现者在设计数据结构和算法时还是会考虑的影响的。嗯，写到这里，不由地端起茶杯，抿了一口水。

主存 

闪存 现在主要是用在上。提升随机读写的性能。

磁盘我们一般进行的讨论中，都是默认数据放在磁盘上。而磁盘与主存之间，是以块为单位交换数据的。优化查询，就是要优化块数，即磁盘的次数。而进一步细化的话，磁盘的访问时间由三部分组成：寻道时间，旋转时间，传输时间。


磁盘可以通过，或口连接到计算机，也可以通过网络与磁盘控制器相连，即我们常提到的和。

的指导思想就是两条：通过冗余提高可靠性，通过并行提高性能。说到这再岔开一句，其实我们在计算机很多领域都会发现，可靠性都是靠冗余来保证的，而冗余又会带来一致性等问题，针对新的问题，不同的思路会得到各自的方案，我觉得抓住这条主线会有助于我们的学习。
回到正题，我直接画一张不同级别的图吧：

也有厂商使用 或者 这样的说法，和这里不是同一个术语版本，大家不要混淆就可以了。
缓冲区
我们一直在说，数据库要尽量减少磁盘和主存间传输的的数目。这也是学习数据库的一条主线。那么，很自然的一个想法就是，我保存尽量多的在主存中，这样访问时再去磁盘上交换的几率不就降低了嘛。而主存中用于存储磁盘块的拷贝的地方，就叫做缓冲区。但是主存比磁盘小得多，所以中内容如何管理，是数据库中很重要也很有的内容。
比如快满时如何替换，经典的算法我们很容易就会想到，但就在的基础上又加了一个因子，避免全表扫描对替换的影响。
相关阅读十分钟入门关系型数据库一：三范式分钟梳理关系数据库基础知识三：树分钟梳理关系数据库基础知识四：两阶段多路归并排序分钟梳理关系数据库基础知识五：查询优化与连接算法感谢阅读腾讯 微信号第篇文章。本文介绍了我们在图像描述生成与等技术跨界的前沿研究进展，并邀请大家测试一个趣味。我们还会分享在多媒体内容应用上一点思考。

年月，在图像描述生成技术这一计算机视觉与交叉研究领域，腾讯 凭借自主研发的强化学习算法在微软 相关的类别挑战赛上排名第一，超过了微软、谷歌、等参赛公司，体现了在这一前沿领域的技术优势。


微软 也称常见物体图像识别数据集，对图像的标注信息包括类别、位置和图像语义文本描述等，该数据集的开源使近两三年来图像分割语义理解取得了巨大进展，几乎成为图像语义理解算法性能评价的「标准」数据集。链接：

团队特别制作了「把照片唱给你听」体验，将图像描述生成技术与文本转语音  ，简称两大技术结合，希望以更轻松的方式让大众了解机器「视觉能力」提升的一小步。上传到张图片后，会生成相关的文字描述并匹配韵脚歌词，再通过合成语音配合旋律出来。


上传吃喝玩乐国庆美图时，唱出来是这样的



上传不太正常的图片时，可能会被被网友的脑洞玩坏 _||

现在，我们将邀请位「首席体验官」优先测试。如果你有相关技术背景，或图片视频制作经验，将有机会优先体验。请留下评论，回复您的姓名邮箱所属公司职业，如：王小明腾讯设计，我们将稍后通知测试方法。
 第 一 步：让 机 器 看 图 写 词
详 解 图 像 描 述 生 成 技 术
中机器「写」出的歌词，其实是给图片配上一句话说明，也被称为图像描述生成。这是一个跨模态研究方向，机器不仅要理解图像内容，还要学习和组织语句，给出通顺并符合人类语义习惯的表述。
图像描述生成是一个让机器学会深度理解图片内容的技术。以前，机器只能识别图片里出现的是一只狗，而不是猫；现在，机器不仅识别出狗，说出它的颜色甚至种类，甚至能理解它所处的环境和与其他物体的关系，这体现了机器「视觉能力」的进步。


从简单的图片分类到生成复杂的文字描述，机器用了多年

在一个三岁儿童的眼里，这可能是个很简单的任务。但机器走到这一步，花费了几十年的时间。尽管如此，机器在理解更复杂的图像内容时，恐怕依旧赶不上三岁小孩。但我们相信，机器前进的每一小步，都体现出人类智慧的一大步。
中使用的是我们全新设计的图像描述模型，采用端到端编码器解码器模型。这个过程可以用下面的图片表示出来：给定一张图片，用卷积神经网络为图片编码，得到全局或局部的图片表示；用长短时记忆模型解码上述的图片表示，转换为一句话的文字说明。解码过程中创新采用了注意力模型  捕捉到了每个单词生成时，不同局部信息的贡献程度，通过引入不同级注意力模型，更加充分的挖掘在产生每一个单词的过程中的图像的全局和局部信息的贡献；而整个深度网络模型得到了强化学习的充分训练，从而产生更加流畅的自然语句描述图像内容。


采用的全新图像描述模型

在研究上，这个技术能同时推进对图像和自然语言间单学科到跨学科的理解、分析与运用。而应用上，它的前景非常值得期待。互联网上几乎大部分数据都以图像文本的多模态方式存在，仅以腾讯产品为例，从微信朋友圈、空间图片到天天快报的新闻，都是图像与文本强相关的素材，这之间的深度关系挖掘，能促进更强的内容理解，进而提供更好的产品体验。比如能为相册照片自动生成丰富的描述，可进一步提升图片的分类、搜索和推荐质量；用于图像文本对话系统中，可为图片生成更相关的评论，或直接做「斗图」这样的趣味图像对话；与语音技术结合时，能帮助幼儿或视觉障碍人群更好地理解图像内容。
 第 二 步：让 机 器 看 字 说 话
聊 聊 文 本 转 语 音 技 术 
机器「唱」给你听的，正是将文字转为语音的合成声音。语音合成 或文本转语音技术，是这类语音助手不可或缺的一部分，也被广泛应用到游戏、读书及娱乐等领域。
我们使用了商业产品中最常见的参数合成技术，提供了清晰可理解、自然流畅的语音。这背后是大量的工作，第一步是录制专业播音人才近小时语料；因为不可能录制人的每一句话，第二步里机器要将语音切片成音素，最后使用深度学习对音素的的声学特征与时长建模。
目前我们还在进一步研究语料库较小、低占用的参数合成技术，并考虑将单元选择的高品质和参数合成的灵活性优势结合。
让 内 容 与  做 加 法
机 器 对 文 字、图 像 与 视 频 施 魔 法
结合腾讯内容产品上的独特优势，针对图像、视频、新闻与文学等领域的「内容」一直是腾讯 的四大应用方向之一。
针对图像、视频和文本等多媒体内容，我们不断进行探索与尝试，并在基础图像识别领域，如人脸检测、人脸识别及方面有很大突破，更多细节将在月日在成都举办的腾讯全球合作伙伴大会点链接上分享，敬请期待。


原文来自：腾讯实验室 公众号麒麟由腾讯安全反诈骗实验室研发，是平台里的一个重要的应用服务，它创新地利用大数据，实时定位全国的伪基站传播轨迹。通过地图，从空间、时间维度，直观的呈现伪基站的聚类的传播区域和实时运动轨迹，为警方打压短信诈骗犯罪，提供帮助。
什么是伪基站？
想要了解麒麟，我们需先了解伪基站工作原理，那我们就从一张很常见的短信截图开始。图：伪基站发送的诈骗信息
上图的信息就是我们在新闻中经常听说的伪基站发出的。伪基站是通过利用网络单向认证的弱点，骗取手机的连接，向手机发送信息，拦截通话。伪基站诈骗信息不仅让用户损失钱财，更有甚者，通过伪基站可以偷听用户的通讯信息，对于用户的隐私和安全带来了极大的隐患。
伪基站是怎样群发诈骗信息的？
伪基站一般由这三个部分组成：

一个无线发送器
一台笔记本用于控制发送器
一部工程机用于搜索附近的合法基站，并获取其配置信息

图：伪基站构成想要预防伪基站的危害，首先要了解伪基站的原理。发送垃圾或诈骗短信时，伪基站一般执行以下步骤：用工程机获取附近合法基站的配置信息基站的频率、、信号强度通过控制笔记本，给伪基站的无线发送器配置不同的参数。配置相同的频率或者另外一个频率，设置一个不同的尤其保证不同，设置一个更大的信号强度附近用户的手机在检测到伪基站之后，由于其功率更高，并且不同代表一个不同的位置码，从而很可能连接到伪基站。因为伪基站的变更，尤其是表示位置区域的变更了，导致用户手机向伪基站发送位置更新请求。伪基站向用户手机发送身份认证请求，以获取其和 。伪基站向用户手机发送垃圾或诈骗短信。伪基站中断和用户手机的连接。用户手机自动恢复到合法基站的连接。 
图：伪基站框架示例
如何检测伪基站？

伪基站的检测大致分为几个流派：物理派：基于信号采集器，伪基站探测车或电子围栏等。考虑到伪基站的移动性，以及方案中的硬件的需要，这种方式运行成本很高。不过，如果发挥想象力，借助共享经济还是可能有新突破的。比如利用顺风车或者共享单车这类来做点采集，不过硬件成本会有些高昂。可以参考：

用户举报派：发挥朝阳群众的智慧，请用户来举报。覆盖率和及时性方面很难保障。

大数据派：运营商通过对基站数据进行细粒度的分析，或者拥有庞大用户的安全软件：利用手机终端采集数据通过大数据的方式来实现检测。性价比方面会更好一些。
终端派：利用手机芯片或者终端软件厂商，对于收到的基站信息进行数据分析，从而实现伪基站的检测。终端派的优势就在于成本低，更加实时，对位置判断更加精准。以腾讯的麒麟伪基站实时发现系统为例，定位精度在米以内，准确率高达。图：麒麟伪基站定位系统上图为腾讯的麒麟，利用可视化技术从空间、时间维度直观呈现伪基站聚类传播区域和实时运动轨迹，大大提高警方的抓捕效率。图：麒麟的全国伪基站实时分布麒麟落地全国城市，总体伪基站诈骗案下降，年和深圳警方首次合作就把伪基站发案率降低了，其实，目前深圳地区伪基站数量已经降到基本为。
目前为了方便出警，麒麟还完善了微信追踪功能：
通过微信，可发送伪基站路径给远程实施抓捕工作的同事，大大提高警方发现、抓捕伪基站犯罪团伙的效率。感谢阅读腾讯 微信号第二篇文章，我们将深度解析本届热门研究。第一部分是五大前沿领域的重点文章解析，包括低中层视觉、图像描述生成、视觉、计算机视觉与机器学习、弱监督下的图像识别等。第二部分是及我们计算机视觉团队简介等。接下来的两篇文章中，我们将对顶级会议和做类似深度解读，敬请期待。

腾讯 去年四月成立，今年是首次参展，共计六篇文章被录取详情见文末，由计算机视觉总监刘威博士带队到现场交流学习。


腾讯 展台及科学家在环节介绍论文
从研究领域和前沿思考出发，我们重点关注了五大领域的前沿研究，以下为重点论文评述。
一、低中层视觉问题
   
在计算机视觉领域里，低中层视觉问题更关注原始视觉信号，与语义信息的联系相对松散，同时也是许多高层视觉问题的预处理步骤。本届有关低中层视觉问题的论文有很多，涵盖去模糊、超分辨率、物体分割、色彩恒定性 等多个方面，方法仍以深度学习为主。
其中在超分辨率有关的工作中，较为值得关注来自的等人所著文章。这是第一篇将生成对抗网络  ，简称思想用于图像超分辨率的研究具体结构见下图。以前的超分辨率方法，大都使用平均平方误差  ，简称导出的损失函数，直接最小化 虽能得到不错的超分辨率结果，但难以避免细节上的模糊，这是本身设计问题导致的。             á        
虽然后来阿斯利康测序机构的与斯坦福大学的等人在 时中提出使用 替代 ，获得了细节更丰富的超分辨率结果，但仍然有进步的空间。而等人的这篇论文在 基础上加入 ，约束超分辨率结果需符合自然图像分布规律，使超分辨率结果获得了非常逼真的细节效果。此方法也并非全无缺点，由于 考虑的是自然图像的整体分布，与具体输入图像即测试图像无关，因此恢复的图像细节可能并不忠实于原图，类似「捏造」出假细节，因此不适用于一些追求细节真实性的应用。                    使用 生成的结果黄色方框能够落在自然图像分布上红色方框集合。 虽能获得平均意义上的最小误差蓝色方框，但却没落在自然图像分布上红色方框的集合，因而丢失了很多图像细节。
未来，将 引入到视频超分辨率的解决方案中是一个很自然的扩展，相信很快会有研究工作出现。值得一提的是，的这批研究人员在本届还有一篇关于视频超分辨率的论文，虽未引入 ，但通过更好帧间对齐方法提升了视频超分辨率的可视化效果。                      
二、图像视频描述生成
   
粗略统计，本届有篇视觉描述生成相关论文，其中有篇图像描述生成相关论文，其他论文多集中在视频描述生成方向。我们重点关注了其中几个较有代表性的研究：
          这篇论文由腾讯 和浙江大学等机构合作完成，主要讨论了视觉注意力模型在空间与通道上的作用。该模型能动态提取随时间变化的上下文注意力信息。传统的注意力模型通常是针对空间设计的，例如在产生图像的描述的过程中，模型的注意力模型会注意图像的不同区域。但会忽略中的通道和多层中的信息。这篇论文提出了一个全新模型，可针对中的空间和通道信息设计新的注意力模型。在图像描述生成任务中，该模型表现出了良好性能。
      研究院发表的这篇论文直接优化了评价标准   。由于此目标函数不可微，论文中借鉴基础的强化学习算法 来训练网络。 该文提出了一个新的算法  ，将贪婪搜索  结果作为  算法中的基线，而不需要用另一个网络来估计基线的值。这样的基线设置会迫使采样结果能接近贪婪搜索结果。在测试阶段，可直接用贪婪搜索产生图像描述，而不需要更费时的集束搜索又名定向搜索， 。除了，此论文也改进了传统编码器解码器框架中的解码器单元，基于网络，作者改进了及带注意力机制的。综合这两个改进，作者提出的方法在微软的图像描述挑战赛   占据榜首长达五个月，但目前已被其他方法超越。
       由与谷歌合作的这篇论文也使用强化学习训练图像描述生成网络，并采用框架。此论文通过一个策略网络 和价值网络 相互协作产生相应图像描述语句。策略网络评估当前状态产生下一个单词分布，价值网络评价在当前状态下全局可能的扩展结果。这篇论文没有用或指标作为目标函数，而是用新的视觉语义嵌入定义的，该奖励由另一个基于神经网络的模型完成，能衡量图像和已产生文本间的相似度。在 数据集上取得了不错效果。
            弗吉尼亚理工大学和乔治亚理工大学合作的这篇论文主要讨论自适应的注意力机制在图像描述生成中的应用。在产生描述语句的过程中，对某些特定单词，如或等，不需要参考图像信息；对一些词组中的单词，用语言模型就能很好产生相应单词。因此该文提出了带有视觉哨卡 的自适应注意力模型，在产生每一个单词的时，由注意力模型决定是注意图像数据还是视觉哨卡。
在图像描述生成方面，本届还有很多其他方面的研究工作。包括在《         》中，微软亚洲研究院将复制功能 引入图像描述生成学习新物体，《          》一文用记忆网络 来定制个性化的图像描述生成。
近年来，由于视频数据大大丰富，也有一系列的工作讨论视频描述生成，包括复旦大学与英特尔合作的《    》，和杜克大学与微软合作的《     》等。
三、计算机视觉
  
近年来，计算机视觉快速发展，被广泛应用在无人驾驶、或等领域。在本届，该研究方向亦受到广泛关注，并体现出两大特点：一方面其在传统多视图几何如三维重建等问题上有所突破，另一方面它也和现今研究热点，如深度强化学习等领域紧密结合。我们将对以下两个方向做进一步介绍：
               这篇论文为腾讯 、约翰霍普金斯大学及加州大学洛杉矶分校合作发表，作者主要讨论从二维图像中进行人造物体如汽车、飞机等的三维结构重建问题。事实上，绝大多数人造物体都有对称性以及曼哈顿结构，后者表示我们可以很容易在欲重建的人造物体上找到三个两两垂直的轴。如在汽车上，这三个轴可为两个前轮、两个左轮及门框边缘。作者首先讨论了基于单张图片的物体三维结构重建，并证明了仅用曼哈顿结构信息即可恢复图像的摄像机矩阵；然后结合对称性约束，可唯一地重建物体的三维结构，部分结果如下图所示。
然而，在单张图像重建中，遮挡和噪声等因素会对重建结果造成很大影响。所以论文后半部分转到了多张图像基于运动恢复结构   简称及对称信息的物体三维重建中。事实上，算法涉及到对二维特征点进行矩阵分解，而添加对称性约束后，我们并不能直接对两个对称的二维特征点矩阵直接进行矩阵分解，因为这样不能保证矩阵分解得到同样的摄像机矩阵以及对称的三维特征点坐标。在文章中，作者通过进一步利用对称性信息进行坐标轴旋转解决了这个问题。实验证明，该方法的物体三维结构重建及摄像机角度估计均超出了之前的最好结果。
         本文由德国德累斯顿工业大学 与微软联合发表，主要通过强化学习估计物体姿态。传统姿态估计系统首先对物体姿态生成一个姿态假设池    ，接着通过一个预先训练好的卷积神经网络计算假设池中所有姿态假设得分，然后选出假设池中的一个姿态假设子集，作为新假设池进行。以上过程迭代，最后返回得分最高的假设姿态作为姿态估计的结果。
但传统方法对姿态假设池的步骤非常耗时，如何选择一个较好姿态假设子集作为姿态假设池就变得尤为重要。本文作者提出了一同基于策略梯度的强化学习算法来解决这个问题。该强化学习算法通过一个不可微的奖励函数来训练一个，使其选取较好的姿态假设，而不是对姿态假设池中的所有姿态进行。
强化学习的步骤如上图所示。首先给强化学习输入一个较大初始姿态假设池，然后该通过对其策略采样，选择一个新的强化学习池，并对其进行。上述过程达到一定次数后，最后求得的姿态假设池中得分最高的姿态假设即为所求得姿态。实验表明该方法在大大提高运行速度时，还得到超出此前最佳算法的估计结果。
四、计算机视觉与机器学习
    
计算机视觉与机器学习历来联系紧密，随着深度学习近年来在视觉领域取得的空前成功，机器学习更是受到更广泛的重视。作为机器学习一个分支，深度学习依然是计算机视觉领域绝对主流。但与前几年不同的是，纯粹用深度学习模型「单打独斗」解决某个视觉问题似乎不再流行。
从近两届论文看，深度学习模型与其它传统的机器学习分支模型的融合渐成趋势，既利用深度学习模型的优异性能，又利用传统模型的成熟理论基础，取长补短，进一步提高性能并增加了深度学习模型透明度。本届上这种融合趋势可分为两个具体方向：一个是传统机器学习模型方法与深度学习模型深度融合，让后者能设计更好模型；另一个是用传统机器学习理论解释或阐述深度学习模型性能。我们关注到相关的重点论文如下：
一、传统机器学习模型方法与深度学习模型深度融合
         矩阵的低秩稀疏分解是经典机器学习方法，假设一个大规模矩阵可分解为两个或多个低维度矩阵的乘积与一个稀疏矩阵的和，从而大大降低原矩阵表示元素个数。在这篇由优必选悉尼研究所、新加坡理工大学和悉尼大学共同完成的论文中，该方法被用来模拟深度学习的滤波参数矩阵，在保证模型性能同时，大大降低了参数个数，这对深度学习模型的进一步推广，尤其是智能手机端应用会有很大推动作用。类似文章还有杜克大学的这篇。           
 –      领域自适应 是迁移学习 的一种，思路是将不同领域如两个不同的数据集的数据特征映射到同一个特征空间，这样可利用其它领域数据来增强目标领域训练。深度学习模型训练需要大规模数据，这篇由谷歌发表的文章，提出的思路是对真实物体进行渲染，制造大量人造渲染图像，从而帮助深度学习模型训练。
然而，渲染图像与真实图像之间有很大差异比如背景差异，直接用渲染图像训练得到的深度学习模型并没有产生很好识别性能。本文将渲染图像和真实图像看作两个领域，并结合当前流行的生成对抗网络修正渲染图像，得到更加贴近真实图像的渲染图像如下图所示：加上类似的背景。最后再利用这些修正后的渲染图像训练深度学习模型，取得了很好效果。
二、传统机器学习理论解释或阐述深度学习模型性能
  在现有研究和实际应用中，深度学习模型被观察到对样本噪声或扰动比较敏感，比如在原始图像上加一些很小的噪声或变形，都可能造成误分类。但对什么类型、多大幅度的噪声或扰动会引起这种错误，我们还知之甚少。洛桑联邦理工大学和加州大学洛杉矶分校合作的这篇论文对此问题进行了初步探索。
文章基本思想是围绕机器学习中的分类边界和间隔，在原始图像特征空间中计算出一个最小扰动向量，使原始图像跨过分类边界造成误分类。计算得到的这个最小扰动向量被称为通用扰动向量，因为该向量值与模型相关并与具体的图像独立。作者分析了、和等多个主流深度学习模型，发现其对于相对应的通用扰动向量非常敏感。这项研究对了解深度学习模型的分类边界和模型鲁棒性有很大帮助。
     常用深度学习网络中，往往会用到很多非线性函数，如激励函数和激活函数等，所以整个网络可被看做是一个非线性复合映射函数。这样的函数很大可能是非凸函数，在优化过程中存在很多局部最优解，增加了模型训练难度。但约翰霍普金斯大学的这篇论文证明，在网络构成函数满足一定假设时，能保证得到全局最优解。背后原理是使整个网络的搜索空间只包含全局最优解和平台解，而不存在局部最优解如下图所示。
该文的证明运用了机器学习中的矩阵分解和对应的优化理论。这项研究工作展示了全局最优解在深度神经网络中存在的条件，为我们设计更加容易训练的模型提供了有价值的指导。
五、弱监督下的图像识别
  
深度学习成功的一大关键因素是大量训练数据，但现实场景中对海量数据作精细数据标注需要大量人力和财力，这就回到了计算机视觉中的基本问题：目标检测  和语义分割 。本届也有论文关注弱监督下该问题的解决，我们将介绍两篇仅依赖图像级别标注的相关研究。
       这篇最具代表性的目标检测论文由腾讯 和新加坡国立大学合作完成。在检测器训练时，该文提出了一种依靠检测器模型自主动态挖掘高质量正例样本的方法。鉴于检测器有强大的拟合训练样本能力，错误训练样本  同样能获得较高类别置信度。但当检测器训练其它正例样本时，错误训练样本获得的类别置信度增量    较小，因此当检测器在训练其它样本时，一个 获得的类别置信度增量大小可有效反映该样本的真实质量  或 。依赖类别置信度增量动态挖掘高质量训练样本，可有效增强检测器性能。 该文在  和目标检测任务上取得了目前最先进的效果。
            这篇有代表性的语义分割论文来自新加坡国立大学，提出了用分类网络解决语义分割的新方法。分类网络能提供目标物体的显著区域  ，但语义分割要求对目标物体全部像素的精确预测，该文利用了一种逐步擦除显著区域方法，不断提高分类网络预测难度。当擦除显著区域和重新训练分类网络交替，按从主要到次要的顺序逐渐获得目标物体全部区域，训练出一个高性能语义分割网络模型。该方法在  和语义分割问题上取得了目前最佳效果。
一分钟数读
是近十年来计算机视觉领域全球最有影响力、内容最全面的顶级学术会议，由全球最大的非营利性专业技术学会电气和电子工程师协会主办。今年会议于月日至日在美国夏威夷举行。
在评估会议的学术影响力指标上，本次会议均创新高 —— 论文有效提交数为篇↑、录取数为篇↑、注册参会人数人↑，并在新发布的谷歌学术指标中，成为计算机视觉与模式识别领域影响力最大的论文发布平台。
在产业影响力指标上，会议赞助金额近万美元↑，赞助商高达家↑，囊括了、及腾讯等科技巨头，也有商汤、旷视等众多初创企业。
录取论文涉及领域占比最高的五类是：计算机视觉中的机器学习、物体识别和场景理解、视觉、低级和中级视觉、分析图像中的人类。
大会共设个研讨会、个教程辅导和场竞赛，覆盖语言学、生物学、建模和自动驾驶等计算机视觉的细分领域。
现场论文展示分三种形式：分钟长演讲分钟短演讲和论文海报展示，长短演讲共场，海报展示个。在参会心得上，我们建议重点参加口述演讲，会对精选文章做长或短的进一步解读；而海报展示数量多、内容杂，只在固定时段有，要用好地图和会程指引，有选择地、集中地参加此环节。展会区囊括各类企业，会从研究到应用进行展示讲解，可选择性参加。
关于腾讯 及其计算机视觉团队
腾讯 成立于年月，专注于机器学习、计算机视觉、语音识别和自然语言理解四个领域「基础研究」，及内容、游戏、社交和平台工具型四大「应用探索」，提升的决策、理解及创造力，向「  」的愿景迈进。
腾讯 主任及第一负责人是机器学习和大数据专家张潼博士详情可点链接，副主任及西雅图实验室负责人是语音识别及深度学习专家俞栋博士。目前团队共有余位科学家及多位应用工程师。
计算机视觉团队团队是最早组建的研究团队之一，目前有十多位基础研究科学家，大多拥有国内外院校博士学位，并与一个较大的应用工程师团队紧密合作，由计算机视觉和机器学习专家刘威博士领导。我们很注重对青年研究者的培养，团队中应届毕业的博士接近半数，也将继续在海内外招募不同级别的优秀研究者。
在基础和前沿研究方向上，团队聚焦中高层视觉，尤其视频等可视结构数据的深度理解，同时也在重要的交叉领域发力，如视觉、视觉信息检索等。正在进行或计划中的研究项目兼具了挑战性和趣味性，包括超大规模图像分类、视频编辑与生成、时序数据建模和增强现实，这些项目吸引了哥伦比亚和清华等海内外知名大学的优秀实习生参与。
团队在本届上有六篇文章被录取，下面论文一提到的实时视频滤镜技术已在腾讯手机版上线，实现了基础研究到产品应用的迅速转化，正是我们「学术有影响，工业有产出」目标的体现。
腾讯 共六篇论文入选本届
论文一：      本文用深度前向卷积神经网络探索视频艺术风格的快速迁移，提出了一种全新两帧协同训练机制，能保持视频时域一致性并消除闪烁跳动瑕疵，确保视频风格迁移实时、高质、高效完成。
论文二：        论文首次提出一种全尺寸、无标注、基于病理图片的病人生存有效预测方法，在肺癌和脑癌两类癌症的三个不同数据库上性能均超出基于小块图像方法，有力支持大数据时代的精准个性化医疗。
论文三：          针对图像描述生成任务，基于卷积网络的多层特征来动态生成文本描述，进而建模文本生成过程中空间及通道上的注意力模型。
论文四：       本文提出依靠检测器自身不断改进训练样本质量，不断增强检测器性能的一种全新方法，破解弱监督目标检测问题中训练样本质量低的瓶颈。
论文五：  本文提出了一种新的自动图像标注目标，即用少量多样性标签表达尽量多的图像信息，该目标充分利用标签之间的语义关系，使得自动标注结果与人类标注更加接近。
论文六：              基于曼哈顿结构与对称信息，文中提出了单张图像三维重建及多张图像  三维重建的新方法。

文章来源腾讯实验室_世界主流的天文机构竟然同时闹炸锅，人类有史以来第一次观测到了由两颗中子星合并产生的引力波，并“看到”了这一宇宙事件发出的强电磁信号。
 两颗中子星合并产生引力波
有人发问：引力波来了，外星人还远吗？可是说真的，看完这么牛逼而壮观的宇宙引力波后，除了外星人，你就没想过，引力波现象到底是怎么被观测到的么？

今天小编就拿出真本事带你来见识一下！首先普及一下，这样的天文观测背后，其实是庞大的数据运算处理能力在支撑，是超级计算机干的活。所以这就不难理解为什么中美这样的大国在拼命发展超级计算机了。
 无比强大的超级计算机
有些小伙伴说，超级计算这么高大上，离我们那么远，我关心它干啥？这么想，你可就了。超算早就已经深入我们生活的方方面面，每晚分左右，央视新闻频道的《天气预报》，那可是多种公式、参数和时效要求相加的大难题，你一定不知道那是神奇的超算在背后秒速运作出来的吧！
 
电影《阿凡达》也是因为这神奇的超算，特效渲染才无需等待年！
 电影阿凡达极致特效
人脸识别、基因测序要是没有超算，脑细胞怎么分裂都不够用吧！
：以上的图片均来源于网络
总之，超级计算真的超级厉害有木有！想不想亲自见识一下它的超级之处？赶紧关注下述头条新闻：腾讯云即将在月日至日举办的合肥 大会上发布杀手级产品——腾讯超算云，各行各业从此在云上就能“一键”打造属于自己的超算中心。想抓住机会让企业产品做得更好、市场做得更精准的伙伴，想了解更多关于腾讯超算云信息的伙伴，还等什么呢？赶快参会，一起见证这个历史时刻吧！导语：卷积神经网络日益增长的深度和尺寸为深度学习在移动端的部署带来了巨大的挑战，模型压缩与加速成为了学术界和工业界都重点关注的研究领域之一。

前言
自从一举夺得  图像分类竞赛的冠军后，卷积神经网络的热潮便席卷了整个计算机视觉领域。模型火速替代了传统人工设计特征和分类器，不仅提供了一种端到端的处理方法，还大幅度地刷新了各个图像竞赛任务的精度，更甚者超越了人眼的精度人脸识别任务。模型在不断逼近计算机视觉任务的精度极限的同时，其深度和尺寸也在成倍增长。
表 几种经典模型的尺寸，计算量和参数数量对比




 































随之而来的是一个很尴尬的场景：如此巨大的模型只能在有限的平台下使用，根本无法移植到移动端和嵌入式芯片当中。就算想通过网络传输，但较高的带宽占用也让很多用户望而生畏。另一方面，大尺寸的模型也对设备功耗和运行速度带来了巨大的挑战。因此这样的模型距离实用还有一段距离。
在这样的情形下，模型小型化与加速成了亟待解决的问题。其实早期就有学者提出了一系列模型压缩方法，包括权值剪值和矩阵分解等，但压缩率和效率还远不能令人满意。
近年来，关于模型小型化的算法从压缩角度上可以大致分为两类：从模型权重数值角度压缩和从网络架构角度压缩。另一方面，从兼顾计算速度方面，又可以划分为：仅压缩尺寸和压缩尺寸的同时提升速度。
本文主要讨论如下几篇代表性的文章和方法，包括、 、、、和，也可按照上述方法进行大致分类：
表 几种经典压缩方法及对比




 
 









 

























一、
 设计思想
是  等人于年的论文《           》中提出的一个小型化的网络模型结构，该网络能在保证不损失精度的同时，将原始压缩至原来的倍左右 。
的核心指导思想是——在保证精度的同时使用最少的参数。
而这也是所有模型压缩方法的一个终极目标。
基于这个思想，提出了点网络结构设计策略：
策略 将卷积核替换为卷积核。
这一策略很好理解，因为个卷积核的参数是卷积核参数的，这一改动理论上可以将模型尺寸压缩倍。
策略 减小输入到卷积核的输入通道数。
我们知道，对于一个采用卷积核的卷积层，该层所有卷积参数的数量不考虑偏置为：

式中，是卷积核的数量，也即输出通道数，是输入通道数。
因此，为了保证减小网络参数，不仅仅需要减少卷积核的数量，还需减少输入到卷积核的输入通道数量，即式中的数量。
策略 尽可能的将降采样放在网络后面的层中。
在卷积神经网络中，每层输出的特征图 是否下采样是由卷积层的步长或者池化层决定的。而一个重要的观点是：分辨率越大的特征图延迟降采样可以带来更高的分类精度，而这一观点从直觉上也可以很好理解，因为分辨率越大的输入能够提供的信息就越多。
上述三个策略中，前两个策略都是针对如何降低参数数量而设计的，最后一个旨在最大化网络精度。
 网络架构
基于以上三个策略，作者提出了一个类似的网络单元结构，取名为 。一个  包含一个 卷积层只包含卷积核和一个卷积层包含和卷积核。其中，层借鉴了的思想，利用卷积核来降低输入到层中卷积核的输入通道数。如图所示。

图  结构示意图
其中，定义层中卷积核的数量是，类似的，层中卷积核的数量是， 卷积核的数量是。令   从而保证输入到的输入通道数减小。的网络结构由若干个   组成，另外文章还给出了一些架构设计上的细节：

为了保证卷积核和卷积核具有相同大小的输出，卷积核采用像素的和步长
层和层均采用作为激活函数
在后采用的
由于全连接层的参数数量巨大，因此借鉴的思想，去除了全连接层而改用  。 

 实验结果
表 不同压缩方法在上的对比实验结果

上表显示，相比传统的压缩方法，能在保证精度不损甚至略有提升的情况下，达到最大的压缩率，将原始从压缩至，而结合 后更能达到，完全满足了移动端的部署和低带宽网络的传输。
此外，作者还借鉴思想，对原始网络结构做了修改，增加了旁路分支，将分类精度提升了约。
 速度考量
尽管文章主要以压缩模型尺寸为目标，但毋庸置疑的一点是，在网络结构中大量采用和卷积核是有利于速度的提升的，对于类似这样的深度学习框架，在卷积层的前向计算中，采用卷积核可避免额外的操作，而直接利用进行矩阵加速运算，因此对速度的优化是有一定的作用的。然而，这种提速的作用仍然是有限的，另外，采用了个 和两个卷积层，因此仍需要进行大量常规卷积操作，这也是影响速度进一步提升的瓶颈。
二、 
 出自  的一篇论文《            》。该文章获得了 的最佳论文奖，同时也具有里程碑式的意义，引领了模型小型化与加速研究方向的新狂潮，使得这一领域近两年来涌现出了大量的优秀工作与文章。
 算法流程
与前面的“架构压缩派”的不同， 是属于“权值压缩派”的。而两篇文章均出自团队，因此两种方法结合，双剑合璧，更是能达到登峰造极的压缩效果。这一实验结果也在上表中得到验证。
 的算法流程包含三步，如图所示：

图   
、权值剪枝
剪枝的思想其实早已在早期论文中可以窥见，等人曾经就利用剪枝来稀疏网络，减小过拟合的风险，提升网络泛化性。
图是上训练得到的 卷积层中的参数分布，可以看出，大部分权值集中在处附近，对网络的贡献较小，在剪值中，将值附近的较小的权值置，使这些权值不被激活，从而着重训练剩下的非零权值，最终在保证网络精度不变的情况下达到压缩尺寸的目的。
实验发现模型对剪枝更敏感，因此在剪值时建议逐层迭代修剪，另外每层的剪枝比例如何自动选取仍然是一个值得深入研究的课题。

图  层权值分布图
、 权值量化
此处的权值量化基于权值聚类，将连续分布的权值离散化，从而减小需要存储的权值数量。

初始化聚类中心，实验证明线性初始化效果最好；
利用算法进行聚类，将权值划分到不同的中；
在前向计算时，每个权值由其聚类中心表示；
在后向计算时，统计每个中的梯度和将其反传。

图 权值量化前向和后向计算过程
、 霍夫曼编码
霍夫曼编码采用变长编码将平均编码长度减小，进一步压缩模型尺寸。
 模型存储
前述的剪枝和量化都是为了实现模型的更紧致的压缩，以实现减小模型尺寸的目的。

对于剪枝后的模型，由于每层大量参数为，后续只需将非零值及其下标进行存储，文章中采用  来进行存储，这一步可以实现的压缩率。
对于量化后的模型，每个权值都由其聚类中心表示对于卷积层，聚类中心设为个，对于全连接层，聚类中心设为个，因此可以构造对应的码书和下标，大大减少了需要存储的数据量，此步能实现约的压缩率。
最后对上述压缩后的模型进一步采用变长霍夫曼编码，实现约的压缩率。

 实验结果
表 不同网络采用 后的压缩率

通过 可以将原始的压缩至，实现约的压缩率。
 速度考量
可以看出， 的主要设计是针对网络存储尺寸的压缩，但在前向时，如果将存储模型读入展开后，并没有带来更大的速度提升。因此 等人专门针对压缩后的模型设计了一套基于的硬件前向加速框架，有兴趣的可以研究一下。
三、
二值网络一直是模型压缩和加速领域经久不衰的研究课题之一。将原始位浮点型的权值压缩到比特，如何最大程度地减小性能损失就成为了研究的关键。
此篇论文主要有以下几个贡献：

提出了一个和，前者只对网络参数做二值化，带来约的存储压缩和的速度提升，而后者对网络输入和参数都做了二值化，在实现存储压缩的同时带了的速度提升；
提出了一个新型二值化权值的算法；
第一个在大规模数据集如上提交二值化网络结果的工作；
无需预训练，可实现  。

  
为了训练二值化权值网络，令，其中，即二值滤波器，是是尺度因子。通过最小化目标函数，得到其最优解：
  
即最优的二值化滤波器张量即为原始参数的符号函数，最优的尺度因子为每个滤波器权值的绝对值的均值。
训练算法如图所示，值得注意的是，只有在前向计算和后向传播时使用二值化后的权值，在更新参数时依然使用原始参数，这是因为如果使用二值化后的参数会导致很小的梯度下降，从而使得训练无法收敛。
  
在网络中，优化的目标是将两个实数向量的点乘近似到两个二值向量的点乘，即

式中，，
类似的，有最优解如下式

在卷积计算中，输入和权值均量化成了二值，因此传统的乘法计算变成了异或操作，而非二值化数据的计算只占了很小一部分。
中一个典型的卷积单元如图所示，与传统单元不同，各模块的顺序有了调整。为了减少二值化带来的精度损失，对输入数据首先进行归一化处理，层用于对输入做二值化，接着进行二值化的卷积操作，最后进行。

图 训练过程

图 传统卷积单元与卷积单元对比
  实验结果
表 上二值网络与结果对比

与相比，网络能够达到精度基本不变甚至略好，由于对输入也做了二值化，性能稍降。
四、
算法是等人在论文      中提出的一种类似网络迁移的学习算法。
 基本思想
直译过来即蒸馏，其基本思想是通过一个性能好的大网络来教小网络学习，从而使得小网络能够具备跟大网络一样的性能，但蒸馏后的小网络参数规模远远小于原始大网络，从而达到压缩网络的目的。
其中，训练小模型 的目标函数由两部分组成
 与大模型 的输出的交叉熵 ，称为软目标 。其中，的计算加入了超参数温度，用以控制输出，计算公式变为

温度越大，输出的分布越缓和，概率越小，熵越大，但若过大，会导致较大熵引起的不确定性增加，增加了不可区分性。
至于为何要以 来计算损失，作者认为，在分类问题中，真值是一个确定性的，即 。以手写数字分类来说，对于一个数字，它的是的概率是，而是其他数值的概率是，而对于 ，它能表征是的概率，假如这个数字写的像，还可以给出是的一定概率，从而提供更多信息，如



数字














真值












软目标













与真值的交叉熵=
训练的损失为上述两项损失的加权和，通常第二项要小很多。
 实验结果
作者给出了在语音识别上的实验结果对比，如下表
表 蒸馏模型与原始模型精度对比

上表显示，蒸馏后的模型的精确度和单字错误率和用于产生软目标的个模型的性能相当，小模型成功地学到了大模型的识别能力。
 速度考量
的提出原先并非针对网络加速，而最终计算的效率仍然取决于蒸馏模型的计算规模，但理论上蒸馏后的小模型相对原始大模型的计算速度在一定程度上会有提升，但速度提升的比例和性能维持的权衡是一个值得研究的方向。
五、
是由提出的针对移动端部署的轻量级网络架构。考虑到移动端计算资源受限以及速度要求严苛，引入了传统网络中原先采用的思想，即限制滤波器的卷积计算只针对特定的中的输入，从而大大降低了卷积计算量，提升了移动端前向计算的速度。
 卷积分解
借鉴 的思想，将普通卷积操作分成两部分：

 
每个卷积核滤波器只针对特定的输入通道进行卷积操作，如下图所示，其中是输入通道数，是卷积核尺寸：



图  
 的计算复杂度为 ，其中是卷积层输出的特征图的大小。

 

采用大小的卷积核将 层的多通道输出进行结合，如下图，其中是输出通道数：

图  
 的计算复杂度为 
上面两步合称  
标准卷积操作的计算复杂度为
因此，通过将标准卷积分解成两层卷积操作，可以计算出理论上的计算效率提升比例：

对于尺寸的卷积核来说，  在理论上能带来约～倍的效率提升。
 模型架构

图 普通卷积单元与 卷积单元对比
的卷积单元如上图所示，每个卷积操作后都接着一个操作和操作。在中，由于卷积核只应用在 中，因此的计算量都集中在  中的卷积中。而对于等采用矩阵运算实现卷积的深度学习框架，卷积无需进行操作，因此可以直接利用矩阵运算加速库进行快速计算，从而提升了计算效率。
 实验结果
表 与主流大模型在上精度对比

上表显示，在保证精度不变的同时，能够有效地减少计算操作次数和参数量，使得在移动端实时前向计算成为可能。
六、
是今年提出了一篇用于移动端前向部署的网络架构。基于的思想，将卷积操作限制到特定的输入通道。而与之不同的是，将输入的进行打散，从而保证每个卷积核的感受野能够分散到不同的输入中，增加了模型的学习能力。
 设计思想
我们知道，卷积中的操作能够大大减少卷积操作的计算次数，而这一改动带来了速度增益和性能维持在等文章中也得到了验证。然而操作所带来的另一个问题是：特定的滤波器仅对特定通道的输入进行作用，这就阻碍了通道之间的信息流传递，数量越多，可以编码的信息就越丰富，但每个的输入通道数量减少，因此可能造成单个卷积滤波器的退化，在一定程度上削弱了网络了表达能力。
 网络架构
在此篇工作中，网络架构的设计主要有以下几个创新点：

提出了一个类似于的单元

借鉴的旁路分支思想，也引入了类似的网络单元。不同的是，在=的单元中，用操作代替了操作，用 代替了=的卷积操作，有效地减少了计算量和参数。单元结构如图所示。

提出将卷积采用操作会得到更好的分类性能

在中提过，卷积的操作占据了约的计算量，所以作者将也更改为卷积，使得相比的计算量大大减少。

提出了核心的操作将不同中的通道进行打散，从而保证不同输入通道之间的信息传递。

的操作如图所示。

图 网络单元

图 不同间的操作
 实验结果
表 与在上精度对比 

上表显示，相对于，的前向计算量不仅有效地得到了减少，而且分类错误率也有明显提升，验证了网络的可行性。
 速度考量
作者在平台上对网络效率进行了验证，鉴于内存读取和线程调度等因素，作者发现理论上的速度提升对应实际部署中约。作者给出了与原始的速度对比，如下表。
表 与在平台上速度对比 

结束语
近几年来，除了学术界涌现的诸多模型加速工作，工业界各大公司也推出了自己的移动端前向计算框架，如的、的以及苹果今年刚推出的。相信结合不断迭代优化的网络架构和不断发展的硬件计算加速技术，未来深度学习在移动端的部署将不会是一个难题。
参考文献
       
        
    
       
            
             
       
        
         
          
   
         背景
在近几年比较火的敏捷开发大背景下，我们的项目团队的需求管理，也一直在探寻着敏捷开发的轻量化管理的原则，并且由于我们团队采用了  的团队运作模式，所以版本的需求都是由各个 自己独立管理的方式，理想状态是，各 自己管理需求，自己去做质量管理，自己评估把控进度和最后版本的顺利发布。而现实往往和理想之间，总会存在差距。下面就来谈谈，咱们浏览器项目需求管理那些事 
需求管理 时代   自管理 规划表
我们知道，敏捷价值观中有一个是关于文档的，认为：

这个原则本身是一种比较好的价值观，认为在开发过程中，有可用的软件好过详尽的文档描述，来引导团队快速迭代做出可用的软件。我们的项目需求管理 时代，就是用 列表的方式来轻量化去管理需求，通过项目群来同步版本需求规划。
这种方式，确实简化了需求的定义，对团队来说是一种比较轻量的管理方式，但实际应用后，我们发现没有了需求文档的详细说明，和集中的需求设计交互管理，我们的版本需求质量也就也会受到一定的影响，因为没有文档，可能有些需求会被反复更改，导致需求变更增多，变更的增加也造成版本管理出现一些问题：版本需求不可控，质量影响、版本延期等。


首先，是版本延期

由于需求大多是一句话需求，没有明确的交互或详细描述，产品经理的想法也会不断变化，而开发的理解也会有所不同，这样就造成额外的劳动量。使得开发无法按期完成需求，而造成版本的延期。

其次，需求变更多

由于版本延期，已经开发好的又会觉得与其等待别的，不如自己也加入到需求新增的大军中，继续开发，这样互相影响，从而导致本一再延期，整个项目的周期也被不断拉长。

需求的沟通、维护成本加大

、需求描述就是一句话，大大增加了开发难度和测试难度，可想而知，沟通成本加大。、 需求靠维护，更新和同步都是需要收集人及时更新并要同步到相关人员，维护成本高。

版本质量不可控

因为需求不明确，版本需求的新增或变更也难以控制，导致缺陷量也比较多，版本稳定需要更长的周期。面对遇到的问题，我们进行了总结和改进，开始了需求管理的时代。

项目需求管理时代  集中管理需求评审
、 需求的工具化管理：变的人工维护，为集中管理方式，每条需求的单上有明确的交互设计，解决需求的维护和沟通成本。
、需求评审机制：设立产品版本规划管理委员会。建立需求评审机制，由这个专门的需求决策者来对每个版本规划的需求质量和范围进行评审确认。这样在版本开发前就确认各的需求是否可以上这个版本，确保版本需求可控。
这样运作一段时间，基本解决了人工维护的成本和需求不明确的沟通成本问题，延期和变更有一定改善，但是延期和需求变更仍然存在，版本仍会有较大的发布延期情况，需求变更率也非常高，版本整体波动较大。
针对问题，我们继续进行相关的总结分析，发现主要原因还是需求的质量控制不够：虽然我们的需求在迭代开始前，有了评审的机制，但实际开发的过程中，由于需求本身复杂度、技术方案选择，或者开发时间的评估不足等，仍然会导致我们的需求开发有一定的可能会出现延期的情况。而且由于当时评审的仅仅是需求的设计文档或交互稿，有时候做出来后产品或老大可能会觉得和预期不一样，仍然会存在变更的可能性。
针对这些问题和总结的原因，我们继续寻找更好的需求管理模式。

需求管理时代  集中管理合流评审
经过不断的总结和根因分析，我们的需求管理方式又做了如下调整：
、 针对需求评估不足或者变更引起的延期，我们的需求仍是采用工具管理的方式，但这里的管理会有所变化，这里的需求评审由内自己评审完成，同时要求内必须要要完成内部的需求评审，这个需求的把关由自己负责。而评审的完成时间必须是在版本规划的第周内完成。

这个变化将需求的评估充分放权给内部完成，你需要根据火车版本的周期，来评估和规划，版本周期内可以完成的需求，而不是所有的需求都想挤上同一趟火车。
、 我们将产品管理委员会对需求的评审时间，延后到合流阶段，建立了合流评审的机制。这样做的好处是，当开发到合流阶段时，需求功能已经基本完成并可以使用了，这样给到老大进行评审时就比较直观，这样再评审后的既定时间内稍作修改基本就可以达成需求的预期，也减少了合流后的需求变更带来的质量风险。同时，对需求的变更管理也进行了规范，需求的重大变更或新增均需要有充分的理由给到审批，通过才能合入。

经过一段时间的运作，我们来看下实际的效果：
 版本从延期不可控 到 逐步可控 再到基本无延期；需求变更逐步改善，变更率下降了到；质量逐步提升，千行缺陷率也下降明显；
大大降低了项目的时间和人力成本，同时也为产品需求的快速上市提供了保障。
当然，敏捷项目需求管理的方法，我们仍在不断总结和迭代优化中，希望大家也一起来多探讨更好的管理模式，期待更优的需求管理 时代的到来！徐东山：腾讯云安全副总监，  年进入腾讯并服务至今，历任后台开发、后台策略安全等岗位。从  年腾讯开放平台和腾讯云启动迄今，一直从事腾讯云安全相关的业务规划和系统建设工作。对海量服务系统开发、后台策略安全设计等有较强烈兴趣和一定积累。
分享主概要  ：
、腾讯云安全在腾讯云不同发展阶段，承担着不同的使命和职责，在这些不同阶段，腾讯云安全建设方向有着怎么样的体现。对于使用腾讯云的客户，腾讯云安全主要提供的保障和服务。  
、对腾讯云安全的网络防护大禹、业务安全天御、移动安全乐固等产品服务和技术实现的说明。
分享实录
首先介绍下我自己，我是来自腾讯公司的徐东山，当前主要负责腾讯云安全的架构设计与产品规划等工作。  
我们团队主要涉及到海量服务后台开发、后台安全策略、运维安全、大数据处理、机器学习等领域，当前也有较大的人力缺口，欢迎在这些方面有经验、同时对腾讯和深圳有兴趣的同学私下联系我。  
现在我开始分享。 年前，我们说到云计算，还觉得它是一个有些飘渺的技术方向和概念，但今天，我们说到云计算，已经可以认为它是实在的产业并且直接影响到了  行业的现实领域和抉择。 

产业发展过程中，腾讯云在里面起到了重要作用。从腾讯云诞生至今，安全一直是最核心的问题，也一直面临质疑和挑战。并且，随着腾讯云与行业的发展，安全的质疑与挑战也随时间与阶段呈现不同的特点

下面，我根据腾讯云发展的不同阶段，对云安全在相应阶段的使命与建设理念进行描述。

腾讯云的发展，可以认为有四个阶段：
内部使用阶段：对云计算技术进行研究，并在内部业务如 、、会员等业务上进行应用。
支持开放平台阶段：以开放平台推出为标志，腾讯正式迈出了开放的步伐。其中，腾讯云负责支持合作伙伴的计算、网络等资源需求。公有云阶段：在支持开放平台基础上，腾讯云正式推出了公有云，全面对外提供 、 等服务。
互联网 阶段：随着互联网 战略的实施，腾讯云在里面承担了基础资源落地的核心任务和使命。

在腾讯云的发展历史中，云安全从开放平台阶段开始介入，通过完成使命，推动着腾讯云在不同阶段的发展和演进。  
开放平台阶段：在这个阶段，外部合作厂商的服务开始纳入腾讯体系，并对用户直接提供服务。当时最大的挑战在于，服务由合作厂商提供、运营和管理，其服务标准等是否能够符合腾讯要求，会否损害用户利益。基于此，云安全需要对合作厂商的服务进行监控，对损害用户利益的合作厂商，要能及时阻止并处理。
公有云阶段：公有云阶段最大的挑战在于，腾讯云第一次对外全面开放了基础措施，原来基于自研的强制的安全规范和措施对公有云客户来说无法落地和实施，在全面开放的背景和要求下，怎么保障腾讯云基础平台和支撑体系的可靠和安全，是云安全当时面临的主要任务。互联网 阶段：在这个阶段，腾讯云有更强烈的使命来帮助整个行业、整个生态更安全的运营，除了托管在云上的业务，对非托管业务也需要一起覆盖。云安全需要针对互联网行业和生态的痛点，提供切实可行的安全解决方案，从而帮助行业和生态更聚焦在业务成长上。

开放平台时代，云安全主要针对合作厂商的业务进行行为和内容安全审计：  
、对服务进行漏洞扫描、对主机进行检测等，帮助合作厂商发现业务脆弱性并进行修复。  
、对业务内容进行扫描，和结合传播渠道，发现其中不合规的恶意内容，并及时处理。  
、对业务托管机器进行网络监控，对恶意网络行为进行识别，从而从事后发现被恶意控制的机器。

公有云初期，云安全重点保障了支撑体系的安全可靠： 
、梳理安全运营规范和修改安全策略，给正常客户更自由体验，对非正常客户识别行为做到旁路化。、对齐行业标准，梳理云计算基础平台的资产和风险，并制定相应的规范和基线，强制执行。、对公共的安全需求，进行统一服务提供，通过统一服务减少业务参与，减少风险。、定期进行基线更新、风险识别并推动修复，通过自动化开发提升执行效率。

当前，为了配合互联网 战略的更进一步实施，云安全针对客户痛点推出一序列强化服务，在基础服务之外，推出了更有针对性、能力更强的大禹、天御等安全服务，并且覆盖到非云客户。
对一般客户来说，主要存在着下面的几个问题：
、客户端被篡改。、被  攻击。、业务有漏洞导致被入侵。、业务逻辑被盯上，导致被刷。

通过公司内部积累和腾讯云各个阶段的使命达成，腾讯云安全积累了业界领先的能力，并且形成了一整套的安全总体架构。
从层次上，覆盖了组织管理、物理安全、基础平台、合规性审计、网络安全、主机安全、应用安全等各个方面，给客户提供全面强有力的安全保障。  

对提供计算和网络资源的云服务商而言，可信是其首要保证的。腾讯云从两方面来保障基础平台的可信度：
、确保客户的资源只自己可见，包括网络隔离、访问鉴权等。客户只能看到自己的资源，看不到别人的资源，也看不到任何非授权的服务。
、云服务提供商做好自我保障，断绝从平台方向对客户资源的非授权访问。包括平台自我加固，以免存在漏洞被恶意利用；同时对内部进行审计，任何操作都有记录可追溯，并对异常行为能够自动告警。

通过上面的可信措施落实，腾讯云也获得了一序列的外部合规性认证，包括  ：、可信云、等保等认证，给客户提供了更可信的保障。

在基础平台和支撑体系安全可靠之外，腾讯云安全在网络、主机与应用、业务、移动等领域均提供了全面的安全服务。

下面，针对云安全服务，我挑选部分内容对大家进行介绍。

大禹、天御、乐固三大产品，分别从网络安全、业务安全、移动安全的方向，提供了整套全面的安全服务。
同时，这三大产品，也可以很好支持非云托管的客户。

首先介绍下  攻击：
 又称为分布式拒绝服务，全称是    。   
 就是利用合理的请求造成资源过载，导致服务不可用。  
描述：城东新开了一家牛肉面馆，生意红火，顾客络绎不绝。  
某天，一个地方恶霸召集了手下一批小弟，一窝蜂涌入牛肉面馆，霸占了所有座位，只聊天不点菜，导致真正的顾客无法进店消费。由此，牛肉面馆的生意受到影响，损失惨重。如果把这家牛肉面馆，看作是一家互联网企业，那么这群地痞的恶行，就是典型的分布式拒绝服务，也就是我们所说的  攻击  
 黑产  
动机=》敲诈勒索：在线盈利企业为首要敲诈目标，收取保护费；商业竞争：游戏的私服，和电商，是重灾区，竞争对手攻击  
成本=》黑产圈承诺  元一次，包打死！！！  
流量来源=》非法 ；肉鸡
面对猖獗的  攻击我们能做什么？
、默默忍受：被打时，网络无法访问  
、扩容机房出口带宽：高成本  
、接入腾讯云－大禹系统
大禹治水，分而治之，而非堵而治之  
如果机房带宽   带宽，无法承受。因此，我们聪明地选择全国分布式节点腾讯既有数据中心做防护。  
大禹系统防护说明：
单节点防护能力 ＋，全国节点  ，合计可抵抗攻击 ＋  
每个节点由腾讯自研  检测和清洗算法  
因为是分布式部署，相当于把流量分摊没有哪个黑产可以进行 ＋的攻击  
大禹系统，就是这样以分布式，来保证你的服务可用
大禹系统防护全景图：
用户请求  
－ 腾讯  调度系统  
－ 腾讯云大禹系统流量清洗  
－ 业务侧自己的服务器
大禹系统接入流程：
客户到大禹管理台配置安全域名  
把用户请求以  的形式重定向到大禹系统用户请求－域名－大禹系统－

业务侧服务器
羊毛党第一步：

其次： 

全路径进行识别和打击：

从信用、行为、内容等方面，对广告、恶意内容等进行识别：
 
腾讯验证码： 

类型丰富：

天御提供了防刷、内容识别、验证码等多项业务安全能力
 
 存在风险

对抗的主要思路和原理：、 加固整体替换  
、 加固方法替换  
、 加固 加壳  
、自定义加固、多维度加固

注：分内容没有详细说明。欢迎大家扫码下载腾讯云安全白皮书，了解更多内容。
问答实录：
全国分布式节点怎么理解？
答：大禹系统使用了  节点在前面分流攻击流量，我们  节点是全部分布的。  
  怎么分配的？
答： 解析用了腾讯自研体系的  系统，能根据用户访问就近接入，并会根据节点质量自动调度。 在我们公司服务了 、微信、 等业务，久经挑战。  
对内部进行审计，任何操作都有记录可追溯，能具体说说么，操作每条指令都存入日志么？
答：这里的操作指腾讯云内部人工的操作，我们通过管理权限、堡垒机等限制员工在合理范围内操作，并把输入的命令记录到流水。  
腾讯云安全对最典型的  攻击是怎样防御和限制的？在云平台上，谢谢！

答：我们的  防护有三种模式，一种是在云机房内，一种是专门的高防机房，一种是大禹在前端的分流清洗。我理解的是第一种，这种我们是搭建了自研的  防护设备宙斯盾，大禹在具体节点上也复用到了这个系统和能力，由宙斯盾进行清洗。对于协议级别攻击一般也是大流量，我们根据协议内容的异常识别等进行攻击源识别；对于应用层攻击，我们根据请求规则、互动等识别。  
你们这套系统是只能对腾讯云有用吗？我们私网可以使用吗？
答：大禹、天御、乐固都可以对非云的业务提供，其中，大禹、天御必须要有外网，乐固只要在我们官网上加固。  
请教下腾讯云  私有网络与企业网之间建立的  通道有什么办法做到监控？
答：对这个我们不会做内容监控，但是可以对流量包量、时间曲线、源端目的的等识别，并判断异常进行告警。  
你们的  动态迁移是怎么实现的？
答：基于  和  节点可用性来调度，对  节点进行可用性监控，当满足迁移条件时，修改  解析。  
请问一下 大禹是如何判断的，如何自动接入大禹的？
答：大禹在各个节点均有攻击清洗能力，在节点可以进行流量清洗。接入的话，只要把域名  给我们分配的特定域名上即可。  
对于国外服务器的建议与方案呢？
答：腾讯云在香港和北美均有托管机房，可以接入天御，可以使用乐固。但是接入大禹意义不大，因为大禹资源主要在国内。  
请问面对这么大流量，怎么分析哪些是恶意攻击？哪些是正常流量在  攻击的时候 正常用户可以正常使？
答：系统分成检测、清洗、控制等部分，在平时，流量会直接到源站或者业务服务器，同时，流量会分光到检测设备，检测设备对流量进行判断，这个时候检测不会影响业务流量；当检测设备检测到攻击后，会通过控制系统下发策略，这时候业务流量会经过清洗设备，经过清洗后再回到源站或者业务服务器，这个时候清洗会影响到源站。一般性来说，清洗设备只会过滤攻击流量，业务正常流量会透传回到源站。  
是绿盟的流量清洗设备不？
答：清洗逻辑，当前用的主要是我们自研的设备宙斯盾。  
我最想知道公司机房怎么接入你们的系统？
答：整个机房接入吧？这个可能具体要看，比如机房外网服务的提供方式，有多少访问入口等的。如果域名少或者  数少，就有办法通过牵引搞掂，如果多的话，就是资源耗费的问题。  
大禹是分布式的吗，假如攻击流量超过机房的带宽，能转移到其他机房么？
答：大禹是分布式的，流量会分流到各个  节点，如果某个节点不可用或者超过带宽，会自动剔除该节点，并把该节点的业务流量调度到其他大节点去。  
 二层 三层？
答：腾讯云体系中，对于转发，主要是基于  层和  层。  
 对于应用层攻击，我们根据请求规则、互动等识别  ——这个没法通用吧，要建立正常业务流量的特征库么？
答：要针对特定的业务设置。这个主要看攻防情况，会设置默认规则，这些会相对简单较容易漏过，之外还有特殊规则，这些主要是漏过后和客户一起制定，联手与攻击者对抗，这块相对坎坷。对业务流量的特征库，正在做，但当前只对大禹的几个高危用户在试点。  
请教下，如果腾讯云上某客户业务管理员被非法利用，进行非常规操作，机器学习是否可以进行甄别并发出告警？
答：简单说下思路：异地  和时间登录、操作频次、操作范围等可以识别，还可以根据更广度的操作习惯，但是当前在操作习惯上，更多是 、、 等  要素来做。  
能在清楚点么是如何判断的啊 ？就好像餐馆来了好多人 我怎么判断哪些是消费者哪些是混混 处理策略又是如何清洗的直接过滤么 会不会对正常流量误判断？
答：简单说，协议包里面，、 等字段的合理性，或者是否会对某些返回进行识别。清洗策略是识别恶意后丢弃，如果判断失误，是会有误杀。
 阿里云也在香港有托管机房吧？你们的优势在哪？
答：按照你自己的核心需求，找到最关键的几个点来，进行评估。  
腾讯云安全服务是对客户开放的，还是需要单独购买云安全服务呢？
答：托管在腾讯云上，会享用基础安全服务，如果不是托管，可以单独使用大禹天御和乐固。但是登录防护等则没有办法。  
 这些是公开的防御系统听说腾讯内部还有一个特别强大的防御系统是吗？
答：说宙斯盾吗，云上的大禹和宙斯盾是我们的精华了。图片来源：
回顾自己的技术成长之路，具体技术真心没有一样敢说精通，对于一个像我这样工作、年的人来说，实在有些难以启齿。
现在中国整个的技术环境看重的是技术深度，而我从一开始就认为应该先广度再深度，自然在同行中被认为是异类。我没记错的话，大神左耳朵耗子的观点就是深度优先。
为什么要广度优先，而不是深度优先。我有自己理由：

技术变化太快，当你还没有深挖到某一个框架的本质，这个框架就可能已经过时了，特别是框架；

容易只见树木、不见森林：比如你花很多时间去研究如何分布式存储你业务应用中的文件，但是你可能不知道世界上还有 这样的东西；

手里有把锤子，全世界都是钉子：精通写脚本的人，所有的运维工作都倾向于写来解决运维问题，不知道世界上还有这样方便的东西，也不知道有时候根本问题不在运维，而在开发。


我说出这些理由，并不是说我们就不需要深入研究某个框架和技术，只是想说明我们的选择的优先级会决定，至少会影响我们的思维方式。
这几年，我开始输出一些体现我思维方式的文章，比如：

《耦合的本质》
《关于自动化配置还有什么好说的呢？》
《也许，这样理解更容易》
《，，的共性》 根据自己的一次分享整理
《信息检索中，索引的本质》

很少人发现这些文章的真正价值，因为看起来和他们的实际工作没有任何关系，这些文章不会告诉你怎么快速搭建好环境，也不告诉你怎么用 一个文件到所有的目标机器上。
在一次面试时一位老架构师两次问我：《耦合的本质》真的是你自己写的？显然他不相信写这篇文章的人不到。确认之后，他说他不完全认同“耦合的本质是假设”，但是他欣赏这样的思维方式。
我头一回感觉到有人看懂这篇文章。
总的来说，这些文章体现出来思维方式是：

利用概念推导、还原事物的形成过程、找共性这个手段来找到事物的本质，再从这个本质推导基于此事物的上层建筑。

比如我根据我们实际运维过程所要做的事情，推导出要实现自动化所要解决的问题，然后再通过“找共性”的方法，最终找到了这，， 三款工具之间的共性。
但是有什么用呢？其实，找到共性后，当遇到第四种自动化运维工具时，我们就很容易提问了：

如何与受控机器通信

如何组织机器的？

使用什么来描述这些机器的配置


最后根据这些问题进行深入地学习，这样我们就可以从被动学习变成主动学习，有方法论的学习方式。甚至找到这些工具的知识边界。
然而这只是我的个人学习方式，不一定适用于所有人。也不代表我的学习方式就是好的。
我只想说明：深度优先和广度优先的选择会改变我们的思维方式。
按道理，使用这样的思维方式有点像方法论，任何一门技术都可以做到精通，但是我目前就是没做到精通。
因为我排斥用脑袋记东西。我认为记不了的东西或者能不记的东西，它就不值得记忆。比如如何将字符串转成一个整型数字、里某个的具体用法。
而现实中，我对比其他的运维人员，我发现我用用得已经非常好了，里的概念我基本已经理解透了。但是我仍然不敢说精通。我实在记不了这个的所有参数。
所以，即将三十了，我仍然不敢说我精通任何一项技术。这成为我的困境。
这时，很多人就会说了，你应该考虑转管理了。
但是，我要问了：为什么要转管理呢？
不少人的回答：

因为你老了，你没有精力去学习更多的新语言、新框架了，你拼不过小鲜肉了。

这个观点里有，有两个假设：第一，到三十后，你学不会，或学得慢新语言、新框架是因为没有精力；第二，小鲜肉没有能力做管理；
第一点假设不成立，因为那只是借口——不想做的人，会找理由，想做的人，会找办法。第二点假设只是概率性问题，小鲜肉也可以做管理。
转不转管理，决定于你是否真的好了，是否真的喜欢做管理。和你年龄没有任何关系。
说到底，写不写代码，做不做管理，都是个非常私人的问题。我们没必要那么在意别人怎么看。
最后，我深爱着写代码。这不会因为我目前或将来是否精通某项技术而改变。安装 
检查是否安装
  
卸载旧版本
  
安装最新版本
  
检查是否安装成功
 
创建项目仓库
创建目录
  
创建项目仓库    
  
检查是否创建成功
 
之后使用  查看是否多了一些文件夹如果成功
配置项目库
进入  目录，了解配置文件：
 是权限控制文件
 是账号密码文件
 是  服务配置文件
配置 
根据  标签中的提示进行配置即可，等号左边是用户名，右边是密码
配置 
只有自己用，所以只是限定自己的用户有  权限即可，在文末加入用户名和读写权限就可以了


  = 
配置 
 =   使非授权用户无法访问
 =   使授权用户有写权限
 = 
 =   访问控制文件
 =     认证命名空间，会在认证提示里显示，并且作为凭证缓存的关键字。
采用默认配置 以上语句都必须顶格写 左侧不能留空格 否则会出错
开放  端口
修改 
        
保存  配置    
 
重启 
  
查看  状态
 
启动  服务
   
 守护进程   根目录
连接 
使用  连接到 我的  地址
输入前面设置的用户名密码即可访问
配置开机启动
编写脚本 _，放在_，代码如下

 _=_
   
关于绝对路径：在启动的时候环境变量可能没有加载，所以采用绝对路径比较保险，可以使用   命令来查询绝对路径
修改脚本权限
  _
或者
  _
添加自启动
 
在文件末尾添加命令行脚本
_
重启之后确认启动成功
 | 
 网站工作目录
       
使得  可以自动同步网站代码
将工作目录转移到钩子文件夹
 
添加配置文件
  
  
修改  文件，加入以下代码
 =
 
      
 ```` _
 同步时注意
工作目录需要先 前面已经  过了
先切换到工作目录 再用  的  或者  命令进行 
如果工作目录有更改，需要 
先切换到工作目录 再用  的  或者  命令进行同步
可能需要— 或者 参数，后面跟上这次修改的一些信息即可
如果工作目录中有新的文件，需要先添加到  中在同步
使用  的  命令进行添加文件或者文件夹如果需要添加的文件很多，可以使用  的 通配符：   
批量添加删除  同步的文件
使用  命令添加    
 |  | { }|  
删除
 |  | { }|  
可以添加到  中，如，命令叫做  和 
如果  同步目录中出现中文，钩子无法正常运行需要修改系统的 
 _=_
之后可以用  命令检查添加  的命令已经包含在自启动文件中了

相关推荐
 安装配置服务器
免费体验云服务器，提供最佳上云实践机会
【腾讯云的种玩法】  单机环境搭建与初步学习起源
 朋友圈广告项目于年月对外发布，我们第一个非商业广告是龙哥想出来的创意，大家应该都有印象，为我们的“与众不同”奠定了基调，也为后面的商业广告预热了气氛。

第一批投放商业广告有三个，分别是宝马，可乐，手机。在发布当天便引起了广大网友的热烈讨论，不少网友以“你刷到了哪一条”进行调侃，甚至有网友将三则广告集合在一起评论：“开宝马，喝可乐，用才是人生赢家”，“看到宝马广告的是土豪，看到的是中产，看到可乐的是屌丝，啥都没有看到的，很抱歉，你已经被抛弃了”……
   
当时很多人问我广告系统到底是什么样的？是不是整个系统只是几行代码随机投放一个广告给用户就好？下面我将大致介绍一下朋友圈广告系统的架构，研发中遇到的问题，以及联合团队小伙伴们做出的一些优化。
系统总览

  这是朋友圈广告后台系统的主要模块图，下面将挑选部分展开分析。
社交计算
朋友圈广告与传统广告最大的不同就在于引入了社交元素，而如何将社交元素与广告选择结合起来，是我们要思考的问题。
量化指标
要解决问题，首先就得有一个指标去衡量好坏。前一段时间，尼尔森对的广告进行了用户调研，发现当用户看到一个有好友互动的广告之后，对广告品牌的记忆率和认知度有的提升。其实这也是一个很自然的感觉，那么就首先定一个与之相关指标：扩散度。
系统实现
首先，要注意到朋友圈广告的生命周期都是短的，所以如果采用离线数据计算再反推到在线系统之上的方案，就会使得整个投放阶段效果很差。其次，广告系统对延时要求非常高，如果每次直接拉取每个好友的实际评论情况，也不切实际。因此，最终选择了用户互动信息实时写入到每个好友身上。
这里会遇到个工程上的问题：

微信的用户好友数据都是分布存储在不同的上的，如何实时将各个间数据打通。
有的微信用户可能有几千个好友，如果一个个写，就算是扔到异步队列也效率太低了。

其他因素
只是看用户好友的评论与点赞次数，这个就足够了吗？显然是不行，下面列出个主要要考虑的要素：

用户之间的亲密度

好友的权威影响力

评论的正面影响
这其中涉及到数据挖掘，自然语言处理的应用，以及如何与在线系统打通，鉴于篇幅，后面有机会再深入展开。


广告质量预估
朋友圈广告的展现形式，决定它有很多关注点，并不像传统广告只关注点击那一个动作。下面将我们要考虑的因素列出来，这是一个多目标预测问题，

这么多目标，传统常见的多目标预测方法可能是训练出多个模型，但是这样在线系统使用时候就面临一个时耗的问题。所以我们的经验是根据训练数据累积预测不同行为，离线模型可以直接训练出综合的质量因子。使用神经网络和多元线性回归融合。
那么在预测时候，需要考虑哪些因素呢？下面给出一个的大类：
 
速度控制
这个也是朋友圈广告与传统效果广告不同的地方。传统广告，当一个用户看到之后，以上的用户在一个小时之内就会点击公众号广告为例，并且不会延迟太久。
而朋友圈广告则很不同，因为一个用户在拉取朋友圈之后，他可能不会往下拉着去看完所有的，也许到了第二天，第三天才去往下翻着看，此时也要产生扣费。另外就是朋友圈广告有评论点赞提醒功能，假如你的好友第二天对广告评论点赞通知到你，你再回头去看广告时候，也会产生一次扣费当然不是无限的。
这个就给系统进行投放时候的广告主余额控制带来了很大的麻烦，我们也为此更改了很多的版本上线实验才能做到目前较为精准的控制。其中关键环节是要保证曝光数据实时回流参与计算。另外经过多次投放，我们可以分析得出大部分用户在不同时间段上的行为规律，这样结合广告消耗的不同阶段去制定不同的速度控制策略，便可解决问题。
我们还针对这个给产品运营同学做了相关运营观察页面：
 
人群控制
在设计朋友圈广告系统初期，我们陷入了传统效果的广告系统架构的误区，即实现了检索—广告初选à广告预测à广告精选者这种经典的方案。可是朋友圈广告与之前业务并不同，因为一些时候，只有一个广告在投高逼格路线嘛，所以用传统的各种选择和预测方法是没用的。
这个本质就是从人选广告变为了广告选人。
这其实是一个很复杂的问题，主要有这么个因素要考虑：

前期投放哪些用户，他们最可能参与广告互动？他们最可能带动好友？
那些确定要投放的用户，他们是否满足拉取条件？是否被用户体验屏蔽掉？
精品用户范围太窄或者限制时间过长，广告主到时间投放太少不满足需求怎么办？

这里给出我们目前的解决思路和方案，只是一个示意图，其中需要涉及到前面讲的行为预测以及广告保量的知识，后续这里可以着重展开再写。

朋友圈后台架构支持
在原先朋友圈后台中，每条的评论点赞信息都是存储在一个上，它存储于存储系统中，每次拉取与更新都是对这些数据全存全取。但是现在一个广告，它类似于一条公共，一个广告下面的评论可能是百万量级，如果继续沿用之前的方案，每次存取量都会太大。
于是，微信后台团队改为将点赞评论数据分布存储在每个用户身上。当有读取时候，则需要将用户每个好友的评论点赞信息都读取出来可以想想为什么不用上面社交计算中提到的写扩散方式。
 
但是这样会引进两个工程问题：

每次读取数据量十分大
后端调用扩散出的链接数是随着集群规模扩大而扩大的

最终我们通过引入版本号的机制，在手机客户端中存储每次拉取的版本号，并将版本号这种轻量级数据写扩散到所有好友身上，方便快速感知变化。最终比较好的解决了这个问题。
客户端支持
 微信朋友圈广告能够快速上线，很大得益于微信客户端同事高效率的工作，和两个平台并行开发。
 广告有些特别的地方，比如它支持用户不感兴趣的反馈，支持外链的分享，发表帐号要和公众号体系打通等。
 另外，广告不能像用户普通一样，一直存在于用户的流中，因为假如用户回顾以往，发现一条条广告时候，那一定会很扫兴的，于是我们会对用户没有特别感兴趣的广告进行定期删除。另外，用户的发表之后就只有删除的动作了，而一个广告的假如其中某个图片需要临时更新，我们也要提供一种快速更新的机制，不能让广告主删掉广告。
 广告最重要的就是计费和效果分析，这里的数据重担都在客户端上了，需要对用户对广告相关的操作都进行收集并上报。这里涉及到实时且稳定的数据上报通道与之前的数据统计需要上报数据机制的完全不同的。关于各个统计点和路径分析上报，也做了有规划的整理。
结束语
得益于这一年辛勤的努力，微信朋友圈广告项目中的小伙伴在研发道路上都积累了很多经验，不止是技术与算法上，也包流程与质量上的。未来一年也将继续保持积极的学习心态，让微信朋友圈广告成为社交广告的标杆！推荐算法在个性化领域有着广泛的应用，粗略统计，所涉及到的学科包括人工智能、机器学习、认知科学、信息抽取、数据挖掘、预测理论、近似理论，甚至是管理科学、市场营销和心理学。所使用的算法除了传统的协同过滤，还包括图模型 、矩阵分解 、奇异值分解， 、链接分析 、回归分析 ，以及机器学习领域各种分类和学习算法。常见的推荐算法分类如表
表 推荐算法分类

推荐算法应用数据分析技术，找出用户最可能喜欢的东西推荐给用户，现在很多电子商务网站都有这个应用。目前用的比较多、比较成熟的推荐算法是协同过滤 ，简称推荐算法，算法分为两大类，一类为基于的，另一类为基于的，和算法均属于类型。的基本思想是根据用户之前的喜好以及其他兴趣相近的用户的选择来给用户推荐物品。

如图所示，在中，用×的矩阵表示用户对物品的喜好情况，一般用打分表示用户对物品的喜好程度，分数越高表示越喜欢这个物品，表示没有买过该物品。图中行表示一个用户，列表示一个物品，表示用户对物品的打分情况。分为两个过程，一个为预测过程，另一个为推荐过程。预测过程是预测用户对没有购买过的物品的可能打分值，推荐是根据预测阶段的结果推荐用户最可能喜欢的一个或个物品。
基于用户的协同过滤推荐算法原理和实现
基于用户的协同过滤推荐算法是最早诞生的，原理也较为简单。该算法年提出并用于邮件过滤系统，两年后年被用于新闻过滤。一直到年，该算法都是推荐系统领域最著名的算法。
基本思想
俗话说“物以类聚、人以群分”，拿看电影这个例子来说，如果你喜欢《蝙蝠侠》、《碟中谍》、《星际穿越》、《源代码》等电影，另外有个人也都喜欢这些电影，而且他还喜欢《钢铁侠》，则很有可能你也喜欢《钢铁侠》这部电影。
所以说，当一个用户  需要个性化推荐时，可以先找到和他兴趣相似的用户群体 ，然后把  喜欢的、并且  没有听说过的物品推荐给 ，这就是基于用户的系统过滤算法。
原理
找到与目标用户兴趣相似的用户集合；找到这个集合中用户喜欢的、并且目标用户没有听说过的物品推荐给目标用户。
 发现兴趣相似的用户
通常用公式或者余弦相似度计算两个用户之间的相似度。设  为用户  喜欢的物品集合， 为用户  喜欢的物品集合，那么  和  的相似度是多少呢：
公式：

 代表用户  与  之间的兴趣相似度，表示用户  曾经喜欢过的物品集合  表示用户  曾经喜欢过的物品集合。
余弦相似度：

脑补一下数学知识：
两个向量间的余弦值可以很容易地通过使用欧几里得点积和量级公式推导：

鉴于两个向量的属性，  和的余弦相似性θ用一个点积形式来表示其大小，如下所示：

产生的相似性范围从到：意味着两个向量指向的方向正好截然相反，表示它们的指向是完全相同的，通常表示它们之间是独立的，而在这之间的值则表示中度的相似性或相异性。 对于文本匹配，属性向量 和 通常是文档中的词频向量。余弦相似性，可以被看作是一个规范比较文件长度的方法。 在信息检索的情况下，由于一个词的频率权不能为负数，所以这两个文档的余弦相似性范围从到。并且，两个词的频率向量之间的角度不能大于°。
假设目前共有个用户： 、、、；共有个物品：、、、、。用户与物品的关系用户喜欢物品如下图所示：

如何一下子计算所有用户之间的相似度呢？为计算方便，通常首先需要建立“物品—用户”的倒排表，如下图所示：

然后对于每个物品，喜欢他的用户，两两之间相同物品加。例如喜欢物品  的用户有  和 ，那么在矩阵中他们两两加。如下图所示：

计算用户两两之间的相似度，上面的矩阵仅仅代表的是公式的分子部分。以余弦相似度为例，对上图进行进一步计算：

到此，计算用户相似度就大功告成，可以很直观的找到与目标用户兴趣较相似的用户。
 推荐物品
首先需要从矩阵中找出与目标用户  最相似的  个用户，用集合   表示，将  中用户喜欢的物品全部提取出来，并去除  已经喜欢的物品。对于每个候选物品，用户  对它感兴趣的程度用如下公式计算：

其中 表示用户  对的喜欢程度，在本例中都是为 ，在一些需要用户给予评分的推荐系统中，则要代入用户评分。
举个例子，假设我们要给  推荐物品，选取  =  个相似用户，相似用户则是：、、，那么他们喜欢过并且  没有喜欢过的物品有：、，那么分别计算   和  ：


看样子用户  对  和  的喜欢程度可能是一样的，在真实的推荐系统中，只要按得分排序，取前几个物品就可以了。 
整个过程可以用一张图简单的如下：

优点
以使用者的角度来推荐的协同过滤系统有下列优点

能够过滤机器难以自动内容分析的资讯，如艺术品，音乐等。

共用其他人的经验，避免了内容分析的不完全或不精确，并且能够基于一些复杂的，难以表述的概念如资讯品质、个人品味进行过滤。

有推荐新资讯的能力。可以发现内容上完全不相似的资讯，使用者对推荐资讯的内容事先是预料不到的。可以发现使用者潜在的但自己尚未发现的兴趣偏好。

推荐个性化、自动化程度高。能够有效的利用其他相似使用者的回馈资讯。加快个性化学习的速度。


缺点
虽然协同过滤作为一推荐机制有其相当的应用，但协同过滤仍有许多的问题需要解决。比如一些非常流行的商品可能很多人都喜欢，这种商品推荐给你就没什么意义了，所以计算的时候需要对这种商品加一个权重或者把这种商品完全去掉也行。再有，对于一些通用的东西，比如买书的时候的工具书，如现代汉语词典，新华字典神马的，通用性太强了，推荐也没什么必要了。这些都是推荐系统的脏数据，如何去掉脏数据，这是数据预处理的时候事情了，这里就不多说了。整体而言，最典型的问题有

新使用者问题   系统开始时推荐品质较差

新项目问题   品质取决于历史资料集

稀疏性问题

系统延伸性问题。


基于物品的协同过滤推荐算法原理和实现
   称为基于物品的协同过滤算法，简称 ，是目前业界应用最广的算法。该算法给用户推荐那些和他们之前喜欢的物品相似的物品。比如，该算法会因为你购买过《数据挖掘导论》而给你推荐《机器学习》。
原理
主要分为两步：计算物品之间的相似度；根据物品的相似度和用户的历史行为给用户生成推荐列表。
物品的相似度
 算法首选计算物品之间的相似度，计算相似度的方法有以下几种：

基于余弦的相似度计算，通过计算两个向量之间的夹角余弦值来计算物品之间的相似性，公式如下：


其中分子为两个向量的内积，即两个向量相同位置的数字相乘。

基于关联的相似度计算，计算两个向量之间的关联度，公式如下：


其中表示用户对物品的打分，表示第个物品打分的平均值。

调整的余弦 相似度计算，由于基于余弦的相似度计算没有考虑不同用户的打分情况，可能有的用户偏向于给高分，而有的用户偏向于给低分，该方法通过减去用户打分的平均值消除不同用户打分习惯的影响，公式如下：


其中表示用户打分的平均值。
预测值计算
根据之前算好的物品之间的相似度，接下来对用户未打分的物品进行预测，有两种预测方法：

加权求和。
用过对用户已打分的物品的分数进行加权求和，权值为各个物品与物品的相似度，然后对所有物品相似度的和求平均，计算得到用户对物品打分，公式如下：



其中为物品与物品的相似度，为用户对物品的打分。
回归。
和上面加权求和的方法类似，但回归的方法不直接使用相似物品的打分值，因为用余弦法或关联法计算相似度时存在一个误区，即两个打分向量可能相距比较远欧氏距离，但有可能有很高的相似度。因为不同用户的打分习惯不同，有的偏向打高分，有的偏向打低分。如果两个用户都喜欢一样的物品，因为打分习惯不同，他们的欧式距离可能比较远，但他们应该有较高的相似度。在这种情况下用户原始的相似物品的打分值进行计算会造成糟糕的预测结果。通过用线性回归的方式重新估算一个新的值，运用上面同样的方法进行预测。重新计算的方法如下：

 其中物品是物品的相似物品，和通过对物品和的打分向量进行线性回归计算得到，为回归模型的误差。具体怎么进行线性回归文章里面没有说明，需要查阅另外的相关文献
下图给出一个 的例子。用户喜欢《中文版》和《编程之美》两本书。然后 会为这两本书分别找到和它们最相似的本书，然后根据公式的定义计算用户对每本书的感兴趣程度。

适用场景
 算法，适用于的更新不频繁，数量相对稳定且数明显小于用户数的场景。在电影，小说等产品的推荐中， 是常用的方法。亚马逊，，的推荐算法的基础都是该算法。
 对应的推荐子策略为 ，需要使用方提供用户的和物品的相关内容。目前子策略在中未实现，不能定制。
优点

可以发现用户潜在的但自己尚未发现的兴趣爱好

有效的进行长尾挖掘

利用用户的历史行为给用户做推荐解释，使用户比较信服


缺点

依赖于用户行为，存在冷启动问题和稀疏性问题

和的区别和应用
算法的特点

用户较少的场合，否则用户相似度矩阵计算代价很大

适合时效性较强，用户个性化兴趣不太明显的领域

对新用户不友好，对新物品友好，因为用户相似度矩阵不能实时计算

很难提供令用户信服的推荐解释


算法的特点

适用于物品数明显小于用户数的场合，否则物品相似度矩阵计算代价很大

适合长尾物品丰富，用户个性化需求强的领域

对新用户友好，对新物品不友好，因为物品相似度矩阵不需要很强的实时性

利用用户历史行为做推荐解释，比较令用户信服


因此，可以看出适用于物品增长很快，实时性较高的场合，比如新闻推荐。而在图书、电子商务和电影领域，比如京东、天猫、优酷中，则能极大地发挥优势。在这些网站中，用户的兴趣是比较固定和持久的，而且这些网站的物品更新速度不会特别快，一天一更新是在忍受范围内的。
参考文献
项亮 《推荐系统实践》
_ 
==
本系列为两年前  云平台的进阶篇，本次借助  的《种玩法》活动来继续完成进阶篇，主要以在  上搭建一个完整的应用环境作为展开，除了需要特殊说明的环境，该系列文章不涉及搭建基础环境包括环境请参阅《  云平台》基础篇相关文章，以下是本次要进行实验的拓扑红色为已完成搭建，蓝色是本次文章涉及的区域：
 
不是说不涉及基础建设，为什么这次还要起个标题叫“应用准备”呢？因为这里的其实是使用《【实验室】在腾讯云上创建您的  故障转移集群》系列文章中所创建的群集，只是做了下改造，主要是以下两点：
、    从 改造成了  具体搭建方法略
、    共享存储由本来的改成即基于文件共享的群集
顺便一提，之前在系列文章中提到的创建弹性网卡只能通过调用创建，在经过了两个月后，通过创建弹性网卡并绑定的功能终于上线了，本篇意在指明从转换成中的关键步骤，还有演示如何从上创建弹性网卡。
，正式开始：
、    首先  同样依赖于所以两个节点在基础群集环境实际上是一致的：
 
、    由于存储改用，所以原来的伪需要改成文件服务器，这次就拿这台文件服务器来演示基于如何创建并绑定弹性网卡，之前弹性网卡界面上创建是灰色的：
 
、    现在的界面是这样的，直接点击绑定网卡：
 
、    选择新建及绑定网卡即可：
 
、    接着就提示绑定成功了：
 
、    界面上就可以看到新建的网卡跟之前的网卡，但是这里还是有槽点的见槽点，作为创建网卡第一版还是可以理解的，但是对于我们目前的网络来说还是不能满足：
 
、    所以这里参照《在上创建您的 》这篇文章，对这台服务器添加服务器一样的配置即分配多一个网卡，中间出现了一个小插曲，原来为了安全起见最新版本的已经对云做了限制，只有有相应授权的用户才可以调用，否则会出现错误具体见这里，要解决这个问题，可以直接将用户添加到超管或者单独给予云即可：
 
、    下面就是涉及改造的第一步了，把仲裁从磁盘改为文件共享仲裁，这里选择高级仲裁设置：
 
、    节点选择所有，群集仲裁配置文件共享见证：
 
、    输入选择文件共享路径作为仲裁盘：
 
、    这就完成了仲裁盘的改造：
 
、    第二个需要设置的是，安装时不再使用方式安装，而是以单机模式进行安装，由于这里采用域验证且是先安装了服务，所以这里输入的账户建议用本地账户：
 
、    单机模式安装 ：
 
、    值得一提的是 支持语言可惜 版没有集成进来：
 
、    为了支持以后的 落地，这里排序事先改为拉丁排序正式环境请勿效仿，正式环境请采用独立数据库来支持相关组件：
 
、    创建完成之后使用进行链接   ，默认不自带，需要额外下载在中可以选择密码身份验证了，故如果有统一跳板机或者网管机的需求，这些中转机器已经可以不用加入到域了：
 
、    槽点：创建弹性网卡仍然比较初步。
大家不知道有没有注意到，有两个地方：
、    在第六步那儿的图绑定实际上只能绑定在同一个网络下，所以多个要分隔不同网络是不支持的比如存储网络作为一个、管理网络作为一个、生产网络作为一个
、    一次最多只能绑定网卡，对于点的网络分离是不现实的

相关推荐【腾讯云的种玩法】构建企业级应用环境之数据层面优化二【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群每天分钟，用去食堂吃饭的时间解决一个知识点。

优化器
今天的内容相对来说清汤寡水一点，就梳理下优化器的内容。没什么复杂的。
数据库拿到我们给的后，会解析成一棵语法树。而优化器做的事情，就是应用关系代数的知识，找出等价的多种计算路径即对这棵树进行数学上等价的变换。这个过程就是我们标题中的查询优化。
那么要衡量不同方案的好坏，就需要我们设计一个代价的评价标准，这就是代价模型。而优化的思路可以分基于代价和基于规则两种。
基于代价需要我们掌握数据库中的统计信息，比如表中的记录数，记录的大小，某个字段中不同取值的数目即选择性的高低等。中会加入直方图。
基于规则就是变换执行计划时，有一些启发式规则。比如尽早执行选择操作，尽早执行投影操作，避免笛卡尔积等。指导思想就是尽早的缩减规模。
好，这一块基本上就这些要点了。我感觉抓住指导思想就显得很清晰，当然去细究细节的话也会很有意思，比如的代价模型是怎么算的，我以前听姜承尧说他觉得 的代价模型有个，这个有兴趣可以一起看看源代码。
连接
顺便复习下做等值时不同的连接方式与代价，通过粗略的估算给大家一个直观的认识。
假设我们有和两张表，现在要做。表的记录数设为，占据的块数设为；表的记录数设为，占据的块数设为。
嵌套循环连接
就是最简单的，以一张表的每一行记录，与另一张表的每一行记录比较。直接来两层循环。我们来估算下代价。
若从表的每行记录出发，那么最坏情况下，块传输次数是×=，搜索次数是=。
若从表的每行记录出发，那么最坏情况下，块传输次数是×=，搜索次数是=。
块嵌套循环连接
一个小小的优化思路是，我每次以块的方式处理关系，这样不就可以减少块读写次数了么。
若从表的每块出发，最坏情况下，块传输次数是×=，搜索次数是×=。与前面相比，思路上小小的变化造就了性能上大大的提升。
索引嵌套循环连接
如果连接的字段上有树索引，设每个节点有个索引项，表记录数为，那么树的高度就是，回表假设再加一次磁盘，此时访问次数为×=，每次访问都有一次搜索和一次块传输。咦，怎么用了索引反而代价更高了？大家注意下，这里只说了表上有索引，如果表上也有索引且有个选择操作的话，行数会大大减少。使用索引会比块嵌套要快得多得多。
好，今天就到这里。
相关阅读十分钟入门关系型数据库一：三范式 分钟梳理关系数据库基础知识二：存储结构分钟梳理关系数据库基础知识三：树分钟梳理关系数据库基础知识四：两阶段多路归并排序在最近的开发过程中，遇到了一个尴尬的问题，外网环境下无法访问内网本地虚拟机的系统中的服务很难将自己做好的网站和页面展示给别人看并接受对方的意见实时进行修改
之前在开发参赛项目的时候有用到过转发进行团队内部的交流，于是在网上搜索了几个的服务，然而用起来都不尽如人意，就打算用上的服务器，试着自己搭建一个的服务器，用于内网穿透。
先介绍一下
  

                           

翻译一下：
是一个隧道，即建立安全通道从公共端点到本地运行的网络服务，同时捕捉检查和重播所有流量的反向代理。
简单来说，他可以代理你本地的数据，并将其转发到外网。
闲话少许习大大教导我们撸起袖子加油干
：安装 和
是啥，是干什么用的，在此我就不过多阐述了！
       
，语言支持，因为是基于语言编写的这里我都已经安装了，没有安装的按照提示安装即可
：获取  源码
此处使用非官方地址，修复了部分包无法获取
    

  

：生成自签名证书
使用官方服务时，我们使用的是官方的证书。自建服务，如果不想买证书，我们需要生成自己的自签名证书，并编译一个携带该证书的客户端。
证书生成过程需要一个__。 以官方随机生成的地址为例，其__就是“”，如果你要 提供服务的地址为“”，那__就应该 是“”。这里呢，我替换成自己的域名 “”这个地方大家也要提前准备好自己的域名没有多余域名的同学呢就可以给自己的域名添加一个二级域名来解决
注意下述指令中的域名要换成大家自己的哦不然就绑定到我的域名上去了
  

 _=

     

           =_  

     

       =_  

              
执行完后

替换：
   
：编译
    
这一步骤等待时间较长，成功编译后，会在目录下找到和这两个文件。

：启动服务端
前面生成的  就是服务端程序了，指定证书、域名和端口启动它证书就是前面生成的，注意修改域名：
   = = = = =
到这一步， 服务已经跑起来了，可以通过屏幕上显示的日志查看更多信息。、 分别是  用来转发 、 服务的端口，可以随意指定。 还会开一个  端口用来跟客户端通讯可通过 = 指定，如果你配置了  规则，需要放行这三个端口上的  协议。
现在，通过  和   大家要访问自己的域名哦 就可以访问到  提供的转发服务。为了使用方便，建议把域名泛解析到  上，这样能方便地使用不同子域转发不同的本地服务。
访问后看到提示：

   

这说明万事俱备，只差客户端来连了。
在服务端为了保证服务的一直启动，可以使用，此处略过
：客户端
单有服务端，你转发什么捏？肯定要在你需要发布内容，服务的设备上安装匹配的客户端啊。在这里，我使用的服务器是，而需要转发的服务器，也是，就省去了重新编译这一环节。
将目录下的  通过的指令下载到当前客户端所在的系统中。
   
上述指令根据服务器信息和本地路径替换
创建一个配置文件：
写入以下内容：

_ “
___ 

注意：这里的_换成前面配置的自签名证书中的域名
另外，这个域名请提前解析到服务器，参考如下：

接下来只需要指定子域、要转发的协议和端口，以及配置文件，运行客户端：
   = = 
如果没有错误，就会出现下面的界面

这表示转发成功，转发后的端口号，是在服务端中设置的端口号，转发为你填写的本地端口号。
在本地环境访问 也可以查看该端口转发下的请求

一个简单的转发就配置好了，只需要一个外网服务器和域名，就可以轻松的将你所有的内网服务器虚拟主机转发到外网。
如果想要了解如何在下使用服务可以参考这篇文章编译下客户端和相关配置

相关推荐
【腾讯云的种玩法】编译下客户端和相关配置
高性能高稳定的弹性伸缩计算服务本篇文章是我在读期间，对自然语言处理中的文本相似度问题研究取得的一点小成果。如果你对自然语言处理     和卷积神经网络   有一定的了解，可以直接看摘要和创新与技术实现部分。如果能启发灵感，应用于更多的现实场景中带来效果提升，那才是这篇文章闪光的时刻。如果你没有接触过和，也不在担心，可以从头到尾听我娓娓道来。有任何问题，欢迎交流。
 摘要
，即基于词汇语义特征的跳跃卷积模型         ，基于卷积神经网络模型引入三种优化策略：词汇语义特征    、跳跃卷积   和均值采样     ，分别在词汇粒度、短语粒度、句子粒度上抽取更加丰富的语义特征，从而更好的在向量空间构建短文本语义表达模型，并广泛的适用于问答系统  、释义识别   和文本蕴含  等计算成对儿出现的短文本的相似度的任务中。
 从词向量到文本向量
人类的语言，是人类独有的进化千百万年后形成的信息表达方式。相比于具有原始信号输入的图像像素和语音声谱，符号化的自然语言属于更加高层认知的抽象实体。因此，自然语言处理的第一步也是至关重要的一步就是怎样将符号化的自然语言表示成计算机可以理解的数值形式。
对于自然语言的理解，在语言粒度上遵循着自底向上从字、词、句、段落最后到篇章的研究思路。在对最小粒度的字的符号化表达上，基本可以分为两种： 和  。

 是将所有的词构建成一个词典，每个词对应一个索引，该词对应的索引位为，其他位为。例如，词典为{  }，那么就可以表示为，就表示成。这种方式有两个缺点：一是维数灾难；二是语义鸿沟，任意两个单词都是正交且孤立的，无法表征词语间的相似性。即便如此，配合传统的最大熵、等算法也很好的实现了中各种主流任务。
  在深度学习  方法中较常用，通常中文翻译成词向量，或者词嵌入  。它用低维实数变量常用的有维，维，维来表示词典中的每一个词。这种方式相比于 最大的优点是在向量空间上，可以将词语之间的语义相关关系映射成如欧式距离等距离量度上的大小关系。现有的词向量训练的方法都是在用神经网络训练语言模型的同时，顺便得到了词向量。如果对词向量非常感兴趣，可以参考

在大多数的任务中，如情感分类、机器翻译、问答系统等，都需要以自然语句作为输入。那么，怎样以词向量为基础，表达一个短语或一句话的语义呢？短语或者句子能否也通过向量的形式表达？答案是肯定的。在深度学习框架下，有许多神经网络，如卷积神经网络、递归神经网络 、循环神经网络 等，都可以将词向量序列有效的编码成短语或句子向量。

 通常自底向上地基于语法解析树的结构逐层生成短语、句子的向量表达，同时受限于生成语法解析树的准确率。
 通常应用于具有时序关系的序列问题，并假设一个序列当前的输出与之前的输出有关，神经网络会对前面的信息进行记忆并应用于当前输出的计算中。
在多种任务中，被证实在同时从语法和语义两个层面学习句子向量表达上表现突出，独有的卷积操作使其可以学习到在文本长序列中具有稳定表达方式的短序列的特征，而与其出现位置无关。

 短文本相似度计算的现有解决方案
通过神经网络学习到的短语或句子向量就可以进一步应用于以短文本相似度计算为核心的多种任务中，如问答系统中的答案选择问题  ，，即从输入问题的特定候选答案列表中，筛选可以回答问题的正确答案，本质是一个二分类问题预测为正确的答案标记为，错误的答案标记为。再如，释义识别任务，即判断两句话是否表达同一种语义。
目前，基于模型的短文本相似度的计算方法可以大致分为两类：一类是基于结构的神经网络模型，先分别学习输入的文本对儿的句子向量表达，再基于句子向量计算相似度；另一类是直接以词语粒度的相似度矩阵作为输入，学习并计算文本相似度。下面将分别展开介绍。
 基于结构的神经网络模型
这里列举最近两年比较有代表性的两篇文章。
如下图所示，是发表在年上的文章，并用于上的两个任务：答案选择和微博检索。以答案选择任务为例，从左至右，作者采用上下并行的双通道浅层模型来分别学习输入的问题和答案的句子向量表达，然后经过相似度矩阵计算相似度，全连接层和隐藏层进行特征整合和非线性变换，最后层来输出输入候选答案被预测为正确或者错误的概率。左半部分的双通道即可理解为学习从词向量到句子向量的表达模型。

如下图所示，是发表在年的文章，同样应用于答案选择任务，并在两个公认基准数据集和上进行了测试。文章的核心想法是采用双通道来抽取输入问题和答案之间的相似性与不相似性，整合成最终的句子向量并计算相似性。

 基于词语粒度的相似度矩阵直接学习并计算文本相似度
如下图，在其文章中直接基于词向量计算输入文本对儿在单词粒度上的相似度计算方式有多种：欧式距离、余弦距离、参数化的相似矩阵，并以此为后续深层卷积神经网络的输入，最终学习得到的向量经过全连接层和层进行预测。

 模型创新与技术实现
有了前面在深度学习框架下，文本向量学习的背景和基于短文本相似度的现有方法的总结和介绍，终于进入本篇文章的重头戏，模型的介绍。模型延续了基于结构神经网络模型构建短文本表达模型的总体思路，但通过引入三种优化策略：词汇语义特征    、跳跃卷积   和均值采样     ，分别在词汇粒度、短语粒度、句子粒度上抽取更加丰富的语义特征，并在答案选择计算短文本相似度问题上取得了非常好的效果。

下图展示了的整体框架图，自底向上，模型由个模块组成：对于输入的问题和候选答案，我们利用词汇语义特征技术为每个单词计算特征值，以此来表征问题与答案之间的语义交互特征。特征会和词嵌入拼接在一起构成词语粒度上更加丰富的特征表达，表达词的向量再次拼接构成句子矩阵。问题和候选答案的句子矩阵经过跳跃卷积层和均值采样层，最终形成对问题和答案各自的向量表达，记作和 。和会根据学习得到的相似度计算矩阵得到一个相似度分数。最后，相似度分数和、整合一起作为分类器的输入，最终得到输入候选答案被预测为正确答案和错误答案的概率。接下来，我将一一介绍三个优化技术的实现细节。

 词汇语义特征技术  ，

技术提出的原因：基于的神经网络结构有个缺点就是将输入的文本对儿看做互不相关的句子，相互独立的用同一套神经网络结构去学习文本的向量表达。但是在短文本相似度相关任务中，如问题和候选答案，往往是文本对儿间在语义、词语表达、语序等方面存在关联，而前人方法忽略了这点。少部分学者注意到了这点，但目前所用方法局限于：借助额外知识标记近义词反义词、上位词下位词等关系；或者引入字符串匹配信息，严格匹配标记为，其余为。因此，本文提出的技术是一项用来构建问题与答案之间的语义交互特征的技术。

核心想法：技术将词语粒度上的相似性量化细分为个相似度，从而建立输入文本对儿之间的语义关联，为后续神经网络提供更加丰富的语义特征输入。

技术可行性分析：技术将词语粒度上的相似性量化细分为个相似度，不仅可以包含前人提出的近义词、反义词关系，如和的为， 字符串匹配如和被标记为，也可以涵盖更多的相似性。例如，和不是近义词，在字符串上也无法匹配，但可以捕捉到他们之间有的相似度，而正是回答该问题的正确答案，




特征怎样计算得到？问题和答案中的每一个单词都会有一个特征，具体来说是一个上的整数值。的计算过程可通过下面一个例子说明，当我们想要求解问题中一词的特征时，第一步我们需要计算与答案中每一个词的余弦相似度并选取其中的最大值，因此被选取出来。第二步，余弦相似度值的最大值将通过一个映射函数映射为一个，区间的整数，当我们假定=，最终计算得到的特征为。这是合理的，和一定程度上是近义词。


 跳跃卷积技术 ，

技术核心想法： 在短语粒度上，我们提出跳跃卷积技术。下图展示了以     为例，设定卷积窗口长度为时，且步长为跳跃一次，跳跃卷积方式在传统卷积方式上的改进：



传统卷积方式将取得如下短语特征：{           }
跳跃卷积将取得如下短语特征{                                    }。

的技术实现：如上图所示，左侧传统卷积方式将卷积窗口作为一个整体，自左向右每次移动一个单词的步长进行卷积操作。相比而言，跳跃卷积则是同样自左向右每次移动一个单词的步长，但移动的并非卷积窗口的整体，而是整体中的一列。例如，上图右侧，初始卷积抽取了短语“   ”紫色框的特征；而后将覆盖在“”上的卷积窗口的那一列向右移动一个单词的步长，从而得到短语“   ”蓝色框的特征；接着，将覆盖在“”上的一列向右移动一个单词的步长，从而得到短语“   ”绿色框的特征，以此类推。

技术可行性分析：传统卷积方式只允许在特定大小的卷积窗口中对相邻的词语进行卷积，而跳跃卷积可以通过跳跃停用词如、形容词等，在特定大小的卷积窗口中将抽取到包含更完整更浓缩的主体语义信息的短语特征如‘   ’，从而提升了短语粒度上特征的丰富性。虽然，跳跃卷积相比于传统卷积方式，也会额外抽取到许多无用的短语的特征。但实验结果证明，跳跃卷积技术对增加短语特征丰富性的帮助，要大于额外增加的无用短语特征带来的噪音的影响。


技术实现可以参考。的文章应用于情感分类   和新闻分类   任务，而本文应用于答案选择任务。
 均值采样技术  ，

均值采样提出的背景：卷积神经网络中的池化层，也称采样层，主流有两种方法：最大值采样   和均值采样  。但上述两种方法也存在一定的局限性，由此，  提出了对于最大值采样的一些改进技术，提出了动态采样技术。

均值采样的核心思想：本文提出的均值采样技术结合了最大值采样和均值采样。具体而言，对于卷积层传入的特征矩阵 ，采样技术选取其中最大的前个值，并取其平均值作为最终的采样结果。均值采样的好处，一方面可以减少异常噪音点的影响，另一方面可以保留表现比较强的特征的强度。虽然想法简单，但实验证明对模型的提升效果较好。


 实验结果
 实验数据
本文在两个公认标准数据集和设计全面的实验。下图展示了两个数据集的一些统计信息。

两个数据集有以下两方面区别：

候选答案从文档库中抽取出来，而候选答案来自日志被查询的问题所返回的链接列表，筛选出被五个不相同的用户点击过的链接，并从选中链接的摘要中抽取答案，因此更加真实、更能反映用户的真实查询意图。
候选答案要求至少与问题有一个非停用单词，而中的答案与问题不存在相同单词，因此对技术提出了更高的挑战。

 实验结果：
下面两个表格分别展示了模型与前人方法在和两个数据集上的效果对比，由此可见，模型相比于当前最好的方法，在和两个指标上，对数据集提升了，对数据集提升了。答案选择问题的比较高，所以的提升效果还是非常显著的。

 总结
本文主要介绍了模型，即基于词汇语义特征的跳跃卷积模型         ，基于卷积神经网络模型引入三种优化策略：词汇语义特征    、跳跃卷积   和均值采样     ，分别在词汇粒度、短语粒度、句子粒度上抽取更加丰富的语义特征，从而更好的在向量空间构建短文本语义表达模型，并在答案选择   问题上进行了实验验证。
其中词汇语义特征技术可以更广泛的应用于基于神经网络结构学习文本对儿间向量表达的相关任务。跳跃卷积技术和均值采样技术更广泛的使用于存在卷积层和采样层的神经网络结构中。三种技术既可以根据需要单独使用，也可以相互助益共同提升模型整体效果。

原文：==本文转载于全球人工智能微信公众号邹成卓，腾讯武汉研发中心前端工程师，从事前端、服务端开发工作。关注前端工程化与 服务相关技术，个人网站： 。

面向公网的服务或者接口服务可能会面临黑客的攻击，故一些基本的安全案例在上线之前要过一遍，本文记录一些简单的安全漏洞，后续发现陆续补充。
越权访问
漏洞场景
类似于格式的路由，要特别注意越权访问的问题
例如是属于用户的资源，但是后台没有对资源从属关系做验证，导致恶意用户登录后也可以通过此链接访问到资源
解决方案
此漏洞比较低级，但是也是一个需要注意的点。 开发类似的资源接口时，注意一下做身份校验就可以了。
服务器路径泄露
漏洞场景
有时候服务端对错误信息处理不当，在生产环境中和开发环境一样，把错误的和调用栈同时打印出来，会暴露服务器内部的路径。
这样的漏洞本身不会导致什么危害，但是若与其他漏洞结合，容易导致黑客推断出服务器内部的具体情况，所以一般也会被认为是一种安全漏洞。
解决方案
为生产环境开发一个友好的报错界面，只显示错误，不要显示错误信息堆栈。

漏洞场景
富文本  含有用户编辑富文本页面为重灾区，是典型的存储型场景。 用户编辑了一段含有代码的内容存放于，渲染到页面上展现给其他用户时，若用户内容出入时都没有做好过滤的措施，就会导致其他用户面临攻击的风险。
页面直接显示参数中的内容
比较典型的例如查询参数、页码参数等。类似于==
若页面上对或者处理不当直接渲染在页面上，则容易导致反射型攻击
解决方案
要注意的一点，现在很多浏览器已经可以自动拦截部分攻击代码了，但是这并不意味着我们就可以不处理，因为不能保证所有用户都用了先进的浏览器。

在调试的时候可以给接口加上    这个来允许浏览器运行代码。
过滤的规则比较繁杂，可自行之。有一些开源的组件可以很方便的用来处理问题，例如： 

漏洞场景
如果不注意防范，很容易被攻击。
请求
若用户的敏感操作是一个请求，如== ，此时攻击者在钓鱼页面中插入一个标签，的值是== 。攻击者将此页面发送给网站的用户，若用户已经登录，则敏感操作将成功。
请求
请求做敏感操作实际上是很低级的错误。那么使用请求就很安全了吗？ 也不是的，攻击者可以在钓鱼页面中伪造表单，若 用户已经登录，照样会被攻击，像下面的代码一样

 = =
     = = = 
     = = = 
     = =  

用户进入攻击页面后，攻击者可以自动提交表单，若用户已经登录了 则请求依然会成功
解决方案
检查
检查下请求的，根据地址来判断是否接受请求
添加 
在中写入一个随机生成的 ，用户请求的时候这样构造表单
 = =
     = = = 
     = = = 
     = =_ = 
     = =  

这样攻击者在伪造表单的时候，是没办法获取 随机值的——除非网站还有漏洞，攻击者可以拿到用户的。因此中的 建议是写成 的，那样会更为安全一点。
为了更简单的处理此类问题，还可以考虑在页面中使用封装好的库，然后在全局配置的请求中加上，后端验证的时候也从中去取。
开发 的话，可以用一些开源的模块来快速处理此类问题，例如模块：
注入
注入的场景比较多，这里记录一下我所了解到的场景和防范方式吧，后续补充。
漏洞场景
客户端字符未经处理
这种方式的注入在远古时代的应用中比较常见，现在的应用一般不会出现这样的低级注入问题。
例如     =  =
假如字段是直接使用用户输入字符做拼接的，那么可以输入  = ，来让语句变成
     =  =   =`
这样就可以非法获取用户数据了。
注入
参见 
解决方案
首先客户端填写的参数是绝对不能未经处理直接拿来拼接语句的，如果是手动拼接，要注意替换下面这些符号：

\\\\\\
\\\
\\\
\\\
\\\
若不是手动拼接而是使用的框架，则一般框架会自己去处理注入的问题。
而注入，一般容易出现在分页等场景中，此处要注意的就是、、等参数一定要做数字类型校验及大小校验。
上传文件类型绕过
漏洞场景
上传文件时，需要注意限制用户上传的文件类型，如只接受图片等。判断文件类型的时候，有时候只会去判断文件后缀名是否合法，此时会有文件类型绕过的风险，攻击者将文件后缀名修改之后上传，即可绕过服务端对文件类型的检测
解决方案
一般来说不仅仅要检查文件后缀名，还需要根据文件头的前几个字节来判断文件的真实类型，对应关系可以参考百度百科：
若是应用，可以用此模块来判断：
响应头注入
漏洞场景
用户输入的参数未经处理直接在的响应头中出现，由于报文是用\\来分隔和的，攻击者可能在参数中插入\\来截断原本的报文，构造任意响应
解决方案
在用户输入的响应头中过滤回车换行符
实际上，参数中包含—— 的控制字符时都是不合法的，可以对其进行删除

相关推荐
全新的跨平台调试工具成勒索新目标，数据服务基线安全问题迫在眉睫前言
由于 是弱类型，所以在大型项目中使用时显得能力略有不足。从七月份在腾讯实习到现在，接触到了不少项目的代码，平均算来每天都有  的时间用于阅读、理解他人的代码。每次阅读他人代码的时候，我心中都会冒出来两个强烈的愿望：要是 是强类型的多好！要是文档能再详细一点就好了！多亏了 和 ，这两个愿望都有变成现实的可能。
 立即上手
使用 的最佳方式肯定是直接使用它的语法来编写  文件，然后通过编译器转换成  文件。然而对于老项目而言，切换构建往往意味着麻烦和巨大的风险，而且假如将来 也引入了类型系统这非常有可能，那又得从 切回 回归标准。那么有没有一种无痛的方式，让我们既可以享受 带来的好处，又能不改变项目的现有构建方式呢？
答案就是  ，在  文件的头部引入这样一行注释，就可以使用 了。
举个例子，在下图中我们首先声明了一个变量 ，然后把数字  赋给了它，接着又把字符串  赋给了它，看起来好像没有什么问题。

未使用 
现在让我们加上 ，咦，怎么  下面出现了红色的报错？把鼠标移到  处，发现报错是       ，也就是说在 中这种把字符串  赋值给数字变量  的做法是不妥的。

使用 
享受 类型系统的好处就是这么简单，不需要改变构建，不需要进行项目的迁移，所需要做的仅仅是在  文件的头部加入  前提是你使用的是  ，不过其它的编辑器下载相应的插件即可。
 添加类型
如果仅仅使用  的话，我们只能使用它的自动类型推断功能，这对于大型项目来说是远远不够的，我们希望能像强类型语言一样指定每个变量的类型。本着不对项目产生侵入的原则，可以通过  风格的注释来完成这一点。接下来的举例说明取自官方的文档：

  使用  来声明类型
   {}
 
 

  {} 
 


  用 “” 说明函数的返回值类型
   {}
 
  {}


  可以像使用  一样使用 
   {{   }}
 
  {}


  可以指定  类型，如字符串或者布尔值
   { | }
 
 


  声明元素类型是数字的数组  方式
   {}
 
 


  声明元素类型是数字的数组  方式
   {}
 
 


  声明元素类型是数字的数组  方式
   {}
 
 


  声明对象类型
   {{   }}
 
 


  用  自定义复杂类型
   {}   创建一个新的类型 
   {}    属性  是  类型
   {}    属性  是  类型
   {=}    属性  是可选的  类型
   {}    属性  是可选的  类型
   {} =   属性  是可选的  类型默认值 
 
  {} 
 



  声明函数参数类型
    {}   风格声明 
   {}     是  类型参数
   {=}    是可选的  类型参数
   {}   另外一种可选参数写法
   {} =   是可选的  类型参数默认值为 
   {}  函数返回值是  类型
 
     {
   
}


  也可以使用模板来声明类型
  如  表示返回值和参数  是相同类型
   
   {} 
   {}
 
 {}
写在最后
对于老项目，使用   和  引入 来享受类型系统的好处是最简单、学习成本最低的方法。对于新项目，相较于激进地使用  文件，我认为   和  是更好的方法，因为 在不久的未来很有可能会引入可选的类型系统类似于 ，到时候可以避免再从 回归 。
参考链接

   
    背景
今天处理了下放在腾讯云的网站的服务器的一个小问题。
由于我把简历放在了上了，但是本人又不甘心只能墙外人看到，因此就通过墙内腾讯云服务器，配置了做了反向代理到了我的简历网站。
不过由于墙内的原因，有的时候并不能很好的通，甚至出现无法找寻的情况。而墙内服务器按照运维规范，我设定了定时重启的定时计划任务。有的时候就出现上面的域名的这个问题就会导致反向代理的配置无法通过审查，从而引起重启失败只能关闭而不能启动而造成网站无法访问。这很尴尬。
之前每次出现这个问题，只能登陆服务器然后手工重启，这不，今天又出现这个问题了，为了一劳永逸，今天写了个脚本替换了之前的老旧的重启命令。
 主要步骤

在服务器某个安稳的地方写一个脚本。例如新建文件夹，在其下撰写一个_脚本。
进入文件夹，执行 _命令，编写脚本，内容如下：
 
=__ 此处需要替换成自己需要的地址
=`  `
       
      此处需要替换成自己在通后执行的命令

     这是失败后进行的时间戳记录，此处可以替换或添加为自己在不同时执行的命令
            _

 将_脚本转为可执行权限：
   _
 或者
   _
 执行测试，查看脚本是否有错：
 _

输入 ，对定时计划任务进行编辑，添加如下命令。
       _
 关于命令，请见下一小节“ 关于命令的相关小结”。

完成


 关于命令的相关小结
通过 命令，我们可以在固定的间隔时间执行指定的系统指令或  脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。
       定时任务 _
 命令格式

         |  |  

 命令参数

 ：用来设定某个用户的服务；
：是命令文件的名字表示将做为的任务列表文件并载入。如果在命令行中没有指定这个文件，命令将接受标准输入键盘上键入的命令，并将它们载入。
：编辑某个用户的文件内容。如果不指定用户，则表示编辑当前用户的文件。
：显示某个用户的文件内容，如果不指定用户，则表示显示当前用户的文件内容。
：从目录中删除某个用户的文件，如果不指定用户，则默认删除当前用户的文件。
：在删除用户的文件时给确认提示。

 的文件格式
分 时 日 月 星期 要运行的命令

第列分钟～
第列小时～表示子夜
第列日～
第列月～
第列星期～和表示星期天
第列要运行的命令

 常用方法
创建一个新的文件
向进程提交一个文件之前，首先要设置环境变量。进程根据它来确定使用哪个编辑器编辑文件。  的和用户都使用，如果你也是这样，那么你就编辑目录下的 文件，在其中加入这样一行
=  
然后保存并退出。不妨创建一个名为 的文件，其中是用户名，例如， 。在该文件中加入如下的内容。
           
     
        
保存并退出。注意前面个域用空格分隔。
在上面的例子中，系统将每隔 分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的文件，可以把这个新创建的文件作为命令的参数
  
现在该文件已经提交给进程，它将每隔 分钟运行一次。同时，新创建文件的一个副本已经被放在目录中，文件名就是用户名即。
列出文件
使用参数列出文件
  
      ``  
可以使用这种方法在目录中对文件做一备份
    
这样，一旦不小心误删了文件，可以用上一节所讲述的方法迅速恢复。
编辑文件
如果希望添加、删除或编辑文件中的条目，而环境变量又设置为，那么就可以用来编辑文件
  
可以像使用编辑其他任何文件那样修改文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， 会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。 我们在编辑文件时，没准会加入新的条目。例如，加入下面的一条：
          
          {} \
保存并退出。

最好在文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的定时作业。

删除文件
 
 使用实例
实例：每分钟执行一次
     
实例：每小时的第和第分钟执行
     
实例：在上午点到点的第和第分钟执行
     
实例：每隔两天的上午点到点的第和第分钟执行
       
实例：每周一上午点到点的第和第分钟执行
     
实例：每晚的重启
      
实例：每月、、日的  重启
      
实例：每周六、周日的  重启
      
实例：每天  至  之间每隔分钟重启
      
实例：每星期六的晚上   重启
      
实例：每一小时重启
      
实例：晚上点到早上点之间，每隔一小时重启
      
 使用注意事项
注意环境变量问题
有时我们创建了一个，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在文件中没有配置环境变量引起的。
在文件中定义多个调度任务时，需要特别注环境变量的设置，因为我们手动执行某个任务时，是在当前环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。
不要假定知道所需要的特殊环境，它其实并不知道。所以你要保证在脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下点：

脚本中涉及文件路径时写全局路径；

脚本执行要用到或其他环境变量时，通过命令引入环境变量，如
  _
 
  
  _=_
    

当手动执行脚本，但是死活不执行时很可能是环境变量惹的祸，可尝试在中直接引入环境变量解决问题。如
        ___


注意清理系统用户的邮件日志
每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。 例如，可以在文件中设置如下形式，忽略日志输出
        
“ ”表示先将标准输出重定向到，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了，因此标准错误也会重定向到，这样日志输出问题就解决了。
系统级任务调度与用户级任务调度
系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成不建议这么做，但是反过来却不行，用户的任务调度操作可以通过” – –”来设置，也可以将调度任务直接写入文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到文件，即使在用户下创建一个定时重启系统的任务也是无效的。
其他注意事项
新创建的 ，不会马上执行，至少要过分钟才执行。如果重启则马上执行。
当失效时，可以尝试 解决问题。或者查看日志看某个有没有执行报错  。
千万别乱运行 。它从目录中删除用户的文件。删除了该用户的所有都没了。
在中是有特殊含义的，表示换行的意思。如果要用的话必须进行转义，如经常用的 ‘’在里是不会执行的，应该换成 ‘’。
更新系统时间时区后需要重启在中服务名为
  
下启动、停止与重启
  
  
  
 参考文献

      定时任务 _


相关推荐
腾讯云下从迁移到过程
【腾讯云的种玩法】  升级与实战练习与笔记
云上安全新保障作者 | 钱坤编辑 | 京露

钱坤，腾讯后台开发工程师，从事领域为流媒体相关，参与腾讯平台开发维护。

原文是《    》。这篇文章是年的文章，里面介绍了一些在内容分发网络中的算法研究，下面对论文中的这些算法进行简单的总结。水平有限有限，有理解错误的还望指正。
：并不是所有的算法都已经投入到了实用阶段。
 
 的研究主要用在的中的两个场景：索引管理优化；内容过滤。
 是算法的一个变种，有非常优秀的空间效率使用位数组和时间效率插入的时间复杂度稳定为常数，但是会有一定的错误率。直观的说，算法类似一个 ，用来判断某个元素是否在某个集合中。和一般的 不同的是，这个算法无需存储的值，对于每个，只需要个比特位，每个存储一个标志，用来判断是否在集合中。其基本算法如下：
首先需要个函数，每个函数可以把散列成为个整数
 初始化时，需要一个长度为比特的数组，每个比特位初始化为
 某个加入集合时，用个函数计算出个散列值，并把数组中对应的比特位置为。
 判断某个是否在集合时，用个函数计算出个散列值，并查询数组中对应的比特位，如果所有的比特位都是，认为在集合中。
通过一系列的数学证明，可以得出最优函数个数、位数组的位数、存储的最元素数关系如下：

再通过一系列的数学证明，可以得出正向错误率、位数组的位数、存储的最元素数关系如下：

根据这两个公式，可以进行参数调整以达到预期目标。 的主要场景如下：
索引管理优化：有些系统的索引查询可能由于访问慢设备导致查询操作较慢，可以在索引查询之前用使用 搭建一层索引提升索引查询速度，如果 中无法查到该文件，则认为该文件不存在，如果 中可以查到该文件，则请求索引系统。在这种场景中由于存在元素删除操作， 不能使用位数组，每一位需要用一个数字变量来代替，当多个文件共用一位时使用递增。
内容过滤：统计了一个 两天中文件访问次数，如下图，可以发现，在总共亿左右的文件中，有的文件仅被访问过一次，文件访问次数少于次。

仅有单次访问的文件是没有必要落盘的，对于这种文件落盘会占用磁盘和存储，并且可能会将更热的文件挤掉，进而降低命中率导致回源带宽增高。
以此为基础，实现了“ ”算法，即文件被第二次访问才落盘，而记录是否有过第一次访问所使用的算法就是 。
由于上被访问的文件数趋近于无穷，所以可以使用两个 交替来记录文件第一次被访问，当第一个 已经到了能记录的上限，就使用第二个 ，如果第二个也到了上限，则清空第一个 重新使用第一个，每次查询文件是否曾经被访问需要查询两个 。
实现了这个组件之后在测试环境进行了测试，从下面的测试结果来看，测试环境缓存命中率从上升到了，磁盘写数据量下降了，磁盘操作时延下降了。



稳定分配问题
稳定分配问题的研究主要被用于全局负载均衡。
在中的网络中可以抽象出两个概念。
 ， 包含两个元素，第一个元素是用户的集合，第二个元素是 的类型比如、等
 ，的服务器集群最小单位是，一个中包含若干服务器。通过对 和 进行稳定分配，可以实现全局负载均衡。
对算法进行研究拓展以用于解决全局负载均衡问题。标准的算法是被提出用来解决“稳定婚姻问题”的：为个男性和个女性互相找到最合适的配偶。算法的基本思路为，先对所有男士进行落选标记，称其为自由男。且每个男士和每个女士均有一份排序，在排序中标记心仪的异性排名。当存在自由男时，进行以下操作：
每一位自由男在所有尚未拒绝她的女士中选择一位被他排名最优先的女士；
每一位女士将正在追求她的自由男与其当前男友进行比较，选择其中排名优先的男士作为其男友，即若自由男优于当前男友，则抛弃前男友；否则保留其男友，拒绝自由男。
若某男士被其女友抛弃，重新变成自由男。
把这个算法基于以下的点进行拓展用于对 和 进行匹配，也就是全局负载均衡。
 和 数目并不相等。在正常的场景中， 的数目是要多于 的数目。
排序列表可以不完整。没有必要建立一个 到所有的 的性能分数排序，只需要选择出该用户组可能被调度到的服务器集群并进行打分排序即可。
每个 拥有不确定的任意的容量。估算 的容量，并让它为多个用户组进行服务。
有了拓展的算法作为框架，再对机器的资源进行细化，一个 中一台机器的资源可以具体分为两种：网络资源和非网络资源如内存、能力等。网络资源消耗用来表示，非网络资源消耗用来表示。那么可以用如下一个分层的资源树来对一个机器的资源进行表示：

 代表机器的可用网络资源为， 代表机器可用的非网络资源为，叶子节点代表不同的请求类型可以使用的上限。
如果这时收到单位请求，每单位请求占用和，那么资源树剩余资源如上图中蓝字所示， 剩余， 剩余 ， 剩余 。
假设接下来收到单位的请求，每个请求消耗和，总共需要消耗和，这时发现当前机器的资源不足以承受全部的请求，这时会根据用来评估客户端和服务器的服务性能的组件的输出判断该和哪种 之间有更好的性能，如果结果是更适合于服务新来的请求，则按照算法会驱逐单位的旧请求，并接纳新来的请求。反复进行这种驱逐操作可以让全局实现最优分配。
感觉这个算法在具体的实现细节上还存在着很多挑战。
一致性
一致性的研究被用来实现的局部负载均衡。感觉一致性应该和有着千丝万缕的联系，比如两者都是来源于，一致性的提出人曾经在工作等等。
当用户被分配到一个 之后，需要尽可能通过一致性将同样的文件请求尽可能的到某台已经在中缓存了该文件的机器上。所以可以通过一致性提升命中率，来达到提升性能和增加资源有效利用率的目的。
关于最基本的一致性算法网上有很多讲解，一致性解决了当分布式系统中某台 掉了或者新加入一台可能会导致所有内容要重新洗牌的问题。并引入虚拟节点来优化算法结果。这些内容网上有很多，就不在重复了。下面说一些论文提到的对于一致性的特性化改造：
对于热点文件，为了防止请求压在服务器组内同一台机器上，需要将一个热点文件映射到台服务器上进行分流，比较方便的方式为将文件映射在原本的出来的机器上以及之后的台机器上。不同的热点文件集合在做一致性的时候，需要变换桶的排列，以防止由于值接近导致不同文件所映射的台机器大部分重合，从而导致机器高负载的问题。
用户所使用业务也是做一致性需要考虑的输入之一。对于一个在上注册的业务，会得到一个或多个统一分配的序列号，可以按照序列号对对象存储，并将对于同样序列号的不同文件请求到同一个机器或集合，以尽可能满足某些客户端复用连接下载多个对象的需求比如尽可能的把同一个界面上的小对象存储到一台机器上。
 与数据一致性
即使两个机器上的运行程序完全相同，由于运行时的分别独立收集输入数据可能导致输出结果不相同的情况，这种情况需要 来在服务器组里选择一个来向其他的服务器分发运算结果，以统一输出。的选择过程中会遇到数据一致性的问题，这种一致性的问题可以通过或者算法来解决。我找到以下的两个地址，感觉对两个算法讲的比较容易理解：
：和分布式系统
：  
 有两种：
  ：至少要选择一个。
  ：最多只有一个被选择出来。
比如当网络出现问题导致一个集群出现两个子网，如果使用  类的算法不会允许选择出两个，而是选择宁可放弃选举的过程，使用比较旧的决策数据。比如用户组划分的过程，如果网络中出现两份用户组划分的结果，会引发全局负载均衡运算出现问题，所以在这种情况下不能选举出两个，宁可使用旧一点的用户组划分结果。

相关推荐
图片流量节省大杀器：基于的自适应图片技术实践发布更新文章、提交审核评论自动清理腾讯云缓存不断更迭创新的云计算技术一直激发着开发者的热情。作为腾讯云开发者生态建设的一部分，在月日腾讯“云未来”上海峰会开发者专场上，腾讯云邀请技术专家进行了一场围绕电商行业的云端架构与开发的主题分享，帮助开发者快速了解电商行业如何在云端构建业务。同时，腾讯云“云创业”计划也在上海对开发者发起新一轮招募，激励广大开发者的创新思维落地。

唐良：云端架构给电商行业带来创新力


腾讯云电商行业资深架构师唐良以电商行业的发展为例，讲述了云端架构升级为企业开发与业务创新带来的全新价值。唐良表示，腾讯云帮助电商企业从自建的数据中心一步步成功迁移到云端，从最开始的弹性上云、到数据库上云，到数据同步，再到混合云。继而当电商客户越做越大后，该企业也将自己的大数据平台建立在腾讯云的黑石服务器上，实现了高性能计算，从海量数据分析中获取洞察。同时腾讯云的服务器为该企业提供了机器学习的能力。此外，腾讯云的云监控服务保证了系统的可用性与稳定性。数据表明，该企业的最后支付体系，由于放在腾讯云上，通过微信支付的速度比非腾讯云客户快了，这对电商企业来说是一个巨大的优势。

腾讯云电商行业资深架构师针唐良
唐良还分享到，腾讯云的数据中心已遍布亚洲、欧洲、美洲等全球地区，数据中心之间也由腾讯云自有的专线打通连接，能够灵活快速地满足客户的架构部署与升级。针对电商行业“羊毛党”的问题，企业基于腾讯云，利用人工智能技术，通过用户手机设备或社交账号信息信用记录的分析，能大大降低“褥羊毛”对企业带来的损失。基于腾讯云的天御，同城收到的恶意消息减少了，东鹏特饮也借由天御一年节省了三千万费用。同时，唐良还介绍了电商企业接入腾讯云后的进阶服务——电商业务的创新玩法。蘑菇街基于腾讯云在里开创了“红人买手直播间”。用户可通过网络红人视频直播推荐的服饰与搭配，直接进行互动选购，这相较于传统的电商购买模式，人与人的距离被拉近，用户购买体验也大大增加。截至到今年月，直播间综合收入是去年十一的倍，红人主播单场交易额，也达到了万。

白辉：电商转型难题，看云如何破题


蘑菇街电商技术架构师白辉分享了蘑菇街从导购到垂直电商的转型历程，揭示了电商应如何破解技术架构老旧与业务野蛮增长的难题。 蘑菇街电商技术架构师白辉
在发展过程中，蘑菇街“社交游戏化”导购平台的定位导致了数百款轻量级、零碎化的社交游戏使得系统难以维护。而越发复杂的业务生态也使得蘑菇街必须向沉淀用户数据转型。为保持陡峭曲线性的业务增长，蘑菇街搭建出集中化的系统架构，以最低的成本支持众多业务需求的快速交付，以满足在控制开发与维护成本的基础上快速响应产品需求。
此后，在业务量激增带来的挑战下，蘑菇街自研等新的中间件，并对服务框架进行了配套升级，以保证产品迭代速度和平台稳定性。白辉称，当电商业务体量达到几百亿调用量的阶段，基础服务中间件的改造就至关重要。在引入系列中间件之后，蘑菇街获得了业务层面上的解耦，商品、交易逐步完成服务化，创造了基础的用户服务、交易服务以及支付服务，并针对不同的业务保障级别搭建相对应的链路集群，保证流畅稳定的客户体验。年，蘑菇街的服务可用性达到了。
 而在从垂直电商转型为电商平台的新战略阶段，电商平台的技术架构需向更深层次的积木式、无状态、云化发展。利用、、小程序等前端组件和后端的数据做灵活绑定；关注不同平台的定制化需求，增强平台隔离性的能力；搭建有灵活数据组装能力的后端，在应用层搭建配套的技术框架体系，增强灵活编排的能力。白辉表示，过去，蘑菇街一直致力打造服务自身的私有电商云；未来，蘑菇街将开放自身云的和部分层能力。

黄荣奎：如何快速、便捷开发小程序


京东、蘑菇街等电商企业率先使用微信小程序，带动了小程序开发的热潮。腾讯云小程序方案技术负责人黄荣奎在现场为大家带来了最新的微信小程序开发工具与技巧。他将小程序的开发分成客户端代码与业务核心能力两个部分，并总结了传统开发过程中将遇到以下四个问题：环境部署耗时；后台代码部署不方便；开发调式不直观；很多时间将花费在框架搭建上，包括基础的功能，比如登录体系，而不是直接开发业务功能。腾讯云小程序方案技术负责人黄荣奎
为了让开发者更加方便快捷地开发小程序，黄荣奎介绍了一套新版开发工具，均与腾讯云配套，可实现以下核心功能：

一键自动配置可运行后台环境：腾讯云和微信小程序帐号可以直接打通，开发者可以直接通过域名访问腾讯云服务器；
后台代码编写：开发者可以基于腾讯云查看对应的资源管理，同时还能修改数据库密码、下载运营日志等；
一键上传代码自动部署：当代码写好之后，通过点击上传测试即能实现轻松部署，成功传到服务器上的代码也能直接运行；
远程调试：开发者可在前端调试界面看到控制台，同时获取断点、对应变量的信息，大大提高开发调试的效率；
快速搭建后台能力；
丰富的与：开发者基于与，还能获得腾讯云丰富的后台服务，包括、优图、语音识别、图片识别、、人脸识别等等。


王之捷：智能云端架构大幅提升智能语音识别能力


腾讯云业务架构师王之捷分享了腾讯云在人工智能、尤其在智能云方面的最新进展，以及如何将这些能力应用到工作当中。腾讯云业务架构师王之捷
王之捷表示，不断增强的计算能力、日益积累的海量数据，和先进的模型算法作为三大基石支撑并促进了人工智能的发展。
在计算能力方面，腾讯云拥有强大的基础设施，这主要得益于腾云遍布国内的服务器，使得腾讯云能够在大范围使用，同时输出，并且能够在全球个国家和地区能够接触到；在海量数据方面，依托、微信亿级别的用户群应用，每天都能积累超过数千万的图片数据、数十万小时的语音数据和千亿级别的文本量数据，为机器深度学习提供了强大的数据基础；在先进的模型算法方面， 、优图实验室、微信智能语音等，并且在这些领域吸引了数十名国内外专家，使腾讯云的算法能力始终保持在业界领先水平。
尤其在智能语音领域，腾讯云年开始深入研究语音深度学习模型和等，后来则采取了双向，再结合识别，形成模型，再到现在端到端模型，实现了语音和文本的智能双向转换。后来，针对数据量的几何级增长，借助加速的矩阵运算，语音识别的准确率不断提升。在噪音场景下，识别错误率由年的降低到了，对日常口语识别错误率也由以前的下降到；而在标准朗读的情况下，识别错误率更从原来的降低到了，换言之，识别准确率高达，处于业界领先水平。
不仅如此，腾讯云独创的创新方法还支持语言模型的并行解码，可以在一套系统上面同时加载多个语言模型，在同时识别的时候自动挑选一个识别效果最好模式，由此解决了垂直领域的定制问题。

邹方明：看腾讯云如何架构海量存储系统


回首腾讯云存储十年的历程，腾讯云存储业务中心总监邹方明将其划分为四个阶段：萌芽时代、图片时代、视频时代和云时代。
腾讯云存储面临的第一个大挑战正是在图片时代兴起之初。当时，传统的三层储存架构模式在性能、及成本方面都明显难以招架海量的日志和图片上传。腾讯云存储适时推出了系统自动化运营方案，通过实时监测物理区域，在秒内就能做出反应，对校表储存量超过的存储磁盘进行扩容，极大地节省了传统扩容方式所耗费的时间与人力。腾讯云存储业务中心总监邹方明
但在自动化扩容运营系统基本适应图片时代后，新的问题开始出现：当空间、动态以及、朋友圈相册每天上传量高达亿级别的时候，文件删除量也达到了，之前设计的磁盘条带化整理系统遭受挑战。为了便于磁盘的自动回收，腾讯云存储将磁盘分成同等大小的空间并进行分片分头的整理，留存出到的冗余利用率，解决了当时的问题。
当腾讯云存储的数据储存增长量在四年时间内从到，腾讯云存储接到的需求也不断增多。面对超大容量源文件存储设备消耗量大、维护成本高的问题，腾讯云存储通过文件压缩、转码、解码的方式，将一个文件一个索引转换为多级索引，每个级别索引仅代表一个小分片，把这些小分片累积起来以支持更大的存储，强力解决了这一问题。同时，腾讯云存储通过设计纠删码的方式，为文件留出—份纠删冗余并分别存在多台设备里，最终使文件存储大小压缩到—份，极大的减少了原先存储的设备量。
同时，这一纠删码技术也运用到信息安全保障中：在单地数据中心出现问题时，这一技术能保障另一共存数据中心能及时完整地进行数据的整合并恢复归档，在降低成本的同时，极大程度地保障数据的安全。

熊普江： 网络架构助力开发者快速构建、优化业务


腾讯云自成立年来，已经为企业、开发者、合作伙伴、数百万用户提供了云计算服务。如何应对不同业务对网络架构和性能的不同要求，为海量用户提供广泛的优质网络覆盖，便是腾讯云核心解决方案——的网络服务平台腾讯云内部叫做平台的核心价值所在。腾讯资深架构师熊普江
为了帮助快速发展的中小运营商宽带用户消减通联的制约，腾讯在年开始了网络建设，截至目前，在全国建了个平台，对等互联家运营商，均为用户量在万以上的有号的运营商，互连带宽超过多个，互连专线多条。此次上海峰会，腾讯资深架构师熊普江全面解读了腾讯云平台的核心技术优势与未来演进方向。
平台整合了架构，并使用腾讯云自有的号，在与运营商私有互联时使用  特性；当对等互联的运营商接口使用时，则仅允许其访问腾讯云自有地址，避免了穿透流量；当所有连接运营商的接口使用时，则拒绝等非正常数据包，形成天然的抗攻击的能力。
与三大运营商静态路由互连相比，腾讯云表现卓越：首先，用户访问质量大幅提升，网络性能约有左右的提升；其次，运营成本大幅降低，为合作伙伴节省跨网成本超过亿元；再次，的服务器都是最佳最短路由的单，业务架构更加简洁而高效；最后，腾讯云能够高效、可靠地适用于任何业务架构和任何性能要求。
开发者专场上，腾讯云“云创业”计划也再次面对开发者发起新一轮招募。该计划包括专项扶持的“孵化计划”、“起飞计划”以及“腾飞计划”，为中小企业开发者提供云资源、技术、培训等一体化的扶持，为开发者云生态注入养料，释放核心潜能。作者：
团队：腾讯移动品质中心

一、冒烟测试，什么鬼
冒烟测试，名字听起来很奇怪，冒烟和测试完全就没有什么关系，为什么两者会联系到一起？冒烟测试本是说硬件测试时进行加电，如果电路板没有冒烟则说明电路设计没有问题，后来冒烟测试引入到了软件测试中，用来验证主路径是否畅通。
软件冒烟测试往往在敏捷开发团队中有着非常大的帮助，在目前这种快速开发迭代的节奏下，如果依旧采用常规的提测、测试、回归流程，显得过于死板和迟钝，产品中存在的问题不能以第一时间反馈给各角色，而冒烟测试则是集合了整个团队的力量共同助力产品的质量。这里所说的冒烟测试是穿插在整个项目流程的各个阶段，从而在项目周期中把控产品质量。
那你可能会问了，如此大规模的冒烟测试，倾尽团队各方的力量，它到底有哪些优势值得我们投入这么多精力？下面我们就来讲讲冒烟有什么厉害之处。

二、冒烟测试的优势
冒烟测试，虽说是测试方法的一种，那你认为它仅仅是一种测试，那就太过浅显了，冒烟测试可以弥补很多常规测试中不足，冒烟不仅可以测出，更早的发现产品缺陷，还可以发现产品层面的问题，另外，也会弥补测试中机型不足的问题，同时也可以进一步提升提测质量。

在产品研发的过程中，常常会有这么一个问题，所有的人只熟悉自己负责的模块，而每天一次的冒烟让每一个角色都可以融入到产品中，更多了解自己的产品，发现产品的优缺点，提出自己对于产品的想法。对于产品经理，可以第一时间接触到产品，在产品的刚有雏形的时候来验收产品，避免研发过程中需求理解错误，减少修复成本。
一般在测试工作中，机型有限，测试时不能兼顾到所有机型，然而某些缺陷只在特定机型上才会暴露，如果等到产品上线发现适配问题再修复，修复成本会很大，冒烟测试中多了十几个机型，更容易暴露机型问题。
除了机型问题，在常规的测试中，提测质量往往是一个痛点，虽然开发有自测，可是总还是有一些浅显的问题存在，更有甚者还会阻塞测试工作，提测前进行冒烟可以完美的解决这一问题，冒烟测试属于自由体验，可以保证在主路径上不会有严重的缺陷存在，提高提测质量，解决测试阻塞的问题。
冒烟的时候经常会有一个有趣的现象，大家会热烈的讨论某个功能该如何做，每个人说出自己的见解，更正不合理的产品需求，最后把解决方案记录在列表中转为产品需求。
在不断的冒烟测试中，代码上的缺陷不断被修复，同时产品功能也在不断完善。原来冒烟测试这么厉害，教练，我要学！既然要学总要有各流程吧，下面我们介绍一些冒烟测试中的“套路”。
三、冒烟
冒烟流程是既简单又很复杂，短短半小时看似短暂，却像是浓缩了一整个项目流程进来：首先得把主角“打包”出来，然后组织大家去冒烟，收集冒烟中的问题，最后录入系统给相应负责人解决。

冒烟包在包的过程中经常会有各种问题，因此需要在时间上预留一些，通常情况下需要提前半小时包，在包前需要确认各开发今天写的代码都已经更新至。
每个版本由一个开发和一个测试负责，开发负责打包并收集各开发的和体验路径，测试负责将上一次冒烟修复的打印出来给大家回归。
各角色在冒烟的时候不仅要体验新产品，也需要履行各自的职责：开发需要引导大家体验自己的，并讲解需求，产品经理和设计师需要关注需求是否正确实现，测试则是要让大家回归已解决的谁提的谁回归，拒绝的需要开发给出拒绝的原因，如果不合理，提人可以将重新打开。
冒烟结束后，测试负责人需要根据 中的内容，将分模块，类型，建议，具体格式为：
标题格式说明：【版本模块名冒烟测试】【建议】提人 ，最后全部提给该版本的冒烟开发负责人，由他统一分配。
冒烟测试中提出了这么多问题，怎么分类，如何处理，每一天的冒烟既是一个新的开始也是一个对上一次冒烟的闭环，分类的不同，发现阶段的不同，其解决的方式也有所不同。
四、查杀
冒烟中，同一个在不同的手机上会有不同的表现，因此经常会有重复出现，或相似，表现不一致就会提，这样导致的“含金量”不高，一个版本下来可能有效的冒烟只有、成，但是在面前宁肯让其重复也不能遗漏。

这是我们 某个版本的冒烟数据，单冒烟一项就提了个，虽多，线上质量却从未出过问题。
有效的有成，拒绝以重复和建议类偏多，约占到总的。那剩下的成拒绝应该如何看待，难道拒绝了就没有存在的价值了吗？

并非如此，重复一般说明问题该容易复现，因此需要重点照顾，虽然被定位为无效，但是重复可以帮助开发找到需要重点关注的地方。建议类一般是对产品需求的看法，千人千面，并不是所有的意见都符合产品逻辑，但是这些建议却值得产品经理去思考。
有效的该如何解决，当然的种类很多，不同类型的解决的方式也有所区别，目前我们冒烟测试有三大类：常规问题，以及体验类问题。

常规类型的为冒烟时的常规缺陷，常规问题常规解决，这类缺陷在冒烟时由发现问题的人回归，并对解决的结果作出判断，评估该是否已被解决，或者拒绝理由是否合理，如果有异议可以要求重新打开该。
属于非常严重的一类型，如果解决方案不够妥当，可能会引入其他问题，如果仅仅是在冒烟期间没有复现就认为已修复，这样会太过草率，因此，每次冒烟的时候，开发会讲解该是如何修复的，为什么会发生该，大家一起评估过这个修复方法后才算结束。
体验类比较特殊，如果觉得有产品缺陷的地方就可以提这一类，这类一般会转到产品名下，产品会权衡要不要把这个建议纳入到产品中来。由于冒烟是穿插在整个项目周期中的，在项目即将发布前可能依旧存在问题，此时修复这些问题，如果代码改动太大，可能会引发其他的，所以如果是在项目后期冒烟中发现很难解的需要评估改动范围，不然为了一个小问题而引入更多的就得不偿失了。
五、冒烟技巧
上面说了这么多，真正要施行下去是有一定难度的，每天让大家从工作中抽出宝贵的半小时时间用于体验产品，对于每天加班的开发来说是很难接受的，那有没有什么捷径可以走，这么厉害的东西不能出师未捷身先死啊，总得通过某些方式把它推行下去吧。
、用数据说明冒烟的优势
冒烟过程中会出现各种，这些的提前暴露可以在项目初期就开始修复，提升代码质量，成果非常可观，可以通过一两个版本的数据情况让大家认识到冒烟对产品质量的重要程度。
、项目的支持
任何工作的顺利进行都需要有上级的支持，项目对冒烟测试的支持可以减少冒烟测试中遭遇的各种阻力。
、冒烟时间地点
通常情况下，冒烟应当选择在人比较疲劳的时候，这个时间段工作效率不高，可以利用这个时间进行冒烟，解决了时间利用率低的问题，同时也能缓解工作的疲劳。
至于地点，只要不是在自己的工位上冒烟就可以，最好能找个茶水间，让大家放松心情的同时进行冒烟。
如此以来，可以让项目组成员意识到，冒烟不仅仅是工作的一部分，同时可以缓解工作的疲劳，提升大家冒烟的积极性。
、物质奖励
冒烟的时候可以准备零食给大家，对于冒烟积极的同学可以提供物质奖励。
当然，组织冒烟的技巧不仅限于此，此时就是你开辟脑洞的时刻了，只要能让冒烟测试顺利的开展下去，再“卑劣”的想法都值得去尝试。
六、总结
在版本快速迭代的节奏下，冒烟测试不仅成为常规测试的一个有效补充，也为其他角色了解测试搭建了一个很好的桥梁，这个过程需要各个人员积极的参与和优化才能得到理想的效果。
获取更多测试干货，请搜索微信公众号：腾讯移动品质中心！导语
 是一款开源的、高性能、跨数据库系统的复制引擎，可用作多种场景下的数据迁移组件。本文尝试利用该工具实现  数据到  的同步。
一、初始环境设置：

 主机： 服务器，开启 ，_ 设置为  格式；端口 ；安装过程不赘述
 主机： 服务器；端口 ；安装过程不赘述
两台机器有一个同名的账户，这里用默认的机器账户 ，两台机器配置信任关系，相互之间可免密码登录

二、配置同步账户：
登录  主机，为  进程授权，因为这里  是本机安装，故授权  是 ；权限类型至少需要  、 、  ，还需增删查改，建议授权  

         

三、下载 ：

二进制压缩包下载网址：
或者  源码下载网址：

四、解压安装：
在  主机执行如下操作： 
     =_===_======
在  主机执行如下操作：
     ===_======
参数解释： 是服务名字，唯一标识一对数据迁移服务； 端通过  参数、 中包含的端口信息、、 信息连接上指定实例，之后同步  库数据； 端通过  参数、 连接指定的  实例也可以是  入口，然后进行同步。如果  端同样做了授权：详细参数参见    。
执行完成后，看到  是  状态即说明成功。此时可以看到在  目录下如下：   _   
这步骤安装时候一直不能通过：当时报错是：

原因为配置  信任关系时候，两台机器可以相互登录，但本机不能免密码登录本机。分别将自己的密钥添加到认证文件中就好了；
另公司内为了安全， 端口非默认的 ，那么这步安装时候要加参数： == 。
五、查看同步状态：
 _                                                            _                         
输出解释： 状态表示同步进程工作状态，若有报错则会在这里看到。 
起停同步进程：  
    
上下线数据迁移服务：  
   
默认是基于  全库开始同步，指定同步特定库表：  
   ===__  
从指定的  点开始同步：  
        
六、验证数据同步效果：
 端建立一张表，并插入一条数据； _        =
 端进行验证： _
该步骤如果执行完成后，数据未能实时同步，可以通过 的输出配合进行调试。
七、缺点：

通过  同步之后的数据没法进行  比对，只能依赖业务层面 
基准数据需要人工导入
部分  语句不能正常同步，如  ；  等月日， 公司通过  的官方博客宣布正式发布   版本。这是  版的第二个  修复版，这次更新提升了编译器的性能，同时引入了多个工具链新特性。  还带来了与  版本   插件的兼容性。
 是一个基于  的新的编程语言，由  开发。
其主要设计目标：

创建一种兼容  的语言
让它比  更安全，能够静态检测常见的陷阱。如：引用空指针
让它比  更简洁，通过支持   ，  ， ，    等实现。
让它比最成熟的竞争对手  语言更加简单。作者：陈帅
团队：腾讯移动品质中心

一、简述
性能测试，在通信设备测试界，是一个非常成熟的领域，组织在这个范畴制定了诸多以规范测试行为。但在笔者接触移动测试领域的四年里，性能测试仿佛是一个可有可无的专项。性能问题，在各个项目中，总是停留在“用户报障 开发关注  测试复现”。
显然，性能问题，如果也能最大限度的按照“测试发现  问题定位 开发修改”的正常流程来走，对产品质量是有非常大贡献的。下文的介绍，目标就在于此：测试过程中，测试工程师识别更多的产品关键场景，通过场景化、工程化、自动化的测试手段，发现更多的性能问题，使得性能收敛于产品发布前。
二、目标与战法
尝试概括下性能测试：通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。成功的性能测试，会具备以下几个特点：
提供给开发的信息具有精准性必备；
测试方法高效，测试数据稳定可靠必备；
使用的分析方法具有高可信度必备；
测试熟练使用工具帮助开发定位性能问题可选。
提供给开发的信息具有精准性。
如果测试或用户告诉开发同学：
“你们这个版本性能很差！”
“我们用着用着手机就开始发烫了，你搞定一下！”
开发同学内心肯定是迷茫的。
如果测试将自己的措辞换成：“我们资讯页面，观看视频过程耗电量高，这个版本比上个版本高了。”这样开发团队可以根据模块指定跟进人，知道具体的路径，知道耗电量的优化目标这个版本多出的这，那问题的推进必然会更加顺利。
测试方法高效，测试数据稳定可靠。
在设计本框架前，团队执行性能测试，包括长板性能测试亮屏后台耗电及内存、手工驱动的场景性能测试、基于页面驱动的流畅度测试。
长板性能，场景过于单一，基本只校验了管家后台进程无任何操作下的性能表现；
相比于自动化驱动，手工测试无法保证收集到大样本数据让人反复做一个操作分钟，这种任务毫无疑问是对员工的摧残；
页面驱动的流畅度测试，经常出现两次对同一版本的测试得出截然不同的测试结果，测试数据不稳定，难以向开发证明其代码有问题。后文介绍流畅度测试时再详述优劣。
使用的分析方法具有高可信度。
传统的分析方案中，往往简单地采用均值来评估性能项。笔者认为，合理的选用评估算法，也能让你的测试报告更有说服力。一个存在少量毛刺的数据序列，如下图，由于毛刺偏离严重，将严重拉低平均值。多一个毛刺，少一个毛刺，均值都会有很大不一样，在样本量较少时，往往会出现两次测试获得的性能数据差异大的问题。流畅度数据具体如何解决将在后续流畅度篇中详述。

图一流畅度样本
测试熟练使用工具帮助开发定位性能问题。
测试左移一点，多做一点，开发就可以少花一点精力在缩小问题访问上。在功能测试中，一个从偶然复现到找到必现路径，会让开发减少大量定位问题时间。同样，在性能测试中，如果测试能指明哪个线程是功率消耗大户，哪个对象是内存泄漏祸首，那么开发也能更加迅速地修复问题。同时，测试在定位过程中，不仅仅提升了自身能力，也建立起了自己的技术形象。
三、性能测试框架设计
如下图，本次设计的性能测试框架，包含有数据收集、数据分析、自动化、驱动框架四个模块，各自独立解耦。这样设计能够降低用例接入成本，可扩展性好。

图二框架设计原理图
四、数据收集方案
我们需要通过一种或多种数据，直接反应一项性能的好坏。所以如何收集数据样本？收集那些数据样本，是性能测试框架必备的一个模块。
五、驱动方案
移动客户端的性能测试，主要是模拟用户操作来创造类用户使用场景，获取使用过程中的、、流畅度等数据，以衡量该使用场景下，被测应用的性能指标。
本框架的自动化框架，选择了 版的开源代码。主要有如下几点原因：
、数据收集模块需要使用工具，做输出结果处理、文本分析，在这方面有较大优势，代码量低；
、封装的开源版，非常轻量级，功能全面，直接使用开源项目，能够节省非常多的框架开发时间。
六、驱动框架介绍
在本框架中，测试人员能够用如下的命令行直接驱动一个或多个用例的执行，所以设计了类逻辑的方案。
     
     
如下图，类用来驱动和组织各个用例的_，_，，_，_等方法。

图三类的驱动部分
而用例中包含的这些方法，主要作用是：
_  用于执行初始化环境；
_  主要用于拉起相应的性能数据收集线程、使用自动化初始化应用到被测场景，如闪屏滑动，进入主页等；
  自动化执行场景的关键逻辑，如：测试“连续播放不同视频”场景的内存泄漏。则用例需要在方法中，使用实现循环点击不同视频播放的逻辑；
_  该方法主要用于通知数据收集线程停止数据收集，进行数据归档；
_  该方法将清空环境，将所有数据汇总到报告中，并使用数据分析算法得到可以直接用于报告的内容。

图四执行逻辑
如图四，自动化在中执行相应场景时，性能数据收集线程会持续收集性能数据。
注明：上述的五个步骤并不需要在每个中实现，对应同一专项，除了，其他四个方法，都具有相同的逻辑，抽象到父类中实现即可，这样可以做到同一个专项下的不同场景用例，只需要写一个方法。
七、数据分析方案
拿到数据后，想要最大化数据的价值。合理合适的数据分析方案显得尤为重要。笔者一开始做性能测试，所能想到的也就是拿到一大堆样本数据，取平均值，再做对比分析。
本框架试图提供除了平均值外，提供其他更为丰富的数据来评估各类性能指标。包括：
中位数：以它在所有标志值中所处的位置确定的全体单位标志值的代表值，不受分布数列的极大或极小值影响，从而在一定程度上提高了中位数对分布数列的代表性。中位数用于评估网络延迟样本，效果明显优于平均值。原因在于，如大部分延迟在时，其中有几个异常样本值以上，它们会严重拉高均值，导致均值不能完全代表该延迟数据序列。
方差与标准差：结合均值来评估数据序列，可以评估到数据序列的离散程度。
分布图或分布表：分布图或分布表也能比较好的评估一个数据序列的好坏，用它来做流畅度、网络带宽、网络延迟等性能评估，能够比较直观、详细地给出对比结果。

图五流畅度优化效果示意
曲线图：内存性能的评估，最优解莫过于占用曲线 平均值了。

图六占用内存曲线
平均值：最传统的均值，依然是一柄利器。
极大值、极小值。
八、必要的说明
框架使用了开源代码：


以上对具体代码的介绍比较少，后续几篇继续阐述下具体逻辑是怎么实现的。
搜索微信公众号：腾讯移动品质中心，获取更多测试干货！前言
 随着人工智能的大热，越来越多的小伙伴们开始投身到机器学习的大潮中。作为其中的一员，我对此也是极有兴趣的。当然我更感兴趣的，是怎么利用这些有趣的算法，来实现脑海里各种奇奇怪怪的点子。写这篇文章的契机，是我在某天看完腾讯指数的推送后，突发奇想，想自己实现类似这样的一个东西，感觉蛮好玩的。然后就在上周末，利用了一些空余时间，写了一个简单的舆情监控系统。
思路
基于机器学习的舆情监控，这样的一个想法，其实可以有很大的想象空间，可以做很多有意思的事情。比如可以关注你喜欢的明星或电影的口碑情况，或者了解你所关注股票的舆论变化，甚至预测其未来的走向等等。但我决定先从最简单的例子入手：就是从新浪微博中，识别出关于腾讯的正面或负面的新闻。本文的论述也将围绕这个场景展开，不会涉及太多复杂难懂的东西，可以说是很简单的一个东西，请放心阅读。
技术上的实现，主要是用对采集到的微博文本做分类训练，关于就不需要介绍了，很有名的一个机器学习工具，如果想详细地了解可以移步它的官网：。
下面是我们接下来需要做的所有工作：

环境
机器：
语言：
第三方库：、、 等
数据采集
 数据采集是对我来说是最好做的一步，其实就是写爬虫从各大网站收集大量的信息，存起来，以便我们后续分析处理。如下图：

因为这只是一个试验性的兴趣项目，没办法花太多时间投入，所以我这次只打算从微博的搜索结果中，取条数据来分析。当然如果有可能的话，数据越多越好，训练出来的模型就越准确。
采集的页面是百度的微博搜索结果页：=腾讯====
用对该页面逐页抓取，然后用模块对抓取到的页面进行解析，得到一条条的微博文本。下面贴下这个页面的解析代码：

人工处理
这一步是最苦逼也是最花时间的一步，我们需要把采集到的数据，一条条精确地人工分类整理好，才能给后续的算法训练使用。如果你的场景在网上能找到现成的训练数据集，那么恭喜你已经节省了大把时间，但大多数情况还得自己来，所有脏活累活都在这了。而且人工分类的准确性，也决定了训练出来的模型的准确性，所以这一步的工作也是至关重要的。
我们的目标是把消息分为“正面”、“负面”和“中性”三个类别。首先我们要先给这三个类别下一个明确的定义，这样在分类的时候才不会迷茫。我个人给它们下的定义是：
正面：有利的新闻、积极正面的用户言论；
负面：不利的新闻、消极反面的用户言论；
 中性：客观提及的新闻、不带感情色彩的用户言论。
按照上面的标准，我们把采集到的条微博一一分类标记好。
文本预处理
采集过来的微博文本，带有很多无效的信息，在开始训练之前，我们需要对这些文本做预处理，并保存为能接收的数据，主要工作包括：
 、去杂质，包括表情符号、特殊符号、短链接等无效信息，这里用正则过滤掉即可，不再详细描述； 、保存为文本文件，因为要求训练数据以特定的格式存放在本地目录，所以我们需要用脚本对原数据进行处理，目录格式如下：

：存放待训练的数据，子目录名称为分类名，子目录下存放训练文本文件，文件名随意，内容为单条微博文本；
：存放带测试的数据，子目录名称随意，在子目录下存放测试文本文件。
建议训练集和测试集按的比例划分，用自动生成以上的本地文件。
 、分词，因为微博的数据大部分都是中文，所以推荐用分词，对中文的支持比较给力，效果也很好。支持自定义词典，支持返回指定词性的分词结果，可以去除一些停用词和语气助词等。使用起来也很简单，这里不详细介绍，有需要可以访问它的地址：
算法选择
准备好训练数据之后，我们就可以开始训练了，为此我们需要选择一个合适的分类算法。但机器学习算法那么多，如果一个个去测试对比，将花费我们不少精力。幸好已经考虑到了这个问题，并提供了一个算法选择方案。通过把多个算法的运行结果进行图形化对比，可以很直观的看到哪个算法比较合适。
这个是官方提供的测试代码：___把这个官方案例的数据输入部分替换成自己的即可。结果如下图： 

综合运算效率和得分情况，我选择了算法来作为我的训练算法。
训练
文本分类的训练主要有以下个步骤：

这个步骤 都已封装了相应的方法，所以使用起来极其方便。参考如下代码：

注：以上代码为了方便展示，把模块引入也放到方法内部了，仅作参考
应用
最后就是对训练好的模型进行测试和应用。
 通过已有的模型，对新的数据进行预测，代码如下：

注：本代码只是展示用，仅作参考
 打印出来的部分结果见下图：
经统计，预测的准确率为，该模型算出的当天腾讯相关的舆情如下：

结语
本文只是记录下我这两天的一些想法和试验过程，没有涉及太多代码实现或者其他高深的算法，相信不难看懂。如果有人感兴趣的话，后面我可以把源码整理完发布出来。
感谢阅读！这是【 开源项目贡献指南】系列的第七章，原文【  ——     】

为什么有些人会寻求经济支持
大多数开源工作都是自发的。举个例子，如果有个人在他们使用一个开源项目的时候遇到一个然后他提交了一个快速的修复方案，或者他们很享受在业余时间修补项目的问题。

我那时候在寻找一个编程项目作为一个业余爱好打发我圣诞节附近的一个周。我在家里有一台电脑，除此之外也没啥了。所以我决定写一个新的脚本语言的解释器，我选择作为这个项目的名字。
—  “ ”

有很多原因会让一个人觉得没必要因为他们在开源项目中做的工作而获取报酬。

他们可能有一个非常喜欢的工作了，这让他们会在空余时间对开源项目做贡献。

他们已经把开源作为一个习惯了

他们在给开源项目做贡献的时候获得了其他的好处，比如建立声望，学习一项新技能，或者感觉离社区更近。



经济上的支持会给你多多少少增加一份责任感。在这个我们生活的万物互联，快节奏的世界里，能够拒绝别人说：“我现在不想做这个，我想做点不一样的。”对我们而言很重要。
—  “  ’  ”

而对于其他人来说，特别是在项目正在进行而且需要大量事件投入的时候，获取报酬似乎是唯一的方式让贡献者持续工作，不管是因为项目需要还是个人的原因。

不管问哪一个开源项目的维护者，他们都会告诉你实际上他们要做多少工作。你有客户，你得给他们解决问题，你得开发新功能。这都需要很多时间的投入。
—  “        ”

有偿工作也使各行各业的人做出有意义的贡献。而有些人在开源项目上花不起无偿的时间，基于其自身目前的财务状况，债务，或家庭或者其他需要花费精力的义务。这意味着这个世界永远不会看到那些没有时间奉献自己的人才的贡献。

开源软件为技术产业带来了巨大的利益，而技术产业则意味着对所有行业的好处。然而，如果能专注于此的人是幸运的和痴迷的，那么就有一个巨大的未开发的潜力。
—  “   ”

如果你在寻求经济支持，有两种方式可以考虑，第一是找你的老板，第二是找别的组织给你的项目资助。
为你的时间找赞助
现如今很多兼职或者全职搞开源项目的人都会得到报酬。最常见的方式就是和你的老板谈谈。
记录一切

就像很多开源社区的人一样，维护一个项目让我心力交瘁。当我一开始做开源项目的时候，我可以迟一点再弄或者是回家了弄…此处省略一万字我可以和我的老板讨论我遇到的问题，我们从我们自己使用的的经历中获取灵感并且转换成要解决的问题。
—  “ ”

如果你现在没有一个现有的开源项目，但是想把你现在在做的工作开源出来，那么试图说服你的老板把公司内部的某些软件开源吧。
许多公司正在开发开源程序，以建立自己的品牌和招聘高素质人才。
举个例子，发现有财务方面的原因促使沃尔玛对开源项目投资   发现的开源计划对他们招人产生了积极的影响
这和我们的黑客文化和团队架构密切相关，我们问我们的员工。“你在感受到了我们的的开源计划了吗？”。三分之二的人回答是。二分之一的人说这个计划在他们决定为我们工作的时候起了积极的作用。我希望这都不是边缘数字，而是一个继续进行的趋势。
如果你的公司沿着这条路走下去，保持社区和公司活动之间的界限是很重要的。最终，开源项目通过来自世界各地的人们的贡献来维持自己，这比任何一个公司或地点都要重要。

获得有偿的开源工作是一个难得的好机会，但你不应该在工作中放弃原有的激情。你的激情应该是为什么公司要付钱给你。
—  “ ”

如果你不能说服你的雇主优先考虑开源工作，那么考虑找一个新的雇主来鼓励员工对开源的贡献。寻找那些致力于开源工作的公司。比如说：

一些公司，如或，有网站突出其在开放源码的参与。

 发布了给员工制定的开源项目贡献政策


起源于大公司的开源项目比如说或者，还会专门请人在这些项目上干活。
最后，根据您的个人情况，您可以尝试筹集资金独立资助您的开源工作。例如

通过   给他的项目筹集资金。

通过   给它的项目架构调整的工作筹款。


给你的项目寻求资助
除了对个人贡献者的安排，有时候项目会需要从公司，个人，或者其他方式给正在进行的项目筹集资金。
组织资金可能转向支付目前的贡献者，包括运行项目的费用如托管费，或投资到新的功能或想法。
随着开源的流行，寻找项目的资金仍然是实验性的，但也有一些共同的选择。
通过众筹活动或赞助提高你的报酬
寻找赞助效果很好，如果你有一个强大的受众或声誉，或您的项目是很受欢迎的。
寻求赞助了的项目的几个例子包括：

 通过 从公司或者个人筹集资金

 通过 筹款

  一个非盈利性组织，支持在  和其他的基础性设施项目。


创建收入流
根据您的项目，您可以为商业支持、托管选项或附加功能收取费用。几个例子包括：

 为付费版本提供附加的支持

  提供付费版本的产品

 一个有付费管理项目的非盈利组织


一些流行的项目，比如和，甚至会寻找风投来支持他们在商业上的发展。
申请资助
一些软件基金会和公司为开源工作提供资助。有时，赠款可以支付给个人没有建立一个法律实体的项目。

   收到了来自   的资助

 由’  发起

 收到了来自 的资助

   给相关的项目提供资助


更详细的方案和案例研究，写了一份指南教你如何通过开源工作获取报酬。不同类型的资金需要不同的技能，所以考虑你的优势，找出哪种选择最适合你。
建立经济支持案例
无论你的项目是一个新的想法，或者已经有好多年了，你应该把重要思想为识别你的目标在使一个令人信服的理由。
无论你是想付出自己的时间，或筹款为一个项目，你应该能够回答下列问题。
影响
为什么这个项目这么有用？为什么你的用户，或者潜在的用户，这么喜欢他？五年之后这个项目会是什么样子？
引导
尝试收集证据，你的项目是重要的，无论是指标，轶事，或见证。现在有没有公司或值得注意的人使用你的项目？如果没有，有一个突出的人赞同吗？
对投资者的价值
投资者，或者发放资助的组织，经常会收到这样的请求，为什么要支持你的项目而不是别的项目和社区？他们能得到什么？
资金的使用
实际上你会怎么处理这笔资助？专注于项目里程碑或结果，而不是支付工资。
怎么接受资助？
没有人在支出方面有什么要求？例如，你可能需要成为一个非营利性的或有一个非营利性的财政赞助商。或者，资金必须提供给单个承包商，而不是一个组织。这些要求有不同的资助者，所以一定提前做好功课。

多年来，我们一直友好的网站图标的主要资源，有万多人，精选了万多个网站，包括社区。版是在三年前。网络技术改变了很多，从那时起，坦率地说，字体真棒有点陈旧。这就是为什么我们介绍  。我们追求现代化，也重写和从上到下重新设计每一个图标。我们说的是更好的设计，更好的一致性和更好的可读性。
—     

不断尝试，不要放弃
筹集资金并不容易，无论你是一个开源项目，一个非营利组织，或一个软件启动，在大多数情况下，你需要富有创造性。确定你想如何得到报酬，仔细研究，设身处地的为你的投资人着想将会帮助你建立一个资助方面的令人信服的案例。作者：

、前言
众所周知，微信在后台服务器不保存聊天记录，微信在移动客户端所有的聊天记录都存储在一个  数据库中，一旦这个数据库损坏，将会丢失用户多年的聊天记录。而我们监控到现网的损坏率是，也就是每  个用户就有  个会遇到数据库损坏。考虑到微信这么庞大的用户基数，这个损坏率就很严重了。更严重的是我们用的官方修复算法，修复成功率只有 。损坏率高，修复率低，这两个问题都需要我们着手解决。
、 损坏原因及其优化
我们首先来看  损坏的原因，官网上列出以下几点：

文件错写
文件锁 
文件  失败
设备损坏
内存覆盖
操作系统 
 

但是我们通过收集到的大量案例和日志，分析出实际上移动端数据库损坏的真正原因其实就个：

空间不足
设备断电
文件  失败

我们需要针对这些原因一一进行优化。
、优化空间占用
首先我们来优化微信的空间占用问题。在这之前微信的部分业务也做了空间清理，例如朋友圈会自动删除天前缓存的图片。但是总的来说对文件空间的使用缺乏一个全局把控，全靠各个业务自觉。我们需要做得更积极主动，要让开发人员意识到用户的存储空间是宝贵的。我们采取以下措施：

业务文件先申请后使用，如果某个文件没有申请就使用了，会被自动扫描出来并删除；
每个业务文件都要申明有效期，是一天、一个星期、一个月还是永久存储；
过期文件会被自动清理。


对于微信之外的空间占用，例如相册、视频、其他的空间占用，微信本身是做不了什么事情的，我们可以提示用户进行空间清理： 

、优化文件 
、 = 
设置的文件同步机制为全同步，亦即要求每个事物的写操作是真的到文件里去。
、 = 
通过与苹果工程师的交流，我们发现在  平台下还有  这个选项，可以严格保证写入顺序跟提交顺序一致。设备开发商为了测评数据好看，往往会对提交的数据进行重排，再统一写入，亦即写入顺序跟提交的顺序不一致。在某些情况下，例如断电，就可能导致写入文件不一致的情况，导致文件损坏。
、优化效果
多管齐下之后，我们成功将损坏率降低了一半多；损坏还是无法完全避免，我们还是得提高修复成功率。 

、 修复逻辑优化
、 表
首先我们来看  的架构。 使用 树 存储一个表，整个  数据库就是这些 树 组成的森林。对于每个表的元数据表名、根节点地址、表  等，都记录在一个叫 _ 的表中。这个 _ 表下简称  表 本身也是一个 树 存储的普通表。

、官方修复算法率低下原因
官方修复算法是这样一个流程：从  表中读出一个个表的信息，根据根节点地址和创表语句来  出表里的数据，能  多少是多少，然后插入到一个新  中。要注意的是  表他本身也是一个 树 形式的普通表， 第页就是他的根节点。那么只要  表某个节点损坏，这个节点下面记录的表就都恢复不了。更坏的情况是  第页损坏，那么整个  表都读不出来，就导致整个都恢复失败。这就是官方修复算法成功率这么低的原因，太依赖  表了。
、备份  表
那么最自然的想法，自然是另外备份一份  表了，也不需要用树，直接用数组序列化存储就好。我们只需要每隔一段时间轮询  表，看看最近有没有增删 ，有的话就全量备份。
、备份时机
这里有个担忧，就是普通数据表的插入会不会导致表的根节点发生变化，也就是说  表会不会频繁变化，如果变化很频繁的话，我们就不能简单地进行轮询方案了。通过分析源码，我们发现  里面 树 算法的实现是 向下分裂 的，也就是说当一个叶子页满了需要分裂时，原来的叶子页会成为内部节点，然后新申请两个页作为他的叶子页。这就保证了根节点一旦定下来，是再也不会变动的。实际的代码调试也证实了我们这个推论。所以说  表只会在新创建表或者删除一个表时才会发生变化，我们完全可以采用定时轮询方案。
、备份文件有效性
接下来的难题是既然  可以损坏，那么这个备份文件也会损坏，怎么办呢？我们采用了 双备份 的机制。具体来说就是会有新旧两个备份文件，每个文件头都加上  校验；每次备份时，从两个备份文件中选出一个进行覆盖。具体怎么选呢？优先选损坏那个备份文件，如果两个都有效，那么就选相对较旧的。这就保证了即使本次写入导致文件损坏，还有另外一份备份可以用。这个做法跟  标榜的 多版本并发控制的做法有异曲同工之妙，相当于确认新写入的文件有效之后，才使用新写入的文件，否则还是继续用旧的有效的文件。
前面提到  损坏的一个常见场景是空间不足，这种情况下还要分配文件空间给备份文件也是会失败的。为了解决这个问题，我们采取 预先分配空间 的做法，初始值是 ，大约可存  个表的元信息，后续则按照的倍数进行增长。
、优化效果
通过备份  表，我们成功将修复成功率提高了一倍多。

、其他
通过这些优化，我们提高了微信聊天记录存储的可靠性。这些优化实践，会同之前在并发性能方面的优化实践微信 源码优化实践，将会合并到微信即将开源的  组件中。我们正在进行紧张的代码整理工作，争取在  年年中开源 。

本文来源于： 微信公众号导语
业务背景介绍：腾讯云数据库产品中心  大数据及人工智能产品中心 前端从年初开始尝试    全家桶，期间经历了很多波折，到目前为止总共个项目，其中有个项目使用了该方案。
一、团队项目开发现状
目前团队这边各个项目都采用模块化开发，一般来说一个页面是一个模块，一个页面模块可依赖多个其他模块，然后前端通过识别入口文件依赖关系来加载对应的模块。

图：页面渲染流程
由于腾讯云数据库会有很多种，如：    等，大数据也有很多组件，如：、， 等，直接导致了会有很多新项目需要搭建开发如上文所述的个项目，并且还在持续增长中，所以这里开发新项目采用的方案是部分组件复用，部分代码横向复制。

图：新项目开发模式
如上图所示， 组件模块 和 公共模块是被复用的，会加载同一个模块。在一个新项目中，页面模块中的代码是被复制过去的，其中包括  耦合业务的代码以及  的 和 。
在项目数量较少的情况下这一般没有什么问题，但是当要维护的项目数量过多，其中的页面模块的重复代码就会越来越多。
特别是腾讯云官网控制台有个特点，基本上每个组件的控制台都有表格，而表格的渲染、加载、刷新、分页逻辑 和 状态树都分散在 业务组件、  和  里面，这直接导致大量的重复代码，特别是当表格产生一个或者要进行一次优化，均需要对多个项目均完成改造，这直接导致项目的不可维护。
二、   业务层复用方案
上述所述，团队开发方式中存在的一个本质问题就是缺乏    业务层模块的复用。调研了一下   相关社区，发现并没有适合我们团队的轮子，所以决定造一个。

图：  方案 —— 
 针对业务层模块打包方案，这里核心要解决的问题有以下几点：

打包标准化
参数控制
依赖管理
状态隔离

、打包标准化
标准化打包是一个模块定义的必须，也是模块之间的互相引用注册的前提。这里通过定义业务模块的构成标准，如上图所示，每个都由四部分构成。

 用于表示挂载状态子树的
 用于表示参数传递的默认参数，这里参数主要用来控制 的行为，还有一些事件回调
 表示当前  依赖的   列表
  表示当前   的 业务代码

、参数控制
一个业务层模块与组件类似，是可以随着其他业务引用方的需要可以自由配置的，其提供的参数能够实现下面三种类型传递

基础属性 用于控制业务层模块的表现表格举例 如：是否显示新建按钮，表格加载的数据接口
事件回调 用于控制业务层模块事件行为表格举例 如：新建按钮点击事件触发回调，表格数据加载后数据加工处理回调
事件触发 用于获取业务层模块事件触发器，使得引用方能够主动触发被引用模块的一些事件行为

、依赖管理
多个业务层模块之间，肯定会存在一些依赖关系，如：模块引用模块，模块引用模块、模块。当每个业务层模块都申明了自己的依赖之后，那么在模块被引用的时候，就可以自动计算出它所有依赖的：

模块  
模块  
模块  
模块  

并将上述均注册到 。
、状态隔离
状态隔离指的是每个业务层模块只能更新自己下面的状态子树，这样业务层模块职责单一，高内聚低耦合，在复杂的情况下代码不会出现难以维护的情况。
三、核心原理
在 框架中的运用如下图所示，其中蓝色部分是 的核心。特别要说明的是，组件是使用框架输出的可复用业务层组件，该组件包含 业务组件与 相关业务层代码，与传统不同的是，使用了内置的方法延迟连接到  真正操作在 引用该业务层组件的时候完成。

图：运用在 框架中的架构图
另外，对做了改造，使得封装的 组件 只能将  到自己的状态子树上面去，如上图的 状态子树处理逻辑。同时考虑到老业务的无缝兼容引用，这里  也兼容了  原生  写法。
 是  另一特色，该模块能够创建自动化的   处理器，使得开发人员不用写  代码，提升工作效率。
 组件在这里是的基础公共组件。
 原理如下图所示：

图： 原理
要弄明白 的实现原理，先要了解  的原理。是通过方法将组件绑定到，该方法返回一个，包装了当状态变化的对组件的处理逻辑。
 的原理是在基础上再包一层对象，通过调用该对象上的配置函数来得到一个来实现的延迟绑定，而该对象包含了依赖信息，参数控制等信息。
四、实践效果
个项目中个项目已接入，并取得下面成功

提升开发效率，已将  代码全部优化掉
提升开发效率，表格页面开发效率从天提升到小时
减少样板代码，统计模块代码量减少约 
减少重复代码，统计项目代码量平均减少约 
高可维护，在线修复或优化升级
成功节约大量开发和维护成本，开发更便捷更规范化续前文《【腾讯云的种玩法】几种在腾讯云建立的方法一》
【懒人安装——集成环境安装】
还是前奏：环境检查

操作系统：本例使用的大部分在  与   位上可行
服务架构：提供、提供
注：此处为


软体版本：、 

在服务器上安装并完成网站创建
  面板，简称，是一个基于架构的类似 虚拟主机 独立面板。这个面板安装简单，非常适合新手，以及一些恐惧命令行的 用户。
的主要功能有：在线划分虚拟主机多个网站、帐号自定义、在线创建和管理、数据备份支持本地和异地备份、任务计划自动任务、以及模块扩展，可以通过官方在面板的基础功能上扩展更多的功能。面板支持在线升级，减少工作量，更傻瓜化、简单化。
安装 

注意： 已经停止维护更新，所支持系统也仅限于如下几个：  、  、  、  、  、  、   、   这里我们演示的时候，选择的是腾讯云  新版本 支持至所有的最新系统，但是已经成为了收费软体，因此这里不选择其进行安装。

根据官方提示，我们按照如下操作进行安装：
 使用  账号登录  服务器。
 执行  安装脚本。  
         |  
 根据提示输入选择选项。为安装，为卸载，为退出不做操作。
输入回车，接着输入与密码即进入安装流程，安装过程大约需至分钟以服务器性能为准，最后如看到安装成功提示，说明系统已安装完成。
成功安装后有必要请删除日志文件，如安装失败需协助安装请把错误日志反馈我们。
访问 即可进入 端管理，默认账号为。
执行输出大体如下：
================================================================
      
 
================================================================
   

   
================================================================
      
   
   
 
 
     
   
    此处需要填写自己的
    

    填写 密码，注意脚本中输入密码为明文
    

    填写 面板密码，注意脚本中输入密码为明文




各种安装软件的输出



   
=============================================================
      
 

  
=============================================================
      
 

   
  
=============================================================
      
 

  
  
=============================================================
      
 

   
正在启动 ：                     

=============================================================
      
 

================================================================
     
  


 

   
  
  
  
  
  
  
  
  
   
   
   
  

   
 
 
 
 
 

  年 月 日 星期二  
  年 月 日 星期二     
   
================================================================
接着，我们访问，进入 端管理，进行操作。

在 端配置网站访问
配置虚拟主机
这里，我们就需要一个域名了。接下来我继续以这个二级子域名来演示。
进入后，单击虚拟主机下的虚拟主机标签，在下方的新增虚拟主机表单处的主标识域名输入需要绑定的域名，例如我这里输入。注意域名需要换成自己的。

其他的不用动，直接点保存即可。
配置数据库
单击下的快速建库，在数据库名称、用户名、用名密码处输入相关信息，并记录下来。单击创建即可。如图所示。

安装
紧接着，我们回到命令行终端界面，首先进入网站文件夹：
  
备份已存在文件：
   
下载：
  _
解压文件
   _
移动文件
   
访问域名，进行最后一步的安装。

安装情况同上节相关子节，请参见上一节的相关子节

在服务器上安装并完成网站创建
是  的简称，是一套通过控制和管理服务器的服务器管理系统以及虚拟主机管理系统，旨在易于使用系统做为我们的网站服务器系统，以及平时对服务器的常用管理操作，均可在的后台里操作完成
关于的安装，这里不多介绍了，与相似，而且功能跟更强大。相关安装教程请单击此处获取，网站上也有不少教程。

 版本已经发布，更多可单击此处查看

【懒人安装——腾讯云镜像安装】
又是前奏：环境检查

操作系统：  腾讯云镜像版本
服务架构：
软体版本：腾讯云镜像

安装步骤
这个比刚才那个还简单，整个一个傻瓜操作。

登陆腾讯云管理中心，根据你所买的服务器的地域，找到你的 ，点击重装系统。注意：如服务器正在运行，则需要停止服务器才可以重装系统

重装系统时选择 服务市场建站模板 博客平台   位，之后输入密码，点击重置即可。
 



通过进行连接：终端；：终端或；：或服务器，格式如下：
  用户名地址   
 进入后，通过命令 查看、等相关帐密。
 



按照提示，进入服务器，登陆相关账户可以进行设置  的地址为 
 


小结
这个方法比较简单，就不过多介绍了。
【文艺安装——安装】
永恒不变的前奏：环境检查

操作系统：本例使用的大部分在  与   位上可行
服务架构：
软体版本： 


 目前只能安装在  位平台上，并且要求内核版本不低于 ，实际上内核越新越好，过低的内核版本容易造成功能的不稳定。

第一节：安装演示的是  版本

本节节选自《——从入门到实践》，图书在公开阅读且接受。向开源作者致敬！

这里与根据系统不同选择阅读即可，如果非深入学习不必全部阅读。
 安装
系统的要求是： 位操作系统，内核版本至少为 。
 目前支持   及以后的版本，推荐使用   系统。
安装软件源
首先，添加  软件源。
    

= 
=
=
=
=

安装 
之后更新  软件源缓存，并安装 。
   
     
对于   系统， 源中已内置 ，如果已经配置了 源，可以直接通过上面的  命令进行安装。
另外，也可以使用官方提供的脚本来安装 。
     | 
后续配置
可以配置让  服务在系统启动后自动启动。
    
配置完成后截图：获取版本

 安装
更新镜像源
首先需要安装  包支持  协议的源。
     
添加源的  密钥。
       
获取当前操作系统的代号。
 _ 
       
一般的，  代号为 ，  代号为 ， 代号为 ， 代号为 ， 代号为 。这里获取到代号为 。接下来就可以添加  的官方  软件源了。通过下面命令创建  文件，并写入源的地址内容。非  版本的系统注意修改为自己对应的代号。
     
   

添加成功后，更新  软件包缓存。
   
分版本的预安装任务
这里演示高于  的版本

   
  
   

为了让  使用  存储，推荐安装  软件包。 
      
在   或者 上安装，需要安装是内核的一个安全模块，新版本的已经被整合到内核
    
安装 
在成功添加源之后，就可以安装最新版本的  了，软件包名称为 。
     
如果系统中存在旧版本的  ，会提示是否先删除，选择是即可。
第二节：安装基础环境及
抓取镜像灵雀云镜像，下同：
  
抓取镜像
  
建立容器
     __=  
其中，是数据库名，为这个数据库的密码。
建立容器并运行
         
其中，为镜像名，为你所起的数据库名与数据库类型，：为 容器端口与宿主机端口映射设置。
启动后，我们可以通过 命令查看现在系统中运行着的容器

我们可以看到，现在数据库与的容器都运行起来了，现在就可以通过地址访问了为保护隐私，接图已隐去地址

小结
其实看起来命令比较多，其实都不复杂。简单的几行命令就完成了。而且更多的还在虚拟化技术，这都需要我们一起去探索哦
参考资料

     上安装     水景一页
 —— 从入门到实践  
曾金龙，肖新华，刘清编著开发实践北京：人民邮电出版社
白宦成， 使用腾讯云市场  镜像部署博客 黄冈师范学院 

相关推荐： 【腾讯云的种玩法】几种在腾讯云建立的方法一 如何在腾讯云快速构建一个个人站点作者：段超

什么是测试分析？
在软件测试过程中，以最小的成本将软件质量风险降至最低，这就是精准测试。宏观上，测试分析是响应精准测试的实践，贯穿整个测试过程，并对整个测试过程起指导作用；实践中，测试分析在测试阶段中的位置如图所示图测试分析在测试流程中的位置
在项目中，我们往往根据需求和代码来进行分析，最后得到一个包含需求背景、开发实现分析、测试纬度等内容的格式的简版分析报告。图测试分析模版
这里结合实践说明一下分析的过程以及分析侧重点。本文主要针对于增量的需求进行测试分析，对于全量的新项目，侧重点可能并不适用。
基于需求的测试分析
互联网项目一般都追求快节奏，所以需求描述得比较简单，甚至可能会有一些重要逻辑未考虑的情况，对这样的需求进行分析时，推荐使用模型来进行需求分析，理解需求、消除歧义。关于模型可参见这里。模型帮助测试同学理清需求，借助传统的用例设计的方法正交分解、判定表、边界值、等价类、场景法等等，可以设计出一些基于需求的用例。对需求进行测试分析，可以得到黑盒的测试策略，这一步可以在需求提出即可立即开展。
基于实现的测试分析
通过查看开发的提交，分析开发实现，进而得到测试策略。下面重点说明一下基于实现的测试分析，也正是有别于传统基于需求的用例设计的分析方法。
一、查看代码提交
的提交是进行代码测试分析的输入，根据开发的提交来进行实现分析，进而得到最终的测试策略。
代码提交要求：
、减少提交次数量：提交次数过多，人员容易被中间版本误导，影响效率，提高的成本。
、提交与需求关联：提交必须与需求关联，并且一次提交必须仅与一个需求关联。
、不提交无关代码：开发提交的代码中往往包含一些与需求无关的代码，可能是预埋逻辑，可能是备选方案。这些代码会影响人员的注意力，甚至会引起漏分析预埋逻辑时未分析、真正使用该逻辑时也未分析。
项目中测试人员应提醒开发注意养成良好的提交习惯。目前电脑管家全面推行使用公司组件，规范化提交。
拿到与需求关联的提交后，我们可按照以下步骤进行分析：
二、理清类关系可选
对于一般业务来说，一次迭代涉及的类不会太多，通过一些分析软件如可以立即生成类图供查看。类图虽然不能直接反应出业务逻辑，但对于理解开发实现的大致结构很有作用。通过类图可获取到一次迭代涉及哪些类以及类之间的继承关系，了解类大致成员有哪些。生成的类图
三、寻找核心业务入口
一般来说业务总会有一个入口点，找到入口点才能顺藤摸瓜。例如一个点击之后的很有可能是触发类似的回调函数，那么这个函数即是我们的入口函数。有的业务有多条业务线，可能有多个入口，列出每个入口，后面一条条进行分析。
四、查找函数调用链
从入口函数出发，找到所有业务函数调用链。这一步骤是整个测试分析的核心，直接关系到测试分析的质量。在查找业务函数调用链的过程中，注意核心函数的逻辑结构，如果非常复杂，可以借助控制流图来单独对函数内部结构进行分析，检查每个分支是否符合需求逻辑。生成的控制流图
五、寻找测试点
和开发有点不同，我们是带着测试分析的目的去的，即根据代码来找寻测试点。面对大量的代码提交，不要被代码带进去，深究一些非核心的细节往往会本末倒置，始终保持怀疑的态度去找寻测试点。对于一般程序，这里总结几个侧重点，可能并不正确，请大家拍砖。
重逻辑
往往在测试执行中容易发现问题，而逻辑的触发可能比较隐蔽，测试执行中不易触发。在项目时间紧张的情况下，把时间花在理清逻辑上更重要，也容易发现问题。当然一些逻辑触发意味着的变化，这样可以借印证逻辑的变化，是更好不过了。
重逻辑
往往在测试执行中容易发现问题，而逻辑的触发可能比较隐蔽，测试执行中不易触发。在项目时间紧张的情况下，把时间花在理清逻辑上更重要，也容易发现问题。当然一些逻辑触发意味着的变化，这样可以借印证逻辑的变化，是更好不过了。
重异常
以上比例的异常用例是我们的目标。可以说异常用例的设计直接体现了一个测试人员的分析能力。在平时的工作中多注意总结和收集，逐步积累。比如对于任意一个关于设置本地路径的业务，都可以思考如下测试点：

超长路径
带空格的路径
带中文的路径
磁盘空间不足


他山之石，可以攻玉。和开发一样，测试同学遇到的的问题都是别人遇到过的。所以我们可以从如下几个方面汇总他人的经验教训：

业界开发规范
部门开发规范
异常用例
线上下分析

关于异常用例方面的总结，笔者也在总结和收集中，期待与大家的交流。
重动态
里面有很多状态变化、事件响应、消息传递等动态的内容，理清这些动态内容对于我们理解业务非常重要，同时很多来源也在此。

事件
定时器
线程
互斥量
信号量
临界区_

在遇到这些关键字时，我们不妨 检查所有用到这些对象的使用是否有问题。具体包括：

创建和销毁是否对应
状态改变是否符合逻辑
销毁时机是否合理，销毁逻辑是否正确
销毁后是否仍可能使用

同时，业务上一些核心的状态、标识、模块间通讯的数据等也属于动态内容，也可以加强对这些内容的检查及用例设计。
重第三方
如果对某次迭代进行分析时，发现引入了第三方的库，我们需要特别关注对第三方库接口的使用情况。从功能、性能、稳定性、安全性等各个维度对接口进行评估，特别是频繁调用的接口，更应保持谨慎的态度，评估影响、输出风险点。对于第三方接口，一般都需要考虑兼容性，尤其是不同系统的兼容性。
六、分析耦合
在查找函数调用链中，我们在梳理核心业务逻辑时，就会找到第三方库的使用。中，在变更的代码中搜索关键字，也可以找到装载的模块。库如果是非微软提供，我们更需要小心。如果有使用第三方库的情况，通常会专门将其列出进行分析。
另外耦合还包括内部模块与模块之间的关系。这里笔者采用需求矩阵的方式来进行思考。
七、脑暴异常
异常的思考作为剧本式分析方法的一个补充，可以起完善测试策略的作用。通常也会在中专门列出来。异常种类各式各样，非正常环境、非正常操作、非正常输入都是我们可以考虑的异常点。比如某个业务流程中直接退出窗口或者取消任务，连续快速点击某个按钮、在精简版的操作系统中运行程序等等。
结束语
本文为业务测试人员提供一个测试分析的思路，特别适用于快速迭代的业务测试，对于专项测试本文介绍的思路并不完全适用。限于水平有限，很多内容可能并不正确或者完整，请斧正。
本章完近日，腾讯深圳总部 浙江西湖高等研究院独立实验室负责人李牮博士进行了一场名为 “从奇异粒子到量子计算”的科普讲座。李牮引领听众一窥即将到来的量子革命的一个重要前沿——量子计算，并进一步介绍其中非常有趣并极具潜力的一种方案——“拓扑”量子计算。作为拓扑量子计算的基石，李牮博士还介绍大家认识了一种性质奇异的粒子——马约拉纳费米子。接下来，让我们跟着李牮博士，来看看这些令人着迷的物理怎样有机会在不远的将来再次深刻地改变人类的生活。

在谈量子计算之前，我们要先从什么是“量子”说起。这里的“量子”，其实是由量子力学所描述的事物的泛称。在量子的世界中存在着不少与我们从日常生活的“经典”世界中获得的经验不同的东西。举例来说，在经典的世界中的一只灰猫，无论人们什么时间看它，它都是灰色的；而在量子的世界中的一只灰猫，人们在看它的时候会发现它有时是黑色的，有时是白色的，只有在统计意义上它才是“灰色”的见上图。我们把这只量子猫所处的状态叫做黑和白的量子叠加态。

如果我们进一步将黑和白当作和这两个二进制数，那么这只量子灰猫实际上就是一个量子比特。不同于“非即”的经典比特，每一个量子比特都处在“既又”的量子叠加态。这样的量子叠加态可以由两个复数组成的一个矢量来描述见上图，而每个复数的模方对应着这个量子比特在被读取的时候显示或者的几率——用我们刚才的量子灰猫的例子，这些几率也就是我们实际看到它是一只黑猫或者一只白猫的几率。

量子计算就是从若干个量子比特的初始状态出发，通过一系列变换操作，得到某个特定的终态作为计算结果上图是一个简单的例子。这里，量子计算与经典计算最根本的不同就是在于量子计算操作的对象是多个量子比特的量子叠加态。如果量子比特的总数目为，而每个量子比特或或，我们就有种排列组合例如，如果=，我们有下列排列组合：，，，，，，，。这些排列组合构成了量子叠加态的基础——我们的个量子比特可以“同时”以一定几率处在种状态上，类似于我们的一只量子灰猫可以“同时”处在黑和白两种状态。换句话说，基于个量子比特的量子计算机可以对种状态进行并行处理，从而达到经典计算机无法企及的计算能力假设足够大。
然而，成功制造出一台强大的量子计算机远非易事。这其中最大的障碍是量子退相干。简单的说，量子退相干会破坏我们的量子叠加态，是我们在日常生活中很难直接看到奇特的量子现象的“罪魁祸首”。量子退相干的来源又是无处不在的——温度、外界环境的各种干扰都能带来量子退相干。要想有效的克服量子退相干，一个非常有吸引力的方案就是拓扑量子计算。

拓扑是数学的分支，它不关心物体局部的细节，而只关心整体的分立化的性质。举个例子，一个茶杯在拓扑上可以等于一个甜甜圈，因为它们都有一个孔。茶杯的孔是把手的地方，甜甜圈的孔当然是它中间的孔。另外一方面，一个球和任何一个没有孔的东西是等价的，因为你总是可以把它捏成另一个东西见上图。当拓扑的概念应用到量子计算中来，就是我们想要找到一种特殊的系统，让其中的量子比特以及对它们的操作不受局部细节干扰的影响，从而很大程度上避免量子退相干。在现阶段，最接近实现拓扑量子计算的这样一个特殊的系统是基于奇异的马约拉纳费米子的。

马约拉纳费米子是一种“特立独行”的费米子。通常的费米子，例如作为代表的电子，和它的反粒子正电子具有截然相反的电荷——电子带负电，正电子带正电——从这个角度说，我们可以把它们看作一黑一白。然而马约拉纳费米子有点像我们中国的太极，它的反粒子——如果我们想象成把黑白互换——其实就是它自己见上图。但这还不是马约拉纳费米子奇异性质的全部。如果我们把两个马约拉纳费米子“拼”到一起，我们可能看到两种结果，如同我们得到黑色或者白色见下图。这很像我们开头所说的量子灰猫，或者量子比特——唯一的不同，也是根本的不同，是现在这个量子比特由两个马约拉纳费米子组成，而这两个马约拉纳费米子可以分处在相距很远的不同位置。这种分散于空间中的量子比特可以有效的对抗局部干扰带来的量子退相干。


更为有趣的是我们在这样的量子比特系统中实现计算操作的方法——编织。这里所说的“编织”是想象在一个平面中分布的若干个马约拉纳费米子随着时间而相互围绕运动所形成的图像见上图。精妙的物理和数学理论告诉我们，通过特定形式的编织，我们能够实现对马约拉纳费米子量子比特的某些基本操作，从而构成量子计算的基础。重要的是，这些编织的形式也具有拓扑的意义——如同一件织好的毛衣，无论穿着它的人身形如何，毛衣并无真正分别除非毛线不幸断开。
至今为止，制造一台真正强大的量子计算机，无论是拓扑的还是非拓扑的，仍旧是物理学家们夜以继日奋力追求的目标。但是我们有理由相信，美妙的物理将在不远的未来通过量子计算再次为人类的生活带来深刻的变化。


在讲座的最后，李牮博士介绍了西湖大学的办学理念、发展思路、建设进展。谈及加入西湖大学暨浙江西湖高等研究院的初衷，他这样说道，“对我而言，科研中的未知往往是财富：我享受它带来的煎熬，更享受解开未知后的骄傲。西湖高研院亦是这样的未知，我将致力于将她变成我和所有人的骄傲。”
附：李牮博士个人简介


李牮，湖北武汉人，曾为普林斯顿大学物理系博士后。年于西北大学获学士学位并保送进入中科院物理所；年转入香港大学并于年获得博士学位；年底至年在瑞士日内瓦大学从事博士后研究；年至年在美国普林斯顿大学从事博士后研究。 现为浙江西湖高等研究院理学研究所研究员。腾讯云商业智能分析产品由北京永洪商智科技有限公司提供，永洪一站式大数据分析平台

创建数据集模块常见设置
创建数据集的主要功能是从数据库查询出所需的数据，从而进行数据分析。在创建数据集处，可以对数据进行一些简单的处理，如数据级别的权限设置，字段信息修改，字段管理等。接下来详细介绍一下创建数据集模块常见的设置。
一、常见设置
、新建层次
在新建层次之前，我们先熟悉一下产品的钻取功能，钻取包括上钻、下钻、以及穿透钻取，其中上钻、下钻功能适用于表、交叉表、图表，穿透钻取只适用于图表。
产品的钻取功能的前提需要对数据进行层次设置，层次设置的主要操作步骤如下：
右键选择新建层次，输入层次名称则在维度目录下生成层次文件夹

将对应字段拖入层次文件夹中；

注意：在该层次文件夹下数据段的排放顺序决定了数据段间的级别关系，默认排列在上方的数据段的级别最高，依次往下类推。

在编辑报告处可以建层次文件夹中的字段绑定到表格或图表上，进行钻取操作。

、新建文件夹
在数据字段较多的情况下，字段管理起来比较麻烦，在使用数据字段时也很难找到对应的字段，这里可以通过新建文件夹的方式将同一主题的字段放到同一文件夹中进行管理。新建文件夹的操作步骤如下：
右键选择新建文件夹，输入文件夹名称，则在维度目录下生成对应名称的文件夹；

将需要放入到文件夹中的字段通过数据拖拽到文件夹中；
、设置字段别名有些时候数据字段从数据库中查出来的名字比较复杂或不容易懂，在编辑报告时分析起来就不方便，这里可以可视化修改数据字段别名，具体操作是在数据字段与别名的交叉处双击，输入别名即可。

、设置字段可见性
有时从数据库中获取的字段，有的在某个主题的分析中不需要，为了方便在编辑报告时使用找到其他字段，可以将这类字段隐藏。具体操作是点击字段信息后面的可见性设置按钮。

、设置数据加载条数
由于有的数据量较大，预览起来加载时间会比较长，这里我们可以对数据加载条数进行限制，产品默认显示的是行。在元数据区域顶端右上角，在样本条数中输入的数据就是加载的数据条数，如果需要显示全部数据，勾选全量数据即可，如下图所示。

二、数据级别的权限设置
、列过滤器
在管理系统  认证授权  安全管理下设置文件权限后，在查询的元数据区域会显示列过滤器的操作项。列过滤器可以对用户，角色和组设置不可见的权限。
当鼠标点击数据字段与列过滤器的交叉处时，将会显示提示文字：编辑，点击编辑，则会弹出列过滤器对话框。

【可用列表】列出了所有可以被设置权限的用户，角色和组。只有具备 _ 和 _的用户才可以设置列权限。
对于 _ 的用户  可用列表会列出所有的用户，组和角色。
对于 _ 的用户，只列出 _ 下的所有用户和组。
【已选列表】添加到已选列表中用户，组或角色在预览查询或查看报告中不能看到所编辑的列。比如：对产品列进行列过滤器编辑，将  添加到已选列表中，应用并确定。再用  登录后，在预览查询和编辑报告中都不能看到产品列。
【添加】将可用列表中的用户添加到已选列表中。
【移除】将可用列表中的用户移除。
注意：可见性与列过滤器的区别和关系：
区别：可见性设置是针对所有用户的，列过滤器设置是针对部分用户的。
关系：在可见的状态下，可以对用户，组和角色设置列过滤器。设置后，所设置的用户，角色和组对设置列不可见而其他的用户，组和角色不受影响。
     在不可见的状态下，列过滤器的对话框为置灰状态的。不能对列过滤器进行编辑。
、行过滤器
在元数据编辑区域顶端点击行过滤器，点击编辑行过滤器打开行过滤器对话框，可在该对话框内设置过滤条件，这里可以针对所有用户记性数据量限制，如下图所示，所有用户都只能看到产品名称为柠檬花菜对应的数据。

行过滤也可结合权限设置过滤条件，如下图所示，只有组名与区域分布的数据值相同的用户可以看到对应区域的数据。

注意：行过滤与权限相结合，需要注意对应权限数据设置与过滤列中的数据相同，如上图，组名与区域分布字段的数据相对应。焦点：
焦点可以理解为选中态，在 上起很重要的作用。一个视图控件只有在获得焦点的状态下，才能响应按键的事件。

上图中，外面有一个绿色光圈的视图，就是当前有焦点的视图。
相对于手机上用手指点击屏幕产生的事件， 在使用 的过程中，遥控器是一个主流的操作工具，通过点击遥控器的方向键来控制焦点的移动。当焦点移动到目标控件上之后，按下遥控器的确定键，才会触发一个事件，进而去做下一步的处理。焦点的移动如下图所示。

基础的用法：
在处理焦点的时候，有一些基础的用法需要知道。首先，需要为，一个控件才有资格可以获取到焦点，可以通过方法来设置。如果想要在触摸模式下获取焦点在我们用手机开发的过程中，需要为，可以通过来设置。也可以直接在布局文件中指定：

    
    =
    =
然后，就是控制焦点的移动了。在谷歌官方文档中提到：焦点移动的时候默认的情况下，会按照一种算法去找在指定移动方向上最近的邻居。在一些情况下，焦点的移动可能跟开发者的意图不符，这时开发者可以在布局文件中使用下面这些属性来指定下一个焦点对象：




在代码中，让一个指定的获取焦点，可以调用它的方法。
遇到的问题：
尽管有了官方文档中提到的基础用法，但是在进行 开发的过程中，还是经常会遇到一些焦点方面的问题或者疑问，如

“明明指定了焦点，焦点却跑丢了”
“里居然截获不到按键事件”
“我没有做任何焦点处理，焦点是怎么自己跑到那个上的”

接下来，带着这些问题，我们就从源码的角度出发，简单分析一下焦点的移动原理。本文以 作为参考。

在手机上，当手指触摸屏幕时，会产生一个的触摸事件，，进而完成点击，长按，滑动等行为。
而当按下遥控器的按键时，会产生一个按键事件，就是，包含“上”，“下”，“左”，“右”，“返回”，“确定”等指令。焦点的处理就在的分发当中完成。
首先，会流转到中开始进行处理，具体方法是内部类中的。在 之前，是这个方法，逻辑大体一致，本文仅以作为参考

    {
           = 
        
               
          先去执行的
          {
             _
        }
        
            
          == _ {
              = 
            
              =  {
                  = 
                  =  {
                      之后会通过去找下一个焦点视图
                      = 
                      =    =  {
                        
                           {
                            
                             _
                        }
                    }

                                
                       {
                         _
                    }
                }  {
                                 
                      如果当前本来就没有焦点视图，也会通过找一个视图
                      =  
                      =    {
                         _
                    }
                }
            }
        }
         
    }
从几处关键的代码，可以看到这里的逻辑是：

先去执行的
之后会通过去找下一个焦点视图
如果当前本来就没有焦点，也会通过找一个视图

就是，继承了，但本身并不是一个，可以看作是树的管理者。而这里的成员变量就是，它指向的对象跟和的指向的对象是同一个对象。所有的组成了一个树，每一个都是树中的一个节点，如下图所示：

最上层的根是，中间是各，最下层是。本文的分析都是基于树的。
在中，首先走了的，也就是从开始进行的分发。
 
首先走的，之后会依次从的方向分发。有兴趣的话可以通过看一下的流转方向：

对于的分发，之后会另开一篇细讲，包括的处理优先级，长按的识别等，这里只简单看一下和的。
首先看的。

    {
    
       _ | __
            == _ | __ {
          以的身份处理
          {
             
        }
    }    =     __
            == __ {
          以的身份把交给处理
          {
             
        }
    }
    
     
}
通过的判断，有两个处理路径，也可以看到在处理时，扮演两个角色：

的角色，也就是此时需要在自己与其他之间流转
的角色，此时需要在自己的子之间流转

当作的时候，会调用自己的。
当作的时候，会调用当前焦点的。
其实，从概念上来看，都是调用当前有焦点的，只不过有时是自己本身，有时是他的子。
再看看的
    {
    
      = 
      如果设置了，则优先走方法
      =    =     _ == 
                {
         
    }
      把自己当作参数传入，调用的方法
       = 
                 {
         
    }
    
     
}
这里，会优先处理的回调。然后才可能会走的，最终走到的或者。
将大体的流转顺序总结如下图

其中任何一步都可以通过 的方式来消费掉这个，结束这个分发过程。
 
如果没有消费掉这个，会由系统来处理焦点的移动。通过的方法找到下一个获取焦点的，然后调用
那是如何找到下一个焦点视图的呢？
 
     {
      =  {
          
    }  {
         
    }
}
并不会直接去找，而是交给它的去找。
 
      {
      {
                   
                  
                   
           
    }    =  {
          
    }
     
}
判断是否为顶层布局，若是则执行对应方法，若不是则继续向上寻找，说明会从内到外的一层层进行判断，直到最外层的布局为止。有意思的是，提供了设置的方法，但又了起来不让使用，看来这个逻辑还有待优化。

  {}
 
             
         
 
    {
      {
         |= ___
    }  {
         = ___
    }
}
最后的算法交给了
  
的把自己和当前焦点以及方向传入。
 

         {
        
}

          {
      = 
      =  {
          优先从或者代码中指定的中找
         =   
    }
      =  {
         
    }
      = 
     {
        
         
          {
              其次，根据算法去找，原理就是找在方向上最近的
             =     
        }
    }  {
        
    }
     
}
这里是上面为的，是当前焦点视图
优先找开发者指定的下一个的视图 ，就是在或者代码中指定 的视图其次，根据算法去找，原理就是找在方向上最近的视图
 
 
        {
          
      =  
      =   
             
                    ||  {
         
    }
     
}
首先执行的方法
 
      {
      {
         _
              == _  
              
        
        }
    }
     
}
比如，按了“左”方向键，如果设置了，则会通过去找这个。一般是在里面设置的，比如

    =_
    =_
     
也可以在代码里设置
_
来看看做了什么。
      {
      ==  {
         可以理解为一个判定器，如果匹配则判定成功
         =  
    }
     = 
      =  
    
     
}

       {
      = 
      {

         从当前起始节点开始寻找是遍历自己的，寻找匹配的，跳过，具体可去看和中该方法的具体实现
          =  
          =  ||  ==  {
             
        }

          = 
          ==  ||    {
             
        }

         如果如果当前节点没有，则往上一级，从自己的中查找，并跳过自己
         = 
         =  
    }
}

      {
      {
         
    }
     
}
的
 

      {
      {
         
    }

       = 
       = 

       =      {
          = 

          =     ___ ==  {
             = 

              =  {
                 
            }
        }
    }

     
}
可以看到，这个方法从当前指定视图去寻找指定的视图。首先从自己开始向下遍历，如果没找到则从自己的开始向下遍历，直到找到匹配的视图为止。这里要注意的是，也许存在多个相同的视图比如，，等场景，但是这个方法只会返回在树中节点范围最近的一个视图，这就是为什么有时候看似指定了，但实际上焦点却丢失的原因，因为焦点跑到了另一个“意想不到”的相同的视图上。
接《从源码出发浅析 的焦点移动原理下篇》引言
大家好我是香港大学机械工程专业的一名在读研究生在大四学年瑞典皇家理工学院交流学习的过程中阴差阳错的将 当作机械类课程选择从此打开了我通往机器学习的大门这篇分享算是对我初赛阶段的工作与成果做一个总结也分享一些心得希望能帮助到更多对机器学习及广告系统的感兴趣的同学
我是神经图灵机队伍的唯一一个队员 一个人做优点是自己非常清楚比赛的节奏以及目前结果的优劣因为从数据处理特征工程模型搭建训练调优这一系列过程完整的做下来后对比赛想不了解都难但还是羡慕组队的同学毕竟一个人思维会有限制而且工作量也大大提升 不过建议在未来比赛中大家在对数据与题目有充分了解的情况下做出较为满意的成绩再与其他成绩相仿的同学组队这样会事半功倍结果也会有较大的提升
 对赛题及其工业背景的深入了解
虽说目前的机器学习工具包功能强大诸如等的分类器使用默认参数就可以从没有处理过的数据中提取出有价值的信息做到效果很好且繁华能力很强但想要更上一层楼还是要脚踏实地
首先我所花时间最长也是感觉最重要的一环是对赛题与数据要做到非常充分的了解比赛名为腾讯社交广告算法大赛那么我们一定要花一些时间了解一下当今媒体广告包括腾讯广点通平台的运营和收费机制这些知识虽然看似与赛题不想管但在我目前来看对我特征工程和数据处理起到了潜移默化的巨大的影响举个例子在比赛数据中出现了广告主推广计划广告素材这样的级树关系应该所有同学都能从字面上理解这样的层级关系在数据处理时进行类似树结构的方式也并不难想到但其实仔细推开社交广告运营的机制我们还能从这样的关系中发掘更多潜在的机器学习分类器很难自我学习却有价值的特征
 数据可视化及分析
对数据分布统计在每一个数据竞赛中都会需要 较为体系化的分析流程与开源代码教程也不难找到 本次大赛的另一个特点便是数据带有时序性 这给数据处理与分析造成不小的困难 我这里主要分享一些我所做的涉及时间序列的分析工作与成果
 截止至该日共出现的各个变量的不同值的数量
可以看到 每日都会有新的之前从未出现的以及加入对   也等同 这就意味着除了按日期划分的训练集中各个变量不一致外 在线上预测集中一定会有训练集中不存在的 所以在选择特征与训练集时要尽量做到将类特征抽象 例如统计转化率 做聚类等 而避免直接使用类特征

 转化率分析
转化概率是本次比赛预测的 与其最为相关的便是各个对应的了 官方所给就是将历史统计的转化率来直接作为概率进行预测 
下图所示为每日所有的平均转化率 其中蓝色线为原始数据 考虑到最后五天的训练数据有误 又额外做出绿色线转化时间小于等于天 红色线转化时间小于等于两天 可以看到 转化率在日及以后较为稳定 在日出现转化率的剧烈变化 且这两日的数据总数也明显少于平均水平 可能是恰逢节日或数据上传误差等因素 综合考虑 日之前的数据暂时被弃用

 时序分析
笔者还对日转化率进行了 分析及拟合 但由于总日期数过少 且波动较大 可能属于非稳定时间序列 并不能通过去趋势等方法进行较好回归
 训练集选取与特征提取区间
如果说在机器学习中有比特征还要重要的 那就是训练集的选取了 最好的训练集莫过于与线上测试集的变量分布完全相同 这样的情况下线下的训练结果可以完美的用于线上数据的预测 这种情况在一些特定的 数据分布较为稳定的机器学习问题中可以实现 
但对本次社交广告算法大赛 首先训练样本有时间先后关系 而且如中分析 每日的 都各不相同 所以存在这样的一个隐含因素 即若预测日数据 则使用越接近日的数据训练 则预测效果应该会越好 但同时另一个问题 即日以后的数据 由于回流时间为日 所以截止至日时并不能准确统计广告是否转化 且该问题在  两日尤为严重 所以最后结合线下与线上测试 我选择了  三天的数据进行线下与训练 并用于线上测试 在初赛阶段 线下线上误差基本一致 且增减情况良好

 特征工程
在对赛题与数据有了充分的了解后第二步就是特征工程了特征工程上我目前还没有非常得意的大家日日所念的  我基本上是每天优化一些自己的特征每天的成绩虽然进步不大但也在稳步前行交流群中几位大佬多次提及的强特征我至今也没有悟到但也许后面就会慢慢发现也许我已经提出了出来 
在特征工程上最重要的 也是三周里每一组周冠军都提到过的 线上线下一致 好多同学对这点理解不清 其实用逆向思维 首先对日的预测集提取特征因为是最后一天所以无论如何都不会发生数据泄露 这个时候再仿照日数据特征提取的方式与时间区间 一步一步提取 就可以有效的规避数据泄露 有效的避免数据泄露 可以做到线上线下同增减 这样的情况下 当我们加入新特征线下误差降低时 我们便可以推断出该特征有益 反之亦然 考虑到预测集为日 其前天的有不准确的情况 但仍然可以进行统计 但生成训练集时 必须对特征提取区间模仿日数据做处理代码如下 例如处理日的数据 那么提取之前的特征时 只能够提取转化时间小于日点的数据 否则会造成训练集与预测集特征不一致
 __ 
     = _ = 
    _   = 
     _
同时 另一个难点是在根据历史观测值进行转化率统计时 出现了样本稀疏的情况 则根据中心极限定理 观测概率并不能较好的代表真是概率 在预估中 两个经典的方法便是贝叶斯平滑与指数平滑 相关博文在互联网都不难找到
我这里再说一点我结合本次大赛数据 对贝叶斯平滑做的一点点小的修改 例如对我们数据中存在的          层级关系为训练集中全部样本 这样的层级关系隐喻了在同一个父节点下的子节点 其来自于同一个分布 所以我逐层进行了贝叶斯平滑 且建立层级关系还有一个好处 即对预测集出现的数据 若该 在训练集从未出现过 则在时该值为空 则向上寻找其父节点的统计值 最高一层为 是基与全部训练数据的统计 的值不进行贝叶斯平滑 且一定存在 这就保证了当在预测集中遇到了未出现的样本时 使用最合理的缺省值进行补全

 机器学习模型
目前我在使用与两种模型 好处是模型泛化能力强且速度快 可以最快得到结果以进行特征筛选与调试 模型和是提升最终结果的利器但不建议大家太早使用一是浪费时间是这样的大杀器是否使用对我们结果本质的提升是没有帮助的因为如果现在使用融合效果提升那么未来其他同学加入模型融合后也必然会赶超自己
总结
最后还是希望大家脚踏实地使用或自己喜欢的语言静下心来一步一步的做好数据分析多从数理统计的角度想问题 增加每一项特征或对训练集与模型的没一点修改 都要有理论支持 这样不仅比赛成绩会一步一步的变好 更重要的是在积累下了扎实的数据挖掘与分析基础 真正实现参加比赛提升自我的目的
参考

背景
上一篇 《 入门：求  元一次方程》根据官网的入门教程，使用基础的  稍作修改解决了  个数据的权重问题，再继续看官网后面的教程，有一篇  高级  入门教程教我们如何使用 深度神经网络分类器实现对鸢尾花的分类。刚看到这篇文章的时候，中间出现了几种鸢尾花的图案，我还以为输入是图片， 会进行图片识别，后来发现输入的训练集只是一组组特征数据包含花萼的长度宽度和花瓣的长度宽度对应分类，可以看做能够解决这样的一个问题：给定一组特征数据，求这组数据的分类。 和之前一样，先分析一下原文中的示例，很多文章对原文中的示例进行翻译，但是并没有举一反三，这样其实学习效果并不好，本文会在学习后使用原文的方法，解决一个新的问题。 由于作者能力有限，目前仅停留在使用阶段，先培养机器学习思维方式，对于原理部分，可以参考其他的资料。能保证的是，阅读本文不会让你过于枯燥，也不会很难，我的宗旨是用简单的语言将复杂的问题说清楚。
原文示例
 原文链接在这里，我们先逐行分析一下，首先进行必要的包含工作，我对  不是特别熟悉，前面这  行我还专门去查了一下是什么含义，具体可以参考  这篇文章：   
 ____  _
 ____  
 ____  _

 
 

   
   
然后定义训练集和测试集的路径，这次的数据是以  的格式加载进来：
_ = _
__ = _

_ = _
__ = _
然后进入到主函数，主函数首先是将训练集和测试集的  文件下载下来：
           
  _
         = __
         _   
                

  _
         = __
         _   
                
下载下来的文件可以打开看看，我们打开训练集：










可以发现首行的格式看起来并不是一个表头，这个格式是有规范的，但是原文没有讲，我们继续往后看它是怎么读取的：
  
_ = ___
        =_
        _=
        _=

_ = ___
        =_
        _=
        _=
 使用 ___ 对  文件进行读取，它有  个参数：

： 文件名
_：目标数据的类型，本例中为分类 ，使用整形表示
_：特征值的类型，本例中是花萼花瓣的长宽度，使用浮点数表示

打开 ___ 的源代码，可以看到它的实现方式：
 ___
                                                 _
                                                 _
                                                 _=
            
       _
        _ = _
         = _
        _ = 
        _ = 
         = _ _ =_
         = _ =_
            _
             = _ =_
             =  =_

     = =
这样就很清楚了，使用 ___ 函数读取的  文件首行前两列分别表示数据组的个数和每个数据组的特征数，训练集中一共有  组数据，每组数据包含  个特征。首行的另外  个数据，实际上并不会读取到。具体的特征数据从第二行开始，最后一列为目标值即训练完毕后期望的输出值，前面的  列为特征数据即训练完毕后的输入值，这个  必须和第一行第二列相等，否则就会读取失败了。 数据读取完毕后，可以把结果打印出来看看：   
_

=
                      
                                    
                                   
             
                                   
                                     =
             =    
因为篇幅问题，上面省略了很多数据，可以看到和 ___ 代码中一致，结果为一个  结构，其中  为  组数据，每组数据包含  个特征值，而  为一个长度为  的数组，表示这  组数据的分类。 这样就完成了训练集和测试集的数据加载工作，之后创建一个  分类器：
       
_ = __ =

          
 = _=_
                                                                                        _=  
                                                                                        _=
                                                                                        _=_
这段代码，我目前的知识还无法理解全部参数的含义，先看看第一行 __的参数：

_ 填的是，这个我还不明白有什么作用
 填 ，对应每组数据有  个特征值。

的参数：

_：把之前创建的特征列传入，具体有什么含义还没深入理解。
_：每层神经元数量，跟  原理有关。
_：目标的类型的个数，目前是  个。
_：训练模型保存的路径，这个很重要。

然后要构造一个输入函数，用于将训练数据输入到  中用来训练，这个函数返回  个  数据，一个是大小为 的输入数据，表示  组数据，每组数据包含  个特征值，还有就是  个输出数据，这  组数据用于训练模型。因为返回的数据是  常量，直接打印会显示出他们的属性：    


 =  = _ = =
如果想看看他们的值，可以创建一个  执行一下：   
 = 


         
                                    
                                   
             
                                   
                                     =
                       
                
接下来就开始训练，使用  的  函数进行训练，次数为  次：
  
_=__ =
训练的结果会保存在之前创建  传入的 _ 中，本例中是_，这是一个目录，训练结束后，可以看到该目录保存了一些数据：
   _
_
├──    
├──   
│   └──   
├──   
├──   
├──   
├──    
├──   
├──   
├──    
└──   
如果再执行  次训练，会发现目录中数据量增加：
   _
_
├──    
├──   
│   ├──   
│   └──   
├──   
├──   
├──   
├──   
├──    
├──   
├──   
├──    
├──   
├──   
├──    
├──   
├──   
├──    
└──   
可见，训练的结果在执行完训练后，就已经保留下来了，后续对于数据的分类，可以直接使用当前的训练数据而不用重新训练：   
       
_ = __ =

          
 = _=_
                                                                                        _=  
                                                                                        _=
                                                                                        _=_
训练结束后，通过  组测试集来对训练效果进行测试，与训练时一样，同样构建一个数据输入函数 __，将数据和结果传入，使用  对数据进行测试：
    
 __
     = _
     = _

      

  
_ = _=__
                                                                         =

  {}_
注意到例子中把  返回的结果的字段打印出来，其实返回的结果是一个字典，可以打印出来看看是什么：
_=__ =

{    _   }
可以看到打印结果中有损失函数、训练次数、准确率和  信息， 信息我还不太能理解它的具体含义，但是可以看做是评价模型效果的一个指标，有兴趣的同学可以顺手  一下。 可以看到测试集的准确率是 ，总共  个测试数据，错了  个。 那么未来对于单个输入数据，我们怎么使用训练好的模型对其进行分类呢？继续看代码：
     
 _
                =

 = _=_

       {}
还是创建一个输入函数，把数据传入，使用  对数据进行分类，返回值是一个  生成器 ，所以用  包一下，结果为：
        
表示这  组数据分别被分类为  和 。 这就是我对于官方的  分类器示例的一些理解，希望能帮助读者学习，完整代码：

=
 ____  _
 ____  
 ____  _

   
   
 
 

_              日志级别设置成 ，避免干扰
_=                    打印内容不限制长度

  
_ = _
__ = _

_ = _
__ = _

 
                   
          _
                 = __
                 _   
                        

          _
                 = __
                 _   
                        

          
        _ = ___=_
                _=
                _=

        _ = ___=_
                _=
                _=

               
        _ = __ =

                  
         = _=_
                                                                                                _=  
                                                                                                _=
                                                                                                _=_
            
         __
                 = _
                 = _
                  

          
        _=__ =

            
         __
                 = _
                 = _

                  

          
        _=__ =
        _ = _=__ =

          {}_

             
         _
                        =

         = _=_

               {}

 ____ == ____
        


举一反三
学习了  分类器的用法之后，我们可以用它来做什么呢？先随便举个例子吧，给出一个坐标，输出它所在的象限，比如 的象限为 ， 的象限为 ，其中比较特殊的，令在坐标轴上的数据点的象限为 ，比如 和 的象限输出为 。 要完成这个测试，首先要生成训练集和测试集  文件，使用一个 _ 函数生成数据，首行为数据组数和特征的数量，在本例中，特征数量为 。我们使用随机数生成一个坐标，它们的值限制在  的范围内， 和  低于  的部分，将其置为 ，用来表示坐标轴上的点：
_ = _
_ = _

 _
           
                首行，写入数据集的组数和特征的数量
                  

                原点
                

                产生一个随机坐标
                   
                         =  
                         =  

                           
                                 = 
                           
                                 = 

                        获得坐标的象限
                         = 
                               
                                 = 
                               
                                 = 
                               
                                 = 
                               
                                 = 

                          
在  函数中，判断数据文件是否存在，不存在则生成数据，其中训练集包含  个数据，测试集包含  个数据：
 生成训练集和测试集
  _
        __

  _
        __
训练的内容和前面的例子几乎完全没有变化，这里我认为可以调整的参数有神经网络的层数以及每层的神经元数，这个目前我还没有经验对其进行调整：
 加载数据
_ = ___=_
        _= _=

_ = ___=_
        _= _=

  维数据
_ = __ =

 改造一个分类器
 = _=_
                                                                                        _=  
                                                                                        _=
                                                                                        _=_
 构造训练输入函数
 __
         = _
         = _
          

 训练模型
_=__ =

 构造测试输入函数
 __
         = _
         = _

          

 评估准确度
_=__ =
_ = _=__ =
  {}_
最后传入几个测试数据，由模型对数据进行分类，这样可以直观的看到训练的效果，其中包含了几个在训练集中没有的数据，训练集中的坐标点绝对值都限制在  以内，测试中传入了坐标值为  的点，看是否能够得到正确的结果：
 传入数据，对其进行分类
 _
          =

 = _=_

       {}
完整代码如下：

=
 ____  _
 ____  
 ____  _

   
   
 
 
 

_              日志级别设置成 ，避免干扰
_=                    打印内容不限制长度

_ = _
_ = _

 _
           
                首行，写入数据集的组数和特征的数量
                  

                原点
                

                产生一个随机坐标
                   
                         =  
                         =  

                           
                                 = 
                           
                                 = 

                        获得坐标的象限
                         = 
                               
                                 = 
                               
                                 = 
                               
                                 = 
                               
                                 = 

                          

 
         生成训练集和测试集
          _
                __

          _
                __

         加载数据
        _ = ___=_
                _= _=

        _ = ___=_
                _= _=

          维数据
        _ = __ =

         改造一个分类器
         = _=_
                                                                                                _=  
                                                                                                _=
                                                                                                _=_
         构造训练输入函数
         __
                 = _
                 = _
                  

         训练模型
        _=__ =

         构造测试输入函数
         __
                 = _
                 = _

                  

         评估准确度
        _=__ =
        _ = _=__ =
          {}_

         传入数据，对其进行分类
         _
                  =

         = _=_

               {}

 ____ == ____
        



执行上述代码，每执行一次，程序会训练  次，多次执行，可以逐步提高训练准确度，首次执行的结果如下：
{    _   }

  

                   
可以看到达到了 的准确度，手工传入的测试数据全部正确，可见效果确实很不错。 再多执行几次程序，提高训练的次数， 函数值会越来越小，分类准确率越来越高。本例中，在进行  次训练后，准确度达到了 ：
{    _   }
{    _   }
{    _   }
{    _   }
{    _   }
{    _   }
{    _   }
{    _   }
在我的机器上，执行  次训练耗时将近 ， 次差不多耗时  分钟，在训练完毕后，如果只是需要对数据进行分类，则耗时可以降低到  左右，其中加载训练数据耗时 ，对数据进行分类耗时 ，其他则是脚本本身的开销。从这里也可以看到， 分类器的训练过程是比较耗时的，具体执行的过程并不算特别耗时。 学会使用  分类器之后，如果有一些数据，有几个输入特征值，需要将其分类，就可以采用  分类器很方便地对其进行处理，前提是训练的数据集数量足够，这样才能达到比较好的训练效果。 比如我能想到的一个例子是文字识别，或者验证码识别，通过对图像的特征描述，达到识别文字或者验证码的目的。特征可以是简单的文字二维点阵描述，或者复杂点，描述为文字中封闭区域，转折的数量、方向等。其他还有很多问题可以通过  分类器解决，了解这个工具后，遇到问题时可以想想能否用这些机器学习的工具帮忙解决问题，在使用过程中，逐步理解各种神经网络的知识，如果直接看理论，难度很大也很枯燥，在实践中学习会更加容易，记忆也更加深刻，这也是我学习  的一个目的。
参考资料

 
：一文初探  高级  使用初学者篇


相关推荐
入门：求元一次方程入门：使用神经网络拟合元一次方程本文作者： 

是什么
专业制作动画采用公司的 软件。做出来的动画可以导出为文件，就是这个动画文件的前端播放器，支持渲染为\\三种格式。它不仅可以播放动画，可以完全控制动画的播放、暂停、速率、播放对应帧等等。更可以做到更改帧对象的位置。可以说是不可多得的好工具。

使用方法
官网
首先机子要装  ，如果没装，就需要找设计师要动画的文件。
这里假设已经获取到动画导出的文件了。我扒了的例子到我的站点，大家可以用这个文件来测试：
动画基本播放

以下所有代码默认都已经导入了

   = {
     
        
       是否循环播放
     
     

}
  = 
控制动画窗口的大小
会将对应的或者节点插入容器节点中。例如
  =
     = =

的大小将被动态调整为容器宽度或高度按照画布比例的最小值。
虽然提供了在已有上渲染的能力，实测试效果并不理想，且没有文档说明如何进行调整。所以建议控制的大小来控制动画的大小。

控制帧率
   停止
   开始播放
  暂停
 播放速度
   播放秒钟后的画面
   播放第帧
   倒叙播放
   播放第帧到第帧
   依次播放帧，帧，帧，之后如果的话，会循环播放最后一个片段，即循环播放帧
   结束当前片段的播放，立即播放帧。
所以，运用以上的接口，我们可以很好的控制动画对象的播放。
举个例子
一个动画完整的包含一个控件的出现和消失。 

我们可以通过以上的将动画拆分成两个片段： 开始片段和消失片段。步骤是：

通过获取到动画的总帧数。
和设计沟通一下，得知前帧是出现，后帧是消失。
将前帧和后帧拆分成两个不同的片段。在点击事件中分别播放。


事件

 一次播放完成
循环播放一次完成，每次都会触发
播放过程中不断触发，慎用，在无性能瓶颈的情况下，最高触发次数为，所以不要给这个事件加句柄。
不同片段播放开始时候触发，如果是相同片段的循环，第一次后就不会触发此事件了。

坑

目前的文档支持得不是太好。上的能解决的问题也很有限。几乎看不到，需要自己慢慢试。


： 支持得不是太好。


 用于在已有的上渲染动画，效果不是很好。不推荐使用

性能
选取大小约为的动画文件，在不同平台不同价位的机器上进行测试。采用 内核
同时播放个动画





 





表现良好
明显掉帧



轻微掉帧
无法正常播放



明显掉帧
无法正常播放



所以，这个动画框架在低端上的可用性还是很低的。如果对进行判断，只在上采用此动画解决方案，其实也不失很好的办法。



实在是有点卡

原文链接：前言
总结目前语音识别的发展现状，、和算是语音识别中几个比较主流的方向。年，微软邓力和俞栋老师将前馈神经网络    引入到声学模型建模中，将的输出层概率用于替换之前中使用计算的输出概率，引领了混合系统的风潮。长短时记忆网络，  可以说是目前语音识别应用最广泛的一种结构，这种网络能够对语音的长时相关性进行建模，从而提高识别正确率。双向网络可以获得更好的性能，但同时也存在训练复杂度高、解码时延高的问题，尤其在工业界的实时识别系统中很难应用。
回顾近一年语音识别的发展， 绝对称得上是比较火的关键词，很多公司都在这方面投入了大量研究。其实  被用在语音识别中由来已久，在 、 年的时候   就将  引入了语音识别中。那时候的卷积层和  层是交替出现的，并且卷积核的规模是比较大的， 的层数也并不多， 主要是用来对特征进行加工和处理，使其能更好的被用于  的分类。随着在图像领域的发光发热，，和的应用，为在语音识别提供了更多思路，比如多层卷积之后再接  层，减小卷积核的尺寸可以使得我们能够训练更深的、效果更好的  模型。
 语音识别为什么要用
通常情况下，语音识别都是基于时频分析后的语音谱完成的，而其中语音时频谱是具有结构特点的。要想提高语音识别率，就是需要克服语音信号所面临各种各样的多样性，包括说话人的多样性说话人自身、以及说话人间，环境的多样性等。一个卷积神经网络提供在时间和空间上的平移不变性卷积，将卷积神经网络的思想应用到语音识别的声学建模中，则可以利用卷积的不变性来克服语音信号本身的多样性。从这个角度来看，则可以认为是将整个语音信号分析得到的时频谱当作一张图像一样来处理，采用图像中广泛应用的深层卷积网络对其进行识别。
从实用性上考虑，也比较容易实现大规模并行化运算。虽然在卷积运算中涉及到很多小矩阵操作，运算很慢。不过对的加速运算相对比较成熟，如等人提出一种技术可以把所有这些小矩阵转换成一个大矩阵的乘积。一些通用框架如，等也提供的并行化加速，为在语音识别中的尝试提供了可能。
下面将由“浅”入“深”的介绍一下在语音识别中的应用。
 
提到在语音识别中的应用，就不得不提       ，在中有两层的应用，算是浅层应用的代表。 和  在语音识别任务中可以获得比更好的性能提升，对建模能力来说，擅长减小频域变化，可以提供长时记忆，所以在时域上有着广泛应用，而适合将特征映射到独立空间。而在中，作者将，和串起来融合到一个网络中，获得比单独网络更好的性能。
网络的通用结构是输入层是时域相关的特征，连接几层来减小频域变化，的输出灌入几层来减小时域变化，最后一层的输出输入到全连接层，目的是将特征空间映射到更容易分类的输出层。之前也有将 和融合在一起的尝试，不过一般是三个网络分别训练，最后再通过融合层融合在一起，而是将三个网络同时训练。实验证明，如果输入更好的特征其性能将得到提高，受到启发，作者用来减小频域上的变化使输入自适应性更强的特征，加入增加隐层和输出层之间的深度获得更强的预测能力。
 网络结构

   
网络结构图如图，假设中心帧为，考虑到内容相关性，向左扩展帧，向右扩展帧，则输入特征序列为    ，特征向量使用的是维的梅尔特征。
部分为两层，每层个 ，第一层采用 时域频域滤波器，第二层为的滤波器。池化层采用策略，第一层 是，第二层不接池化层。
由于最后一层输出维度很大，大小为，所以在后之前接一个线性层来降维，而实验也证明降维减少参数并不会对准确率有太大影响，线性层输出为维。
后接层，每个层采用个，维映射层来降维。输出状态标签延迟帧，此时输出信息可以更好的预测当前帧。由于的输入特征向左扩展了帧向右扩展了帧，为了确保不会看到未来多于帧的内容，作者将设为。最后，在频域和时域建模之后，将的输出连接几层全连接层。
借鉴了图像领域的应用，作者也尝试了长短时特征，将的输入特征作为短时特征直接输入给作为部分输入，的输出特征直接作为的部分输入特征。
 实验结果
针对结构，我们用自己的中文数据做了一系列实验。实验数据为的中文有噪声语音，所有模型输入特征都为维特征，帧率。模型训练采用交叉熵准则，网络输出为多个。由于的输入需要设置和两个参数，设为，经过实验为最优解，后面的实验结果中默认==。
其中为层个，为 ，和具体的网络参数略有调整，具体如下图，另外还增加一组实验，两层和三层组合，实验验证增加一层对结果有提高，但继续增加的层数对结果没有帮助。

  实验结构













层



层












  测试集结果













层



层












  测试集结果
  
在过去的一年中，语音识别取得了很大的突破。、微软、百度等多家机构相继推出了自己的 模型，提升了语音识别的准确率。网络的提出使我们可以把神经网络训练的更深。尝试 的过程中，大致也分为两种策略：一种是 框架中基于  结构的声学模型，可以是、 连接的  网络结构、或是结构。另一种是近两年非常火的端到端结构，比如在  框架中使用或实现端对端建模，或是最近提出的  、 模型等粗粒度建模单元技术。
对于输入端，大体也分为两种：输入传统信号处理过的特征，采用不同的滤波器处理，然后进行左右或跳帧扩展。

     
第二种是直接输入原始频谱，将频谱图当做图像处理。
    
 百度 
百度将   应用于语音识别研究，使用了  ，以及包含 连接的深层 等结构，并将  和  的端对端语音识别技术相结合，使得识别错误率相对下降了  原错误率的以上。
此前，百度语音每年的模型算法都在不断更新，从  ，到区分度模型，到  模型，再到如今的   。基于 的声学模型也于  年底已经在所有语音相关产品中得到了上线。比较重点的进展如下： 年，基于美尔子带的  模型;年，  区分度模型; 年初，基于 的语音识别 ; 年底，基于 的端对端语音识别; 年，  模型，目前百度正在基于  开发 ，据说训练采用大数据，调参时有上万小时，做产品时甚至有  万小时。

 百度语音识别发展
百度发现，深层  结构，不仅能够显著提升  语音识别系统的性能，也能提升  语音识别系统的性能。仅用深层  实现端对端建模，其性能相对较差，因此将如  或 的 循环隐层与 结合是一个相对较好的选择。可以通过采用  结构中的  这种小  ，也可以采用  连接等方式来提升其性能，而卷积神经网络的层数、滤波器个数等都会显著影响整个模型的建模能力，在不同规模的语音训练数据库上，百度需要采用不同规模的  模型配置才能使得最终达到最优的性能。
因此，百度认为：在模型结构中， 帮助模型具有很好的在时频域上的平移不变性，从而使得模型更加鲁棒抗噪性;在此基础上， 则与  一起专注于序列的分类，通过  的循环连接结构来整合长时的信息。在  研究中，其卷积结构的时间轴上的感受野，以及滤波器的个数，针对不同规模的数据库训练的语音识别模型的性能起到了非常重要的作用。为了在数万小时的语音数据库上训练一个最优的模型，则需要大量的模型超参的调优工作，依托多机多  的高性能计算平台，才得以完成工作。基于  的端对端语音识别引擎，也在一定程度上增加了模型的计算复杂度，通过百度自研的硬件，也使得这样的模型能够为广大语音识别用户服务。
 
 年，  公布了英语会话语音识别领域的一个重大里程碑：系统在非常流行的评测基准  数据库中取得了  的词错率。到了年  月份，  团队再次宣布在同样的任务中他们的系统创造了 的词错率新纪录，其解码部分采用的是，语言模型采用的是启发性的神经网络语言模型。声学模型主要包含三个不同的模型，分别是带有激活的循环神经网络、卷积核的深度卷积神经网络、双向长短期记忆网络，下面我们来具体看看它们的内部结构。

     框架
非常深的卷积神经网络的灵感来自参赛的网络，中心思想是使用较小的卷积核来取代较大的卷积核，通过在池化层之前叠加多层卷积网络，采取激活函数，可以获得相同的感知区域，同时具备参数数目较少和更多非线性的优点。
如上图所示，左为最经典的卷积神经网络，只使用了两个卷积层，并且之间包含一个池化层，卷积层的卷积核也较大，和，而卷积的特征面也较多，张卷积特征面。
左、左、左均为深度卷积神经网络的结构，可以注意到与经典的卷积神经网络所不同的是，卷积的特征面由个增加到个再增加到个，而且池化层是放在卷积的特征面数增加之前的；卷积核均使用的是较小的卷积核，池化层的池化大小由增加到。
最右边的参数数目与最左边的经典卷积神经网络参数数目相同，但是收敛速度却足足快了倍，尽管计算复杂度提高了一些。
 微软
年月在产业标准  语音识别任务上，微软研究者取得了产业中最低的  的词错率。基于神经网络的声学和语言模型的发展，数个声学模型的结合，把  用到语音识别。
而在年的月，微软人工智能与研究部门的团队报告出他们的语音识别系统实现了和专业速录员相当甚至更低的词错率，达到了。 的词错率已经等同于人速记同样一段对话的水平，而且这是目前行 语音识别任务中的最低记录。这个里程碑意味着，一台计算机在识别对话中的词上第一次能和人类做得一样好。系统性地使用了卷积和  神经网络，并结合了一个全新的空间平滑方法  和   声学训练。
虽然在准确率的突破上都给出了数字基准，微软的研究更加学术，是在标准数据库——口语数据库  上面完成的，这个数据库只有  小时。
  
根据   年度互联网报告，以机器学习为背景的语音识别系统，年月已经获得英文领域的字准确率，此结果逼近人类语音识别的准确率。如果定量的分析的话，从年开始，系统已经提升了的性能。

 
   语音识别性能发展
从近几年在各类会议上的文章可以看出，尝试 的路径主要采用多种方法和模型融合，如 ，  ，  方法的融合。比如 会议中所展示的结构

                             
 科大讯飞
年在提出前馈型序列记忆网络     的新框架后，科大讯飞又提出了一种名为深度全序列卷积神经网络    ，的语音识别框架，使用大量的卷积层直接对整句语音信号进行建模，更好地表达了语音的长时相关性。
的结构如下图所示，它输入的不光是频谱信号，更进一步的直接将一句语音转化成一张图像作为输入，即先对每帧语音进行傅里叶变换，再将时间和频率作为图像的两个维度，然后通过非常多的卷积层和池化层的组合，对整句语音进行建模，输出单元直接与最终的识别结果比如音节或者汉字相对应。
  框架
首先，从输入端来看，传统语音特征在傅里叶变换之后使用各种人工设计的滤波器组来提取特征，造成了频域上的信息损失，在高频区域的信息损失尤为明显，而且传统语音特征为了计算量的考虑必须采用非常大的帧移，无疑造成了时域上的信息损失，在说话人语速较快的时候表现得更为突出。因此直接将语谱图作为输入，相比其他以传统语音特征作为输入的语音识别框架相比具有天然的优势。其次，从模型结构来看，与传统语音识别中的做法不同，它借鉴了图像识别中效果最好的网络配置，每个卷积层使用的小卷积核，并在多个卷积层之后再加上池化层，这样大大增强了的表达能力，与此同时，通过累积非常多的这种卷积池化层对，可以看到非常长的历史和未来信息，这就保证了可以出色地表达语音的长时相关性，相比网络结构在鲁棒性上更加出色。最后，从输出端来看，还可以和近期很热的方案完美结合以实现整个模型的端到端训练，且其包含的池化层等特殊结构可以使得以上端到端训练变得更加稳定。
 总结
由于本身卷积在频域上的平移不变性，同时、残差网络等深度网络的提出，给带了新的新的发展，使成为近两年语音识别最火的方向之一。用法也从最初的层浅层网络发展到层以上的深层网络，从框架到端到端框架，各个公司也在 的应用上取得了令人瞩目的成绩。
总结一下，发展的趋势大体为：
 更加深和复杂的网络，一般作为网络的前几层，可以理解为用提取特征，后面接或。同时结合多种机制，如 、 的技术等。
   的识别系统，采用端到端技术 ，  等。
 粗粒度的建模单元，趋势为从到到，建模单元越来越大。
但也有局限性，研究表明，卷积神经网络在训练集或者数据差异性较小的任务上帮助最大，对于其他大多数任务，相对词错误率的下降一般只在到的范围内。不管怎么说，作为语音识别重要的分支之一，都有着极大的研究价值。
参考文献：
                 
                       
                          
                     
                       一、引言
在实际工作中，难免会遇到从网页爬取数据信息的需求，如：从微软官网上爬取最新发布的系统版本。很明显这是个网页爬虫的工作，所谓网页爬虫，就是需要模拟浏览器，向网络服务器发送请求以便将网络资源从网络流中读取出来，保存到本地，并对这些信息做些简单提取，将我们要的信息分离提取出来。
在做网页爬虫工作时会发现并不是所有网站都是一样，比如有些网址就是一个静态页面、有些需要登录后才能获取到关键信息等等。此外，简单而又强大，又有不少第三方库可以让我们轻松拿到浏览器中所看到的内容。因而，本文将根据网站特性进行分类介绍几种使用完成网页爬虫的方法。
二、静态页面
在做爬虫工作时，什么类型的网站最容易爬取数据信息呢？不需要登录等处理，直接用方法请求即可从服务器获取到返回数据，如我们访问一些博客文章，一个请求就可以拿到博客文章里的内容。下面将举例介绍如何爬虫这种类型页面内容该如何爬取。
示例
、需求说明：假设我们需要及时感知到电脑管家官网上相关产品下载链接的变更，这就要求我们写个自动化程序从官网上爬取到电脑管家的下载链接。
、分析过程：在浏览器中打开，按下 查看网络请求，内容如下图。这里只有一个请求，没有登录，也不涉及加密过程。此外，点击，可以很容易的从源码中找到下载链接。图
、解决方案： 是的第三方库，可以发送网络请求数据并获取服务器返回的源码。使用库获取到文件，然后利用正则等字符串解析手段或者库第三方库完成信息提取。下面代码展示的是利用库和库完成信息提取。图  源码截图
知识点
、有些网络服务器反感爬虫，会对请求头做个简单判别，直接拒绝那些明显是由自动化程序发起的请求。就例如图中的代码，使用的默认请求头值为，而浏览器访问时值为：         。为了避免自动化程序被拒绝，在请求时可以修改请求头，让自动化程序更像一个浏览器。
、在网页爬取时，可能会遇到公司网络不允许访问外网的情况，这时就需要设置代理  ={“”“”}
、库是解析器，它可以很好的处理不规范标记并生成剖析树，通常用来分析爬虫抓取的文档，可以大大节省编程时间。
三、表单
前面介绍的是通过协议的方法去请求信息，对应网站不涉及表单。表单是含有标签，是要交互的数据区域，你可能需要输入文字、做下拉选择等，完成与服务器的交互。下面将给个简单的示例让大家理解表单情况。

示例
、需求说明：访问网址，并输出服务器返回内容。
、分析过程：在浏览器中打开，展示在面前的是个登录界面 按下，可看到如下图的信息。很明显这是一个表单。点击登录后查看会发现看到一个请求以及请求参数。当登录完成后，即可访问，查看网址中详细内容。
、解决方案：仍然使用强大的库完成表单操作，下面将仅展示登录那里，登录过后的页面内容解析和第二部分一致，这里不再详细赘述。
知识点
、需要注意的追踪。一旦网站验证了你的登录权证，它将会将登陆权证保存在浏览器的中，若是我们一直自己处理的追踪，在面对复杂网址时将会比较麻烦，降低开发效率。我们可以使用对象解决这个问题，就如上述截图代码中。会持续跟踪会话信息，包括，。可以调用_查看当前 值。
、在表单中存在“隐含”字段，该字段是对浏览器可见，但是对用户不可见。一般而言，“隐含”字段是在每次请求时生成，每次打开同个网址，同个“隐含”值不一样。这个处理有一定的反爬虫效果。至于“隐含”字段是否作为参数，可以手动在浏览器下完成表单请求，观察请求参数是否包含某个“隐含”参数。如下图：网址包含“隐含”字段，并在时带上。第二部分介绍的、代理同样适用于这里。
四、基本接入认证
基本认证是一种用来允许浏览器后者其他客户端程序在请求时，提供用户名和口令形式的身份凭证的一种登录验证方式。把“用户名冒号密码”用算法加密后的字符串放到中的中发送给服务端。在发明之前，基本认证是处理网站登录最常用的方法，目前一些安全性比较高网址还在使用这种方式。
示例
、需求说明：访问某网站涉及内部，不对外公布。
、分析过程：在浏览器中输入该网址，看到如下页面。这时候需要输入用户名和密码才能得到所需要的数据。否则会返回错误代码，要求用户重新提供用户名和密码。此外用抓取中间数据时，中有如下信息：，很明显这是一个基本认证。、解决方案：这个实际是个请求，和普通的请求区别是：在每次请求数据时，需要用加密用户名和密码，并附加到请求头中。库提供了一个模块专门用于处理认证，这样就不用程序自己做加密处理。下面给出具体代码：
知识点
目前有多种登录验证方法，其中最广泛应用的是基本验证和摘要验证，模块也提供摘要验证处理方法，具体使用方法我也没有研究过，请各位查询相关资料。
五、动态页面
前面介绍了静态页面和含有表单网站的爬虫方式，相对比较简单。而实际在做网页爬虫工作时页面情况更加多样复杂。如：、网页中包含代码，需要经过渲染处理才能获取原始数据；
、网站具有一定反爬虫能力，有些是需要客户端脚本执行后才会产生，而模块又不能执行代码，如果我们按照第三部分操作来表单，会发现部分少了部分，导致请求被拒绝。在当前知名网站反爬虫工作做的比较好，很难找到简单表单就可以。那有什么好的方式解决这种类型网站的爬虫呢？
“   第三方浏览器“。
示例
、需求说明：登录微软官网，自动下载微软最近发布文件。
、分析过程：
 当我们使用 库去获取服务器源码时，发现获取的源码和浏览器上渲染出的场景不一样，拿到是源码。如下图：有个第三方库，该库可以执行代码，但执行效率低，此外微软官网还涉及加密的，若是采用     三种库组合方式处理，那代码会显得臃肿杂乱。
那是否有其他更为简洁易懂的方式呢？
有， 。
“ 第三方浏览器”，可以让浏览器自动加载页面，由浏览器执行从而获取到需要的数据，这样我们的代码就无需实现浏览器客户端的功能。可以说，“  第三方浏览器”组成了一个强大的网络爬虫，可以处理、等页面爬取情况。第三方浏览器分有界面和无界面有界面浏览器就是可以直接看到浏览器被打开以及跳转的过程。无界面浏览器会将网站加载到内存并执行页面上的不会有图形界面。可以自己喜好或者需求选择第三方浏览器。
、解决方案：采用“ ”方式完成需求。
下载安装的库；
下载到本地；
利用 完成对页面的操作。下面给出一个示例，完成微软官网的登录。示例代码在初始化时设置了网络代理、指定了浏览器下载文件保存路径、让提示下载进度等信息。
知识点
在实例化时，可以通过参数对浏览器做些设置，如设置网络代理、浏览器下载文件保存路径等。若是不传参数，则默认继承本地浏览器设置。若是对浏览器启动时属性进行设置，则就利用到了类。具体信息可参考官网。
“    第三方浏览器”可以处理多种爬虫场景，包括静态页面，表单，以及等。应用场景很强大，使用操作浏览器进行模拟点击的方式就可以让我们省心很多，不需要担心有什么“隐藏字段”、追踪等。但对于包含验证码网页的操作，这种方式也不好处理，主要困难在于图像识别。
六、总结
本文主要针对各网站特点给出不同的爬虫方式，可以应对大量场景的数据爬取。在实际工作中使用频率最多还是“静态页面”、“动态页面”这两种。当然，若是页面包含验证码，那就需要结合图像识别工具做些事情了，这种情况相对也比较难处理，图像识别准确率受到图片内容影响。这里是个人的一些小总结，不知道大家是否有其他更好的方法呢？
大家若是有其他比较好的爬虫案例，欢迎在评论区留言，大家一起学习交流！
想知道更多测试相关干货 请关注我们的微信公众号：腾讯移动品质中心。上月听了本部门大牛的调优分享，当时对一个点不是很理解，回去好好理了一下，整理成文。
       谓词下推
基本概念：谓词下推 属于逻辑优化。优化器可以将谓词过滤下推到数据源，从而使物理执行跳过无关数据。在使用或者的情况下，更可能存在文件被整块跳过的情况，同时系统还通过字典编码把字符串对比转换为开销更小的整数对比。
说白了，就是把查询相关的条件下推到数据源进行提前的过滤操作，之所以这里说是查询相关的条件，而不直接说是 后的条件，是因为语句中除了后的有条件外，时也有条件。本文讨论的主要就是时的条件的处理。
       中条件和后条件

那么这两类不同的条件，在外连接查询中是否都会下推呢？不是的，是否下推是遵循一定规则的，对于左连接查询，可以归纳为下表：



　
左表
右表




中条件
不下推
下推


后条件
下推
不下推



       具体情况具体分析
帽子很高，其实就是对中表格中的规则一个一个来分析。
    左表后条件下推

查询语句如下：



表结构和数据如下：

左表：


















右表：


















来分析一下下推到左表左表进行数据过滤的结果：
经过过滤后，左表变为：














此时再和右表进行左连接，流程如下：
左表为的行，在右表中能上，则连接结果如下：
















可见，条件下推过滤了左表整整的数据，相当牛叉，虽然只有两条。究其原因，是因为在中，把以上的查询解析成了如下的子查询：

    左表中条件不下推
查询语句如下：

左表：


















右表：


















来看看不下推的情况下计算出的正确结果，过程如下：
第一步：左表为的行在右表中能找到相等的，但是左表的为，是不满足第二个条件的，所以左表这一条相当于没有和右表上，所以左表的值保留，而右表的为。
第二步：左表为 的行在右表中能找到，而且左表为的行的大于，两个条件都满足，所以算是和右表上了，所以左表和右表的都保留。





















    右表中条件下推
查询语句如下：

现在把这个右表中条件下推，来过滤右表，过滤后如下：














然后左表再和右表进行左连接，流程如下：
第一步：左表为的行在右表中没有，此时左表值保留，右表为
第二步：左表位的行在右表中有，并且大于，两个条件都满足，则左表和右表的值都保留。





















那么如果不下推，来看看结果，流程如下：
第一步：左表为的行在右表中有，但是不满足第二个条件，所以这行算是没上，所以左表数据保留，右表为
第二步：左表为的行在右表中有，也满足第二个条件，所以左右表的数据都保留。





















可见，右表中条件下推不下推，结果一样，所以，干吗不下推？可以过滤掉一半的数据呢。中的等价处理语句是：

    右表后条件不下推
这个应该是最违反常规理解的查询了，查询语句如下：

首先来看，后条件不下推的情况，流程如下：
第一步：左表为的行在右表中可以找到，但是此时仅仅满足条件，在使用条件判断这条连接后数据时，发现右表的不满足的条件，所以这条结果不保留注意，这里是不保留，全都不保留，左表右表都不保留，要跟上边的没上，右表的值为的情况区别开，这也是关键所在
第二步：左表为的行和右表为的行上了，同时也满足的条件。
















很明显，这是一条符合语义的正确的查询结果。
好了，接下来看看右表后条件下推的情况：
第一步：使用过滤右表，过滤后右表只剩一行为的行
第二步：左表为的行在右表中没有，此时左表值保留，右表值为
第三步：左表为的行在右表中有，此时左表值保留，右表值也保留。
结果如下：





















这其实是一个错误的结果。
好了分析结束，其实大家也看出来了，我是打着的幌子骗点击的，任何数据库其实都会按照这个规则处理的，不是所特有的。导语： 最近有接触到树，花了点时间，顺便总结梳理下方便后续翻阅；时间仓促，且文中多是个人的理解，仅供参考。

定义
参考百度百科及百科定义： 树是一个叉排序树，每个节点通常有多个孩子，一棵树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。
 树主要价值在于存储用于在面向块的存储环境中高效检索的数据，通常用于数据库和操作系统的文件系统中。 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。 树元素自底向上插入。
结构类似如下：

树的特点剖析

只有叶子节点才记录数据，非叶子节点只包含索引；换句话说，所有叶子节点中包含了全部关键字的信息，及指向这些关键字记录的指针，所有的非终端节点内部节点并不存储数据信息，而是保存其叶子节点的最小值作为索引。 此点设计初衷，主要作用体现在降低磁盘方面。

能够提供稳定高效的范围扫描功能；这也是为什么数据库和操作系统中的文件系统通常会采用树作为元数据索引的原因，这个特点主要得益于所有叶子节点相互连接，并且叶子节点本身依关键字的大小自小而大顺序链接。这种设计在扫描时可以避免的耗时的遍历树操作。所以，树通常可以提供两种查找方式，一，从根节点起随机查找起点是指向根节点的； 二，顺序查找起点是指向最小关键字的。

所有叶子节点均出现在同一层；因为在实现上树元素插入采用的是自底向上分裂算法删除元素类似同理，具体实现可参看下节图示。另外说明的一点，中的并不是代表二叉而是代表平衡。

对于阶树，的值越大，固定高度的树存放的值就越多。实验数据表明当处于之间，性能最好待验证；在百科里的树的介绍里提到的值也通常是甚至更多：                                     。

在树的索引中，用户可以得到页表或者叫块级别的位置信息；但如果要进行一次比如到的范围查询，则可能需要读取两个在磁盘上不连续甚至可能相隔很远的叶子节点页表；这种情况，通常在树的设计中会含有一组被称为 优化表命令，的作用是把表重写，从而使表的范围查询变成磁盘的多段连续读取，提高范围查询的执行效率。


树插入删除操作图示
插入基本算法参考定义：
执行搜索以确定新记录应该进入哪个节点。

如果节点不满，添加记录。
否则，拆分节点。

分配新的叶子节点，并将一半的原节点元素移动到新的叶子节点。
将新叶子节点的最小键和地址插入父节点。
如果父节点满了，分拆。    
将中间键添加到父节点。
重复一遍，直到找到不需要拆分的父节点。


如果根分裂，创建一个新的根，分别取自叶子的最小键。

树在根部生长，而不是在叶子上生长。


举个栗子：往下图的阶树中依次插入关键字：、、、、

首先查找应插入的叶节点最左下角的那一个插入发现没有破坏树的性质完毕。插完如下图所示
继续查找应插入的叶节点还是最左下角的那一个插入，发现该叶子节点已经破坏了树的性质，则分解成   两个并把往父节点移；
这时可以发现父节点也破坏了树的性质则把之再分解成   两个并把和由于此时是根节点向上产生一个新根节点；
如下图：
接着查找应插入的叶节点第三个叶子节点插入发现没有破坏树的性质完毕。插完如下图所示
接着查找应插入的叶节点第三个叶子节点插入，发现该叶子节点已经破坏了树的性质，则分解成   两个并把往父节点移；如下图所示
最后查找应插入的叶节点第四个叶子节点插入发现没有破坏树的性质完毕。插完如下图所示
至此完毕！
删除算法类似，但更为复杂些，插入算法节点之间只与父节点产生关系，而删除算法则需要考虑兄弟节点和父子节点的关系；在此不赘述了。
总而言之树多用于文件系统索引比如   等和数据库索引比如存储引擎等方面，其优势主要体现在针对树：

降低磁盘方面做的更好
 树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存 中的需要查找的关键字也就越多。相对来说读写次数也就降低了。
 举个例子，假设磁盘中的一个盘块容纳，而一个关键字，一个关键字具体信息指针。一棵阶一个结点最多个关键字的内部结点需要个盘块。而树内部结点只需要个盘块。当需要把内部结点读入内存中的时候， 树就比树多一次盘块查找时间在磁盘中就是盘片旋转寻道的时间。

查询效率更加稳定
 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。


但是如果对写数据敏感度比较高，则更倾向于使用树，树能够保证更稳定的数据插入速率；后续有时间整理介绍。前言
  再过一个多月就要发布了，这将是  框架的下一个  长期支持版，对于喜欢追求最新版本的  开发者来说，现在肯定已经至少都升级到   了，接下来升级到   自然是理所当然的事情，但是对于追求稳定和长期技术支持的人来说，即使依然在使用   面对这个新的长期支持版，吸引力甚至比其它更新版本的用户更大，因为自  以后， 在   版本中，已经提供了一系列非常有吸引力的新特性。
一步到位升级到  就可以体验这些极大提升开发效率的新特性，也能轻易实现很多原本比较麻烦的功能。那么，如何在   正式发布之前先一步体验它，以及为自己的功能、扩展提前做出兼容准备呢？
鉴于 在正式发布之前还会继续进行修复和引入新特性，加上很多第三方的包目前还没有提供兼容的版本，因此不建议直接将   应用于生产环境，因此本文只考虑新建项目的情况。
创建一个新的项目，有多种方法：

用  可以快速创建新的项目，是官方推荐的方式之一。具体方法：

首先 通过  安装 

   

然后，执行命令创建  项目。

  

如果要创建最新的  版本当前的版本，加上  参数，即可创建最新的  版本的  项目。

   

通过  来创建  项目是大家都很熟悉的一种方式了，只要执行：
   
即可创建基于当前最新发布版本的  项目。如果要创建特定版本，则在后面再加上版本号即可，最新  版本当前的版本号是  所以可以执行下面的命令来创建：
    

还有一种不太常用的创建  项目的方法，就是直接通过  拉取  上  项目的代码，然后执行   来安装，采用这种方法，可以切换到官网的任意一个分支版本，最新的  版本的分支号是  所以命令如下：
 克隆上的代码到本地
   
 
 切换到开发分支
  
 安装依赖包
 
 创建本地环境配置文件
  _ ||    复制  为 
 生成
  作者 | 刘晓轶编辑 | 顾乡
本地图形化工具登录腾讯云
用户购买了腾讯云后，有在本地通过图形化工具登录管理的需求，可以通过一台有公网的配置代理实现。方法如下：
一、下载安装
二、安装完成，启动：


可以导入之前导出的连接快速导入

新建连接：


主要配置  和   选项，具体方式如图：

此处的方式，必须严格遵守腾讯云 方式来连接！

勾选 ，填写公网，端口号，用户名，密码，也可通过密钥方式登录。
 
测试连接成功。

验证！

相关推荐
设计思路学习与总结操作  云爬虫初探单机主从高可用性优化 工具简介：
 是一套类似于  的动态检测的工具集，由于使用方便，不需修改目标程序源码，输出清晰图文并茂等优势，常被用作后台特别是后台服务内存泄漏检测、性能打点、竞态检测等。
 工具安装：
  去官方网站  下载最新安装包，如    解压；
 常规源码编译安装：；    
  安装成功   输出版本号；
 工具使用：
 内存泄漏检测：
  正常编译目标程序 如    _ ，官方推荐加上          选项；
   = =                          = _   
   = 表示使用工具集中的内存检测，其他选项参考       
 特别的  =  开启这个选项将使  追踪到子进程，但据说不是很好用，所以我一般将服务设置为前台运行，如果你的后台服务 进程无法设置前台运行，可以尝试这个选项；
 结果输出，直接  由命令中的  指定查看：

结果中比较重要的是： 

  确定有内存泄漏，表示在程序退出时，该内存无法回收，也没指针指向该内存首地址；
  间接内存泄漏，比如结构体中定义的指针指向的内存无法回收；
 ： 可能出现内存泄漏，比如程序退出时，没有指针指向一块内存的首地址了，但由其他某个指针能推算出首地址；
  程序没主动释放内存，在退出时候该内存仍能访问到，比如全局  的对象没 ，由于操作系统会回收，所以此类问题可忽略
最严重的是   和  ，检测结果文件中已给出了具体函数和源文件。
 性能检测调优：
 正常编译目标程序同上；
  =  _ __
  = 表示使用调用检测工具，同样，建议在前台运行；
  由于  的原理是时间点采样，所以被测程序最好在合适的压力下运行合适长的时间；
 查看结果，运行完后，将输出  文件，该文件可被  等工具解析转化为 ，再由  转化为图片输出，也可以直接用 _ 直接解析打印，但最方便的是使用图形工具解析，如  上的 
  安装略，以下是  打开上述   文件的效果：

左边列出了调用、调用栈  排序等，右边列出了所有调用者、被调用者以及调用图等。
 分析程序的性能损耗在哪，可以选择左侧       ，找到感兴趣的  文件：

  表示自身执行的耗时，表示包含调用函数的总耗时，选择感兴趣的函数，在右边可查看该函数的调用关系图：

 根据耗时分布找到程序的性能瓶颈，针对性的优化，关于  的详细说明，可查阅官网  ；
 最后：
在  的调用图中发现这个：

它是什么呢，有什么用呢？
在下篇文章《_ 在你不小心    时的作用》在聊 个人介绍：年大学实习期加入初创期的网易，成为第号员工，年间从程序员开始，历任项目经理、产品总监。年后创业年，开发过视频直播社区，及多款页游产品。年后就职于腾讯游戏研发部公共技术中心架构规划组，专注于通用游戏技术底层的研发。

要说“远程对象”，必先说“远程调用”，也就是  。比较著名的  框架有，最近很火的 ，也就是  开源的  。另外还有  开源的  等等……鹅厂内部也有很多  框架，琳琅满目不暇接。 在  里面也支持     ： 远程方法请求功能，也可以视为一种  ，但实际上这个更像我们现在要讨论的“远程对象调用”。
在诸多的  中，我们都基本认为是通过网络，对运行在另外一个进程或者电脑里的某个函数，发起一次调用请求。既然是一次函数调用，那么我们自然要传入参数，然后期望获得返回值。在这个过程中，我们往往只需要输入：函数名参数，就能找到一个远程的进程，去执行对应的函数，然后传入目标参数。在这个过程里，执行这个函数的进程，会被认为是无状态的，所有的输出，都仅与输入的参数有关，除非有一部分状态是记录在数据库持久化设备上的。因此，计算的过程算法，和计算的数据，实际上分离的，这些计算所需的数据，要么来源于参数，要么是数据库设备。而被请求的函数，以及装载这个函数的容器——进程，是不保证任何的状态维护能力的。
而“远程对象调用”，正是在“状态”这个环节上，和不同——它是由框架去保证某种状态的。当我们发起一个远程对象调用的时候，是需要首先“找到”一个远程对象，然后再发起“方法”成员函数调用。这和就产生了两个明显的区别：

我们需要用某种手段定位到对象，而不是仅仅用一个函数名。对象是一个更复杂的远程概念，因为有可能同属于一个类，而存在多个状态一致或不一致的对象，在远程的机器上存在。我们就不能仅仅通过一个固定的路由标志比如类名去找一个这样的对象。远程对象的路由方式成为不同“远程对象调用”框架之间的一个显著区别。

我们并不需要把所有的数据，在每次请求时都通过参数发给远程对象，因为对于同一个远程对象来说，它是可以包含大量过程状态的。我们只要找到正确的远程对象，就能获得之前操作所造成的结果状态。有远程对象往往是生存在进程的内存中，所以对于访问自己的状态数据，会非常快速，这对于有延迟压力的程序来说，是非常有用的。



所以，远程对象调用，最大的特点，就是数据和计算是合并在一起的——这很好的提高了使用面向对象编程的便利性，也大大降低了远程调用中因为数据拉取产生的延迟。
远程对象的优点： 压力、易用性
在传统的“请求响应”为基础的分布式服务器中，最常见的数据系统是：接入逻辑缓存数据库 这样一个四层结构。为了让承担计算压力的“逻辑”模块能分布到不同的进程上，我们往往会把“逻辑”模块做成“无状态”的，这样我们就可以随意的启动、停止任何一个逻辑模块的进程，而不需要担心因此丢失用户数据。但是这样做，逻辑模块是轻松了，承担状态存储的“缓存数据库”哥俩压力就大了。因为每一个数据操作，都需要去从他们这里读取数据，然后再回写结果如果有数据修改操作的话。

由于“缓存—数据库”模块是有状态的，一般来说还很难简单的做分布式部署，因为如果随机分布数据的话，逻辑模块可能就会找不到状态所在的缓存进程。从理论可以知道，我们要让状态能分布，就一定要牺牲一些一致性或可用性。因此我们更倾向以的存储系统去充当“缓存数据库”模块。但是，即便是，还是会有两个缺点：一个是跨进程访问的延迟；一个是编程上的复杂性。
跨进程访问的延迟来源于两方面，一方面是本身跨进程通过  之类的手段通讯，就会有比进程内存访问高的多的延迟，而且我们常常会把一个业务流程按数据的类型划分到不同的“逻辑模块”里，这样一个业务请求可能会需要多次的跨进程访问才能访问完所需的数据，这就大大加重了因为网络带来的延迟；另外一方面来源于路由查找，虽然我们可以用一致性哈希这类算法取代路由查找，但是基于数据的业务特性，我们却不太喜欢把所有数据都拆的七零八落，所以常常还是有一个查询、或探索数据所在地的过程。
编程的复杂性也是很严重的问题。不管是  还是  ，这些数据都是以序列化的方式描述的，并且也按照数据的组织存放形式，要求使用者去准备好输入或者解析读出这些数据。这些数据和我们在编程中常用的结构体、对象往往完全是不一样的形式。这就造成了我们很多额外的编码和调试的工作。这些数据往往还是“结构敏感”的：如果我们修改了数据结构，往往需要重新配置数据表结构，修改访问代码等等。这让我们在快速开发业务逻辑的时候，背上沉重的开发效率包袱。因此业界才有很多所谓  对象关系映射的框架出现。
但是如果我们使用“远程对象调用”，就可以有效的缓解以上两个问题：

缓解跨进程延迟。由于远程对象本身已经包含了数据，所以对于所需的数据，都是从内存中直接读写，这方面的延迟是绝对最快的。另外，由于远程对象调用发起之前，已经需要先查找到目地对象，这样就把查找方法和查找数据的两个过程合二为一了，在路由层面也能有效降低延迟。

极好的易用性。由于面向对象编程的概念已经深入人心，所以对于“先找到一个对象”，然后“调用其方法”的过程，是非常自然的。复杂的负载均衡、容灾、扩容等问题，实际上都隐藏在“查找对象”这个环节底下，开发者几乎无需关心，所以用起来会非常方便。而编写一个远程对象，也非常简单，就是写一个类，实例化一个对象，然后登记到服务器里而已。这都是面向对象编程的传统做法。由于对象本身都是带数据的，所以编写这些远程方法也会比较简单，大部分的数据都直接在本地内存读写，比如从对象成员属性里。节省了大量编写或者定义和使用特别的存储设备协议的时间。


业界远程对象方案：
远程对象调用的框架，在业界也是常见的东西，这里大概说一下三家的     。这三家的框架大概的说明现在远程对象调用的主流用法。

全称  ，是的企业分布式集群方案的核心规范。能部署在多个服务器上提供远程对象调用服务的对象，就称为对象。底层的网络是通过自带的功能实现。本身只是规范中的一部分，仅仅是一套接口。具体的实现由类似这样的“容器”软件提供。之所以不及  流行，很大原因就是因为这些容器软件都是商业软件，需要花很贵的价格购买。但这并不影响作为一个优秀的远程对象方案的技术地位。现在已经升级到版本以上了，摒弃了以前配置复杂，功能晦涩的特点，大胆的使用更简单的生命周期管理、简单的注解式配置、好用的能力，让 重新成为一流的技术。

一个客户端程序，想要访问一个对象，一般需要使用一个叫做的，来具体连接到对象上。的全称是    ，基本等于我们常说的名字、目录服务接口。通过一套规范，来统一各种目录服务器的使用方法。所有的容器，都必须提供一个服务，而客户端程序则通过使用容器提供的来访问容器内的对象。的使用方法，基本上就是输入一个字符串，然后会返回给你一个对象。在的环境里，这个对象就是对象的接口对象对应远程对象的一个映像，也叫桩对象。代码类似：
  =  
  = “”
  =     
输入函数的字符串，是用户可以自己定义的任何内容，只要在对应的容器里面登记了这个对应关系即可。从这个代码我们可以看到，如果想要做容灾、负载均衡等功能，是完全可以通过这个接口来实现的。另外，远程对象的接口桩代码是需要预先部署在客户端测，在上面的例子里是这个类。而对象的这个接口类，是由工具，自动通过来源的对象类定义生成的。对比，等技术，可以直接用源代码代替定义，然后自动生成桩代码，这确实是简便很多。
规范把远程对象定义为三种：无状态会话，有状态会话，消息驱动。这意味着容器对于对象的生命周期是有管理的。其中无状态会话和消息驱动的声明周期是类似的，都是来一个请求消息驱动的意思是每来一个消息，就可能一个对象。当然也可能不是每次请求都新建对象，总之容器不保证会保持对象的生存周期，这样容器可以根据负载压力，灵活的管理众多的对象。而最特别的是“有状态会话”，容器会根据客户端的会话状态和客户端的对象对应，来保持对象，也就是说，每个客户端对应一个有状态。如果你用这个客户端，发起多次查找，访问的那个对象都将会是同一个。这对于需要保持登录状态的服务，就非常方便了。客户无需自己去维持一个远程对象的生命周期，而能得到状态保存的功能。
最后说说的部署配置，以前的容器部署异常复杂。除了需要写一个继承于特定基类的业务类外，还要配置很多细节。而之后，通过注解功能，这些配置都可以和源代码写到一起，而业务类也无需集成特定的接口和类型，可以是任何一个普通的类，只是需要加上一些特定的注释即可。容器提供工具对这些加了注释的类进行处理，一方面把这个类自动部署到容器中，另一方面生成客户端的接口类文件，供用户发布拷贝到需要使用的客户方服务器上去。而一些容器如还提供了的图形界面工具，让整个过程几乎都不在需要编写额外的配置和命令行操作。
 
 全称   ，是微软发布的用于构建面向服务的应用程序框架。这套框架的底层是  的  技术，而编程接口则更多的使用语言语言和平台。这和有一定的类似，差别就是中的远程对象，不需要一个像那样的虚拟机，而是结合在操作系统里。
 
无独有偶，的远程接口定义，也是直接使用代码，加上类似注解的“特性”功能注释，标注在一个定义好的接口上来组成的。具体的业务实现类，只要“实现”定义的这个接口就可以了，和一个普通的类没有任何差别。和的差别是，我们还是需要写一段配置，把这个远程对象的接口和查找字符串，注册到万能的服务器里面。一旦注册完成，就可以通过：这样的字符串去访问了。同时，如果客户端想要访问这个远程对象，则需要使用这个工具，输入刚刚注册的那个，就可以生成对应的客户端桩代码库。客户端可以直接这个新建立的桩类型对象，然后直接调用其方法，就和调用本地对象的方法一样。
   
  =  

     
  = 
  = 
  =  
{}{} = {}   
当然，如果你想连接不同的服务器，还是有机会的，一位内生成的客户端代码，会使用一个配置文件。在里面可以修改远程服务器的地址还是那个注册的。

     
         = 
         = 
         =  


你除了可以通过来提供的远程对象服务外，还可以自己写一个单独的程序，通过定义来完全的控制这些远程对象，从而提供服务。另外，除了通过直接对应一个远程对象外，还可以通过编写“路由服务”，来对同一个的远程对象调用进行灵活的路由。虽然没有提供类似的远程对象生命周期管理功能，但是你完全可以通过的服务和路由服务，来自己编码实现任何形式的远程对象生命周期管理。
 
公司的服务，是以技术为基础的，但是又不同于的另外一套远程对象技术。这套技术更接近于以为基础实现的体系。这个技术的使用标准的 接口作为远程对象的接口，使用的序列化、反序列化能力作为编码能力。然后自己写一个函数，建立一个对象来构造一个远程服务器。而客户端则是通过一个字符串来定位想要访问的远程对象。这个字符串类似： 。我们可以看到这里面有和端口，还有一个编写服务器远程对象时注册的字符串。我们通过 – 这样的命令行部署远程对象，然后用  启动服务器，用  启动客户机。这些命名，都是包含在      里面的。我们可以发现，是一个更加原始的远程对象方案，基本上就是一个的实现的组合。使用起来有点繁琐，但是好处是不需要学习和部署复杂的容器服务，可以完全自己编码去实现一套远程对象服务。这里没有限定你使用什么方法去定位查找远程对象，也没有限定你怎么管理远程对象的生命周期，一切都由开发者自己去编写实现。
小结



规范
远程对象定位
远程对象生命周期管理
服务器部署





路径字符串查找
自动管理，带会话状态对象
使用容器服务



、路由服务
无
部署到或自写



 定位
无
自写



在对象定位的选择上，通过字符串查找已经是标准，而复杂的自定义路由也可以隐藏在这个查找操作下面。远程对象的生命周期管理，实际上是对服务器资源的管理，除了有容器支持以外，其他的方案都比较少提供这样的能力，说明这一块是比较困难的。服务器部署方面，可以让用户以自己写去构建服务器，提供了极大的灵活性。
远程对象的挑战：生命周期管理、数据一致性
通过上面的分析，我们可以发现，远程对象的生命周期管理，是一个比较重大且复杂的课题。我们要保证这样的生命周期管理程序，能有一个通用的策略，来保持各种业务情况下的服务器资源稳定，是比较困难的。而且在分布式系统的情况下，为了负载均衡，还要把同样类型的远程对象，部署到不同的进程上，这就引入了一个新的问题：数据一致性。
远程对象的生命周期，除了占用服务器的内存资源外，还会占用记录其地址的路由空间，检查维护生命周期的运算时间。如果我们提供自动化的对象生命周期管理，势必就需要在客户使用的时候，提供这方面的教育，以及防止客户使用错误、过载等情况下对象管理失效的防御性策略。所以即便是容器，也仅仅提供了非常简单的生命周期管理策略：会话状态、无状态这两种。
对于一般的互联网应用，只有这两种生命周期管理的远程对象，基本上是够用的。因为一般的互联网应用，大部分数据都是持久化数据，需要读写数据库。临时状态数据一般来说不多，主要是用户登录后的产生的一些过程数据，有一个“会话”类型的生命周期就足够了。但是，如果我们的业务是网络游戏，那么这么简单的生命周期就是完全不够的，因为游戏中有大量的临时状态，比如组队的状态，玩家所在房间的状态，关卡副本的状态等等。这些临时状态，都是需要我们通过业务逻辑代码，来控制和管理所对应的对象生命周期的。所以一个适合游戏的远程对象系统，需要提供让客户端程序来选择，“新建初始化”和“销毁”远程对象的能力。
在对远程对象进行管理的时候，我们常常会用到一种叫“对象池”的技术，使用这种技术避免频繁的新建和销毁对象。但是如果这些对象的是带状态的，那么我们的“池”就必须带索引，并且对象也必须有一个。同时我们的对象还需要有一个“”的重置方法，用来让对象回归到初始化状态。
在分布式的系统下，我们的对象池因为是分别存放在不同的机器上，所以其一致性的维护往往是比较困难的。但是，我们可以把这个问题，转换成构建一个“分布式对象池”的问题。假如每个对象池，都按的某个规律，如一致性哈希，存放不同的对象。那么只要在远程调用发起的时候，也就是通过查找远程对象的时候，把请求导向到对象所在进程，那么就能很方便的从本地进程对象池中获得对象。远程对象的“定位”和“一致性”在查找对象这个环节结合起来，是一个非常好的想法。这样能让远程状态对象的使用进一步简化，用户完全无需关心远程对象在什么地方，又能快速的访问到正确的对象。
扩容下的远程对象迁移：
当分布式的对象容器出现部分进程故障，或者需要动态扩容的时候，只要我们针对对象查找的数据做某种程度的数据搬迁，或者缓存清理，就能很容易的实现对象的重新分布。如果对象同时能够支持持久化，那么这种数据搬迁，只需要简单的让对象写入持久化。然后在新的机器上，通过缓存建立的策略，从持久化设备读取出对象即可。
总结
远程对象调用，是一种业界成熟的分布式服务器系统模型。这套模型提供了强大的分布式程序架构能力，并且能方便的置入统一的运维特性能力：容灾、扩容、负载均衡。
它比远程方法调用，增加了对数据位置的指向，能有效的提高系统的响应速度。同时面向对象的形态，也能显著降低复杂逻辑的开发成本。
远程对象的生命周期管理，实际上一种分布式缓存系统的管理。良好的远程对象系统，能提高丰富的生命周期管理功能，以适合网络游戏，这种需要处理丰富临时状态的行业需求。
如果我们把远程对象的寻址和数据一致性维护结合起来，并且提供对象的持久化支持，那么远程对象调用将是一个高度自动化，且具有自我维护能力的强大分布式计算系统。

相关推荐如何设计一个系统谈谈后台服务的和路由管理摩拜单车自去年推向市场运营以来，凭着过硬的技术实力和良好的骑行体验，一直引领着全球智能共享单车行业的发展。仅仅用了一年多的时间，摩拜就发展为服务覆盖中国、新加坡、英国等全球个城市、投放车辆超过万、日均骑行量万的国际化创新品牌。

在月日腾讯“云未来”峰会现场，摩拜单车首席架构师范同祥对外揭秘了这家共享单车行业领导者背后的技术支撑实力。范同祥指出，摩拜今年依然保持高速增长，现在每日最高出行量已经稳稳保持在  万上，摩拜的高速增长主要源自于产品的创新和摩拜车辆的品质，但是如果在高速增长过程中没有足够强大的技术系统作为支撑，摩拜也是很难走到今天的。

在分享中，他将摩拜高速发展的技术支撑总结为「六脉神剑」：

物联网技术
云计算平台
微服务架构
 流水线
腾讯专家团
摩拜技术文化

物联网技术

摩拜在物联网技术领域很早就进行了布局。摩拜从第一辆投产的车开始就投放了智能锁，智能锁里面集成了像  定位、 通信、蓝牙和窄带技术。直到今年的三四月份，友商们才开始量产他们的智能锁。
摩拜在物联网领域有近一百项的专利或专利申请。这些物联网的技术反过来帮助摩拜后台的系统高速迭代快速升级起到了非常重要的作用。仅以  技术来说，摩拜数百万辆车的嵌入式系统固件升级，只需要几个小时的时间，一夜之间就完成了。
云计算平台
摩拜在高速发展中，腾讯云功不可没。

范同祥加入摩拜时，摩拜的技术团队还只有三五十人，后台研发的只有十几个人。十几个人面对高速增长的系统，要解决这么多问题，怎么办？
摩拜非常明智地决定快速上云，但是很可惜的是，早期的云是海外的某知名厂商，当时对摩拜的重视程度不够高。后来选择了腾讯云。在现场，范同祥分享了几个摩拜迁移到腾讯云上的几个故事。
系统迁移不到一个月

我是去年年底加入的，我们在春节之前就迁完了，前后一个月不到。还好当时数据量不大，只有几个，在腾讯专家的协助下，我们提前把数据从原来的云平台导过去，再进行差量同步，切换当晚，进行数据比对和回归测试，确认没有问题。一个通宵，把所有的系统就这么切过来了，速度非常快。

成功度过  攻击

摩拜在今年  月  号遭受了史上最大一次的  攻击 。那天还挺狼狈的，因为是周年庆，也不知道哪位神仙在背后放小脚，让我们系统不太稳定。腾讯云团队迅速响应，启动了北京、广州、上海多地机房，迅速将防控能力提升到，成功抵御了这一拨疯狂的攻击。自此以后，摩拜再也没有遭受过超过一百的  攻击。

上亿条短信发送

今年开春以来，摩拜的友商们很快发动了免费战，摩拜也要响应，有时候一天发送的营销短信高达上亿条。一亿条短信在一天甚至几个小时之内发送出去，摩拜的技术小伙伴是没有什么经验的，这么艰巨的任务最后也是交给了腾讯云的短信团队。摩拜接入腾讯云之后，不仅仅是用了腾讯的计算、存储、网络等基础设施，还得到了腾讯非常多的技术团队的支持，帮助摩拜高速成长。

微服务架构

正是因为有腾讯云的助力，摩拜自己才有时间、有精力腾出来对系统做一些改造。范同祥加入摩拜之后，率领团队迅速完成了以下几件事：

快速升级代码，将技术栈切换到  开源的   的体系。
快速实现了微信支付通道的接入，保证后台和技术通道的高可用。
快速升级系统架构，按业务进行拆分，独立部署

 开源技术栈、等较好的实现了分布式系统的熔断、限流、回退、全链路监控等机制。其中比较经典的应用场景就是微信支付。微信现在对于重要商户是有两个支付通道的，当有一个通道发生问题的时候，基于这个框架可以自动切换到另一个支付通道，这个过程是无缝的。

在架构升级过程中，摩拜曾担心给体验带来较大的冲击，但是腾讯云技术团队及时给予了非常强有力的理论支撑，指出了现存系统的问题。后来，摩拜快速对系统按业务进行垂直拆分，把不同的接口进行归类，独立的部署，使得他们相互不干扰。相应的数据库也分拆成了不同的实例和集群。每一类不同的业务，像关于用户的、车辆的、支付的，归类到不同的子系统当中，连接不同数据库的实例。一开始只能采用最简单粗暴的方式，先拆分再扩容，如果用传统方法，如果不是在云上，我相信这个过程会非常痛苦，管理维护成本非常高。而我们这点做得比较好，因为我们有腾讯云的团队支撑，所以数据库的拆分扩容过程基本上没有操什么心，我们只是把我们的系统业务代码做一些简单的配置变更，就快速实现了系统扩容升级。
 流水线
在系统架构的高速演进的同时，摩拜在开发工具、运维体系的建设上是不遗余力的。

范同祥  年离开 后，一直在互联网创业公司工作，他发现有一个共同特点：国内的创业公司，大多数业务在高速增长的时候，都会演变成人肉大战的模式。人不够，需求太多了，用户太火爆了，怎么办？老板就使劲招人。
因此，他在加入摩拜以后就不遗余力去推动公司建设流水线，推动研发效率的提升。现在，摩拜有机的整合了常见的的开源工具包括 、、、等，严格把控研发过程。

摩拜与腾讯云的集成是非常紧密的。摩拜的运维团队利用腾讯云提供的丰富  和 ，会自动通过腾讯云的  导入机器，对后台服务器进行自动化管理。
机器导入过来以后，摩拜自己定义了一些策略和模板，统一管理开发测试环境和生产环境。国内的大多数互联网公司，都只能维护几个固定的开发测试环境。摩拜做到了按需创建，谁只要有需求，快速在我们平台上一键创建一个完全独立的环境。
怎么做到？摩拜的后台深度集成了腾讯云，简单配置一下，需要多大规模自己定义，最小三台机器组建一个集群。一个按钮点下去，通过调用腾讯云和的，自动完成虚拟机、数据库、域名的初始化过程，分钟之内即可创建一套独立的环境。
腾讯专家团
在摩拜发展过程中，不只是腾讯云的专家技术团队，还有来自于腾讯的 、微信各个领域腾讯公司的技术专家帮摩拜解决各种技术难题。

比如区域化部署。刚才提到两地双机房的方式不适合于摩拜的长期发展，摩拜现在在做全球化的布局，刚刚融资六亿美金的用途就是做全球化，全球化以后分散在不同机房，延迟是比较大的，平均延迟业内是  毫秒左右，腾讯现在做到  毫秒以下。摩拜第一个海外城市新加坡走的是代理模式，核心服务还是在北京机房，通过腾讯新加坡的机房，走腾讯的内网专线，路由到北京机房。

摩拜希望未来用户能够就近接入，欧洲的用户从欧洲的机房接入，美国的用户从美国的机房接入，对后台业务系统就会有非常大的挑战。
摩拜还借鉴参考了当时 、微信的经验，腾讯给摩拜提供了一套区域化部署解决方案。未来摩拜的系统，将部署在国内的四大机房以及海外多地的机房。如果一个机房宕机，同时还有其他机房来提供服务。不论是哪里的用户，接进来几乎感觉不到什么延迟，系统可用性也会大大提高。
摩拜技术文化

最后，范同祥指出了摩拜的独特技术文化和执行力的影响。摩拜的执行力非常迅速，发现重大问题，一个晚上把所有代码改了，第二天就上线。这样的例子非常非常的多。
另外，摩拜的技术团队虽然比较年轻，但是心态非常开放，能够容纳各种各样的新鲜事物，只要你的见解是合理的，团队都毫无保留的采纳。摩拜这一点做得非常好。只要你设计合理，对公司是有利的，我们马上执行。近期云计算安全事故频发，如何尽可能的避免云计算安全故障呢？
一方面是尽可能使用自动化的操作来替代人工操作，降低因为人为操作而产生的故障可能。
另一方面是降低人工操作出现的可能，通过提醒，来降低出现错误的可能。
动手操作
默认情况下，我们登录云主机，看到的界面会是这样的。

这样的提示平淡无奇，自然难以让我们产生警示，这里我们就来教大家如何设置一个独特的提醒。提高警惕性！
 创建提示信息文件
 

 编辑文件，添加我们要提醒的文件
这里我们使用 来编辑文件，并加入我们想要提醒的内容。
 

比如这里我加入    

保存，并退出。
 修改  的配置
执行命令  _
然后在其中加入如下内容
 

重启 
执行命令重启 
如果你是 ，执行  ；如果你是 ，执行  。
 断线重连测试
再次连接，我们可以看到如下的效果。我们填写的提示信息就会出现在我们的登录信息前。
在你使用时，将这个修改为你自己的信息，就可以方便的在登录时，告诉操作人，你当前在操作哪台服务器。

相关推荐性能监控——腾讯云消息队列在环境下的使用【腾讯云的种玩法】服务器配置系列一服务器的配置前言
首先要明确我们的任务。要想解数独，需要进行计算，图片格式的数字肯定是不行的，所以必须把图片上的数字转换为实实在在的数字才能进行计算。要得到实实在在的数字，我们需要做的是对图片上的数字进行提取和识别。本文先说第一步，图片中数字的提取。
在一年之前，我曾用  尝试过  解数独，但由于当时水平有限，未能完成。当时的成果就是透视变换的应用和方格数字的提取。现在稍微简化一下工作，不再从倾斜的数独图片中提取数独，而是直接用正拍且已经提取好的数独开始处理。这里用到的数独图片如下图所示：

方法
以前的方法
从上图这样的九宫格图片中提取数字，我以前用的方法是，先利用轮廓提取，通过轮廓的面积进行筛选，得到所有的个小方格；然后对检测小方格中是否有黑色像素以及像素的多少排除噪音来判定哪个小方格中有数字；最后对有数字的小方格再次进行轮廓提取得到数字的轮廓和轮廓外包矩形。
此方法实现起来相对来说比较麻烦，思路仅供参考。
本次所用方法
在仔细研究了  轮廓提取函数之后，发现利用轮廓的层级结构会更加简单。作为本节最主要的函数，有必要稍微多说几句。
        →  

在中，接受如下参数并返回和。
  源图像，一般为为单通道图像，更具体来说，二值图像。其他情况暂且不论。
  轮廓检索模式，简要介绍几种：

_  只检测外轮廓。对所有轮廓设置==
_  提取所有轮廓，并放置在中，检测到的轮廓不建立等级关系。
_  提取所有轮廓，建立网状的轮廓结构。

  轮廓的近似办法，是提取轮廓上所有像素点，还是只提取关键的一些点。比如一条线段是提取所有点还是只提取两个端点。
  检测到的轮廓，为组成轮廓的点集。
  下面详述。

什么是层级结构呢？我们检测轮廓的时候，有时候可能会出现其中一个轮廓包含了另外一个轮廓，比如同心圆。这里我们认为外侧轮廓为父轮廓，内侧被包含的为子轮廓。同一级别的又有前一个轮廓和后一个轮廓。总的来说，表达的是不同轮廓之间的 关系和联系。
这样，每一个轮廓都会有  _ 
上面说到，_  只检测外轮廓。对所有轮廓设置==。由于只检测最外围轮廓，所有检测到的轮廓肯定没有父轮廓和子轮廓，所有层级结构的第三个和第四个元素都设置为。
看下图：

如果只检测最外围轮廓，那么只会检测到轮廓、和。
如果建立层级关系，以轮廓为例，那么它的父轮廓是，子轮廓是，没有前一轮廓和后一轮廓，设为。所以它的应该是
如果是轮廓，那么它的前一轮廓就是，子轮廓是，没有后一轮廓和父轮廓。所以它的应该是
有兴趣的可以仔细看看，没兴趣的可以略过。兴趣更浓的可以去看文档，那里的讲解更加详细。
这里就说这么多，对于我们本节的内容来说，已经够了。
上面说了啥
我觉得大部分人这个时候还会问，上面说了这么一堆到底是要干什么？？？因为这里确实不是那么清晰明了。
别忘了我们本节的目的是要提取数字，什么样的轮廓包含数字？
一般来说经过前面的阈值分割得到二值图像，然后从二值图像中提取的轮廓是这样的。这是处理的比较好的情况下：

显然最最外面的那个包围所有的就是号轮廓，里面的九九八十一个小方格就是号轮廓的子轮廓。而每一个已知数字的轮廓都是对应方格的子轮廓。
提取数字
所有我们的办法就是先提取方格，然后提取数字。
八十一个小方格有什么特点？父轮廓都是号轮廓！所以：
 = 
   
      == 
        

不记得的可以上翻看一下是不是第四个元素表示父轮廓。
然后从小方格中提取数字轮廓。数字轮廓的有什么特点？其父轮廓有子轮廓，也即是说包含子轮廓的小方格里面就有数字。所以：
   
      = ：
         = 
        _

不记得的可以上翻看一下是不是第三个元素表示子轮廓。不等于表示存在。
最后把检测到的数字画出来就可以得到下面的这幅图了。

代码
    
 

 = 
 = _
 阈值分割
 = 

 对二值图像执行膨胀操作
 = _      
 = 

 轮廓提取，_表示建立层级结构
   = ___

 提取小方格，其父轮廓都为号轮廓
 = 
   
      == 
        

 提取数字，其父轮廓都存在子轮廓        
_ = 
   
      = 
        _
         = 
        _
         = 

 _ 
 


下一步
数字已经提取出来，下一步就该是数字的识别了

相关推荐
玩九宫格数独：预告篇深度学习平台前言：针对互联网“后半场”以及创业维艰的说法，笔者不敢苟同，正所谓：当初张朝阳看不上马化腾，雷军看不上马云，今天，一堆业界大佬也看不上新的创业者，这是创业成功的先兆，而非失败。本文从腾讯的发展历程，分析当初作为创业者的腾讯在巨头笼罩之下有何优势，今天作为巨头的腾讯有何劣势。只为探寻创业成功的秘诀，企业长治久安的隐忧。
观点：大公司的失误不是因为错误而导致的，反倒是因为正确才导致的，所以，这种失误才是必然的，不可避免的。
年，对于互联网创业者来说，笼罩着整个中国的，除了雾霾，还有。同样的，对于其它行业的创业者来说，一定有巨大体量的知名公司笼罩着整个行业。
在这些巨头们的笼罩下，创业成功的机会非常渺茫。
真的是这样么？
就从今天的霸主之一腾讯说起——因为笔者最了解腾讯。
————
笔者最早玩的网络游戏，是联众，天天玩联众里的台球游戏，不亦乐乎。突然某一天，联众开始收取会员费，不交钱就丝毫玩不了。这个决策，一定是无奈的，企业毕竟要盈利。这个决策出台后，一定有用户反馈，然而，联众没有丝毫的改变，将收费进行到底。于是，我就再也不玩联众了。
联众布局网络小游戏的时间非常早，而且从用户占比上，已经达到了当时互联网用户很高的比重。然而，很遗憾，为了收费，他们一刀切下去，令用户伤心了。像我这种收费就不玩的用户，固然显得有些贪婪：想玩好，还不想交钱，天底下哪里会有免费的午餐？
同样由于收费而断送自己前途的，还有很多，比如：邮箱。邮箱收费之后，笔者转移到了亿邮。亿邮后来也推出了收费的版本，但依然保留了免费版本。不愿交钱的用户享受基本的功能体验，交钱的用户享受高级的功能体验——这个策略还是很牛逼的。所以笔者用亿邮用了很久，这说明这家公司也存在了很久。后来，垃圾邮件越来越多，作为普通的亿邮用户，实在是无法忍受垃圾邮件的困扰，就再也不用了。至于亿邮的高级用户是否解决了垃圾邮件的问题，笔者真心不知道。
亿邮的教训是：基本的用户体验如果做不好，用户一定会用脚投票。
再来看看腾讯当时是怎么做的。有一段时间，的注册是需要手机发送短信的，收取一定的费用，然后可以申请十个还是三个号码。
从这个事情来看，当时腾讯也是穷的不得了，否则绝对不会拿注册号码这件事情来收费。
但是，很快，这个策略就被抛弃了。
腾讯牛逼啊，申请个号还要收钱，你牛逼是吧？我不用你就是了！
腾讯是如何发现这个问题的，通过用户反馈？还是通过自己的思考？总之，申请号码收费这件事情就此打住。当然了，腾讯找到了类似亿邮的收费方式：推出高级功能，吸引用户付费。比如秀。无论用户多么讨厌会员、红钻、黄钻、绿钻、等一系列五彩斑斓的钻，至少，不花钱，玩的也还行，嘴里一边骂，手上一边玩。
所以，腾讯战胜联众，不是因为腾讯的体量有多大，当时联众的体量跟相比一点都不差！是因为联众犯了致命的失误，这个失误不是收费，收费没有错，这个失误，是：
缺乏对于用户感受的关注和足够明智的反应。
一方要收费，一方不想交费，这个问题，看似完全冲突，却被亿邮和腾讯轻松化解。
联众如果不收费，说实话，笔者还真是会一直在联众玩台球游戏。
至于游戏的收费策略，大家都知道的，交钱玩的爽，不交钱也能玩。
————
大型网游，许多人都知道的，当初最牛的，是盛大。盛大老板陈天桥一度成为中国首富。
盛大开创的游戏免费、道具收费策略，与上节提到的亿邮跟腾讯如出一辙。

当时的腾讯，大家谁记得有什么大型的网游么？笔者是不记得。当时的腾讯，虽然用户量巨大，然而从盈利赚钱的规模上，跟盛大不在同一个档次！甚至是否盈利，都很难说。
当时的盛大如果收购腾讯，就跟现在的腾讯收购一家创业公司一样简单。当然，没有收购不算是失误，只要自己发展的好，是否收购其它有潜力的公司，这只是锦上添花的事情。后来，盛大全力搞“盛大盒子”。这个情怀还是蛮高的。
然而，经营企业，不能赌气。
就像联众一样，跟那些吃惯了免费午餐的用户赌气，最后损失的是自己。
盛大跟当时中国的网络带宽赌气，跟广电部门的监管政策赌气，最后完蛋的是自己。
今天，做共享自行车的创业公司，谁跟社会的道德水平赌气，谁就必定会完蛋！
用户不愿意交钱，所以才需要变着法子的让用户自愿给钱。
中国的网络带宽很慢，所以才需要从技术上解决带宽和流量的问题。——微信刚刚推出的时候，就是极力宣传自己对比竞争对手的流量优势，因为当时大家都在用移动的网络。
广电部门的监管太严格，所以才需要从产品的角度彻底颠覆广电赖以生存的产品：电视机。今天，谁还用广电网络看视频啊！都是用互联网。
————
腾讯在互联网领域算是后起之秀，在腾讯之前，搜狐、新浪、网易，相当于今天的。
有传言说腾讯找过这几位大佬投资，但是这几位大佬都没有投。这件事情说明不了这几位大佬缺乏眼光，如果缺乏眼光，人家何以能够占据互联网领先的地位？
就像今天一大堆创业公司会找腾讯投资一样，马化腾没有时间一个个仔仔细细调查；同样的，当时，马化腾对于张朝阳，只是成百上千的创业者中间的路人甲。
“我们能够很轻松的做一个出来。”不知道这句话是谁说的，但是真的很有道理！笔者自己也做过一个出来，客户端加服务器。
然而，做出一个软件是一回事儿，让全中国所有网友都用，就是另外一回事儿了。
更何况，就算大家都用，又怎样呢？联众当时还不是被大家用，还不是被大家用，盛大还不是被大家用，还不是被大家用，然后呢？
那么，对于一家企业，如果连产品都不重要，连用户量都不重要，到底什么才是重要的呢？
————
有人会说：是人才。比如说：腾讯收购，最大的收获不是做出了邮箱，而是得到了张小龙这个人。后来张小龙搞出微信，奠定了腾讯在移动互联网的地位。再比如说：腾讯收购易迅，然而易迅拼不过京东，说明刘强东人才难得，所以最后腾讯只好把易迅送给京东，自己占据京东两成多的股份。
然而，张朝阳是不是人才？陈天桥算不算人才？今天的马化腾、刘强东，未来，又会如何呢？
都说十年河东十年河西三十年太久，也就十年吧，这句话只是对结果和现象的描述，原因何在？
今天的创业者，凭什么能够成为明天的？ 
企业持续发展长治久安的关键到底是什么？
————
大公司势力强大，无论是在行业内的影响力，还是企业内部的人才优势，都远非创业公司能够相比。
那么，与创业公司相比，大公司有何劣势呢？今天的腾讯，与十年前相比，哪些地方变得更差了？
微软在创业之初，在多个产品上做出逆转，比如操作系统，比如办公软件，比如浏览器，都是后来居上。为什么偏偏微软强大之后，手机操作系统步履维艰，浏览器反倒被谷歌反超，也是被穷追猛打，占尽优势反而没落？
微软、谷歌、腾讯，创业之初，招聘的人才，跟今天动辄名校高材生相比，简直是天壤之别，为什么更牛逼的人才没有做出更牛逼的事情？
微软坐过“最佳雇主”，谷歌坐过“最佳雇主”，腾讯也坐上了。
“最佳雇主”是什么意思？当然是对员工很好喽！
日子过得“很”滋润，这当然是员工的诉求。但是，日子过得“太”滋润了，问题就产生了。
从“很”到“太”，这个度，是非常难于把握的。物极必反，就差那么一点点。
日子很滋润，大家能够全身心投入工作；日子太滋润，大家就没有了压力和动力。
创业公司，对公司命运具有决定作用的高层领导，压力和动力是相当巨大的。
成功之后，尤其是变成巨头之后，中高层领导的压力就会小了很多，甚至开始享乐。毕竟，苦逼了十年二十年，赚了几千万上十亿，图个啥？
就算不享乐，团队大，业务杂，事情多，一天到晚忙不过来，哪里有功夫考虑更加长远的事情。
别说外部的创业者跑过来说：“我有个好的创业项目，想让您帮忙看看。”
就是内部的员工都接待不过来：“老板，我有个好的创意，想让您帮忙看看。”
有管理学专家总结了一条大公司必然堕落的现象：领导们都在开会！
————
、生于忧患，死于安乐。
创业公司缺在资源，缺在人才，优势在有压力，有动力，每天都在考虑如何赚钱，如何活下去。
大公司优势在资源，在人才，劣势在没有压力，没有动力，每天都在考虑如何花钱，如何活得更滋润。
虽然大公司天天在强调风险、压力、斗志、激情，然而，每年领取几十万上百万甚至成千万上亿元的薪资，跟创业公司动不动就没饭吃饿肚子比起来，压力的差距何止一丁点。
创业团队做不好，老板几年时间等同于白干；大公司业务做不好，大不了被老大批评，奖金少拿一点喽，实在不行业务被裁撤，大不了换个公司换个岗位嘛！
这种状态，如何跟创业公司比？
当初，如果完蛋了，马化腾就完蛋了；完蛋了，微软有几个人因此破产的？换个部门继续造嘛！实在不行直接去谷歌嘛！
华为老板任正非天天忧虑，不是没有道理，下边一大堆中高层干部，一个个富得流油，股票奖金一大把，但凡遇到个什么人生导师世外高人，可能就抛弃一切周游世界去了。
、福兮祸之所倚。
大公司之所以必然会犯错，是因为太成功了，那些成功的经验被奉为宝典，不可逾越。今天马化腾和张小龙的话，别说腾讯内部了，整个互联网行业，有几个敢说个不字？就像十多年前，张朝阳说一个不字，相当于判了腾讯死刑。
这并没有什么错。自己用十年甚至几十年积累的成功经验，今天，一个路人甲，说推翻就推翻，如果连这一点自信和坚持都没有的话，也不可能做到成功的地步。
其实，事情往往还不在于巨头们对创业公司的思路看不上，而是：根本看不懂。
一个崭新的东西，很多时候，都是直觉和感觉，根本没有到思路完全清晰的地步。等思路足够清晰的时候，说明业界的趋势已经非常明显了，机会早就没有了。海尔张瑞敏看不懂马化腾的，是必然的。不是因为马化腾口才不够好，而是因为马化腾当时自己也没有考虑清楚未来到底会如何！如果马化腾当时对的考虑非常清晰，就不会到最后只有的腾讯股份了。
所以，别看那么多电视上的创业演讲，最后能够真正成为未来巨头的，都不在台上，都不是那些老大们一眼看中的项目！如果是具有共识的，业界早就有一堆资源丰富的人搞了，还有什么创业机会。
、时间是有限的，领导都在开会。
大公司之所以必然会犯错，是因为太庞大了，事情多到各级老板没有时间和精力去关注一线的战事，即便内部有从下到上的反馈渠道，然而，能够被重视的，没有几个。不相信？给马化腾和张小龙发个邮件，看看人家有没有时间回！更不要说跟马化腾张小龙促膝长谈了。风险投资、管理学、营销学，有个共同的诀窍：电梯法则。如果想争取到别人的支持、上级、用户，最好能够在秒内等电梯或电梯内的时间打动对方。
然而：
、一个战略性问题能否在秒之内讲完；
、找一个口才如此之好的人，都得万里挑一；
、更不要说创业者自己都没有考虑的完全清楚；
、更不要说即便创业者考虑的完全清楚，巨头们根本听不懂；
、即便听得懂，由于与人家自己的经验相左，也不可能获得认同。
马化腾、张小龙、风投的老板，显然都很忙的，所以从时间管理上，不可能拿出多少时间去关注用户来信或者员工创意这种沙里淘金的事情，真要是把时间都花在这个上边，他们也就没有时间去做别的决策了。
正因为张朝阳和雷军没工夫搭理马化腾，所以马化腾很无奈自己只好忍受压力继续坚持，才有了后来的腾讯。
正因为马化腾没工夫搭理新的创业者，新的创业者才会很无奈默默忍受，直至成功。
这些事情都是最最正常的，所以，创业成功才是正常的！
正因为大公司的失误不是因为错误而导致的，反倒是因为正确才导致的，所以，这种失误才是必然的，不可避免的。
古人说：物极必反，诚不予欺！

以上内容同步发布至作者本人公众号【水滴的声音】关注企业文化、团队管理。