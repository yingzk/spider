本案例演示观察到负载不均衡情况下，电路板测试网络带宽发挥不出来，并实施负载均衡后，看到网络带宽重大提高。
怎么烧录镜像
在 项目下载，用解压后得到，写入的卡卡拔出后，以读卡器插入电脑。
  = = 是你的卡在你电脑的路径
实验方法
开机后电路板的地址自动已经配置为，将电脑与电路板网线直连，保证本机可以访问的地址。登陆电路板可以用命令：
 
无密码。
电路板上也集成了版本的，位于，运行方法：
 
浏览器端设置方法：

运行服务器：
 
电脑运行客户端每秒报一次网络带宽：
           |  
均衡前
此时里面监控到严重的负载不均衡现象：

如果不做任何工作，均衡前电脑上上的周期：

浏览器的显示其中在严重地看热闹：


均衡后
在电路板运行负载均衡脚本
 
该负载均衡脚本内容如下，是关于和的配置：
   _
   _
  ___
   __
此时电脑上带宽报告：

此时命令状态：

此时端浏览器显示
我们看到的线迅速下跳不再看热闹了：

开始处理包：

稳定观察一段时间后两个在均衡处理网络：

再次恢复恶劣状态
在电路板运行负载不均衡脚本就是默认状态
 
电脑上上的带宽再次严重下降：

均衡前后对比






带宽




均衡前
忙 闲

 忙 闲




均衡后
 忙 忙
 忙 忙





文章来源于： 微信公众号导语 无论是几十纳米的病毒 几十微米的叶绿体 几十毫米的蜜蜂，都会使用各自的语言。语言都是一种自然沟通手段，通过语言 可以影响其他个体 共同完成进化任务 从微观的层面上看 人穷极一生 都是在训练我们的高级神经中枢 以便对各种外界刺激做出正确的反应。从宏观上看 自然语言语义的理解 就是对各种外界刺激进行分类的过程。

语言是什么 有什么作用
无论是几十纳米的病毒 几十微米的叶绿体 几十毫米的蜜蜂 还是几十厘米的远古人类 都会使用各自的语言。 语言都是一种自然沟通手段 通过语言 可以影响其他个体 共同完成进化任务。

人类语言是如何形成的
从微观的层面上看 人穷极一生 都是在训练我们的高级神经中枢 以便对各种外界刺激做出正确的反应。 从宏观上看 自然语言语义的理解 就是对各种外界刺激进行分类的过程。
人类这种物种的进化过程 就是对高级低级两套神经系统的训练过程。 对个体来说 高级神经系统的训练效果更显著 对种群来说 高级神经系统上产生的进步 会整合到低级神经系统中去。人类的语言形成与高级神经系统的发展是分不开的 有了语言这种工具 人类可以在交流中定义逻辑规则 表达更加复杂的概念。

语义理解的实质是什么
语义理解的实质是一个分类问题 输入为各种自然语言。输出为理解各个语义后需要产生的行动。

语义理解的两个必要条件
我认为要完成语义理解任务 有两个必要条件作者：

从 《远程调试  设备使用入门》 文章中我们可以知道在 可以通过在中使用下面的代码开启的远程调试。


但我们开发中接触的往往是第三方的，没谁会为我们开启，而能强制做到这一点。

能够勾住 应用程序对象的方法，实现，一个简单的例子：
     {
      会在加载每一个后执行
          {
            可以从中获取当前的名字
           {
            
        }
            
         勾住  所有的构造器
          _ {
            
                  {
                 打开
                  
                     
            }
        }
    }
}

上面的代码可以为打开的。
工作原理可以参考文档： 
没有详细的页面， 因为也就几个，可以查看源代码： 
馋图



拿来主义
、需要   手机
、安装 框架
、已开启 的： 

原文链接：云硬盘，是腾讯云推出的一种可扩展、高性能、高可靠云端存储服务。云存储不是存储，而是服务。就如同云状的广域网和互联网一样，云存储对使用者来讲，不是指某一个具体的设备，而是指一个由许许多多个存储设备和服务器所构成的集合体。
云硬盘与云主机一样，是云计算用户接触最多的云服务之一。但是许多用户可能对它并不是特别了解，仍然像本地使用硬盘那样对待云硬盘。有的开发者甚至不太在意选择具体哪种云硬盘，直到某一天网站开始变得响应迟缓，才发现瓶颈竟然是因为当初选的硬盘性能已无法满足网站的要求。
因此，腾讯云技术社区特别邀请到了负责云硬盘产品经理和研发工程师进行在线分享，为大家全面地介绍云硬盘服务的具体情况，同时分享一些云硬盘使用的最佳实践。
分享日期：月日晚点半点半分享地点：腾讯课堂报名链接：=
分享嘉宾
张浩，腾讯云存储产品经理吴光辉，腾讯云后台研发工程师
分享提纲

什么是云硬盘？及云存储背景知识
云硬盘都有什么用途？
云硬盘主要功能及实操演示
云硬盘典型使用案例
实战：如何测试云硬盘性能？

分享预览导语 ： 消息队列是分布式系统中重要的组件，在很多生产环境如商品抢购等需要控制并发量的场景下都需要用到。最近组内需要做流水的选型升级，这里对消息队列及常见的消息队列进行了一次调研，整理了相关资料，分享给大家。

一、消息队列概述
消息队列 ，是分布式系统中重要的组件，其通用的使用场景可以简单地描述为：

当不需要立即获得结果，但是并发量又需要进行控制的时候，差不多就是需要使用消息队列的时候。

消息队列主要解决了应用耦合、异步处理、流量削锋等问题。
当前使用较多的消息队列有、、、、、等，而部分数据库如、以及也可实现消息队列的功能。
二、消息队列使用场景
消息队列在实际应用中包括如下四个场景：

应用耦合：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；
异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；
限流削峰：广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；
消息驱动的系统：系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者可能有多个负责对消息进行处理；

下面详细介绍上述四个场景以及消息队列如何在上述四个场景中使用：
 异步处理
具体场景：用户为了使用某个应用，进行注册，系统需要发送注册邮件并验证短信。对这两个操作的处理方式有两种：串行及并行。
串行方式：新注册信息生成后，先发送注册邮件，再发送验证短信；

在这种方式下，需要最终发送验证短信后再返回给客户端。
并行处理：新注册信息写入后，由发短信和发邮件并行处理； 

在这种方式下，发短信和发邮件 需处理完成后再返回给客户端。
假设以上三个子系统处理的时间均为，且不考虑网络延迟，则总的处理时间：

串行：=并行： = 

若使用消息队列：

并在写入消息队列后立即返回成功给客户端，则总的响应时间依赖于写入消息队列的时间，而写入消息队列的时间本身是可以很快的，基本可以忽略不计，因此总的处理时间相比串行提高了倍，相比并行提高了一倍；
 应用耦合
具体场景：用户使用相册上传一张图片，人脸识别系统会对该图片进行人脸识别，一般的做法是，服务器接收到图片后，图片上传系统立即调用人脸识别系统，调用完成后再返回成功，如下图所示：

该方法有如下缺点：

人脸识别系统被调失败，导致图片上传失败；
延迟高，需要人脸识别系统处理完成后，再返回给客户端，即使用户并不需要立即知道结果；
图片上传系统与人脸识别系统之间互相调用，需要做耦合；

若使用消息队列：

客户端上传图片后，图片上传系统将图片信息如、批次写入消息队列，直接返回成功；而人脸识别系统则定时从消息队列中取数据，完成对新增图片的识别。此时图片上传系统并不需要关心人脸识别系统是否对这些图片信息的处理、以及何时对这些图片信息进行处理。事实上，由于用户并不需要立即知道人脸识别结果，人脸识别系统可以选择不同的调度策略，按照闲时、忙时、正常时间，对队列中的图片信息进行处理。
 限流削峰
具体场景：购物网站开展秒杀活动，一般由于瞬时访问量过大，服务器接收过大，会导致流量暴增，相关系统无法处理请求甚至崩溃。而加入消息队列后，系统可以从消息队列中取数据，相当于消息队列做了一次缓冲。

该方法有如下优点： 

请求先入消息队列，而不是由业务处理系统直接处理，做了一次缓冲极大地减少了业务处理系统的压力； 
队列长度可以做限制，事实上，秒杀时，后入队列的用户无法秒杀到商品，这些请求可以直接被抛弃，返回活动已结束或商品已售完信息；

 消息驱动的系统
具体场景：用户新上传了一批照片， 人脸识别系统需要对这个用户的所有照片进行聚类，聚类完成后由对账系统重新生成用户的人脸索引加快查询。这三个子系统间由消息队列连接起来，前一个阶段的处理结果放入队列中，后一个阶段从队列中获取消息继续处理。

该方法有如下优点：

避免了直接调用下一个系统导致当前系统失败；
每个子系统对于消息的处理方式可以更为灵活，可以选择收到消息时就处理，可以选择定时处理，也可以划分时间段按不同处理速度处理；

三、消息队列的两种模式
消息队列包括两种模式，点对点模式  ， 和发布订阅模式，。
 点对点模式
点对点模式下包括三个角色：

消息队列
发送者 生产者
接收者消费者


消息发送者生产消息发送到中，然后消息接收者从中取出并且消费消息。消息被消费以后，中不再有存储，所以消息接收者不可能消费到已经被消费的消息。
点对点模式特点：

每个消息只有一个接收者即一旦被消费，消息就不再在消息队列中；
发送者和接收者间没有依赖性，发送者发送消息之后，不管有没有接收者在运行，都不会影响到发送者下次发送消息；
接收者在成功接收消息之后需向队列应答成功，以便消息队列删除当前接收的消息；

 发布订阅模式
发布订阅模式下包括三个角色：

角色主题
发布者
订阅者


发布者将消息发送到系统将这些消息传递给多个订阅者。
发布订阅模式特点：

每个消息可以有多个订阅者；
发布者和订阅者之间有时间上的依赖性。针对某个主题的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。
为了消费消息，订阅者需要提前订阅该角色主题，并保持在线运行；

四、常用消息队列介绍
本部分主要介绍四种常用的消息队列的主要特性、优点、缺点。
 
 年发布，是一个在高级消息队列协议基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。
主要特性：

可靠性 提供了多种技术可以让你在性能和可靠性之间进行权衡。这些技术包括持久性机制、投递确认、发布者证实和高可用性机制；
灵活的路由： 消息在到达队列前是通过交换机进行路由的。为典型的路由逻辑提供了多种内置交换机类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做的插件来使用；
消息集群：在相同局域网中的多个服务器可以聚合在一起，作为一个独立的逻辑代理来使用；
队列高可用：队列可以在集群中的机器上进行镜像，以确保在硬件问题下还保证消息安全；
多种协议的支持：支持多种消息队列协议；
服务器端用语言编写，支持只要是你能想到的所有编程语言；
管理界面 有一个易用的用户界面，使得用户可以监控和管理消息的许多方面；
跟踪机制：如果消息异常，提供消息跟踪机制，使用者可以找出发生了什么；
插件机制：提供了许多插件，来从多方面进行扩展，也可以编写自己的插件；

使用需要：

语言包
安装包

可以运行在语言所支持的平台之上：
       
优点：

由于语言的特性， 性能较好，高并发；
健壮、稳定、易用、跨平台、支持多种语言、文档齐全；
有消息确认机制和持久化机制，可靠性高；
高度可定制的路由；
管理界面较丰富，在互联网公司也有较大规模的应用；
社区活跃度高；

缺点：

尽管结合语言本身的并发优势，性能较好，但是不利于做二次开发和维护；
实现了代理架构，意味着消息在发送到客户端之前可以在中央节点上排队。此特性使得易于使用和部署，但是使得其运行速度较慢，因为中央节点增加了延迟，消息封装后也比较大；
需要学习比较复杂的接口和协议，学习和维护成本较高；

 
是由出品， 是一个完全支持和 规范的  实现。它非常快速，支持多种语言的客户端和协议，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。
主要特性：

服从  规范： 规范提供了良好的标准和保证，包括：同步或异步的消息分发，一次和仅一次的消息分发，消息接收和订阅等等。遵从  规范的好处在于，不论使用什么  实现提供者，这些基础特性都是可用的；
连接性： 提供了广泛的连接选项，支持的协议有：， 多播，，，，，等等。对众多协议的支持让  拥有了很好的灵活性。
支持的协议种类多：、、、、 ；
持久化插件和安全插件： 提供了多种持久化选择。而且， 的安全性也可以完全依据用户需求进行自定义鉴权和授权；
支持的客户端语言种类多：除了  之外，还有：，，，，，；
代理集群：多个  代理可以组成一个集群来提供服务；
异常简单的管理： 是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以监控  不同层面的数据，包括使用在  或者  的  中使用 ，通过处理  的告警消息，通过使用命令行脚本，甚至可以通过监控各种类型的日志。

使用需要：

 
安装包

可以运行在语言所支持的平台之上。
优点：

跨平台编写与平台无关有，几乎可以运行在任何的上
可以用：可以将数据持久化到数据库。虽然使用会降低的性能，但是数据库一直都是开发人员最熟悉的存储介质。将消息存到数据库，看得见摸得着。而且公司有专门的去对数据库进行调优，主从分离；
支持 ：支持的统一接口
支持自动重连；
有安全机制：支持基于，等多种安全配置机制，可以对进行认证和授权。
监控完善：拥有完善的监控，包括 ，，命令行，的 ；
界面友善：提供的 可以满足大部分情况，还有很多第三方的组件可以使用，如；缺点：

社区活跃度不及高；

根据其他用户反馈，会出莫名其妙的问题，会丢失消息；
目前重心放到产品，对的维护较少；
不适合用于上千个队列的应用场景；

 
出自 阿里公司的开源产品，用  语言实现，在设计时参考了 ，并做出了自己的一些改进，消息可靠性上比  更好。在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，分发等场景。
主要特性：

是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式特点；
、、队列都可以分布式；
向一些队列轮流发送消息，队列集合称为，如果做广播消费，则一个实例消费这个对应的所有队列，如果做集群消费，则多个实例平均消费这个对应的队列集合；
能够保证严格的消息顺序；
提供丰富的消息拉取模式；
高效的订阅者水平扩展能力；
实时的消息订阅机制；
亿级消息堆积能力；
较少的依赖；

使用需要：

 
安装、
安装包

可以运行在语言所支持的平台之上。
优点：

单机支持  万以上持久化队列
 的所有消息都是持久化的，先写入系统 ，然后刷盘，可以保证内存与磁盘都有一份数据，访问时，直接从内存读取。
模型简单，接口易用 的接口很多场合并不太实用；
性能非常好，可以大量堆积消息在中；
支持多种消费，包括集群消费、广播消费等。
各个环节分布式扩展设计，主从；
开发度较活跃，版本更新很快。

缺点：
支持的客户端语言不多，目前是及，其中不成熟；社区关注度及成熟度也不及前两者；没有管理界面，提供了一个命令行界面管理工具带来查询、管理和诊断各种问题；没有在  核心中去实现等接口；
 
 是一个分布式消息发布订阅系统。它最初由公司基于独特的设计实现为一个分布式的提交日志系统    ，，之后成为项目的一部分。系统快速、可扩展并且可持久化。它的分区特性，可复制和可容错都是其不错的特性。
主要特性：

快速持久化，可以在的系统开销下进行消息持久化；
高吞吐，在一台普通的服务器上既可以达到的吞吐速率； 
完全的分布式系统，、、都原生自动支持分布式，自动实现负载均衡；
支持同步和异步复制两种；
支持数据批量发送和拉取；
：减少操作步骤；
数据迁移、扩容对用户透明；
无需停机即可扩展机器；
其他特性：严格的消息顺序、丰富的消息拉取模型、高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制；

使用需要：

 
安装包

优点：

客户端语言丰富，支持、、、、、等多种语言；
性能卓越，单机写入约在百万条秒，消息大小个字节；
提供完全分布式架构 并有机制 拥有较高的可用性和可靠性 理论上支持消息无限堆积；
支持批量操作；
消费者采用方式获取消息 消息有序 通过控制能够保证所有消息被消费且仅被消费一次
有优秀的第三方 管理界面；
在日志领域比较成熟，被多家公司和多个开源项目使用；

缺点：

单机超过个队列分区，会发生明显的飙高现象，队列越多，越高，发送消息响应时间变长
使用短轮询方式，实时性取决于轮询间隔时间；
消费失败不支持重试；
支持消息顺序，但是一台代理宕机后，就会产生消息乱序；
社区更新较慢；

 对比
这里列举了上述四种消息队列的差异对比：

结论
在于分布式架构，基于协议来实现，思路来源于，改成了主从结构，在事务性可靠性方面做了优化。广泛来说，电商、金融等对事务性要求很高的，可以考虑和，对性能要求高的可考虑。
五、参考资料：
 消息队列：

大型网站架构之分布式消息队列 
消息队列的使用场景 
浅谈异步消息队列模型 
消息队列的两种模式 

 

主页 
学习教程 
专栏从入门到精通 
能为你做些什么 
指南特性及功能 

 

主页 
 介绍 
的简介与安装 
 和消息简介 

 

主页 
 原理简介 _
与对比项差异 

 
主页：  

特性  
客户端支持语言 

 对比

，队列选型 
和 
即时通信二性能测试 
、、、之间的比较资料汇总 
消息队列软件产品大比拼 

总结：
消息队列利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。目前业界有很多的产品，例如、、、、、等，也有直接使用数据库充当消息队列的案例。而这些消息队列产品，各有侧重，在实际选型时，需要结合自身需求及产品特征，综合考虑。艾瑞咨询近日发布的《 年中国在线旅游度假市场研究报告》显示， 年中国在线旅游度假市场规模达  亿元，较  年增长 ，市场前景广大。互联网 时代的到来倒逼旅游行业转型升级，旅游平台通过用户的交互信息，进行数据分析，从购买需求、产品体验、反馈分享等多方面影响客户，为互联网旅游提供智能服务。
业内人士指出，当前，旅游业变得更加依赖技术：无论是上升拥抱云端、大数据、大平台，还是深度下沉，根扎 ，抢占资源端，技术正在成为互联网旅游发展的关键。去哪儿网就是最典型的例子，从  年  月上市至今，已占据旅游业市场前三的份额，这其中技术的应用功不可没。去哪儿网总裁张强在做客腾讯云会客厅，接受腾讯云副总裁曾佳欣采访时，围绕技术和互联网旅游的话题展开了精彩对话。

技术性地推，抢占市场的基石
 年，去哪网通过地推的方式下沉三四线城市，与低星级酒店签约合作，希望加速抢占三四线市场。张强认为，地推需要依靠成熟完善的计算，而不是人海战术。所以团队根据内部的数据、系统，为每一位销售人员匹配了  系统，提供需求、任务和解决方案，这套系统令这个千人团队有章可循，业务效率大幅提升。
其次就是招聘工程师，实现酒店预订高度自动化。酒店从预订到成功入住有一个流程，要确保酒店有房才能销售给消费者，在线旅游跑马圈地的进程中，自动化为去哪儿网的竞争提供了不可撼动的技术基础，这也是张强所强烈认同的。
技术性地推战略的决定对于去哪儿来说，毋庸置疑是最正确的，奠定了成功转型的基础。互联网是工具，从物流加互联网，再到整个云端，再到实体，交互融合。对去哪儿网来说，大数据、云计算不仅是站稳市场的基石，同时也是未来发展的一板斧。张强这样说到。
 左：腾讯云副总裁曾佳欣  右：去哪儿网总裁张强
以技术为驱动力，打造在线旅游服务闭环
作为一家以技术为驱动力的在线旅游服务公司，去哪儿网创立的初衷，是希望改变旅游的既有形式，通过技术的力量，让消费者找到与自身契合的旅游产品；同时利用技术重新整合和匹配全产业链信息，缩短产业链条，提高服务效率，从而推动整个行业的在线化进程。
去哪儿网在  年  月推出了大数据预测类机票产品智惠飞，为用户提供更精准的在线购票和预定服务；推出了再出发系统，是在线旅游交易系统的再升级，其包含库存管理系统、订单管理系统、 系统和分销系统，能够帮助代理商减少运营成本，提高生产力，完成业务闭环。
目前，去哪儿网的流处理流水线每天需要处理的业务日志量大约  亿条，总计约  的数据量。其中许多任务都需要保证在稳定的低延时情况下工作，快速迭代计算出结果并反馈到线上业务系统中。因此利用大数据处理保证数据的可靠性以及低延时，对去哪儿网系统开发和运维来说十分重要。
张强强调：云计算、大数据代表着未来，一个公司云计算能力的高低很大程度上决定着技术水平的高低。去哪儿网的未来，要做聪明你的旅行。他认为，未来的旅游，将借助云计算的力量延展增值体验，为用户提供新闻资讯、出租车送机、特色美食、周边游、生活等方方面面的服务，旅游将会在这里形成一个闭环。
【栏目介绍】：在互联网时代下，云计算正被越来越多的行业和企业认可。《腾讯云会客厅》作为云计算行业首档高端人物对话栏目，是由腾讯云副总裁曾佳欣亲自主持，在分享云在各领域最佳实践的同时，也邀请到众多创投界资深人士和明星，分享云端创投经验，从资本、技术、渠道、服务等方面，打通整个产业链，构建云端创业生态。作者 | 刘琰编辑 | 迷鹿

刘琰，现就职于腾讯网络媒体产品技术部基础平台组，运营开发岗位，目前主要参与存储集群平台的开发工作。

一、常用数据结构
做容量评估之前，有必要对常用数据结构有大概了解。
、
没有直接使用语言传统的字符串以空字符为结尾的字符数组，而是自己创建了一种名为简单动态字符串的抽象类型，用作默认的字符串。
的定义如下：
  {
               记录数组中已使用字节的数量
              记录数组中未使用字节的数量
            字节数组，用于保存实际字符串
}
下图展示了一个实例：

图 示例图
图的实例中存储了字符串“”， 中对应的长度为，长度为， 占用的总字节数为         = 。
、链表
链表在中的应用非常广泛，列表键的底层实现之一就是链表。每个链表节点使用一个结构来表示，具体定义如下：
   {
                     前置节点
                     后置节点
                              节点的值
} 
另外还使用了结构来管理链表，以方便操作，具体定义如下：
   {
                                   表头节点
                                   表尾结点
                           节点值复制函数
                           节点值释放函数
                  节点值对比函数
                                  链表所包含的节点数量
} 
结构占用的总字节数为，结构占用的总字节数为。
、跳跃表
采用跳跃表作为有序集合键的底层实现之一，跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。
跳跃表由和两个结构定义，结构具体定义如下：
   {
                                       成员对象
                                    成员对象分值
                   后退指针
                            节点层
    {
                    前进指针
                                跨度
    } 
} 
跳跃表可以理解为多层的有序双向链表，结构用于表示跳跃表节点，属性和属性分别表示具体的值对象和对应的排序分值，属性和属性分别表示后退和前进指针，和普通链表不同，前进指针可以直接指向后续第个节点，两个节点之间的距离用属性表示。
每个跳跃表节点的数组大小不定，当节点新生成时，程序都会根据幂次定律 ，越大的数出现的概率越小随机生成一个介于和之间的值作为数组的大小。结构占用的总字节数为  ，为数组的大小。
结构具体定义如下：
   {
              表头节点和表尾结点
                            表中节点的数量
                                      表中层数最大的节点的层数
} 
结构则用于保存跳跃表节点的相关信息，和分别指向跳跃表的表头和表尾节点，记录节点总数量，记录跳跃表中层高最大的那个节点的层数量。结构占用的总字节数为。
下图展示了一个跳跃表示例：

图 跳跃表示例图
位于图片最左边的是结构，位于结构右边的是四个结构，指向跳跃表的表头节点，表头节点和其他节点的构造是一样的，但后退指针、分值、成员对象这些属性都不会被用到，所以被省略，只显示其各个层。
、字典
字典在中的应用很广泛，的数据库就是使用字典作为底层实现的，具体数据结构定义如下：
   {
            字典类型
            私有数据
              哈希表数组
             索引，当不进行时，值为
             当前该字典迭代器个数
} 
属性和属性是为了针对不同类型的键值对而设置的，此处了解即可。中还保存了一个长度为的哈希表数组，哈希表负责保存具体的键值对，一般情况下字典只使用哈希表，只有在时才使用。结构占用的总节数为。
字典所使用的哈希表结构定义如下：
   {
              哈希表节点数组
              哈希表大小
          哈希表大小掩码，用于计算索引值，总是等于
              该哈希表已有节点的数量
} 
属性是一个数组，数组中每个元素都是一个指向结构的指针，每个结构就是一个哈希表节点，保存一个具体的键值对。记录了哈希表总大小，记录了哈希表已有节点的数量，值总是等于 ，它和哈希值一起决定每个键的索引。结构占用的总节数为。
哈希节点使用结构表示，具体定义如下：
   {
     
     
      
} 
的哈希表采用链地址法来解决哈希冲突问题，多个哈希值相同的键值对通过链表连接在一起。结构占用的总字节数为。
字典的整体结构关系如下图所示：

图 字典整体结构关系图
随着哈希表保存的键值对逐渐增多，哈希表中每个桶的冲突链会越来越长，为了让哈希表的负载因子维持在一个合理范围，会自动通过的方式扩展哈希表。
的过程大概就是先为分配对应的空间，然后将中的所有节点转移到中，最后再释放所占用的空间。后新生成的节点数组大小等于超过当前个数向上求整的的次方，比如当前个数为，则新生成的节点数组大小就是。
、对象
前面介绍了的常用数据结构，但大多数情况下并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，每个对象都包含了一种具体数据结构。比如，当数据库新创建一个键值对时，就需要创建一个值对象，值对象的属性指向具体的字符串。
每个对象都由一个结构表示，具体定义如下：
   {
               对象类型
            __  __
           对象所使用的编码
                   
                  对象的引用计数
                     指向对象的底层实现数据结构
} 
具体属性此处不再详细描述，只需知道结构占用的总字节数为。
二、内存分配规则
是一种通用的内存管理方法，着重于减少内存碎片和支持可伸缩的并发性，我们部门的版本中就引入了，做容量评估前必须对的内存分配规则有一定了解。
基于申请内存的大小把内存分配分为三个等级：，，：

  的以字节，字节，字节等分隔开，小于页大小；

  的以分页为单位，等差间隔排列，小于的大小；

  的大小是大小的整数倍。


对于位系统，一般大小为，页大小为，内存分配的具体规则如下：

三、容量评估
容量评估模型根据类型而有所不同。
、
一个简单的命令最终会产生个消耗内存的结构，中间掉的不考虑：

个结构，字节，负责保存具体的键值对；

个结构，字节，用作对象；

个结构，长度  字节，用作字符串；

个结构，长度  字节，用作字符串；


当个数逐渐增多，还会以的方式扩展哈希表节点数组，即增大哈希表的个数，每个元素都是个指针，占字节，个数是超过个数向上求整的的次方。
真实情况下，每个结构最终真正占用的内存还要考虑的内存分配规则，综上所述，类型的容量评估模型为：
总内存消耗 = 大小  大小 _大小  _大小×个数  个数 ×指针大小
测试验证
类型容量评估测试脚本如下：


_=`     | _|  {  }`
     _

=  

          __ __  
     


_=`     | _|  {  }`
     _

 =__
   
测试用例中，长度为 ，长度为，个数为，根据上面总结的容量评估模型，容量预估值为 ×        ×  = 
运行测试脚本，得到结果如下：

结果都是，说明模型预估的十分精确。
、
哈希对象的底层实现数据结构可能是或者，当同时满足下面这两个条件时，哈希对象使用这种结构此处列出的条件都是默认配置，可以更改：

哈希对象保存的所有键值对的键和值的字符串长度都小于字节；

哈希对象保存的键值对的数量都小于个；


可以看出，业务侧真实使用场景基本都不能满足这两个条件，所以哈希类型大部分都是结构，因此本篇文章只讲，对结构感兴趣的同学可以私下咨询我。
与类型不同的是，类型的值对象并不是指向一个结构，而是指向又一个结构，结构保存了哈希对象具体的键值对，类型结构关系如图所示：

 图 类型结构关系图
一个命令最终会产生以下几个消耗内存的结构：

个结构，字节，负责保存当前的哈希对象；

个结构，长度  字节，用作字符串；

个结构，字节，指向当前下属的结构；

个结构，字节，负责保存哈希对象的键值对；

个结构，×字节，负责保存具体的和，等于个数；

个结构，×字节，用作对象；

个结构，×字节，用作对象；

个结构，长度  × 字节，用作字符串；

个结构，长度  × 字节，用作字符串；


因为类型内部有两个结构，所以最终会有产生两种，一种基准是个数，另一种基准是个数，结合内存分配规则，类型的容量评估模型为：
总内存消耗 = 大小 × _大小  _大小  大小× 个数  _个数× 指针大小  大小  大小 _大小  大小  × 个数  _个数×指针大小
测试验证
类型容量评估测试脚本如下：


_=___

_=`     | _|  {  }`
     _

=  

    =  
    
              __ __ _  
    
     


_=`     | _|  {  }`
     _

 =__
   
测试用例中，长度为 ，长度为，长度为，个数为，个数为，根据上面总结的容量评估模型，容量预估值为        ×  ×         ×   ×  = 
运行测试脚本，得到结果如下：

结果相差，说明模型预测比较准确。
、
同哈希对象类似，有序集合对象的底层实现数据结构也分两种：或者，当同时满足下面这两个条件时，有序集合对象使用这种结构此处列出的条件都是默认配置，可以更改：

有序集合对象保存的元素数量小于个；

有序集合保存的所有元素成员的长度都小于字节；


业务侧真实使用时基本都不能同时满足这两个条件，因此这里只讲结构的情况。类型的值对象指向一个结构，结构同时包含一个字典和一个跳跃表，占用的总字节数为，具体定义如下：
   {
     
     
} 
跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素，字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素，这两种数据结构会通过指针来共享相同元素的成员和分值，没有浪费额外的内存。类型的结构关系如图所示：

图 类型结构关系图
一个命令最终会产生以下几个消耗内存的结构：

个结构，字节，负责保存当前的有序集合对象；

个结构，长度  字节，用作字符串；

个结构，字节，指向当前下属的结构；

个结构，字节，负责保存下属的和结构；

个结构，字节，负责保存集合元素中成员到分值的映射；

个结构，×字节，负责保存具体的成员和分值，等于集合成员个数；

个结构，字节，负责保存跳跃表的相关信息；

个层的结构，×=字节，用作跳跃表头结点；

个结构，××字节，用作跳跃表节点，等于节点层数；

个结构，×字节，用作集合中的成员对象；

个结构，长度  ×字节，用作成员字符串；


因为每个节点的层数都是根据幂次定律随机生成的，而容量评估需要确切值，因此这里采用概率中的期望值来代替单个节点的大小，结合内存分配规则，经计算，单个节点大小的期望值为。
类型内部同样包含两个结构，所以最终会有产生两种，一种基准是成员个数，另一种基准是个数，类型的容量评估模型为：
总内存消耗 = _大小  大小  大小  大小×个数 _个数 ×指针大小  层大小  大小  大小  大小  大小  _大小  大小  ×个数 _个数 × 指针大小
测试验证
类型容量评估测试脚本如下：


_=___

_=`     | _|  {  }`
     _

=  

    =  
    
              __  _  
    
     


_=`     | _|  {  }`
     _

 =__
   
测试用例中，长度为 ，长度为，个数为，个数为，根据上面总结的容量评估模型，容量预估值为      ×  ×                ×   ×  = 
运行测试脚本，得到结果如下：

结果相差，说明模型预测比较准确。
、
列表对象的底层实现数据结构同样分两种：或者，当同时满足下面这两个条件时，列表对象使用这种结构此处列出的条件都是默认配置，可以更改：

列表对象保存的所有字符串元素的长度都小于字节；

列表对象保存的元素数量小于个；


因为实际使用情况，这里同样只讲结构。类型的值对象指向一个结构，具体结构关系如图所示：
 
图 类型结构关系图
一个或者命令最终会产生以下几个消耗内存的结构：

个结构，字节，负责保存当前的列表对象；

个结构，长度  字节，用作字符串；

个结构，字节，指向当前下属的结构；

个结构，字节，负责管理链表节点；

个结构，×字节，等于个数；

个结构，×字节，用作链表中的值对象；

个结构，长度  ×字节，用作值对象指向的字符串；


类型内部只有一个结构，基准为个数，综上，类型的容量评估模型为：
总内存消耗 = _大小  大小  大小× 个数  大小   大小  _大小  大小  × 个数  _个数 × 指针大小
测试验证
类型容量评估测试脚本如下：


_=___

_=`     | _|  {  }`
     _

=  

    =  
    
              __ _  
    
     


_=`     | _|  {  }`
     _

 =__
   
测试用例中，长度为 ，长度为，个数为，个数为，根据上面总结的容量评估模型，容量预估值为     ×           ×     × = 
运行测试脚本，得到结果如下：

结果都是，说明模型预估的十分精确。

相关推荐
设计思路学习与总结新变种简介
据爆料，乌克兰政府机构遭大规模攻击，其中乌克兰副总理的电脑均遭受攻击，目前腾讯电脑管家已经确认该病毒为勒索病毒变种。
勒索病毒变种中毒后会扫描内网的机器，通过永恒之蓝漏洞自传播到内网的机器，也通过渗透攻击获取内网域管理员账号密码信息，或者远程命令执行，达到快速传播的目的。有国外安全研究人员认为，勒索病毒变种会通过邮箱附件传播，利用携带漏洞的文档进行攻击。中毒后，病毒会修改系统的引导扇区，当电脑重启时，病毒代码会在操作系统之前接管电脑，执行加密等恶意操作。电脑重启后，会显示一个伪装的界面，此界面实际上是病毒显示的，界面上假称正在进行磁盘扫描，实际上正在对磁盘数据进行加密操作。

当加密完成后，病毒要求受害者支付价值美元的比特币之后，才会回复解密密钥。

传播渠道分析
可能传播渠道邮箱传播
根据乌克兰官方消息，邮件附件被认为该次病毒攻击的传播源头，邮箱附件是一个文档，文档通过漏洞来触发攻击，电脑管家也溯源到了国内类似邮件攻击最早发生在月日早上。在实际测试过程中，并没有完整重现整个攻击过程。
 
 
可能传播渠道
很多安全研究机构认为，这次的攻击源是由于软件的更新服务被劫持导致。
详细功能分析
感染过程分析
，写

扇区保存的是病毒的和微内核代码数据，而原始的被加密保存在第扇区。
，加密文件
遍历分区

要加密的文件类型

文件加密过程

，    传播方式
获取需扫描的地址

依次获取当前活动连接对应地址、缓存中存有的地址，以及枚举内网服务器。
获取本地密码
文件中自带融合了功能的资源，在运行过程中，会释放出解密后的资源，对比与解密后的资源文件如下：

可以获取登陆过的账号密码，甚至域管理员账户信息。拿到域管理员账户信息后，即可以完成后续写文件、远程命令执行等操作。
将自身复制到内网其他机器的共享目录。

远程命令执行

 \\\\ _      \\\ \\\\ 
远程命令执行

 其实就是，用于远程执行命令。需要对方开启共享，而且需要安装服务。
 \\ \\    \\\ \\
    攻击永恒之蓝

根据系统版本选择不同的：

有和两个版本。该主要，调起一个去执行一些任务。
 
磁盘加密和勒索细节
主要功能描述：
、系统重启，恶意加载；、检测磁盘是否被加密，如果没有则显示伪造的检测磁盘界面、并加密；、显示红色的勒索界面，让用户输入秘钥；
细节分析：
启动后，将扇区数据复制到地址处，然后执行地址代码

通过读取标记位判断磁盘已经被加密

若磁盘没有加密，则显示伪造的检测磁盘界面，并加密

加密完成后，读取扇区后面的勒索语句
 
将获取到的语句显示到屏幕上

从屏幕获取秘钥并验证

安全建议
，    及时下载安装腾讯电脑管家，并使用勒索病毒免疫工具，防患于未然。免疫工具下载地址____，    及时使用电脑管家将补丁打全。，    遇到可疑文件，特别是陌生邮件中的附件，不要轻易打开，首先使用电脑管家进行扫描，或上传至哈勃分析系统 对文件进行安全性检测。
参考资料
                    互联网开发的核心问题
当我年进入互联网行业工作的时候，华为刚刚通过了著名的认证。当时作为一个小程序员，非常向往业界经典的软件开发模式。因为看上去，如果企业实行了，我们程序员就不用再天天为了老板一个拍脑袋的主意而加班开发了，各种各样的奇葩需求和无理变更，也会烟消云散。但是，在接下来的十几年，几乎没有那个互联网公司再去通过认证。
是否这种软件开发模式，就根本不适合互联网行业呢？这是一直以来我都在思考的问题。反而是跟随着互联网企业的一步步长大，我无意识的体验了很多现在流行概念的早期实践：敏捷、重构、持续集成、，这些实践一开始都非常的幼稚粗糙，但是却真正的伴随着互联网业务的逐步成长。所以，在讨论互联网服务的开发模式时，我认为必须要先搞清楚互联网服务开发的核心问题是什么。

本质：服务，而不是产品
软件到底是“服务”还是“产品”，这个话题一直都非常具有争议。作为程序开发者，实际上是非常希望软件能够是一个产品，因为软件的后续维护和修改，往往是“导致”项目失败的最常见原因。然而事与愿违的是，在互联网企业中，打多数的软件项目，表现出来的是典型的“服务”特征：

没有明确的需求合同。这导致了没有办法为软件设计固定的开发方案，也难以确定长期目标。

没有预付款和客户验收。互联网服务用户来了就用，爽了就给钱，不爽了就走，连沟通的机会都不会有。

甚至连明显的销售环节都没有。很多互联网公司只有市场推广部门，而没有所谓“销售”部门，因为推广就几乎等于销售，在推广的同事，就必须把销售的事情一起做了。


因此，在互联网行业中，软件开发更多的是以一种服务的形式存在。这种特征，在对需求的分析管理；开发技术的选择；集成与测试；运营和客服四个方面，都导致了不同于“产品”型软件的巨大差异

对于一项服务来说，需求是持续变化的，你可以找到一些通用的模式，但是必须保持变化。

开发效率是第一重要的，因为市场竞争中，应对需求变化快的单位将获得更多的客户。


由于服务必须保持长期的稳定可用，又要具备快速的更新部署能力，所以系统集成的效率和质量要求非常高。所幸的是系统运行的环境大多数都是在可控制的空间里比如开发公司自己的机房内。
服务是公司和客户的一种持续沟通和交互的过程，并非一个单向的发售行为，所以互联网服务需要更多细致的运营和维护的工具，否则难以做到迅速而细致的满足海量的互联网用户的需求。

小米的开发节奏
管理：手段工具
在各种项目管理的课程里面，陈述了大量针对人去工作的方法。各种会议、报告、表格、评估、测量多不胜数，然而软件项目进度的控制，依然是一个难度堪比登月的事情。——对于很多项目经理来说，程序员们基本是一个黑盒子，他们自己都不知道一个事情需要多长时间干完，就更别提别人怎么去预估和控制。这里最大的问题，我觉得是：我们往往总是想着怎样“控制”住软件项目的进度，而忽视了如何减少不利于项目进度的因数。实际上影响软件开发进度的主要因数，一般有一下几个：

程序员的能力水平。有一些项目其中的技术，是程序员完全没接触过的类型，这里包含了学习、调试的时间。

开发过程中的各种修改变更。由于对可行性、需求确认等方面的因数，开发往往会走“回头路”。有些项目做到一般会发现技术上不可行，需要修改需求；而另外一些项目是在项目做到一半甚至快完成的时候，需求方发现需要修改产品设计，因为在产品可体验之前，完全无法想象到最后会是现在的样子。

各种和开发无关的过程中的事务。这里包括开会、写报告、沟通、等待开发电脑编译、处理开发服务器故障、各种开发环境和测试环境的问题处理等等……这些事情往往都看起来不是非常“有技术含量”，但是实际上会严重影响开发进度。因为开发工作需要一个稳定、专心的工作环境，频频的被各种事务打断，会让程序员反复的花费时间去“进入”工作状态——面对成千上万行程序代码，要找到之前写到哪个部分，其实不是那么简单。


针对上面说的几个问题，很多都可以通过应用更好的开发工具来解决。比如一些新的需求类型，我们可以求助于互联网上丰富的开源软件和开源库；面对需求变更，我们可以使用设计模式、单元测试等工具；开发中的事务问题，更是可以有大量业界先进工具可用：……

与其我们拿着鞭子抽打程序员，还不如给程序员更好的开发工具，这样对于项目进度的推动，其实更有好处。
资产：代码流程
互联网公司是由人组成的，人是会流动的，有一些小型的公司，往往会因为一两个核心员工的离职，造成整个系统的代码无法看懂，无法修改，从而最后导致公司完蛋。这种糟糕的情况，不止一次的出现过。然而，如果我们能有一套完善的开发流程，或者是习惯，以及配合良好的开发环境，加上有一定质量的代码，是完全能做到把项目代码，在不同程序员之间顺利交接的。可惜我们很多公司管理者，并不重视程序员用什么工具开发软件，也不知道如何去提高代码的可读性，所以造成我们的项目特别害怕人员变动。如果我们把人员变动看成是一个必然会发生的事情，那么我们就会更重视整个代码的开发环境和开发过程，从一开始就把开发规范确定下来，规定使用什么环境，应用何种工具，并且坚持执行，同时在实践过程中不断的改进。只有这样有预备的去做，最后才会保留的住公司真正的资产。

一家互联网公司，我们在评估其开发资产的时候，并不应看他“拥有”多少行代码，因为这些代码是无法直接卖钱的。而互联网公司的开发速度，以及这个速度背后的能力才是最重要的。
敏捷开发的意义和实践
敏捷开发是我们现在最常见的一个“开发模式”，然而很多时候，我们看到“敏捷”两个字，似乎就是让程序员多加点班，或者忽略一些过程加快把代码弄出来，而真正理解“敏捷”含义的并不多。实际上，敏捷并不会加快单位代码的开发速度！敏捷最主要的目标，是应对需求不明确和需求变更，而这两者正式互联网服务中最常见的情况。

需求变更的原因
在互联网服务中，由于没有直接的“客户”下单要求，所以很多需求，都是由公司内部的人“代表”的，最典型的就是我们的“老板”们了。正式因为没有明确的“下订单”的过程，所以很多传统的需求分析变得没法做了，因为不管是老板还是产品经理，都是面对着成千上万的客户去猜测他们的需求，如果他们自己能代表客户还好，如果猜错了，项目的代码肯定要修改。很多互联网公司都非常重视“数据”，原因就是这些“数据”往往代表了用户对产品的看法，而这些看法成了互联网产品设计的唯一客观标准。然而这些数据本身，会包含了大量复杂性，由于统计方式、产品形态、季节时间等等，都会产生偏差。我们的项目需求，往往就是在这些偏差中确定。这就难免产生需求的变更了。
互联网的客户个体多，服务内容丰富，功能变化快，是互联网项目中需求变更很多的主要原因。因此这也让敏捷开发，成为互联网项目开发中最重要的方法。——敏捷强调的是用原型来验证需求，在互联网服务里就是，尽快推出服务，通过数据来验证想法。如果我们能越频繁的修正原型，就能越快的接近真正的需求，也就是说，如果我们的互联网服务能越快的修正各种问题，同时越快的推出新的版本，就能让用户越牢固的“黏在”这个服务上。
架构设计实体化：单元测试

敏捷开发讲究要快速的修改代码，我们往往会发现，代码修改的越频繁，越多，这似乎是一个无法解决的矛盾。然而，在敏捷开发方法论中，有一个重要的措施，就是用来防止这种修改造成的增加的。这就是——单元测试。 单元测试本质上，充当着自动的人员的角色，如果我们把所有的设计和需求，都先按单元测试的形式“固化”编写下来，那么我们在修改代码后，就能快速的、自动的、反复的去验证我们的代码有没有问题。如果这些测试足够全面和详细，那么我们是不会担心代码修改导致大量的的，因为单元测试会自动帮我们支出问题所在。一旦我们知道了问题，修正起来反而变成是最简单的事情了。
假如一个项目的代码丢失了，但全面的单元测试都还在，那么要重建这个项目并不困难，因为所有的需求，都被蕴含在这些测试代码中，程序员们几乎不需要去重新啃文档，谈需求，他们只要把代码弄成能通过单元测试就好了。这种需求的“代表物”不但是程序员开发的概念和目标，而且还可以自动的帮程序员去验证他们的实现。所以，如果你要使用敏捷开发，要尝试频繁修改原型，就一定要使用测试驱动开发，特别是高度重视单元测试的作用。
统一软件设计思路的重要性
曾几何时，我们认为，使用什么语言开发，用结构化编程，还是面向对象编程……这些一般人难以深入理解的事情，都是程序员这伙顽固的家伙的怪癖，基本属于私人喜好的范畴。外人既不应该深入干预，也没办法去影响，因为如果你不识好歹去在这些事情上冒犯程序员，他们随时可能一言不合就辞职。既然我们只需要可以运行的代码，我们为什么冒风险去激怒程序员呢？然而，在互联网服务的开发过程中，代码本身并不是某一个固定的、静态的东西，它需要不断的与时俱进，需要跟随这业务的发展而变化，同时也会从某一个程序员手里，流向整个开发团队。在这种情况下，软件开发习惯、代码的风格、程序的设计思路，就变成一个非常重要的事情了。
代码交流：面向对象

确实现在还存在大量的讨论，说“面向对象不是万能的”。说得对，但是，世界上有什么东西是万能的呢？我只能说，在需求变更非常快的情况下，面向对象思想，是现在我们能选择的最好工具了。在“数据结构算法=程序”的时代，软件主要是以计算任务为主，电脑是为了代替人脑进行超乎想像的运算任务而存在。而在互联网时代，软件主要的任务已经变成了处理这个真实世界的信息了。信息的存储、交换的任务，已经远远超过了“计算”的任务数量。虽然我们知道，所谓的信息处理，最底层还是依赖大量的“计算”，然而，我们的程序员们，早已不再需要编写大量“计算”的代码，我们面临的挑战，是如何用代码准确而快速的表达这个世界。
面向对象思想包括分析、设计、编码三个部分。这些思想看起来繁文缛节，似乎非常啰嗦。然而，其核心思想却非常简单：从表达过程，转向表达对象。人类的思维中，对象、或物体，是一个个具备自己的信息特征的个体，而行为和过程，往往是依附于这些个体的。比如鸟会飞、账号会锁定、汽车会死火等等。所以如果我们的代码，是以表达对象，把信息和行为统一起来，是最接近于我们的认识规律的。
在互联网开发领域，由于网络无处不在，涉及到的领域异常广泛，如果我们没有一个能把代码世界和现实世界联系的纽带，我们的项目将非常难以理解。——难以理解的项目，就难以变化，从而就失去了互联网最显著的特征。所以我认为，面向对象的思想，是每一个互联网开发人员都应该理解的，并且应该是面对大部分业务时，首先考虑选择的。
代码架构与重构
我见过无数的代码架构图，里面画满了进程和服务器的拓扑，各种线条上标注了通讯协议，编码格式，还有各种流程图和协作图，然而，这些架构设计，无一例外的对于需求变更毫无帮助。因为它们描述的是一种现状，甚至连现状都不是，只是一种猜测，一种关于现状的猜测。随着项目代码的不断变化，代码数量和关系都会膨胀，这种进程、通讯级别的结构，除了越来越复杂以外，根本对于指导项目如何应对各种“代码腐化”毫无用处。
因此我们想到了流行的“重构”，然而，如果我们只是重构进程的关系，通信的层次，那些错综复杂的代码调用关系一样存在。各种回调、事件、耦合还是让代码无法理解。我们只是在试图把混乱塞到一些瓶子里面，并没有解决混乱本身。所以，我们需要的另外一个思想武器：代码结构。只有我们从另外一个角度，另外一个视图去观察代码，才能把握代码之间耦合的情况。正如建筑里的平面图和立面图，都是不可或缺的。

所以我们应该高度重视“代码架构”，也就是描述代码之间的关系的架构，而不是进程之间的关系的架构。在关注代码互相调用、耦合的关系上，我们能把混乱复杂的代码关系理清，整理出一个便于理解，便于修改的代码外观。这些工作看起来完全是针对开发人员的，但是实际上，这些工作是能提高整个开发效率的。它能让代码从难以修改，变得容易修改，从而得以支持快速的业务需求变化，这是对业务、对产品最重要的支持能力。
持续集成的意义和实践
不管是敏捷开发的快速迭代，还是重构系统，我们都将频繁的编译代码、部署、测试，也就是所谓的集成。如果我们的系统集成效率太低，那么快速的迭代可能变成慢速的迭代，重构系统的频率也会大大降低。有一些项目，每一次集成，都要最少经历两三个小时，如果不顺利的话，搞一个通宵都未必能完成。“发版本”是很多程序员和运维管理人员的常见加班原因。对于这个问题，很多小型公司开始的时候，并没有给与足够的重视，认为这些事情不过是程序员或者运维的本分工作之一，也是最日常的工作。真正得到出问题了，才发现重要性。
在任何一个互联网应用业务中，我们都会需要“发版”：出新功能、修改、启动运营活动、甚至是机房搬迁。所有的这些，如果没有一套合适的工具来保障，每次发版都会是一场噩梦。所以持续集成，很自然的成为互联网企业中最流行的、研究最广泛的技术之一。
所有资产纳入版本管理
持续集成的所有东西，都应该来源于版本管理系统。除此之外，软件资产不应该存放在任何其他地方。版本管理系统应该是开发团队的保险箱和金库，除了代码以外，所有的数据文件，配置，脚本，文档，都应该放入这个保险库。由于版本管理系统可以追溯到任何一个是时间点，这可以让故障恢复，问题回溯有良好的支持。

关于源代码使用版本管理系统，已经有很长历史了。但是互联网服务中，除了代码，还有很多其他的资源，比如图片、数据、脚本等等。除了产品项目外，我们的很多额外系统，比如运维工具、产品文档等等，都是需要妥善保管的，这些也都应该存放到版本管理系统中。
一般现在的版本管理系统，都有“分支”的功能，简单来说就是类似于“拷贝”了一份新的资源出来，在这之上的修改，可以由我们选择合并到其他分支或者放弃。所以的常用方案，是启动三个类型的分支：，专门针对“测试”、“开发”、“运营”。如果我们按预定的分支模型来设计版本管理系统的使用，那么我们的持续集成就可以很细致的选择集成哪一个版本的内容。
而在里面，每个使用者，都可以拥有自己的资源库，这对于开发测试可以更加的灵活，但是对于使用者的要求更高一些：在不同的资源库合并的过程中，需要更好的版本管理策略。持续集成系统可以自己拥有一个或者多个资源库，这样他们可以完全脱离版本管理服务器来独立运行。
自动化部署
我们曾经无数次的登录服务器，无数次的拷贝文件，无数次的修改配置，无数次的导入数据到数据库，无数次的……如果我们对这些重复，而且容易出错的工作熟视无睹，我们将永远的被这些本该机器去做的事情困住。自动化部署，是整个持续集成工作中最重要的步骤。当我们每次发版都要很仔细的修改很多文件的时候，我们是无法避免在某次倒霉的事故后被挨批的。只有我们能把部署工作，也用我们的开发能力去解决，编写自动部署工具之后，我们才真正的能提升部署这个事情到一个新的台阶————我们终于可不再担心发版。

和自动化测试一样，自动部署脚本，也是把一系列的技术需求，从纸面文档人手处理，改成用代码实体化，并且可积累改善的方法。自动化部署工具在开源界也非常热门，比如，还有等等，都是为了解决部署问题而发明的软件工具。也许对于你来说，自己用开发一套脚本才是合乎你的品味，但是不管怎样，一定要有这样的工具。就算要花费较长的开发时间，调动项目开发的程序员，一起来认真的开发一段时间自动部署功能，都是非常值得的。因为从今以后，你就可以拥有一个自己的部署系统，这个系统不但可以积累你的运营部署经验，还能加入很多错误、故障的自动检查，让你不再需要导出找“永远不出错的”运维人员。
自动化部署系统中，最核心的部分就是配置管理。拥有一个对现有环境资源集中管理的数据仓库是非常重要的。如果每个你的脚本可以识别自己所在的环境，以主动的方式去“申请”自己的配置文件和安装任务，是非常好的一个模式。因为从一个节点主动去分发程序，比不上多个节点向中心集群请求部署任务，来的更容易稳定。因为在节点上的部署代理程序，能更准确的知道自己环境的情况，也可以做本地的测试。
自动化集成测试
前面曾经说过，敏捷开发非常依赖于自动化的单元测试。实际上持续集成，也非常依赖于自动化的集成测试。集成测试可以把自动化部署的结果进行检验，避免手工进行反复验证。如果只有自动化部署，而没有自动化测试，那么集成工作，其实还是非常浪费人力的。更重要的是，我们在每次“发版本”之后，总会担心新的修改，导致一些旧的功能失效。这种问题实际上是很常见的，如果无法自动化的做这种回归性的测试，那么我们每次发版还是要忍受漫长的测试工作进度。
自动化集成测试也有很多开源的工具可供选择，特别是基于模式开发的程序，但如果是手机的项目，或者客户端程序比如网络游戏，对于这类服务器系统的集成测试，往往需要我们自己根据业务来编写测试程序。对于服务器系统来说，一般我们针对其通信协议编写测试程序即可，而对于客户端系统，如果是系统的，我们还可以根据的内部调度命令安卓就有这样的套件来测试，但如果是类似游戏这类业务，就只能用图形识别技术了。
在持续集成的流程中，集成测试往往是最后一步的检验关口。如果集成测试失败，应该给所有关注集成的人员发送警报实际上，如果成功也应该报告。现在企业往往会用邮件、、微信、短信或者别的一些东西接收这种消息。
的意义和实践
在互联网企业初始的阶段，运维工作往往是服务器端开发人员兼任的。当我在承担这种既是开发又是运维的工作时，往往非常羡慕那些“开发、运维分离”的公司。因为作为开发人员，没有三班倒的值班备份人力，往往是小时的待命状态，工作压力非常大。然而，当我自己参与到一些真正开发、运维分离的项目的时候，却发现，项目运营事故中，最少有的事故，是由运维的原因造成的。
除了常见的硬件、网络故障，操作系统配置出错，日志清理出问题，部署配置搞错，进程不小心杀掉等等都出现过。看来服务器端开发和运维还真是难解难分，而的思想，就是为了努力解决这种矛盾。我们不应该再把开发和运维对立起来，而应该认识到，运维是开发的一种延续，运维的需求也是服务器端系统的功能需求；运维是开发的目地，便利的、通用的运维工具，本身是能提高开发效率的一种专业产品。
运维与开发的一体性：运维、运营、

可以把看作开发软件工程、技术运营和质量保障三者的交集
一个互联网软件的上线运营，往往是由开发人员编写出来，然后经过人员测试，最后放在运营环境里进行运营。这个过程并非是单向的过程，基于前文说的，互联网服务都是在反复修改迭代中完善的，所以项目本身，一定是由多个版本，反复在开发、、运维之间循环交接。举例来说，一个网络游戏，在第一次开发出来后，都会经过比较仔细的测试，然后通过运维人员进行上线部署，最后由运营推广人员进行宣传，同时也要配合这些宣传开启游戏内部的一些功能，客服人员也会在开始运营后参与进来，除了提供客户咨询外，抓作弊玩家和封帐号也会持续进行。而作为开发人员的游戏策划，立刻会关注游戏系统的各种统计数据，以期在下一个版本中改善游戏设计。这个过程，可以看到在产品开发出来之后，整个团队几乎都还是需要以各种方式“使用”此服务器端系统的。所以我们在开发互联网服务的时候，不能仅仅面向互联网上的一般用户，同时也需要考虑整个开发团队的使用需求。
现代的互联网软件系统往往都带有服务器端部分。而这些服务器程序需要运行，因此产生了两类非常明显的需求：

运维需求：这类需求往往表现为非功能性需求，它要求服务器程序能够适应大规模用户访问和持续稳定运行。

运营需求：这里需求通常是功能性需求，因为产品上线后，产品和运营、客服、测试人员，还需要持续不断的使用这个系统，和互联网的海量用户进行互动。


运营：客服、活动
在互联网服务中，运营是一个非常重要的环节。客户除了直接使用互联网软件的功能外，背后其实往往还有大量的从业人员在通过这个软件提供服务。
其中最常见的就是客服服务。客服往往最需要的是查询功能————能够查到系统中特定用户的使用数据，从而协助客户解决问题。客服的另外一个主要工作，是封帐号和封。现在互联网黑色产业链非常庞大，互联网企业保护自己的手段其实不多，而客服是其中一个重要的环节，避免黑色产业侵袭自己的利益，就需要互联网服务系统有人工干预其数据的能力。
运营互联网服务另外一个常见的行为就是“活动”，也就是开放一些限时的服务。就和超市一样，互联网服务也要定时或不定时的加入或关闭一些特别的服务。这些工作非常细致和琐碎，需要服务器系统能够提供人工参与或者机器定时启动的一些功能。在《魔兽世界》这个网游中，大部分的活动都是自动的和定时的，可以从游戏里的一个日历功能查到。而在国产的互联网产品中，的很多是临时加入，需要人工维护的，如“双十一购物节”这种。这些对于服务器系统的版本更新，功能修改，都提出了更高的要求。

因此一般我们在设计互联网服务系统的时候，就应该一开始就把运营需求，也作为版本目标纳入开发计划中。一些比较好的团队，会抽象和总结同类互联网项目比如游戏、电商类型在客服、运营活动上的共性，形成一套标准的服务规范以及实现这个规范的接口。由互联网服务开发团队去实现这些规范的接口，提供功能上的支持，而另外一个运营开发小组，则负责根据这个接口，开发供运营团队人员使用的界面、内部管理系统等。比如游戏的运营规范会要求游戏提供查询角色区服、帐号的名字、等级等数据，提供接口在游戏中发布任务；电商系统的运营规范会要求网店提供本店销售排行查询、优惠券折扣接口等等。
运维：部署虚拟机、监控、统计
作为非功能性的需求来说，部署需求是第一位的。频繁的部署是互联网服务快速演变的基础能力。另外，互联网用户的增加和消退也是非常迅速的，这导致了我们可能需要快速的进行服务器扩容，或者缩容。这种情况都需要涉及到部署。所以我们在开发服务器系统的时候，部署需求是第一个需要考虑。加上如果我们希望实行持续集成，那么就更加需要重视部署的能力。作为服务器端系统，如果被设计成带有非常复杂的进程种类和进程通讯关系的话，要做好部署就会变得更加复杂。加上可能部署的环境还不统一，可能出现的问题就更复杂了。所以现在有大量的技术尝试改善这个方面。首先被大家广泛接受的是虚拟机技术，也就是所谓云服务器，这种技术能让你无需直接操作硬件，不用扛机器到机房来进行部署，是一种巨大的进步。
而后现在我们有了这种基于容器技术的工具，这可以把服务器操作系统层的差异环境，都统一成一个个文件，部署的时候只要运行文件即可。但是这些依然无法简化错综复杂的服务器进程关系，所以现在有了各种“队列服务”技术，比如， 等等，这些队列服务把进程间通讯简化成专门的服务，减少了部署的复杂性。而的广泛使用，让我们在多进程间协调和监控有了更多的手段。在具体部署工具方面，这一类软件做了各种有益的尝试，这些都是能让我们优化部署需求功能的工具。

互联网服务的持续服务能力，实际上会收到各种挑战，除了版本发布可能导致的问题外，在大量机器硬件里面，硬件故障率是一个固定的比例。网络抖动，机房线路故障也常常会出现。更容易出现的是异常的用户访问波动：一大波用户汹涌而来，但是也有可能是攻击。不管怎样，你都需要随时掌握服务器系统的工作状态。这时你就需要一个监控系统，但如果产品上线才发现要做，那往往已经很迟了。因为一个系统是否有问题，并不是简单的从内存、、网卡流量就能看出端倪的，我们往往需要在服务开发之初，就定义好各种需要监控的指标，传统常见的指标有：每秒主循环的次数、每秒处理业务包的次数、服务器中缓存的会话数等等……一些做的好的系统，还会有很多业务层面的监控指标，比如某个特定服务的处理效率、处理成功率等等。
既然一个系统有大量的监控指标，就涉及如何生成和管理这些数据的问题。传统的做法是在系统中“埋入”这些监控程序，系统一边运行一边统计这些指标，然后定时生成日志或者通过网络上报给某个监控系统。但是这种做法的缺点是：如果你需要更多的指标，或者修改指标的统计方法，你就被迫要修改代码，重启服务，这样会影响正在运行的服务。现在另外一个做法是，由系统把运行的原始信息记录成日志，然后把日志集中上报到一个监控系统中，这个监控系统一般都带有分布式的文件存储系统和分布式计算统计能力。在搜集到大量实时日志的同时，这个系统根据预设的指标统计方法，不停的进行日志统计，一旦发现统计结果有问题，就会报警。而这种统计由于是在大数据处理能力的平台上生成的，所以往往发现问题的时间差能缩小到分钟级甚至秒级。这种做法由于搜集的是原始日志记录，所以就可以灵活的在系统运行时定制很多统计和报警的策略，但完全不会增加服务系统的压力，也不需要修改服务系统的代码。

最后说说统计，任何一个互联网系统，都是在用户的使用中不断优化的，这个优化的依据，最重要的客观依据，就是统计数据。而统计数据，一般由两部分构成：

用户的行为数据。比如登录行为，就可以给系统留下用户的、登录时间、登出时间等数据；购买行为，就可以留下购买商品，购买价格，购买时间这些数据。

根据用户的行为的关联，统计出来的数据。比如根据登录行为，我们可以统计出用户的在线时长，用户重复登录的次数，用户重复登录的间隔，还有什么次日存留、七天存留等等……；根据购买行为，我们更是可以整理出用户的购买商品倾向，值，甚至同类用户的购买共性，这些也是所谓大数据做商品统计的主要方向。


根据上面的分析，我们可以发现，实际上统计系统也是应该分两个部分设计，一个是尽量记录用户行为的基础数据，第二个是以复杂多变的统计条件，去挖掘这些用户行为数据中包含的规律。对于第一部分，一个可以存放海量日志数据的分布式存储系统非常重要；对于第二部分，分布式的统计运算系统是必不可少的。对于这个体系，的提供了业界的示范。但是如果你愿意，也可以使用这个思路自己来建设自己的统计系统，也许你的数据量无需要用到那么复杂。
总结
互联网开发模式，是针对于互联网本质上是一个“服务”而发展起来的。因为是“服务”而不是产品，所以应对快速变化的能力是最高的技术标准。我们倾向采用更适合表达需求的软件开发技术、自动化程度更高的开发工具，来提高我们的开发效率，而不是靠单纯的“激励主观能动性”来做管理。
因此我们在基于自动化测试、自动化部署等持续集成工具的平台上，使用重视原型迭代的方法来开发项目，在反复以原型确认需求，以及适应需求变化的过程中，逐步的完善整个开发生产线。并且把开发和运营视为一个整体，在服务的运营过程中，不断的完善互联网服务的运营工具，让开发和运营在同一个生命周期里生长。作者：

这个问题源于最近做的一个项目，需要用进行网络编程，涉及到使用通过自定义的二进制数据序列化协议与客户端进行通信。
当协商通信协议时，对接的客户端同学告诉我在发送数据的时候要将要发送的从本地序转换为网络序，当收到客户端的回包时，需要将收到的从网络序转换为本地序。
作为一个前端工程师，听到上面那段话，我脑海中的画面是：
网络序？本地序？傻傻分不清楚啊！
于是我决定翻开下面这本书，来一探究竟：

什么是网络序和本地序？
所谓的网络序和本地序其实就是一个跨越多个字节的程序对象在中可以简单的认为是一个长度大于的对象在存储器中的存储顺序，在了解这两种字节顺序之前，我们来复习一下计算机的寻址规则。
寻址
在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址，毕竟位所能表示的信息太有限了  。例如，假设一个类型为的变量的地址为，也就是说，地址表达式的值为。那么，的个字节将被存储在存储器的、、和的位置。
字节顺序规则
在存储器中如何排列一个跨越多个字节的程序对象，一般来说有两个通用的规则。
考虑一个位的整数，位表示为    ，其中是最高有效位，而是最低有效位。假设是的倍数，这些位就能被分组成为字节，其中最高有效字节包含位   ，而最低有效字节包含位   ，其他字节包含中间的位。某些机器选择在存储器中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效字节的顺序存储。
前一种规则——最低有效字节在最前面的方式，称为小端法 。大多数兼容机都采用这种规则。后一种规则——最高有效位在最前面的方式，称为大端法 。大多数和 的机器都采用这种规则。注： 和制造的个人计算机使用的是兼容的处理器，这些机器采用的是小端法。
许多比较新的微处理器使用双端法，也就是说可以把它们配置成作为大端或者小端的机器运行。大家先记住小端法 和大端法 这两个名词，这对于我们理解网络序和本地序灰常重要。继续我们前面的示例，假设变量类型为，占四个字节，位于地址，它的十六进制值为。地址的范围为的字节，其排列顺序依赖与机器的类型。
大端法：



字节存储地址










字节内容









小端法：



字节存储地址










字节内容









注：在字中，高位字节的十六进制值为，而低位字节值为。
对于大多数应用程序员来说，他们机器所使用的字节顺序是完全不可见的，无论为哪种类型的机器编译的程序都会得到同样的结果。不过以下三种情况，字节顺序会成为问题：

在不同类型的机器之间通过网络传送二进制数据时。一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反方向发送时会发现，接收的数据里的字节成了反序的。聪明的读者看到这里可能已经知道这篇文章的标题所要解决的问题了，后面我们会重点阐述。

当阅读表示整数数据的字节序列时，字节顺序也很重要。当在小端法机器上查看十六进制字节串时，机器显示的字节顺序与我们通常书写数字时的字节顺序正好相反。比如：自然书写的方式，数字最高有效位在最左边，最低有效位在最右边在小端法机器中会显示成数字最低有效位在最左边，最高有效位在最右边。

当编写规避正常的类型系统的程序时。简单的说就是在语言中可以用一种数据类型来引用任意类型的对象，强烈不推荐这种编程技巧。


看到这里，你可能会像，既然不同的字节顺序会带来这么多问题，为啥还要定义两种字节顺序呢？这不是闲得蛋疼吗？
你答对了！就是因为闲得蛋疼！
事实上，在哪种字节顺序是合适的这个问题上，人们表现的非常情绪化。而术语“ ”小端和“ ”大端出自《格列佛游记》一书，书中交战的两个派别无法就应该从哪一端小端还是大端打开一个半熟的鸡蛋达成一致。就像鸡蛋的问题一样，没有技术上的原因来选择字节顺序规则，因此，争论沦为关于社会政治问题的争论。
 “端”的起源：
 以下是《格列佛游记》一书在年关于大小端之争历史的描述：
“······我下面要告诉你的是， 和 这两大强国在过去 个月里一直在苦战。 战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端， 可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋时碰巧将一个手指弄破了，因此他的父 亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。 老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过次叛乱，其中一个皇帝送了命， 另一个丢了王位。这些叛乱大多都是由 的国王大臣们煽动起来的。叛乱平息后，流亡 的人总是逃到那个帝国去寻救避难。据估计，先后几次有人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。“此段译文摘自网上蒋剑锋译的《格列佛游记》第一卷第章。
在那个时代，《格列佛游记》是在讽刺英国和法国之间持续的冲突。 ，一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序，后来这个术语被广泛接纳了。”
网络序还是本地序？
扯了这么多没用的，终于要说说本文的重点了，什么是网络序？什么是本地序？什么时候该用哪种类型的字节顺序？
因为在互联网上运行的千千万万的计算机可以有不同的字节顺序，为任意整数数据项定义了统一的网络字节顺序  ：大端字节顺序！例如地址：它放在包头中跨越网络被携带。在地址结构中存放的地址总是以大端法网络字节顺序存放的，即使主机字节顺序  是小端法。提供了下面这样的函数在网络和主机字节顺序间实现转换：
 

 返回按照网络字节顺序的值。
      
      

 返回：按照主机字节顺序的值。
      
      

函数将位整数由主机字节顺序转换为网络字节顺序。函数将位整数从网络字节顺序转换为主机字节。和函数为位的整数执行响应的转换。看起来这两个函数屏蔽了不同的本机字节顺序。
结论：

网络序就是大端法字节顺序。
本地序依据机器类型，可能是大端法字节顺序或者小端法字节顺序。
里怎么玩？


作为为而生的当然提供了网络序大端法和本地序大端  小端互相转换。
 |   
读字节流

写字节流

举个栗子
现在跟客户端的同学已经协商好了二进制的数据序列化协议如下：
发给客户端的包体协议：
按字段的前后顺序拼装数据包：
用户个字节，不能为空用户类型个字节可以为空消息序列号个字节可以为空消息命令字个字节，不能为空消息体给客户端的文案，个字节长度编码的

客户端回包给的包体协议：
按字段的前后顺序拼装数据包：
返回码个字节，不能为空
组包：
 _ = 
 _ = 
 __ = 
 __ = 
 __ = 
 因为组好的包是要通过网络发送给客户端，所以要把数据以大端法写到数据包中。
  {
      = _
     ||  _ 
      = __
     ||  _  __
      = __
     ||  _
      = __
     ||  _  __
      =  
      =  
     =   
     拼接各个字段的
         
}

拆包
 _ = 
 _ = 
 __ = 
 __ = 
 __ = 
 因为组好的包是客户端通过网络发送回来的，所以要把数据以大端法读到本地。
  {
      = {}
      = _
      = 
     = 
     拼接各个字段的
     
}

发包、收包，以协议通信
  = 
  =   回包超时时间 单位：毫秒

  {
      = {
        
    }

      =  {
          
        
    } 

     根据参数组包
      = 
      = 

     发包
          {
          
    }

     监听客户端的回包
       {
        
         根据协议解客户端的回包
         = 
    }

      {
         
    }

      {
         
        
        
    }
}

终于写完了，现在各位前端的小伙伴们应该搞清楚网络序和本地序了吧？

原文链接： 定位用户记录的过程可以描述为：
打开索引  根据索引键值逐层查找  树  结点  定位到叶子结点，将  定位到满足条件的  上
如果树高为  则需要读取索引树上的  个结点并进行比较，如果 _ 较小，则大量的操作都会在  上，用户响应时间变长；另外，中  层与  之间的是以  为单位进行交互的， 将记录返回给  层， 层对  的行数据进行相应的计算，然后缓存或发送至客户端，为了减少交互过程所需要的时间， 做了两个优化：

如果同一个查询语句连续取出了 ___ 条记录，则会调用函数 ______ 将 ___ 记录缓存至 _ 中，在随后的 __ 次交互中，都会从_ 中直接取数据返回到  层，那么问题来了，即使是用户只需要  条数据， 层也会将 ___ 条数据放入 _ 中，造成了不必要的缓存使用。另外，  可以根据用户的设置来调整缓存用户记录的条数；

 取出数据后，会将  的位置保存起来，当取下一条数据时，会尝试恢复  的位置，成功则并继续取下一条数据，否则会重新定位  的位置，从而通过保存  位置的方法可以减少  层   层交互的时间；


 层   层交互的过程如下，由于    的   不一样，那么        在读场景下的开销也是比较大的。
  == __  _ = _
{
     
     __
    {    
      __= 
      = ____
    }    
     
      = _                

    = __ _       
}
 功能作用
由以上的分析可以看到  一次定位  的过程即是从根结点到叶子结点的路径，时间复杂度为：    ，上述的两个优化过程无法省略定位  的中间结点，因此需要引入一种可以从   定位到叶子结点的方法，从而省略根结点到叶子结点的路径上所消耗的时间，而这种方法即是 自适应索引   。查询语句使用  的时候有以下优点：

可以直接通过从查询条件直接定位到叶子结点，减少一次定位所需要的时间

在   不足的情况下，可以只针对热点数据页建立缓存，从而避免数据页频繁的 


但是 并不总能提升性能，在多表  模糊查询  查询条件经常变化的情况下，此时系统监控  使用的资源大于上述的好处时，不仅不能发挥  的优点，还会为系统带来额外的  消耗，此时需要将  关闭来避免不必要的系统资源浪费，关于  的适应场景可以参考：____。
 内存结构
 会监控查询语句中的条件并进行分析稍后会进行详细的介绍，当满足  缓存建立的条件后，会选择索引的若干前缀索引列对热点数据页组建   以记录      之间的对应关系 本小节主要对  的内存结构  内存来源进行相应的介绍，其内存结构如图：

上图是  的一个内存结构示意图， 主要使用以下两种内存：

系统初始化分配的 _ 的内存，其中每一个 _ 的数组大小为：____    ，根据机器位数的不同，数组大小不同， 位机器为 _大小的   位机器为 _ 大小的 ， 此部分内存为系统内存__，主要用于构建 _ 结构；

  __ = =  
    ____ = = _=  = =
     
    ___ = _=  = =  
    __ = _=  = =  
    _ =  
    __ = _= __= =  
    ___ _=  
    __ _= _=  

 
                     

当  对数据页面构造  缓存时，此时使用 _ 的  链接中的内存，即 _ 的内存，所以在页数据发生变化的时候，需要对  缓存进行相应的维护；

 实现解析
【  在查询过程中的作用范围 】
 中    的交互中是以行为单位进行交互的， 逐行取数据的过程可以分为以下  个步骤：

如果发现其它线程需要对__上锁，则释放 __，然后执行 ；    在实现上不同

尝试从 ___ 中取数据库记录，有则直接返回，如果没有数据或者不可以使用   则执行

在满足条件的情况下，使用  定位  位置并返回数据 否则执行 

根据  的值确认是否可以从 __中恢复  的位置，如果  =  或不可以从 __中恢复  的位置， 则调用 _____ 打开索引，调用 _____，如果可以使用 ，则快速定位叶子结点，否则遍历  个结点定位  然后进入 ；如果可以从 __ 恢复则执行 

根据查找的值在叶子结点中逐个匹配，查找满足条件的记录，返回数据，取下一条记录时执行 

移动  到下一条记录并返回数据


 则在第   两个步骤中影响着定位叶子结点的过程，根据查询条件定位叶子节点的过程中发挥着  的作用， 的实现主要包括  初始化过程、构建条件、使用过程、维护过程、系统监控等部分，我们从源码的实现的角度上分析上述过程。
【  初始化过程 】
 作为 _ 的一部分，是建立查询条件与  在内存中位置的一个 _ 在系统启动的时候会随着 _ 的初始化而自动的建立相应的内存结构，其初始化过程为：

利用系统内存  创建全局变量 __ 及其锁结构

利用系统内存  建立 _ 内存结构，并初始化其成员变量，其中 _ 数组的大小取决于当前 _ 的  与 系统的机器位数，计算公式为：____    ，__ 的结构如下所示：


  
 = __  
  
 = {
   = ___ 
   =  
  _ =  
   =  
  __ =  
  _ = {
     =  
    _ = 
  } 
   =  
   =  
  _ = 
}
说明：

所有 _  共享一个 ， 而不是每一个 _  一个 

 之前  只有一个全局的锁结构 __ 当压力比较大的时候会出现性能瓶颈， 对  进行了拆锁处理，详情可以参考函数 ___  ___

 的 __     是中两个比较大的锁，详情可以参考      –     ， 通过对  锁拆分     以及引入不同的索引锁协议  解决了这两个问题。


【  构建条件 】
 是建立在     内存地址之间的映射信息，在系统接受访问之前并没有足够的信息来建立  的映射信息，所以需要搜集  语句在执行过程中的 _    信息并判断是否可以为数据页建立  缓存，其中：
  对应 __， 用于记录  中的 _ 前缀索引列数  _   信息，这些被用于计算  值；
  用于记录计算  的值所需要的    之外，还记录了在此情况下使用  在此数据页上潜在成功的次数；
我们简单的对  统计信息的几个方面进行简单的描述。

触发  索引统计的条件

 语句在定位  的过程中会执行 _____ 函数，当打开  的时候，在_____ 返回之前会调用 ___ 来更新相应的统计信息，如果当前的索引的 __  ___ ，则对      不进行统计，否则则会调用 ____ 更新      信息，实现如下：
 ___
===================
  __         
  __          
{
 
  _
   _  ___ {
       
  
  }
  ____ 
}

 中索引查询信息 _ 的更新与自适应的过程 

背景知识： _____ 中在定位  的过程中会在树的每一层调用 ____ 来确定下一个  结点或叶子结点，____ 函数会将查询过程中比较的前缀索引列数  最后一列匹配的字节数记录至 {_ _ _ _}，目的是为了保存与   在比较过程时的最小比较单元，详细的计算过程可以参考 ____ 的实现代码。
首先判断当前  是否为   ， 如果是   则不进行  等相关的操作；
其次，如果当前索引的 __ = ，则会按照推荐算法从 {_ _ _ _} 推荐出前缀索引列数  最后一列的字节数用于计算  中存储的键 {__} 的值。
 当 __ =  时，则会判断当前查询匹配模式  _ 中保存的匹配模式是否发生变化，如果没有发生变化，则会增加此模式下潜在利用  成功的次数 __，否则需要重新推荐前缀索引列等相关信息，并清空 __ 的值__ = ， 就是利用这种方法来实现自适应的，所以在打开  的系统中不建议经常变换查询条件，前缀索引等信息的计算过程如下：
____
{
  

             
              
     

  _ =  

   = ___ _
        _ _
    ==  { 
    __ =  

              

    _ =  
    _ =  

    _ = 

  }      { 
    __ =  

     _ = _ {

      _ = _
      _ =  

    }   _  _ {

      _ = _   
      _ =  
    }  {
      _ = _
      _ = _   
    }    

    _ = 
  }  {
    __ =  

     _ = _ {

      _ = _
      _ =  

    }   _  _ {

      _ = _   
      _ =  
    }  {
      _ = _
      _ = _   
    }    

    _ = 
  }
}
由以上算法可以看出，选择{_ _ _}的依据则是在不超过   列数的前提下，使其计算代价最小，而 _ 的值则会决定存储同一数据页上相同前缀索引的最左记录还是最右记录。

数据页  信息的更新

数据页   的更新主要包括数据页上的索引匹配模式、在已有索引匹配模式下成功的次数以及是否为该数据页建立  缓存信息的判断，其主要过程如下：
 将 __ 设置为  此时其它线程无法使用该索引上  功能；
 如果 _ 的匹配格式  该数据页上保存的匹配模式相同时，则增加此  使用  成功的次数 __， 如果已经为该数据页建立  缓存，则设置 __ = ；
 如果 _ 的匹配格式  该数据页上保存的匹配模式不相同，则设置 __= 且使用 _ 对  上的索引匹配信息进行重新设置，详细过程可参考 _____；
 判断是否需要为数据页建立  缓存，在数据页  上使用  成功的次数大于此数据页上用户记录的  且当前前缀索引的条件下使用  成功的次数大于  时， 如果此数据页使用  潜在成功的次数大于  倍该数据页上的用户记录或者当前推荐的前缀索引信息发生了变化的时，则需要为数据页构造  缓存信息，详情可参考以下代码；
   __  ___
        ____
       __ = ___ {

     
        || __    ___
        || _ = __
        || _ = __
        || _ = __ {

               

      
    }
  }
【  构建过程收集  判断  建立】
 的构建过程指的是根据 _ 构建查询条件  数据页的  关系，其主要过程为：
 收集  信息。遍历该数据页上的所有用户记录，建立由前缀索引信息  物理记录之间的映射关系的数组 { }，其中 _ 用来判断在前缀索引列相同情况下如何保存物理页记录，从代码中可以得知：当 _ 为  时前缀索引列相同的记录只保存最左记录，当 _ 为  时前缀索引列相同的记录只保存最右记录，代码实现如下：
    {
    _ = ___
     ____ {
       _ {
        _ = 
        _ = 
        _
      }
      
    }

     = ___  
            _  _   
    _ = __  _
             _ 

      = _ {
              
       _ {
        _ = _
        _ = _
        _
      }  {
        _ = 
        _ = 
        _
      }
    }

     = _
     = _
  }

 如果之前该数据页已经存在  缓存信息但前缀索引信息与当前的信息不一致，则释放之前缓存的  信息，如果释放超过了一个  ，则将释放的数据页退还给 _ 链表 
 调用 ______ 来确保  有足够的内存生成映射信息 __ {  }，该内存从 _ 链表获得，详情参考：__  的值的计算可参考函数：_ 
 由于操作过程中释放了 __，需要再次检查  上的信息是否发生了变化，如果发生变化则退出函数；
 调用 ___ 方法将之前收集的信息生成 __ 并将其存放到 ___ 的数组中，其中存放后的结构可以参考图   ；
    =    _  {
    ___   
  }
【  使用条件及定位叶子结点过程 】
在 “ 在查询过程中的作用范围” 一节中我们详细的介绍了  中  层   层中的交互方式以及  在整个过程中的位置  作用，下面着要看一下在 步骤   中  是如何工作的。
步骤  中，是使用  的一种  查询方式，只有在满足很苛刻的条件后才能使用  的  查询方式，这些苛刻条件包括：
 当前索引是   
 当前查询是  
 当前查询不包含  类型的大字段；
 记录长度不能大于 _
 不是使用  接口协议的查询；
 事物开启且隔离级别大于  ；
 简单  查询而非在   ；
在满足以上条件后才能使用  的  查询方式定位叶子结点， 中满足条件后的操作可以简单的描述为：
______

______

______
步骤  中使用  快速定位叶子结点同样需要满足一些条件，具体可以参考代码：_____，在此不再累述，我们着重分析一下使用  定位叶子节点的过程。
 对  所在的 _ 上锁，使用查询条件中的  信息计算出键值  
______
 = _ _ _ _
 在 _ 上进行查找  =  的 __
 _
____
===================
  __       
              
{
  __  
  ___ 
  ___

   = ___ 

    {
      ==  {
      
    }
     = ___
  }
  
}

 = _ ________ 
 释放锁资源并根据返回的记录定位叶子结点；
 = __
______
__ _   
 定位到叶子结点后的过程和不使用  之后的过程类似，直接返回记录并记录  位置；
 维护  监控
  中有两个  相关的参数，分别为：___ ____，其中 ___ 为动态调整的参数，用以控制是否打开  功能；____ 是只读参数，在实例运行期间是不能修改，用于调整  分区的个数 引入，减少锁冲突，详细介绍可以参考官方说明：___ ___，本节主要介绍操作  的相关命令以及命令的内部实现过程。
 打开  操作  内部实现
  ___=，此命令只是对全局变量进行设置，代码实现如下：
      
_

__
====================
{
  ____
  __ =              
  ____
}
 关闭  操作  内部实现
  ___= ，此命令用于关闭  功能，具体实现可参考 __， 关闭流程说明：

设置 __ = ，关闭  功能

将数据字典中所有缓存的表对象的 _ 设置为，只有 _____  =  的情况下才能清除数据字典中的缓存对象，详情见 ____

将所有数据页中的统计信息置空，具体实现可参考 ____

释放  所使用的 _ 的内存，__ 具体实现如下：


          
_

__
====================
{
  __ 
     

  __
  ____

  __ = 

     __    
      
    = _____ 
        = ____  {

    ____
  }

    = ______ 
        = ____  {

    ____
  }

  __

      =  
  ____

        
    =    ___  {
    _____
    _____
  }

  ____
}
  缓存信息的维护
 维护的是     在物理内存地址的  关系，当物理记录的位置或者所在  的地址发生变化时， 也需要对其进行相应的维护，如新记录的的插入，表记录的的删除，数据页的分裂，    ， 换页等都需要对  进行相应的维护，详情可参考函数 ____  _____  ______的实现；
  信息的监控
 默认情况下只对 __ 使用  方式查询的次数  ___ 使用  查询的次数，需要遍历  结点 进行监控，更详细的监控需要进行额外的设置，详细设置方法可参考 __  __ ，打开  的监控方法、使用监控、重置监控的方法如下
 _   __ = __
      

 _     _ _ _ _ _  _    _

|   |                                      |            |   | _ | _ | _          | _        | _ |

|  | __                   | __ |  |     |       |  |   |           |
|  | ___             | __ |  |     |       |   |   |           |
|  | ___                | __ |   |      |       |  |   |           |
|  | ___              | __ |       |       |       |                   |   |           |
|  | ___                 | __ |  |     |       |   |   |           |
|  | ___               | __ |       |       |       |                   |   |           |
|  | ______ | __ |       |       |       |                   |   |           |
|  | ___               | __ |       |       |       |                   |   |           |

     

 _   ___=__
      

 _   __=_
      

 _     _ _ _ _ _  _    _

|    |                                      |            |  | _ | _ | _ | _ | _ |

|  | __                   | __ |      |       |       |       |          |           |
|  | ___             | __ |      |       |       |       |          |           |
|  | ___                | __ |      |       |       |       |          |           |
|  | ___              | __ |      |       |       |       |          |           |
|  | ___                 | __ |      |       |       |       |          |           |
|  | ___               | __ |      |       |       |       |          |           |
|  | ______ | __ |      |       |       |       |          |           |
|  | ___               | __ |      |       |       |       |          |           |

     
值得一提的是只有执行   ___=    __=_ 才对状态进行重置，如果发现 __  ___ 的时候，则应该关闭  以减少不必要的系统消耗。
相关推荐腾讯云数据库  相关文档开发实践问，你能住几个？作者：

前言
插件化工程具有减少方法数和包大小，易于扩展等优势，深得大型工程的青睐，但同时插件化也会引起一些意想不到的麻烦。我们最近在做的插件工程就遇到了一个诡异的链接错误。
我们的插件工程作为主工程的具体业务，主工程提供了基础的类库和工具，插件工程有自己的，并把主工程的设为自己的父，通过双亲委托，插件工程就可以访问主工程中的类。在主工程中有一个类库，有方法，但为了减少主工程的包大小，文件由插件在用到时自己下载和加载。
而这种加载方式，出现了诡异的错误。我们首先检查了方法发现并没有出错，又查看了进程的内存映射信息，发现文件确实已经加载，但调用方法也确实一直出错。待排查了时序等相关情况后，还是不成功，于是我们只得求助于系统源码，希望能从源码中找到答案，以 为例，我们开始了源码分析过程。
加载流程分析
既然要先加载才能用，那我们就先来看是怎么加载的，先来分析方法

方法很简单，直接调用了类的方法，传入了的名称和当前的，再来看这个方法

可以看到，校验了参数后调用了方法，取得和后调用了层的函数。继续看函数

还是很简单的函数，设置完后，调用的函数，继续看

该函数较长，但逻辑还是很清晰的，我们只列出了关键代码，保存了一个以路径和对象为记录的，保存了当前所有已经加载的。首先从中查找记录，如果有说明该已经加载过，再判断和关联的是不是当前的，如果不是，返回，这说明同一个路径的只能被一个加载，如果没找到记录，说明该没有加载过，则通过打开该，保存相关信息到对象中，把添加到中，用查找_函数，如果找到了则执行该函数。 在看代码时第一反应是会不会判断这里有问题，已经被另一个给加载了，但转念一想，如果这里有问题那么的时候会直接报错，而不是在执行的时候才报错。所以的加载流程没有找到有问题的点，那么我们再看执行流程。
方法执行流程分析
我们知道，在环境下，类的方法都会用表示，而的字段保存了该方法的跳转地址

其中__就是函数执行时的跳转地址，那么这个地址是什么呢？其实这个地址是在加载的时候设置的，我们来看下代码

负责在中加载，通过，会解析出，最后通过对的跳转地址进行赋值，这里我们只看方法的情况，执行了函数

就是对__做了赋值，值是通过获得，就是一个函数地址，到这里我们知道类加载后其方法地址被设置成了这个入口函数，当方法被执行时，会调用这个入口函数执行，我们来看这个函数

____在汇编中定义，与平台相关，我们用平台代码作为例子

可以看到这个函数又跳转到了函数

该函数首先查询函数的地址，查到后会通过设置给，这样以后就就可以直接跳转到层的地址，而不用每次都经过该函数，同样调用了来设置跳转地址，接下来看函数

这里又看到了熟悉的，前边分析加载部分已经知道它保存了所有已经加载的，所以这就是从已经加载的里查找函数，如果没找到，则抛出。我们再来看看

就是调用获取函数的地址，所以到此函数的地址就真正的找到了，但是我们注意到了其中的一个判断，==__，也就是和关联的要和当前的是同一个才行，不然会放弃查找，到此我们的疑惑也就解开了，因为层的代码是在主工程的里，而加载用的是插件的，两个不相等，所以在这里放弃了查找而抛出了异常。
解决方案
知道了原因解决自然也就容易了，只要用同一个加载类和就行了，因为层的是变不了的，所以我们就改变加载的
、使用主工程中的类来加载
、如果主工程不好添加代码的话，我们也可以在插件里改变所使用的，但是的方法只有一个参数的公开方法，传的方法是私有的，所以我们只能通过反射去传入主工程的

一点思考
通常我们只注意了类和的对应关系，通过和类的全路径名来唯一的确定一个，而忽略了和也是有对应关系的，具有相同的类和方法才能一一对应，其实也起到了类似命名空间的作用。作者简介： ，深圳大学通信工程专业大三在读，深大的树洞小程序开发者。高中接触  开发和设计，大学开始正式学习前端、、，大一开始在校不间断负责多个公众号、小程序的开发。

深大的树洞以下简称树洞是面向深大学生的一款小程序，同学们可以在这里分享新鲜事，吐槽生活中不爽，诉说碰到的委屈。
树洞也是自微信小程序公测以来上线较早的一批小程序，上线之后获得了深大同学们的广泛好评，平台也一直保持着较高的活跃度。

核心功能展示：

产品核心逻辑较为简单，用户进入小程序之后在首页可以浏览用户已发布的内容，支持点赞和评论，用户同时能在底部 栏进入消息页查看和回复相关评论信息。
点击屏幕右下角的悬浮按钮可以进入发布页面，内容支持文字和配图，并提供定位功能，用户如果选择实名发布信息的话，会获取用户的微信昵称和头像以供主页显示。
版本迭代
关于 
大概是今年的  月份，当时小程序正式上线了，自己用了一圈，体验上总体来说还是比网页要出色一些。然后我也一直有开发一款树洞类应用的想法，于是就着手开始做一款树洞小程序。
当时为了赶在  情人节上线，整个开发周期基本就只有不到一周的时间，包括前后端的开发，十分的紧迫。 的技术选型阶段，后端采用    的架构，而前端小程序方面，为了使用  和  进行开发，选用了  框架。
但是后来发现  也有问题，首先就是状态的绑定分为了  和  ，绑定的时候增加了复杂度，其次就是对于组件的支持并不是特别的舒服，没有  单文件来的好用。
下面就开始来讲  的整个开发过程。
技术选型
后端
后端没有推倒重来，在  的基础上增加了  的后缀，并且复用了一些  版本的 。一方面是考虑到某些  的数据结构已经比较完善了，而且暂时没有更好的设计；另一方面是考虑到这样可以节省一点开发的工作，也可以兼容低版本。
对于数据的设计，也没有推倒重来，只添加了广告和通知两个数据库。
前端小程序端
在  发布之后，无意之间发现了  这个框架，发现这个框架借鉴了  的单文件组件的开发模式，而且一些  的使用也更加贴近原生的 ，另外在框架层面也实现了数据的脏检查，可以摒弃原生小程序的于是决定采用 。
开发
考虑到  版本要加入评论回复的提醒，那么如何展示通知就是一个大问题。原因是因为小程序没有提供跨出小程序通知的能力，那么我们就只能在小程序内考虑通知的提示。
而在对后端的通知  设计的时候，考虑了两种方案：

 


轮询

 是基于  的全双工通信，可以实现服务端推送信息，微信的  端也是采用  来实现通信的，而轮询则是客户端定时请求服务端来查询有无通知。
相比而言，肯定是更优选择，但是考虑到小程序入口在微信内部的，聊天时一定要退出小程序，并且很少人会使用小程序置顶的功能，所以如果使用  就需要经常重复建立  连接。
并且考虑到很少有人会开着树洞等回复，所以实时的通知对用户体验的提升不大，于是我采用了轮询来实现，这也是技术上比较简单的实现方式。
在开发通知页面的时候，我还发现了一个问题，就是微信小程序的   还不支持  请求，便暂用 请求作为替代。
通知方面，由于通知只能在小程序内部进行显示。于是我打算使用  栏来提示，随之而来的第二个问题就是，小程序提供了一个展示  栏的能力，但是只能自定义  和文字，并且只能在配置文件里配置，等于说完全失去了对  栏编程能力，于是我抛弃了原生的  实现，使用  提供的组件系统自己实现了一个  栏。
最后的页面结构如下图所示：

基于此，首页、通知、用户三个页面不再是 ，而是 ，所以开发的时候  应该继承的是  这个类。而其他页面层级的页面的类，则应该继承 。也正是由于这种情况，组件是没有生命周期的函数的，所以需要在  上面手动触发组件内的函数，来模拟生命周期函数的调用。
接下来的一个问题，就是关于  的登录态的问题。由于小程序是没有  的，于是我们普通设计  的登录态  不能放在  上了，于是便考虑将  放在  里。在用户首次登陆的时候将登录态的  放在本地的  里，并在每个请求发起的时候自定义了一个请求头，手动带上 。
示意图如下：

关于树洞开发的一些问题和解决方案就基本记录到这里了。
体验优化
随着树洞用户量的逐渐增加，部分用户反馈在夜间高峰期树洞首页数据刷新缓慢甚至经常刷不出数据。
还有一些已经去外地实习的同学跟我吐槽说，树洞的使用体验不如在校内使用时那么流畅。
我对以上问题进行反思，先考虑从小程序的代码层面进行优化，但是折腾一番后发现在基于微信提供的框架上进行开发后，自己能做的事情十分有限，便作罢。
然后开始从用户请求与服务器端通信的过程入手分析问题，这时正巧看到腾讯云动态加速新品内测，我尝试申请了一下竟然很快就通过了，于是遍想通过接入动态加速，看看问题是否出在网络传输过程中。
接入过程也十分简单，填写加速域名和，然后过大概分钟了：

在接入动态加速之后的一个星期的时间，我每天跟踪了之前曾经跟我反馈过问题的同学们的树洞使用体验，发现他们基本没有再跟我吐槽过卡顿、数据丢失等问题，使用高峰期间的用户体验得到了很大的提高。
然后我使用听云测试了一下腾讯云动态加速的加速效果：

源站所在地：广州
检测数据时间段：年月日   年月日 
测试条件： 大小文件下载

未经加速直连源站各运营商监测数据：

加速后各运营商监测数据：

未经加速直连源站各省份监测数据：

加速后各省份监测数据：

相比之下，加速后性能提升近，可用性也有所提高，效果还是相当明显的。
虽然加速效果很明显，但是我发现截止发文时间为止，腾讯云动态加速控制台的统计分析模块所提供的统计维度还是太少，对于树洞这类运营需求比较强的产品来说，显得有些美中不足，希望他们正式上线之后，能加入更丰富的统计功能。
以上，希望我分享的内容能帮到大家。一、概述
是成员之一，基于语言，无任何依赖，并且比更加轻量，非常适合安装在生产机器上，不会带来过高的资源占用，轻量意味着简单，所以并没有集成和一样的正则处理功能，而是将收集的日志原样上报。
工作原理图：

由两个主要组件构成：  和 。这两类组件一起协同完成的工作，从指定文件中把数据读取出来，然后发送事件数据到配置的中。
负责进行单个文件的内容收集，在运行过程中，每一个会对一个文件逐行进行内容读取，并且把读写到的内容发送到配置的中。
负责管理，并且找到所有需要进行读取的数据源。如果 配置的是类型，将会去配置度路径下查找所有能匹配上的文件，然后为每一个文件创建一个。这里还有一个
一个简单的示例：

 采集系统日志
 _ 
   
   
  _ 
   指定 注册表文件，用于记录上次读取的位置，默认位于下的目录
  _ 
二、安装部署
基于语言开发，无其他任何依赖，安装非常简单！
、下载：
、安装
根据系统选择对应安装包，解压后按照需求修改的配置，然后执行：
      
实际生产环境，还得弄一个自拉起脚本，防止程序异常退出。网管这边目前已经使用自动化运维平台进行全自动安装部署：三、配置介绍
配置比较简单，这里我就直接贴上网管这边目前用到的配置，更多介绍可以看后文的配置详解，一般都可以轻松搞定。
  

 采集系统日志
 _ 
   
   
  _ 

 采集慢日志，这里用到了多行模式
 _ 
   
  _ __
  
       
     
     
     
     

 采集日志
 _ 
   _
  _ __

 规避数据热点的优化参数：
 积累条消息才上报
_ 
 或者空闲上报
_ 

这里配置下这个字段为本机，用于里面将这个值赋给一些拿不到主机的数据，比如慢日志
 

  

        
   
       
   {}
  _ 
  _
    _ 
  _ 
   
  __ 

  
 
_ 
_ 

   
   
   

  
 

           
    
      
    
四、附录：配置详解

   
  

        
  
    
       指定要监控的日志
      
         

      指定被监控的文件的编码类型使用和都是可以处理中文日志的。
         
                
               
       

      指定文件的输入类型默认或者。
      _ 

       在输入中排除符合正则表达式列表的那些行
       _ 

       包含输入中符合正则表达式列表的那些行默认包含所有行_执行完毕之后会执行_。
       _  

       忽略掉符合正则表达式列表的文件默认为每一个符合定义的文件都创建一个。
       _ 

       向输出的每一条日志添加额外的信息比如“”方便后续对日志进行分组统计。默认情况下会在输出信息的子目录下以指定的新增建立子目录例如。
      
         
         

       如果该选项设置为则新增成为顶级目录而不是将其放在目录下。自定义的会覆盖默认的。
      __ 

       可以指定忽略指定时间段以外修改的日志内容比如两个小时或者分钟。
      _ 

       如果一个文件在某个时间段内没有发生过更新则关闭监控的文件。默认只会在下一次才会被发现
      _ 

       设定输出时的的字段也可以用来给日志进行分类。 
      _ 

       以多快的频率去指定的目录下面检测文件更新比如是否有新增文件如果设置为则会尽可能快地感知更新占用的会变高。默认是。
      _ 

       每个监控文件时使用的的大小。
      __ 

       日志文件中增加一行算一个日志事件_限制在一次日志事件中最多上传的字节数多出的字节会被丢弃。   
      _ 

       适用于日志中每一条日志占据多行的情况比如各种语言的报错信息调用栈。这个配置的下面包含如下配置
      

                         
         \

                       
         

                             
                           
                         
         

                   
               _     
           
        _ 

                             
           
         

       如果设置为从文件尾开始监控文件新增内容把新增的每一行文件作为一个事件依次发送而不是从文件开始处重新发送所有内容。
      _ 

       检测到某个文件到了之后每次等待多久再去检测文件是否有更新默认为。
       

       检测到某个文件到了之后等待检测文件更新的最大时间默认是秒。
      _ 

       定义到达_的速度默认因子是到达_后变成每次等待_那么长的时间才一次直到文件有更新才会重置为。
      _ 

       这个选项关闭一个文件当文件名称的变化。该配置选项建议只在。
      __ 

      
    
           
      _ 

   的大小中的事件数量超过这个阈值的时候会清空发送出去不论是否到达超时时间。
  _ 

   是否采用异步发送模式实验
  _ 

   的超时时间如果到了超时时间也会清空发送出去不论是否到达容量的阈值。
  _ 

   记录处理日志文件的位置的文件
  _ 

   如果要在本配置文件中引入其他位置的配置文件可以写在这里需要写完整路径但是只处理的部分。
  _
  
 输出到数据配置单个实例数据可以输出到或者选择其中一种注释掉另外一组输出配置。

   输出数据到
  
            
     

     输出认证
     
     
     

     启动进程数
     

     输出数据到指定     可以使用变量 
     

     一个模板用于设置在映射默认模板加载是禁用的没有加载模板这些设置可以调整或者覆盖现有的加载自己的模板
    

           
       

          
       

         
       

       
     

       
    _ 

     发送重试的次数取决于_的设置默认为
    _ 

     单个批量索引请求的最大事件数。默认是。
    __ 

     请求超时事件。默认秒
     

     新事件两个批量索引请求之间需要等待的秒数。如果__在该值之前到达额外的批量索引请求生效。
    _ 

     是否保持拓扑。默认。该值只支持。
    _ 

     保存拓扑信息的有效时间。默认秒。
    _ 

     配置参数选项如证书颁发机构等用于基于的连接。如果丢失主机的用于连接。
    
              
      _ 

           
       

         
      _ 

                
                    
                
            
       

               
      _ 

              
      _ 

               
      _ 

               
      _ 
   发送数据到 单个实例数据可以输出到或者选择其中一种注释掉另外一组输出配置。
  
      主机地址
     

     配置每个主机发布事件的数量。在负载均衡模式下最好启用。
     

     发送数据压缩级别
    _ 

     如果设置为和配置了多台主机输出插件将负载均衡的发布事件到所有主机。
    如果设置为输出插件发送所有事件到随机的一台主机上如果选择的不可达将切换到另一台主机。默认是。
     

     输出数据到指定     可以使用变量 
     

          
    配置参数选项如证书颁发机构等用于基于的连接。如果丢失主机的用于连接。
    
              
      _ 

           
       

         
      _ 

                
                    
                
            
       

               
      _ 

              
      _ 
   文件输出将事务转存到一个文件每个事务是一个格式。主要用于测试。也可以用作输入。
  
     指定文件保存的路径。
     

     文件名。默认是  名称。上面配置将生成    等文件。
     

     定义每个文件最大大小。当大小到达该值文件将轮滚。默认值是 
    __ 

     保留文件最大数量。文件数量到达该值将删除最旧的文件。默认是一星期。
    __ 
     标准输出 格式。
   
    如果设置为事件将很友好的格式化标准输出。默认。
     
  

   日志发送者信息标示
   如果没设置以名自居。该名字包含在每个发布事务的字段。可以以该名字对单个发送的所有事务分组。
  

   标签列表包含在每个发布事务的字段。标签可用很容易的按照不同的逻辑分组服务器。
  例如一个集群服务器可以对添加上标签然后在的界面以该标签过滤和查询整组服务器。
    

   如果启用了_选项将忽略从运行服务器上所有事务。
  _ 

   拓扑图刷新的间隔。也就是设置每个向拓扑图发布其地址的频率。默认是秒。
  __ 

   拓扑的过期时间。在停止发布其地址时非常有用。当过期后地址将自动的从拓扑图中删除。默认是秒。
  _ 

           
  _ 

   数据库的搜索路径。找到数据库后加载然后对每个事务输出的位置目前只有使用该选项。
  
    
       
       
  
 配置日志。日志可以写入到也可以是轮滚日志文件。默认是。

   如果启用发送所有日志到系统日志。
  _ 

   日志发送到轮滚文件。
  _ 

   
  
     日志文件目录。
     

     日志文件名称
     

     日志文件的最大大小。默认   。
       = 

     保留日志周期。 默认 。值范围为 到 。
     

              
         
       
    

   日志级别。    或 。如果使用但没有配置 将被使用。默认。
   

  参考文档
  导读
我的个人网站后台使用的是  版本，前段时间经常被，借助的新特性，经过一番排查，终于抓到这只鬼。
、问题现象
我的网站前段时间经常时不时就抽风一下，提示数据库无法连接，提示：
建立数据库连接时出错
本想反正是个人网站，挂就挂了，无所谓啦；也可能是配置太低，访问量一大就容易出问题，忍忍算啦。
后来启荣大师说了一句话：看那木匠做的烂门 😓⊙﹏⊙
于是下决心解决问题，不能再被鄙视啦，作为一个，不能容忍数据库无缘无故挂掉，哪怕是个人也不行 ∩_∩
、问题排查
首先，加了个任务，每分钟自动检测进程是否存活，如果没有，就启动之。这也是我们在企业里解决问题的指导思想：尽快找到问题，但在还没确认问题之前，优先保证服务可用性，不管你用啥方法。
接下来，再看自身的日志，看看能不能找到什么线索。然并卵，啥也没找到，应该是被异常的，所以只有启动过程记录，并没有异常关闭的过程记录。
再排查系统日志，终于看到进程因为给了：
图
可以看到，进程消耗了最多内存，被选中，给干掉了。
既然是，那我们再看下当时系统整体内存消耗情况：
图
是不是有明显的内存泄露迹象？不清楚的同学可以先看下面这篇文章普及下：

找到服务器发生罪魁祸首

好了，现在我们已经基本明确进程是因为内存泄露，导致消耗大量内存，最终被了。
那么，我们如何知道进程究竟什么原因消耗掉内存的，都用哪里去了呢？还好， 的__的简称集成了这样的功能，能帮助我们很方便的了解这些信息。因此我们执行下面的，就能找到里到底谁消耗了更多内存：
  _____  

_____

  ____   
图
我们注意到 “” 消耗的内存最大。
再执行下面的，查看都有哪些内部线程消耗了更多内存：
 _ ____ 

______

  ____   
图
我们注意到，上面的结果中，有很多非内部后台线程_ 值比较大用到了 “”，并且内存消耗也比较大。看到这种现象，我的第六感告诉我，应该是并发线程太高或者线程分配不合理所致。因为前端是短连接，不是长连接，不应该有这么多，推测是多线程连接或线程池引起的。
于是排查了一圈和线程、连接数相关的参数选项及状态，基本确认应该是开了线程池 ，导致了内存泄露，持续消耗内存，最终进程消耗过多内存，被系统给了。
下面是我的 相关设置：
图
当我们把线程池功能关闭后，内存泄露的问题也随之消失，进程再也没有被了，看起来确实是解决的问题。
经过几次反复测试，最终观察到以下结论：

同时开着_和 会导致发生内存泄露；
同时开着_和 ，不过采用””模式而非””模式只用到 功能，不会发生内存泄露；
只开着_，不开 ，不会发生内存泄露；
不开_，只开 ，也不会发生内存泄露；
同时关闭_和 ，也不会发生内存泄露；

交代下，我的版本是：

       

更早之前用官方的版本也是有问题的。
、结论及建议
在前端应用经常有突发短连接或相似场景中，开启线程池对缓解用户连接请求排队有很大帮助，可以避免连接瞬间被打满、打爆的问题。但线程池也并非适用于全部场景，像本案例遇到的问题就不适合了我当初开 更多是为了 功能。
上面我们提到，从 版本开始，新增了很多有用的视图，可以帮助我们进一步了解内部发生的一些事情。在_中新增了下面这几个内存相关的视图：

______
______
______
______
_____

看视图的名字，就知道这可以帮助我们分别从账号包含授权主机信息、主机、线程、用户不包含授权主机信息、整体全局等多个角度查看内存消耗统计。
除了内存统计，还有和事务、复制相关的一些视图，并且原来有些视图也进一步增强。
在 中，还集成了 ，关于 大家可以看本文下方的推荐链接。 主要是对_以及_的视图进一步增强处理，提高结果的可读性。比如，我们可以查看当前实例总消耗的内存，以及内存主要由哪些部分给占用了，也可以透过 来查看：
图
建议大家应该花些时间好好再深入理解下_、_、 ，对我们这些非底层代码的 而言，这些都是很好的辅助手段。前言
这次比赛的题目是  公司举办的线上实际问题比赛。 给出两个问题，然后参赛者判断这两个问题是否是重复的问题，即判断两个问题的意思是否一致。 公司本身用了一个   模型来判断问题是否重复。  
这次题目需要用到自然语言处理    的知识。而我对于  完全处于门外汉状态，本着学习的态度尝试一下这个题目。
题目地址： 
这个训练数据有大致  条记录，而测试数据有  之多，其中有很大一部分是为了防止参赛者人工标注而用电脑自动生成的题目。
评价标准
这次的评价标准用的是 

详细公式见：

这个损失函数需要针对每行记录计算预测出问题重复的概率值，而不是  二分值。它的特点就是相比准确率这个指标来说能够更好标识预测的精度，这个损失函数值随着预测精度的提高而减少。
本文工作
由于这次数据量太大，并且涉及到自然语言处理，我自己一台  内存的笔记本完全无法完成大计算量的处理。所以这次文章主要介绍几个简单特征的计算以及可视化，算是给自己这个半途而废的项目做个小总结。
特征计算
训练集的字段如下：

  训练集的记录  
   每个问题的唯一 ，只存在在训练集中 
   问题的文本内容，分别对应两个问题
_  目标值  表示两个问题意思一致， 则表示不一致

下图给出训练集的前  条记录：

文本基础处理
首先对每个问题进行文本处理，去除其中的数字标点以及停用词等同文本含义关系不大的部分，来获取各个问题的关键字。
这次特征计算使用了  包 。包  即  ，是用来做文本挖掘的一个  包，是一个进行自然语言处理的基础包。具体使用方法： 以第八条记录的问题  为例：
 记录  的问题 
       
           

     创建语料库
    
      
去除标点
  _ 
           
去除数字
  _ 
           
转化为小写
  _ 
           
去掉停用词
   _   
           
去掉空格
  _  
        
去掉常用单词结尾，例如是  等结尾，来获取词根
  _  
       
经过这一番处理后，剩余的文本基本就是这个问题的关键字了。
整合成函数如下：    
 提取问题的关键字
    __  
    {
        
          

          _ 
          _ 
          _ 
          _  
          _ 
          _  
         

         = 
        
    }
相同  占比
， 问题的关键字个数_ 两个问题的关键字差异__：相同  比例，两个问题相同的关键词所占整体的比例
  计算相同  占比
      __  
      __  
      
      
    _    
       ==   {
        __  
    }{
        __             
    }
通过图形来看下 __ 的分布状况：
__   _ =  =  =   = _

上图可以看到 __ 比例高的问题对更倾向于意思一致，但是区分度并不高。
问题字符长度
、 问题的字符长度_： 问题的字符长度之差__： 问题字符长度之差所占比例
 问题的字符长度
      
      
    _    
     转化为  范围
    __       _      
     画图
      = _  = __  = _    _    = 

从上图可以看到两个问题之间的字符差异对于结果基本毫无区分度。
情绪分析
语义的情绪分析。如果两个问题的情绪背景不同，那么其含义不同的概率也会大一些。这里用到了  包 ，具体使用方法见：

 包  提供了四个情绪相关的字典。我们所使用的函数 __ 调用的是     。这个字典将词语附上  种情绪        以及两种分类正面情绪和负面情绪


      __
      __

     计算正面情绪和负面情绪的  数
      
      
      
      

     来判断是否两个问题的情绪是否一致
    _     

    ==_=_   _=

从图上看出，随着情绪背景的一致状况的增高，问题意思一致的比例也在增高。
字符串相似度
衡量字符串相似度的计算方式有很多，主要分为基于字符串的相似度和基于语义的相似度。详细情况参见：由于基于语义的相似度计算量太大，我们从基于字符串的相似度度量中获取我们的特征变量。

莱文斯坦距离，又称  距离，是编辑距离 的一种。指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。

 使用  包
    
     余弦相似度
    _ =   =
     莱文斯坦距离
    _ =   =
     转化为  范围 
    __     _      

疑问词是否一致
_ 两个问题的疑问词是否一致
如果两个问题的疑问词不同，那么他们相同的几率会小一些。
 计算两个问题的疑问词是否一致
       
    _ =  
         {
        _     = 
          _ == {
            _ = 
            
        }  _ == {
            _ = 
            
        }
    }
由于变量 _ 是二分值，可以直接查看它和 _ 的 
 加载包
    
    _ _  = 

     结果 
       

              
                
                
               

                                
                         
                      
                            

                                  
                   

                            
                            
                           
                           
                             
                          
                    
                       

                
准确率只有 ，基本和随机猜测没有什么区别。 
相关系数
我们看一下几类参数的相关系数

       _______
     画图
     = ===
     = = = ==== =

从上图可以看到几个特征之间的相关性比较低，都相互独立。
更多特征
前面所有的特征都是基于将问题本身作为字符串来看待，特征只都是来衡量两个字符串之间的相似度。而预测目标其实是语义上的相似，所以上述的特征只能近似的来衡量两个问题的相似度。
更多的关于语义的相似度特征，例如同义词、 、  等，主要由于这些特征计算量都比较大而没有实施。
参考文献

     引言
 在学习操作系统时，经常会做一些服务的配置实验，本地主机搭建练习繁琐，面对初学时的困难繁琐，如何降低实验学习的门槛呢？用真实应用场景的云主机，最大还原真实工作场景，让学习不再枯燥。本系列教程主要针对操作系统试验教学为原型，还原简单实验。
概述
  接触听的最多的就是服务，为什么应用这么广泛呢？  原因是最先在和两个平台之间建立了桥梁，服务器的主要功能就是实现与之间的资源共享。  那么今天，我们就来用腾讯云服务器配置服务，使与资源共享。
实验概述
匿名共享登陆
服务器设置要求

 公司现在有一个工作目录，需要添加服务器作为文件服务器，并发布共享目录共享名为，此共享目录允许所有员工访问。

配置思路
 编辑主配置文件设置全局变量。 在文件中指定日志文件名称和存放路径，并设置权限。 设置共享目录的本地系统文件及文件夹 重新启动服务，使配置生效。 客户机访问测试服务器，检验配置是否正确。
具体配置步骤
准备云服务器
服务器选型

操作系统选择镜像市场的全能型环境    系列以便后面教程使用选择存储与网络保持默认不变设置信息
命名主机名可自己设置端口是服务远程连接端口是远程连接端口安全组选择：默认安全组放通全部端口
支付
学生优惠政策，学生认证后可领取元代金劵生产成功
连接服务器
打开，复制公网，连接服务器
注意：主机名为公网，连接类型选择
第一次连接会接受密钥点击确认并输入用户名 密码
安装
      

查看安装情况
  | 


__ 主要提供服务器的设置文件与设置文件语法检验程序
__                     客户端软件，主要提供主机作为客户端时，所需要的工具指令集
__ 里的是作为域成员的一个中介。它可以把域帐号里的用户和组信息，映射成的用户可组。 包里包含上面说的做映射的服务库 和客户端工具
__   包里只含有客户端工具 ， _                     服务器端软件，主要提供服务器的守护程序，共享文档，日志的轮替，开机默认选项

创建共享目录以及共享目录下的文件
 
  
  
  
  
  

设置要共享目录的属性权限任何人都可访问设置匿名用户可以下载或上传共享文件，所以要给目录授权为权限
    
  
注意：这里是的小写
查看服务器状态
启动服务器可以通过 来启动、关闭、重启服务
  
查看服务器状态
   

配置服务器
服务器配置目录是的核心配置文件，是的启动关闭文件。
命令
   
删除原有内容添加如下内容
  
  该设置与服务整体运行环境有关，它的设置项目针对所有共享资源       
     
         =                              
        定义工作组，也就是中的工作组概念
          =         
        定义服务器的简要说明
          =                          
        定义中显示出来的计算机名称
    
          =                   
        定义用户的日志文件，代表客户端主机名
        服务器会在指定的目录中为每个登陆主机建立不同的日志文件
    
         =                                   
        共享级别，用户不需要账号和密码即可访问
===========   ========

        设置针对的是共享目录个别的设置，只对当前的共享资源起作用
         =                              
        对共享目录的说明文件，自己可以定义说明信息
         =                                      
        用来指定共享的目录，必选项
         =                                       
        所有人可查看等效于  = 
重启服务测试配置是否正确
  
 

连接服务器共享目录
 
回车后无需输入密码，直接回车，最后  命令查看共享目录的内容注意：此处的域名为你自己服务器的公网
连接服务器共享采用快捷键键唤出运行窗口输入服务器的地址格式 \共享目录 共享文件

下一篇：「腾讯云的种玩法」服务器配置系列二服务器的配置待续

参考目录【】高等教育规划教材《操作系统原理与应用》 赵国生 王健等编

相关推荐
【腾讯云的种玩法】 为  设置特定启动提示信息
云服务器下搭建服务器
高性能高稳定的弹性伸缩计算服务在之前的权限管理的文章中，我们了解了文件权限的基本内容和相关内容。今天我们来讲讲文件权限管理的另一个内容：文件特殊权限
文件特殊权限是权限管理中比较难的一部分，分三个小内容，分别是：、和。
第一部分：
首先了解一下主要功能：当用户执行某一程序时，临时获得该程序所有者的身份非所有者以所有者身份运行
这样的说法难免有些晦涩，打个比方：
普通用户是没有文件的权限的，但是仍然可以修改自己的密码，原因就是修改密码的命令“”拥有权限。
                      查询命令所在目录

            查看文件权限
                     标红的代表权限
反例：命令没有权限，所以普通用户无法查看 文件。
由上面的例子，我们可以知道
只有可执行的二进制程序才能设定权限。给一个非程序设定是没有意义的
命令的执行者必须对该程序拥有执行权限，否则没有没有意义。
权限只在程序运行的过程中有效。普通用户变身为超人的时间和限制是非常严格的
所以，大家在设定是时一定要十分谨慎，因为权限是十分危险的！假设你给设定的权限，那么任何人都可以直接修改系统关键文件，包括但不仅限于文件。
好了，了解完的知识，终于可以设定权限了。
如何设定权限？
有两种方法：我以命令为例
          代表权限
            两种命令意思相同
输完上面的命令，我的普通用户也可以  文件了。这里不再演示。
如何删除权限？
很简单，将权限再次指回即可。
  
      

在最后再次重申的危险性，为了保证服务器安全，我们应该
对关键目录严格控制写权限，如 “”   “” “”
用户的密码严格设置并且遵守密码三原则
对系统中拥有权限的文件作一列表，并且定期检查。

相关推荐
云服务器下搭建服务器
【腾讯云的种玩法】系统文件权限的系统阐述与演示
 快速入门云服务器前言
在  前端开发中，我们会借助 、 和  等工具的  模块去监听文件变化，那服务端应该怎么做？其实文件变化的监听依然可以借助构建工具，但我们还需要自动重启服务或者热重载。本文将介绍三种常见的方法。
方案一：
使用  原生的  方法监听文件改动，所谓的“热重载”也不过是及时清除内存中的文件缓存。示例如下：
  = 
     = 
     = __ 

  =  = {
      启动 ，自动检索到 
     {  监听文件夹
         {   } 
    }  {
          
    }
}
 清除缓存
  =  = {
      {
         \\\\\\ {
             
        }
    }
}
 启动开发模式

注意：在服务器入口文件  中引用中间件时需要套一层函数，并使用  的方式引入模块才能清除缓存。比如：
 引入中间件或控制器
   = {
     
}
 或引入路由
   = {
      
}
方案二：应用进程管理器
此处以  为例，、 等类似的进程管理工具异曲同工，这里不再赘述。
 是一款带有负载均衡功能的  应用进程管理器，具有 — 配置项，用来监听应用目录的变化，一旦发生变化，立即重启。详见：     。他是真正意义上的重启，不是热替换。
缺点： 并不提供优雅的方式告知用户何时重启或者杀掉进程。以下是一个简单的  配置 开发环境 ，启动进程  。
  = 

 {
      {
        
        
    }

    {
           开启  模式，并监听  文件夹下的改动
        _ _   忽略监听的文件
        _ {
               不允许符号链接
        }
         
            入口
        _   开发模式下建议使用 
           仅启用  个 
        __   当占用  内存时重启 
    }   {
            
           
    }
}
每次修改文件之后保存，会有个黑框闪一下，说明应用已经成功重启了。
方案三：  
 是对      的一层封装。它的优势包括解决出自  文档：
、在   下不能获取文件名；
、在   下  修改文件后不能获取到修改事件；
、修改文件会触发两次事件；
、不提供文件递归监听；
、高  使用率；
、…
这里使用  的原因是想要支持最新的  语法，包括 、，以及     等模块语法。
下面提供一个完整的监听重载配置文件，并通过注释说明功能和意义。
  = __ 
     =       源文件
     =       编译后输出文件夹
     = 
     = __ 

 启动  监听文件改动
   {
      编译文件夹目录
    {
         
         
         
    }        

      启动 编译后的文件

     添加监听方法
    
         文件新增
           {
                
        }
         文件修改
           {
                
        }
         文件删除
           {
              =  
              =  
             {
                
                  
            }   {
                   
                
            }
             
            ； 清除缓存
        }
}

 动态编译文件
      {
      =  
         =  

     {
        {
             
             
             
             
             
             
        }    {
             
             
             
             
             
        }
    }   {
              
        
    }
          
        通常为清除缓存
}
 清除缓存
   {
      {
         \\\\\\ {
             
        }
    }
      
}
 监听程序退出
   {
     
}
注意：为了能让缓存失效，我们同样需要在  里包裹一层函数，并以  的方式引入路由
   = {
      
}
方案四：开发插件
 和  都是可用于  开发版插件，提供简单易用的开发环境。以  为例，全局安装或本地安装都可   然后通过     启动开发进程。独立、简单，好用！
详见：
综上

每个方法都有不同的适用场景。如果想要尝试最新语法，推荐试用方案三；如果追求简单快捷，方案二是不错的选择。
这就结束了吗？
如果我既想用最新的语法特性，又需要像  那样简单，怎么办？ 构建工具如 对于每个前端开发并不陌生，再加一款  足以解决所有问题。智能交通云在刚刚举办的腾讯“云未来”峰会上，成为瞩目焦点。交通与物流智能化的领军人物就腾讯云新发布的“人工智能即服务”战略展开了讨论与分享。腾讯云也由此率先在交通物流行业落地商业实战能力。
腾讯云助力智能交通物流 邱跃鹏：云是无人驾驶的高速公路
“腾讯“云未来”峰会于月日在深圳举办。在峰会上，顺丰集团、顺丰科技田民，蔚来汽车创始人、董事长李斌，驭势科技联合创始人、吴甘沙分享了各自对于智能物流、未来交通形态等方面的探索与实践；并与腾讯副总裁、腾讯云总裁邱跃鹏，腾讯云副总裁曾佳欣在圆桌讨论中进行了观点的深度碰撞。”
腾讯互联网交通解决方案分享
腾讯互联网城市服务是对公共服务的聚合，以满足一站式业务查询办理需求，目前服务上线个城市，服务亿民众腾讯的互联网交通解决方案，可以从高效、智慧、便民、安全四个方面帮助到政府、企业和群众。高效：提升道路通行效率，提升交管执法效率，提升群众出行效率，提升交通运营效率智能：群众交通服务智能化，大数据交通规划决策，大数据交通态势分析，交通智慧监管便民：交通服务线上化，服务缴费移动化，证件电子化，验名核身线上化安全：保障业务系统安全，保障业务运维安全，保障信息安全，保障用户安全
摩拜的六脉神剑：每日  万次出行服务背后的技术支撑
摩拜接入腾讯云之后，不仅仅是用了腾讯的计算、存储、网络等基础设施，还得到了腾讯非常多的技术团队的支持，帮助摩拜高速成长。应对攻击，协助数据迁移，解决海量短信的发送等等具体问题
老司机们，传说中的电子证件真的来了！
深圳交管部门携手腾讯“互联网警务”联合团队，在微信城市服务推出电子行驶证和电子驾驶证， 微信证件首次实现线下应用场景。车主在遇到路面执法，或前往窗口办事等情况时， 微信证件即可完成身份认证，避免证件不在身边带来的罚款、扣车或怠误办事等情况
互联网警务落地再下一城！热力图助力南京秦淮灯会安保勤务 
腾讯和南京市公安局的一项合作：利用了互联网高科技手段，结合了南京本地历史大数据与腾讯地图的大数据。通过腾讯地图的热力图，保障秦淮灯会的安保勤务。是一个面向中学生的陌生人社交应用。简单来说，它是一个只允许中学生注册的“陌陌”。
它是一个初创的社交应用，前期以快速的功能迭代开发为主，尽可能的降低开发成本、时间成本，验证市场。要达到这个目的，我们团队尽可能的使用现成的第三方服务，挤压时间来对开发核心功能。
云计算高速发展的这几年，、雨后春笋般涌现，为应用开发团队提供了各种各样的云服务。怎么从众多的云服务商中选出最适合的一个？
我们选用腾讯云，来作为我们后端服务的根基：
一是腾讯产品的浓厚社交基因，跟我们陌生人社交的产品基因吻合的，众多腾讯自己的社交产品都使用腾讯云；二是腾讯云提供了众多社交产品所需要的功能解决方案，如云通信、短视频、直播等；三是根据团队研发人员过往的云产品使用经验，腾讯云在性能、稳定性方面有更为卓越的表现。
我们的后台服务开发过程中，除了核心功能逻辑是由自己开发团队实现外，数据库、数据分析、域名、监控、聊天、社区等等环节，我们都利用了腾讯云云服务来加速我们的产品部署。
整体技术架构

我们的服务器逻辑，使用语言，因为其具有轻量、开发快、易部署运维的特点。它的单进程单线程编程模型大大降低了软件开发的复杂度，对于初创团队而言，还能用相对低廉的价格招聘到适合的工程师。
其中数据存储的环节上，、、、对象储存，我们全部都利用了腾讯云的相关数据服务产品。因为根据我们的经验，数据管理，是产品运维中一个比较折腾的点，要做好数据管理相关的性能、监控、备份、回档、扩容、分布式等等环节，是相当不容易的一件事。所以我们使用了腾讯云提供的数据服务，降低“趟坑”的可能性。
选购云主机很容易陷入一个误区，就是一开始就选用一台性能牛逼的云主机，每个月在云主机上就投入了不少金钱。相对于其它主流语言如、，虽然的执行性能并不好，但是它简单轻量，非常适合进行开发，部署非常简单。考虑到以后假如遇到并发问题了，利用负载均衡，我们只需简单的增加一台逻辑服务器即可。由于数据服务是剥离的，云主机本身仅仅是进行语言的执行工作，一开始我们可以选购一台低价的云主机即可。
核心功能模块
地理位置定位
作为一款陌生人社交应用，其最核心的功能非“附近的人”莫属了。技术上怎么高效的实现附近的人？比如说怎么快速的找出附近的人？ 难道使用数据库筛选出所有用户，并分别获取它们的经纬度进行距离计算？
我们的地理位置定位，使用了算法：用字符串来表示经纬度两个坐标。表示的并不是一个点，而是一个矩形区域。
比如某个经纬度，转化成的字符串是，我们要找到这个经纬度附近的人，使用语句  来高效的进行附近的人筛选。
图像服务
社交应用，有大量的用户上传照片。在云服务广泛应用之前，开发人员自建文件服务，还得自己购买硬盘，不但价格高昂，还有各种各样的运维问题需要解决，比如，机械硬盘到达生命周期结束怎么办？备份的工作怎么进行？
使用云存储，就有很多好处，价格低、易扩容、稳定安全，还可以轻松跟内容分发网络配合，提升用户客户端下载图片的速度，优化用户体验。
数据服务
前面总体架构提及过，我们的数据服务，均使用云服务，而不是自己搭建。那么，我们分别用这些数据服务，做一些什么事情？
关系数据库 
数据库是整体社交的数据重心，重要、基础的数据都储存在里面，比如用户信息、用户地理位置。
云存储 
云存储，保存一些次要、周边的功能系统，比如说用户之间的拜访记录、点赞记录等。要注意的是，很多时候与配合，是作为缓存的角色出现的，而我们这里是作为数据库。
弹性缓存 
主要是作为缓存服务，做性能优化。比方说，“获取附近的人列表”，是一个很消耗数据库性能的计算，因此每一次计算，我们会把附近的人列表，保存成一段时间的缓存，来防止用户不停的刷新附近的人列表来大量消耗服务器性能。
短信验证码
现在一款手机应用，通过手机号码验证码验证进行注册的方式几乎成为了标配。因此我们使用腾讯云的短信服务，来实现验证码功能，每条短信几分钱。
云通信
既然是社交应用，聊天功能怎么能少？自研一个聊天系统，可谓一个浩瀚的工程。能不能直接使用像、微信一样的聊天系统来为我服务？ 腾讯云的云通信，就是这样的一套强大的。
经验分享
前面的这些技术架构选型，离不开一个“快”字。 不光技术上如此，我们的产品和团队管理同样也基于“快”的原则做过一些尝试。
产品设计原型
我们使用 进行的原型设计。 好的原型设计，能让美术和客户端更快的完成他们的工作，比满口的空话、满屏的文字来得实在得多。
团队管理软件
目前我们的团队成员，有异地办公。 怎么确保工程进度完成，团队协作工具必不可少，总不能老是把各种文档通过传来传去吧？
我们探索过 等协作工具，考虑到小团队的敏捷性，最终我们还是选用最简单的方法，就是直接用上了云共享笔记。
开发环境应用
在以往，开发、运维环境不一致，是一个开发人员、运维人员很头疼的问题。的出现解决了这个问题，我们开发人员，使用来搭建整个逻辑服务器的开发环境，诸如、等软件的版本，是跟生产环境完全一致的，来避免踩坑。
未来
现阶段我们的产品还属于初期，快速的功能开发、扩充业务为主要目的。我们广泛应用的腾讯云云服务，为我们减少了大量的金钱、时间成本。
随着业务发展，我们计划未来会更多的利用腾讯云其它云服务，比如机器学习、消息队列、直播方案、短视频方案等。这些都是我们未来产品发展所需要利用的功能。



相关推荐
如何用腾讯云打造一款微视频
如何用快速在腾讯云上开发小程序系列：搭建    服务器  是基于腾讯云强大计算能力的一站式深度学习平台。它通过可视化的拖拽布局，组合各种数据源、组件、算法、模型和评估模块，让算法工程师和数据科学家在其之上，方便地进行模型训练、评估及预测。月日，腾讯海量计算及智能学习总监黄明先生在在「云未来」峰会现场正式对外介绍了这款深度学习平台产品。
以下是黄明先生的分享全文：
大家好，今天由分享的是由腾讯数据平台部和腾讯云联袂合作的打造的产品，。这是腾讯云上的深度学习平台，对腾讯云升级为云有着重要的意义。
今天是大数据的专场，大家都知道在过去两年，人工智能得到了迅猛的发展，这主要是因为三个要素：第一个是大数据，从年—年，互联网行业有了丰富的大数据积累，这给人工智能提供了一个充分的训练数据。第二个是大计算，在过去两年，基于的计算能力突飞猛进，给人工智能提供了一个非常好的加速器。第三个就是深度学习，在年到年，各种深度学习的框架、算法和模型纷纷涌现，改变了人工智能的派系格局和研究的方向。
基于这三个要素，在过去两年期间，人工智能得到了迅猛的发展。参考这三大要素，我们来对标一下腾讯云的产品。
首先腾讯云有，这是一款比较经典的产品，目前它的存储量已经达到了＋，这是非常可观的数字，大数据我们已经有了。其次我们有云服务器，这是我们今年刚刚推出的产品，在上面用户可以进行的申请，获得一个单机实例，并进行的计算，这样大计算我们也有了。那接下来就是深度学习平台了，我们推出了，通过它把和连接到一起，打通这两个产品，形成合力。 
我们来看一下这个平台的架构。首先我们可以看到是接入到存储的，在上面有丰富的用户数据，包括各种各样的文本、图片、语音和视频。而在的底层，我们通过这个资源管理器，对底层的、、内存和硬盘进行统一化的管理。资源上面是框架层，我们结合了三大框架，包括、和，基本可以满足大部分用户的需求。再上一层是算法层，目前我们集成了、、、这几类，在上线之后，我们会根据用户的反馈做进一步的丰富。再上面是模型层，用户对数据计算之后会产生一系列的模型，包括图形模型、语音模型、时序模型、视频模型和模型等等，这些我们会在里面进行一个统一的管理。整体基于这个平台，我们给上层的用户，包括其它中小企业提供更好的服务，包括图像识别、语音识别、精准推荐、实时风控等等。
有些用户可能会觉得，有了和之后，我们其实并不需要这样一个平台，用户也可以在上面玩深度学习，有一个平台反而会束手束脚。那到底会带来什么样的变化呢？接下来，我从个方面来介绍一下带来的变化，包括资源、框架、调度、调参、模型和预测这个方面。
首先我们来看一下资源，如果没有的话，它的资源申请是一个用户到实例的级别，在云服务器上，现在有两个类型，一个是，一个是，用户申请之后是要按月付费的，这是一个比较粗的力度。有了之后，我们现在是基于，它使用和的技术，能够对底层的资源进行优化和管理，这样分配资源的粒度就按照工程和卡数的关系来分配的，它的粒度更细，也更灵活，而且后续也可以做到按照运行时长来收费。
第二部分我们看看框架，在没有的情况下，从运行一个实例到跑出一个算法，如果是没有经验的人折腾一两天是很正常的事情。我们可以看到，在整个的过程，包括了系统准备、安装，安装、安装深度学习框架、对接存储，也就是需要把你的代码和存储做一个对接，当这些打通了之后，算法规程师才可以上传算法，然后启动一个脚本，把这个任务运行起来。这个过程中只有一个是红色的，只有这一步是算法工程师是擅长的，其它几步对工程能力弱的人来说都无疑是很难的，分分钟会可能卡住走不下去，而且这都是重复性的事情，用户做了，用户还要继续做，他们的工作不能被复用。
有了，这个事情就非常简单了，基于一个可视化的拖拽过程，用户只需要拖一个组件出来，然后设置一下参数，包括算法参数和资源参数，点一下运行就可以了，省去了大量重复的劳动，目前我们支持、和三个组件，算法方面我们也支持这样的方式，让用户做到即拖即用，释放一个算法工程师的生产力。
第三方面我们看一下调度，如果没有的话，用户可能写完了一个算法之后，调试好了，它需要定期运行。很传统的做法是用一个或者它的增强工具，这个工具是很灵活的，它有很复杂的配置语法和条件，配合一些奇怪的需要的脚本，其实它是能做很多事情的。但它的缺陷也是很明显的，就是它的可维护性是非常差的，需要人工大量的干预。为此我们在调度上有种驱动方式，除了正常的手工驱动之外，我们还支持定时驱动、重调驱动和参数驱动这三种方式，每种方式都有良好的调试界面可调节，用户可以自主设置三种驱动方式的并发度，让用户得到一个最大的便利性。第四是调参。我们刚刚留意到有一种调度方式就是叫参数，这是为了深度学习的调参功能，在之前，用户需要写脚本，进行各种各样的参数调节，通过多种循环来进行参数的组合，然后传给具体的任务，达到调参的目的，但是这种方式其实是风险比较高的，对于写脚本的人来说，对他的能力有一定的高要求。而且一旦习惯了这种方式，很多人就会对平台有一个奇怪的要求，希望我们平台可以去支持一个组件，在这个组件里面写一个循环来调、或者，这是非常危险的方式，会让系统形成一些黑洞，这是不好的。为此增加了一个自动化的调参工具，它有个步骤，第一个是它能够进行多参数的循环组合，第二是它会预生成实例，因为参数形成组合之后，它会有很多的组合产生，这时候是预生成的，当系统的并发度满足条件的情况下，我们才会进行这个参数的真实替换，并且生成多实例并发运行。
这里我们举一个简单的例子，在机器学习中是非常简单的，类似于超参数调节的东西，它有两个参数，第一个是数字型的，第二个是字符串型的，提供这样的功能，经过这样调参之后，可以方便用户进行比较。这是目前的自动化调参，后续我们会针对深度学习的超参数调节进一步优化。
第五个模型。在之前，其实用户训练完了之后会有一个模型文件的生成，、和都有自己的格式。用户为了把这个模型进行一个同步和上线，其实有一种最常见的方法就是用，在不同的用户之间来，去，在这里面它没有版本的管理，同时它也依赖具体运维人员的靠谱程度，决定模型的命运，包括它如果覆盖错了，有可能一个效果好的模型，就会被效果差的模型覆盖掉，这时候效果是非常难以把控的。
为此我们推出了一个模型的概念，在中对模型进行了针对性的设计，我们把这个设计叫做小尾巴，目的就是把一个模型具像化，在一个深度学习算法里面，它的左边有一个小尾巴，里边有一个小沙瓶，在算法模型运行的过程中，这个小烧瓶不停地冒泡泡，代表它是在运行，在炼丹，这在机器学习中是一个非常常见的名词比喻。当算法结束之后，这个小烧瓶也就满了，代表机器学习过程完成了。这是一个把模型从抽象到具像的过程，当这个模型训练完之后，它有丰富的行为，我们可以把这个模型进行收藏、导出和分享。收藏模型之后，这个模型就会被收到个人模型这里，成为一个模块，它可以被拖拽出来到画布，而分享模型，你可以把它分享给你想要合作的同事，你的模型就会出现在他的共享模型里面，他也可以直接把它拖拽出来使用，
第六个就是预测。其实就是一个训练和预测分离。我们知道深度学习里面，预测是一个非常重要的概念，模型训练完之后只是走了第一步，模型的使用，也就是预测才是更加重要的一个工作。目前我们这样一个模型拖拽出来之后，它会变成一个圆圆的一个大节点，可以对数据进行的预测推理，关于模型的在线预测功能，我们正在加紧上线中。
那综合以上点，我们来看一个预发环境的线上任务流第一个是六边型数据节点，它会去检查路径上的数据在不在，并将路径传递给下一个节点作为输入。第二个是长方形的算法节点，带着一个模型训练的小尾巴，跑完之后，它的输出继续传给下一个节点第三个是圆形的模型节点，它是之前训练好模型，用于对上游节点的数据，进行直接批量的预测，得到最终的结果整体上看，这是一个多元素的任务流，有点复杂，但是相当灵活。门槛不高，用户熟悉了之后，很容易上手。
整体来看，是一个融合了深度学习的框架、算法、模型训练、模型推理和协作的一站式深度学习平台，在它上面可以完成一个深度学习的闭环，直接对之前存储在上的数据快速的进行挖掘，而得到的模型又能够快速的部署，降低人工智能的门槛。
的目的，最终是提升中小企业接入人工智能的速度，也是让腾讯云实现弯道超车，加速成为一个智能云的重要产品，目前正在进行最后的准备阶段，很快就能让大家正式使用，敬请期待，谢谢大家！简介
是一个支持，，等服务的缓存代理软件，它可以通过缓存页面来提高服务器的相应速度并降低带宽占用。并且，还具有强大的访问控制功能。可以运行在各种操作系统平台上。
会将访问页面的结果缓存在硬盘和内存上。所以对硬盘和内存的空间大小具有较高的要求。内存和硬盘越大，缓存的命中率就越高。但是真实服务器数据是实时更新的，因此，我们就需要不定期的清空缓存数据以保证用户访问结果的准确性。
代理服务器原理
原理：客户端访问代理服务器，由代理服务器代表客户访问后端真实服务器，真实服务器将响应的数据返回给代理服务器。最后，代理服务器将响应结果返回给客户端，同时将结果缓存在硬盘上及内存中，当客户端再次访问相同的网页时，代理服务器直接将响应结果返回给客户端。
安装服务
 系统的安装光盘中自带了的格式的软件包。
     
    
服务端：

软件包：_

系统服务：

主程序：

主配置文件：

默认监听地址： 

默认访问日志：

默认缓存日志：


常见代理服务器类型
代理服务器有多种类型，一般意义上常分为标准正向代理服务器，透明代理服务器，反向代理服务器。
正向代理服务器主要应用于内部网络希望访问外部网络时缓存页面数据。由于公网地址稀缺，企业内部成百上千台计算机不可能同时大欧连接到上，目前的解决方案就是通过一个统一的网络接口连接。就可以提供这样的接口。所有的客户端通过设置代理服务器连接值，通过代理上网。此模型下，主要负责提供缓存加速服务和访问控制的功能。正向代理是对用户的一种操作。
透明代理与传统的正向代理相似，区别在于传统的正向代理需要每个客户端都进行代理服务器的设置。而透明代理通过网关进行部署。即，所有的设置都是由管理员在网关服务器以及代理服务器进行的。因此，透明代理对于用户是透明的，不需要用户进行任何设置。
反向代理结合智能可以实现基本的框架。通过的分离解析功能，可以为不同地区的请求解析不同的结果返回给客户端。用户访问时，感觉不到是在访问代理服务器。由于使用到了缓存技术，当大的并发量到达时，也可以更快的给用户返回响应结果。反向代理结构如下图所示。

配置文件解析
安装好包后，默认的配置文件为。支持功能非常丰富，配置语句也较多。下表给出了主要的配置语句以及相关说明。

反向代理案例
案例需求
通过配置代理服务器，实现以下目标：

代理服务器可以将远程的服务器页面缓存在本地

代理服务器端口设置为端口

用户通过访问代理服务器即可获得远程服务器上的页面内容

远程服务器对客户端用户是透明的

利用缓存机制提高网站的响应速度


方案
使用台虚拟机，其中一台作为代理服务器，该服务器用来连接两个网段，因此需要配置两块网卡，地址分别为和。一台作为客户端测试主机，地址为。一台服务器，地址为，该服务器为其他代理提供数据源，拓扑图如下图所示。

实现步骤
步骤：在主机 上构建服务器

在服务器上安装软件包，并部署主页。

     _   安装软件包
                        重启系统服务
        搭建主页
    |                     查看端口是否是服务监听 
                                                           
步骤：部署代理服务器

在代理服务器上安装软件包

      _   安装软件包

修改服务的主配置文件

     
        
        _                                    设置反向代理
        _                         设置主机名
        _                                 允许本机所有主机使用代理服务器
        _        定义后台真实服务器信息
        _                定义硬盘缓存路径，总容量，一级目录个数和二级目录个数
        _                                      定义内存缓存大小，注意和之间有空格
        

启动系统服务，并查看端口

    
    |  
                                                                                      
                                                             确定端口为服务监听状态
步骤： 客户端上测试代理服务器结果

通过更改文件来做域名和解析服务

   

 


使用浏览器来测试访问结果。使用选项测试可以看到头部信息。

   
  
    
  
      
      
      
 
 
 
  =
 
               
   
   
   
 
总结答疑

修改配置文件时，注意不要改错位置。否则，服务无法启动

启动服务时，若配置文件没有错误。但服务仍然无法启动，则查看端口是否被其他服务占用。


    |  
比如端口被服务占用，则停掉服务。
    

相关推荐
云服务器下搭建服务器腾讯云搭建代理服务器作者：

什么是
 是一个分布式的、开源的协调服务，用在分布式应用程序中。它提出了一组简单的原语，分布式应用程序可以基于这些原语之上构建更高层的分布式服务用于实现同步、配置管理、分组和命名等。 设计的容易进行编程，它使用一种类似于文件系统的目录树结构的数据模型，以  方式运行，有  和  的绑定。
分布式系统中的协调服务总所周知地难于正确实现，尤其容易产生诸如争用条件  、死锁 等错误。 背后的动机就是减轻分布式应用程序从头做起实现协调服务的难度。
数据模型
 会维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统，如下图所示：

 这种数据结构有如下这些特点：

每个子目录项如  都被称作为 ，这个  是被它所在的路径唯一标识，如  这个  的标识为 
 可以有子节点目录，并且每个  可以存储数据，注意  类型的目录节点不能有子节点目录
 是有版本的，每个  中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据
 可以是临时节点，一旦创建这个  的客户端与服务器失去联系，这个  也将自动删除， 的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为 ，如果  是临时节点，这个  失效， 也就删除了
 的目录名可以自动编号，如  已经存在，再创建的话，将会自动命名为 
 可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个是  的核心特性， 的很多功能都是基于这个特性实现的。

简洁的
 的设计目标之一就是提供简单的编程接口。于是，它只提供了以下的操作：

 ： 在命名空间树的一个特定地址上创建一个节点

 ： 删除一个节点

 ： 检测在一个地址上是否存在节点

  ： 从节点读取数据

  ：将数据写入节点

  ：检索子节点列表

 ： 等待数据传播完成


谁在用？
如小米公司的米聊，其后台就采用了作为分布式服务的统一协作系统。而阿里公司的开发人员也广泛使用，并对其进行了适当修改，开源了一款软件，以适应自身业务需要。另外还包括 、 、 等产品也都使用了。
应用场景

数据量比较小，但对数据可靠性要求很高的场景，比如管理分布式应用的协作数据。
不能做什么

不合适做海量存储，因为它主要用来管理分布式应用协作的关键数据。对于海量数据，不同的应用有不同的需求，如对一致性和持久性的不同需求，所以在设计应用时，最佳实践应该将应用数据和协作数据分开，况且对于海量数据我们的选择很多，如数据库或者分布式文件系统等。

不要让 来管理应用程序的缓存，而应该把这些任务交给客户端，因为这样会导致的设计更加复杂。比如，让来管理缓存失效，可能会导致在运行时，停滞在等待客户端确认一个缓存失效的请求上，因为在进行所有写操作之前，都需要确认对应的缓存数据是否失效。


应用与 进行通信
那么当应用作为整个异构分布式系统中的一环，需要作为客户端去操作 上的时，应该如何实现？
说实话，上文介绍了这么多的原理，其实作为客户端只需要单纯的把作为文件来操作就好，并且可以监听的改变，十分方便。本文只描述怎样使用实现客户端角色。

是的一个客户端实现，这个模块是基于原生提供的 来实现的。
下载  
栗子
  =  
  =  {
      的服务器地址和监听的端口号
    以毫秒为单位
 _ ___ 
 __  
}
  {
      
        = _
    _    _ | _      {
          =  {
                    =   
        }  {
                 
              {
                 
            }
        }
    }
}

其中：

 包含主机名和服务器的端口。

：以毫秒为单位，表示等待客户端通信的最长时间，之后会声明会话已死亡。的会话一般设置超时时间秒。

_：设置日志的输出级别，有四种级别：___ ___ ___ ___。

__ 初始化客户端实例后，该实例是否是按确定顺序去连接 集群中的主机，直到连接成功，或者该会话被断开。


常见：

：连接 

_    _ 创建一个，并赋值，可以决定这个的节点类型永久、临时、永久有序、临时有序。

_  _  我们想要获取数据的节点路径。  表示我们是否想要监听该节点后续的数据变更。_     ： ，为成功。 ：错误信息。：的元数据信息。 中的数据。

_    _  需要注意的是，并不允许局部写入或读取的数据，当设置一个节点的数据或读取时，节点的内容或被整个替换或全部读取出来。 我们想要设置数据的节点路径。：我们想要设置的数据，一个节点可以包含任何数据，数据存储为字节数组 。字节数组的具体格式特定于每个应用的实现，不直接提供解析的支持，用户可以使用如、、或等序列化协议来处理保存在中的数据格式，一般编码的字符串就够用了。：的，从中抽取出来的。_   设置数据的回调。

 关闭客户端连接。

_  _ 判断是否存在。

    ：删除，结尾加上是为了不和保留字冲突。。。


实现对指定节点数据进行的
 

  = 
  =   打日志的工具
  = 
 _ = 
 _ = _  _ 
  = _ ===     
  =   单位毫秒
  = _ ===   _  
 _ = ___
 __ = 
  = {
    
    
    _
    __
}

  {
     {
         = 
        _
    }

    _ {
         =   || 
    }

    
        
       {}            
     
     {
            = {
              = 
             {
                  {
                    
                    
                }
                   = _

                _      {
                      ==  {
                               = =    
                        
                    }  {
                             
                                                
                    }
                     = {}
                }
            }
        }
    }

    
        _
       {}    
      {
           {
              _ 
              _ 
          }
           {
              _ 
              _ 
          }
      }
     
     {
          = 
          = 
            = {
             {
                  {
                    
                    
                }
                   = _

                _      {
                      ==  {
                               = =    
                        
                    }  {
                            
                          
                           
                         {
                             = 
                        }   {
                            
                            
                        }

                        __ =     
                        _ 
                          = 
                         {
                             = 
                        }   {
                            
                            
                        }
                        _      {
                              ==  {
                                       =   
                                
                            }  {
                                   
                                

                            }
                             {
                                
                            }
                        }

                    }
                }
            }
        }
    }

    
        
        {}        要删除的黑名单的号
       {}            
     
     {
          = 
          = 
            = {
             {
                  {
                    
                    
                }
                   = _

                _      {
                      ==  {
                               = =    
                        
                    }  {
                            
                          
                           
                         {
                             = 
                        }   {
                            
                            
                        }

                        __ =     
                             {
                             
                        }

                          =   只对这个被读取时的这个，否则会抛错。
                         {
                             = 
                        }   {
                            
                            
                        }
                        _      {
                              ==  {
                                       =   
                                
                            }  {
                                   
                                
                            }
                             {
                                
                            }
                        }

                    }
                }
            }
        }

    }

    
       
       {}         
     
     {
         只能以覆盖的方式
         
    }

     {
          = 
          = 
            = {
             {
                  {
                    
                    
                }
                   = _

                _      {
                      ==  {
                               = =    
                        
                    }  {
                          

                        __ =     
                         = 
                          = 
                         {
                             = 
                        }   {
                            
                            
                        }
                        _      {
                              ==  {
                                       =   
                                
                            }  {
                                   
                                
                            }
                             {
                                
                            }
                        }

                    }
                }
            }
        }
    }
}

 = 


原文链接：


相关推荐通过在中调用动态链接库文件一次  内存溢出作者 | 杨硕编辑 | 顾乡
腾讯云   镜像上线有段时间了，相信大家都用过了。我自己也用了，分享下我的经验。
 不通的问题，我根据发在群里的文档写成了一个文件，以后如果有用户遇到该问题，可以让用户在服务器里双击执行这个文件即可。


注意等号右边必须有个空格，不要把那个空格忘了。
利用禁用和开启  的方法如下：


自动安装脚本，把安装文件_________解压后，将放到解压后的文件夹里双击即可实现自动安装。
文件中的=这个参数是设置密码的话，执行之前可以根据需要修改密码。

目前还没有集成有环境的镜像。可以给用户推荐著名的护卫神套件，非常省事。
 
 ，系统应该用最新版本的。原来适用于和的的版本在上行不通。
    以及     
大家不要被后面的“ ”误导了，以为必须是才行，的就用不了。
其实系列的大多数应用都是通用的。 是 ， 是。   和   也是通用于 中的的。
  是个好东西，可以实现单站点多版本切换，好多面板工具都不具备这个功能，而 不是面板工具却有这个功能，真的很精湛而且界面很简单。喜欢 环境的人有福了，强烈推荐！
上的邮件服务器软件我目前还没有正式测试，之前在上测试过、、都还不错。相信在上也能表现良好。和是基于的、是基于的。感兴趣的同学可以先尝试下，欢迎跟我交流。
  自动安装文件双击执行之即可。先安装在安装。

调出桌面图标。
没有像专业版或旗舰版那样的右击→个性化→更改桌面图标，但是执行这个文件就可以调出那个设置窗口。



上帝模式直接看网卡。
新建文件夹→用“双击直接看网卡{}”重命名文件夹→自动变成了另一个图标→双击即可看到网卡。


相关推荐
【腾讯云的种玩法】自建 迁移云 过程小记【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群导语
传统的向量空间模型假设特征项之间相互独立，这与实际情况是不相符的，为了解决这个问题，可以采用文本的分布式表示方式例如  形式，通过文本的分布式表示，把文本表示成类似图像和语音的连续、稠密的数据。
这样我们就可以把深度学习方法迁移到文本分类领域了。基于词向量和卷积神经网络的文本分类方法不仅考虑了词语之间的相关性，而且还考虑了词语在文本中的相对位置，这无疑会提升在分类任务中的准确率。 经过实验，该方法在验证数据集上的值达到了，相对于原来业务中所采用的分类方法，有的提升。
业务背景描述

分类问题是人类所面临的一个非常重要且具有普遍意义的问题，我们生活中的很多问题归根到底都是分类问题。

文本分类就是根据文本内容将其分到合适的类别，它是自然语言处理的一个十分重要的问题。文本分类主要应用于信息检索，机器翻译，自动文摘，信息过滤，邮件分类等任务。


文本分类综述
 文本分类的发展历史


文本分类最早可以追溯到上世纪年代，那时主要通过专家定义规则来进行文本分类
年代出现了利用知识工程建立的专家系统
年代开始借助于机器学习方法，通过人工特征工程和浅层分类模型来进行文本分类。
现在多采用词向量以及深度神经网络来进行文本分类。

 文本分类的流程

 文档表示
如何把文档表示为算法能够处理的结构化数据无疑是文本分类非常重要的环节。
根据文本表示过程所使用的数学方法不同，可以分为以下几类：
基于集合论模型 布尔模型    基于模糊集的模型   扩展的布尔模型
基于代数论模型 向量空间模型   基于语义的文本表示
基于概率统计模型 回归模型  二元独立概率模型    语言模型建模模型
接下来会详细介绍一下布尔模型、向量空间模型、基于语义的文本表示。
 布尔模型
布尔模型：查询和文档均表达为布尔表达式，其中文档表示成所有词的“与”关系，类似于传统的数据库检索，是精确匹配。
例如：
查询：  世界杯   小组赛
文档：年世界杯在德国举行
文档：年世界杯小组赛已经结束

文档相似度计算：查询布尔表达式和所有文档的布尔表达式进行匹配，匹配成功得分为，否则为
布尔模型的优缺点：
优点：简单、现代搜索引擎中依然包含了布尔模型的理念，例如谷歌、百度的高级搜索功能。
 缺点：只能严格匹配，另外对于普通用户而言构建查询并不容易。
 向量空间模型
向量空间模型：把对文本内容的处理简化为向量空间的向量计算。并且以空间上的相似度表达文档的相似度。

每篇文档由、、、一共个特征项来表示，并且对应着、、 、个权重。通过以上方式，每篇文章都表示成了一个维的向量。
相似度计算：两个文档的相似程度可以用两向量的余弦夹角来进行度量，夹角越小证明相似度越高。

优缺点：
优点：简洁直观，可以应用到很多领域文本分类、生物信息学等支持部分匹配和近似匹配，结果可以排序  检索效果不错
缺点：理论上支持不够，基于直觉的经验性公式。  特征项之间相互独立的假设与实际不符。例如，会假设小马哥和腾讯两个词语之间是相互独立的，这显然与实际不符。

 基于语义的文本表示
基于语义的文本表示方法：为了解决特征相互独立这一不符合实际的假设，有人提出了基于语义的文本表示方法，比如主题模型，概率潜在语义索引等方法，一般认为这些方法得到的文本表示是文档的深层表示。而 文本分布式表示方法则是深度学习方法的重要基础。

 文本的分布式表示：词向量 
文本的分布式表示 的基本思想是将每个词表示为维稠密，连续的实数向量。
分布式表示的最大优点在于它具有非常强大的表征能力，比如维向量每维个值，可以表征的次方个概念。
事实上，不管是神经网络的影层，还是多个潜在变量的概率主题模型，都是在应用分布式表示。下图的神经网络语言模型采用的就是文本分布式表示。而词向量 是训练该语言模型的一个附加产物，即图中的 。

神经网络语言模型
尽管词的分布式表示在年就提出来了，但真正火起来是年发表的两篇的并随之发布了简单的工具包，并在语义维度上得到了很好的验证，极大的推动了文本分析的进程。
文本的表示通过词向量的表示方法，把文本数据从高纬度稀疏的神经网络难处理的方式，变成了类似图像、语言的连续稠密数据，这样我们就可以把深度学习的算法迁移到文本领域了。下图是的词向量文章中涉及的两个模型和。

：上下文来预测当前词

：当前词预测上下文
 特征提取
特征提取对应着特征项的选择和特征权重的计算。
特征项的选择就是指根据某个评价指标独立的对原始特征项词语进行评分排序，从中选取得分最高的一些特征项，过滤掉其余的特征项。
特征权重的计算：主要思路是依据一个词的重要程度与类别内的词频成正比代表性，与所有类别中出现的次数成反比区分度。
当选用数学方法进行特征提取时，决定文本特征提取效果的最主要因素是评估函数的质量。常见的评估函数主要有如下方法：
 
 ：词频，计算该词描述文档内容的能力 ：逆向文档频率，用于计算该词区分文档的的能力

思想：一个词的重要程度与在类别内的词频成正比，与所有类别出现的次数成反比。
评价：的精度并不是特别高。并没有体现出单词的位置信息。

 词频
词频是一个词在文档中出现的次数。通过词频进行特征选择就是将词频小于某一阈值的词删除。

思想：出现频次低的词对过滤的影响也比较小。
评价：有时频次低的词汇含有更多有效的信息，因此不宜大幅删减词汇。

 文档频次法
它指的是在整个数据集中，有多少个文本包含这个单词。

思想：计算每个特征的文档频次，并根据阈值去除文档频次特别低没有代表性和特别高的特征没有区分度
评价：简单、计算量小、速度快、时间复杂度和文本数量成线性关系，非常适合超大规模文本数据集的特征选择。

 互信息方法 
互信息用于衡量某个词与类别之间的统计独立关系，在过滤问题中用于度量特征对于主题的区分度。

思想：在某个特定类别出现频率高，在其他类别出现频率低的词汇与该类的互信息较大。
评价：优点不需要对特征词和类别之间关系的性质做任何假设。缺点得分非常容易受词边缘概率的影响。实验结果表明互信息分类效果通常比较差。

 期望交叉熵
交叉熵反映了文本类别的概率分布和在出现了某个特定词的条件下文本类别的概率分布之间的距离思想：特征词 的交叉熵越大， 对文本类别分布的影响也越大。评价：熵的特征选择不考虑单词未发生的情况，效果要优于信息增益。
 信息增益
信息增益是信息论中的一个重要概念， 它表示了某一个特征项的存在与否对类别预测的影响。

思想：某个特征项的信息增益值越大， 贡献越大， 对分类也越重要。
评价：信息增益表现出的分类性能偏低，因为信息增益考虑了文本特征未发生的情况。 卡方校验

它指的是在整个数据集中，有多少个文本包含这个单词。

思想：在指定类别文本中出现频率高的词条与在其他类别文本中出现频率比较高的词条，对判定文档是否属于该类别都是很有帮助的
评价：卡方校验特征选择算法的准确率、分类效果受训练集影响较小，结果稳定。对存在类别交叉现象的文本进行分类时，性能优于其他类别的分类方法。

 其他评估函数

二次信息熵 
文本证据权     
优势率 
遗传算法 
主成分分析
模拟退火算法 
算法

 传统特征提取方法总结
传统的特征选择方法大多采用以上特征评估函数进行特征权重的计算。
但由于这些评估函数都是基于统计学原理的，因此一个缺点就是需要一个庞大的训练集，才能获得对分类起关键作用的特征，这需要消耗大量的人力和物力。
另外基于评估函数的特征提取方法建立在特征独立的假设基础上，但在实际中这个假设很难成立。
 通过映射和变化来进行特征提取
特征选择也可以通过用映射或变换的方法把原始特征变换为较少的新特征传统的特征提取降维方法，会损失部分文档信息，以为例，它会剔除低频词汇，而很多情况下这部分词汇可能包含较多信息，对于分类的重要性比较大。如何解决传统特征提取方法的缺点：找到频率低词汇的相似高频词，例如：在介绍月亮的古诗中，玉兔和婵娟是低频词，我们可以用高频词月亮来代替，这无疑会提升分类系统对文本的理解深度。词向量能够有效的表示词语之间的相似度。
 传统的文本分类方法。

基本上大部分机器学习方法都在文本分类领域有所应用。
例如： ，，，集合类方法，最大熵，神经网络等等。

 深度学习文本分类方法

卷积神经网络
循环神经网络



本文采用的是卷积神经网络
实践及结果

网络概览图
 实践步骤

根据警情详情首先训练词向量模型，
把警情详情文本进行分词，去除停用词，然后利用词向量来表示，每篇文档表示为的矩阵文档包含的词语个数，不够的以维填充，：每个词语用维向量来表示
把警情训练样本分割为  。
利用设计好的卷积神经网络进行训练，并测试。

 设计的卷积神经网络结构

 实验结果

为了检验模型在真实数据上的分类准确率，我们又额外人工审核了条深圳地区的案情数据，相较于原来分类准确率的，提升到了现在的，说明我们的模型确实有效，相对于原来的模型有较大的提升。


红色：_在验证集上的准确率走势图
黄色和蓝色：    _ 在验证集上的准确率走势图


红色：_ 在验证集上的走势黄色和蓝色：    _ 在验证集上的走势
 一些感悟

一定要理解你的数据
做好实验记录和分析
大量的数据样本比改善模型来的更有效，但代价也很高
阅读理解原理，开阔视野，加强实践，敢于尝试，追求卓越

 一些参考文献

基于的文本分类
深度学习在文本分类中的应用
知乎用深度学习解决大规模文本分类的问题综述和实践
简书利用实现卷积神经网络做文本分类
利用自动生成语义相近句子
       
卷积神经网络在句子建模上的应用
自然语言处理中模型几种常见的操作
     
博客园文本深度表示模型  词向量模型
用比较两个文档之间的相似度
中文论坛自然语言处理三之  
的学习，词嵌入来龙去脉深度学习
自己动手写译者：

原文：
作者： 
译者按：网络优化一直是译者长期研究的方向， 的理论学习也已做了不少，随着这项标准的推进，越来越多特性被大家开始使用。作为  最激动人心的特性，  在性能提升的效果被寄予了很高期望，却因其对传统  架构的开发模式影响较大未能广泛实践。如何更好地使用这项能力，让我们跟着作者深入探索。
在过去的一年时间， 的出现为关注性能的开发者带来了显著的变化。 已经不再是我们期待中的特性，而是伴着  服务端推送能力已然到来。
除了解决常见的  性能问题比如，首部阻塞和未压缩的报头， 还提供了   能力！服务端推送允许我们向用户发送一些还没有被访问的资源。这是一种获得  优化实践例如内联所带来性能提升的优雅方式，同时也避免了原先实践的一些缺点。
本文中，你将了解什么是  ，它的工作原理与解决了哪些问题。同时你也将学习如何使用它，判断它是否正常运作，以及它对性能的影响。让我们开始吧！
  为何物
访问网站始终遵循着请求——响应模式。用户将请求发送到远程服务器，在一些延迟后，服务器会响应被请求的内容。
对网络服务器的初始请求通常是一个  文档。在这种情况下，服务器会用所请求的  资源进行响应。接着浏览器开始对  进行解析，过程中识别其他资源的引用，例如样式表、脚本和图片。紧接着，浏览器对这些资源分别发起独立的请求，等待服务器返回。

典型的服务器通信大图
这一机制的问题在于，它迫使用户等待这样一个过程：直到一个  文档下载完毕后，浏览器才能发现和获取页面的关键资源。从而延缓了页面渲染，拉长了页面加载时间。
有了  ，就有了解决上述问题的方案。  能让服务器在用户没有明确询问下，抢先地“推送”一些网站资源给客户端。只要正确地使用，我们可以根据用户正在访问的页面，给用户发送一些即将被使用的资源。
比如说你有一个网站，所有的页面都会在一个名为  的外部样式表中，定义各种样式。当用户向务器请求  时，我们可以向用户推送 ，同时我们发送 。

使用  的服务器通信大图
相比等待服务器发送 ，然后等待浏览器请求并接收 ，用户只需等待服务器的响应，就可在初次请求同时使用  和 。
可以想象，这可以降低一个页面的渲染时间。它还解决了一些其他问题，特别是在前端开发工作流方面。
  解决了什么问题？
  解决了减少关键内容网络回路的耗时问题，但这并不是唯一作用。  更像是  特定优化反模式的替代方案，例如将  和  内联在 ，以及使用 方案将二进制数据嵌入到  和  中。
这些技术在  优化工作流中非常受用，是因为这样减少了我们所说的页面“感知渲染时间”，也就是说在页面整体加载时间可能不会减少的同时，对用户而言网页的加载速度却显得更快。这确实是说得通的，如果你将  内嵌到  的标签中，浏览器就可以无需等待外部资源的获取，而立即应用  中的样式。这种概念同样适用于内联脚本，以及使用   方式内联二进制数据。

内联内容的服务器通信大图
看起来是个不错的方案，对吧？在  的时代确实如此，因为也没有别的选择。这么做实际上也留下了恶果，即内联的内容不能有效地被缓存。当样式、脚本资源以外链及模块形式引用，会更高效地进行缓存。当用户访问后续页面需要这些资源时，可以直接从缓存中获取，从而省去了额外的资源请求。

优化缓存行为大图
而当我们对内容进行内联时，它们是没有独立的缓存上下文的，而存在于所内联文档的上下文中。举个在  中内联  的例子，如果  的缓存策略，是每次访问都向服务器拉取最新的内容，那么内联的总是无法缓存其内容。即使把  进行缓存，但在后续访问的页面内，内联相同的  内容也是需要重复下载的。这还是比较宽松的缓存策略，实际情况中  仅有较短的缓存周期。内联是我们在  优化方案中所做的权衡，它确实在用户第一次访问时非常有效，而往往第一印象是非常重要的。
这就是   能解决的问题。当推送资源时，我们能获得与内联相同的性能提升，同时保持资源的外链形式，从而有独立的缓存策略。这里有个需要注意的问题，我们稍后再深入探讨。
我已经谈了很多为什么你该考虑使用   的原因，也澄明了它能为用户和开发者所解决的问题。接下来让我告诉你如何去使用它。
如何使用  
使用 ，通常会以下面的方式使用  这个首部。
  = =
注意我说的是通常，上面看到的实际是预加载资源示意 的实践。这是个区别于 的独立优化方案，但大多数并非全部的实现都将  放进来  首部。如果服务器或客户端选择不接受推送的资源，客户端仍可以根据指示提早获取资源。
首部中 = 部分是必选的，它能告知浏览器推送资源的类型。在这个例子中，我们使用  来指明推送的资源是一个样式表，你还可以设置其他的内容类型。值得注意的是如果省略了  的值，会导致浏览器对推送资源下载两次，所以千万别忘了它。
现在知道推送资源的方法了，但具体要怎样设置  首部呢？我们有两种方式：

服务器配置例如，  或；
后端语言功能例如的  方法。

使用服务器配置设置  首部
下面是一个  配置通过或的例子，作用是在请求  时推送样式资源。
 \
        = =

这里我们使用了  指令来匹配后缀为“”的文件请求。当一个请求匹配这个条件时，我们就往响应头里加入  首部，并告知服务器推送位置在 的资源。
边注： 的  模块也可以使用  指令启用资源推送。该指令的文档指出，这种方法能够早于  首部方法启用推送。根据安装时的不同设置，你也可能无法使用此功能。本文后面会给出  首部方法的性能测试结果。
截至目前， 并不支持   ，目前的  中没有任何支持情况的记录。而随着   实现的逐渐成熟，这种情况可能会发生变化。
使用后端代码设置  首部
另一个设置  首部的方法是使用服务器端语言。这在你无法修改或覆盖服务器配置时十分有效。下面是   方法设置  首部的例子：
  = =
如果你的应用程序部署在一个共享的托管环境中，并且修改服务器的配置不太现实，那么这个方法可能是最适合你的。你可以使用任何服务端语言设置这个首部。在真实使用前记得确保测试无误，以避免潜在的运行时错误。
多资源推送
目前看到的都是演示推送一个资源的例子，如果想一次推送更多资源呢？这么做也是很有道理的，对吧？毕竟页面不止是样式表组成的。下面来看推送多资源的例子：
  = =  = =  = =
当你想推送多个资源，只要用逗号把每个指令隔开就行了。因为资源示意是通过  首部加入的，这种语法让我们可以把不同资源的推送指令合在一起。这还有个包括  的混合推送指令示例：
  = =  =
多个  首部也是同样合法的。下面是  给  配置多个  首部的例子：
 \
        = =
        = =

这种语法相比一长串逗号分隔的字符串更为方便，且达到的作用是相同的。唯一的缺点就是没那么紧凑，而且会多一点字节量的网络传输，但提供的便利是值得的。
现在知道了如何推送资源，在本文下半部分，我们继续看推送是否生效，且表现性能如何。前言
在舆情项目中，需要对每天千万级的游戏评论信息进行词频统计，在生产者一端，我们将数据按照每天的拉取时间存入了当中，而在消费者一端，我们利用了 从中不断拉取数据进行词频统计。
本文首先对 嵌入的方式进行归纳总结，之后简单阐述  在舆情项目中的应用，最后将自己在  的实际优化中的一些经验进行归纳总结。如有任何纰漏欢迎补充来踩，我会第一时间改正
 接收数据
用 流式处理中的数据，第一步当然是先把数据接收过来，转换为 中的数据结构。
接收数据的方式有两种：

利用接收数据

直接从读取数据


基于的方式
这种方式利用接收器来接收中的数据，其最基本是使用高阶用户接口。对于所有的接收器，从接收来的数据会存储在的中，之后 提交的会处理这些数据。如下图：

在使用时，我们需要添加相应的依赖包：
    
    
    _
    

而对于的基本使用方式如下：
 _

   =  
                
还有几个需要注意的点：

在的方式中，中的和中的并不是相关的，所以如果我们加大每个的数量，仅仅是增加线程来处理由单一消费的主题。但是这并没有增加在处理数据上的并行度。

对于不同的和我们可以使用多个创建不同的来并行接收数据，之后可以利用来统一成一个。

如果我们启用了  复制到文件系统如，那么 需要设置成___，也就是___


直接读取方式
在之后，引入了方式。不同于的方式，方式没有这一层，其会周期性的获取中每个的每个中的最新，之后根据设定的来处理每个。其形式如下图：

这种方法相较于方式的优势在于：

简化的并行：在的方式中我们提到创建多个之后利用来合并成一个的方式提高数据传输并行度。而在方式中，中的与中的是一一对应的并行读取数据，这种映射关系也更利于理解和优化。

高效：在的方式中，为了达到数据丢失需要将数据存入  中，这样在和日志中就保存了两份数据，浪费！而第二种方式不存在这个问题，只要我们的数据保留时间足够长，我们都能够从进行数据恢复。

精确一次：在的方式中，使用的是的高阶接口从中获取值，这也是传统的从中读取数据的方式，但由于 消费的数据和中记录的不同步，这种方式偶尔会造成数据重复消费。而第二种方式，直接使用了简单的低阶 ，则利用 的进行记录，消除了这种不一致性。


以上主要是对官方文档的一个简单翻译，详细内容大家可以直接看下官方文档这里不再赘述。
不同于的方式，是从中读取值，那么自然就保存了当前消费的值，那么如果重新启动开始消费就会接着上一次值继续消费。
而在的方式中，我们是直接从来读数据，那么需要自己记录，可以利用、数据库或文件记录或者回写到中进行记录。这里我们给出利用底层接口，将及时同步到中的通用类，我将其放在了上：  
示例中是一个通用类，而是源码中的一个类，由于包名权限的原因我把它单独提出来，简单展示了通用类的使用方法，在每次创建时，都会先从中查看上次的消费记录，而每个处理完成后，会同步到中。
向中写入数据
上文阐述了如何从中流式的读取数据，下面我整理向中写数据。与读数据不同，并没有提供统一的接口用于写入，所以我们需要使用底层接口进行包装。
最直接的做法我们可以想到如下这种方式：
 =
   不能在这里创建
   =
    {
       ={
          =   
        __ 
        ___
          
        ___
          
        
          =  
         =  
        
      }
    }
  

但是这种方式缺点很明显，对于每个的每条记录，我们都需要创建，然后利用进行输出操作，注意这里我们并不能将的新建任务放在外边，因为是不可序列化的 。显然这种做法是不灵活且低效的，因为每条记录都需要建立一次连接。如何解决呢？

首先，我们需要将利用 的方式进行包装如下：

 
 {    }
    =     {
               
      
     = 
          =
        
        =
       
}

  {
   _
         = {
      =  = {
        =   
       {
                  
                
        
      }
      
    }
     
  }
        = 
}

之后我们利用广播变量的形式，将广播到每一个，如下：

 广播
    = {
    = {
      =  
     
     
     
    
  }
     
   
}
这样我们就能在每个中愉快的将数据输入到当中：
输出到
 = {
    {
     = {
       _ _
         
    }
  }
}
 应用
舆情监控对于每天爬取的千万级游戏玩家评论信息都要实时的进行词频统计，对于爬取到的游戏玩家评论数据，我们会生产到中，而另一端的消费者我们采用了 来进行流式处理，首先利用上文我们阐述的方式从拉取，之后经过分词、统计等相关处理，回写到上至于中的回写方式可参考我之前总结的博文：踩坑记——数据库，由此高效实时的完成每天大量数据的词频统计任务。
 调优
 的使用中，当数据量较小，很多时候默认配置和使用便能够满足情况，但是当数据量大的时候，就需要进行一定的调整和优化，而这种调整和优化本身也是不同的场景需要不同的配置。
合理的批处理时间
几乎所有的 调优文档都会提及批处理时间的调整，在初始化的时候，有一个参数便是批处理时间的设定。如果这个值设置的过短，即个所产生的并不能在这期间完成处理，那么就会造成数据不断堆积，最终导致 发生阻塞。
而且，一般对于的设置不会小于，因为过小会导致频繁的提交作业，对整个造成额外的负担。在平时的应用中，根据不同的应用场景和硬件配置，我设在之间，我们可以根据的可视化监控界面，观察 来进行的调整，如下图：

合理的拉取量重要
对于 消费中数据的应用场景，这个配置是非常关键的，配置参数为：。这个参数默认是没有上线的，即当中有多少数据它就会直接全部拉出。
而根据生产者写入的速率以及消费者本身处理数据的速度，同时这个参数需要结合上面的，使得每个拉取在每个期间拉取的数据能够顺利的处理完毕，做到尽可能高的吞吐量，而这个参数的调整可以参考可视化监控界面中的 和 ，如下图：

缓存反复使用的
中的和中的，如果被反复的使用，最好利用，将该数据流缓存起来，防止过度的调度资源造成的网络开销。可以参考观察 参数，如下图：

设置合理的
长期使用的小伙伴都知道，中的垃圾回收机制，可以让我们不过多的关注与内存的分配回收，更加专注于业务逻辑，都会为我们搞定。对有些了解的小伙伴应该知道，在虚拟机中，将内存分为了初生代 、年轻代 、老年代 以及永久代 ，其中每次都是需要耗费一定时间的，尤其是老年代的回收，需要对内存碎片进行整理，通常采用标记清楚的做法。
同样的在程序中， 的频率和时间也是影响整个效率的关键因素。在通常的使用中建议：
 =
设置合理的资源数
的数量，每个可以占用一个或多个，可以通过观察的使用率变化来了解计算资源的使用情况，例如，很常见的一种浪费是一个占用了多个，但是总的使用率却不高因为一个并不总能充分利用多核的能力，这个时候可以考虑让么个占用更少的，同时下面增加更多的，或者一台上面增加更多的来增加并行执行的的数量，从而增加利用率。
但是增加的时候需要考虑好内存消耗，因为一台机器的内存分配给越多的，每个的内存就越小，以致出现过多的数据 甚至  的情况。
设置合理的
和，指的就是数据分片的数量，每一次只能处理一个的数据，这个值太小了会导致每片数据量太大，导致内存压力，或者诸多的计算能力无法利用充分；但是如果太大了则会导致分片太多，执行效率降低。在执行类型操作的时候比如各种操作，的数量会选择 中最大的那一个。
而则指的是在进行类操作的时候，默认返回数据的数量而在进行类操作的时候，数量通常取自 中较大的一个，而且也不会涉及，因此这个的参数没有影响。所以说，这两个概念密切相关，都是涉及到数据分片的，作用方式其实是统一的。
通过可以设置默认的分片数量，而很多的操作都可以指定一个参数来显式控制具体的分片数量。
在的使用中，我们采用了连接方式，前文阐述过中的和中的是一一对应的，我们一般默认设置为中的数量。
使用高性能的算子
这里参考了美团技术团队的博文，并没有做过具体的性能测试，其建议如下：

使用替代

使用替代普通

使用替代

使用之后进行操作

使用替代与类操作


使用优化序列化性能
这个优化原则我本身也没有经过测试，但是好多优化文档有提到，这里也记录下来。
在中，主要有三个地方涉及到了序列化：

在算子函数中使用到外部变量时，该变量会被序列化后进行网络传输见“原则七：广播大变量”中的讲解。

将自定义的类型作为的泛型类型时比如，是自定义类型，所有自定义类型对象，都会进行序列化。因此这种情况下，也要求自定义的类必须实现接口。

使用可序列化的持久化策略时比如__，会将中的每个都序列化成一个大的字节数组。


对于这三种出现序列化的地方，我们都可以通过使用序列化类库，来优化序列化和反序列化的性能。默认使用的是的序列化机制，也就是 来进行序列化和反序列化。
但是同时支持使用序列化库，序列化类库的性能比序列化类库的性能要高很多。官方介绍，序列化机制比序列化机制，性能高倍左右。之所以默认没有使用作为序列化类库，是因为要求最好要注册所有需要进行序列化的自定义类型，因此对于开发者来说，这种方式比较麻烦。
以下是使用的代码示例，我们只要设置序列化类，再注册要序列化的自定义类型即可比如算子函数中使用到的外部变量类型、作为泛型类型的自定义类型等：
 创建对象。
  =  
 设置序列化器为。
 
 注册要序列化的自定义类型。
 
结果
经过种种调试优化，我们最终要达到的目的是， 能够实时的拉取当中的数据，并且能够保持稳定，如下图所示：

当然不同的应用场景会有不同的图形，这是本文词频统计优化稳定后的监控图，我们可以看到 这一柱形图中有一的虚线，而大多数都能够在这一虚线下处理完毕，说明整体 是运行稳定的。
广告下我们项目：腾讯舆情，专注于游戏舆情的挖掘分析，欢迎大家来踩踩
参考文献
     、的区别源码分析 性能调优详解性能优化指南——基础篇的性能调优       

相关推荐踩坑记——初试踩坑记——数据库踩坑记——共享变量导语：  与 都新增了对 的支持，对于 这个概念，本文试图阐述清楚与它相关的问题的由来，概念定义以及 与 对其的支持。

 
在分析 之前，我们先讲一下为什么要考虑 问题，这里需要简单分析一下多线程编程环境中的内存模型。

上图所示的是一个典型的多核系统架构，它包含有个核，每个核有一个私有的 的  ，两个 核共享 的   以及 的主存。
在这个内存模型下，写数据并不是立即写入中，而是写入 ，再从 存入 中，读数据也是先从 中读，读不到再从中读，这种读写数据的模式是能够提高数据存取效率的，但是在一些特殊情况下会导致程序出错，考虑以下这个例子。
                    ==
                    
               =          = 
              =         = 
表面上看，====这种输出是不可能出现的，然而，有一种可能性是，由于不依赖于，编译器可以把=这步操作调整到=这步操作之前，同样，=这步操作可以调整到=这步操作之前，这样一来， 可以先读取 中的的值，  才执行  = 的赋值操作，同理， = 这步操作也可以在=这步赋值操作之前执行，这时候就会出现 ==  ==的输出结果。
如何避免这种情况的出现呢？最简单的方案是给 变量操作加互斥锁，然而，我们都知道，互斥锁会导致代码执行效率降低，那么，有没有其他同步原语，既能保证程序的正确性，又能尽可能地提高程序执行效率呢？下面介绍种   。
 
理论上讲， 有类，如下图所示。

下面分别进行分析。

 这种内存栅栏 ，顾名思义，就是阻止栅栏后面的操作被调整到栅栏前面的操作之前，类似于   或者   操作，如下图所示。

 的主要作用是防止程序加载已经过期的数据，考虑以下代码：
                         
{
    _                  
                          
}
_ 在其中的作用是阻止读取这步操作被到读取这步操作之前，这样，只有在置位后，才会去读取的值。

类似于， 这种内存栅栏用于阻止栅栏后面的操作被调整到栅栏前面的操作之前，类似于 或者 操作，如下图所示。

同理，可以避免将过期的数据写入内存。
 =                             
_
 =                            

 内存栅栏用于保证所有在这个栅栏之前的操作一定会在这个栅栏之后的操作之前执行。例如：
 =                 
_
 =                    
在这里， =  这步操作可以被提前到读取的值这步操作之前，之所以允许这种优化，是因为有时候在 中没有缓存的值，而已经缓存了=这步操作，这时候先执行再执行效率会更高。然而，这种栅栏可以阻止这种情况的发生。

 用于保证所有在这个栅栏之前的操作一定会在这个栅栏之后的操作之前执行，可以认为这是或者中用户本地代码目录与 之间的一次同步操作，如下图所示。

 可以解决前文所说的====的问题，考虑将程序改成如下这种形式。
                    ==
                  
        =               = 
_  _
        =             = 
在这种情况下，====这个情况是不会出现的。
与语义
与是无锁编程中最容易混淆的两个原语，它们是线程之间合作进行数据操作的关键步骤。在这里，借助前面对 的解释，对与的语义进行阐述。

本质上是，它只能应用在从中数据这种操作上，它确保了所有在之后的语句不会被调整到它之前执行，如下图所示。


用上面的 来描述，等价于加上栅栏。

本质上是，它只能应用在数据到中，它确保了所有在之前的语句不会被调整到它之后执行，如下图所示。


用上面的 来描述，等价于加上栅栏。
互斥锁
借助与语义，我们再重新来看一下互斥锁如何用与来实现，实际上，正是与这两个原语的由来，的本意是  ，的本意是  ，因此，互斥锁能保证被锁住的区域内得到的数据不会是过期的数据，而且所有写入操作在之前一定会写入内存，如下图所示。

以上关于 的背景和相关概念说明的部分，有很多参考自  博客，有兴趣的同学可以前往该博客阅读其博文，上面有不少实验也非常地有趣。
 中与 相关的同步操作
  在标准中提出了种同步操作： __ __ __ __ ___ ___，关于 的 ，

漫谈多线程内存模型
并发无锁编程 之  

这两篇文章有比较详细的描述，结合上述对一些专有名词的解释，这两篇文章应该比较容易看懂，这里不再赘述。
 中与 相关的同步操作
为了与 对齐， 标准中也新增了与 相关的同步操作，新添加了这个类来封装相关的方法。
类的设计目的是为了替代以及这两个类中的一些方法，标准中指出这两个类的一些方法存在性能和可移植性问题，下面举例说明：

类会带来额外的内存消耗以及因引用替换带来的新的并发问题。
原子化的操作通常会比原操作带来更多的开销
特定的内置的包里面的可以高效地执行原子更新操作，但是这个包会损害安全性与可移植性。

为了解决这些问题，希望设计这样一种变量类型，它能够支持在多种不同的访问模式下对变量进行读写操作，支持的变量类型包括对象域、静态域、数组元素以及一些不在堆上的用描述的字节数组。
类的访问模式包括以下几类：

读模式，即以内存访问顺序读变量顺序读；
写模式，即以模式的内存访问顺序写变量顺序写，防止乱序；
对变量进行原子化地更新操作，例如在  操作中，以内存访问顺序读写变量；
对数字进行原子化地更新操作，例如在  操作中，对写操作使用普通的内存访问顺序，对读操作使用内存访问顺序；
对进行逐位的原子化更新操作，例如在   操作中，对写操作使用内存访问顺序，对读操作使用一般的内存访问顺序。

后面三种内存访问模式通常被称为模式。
类可以由类进行生产，代码示例如下：
  {
     

    
}



  {
       ___

     {
         {
            ___ = 
                
                  
        }    {
              
        }
    }
}
在获取并返回一个实例之前，的方法会进行访问控制权限检查。
如果要获取一个用于访问数组的实例，可以采用以下方法。
  = 
获取到类实例后，如何用这个类去修改类的域呢？
  = 
  = ___  
  =  ___ 
为了保证效率，类的实例通常需要被声明为 变量其实就是常量，这样可以在编译期对它进行优化。
用类反射获取类的方法如下：
  = 
  = 
        
        
           
调用这个的代码如下：
  =  ___   

  = 
        ___
  =    
反射生成的另一种方案是：
  = 
        __
           

  =  ___   
关于的更多使用方法可以参考文章理解中的。
最后，陈列一下类内部支持 的方法

               
            
    
             
             
     _____
    
       {}

   
               
          
    
             
             
     ____
    
       {}

   
               
          
    
             
             
     ____
    
       {}

   
               
        
    
       {}

   
               
        
    
       {}
通过上面的背景描述，我们可以知道，对于读操作，强于强于，对于写操作，强于强于。
 还提供了一种可达性屏障，定义在类里面
  {
    

   
             
            {
     }      
               
            
             
              
          
    
               
    
        {}

}
总结
 这个问题其实在平时的开发中比较少会遇到，但是考虑到特定的或者编译器在优化指令时会有重排序的情况，了解这些知识有助于调试一些疑难杂症。
参考文献
   博客   标准  关于 的说明作者介绍：陈永洋  

做测试也有一段时间了，随着项目壮大，版本问题也越来越突出。如何有效地对进行预防拦截呢？请看下文。
闪退背后的秘密
以下画面相信负责过项目一定见过，它是怎么出现的呢？

以下为基于源码分析的完整代码调用关系：

主流程如下：
使用语句，那么如果没有有效 ，此时系统便会来进行捕获，并进入流程分为六大流程：
首先发生所在进程在创建之初便准备好了用来来处理 ，并输出当前基本信息；
调用当前进程中的；经过 机制，传递到_进程；
接下来，进入_进程，调用服务端执行；经过一系列的调用最终痛过发送消息__，弹出对话框；
到此，_进程执行完成。回到进程开始执行杀掉当前进程的操作；
当进程被杀，通过死亡通知，告知_进程来执行；
最后，执行清理应用相关的组件信息。可以尝试自己下载最新的源码并查看分析，相关源文件：





更多详情可参考这里。
全面认知
后，我们首先能做些什么呢？测试怎么入手？
最先能想到的是收集日志信息：
 
  程序异常后，会生成 文件位于路径  下
异常可以在日志中看到；
日志会存在系统目录
 ：
可以连接，通过导出对应的日志文件。如设备的位置位
于：
实际项目中都接入了， 后，会自动上报到分析平台，相关的信息相对比较丰富，并可以自动还原异常时调用栈信息栈还原 加固 混淆 符号化等相关问题都可解决。
日志信息中，比较关键的信是错误类型。这里带大家了解一下目前移动端关于异常的整体分类情况。
对来说主要有以下几种：

下大致可如下划分：

除了错误类型信息，还有哪些测试需要重点关注呢？接下来看一下
基本分析
对于测试来说，接到报告后面临的问题有：
、产生的原因初步分析
、疑难的重现
对于错误信息及栈比较明确的，定位起来一般没有什么难度。
如图，栈信息及代码行可以很容易定位到出问题的子模块，排查起来难度不大。
 比较复杂的问题可能集中在的栈都是系统信息或者第三方库，或者多个模块存在耦合的代码，排查起来难度比较大。
如图，栈里面都是自己的内容：
对于这类问题从项目角度可以从提升定位效率及快速重现方面入手：
如目前项目中已经加入了点击流上报，可以辅助定位栈中无代码的疑难问题。
基本分析完成了，是否有办法从源头来减少问题呢？当然有↓↓↓
之阻击战
随着版本量越来越大，对的预估是否力不从心？如何有效地对问题进行拦截阻击呢？
以下是跟进总结过程中的一些可深入的点，如：
体验类问题
体验类问题，如保证异常后的恢复无明显异常：

代码质量提升
分析总结中，可以把常见的坑，提取成静态扫描规则加入到代码扫描中；
通用异常点总结
通过对异常场景的收集总结完善测试分析，规避异常路径未覆盖导致的
测试覆盖率分析

自动化随机测试

动态调试
常用于快速复现及检测内存相关问题。

拦截测试效果一览
通过以上拦截手段，也取得了一些效果：
代码扫描

目前接入
目前接入，扫描问题：

自定义扫描规则
自定义扫描规则，扫描问题：

等随机点击测试
等随机点击测试，发现问题；
常见列表补充
下面是一些常见的列表，供参考
一些参考资料
、【】 之异常信息反馈机制

、  理解 处理流程

、  理解 处理流程

、 崩溃大解析

、 、、、 区别 联系

、 的的类型及原因

、    分析
分析
、  分析 文件：符号化 文件的种方法

、  启动连续闪退保护方案

、 

、  调试之  分析

、 分析 文件：符号化 文件的种方法

、     

、   
_
、      

您是否也曾为线上问题烦恼呢？如果有，您是如何应对的呢？

相关推荐【腾讯】是如何做浏览器的性能测试的？【腾讯】敏捷测试快速俘虏产品  开发上一章节我们介绍了腾讯云分布式数据库的发展历史，基本原理和使用方法；本章节我们继续分析下分布式数据库  的优势和应用场景。

点击购买腾讯云分布式数据库
点击查看腾讯云分布式数据库更多详情
分布式数据库  的优势
性能容量线性增长
 是天然的    ，大规模并行处理系统架构，这意味着随着  分片的增加，每个分片各自承担一部分分布式任务，意味着并发性能、处理能力、存储容量将线性增长。

并且  默认采用线程池，且对调度算法进行了优化，改进当系统内核处于重负载时，查询和更新请求在线程组间分布不均衡等极端情况下性能，并且能够更好地利用计算资源，减少无谓的线程切换，减少请求在队列中的等待时间，及时处理请求。类似的内核优化还有很多，通过  的压力测试， 单个分片纯写入操作能超过  万，纯查询操作能超过  万 ，是  性能的  倍， 的  倍以上，且腾讯云数据库团体还在持续优化。
高可用与强同步
在生产系统中，通常都需要用高可用方案来保证系统不间断运行；数据库作为系统数据存储和服务的核心能力，其可用要求高于计算服务资源。目前，数据库的高可用方案通常是让多个数据库服务协同工作，当一台数据库故障，余下的立即顶替上去工作，这样就可以做到不中断服务或只中断很短时间；或者是让多台数据库同时提供服务，用户可以访问任意一台数据库，当其中一台数据库故障，立即更换访问另外数据库即可。

由于数据库中记录了数据，想要在多台数据库中切换，数据必须是同步的，所以数据同步技术是数据库高可用方案的基础；当前，数据复制方式有以下三种方式：

异步复制：应用发起更新含增加、删除、修改操作请求， 完成相应操作后立即响应应用， 向  异步复制数据。因此异步复制方式下，  不可用不影响主库上的操作，而  不可用有概率会引起数据不一致。
强同步复制：应用发起更新请求， 完成操作后向  复制数据， 接收到数据后向  返回成功信息， 接到  的反馈后再应答给应用。 向  复制数据是同步进行的，因此  不可用会影响  上的操作，而  不可用不会引起数据不一致。使用“强同步”复制时，如果主库与备库自建网络中断或备库出现问题，主库也会被锁住只读，而此时如果只有一个主库或一个备库，那么是无法做高可用方案的。—— 因为单一服务器服务，如果股指则直接导致部分数据完全丢失，不符合强同步的设计初衷。
半同步复制：半同步复制是  提出的一种同步方案，他的原理是正常情况下数据复制方式采用强同步复制方式，当  向  复制数据出现异常的时候 不可用或者双节点间的网络异常退化成异步复制。当异常恢复后，异步复制会恢复成强同步复制。半同步复制意味着  不可用有概率会较小概率引起数据不一致。

腾讯自主研发了的基于  协议的异步多线程强同步复制方案   ，简单来说， 强同步方案强同步技术具有以下特点：

一致性的同步复制，保证节点间数据强一致性；
对业务层面完全透明，业务层面无需做读写分离或同步强化工作；    
将串行同步线程异步化，引入线程池能力，大幅度提高性能
支持集群架构；
支持自动成员控制，故障节点自动从集群中移除；
支持自动节点加入，无需人工干预；
每个节点都包含完整的数据副本，可以随时切换；
无需共享存储设备

腾讯  方案强同步技术原理是，只有当备机数据同步日志后，才由主机向应用返回事务应答，示意图如下：

从性能上优于其他主流同步方案，通过在同样的测试方案下，我们发现其  技术性能优于   半同步约  倍此处测试使用  标准用例测试。



同步方案跨测试
最大并发水平
平均耗时




强同步




  半同步




  半同步




 异步同步




  异步同步





丰富的逻辑表
  对应用来说，读写数据完全透明，对业务呈现的表实际上是逻辑表。逻辑表屏蔽了物理层实际存储规则，业务无需关心数据层如何存储，只需要基于业务表应该如何设计。
 
  为用户提供了三种类似的表分表，小表以及单表：

分表：是指那些原有的很大数据的表，需要切分到多个数据库的表，这样每个分片都有一部分数据，所有分片构成了完整的数据。
广播表：即又名小表广播功能，设置为广播表后，该表的所有操作都将广播到所有物理分片中，每个分片都有改表的全量数据。
单表：主要用于存储一些无需分片的表：该表的数据全量存在第一个物理分片中，所有该类型的表都放在第一个物理分片中，语法和使用防范和完全一样，您可以把他理解为一个非分布式的表。

高性能分布式事务

计划  年  月支持

分布式事务，就是一个数据库事务在多个数据库实例上面执行，并且多个实例分布式数据库上即多个分片上面都执行了写入 操作。实现分布式事务处理的最大难点，就是在这些多个数据库实例上面实现统一的数据库事务的保障，而这里面最重要的算法就是两阶段提交算法。分布式事务能力理论虽然很早就被提出，而业内实际工程化实现和大规模业务验证的产品还较少。

  支持分布事务，可以为银行转账、电商交易等业务提供支持有效支持。当然，分布式事务处理的开销比会比单机架构事务处理开销要大一些，使用分布式事务会导致系统  降低，事务提交延时增大我们不建议您分表上在分布式数据库上使用复杂的事务。而腾讯  通过多种优化，提供了高于开源 分布式事务简称的性能。
由于理论上，一个事务不会操作全部分片，仅操作个分片如转账业务，再加上   的  架构的原因；因此一个分布式实例多个分片的分布式事务性能可以理论叠加某些事务可能操作所有分片，会导致分片越多，性能反而下降。

所以是否使用分布式事务要根据实际应用需求来定：数据量非常大或者数据访问负载非常高时，分布式事务会大大降低应用开发难度， 每个事务的查询语句的写法与使用单机架构实例完全相同，且获得事务的  保障。然而，业务中可能存在少量特别复杂的事务一次性操作所有分片，这势必会造成分布式事务性能的下降若需要操作如此多数据，即使是单机实例耗时也会很长；遇到这种情况，我们建议业务谨慎平衡性能和开发难度的关系，或将事务拆解，巧妙设计；或引入一些等待机制，以优化用户体验。
 灵活的读写分离

计划  年  月支持

  默认支持读写分离能力，架构中的每个从机都能支持只读能力，如果配置有多个从机，将由网关集群自动分配到低负载从机上，以支撑大型应用程序的读取流量；我们提供多种读写分离方案供您选择，且您无需关注若干从机是否完全存活，因为系统将根据策略自动调度

只读帐号：您仅需要在创建帐号时，标记为只读帐号，系统将根据策略向将读请求发往从机； 
注释：您可以在编程过程中，通过注释，系统将把该条语句发往从机，常用于编程阶段将特殊的读逻辑嵌入代码。 

通过多种只读方案的组合，您可以配置出复杂的只读方案，以满足您各种业务需求和开发的灵活性。
可应用于秒杀场景的热点更新能力

计划  年  月支持

  提供热点更新能力，可应用于秒杀或某些瞬时超大并发数据修改的业务场景。传统的方案是将商品库的子库前置在  层或业务层，通过蜕化数据强一致后通过第三方对账确保库存和抢购一致，而仅保证单个用户看到的库存减少规律一致确保用户不会一会儿看见商品还有  个，过一会儿发现商品还剩  个导致投诉。稍稍研究下，我们就会发现，这种实现方案相当复杂。而  通过在数据库层直接实现热点更新能力来做到满足业务秒杀的需求，不仅减少了出错的概率，还提升了极大的开发效率。

 全局唯一数字序列
数据切分后，原有的关系数据库中的主键约束在分布式条件下将无法使用，因此需要引入外部机制保证数据唯一性标识，这种保证全局性的数据唯一标识的机制就是全局唯一数字序列。  全局唯一数字序列以下简称 ，使用的是   类型， 个字节长，使用方法与 的_ 类似。目前   可以保证该字段全局唯一和有序递增，但不保证连续性。
 基于多租户闲时超用技术
公有云虚拟化让多个租户的业务共享物理设备性能，而传统隔离方案严格限制了每个租户实例的性能大小。这种限制方案很公平，但没有考虑到业务特点：大多数业务仅在一天一月的少数时刻有较大的业务压力如下图： 该业务日  平均使用率仅 ，而一天中仅存在  次业务压力较大， 使用率在 。虽然云能够基于弹性扩容，然而普通的弹性方案在这种突发性的压力面前，仍然无能为力——可能当您反应过来，您的业务峰值已过；最终，您还得基于业务峰值配置实例。

闲时超用技术，即在绝对保证每个实例预分配性能下限的基础上，允许实例使用超过预分配的性能。举个例子：假定  实例承载上海股票交易所的业务， 实例是承载纳斯达克股票的业务，、 实例被分配到一台物理设备中，可以在的空闲时间，抢占有限的，并发全部一部分空闲性能。当然，、同时面对峰值时，我们确保  分配的  基本数量。相对于传统的方案，闲时超用是一种更加灵活的性能隔离方案，让您的业务在面对偶然性峰值时也能游刃有余。

当然，如果您不想使用多租户方案，而期望独享整个物理集群，也欢迎您咨询腾讯工作人员，了解独享集群数据库
弹性扩展——自动再均衡技术
  支持在线实时扩容，扩容方式分为新增分片和对现有分片扩容两种方式； 在线扩容仅需管理员到腾讯云控制台点击付费即可，扩容过程对业务完全透明，无需业务停机。扩容时仅部分分片存在秒级的只读或中断，整个集群不会受影响。
  主要是采用自研的自动再均衡技术保证自动化的扩容和稳定，以新增分片为例，扩容过程如下下图：
 

若  节点实际上可能有多个节点存在性能和容量瓶颈，通过控制台点击新增分片
根据新加  节点配置，将  节点部分数据搬迁从备机到  节点。
数据完全同步后， 校验数据库，存在几十秒的只读，但整个服务不会停止。
调度通知  切换路由。

为确保业务不停以及数据一致性，  的整个迁移过程采用移存量数据、迁移增量数据、数据检验、再追增量、切换路由、清理 六个步骤循环迭代进行。该能力经过腾讯内外海量业务迁移，至今未发生过一次数据异常错误或全集群停机。

应用场景

实时高并发交易场景：解决金融、红包、电商、、零售等行业普遍存在用户基数大、并发高访问慢，制约业务发展的问题。

海量数据存储访问场景：面向物联网，交易订单等业务，业务数据增长迅猛，会产生超过单机数据库存储能力极限的数据，数据库实例超过级别且持续快速增长，造成数据库容量瓶颈，限制业务发展。

支持秒杀场景：支持电商、 等存在的整点秒杀瞬时超高并发访问，超大数据写入，秒杀实时排队等等场景。

支持游戏全区全服：支持  经营养成类社交游戏；开房间类竞技类游戏；卡牌对战类游戏，等游戏全区全服，在线扩展，以及开房间等复杂玩法。

成为去的中坚力量：企业的核心业务系统一般都是  为主的应用场景，在这个领域， 一直是市场的领导者，在互联网领域，以  为代表的分布式数据库应用非常广泛，用普通  服务器，轻松支撑起上亿的用户访问，经过验证的好的分布式数据库在性能和稳定性上甚至高于用高端设备搭建的  。当然，对于企业而言，由于  数据库和上层应用绑定比较紧密，通常会使用到  的存储过程、自定义函数、触发器，这就需要涉及到应用迁移，这个工作的工作量和时间周期通常较大，但综合计算下来，即使加上软件改造成本，采用  的  仍然低于使用商业数据库，当前，不管是互联网和传统行业，去  的成功案例比比皆是。

分支业务聚合到总部：由于政务、银行、大型国企的组织架构通常采用总部分部分支的架构；因为各种原因，其某些核心系统建设也采用总部分部分支模式。随着业务互通，人员互通，信息互通等需求越来越强烈，业务逐渐向聚合。而业务聚合一个重要问题是数据库性能和容量无法承载。以某部委为例，其省级业务系统数据规模和性能已经在用最高端的商业数据库硬件承载。如果聚合到总部，一是设备性能扩无可扩，二是软件费用和硬件成本将会是天价。因此，到现在为止，不少业务也仅能做到数据汇总，而非业务聚合。 此类分布式数据库在微信支付、京东等超大规模业务的应用证明了，一个系统承载全国业务的可能性。


展望
分布式数据库   未来将支持更多优秀特性以适应不同的业务场景。我们的目标是您的业务仅需要  个数据库就够了，一个用来部署正式业务，不增加存储成本基础上，能涵盖  场景，且可以覆盖多种数据类型；另一个，一个用来部署您的测试环境，用于新版本开发。导语
函数在编程语言中可谓“头等公民”，理解函数的实现原理，函数的一些方法论对于编程非常有好处。 我将从函数的实现原理以及编写函数的一些建议两个的角度来重新认识一下、中的函数。 那具体函数在汇编层面到底是什么，以及函数是如何跳转的。本文尝试从下面从汇编的角度去理解一下函数。
函数
首先是一段比较简单的代码，我编译成汇编，然后解读每一个汇编指令到底做了什么操作。
代码如下
 
    
{
      =     
     
}

   
{
     
    =
    =
    =
     = 
    =\
     
}
在我 位机器编译后的汇编主要代码为

         
           
           
           
          
          
          
          
          
          
         
         


         
           
           
           
          
          
          
          
          
          
          
          
                          
                     =\
          
          
          
                           
          
          
          
          
         
      
剖析函数的调用过程
这里先复习下汇编知识，下面会经常提及
     将入栈
      出栈，将结果存至
     将数据复制到
  跳转到地址
      将与相加，并且将结果放到中

 栈基针寄存器，指向栈底
 栈指针寄存器，指向栈顶
 指令指针寄存器，指向当前执行的地址
进入函数逻辑
从地址为 开始函数逻辑
       
         
第一步为将前一栈帧的栈基地址入栈，第二部为将栈顶地址拷贝至中。
完成这一步后，就完成了保留上一帧的基地址，初始化本帧的栈顶地址。
这里以我的地址为例，此时 的值为 值也为

 分配栈空间
接下来减去 个字节，即栈顶向低字节移动个字节，变成，相当于当前栈帧为当前的函数分配了个字节的空间，用于存放函数局部参数。当前函数执行完后，回到上一函数的栈顶，便达到了回收局部变量的功能。
    
此时的栈信息如下

为局部变量赋值
接着下面个命令为局部变量赋值。前面个命名暂时忽略，由第个命令开始，分别是将立即数  写入到 往低地址偏移字节的内存块中。将立即数  写入到 往低地址偏移字节的内存块中。将立即数  写入到 往低地址偏移字节的内存块中。这也就是函数中局部变量赋值操作====
     
     
     
          
         
         
此时的栈

 传递参数
接下来的三个指令非常简单，便是将上一步骤中的三个全局变量移动至寄存器 中。看到这里便有一个疑问，其实做一个传递立即数的操作，为什么需要先传递到内存，再传递到寄存器用于函数调用呢？这是因为 的操作数不能是立即数，所以必须要先将立即数传递到内存区域，再从内存区域传递至寄存器。
     
     
     
函数跳转
 的操作为下一条指令的地址入栈，然后跳转至 。跳转后为
                       
                  =\

子函数调用
将前一个堆栈的栈基地址寄存器入栈。向低地址偏移个字节。并且将赋值给。
       
         

由此开始便是子函数的栈帧。此时和是相同。
获取形参与计算
到这里便是从刚才的 中取出  从中取出 ，从取出，分别放置到偏移，，的内存中。并将三者相加将结果放置中。
       
       
       
       
       
        
        
       

 子程序跳出函数，跳转回到函数
执行前的堆栈

最后便是回到函数的步骤。第一个指令将栈顶的数据出栈，并且将其赋值给。从上步骤中可以看到，栈顶数据其实便是，即函数的栈底。
下一步执行 ，继续将栈顶出栈，并且将值付给。按照此时指示的指令地址继续执行程序
   

执行指令后

到此，子程序便退出，回到了函数的函数中，继续执行。
建议：
避免在非调度函数中使用控制函数
在日常编程中，有时会非常自然的根据一些配置参数，来实现具体的功能，也很自然的在函数中根据参数的值的不同，函数体内将不同情况的分支情况都写在一起。
调度函数指根据输入的消息类型或者控制命令来启动相应功能实体。简单而言，便是根据配置，调用其他功能函数，其本身只关心“  ”。而非调度函数功能函数实现具体的某个功能，其本身关心“  ”。以此为规则可以清晰的将函数进行冗余的函数进行分层。
例如以下：
这里使用了一个_参数进行加减法的区分。这种方式其实是非常的不合理，违背了函数实现单一功能的原则。
       _
{
    _ = 
    {
         
    }  _ == {
         
    }{
         
    }
}
如下是将调度函数与非调度函数功能函数进行区分
 
{
     
}
 
{
     
}
       _
{
    _ = 
    {
         
    }  _ == {
         
    }{
         
    }
}
使用防止指针类型变量被修改
如果参数仅作为输入，则使用修饰符声明，防止函数修改该值
       
{
    
     
}
 函数如无返回值时，显式声明类型的返回
听起来其实非常简单，日常编程中也不容易遗漏。这里提及一下的早期版本中，支持不填返回值。且默认的返回值为。
如下的函数声明在某些版本下是可以正常编译

{
     
}
 
{
    
}
确保函数入口与出口的安全性
入口即参数的合法性。以”永不信任的原则“，对传入的参数合法性进行校验。
    
{
    ==
    
}
出口即的返回值必须涵盖所有的正常与异常情况。
在使用其他函数时，也需要对调用函数的返回值进行判断，同时也需对错误的返回值进行相应的错误处理。
局部变量不易过多
人类大脑同时记住的个不同的东西，超过这个就会犯糊涂。因此局部变量的数目应该少，应该不差过个
小结
 函数的栈的实现其实是修改来与的实现的。通过控制这个两个寄存器在函数调用前保存前一函数的压栈，函数体执行完成后出栈回退至上一个函数的，来达到函数调用的效果。
  函数的局部变量是通过移动的值而分配的。函数退出时，回到前函数的栈顶，这便达到了函数推出时，局部变量也随之释放的效果。
 对于函数的功能架构而言，应该遵从功能与调度的分离，尽量做到各尽其事。
 对于函数体内的个个与等的分支逻辑，应该先主后次，先正常逻辑再异常逻辑。感谢对腾讯云技术社区的关注！如果您有意向我们投稿，下面的一些指南性内容对您可能会有帮助，在提交您的文章之前请仔细阅读。
投稿方式

使用邮箱、微信账号、微信公众号等注册腾讯云账号，或是直接使用 号登陆腾讯云；
进入社区首页，点击右下方蓝色按钮「申请入驻社区」申请发表文章权限，填写必要信息并审核通过后，即可发布投稿文章，具体流程参见社区作者入驻指南；
所有投稿文章均会有专属编辑审核，我们会在小时内审核完毕节假日可能延后。

投稿须知

腾讯云技术社区目前使用  写作，投稿文章须符合  语法，相关语法说明见此文；
目前支持投稿的文章领域包括：云计算及腾讯云实践、大数据、人工智能、系统运维、架构设计、后台开发、编程语言、数据库、安全、 前端、移动开发等。
腾讯云技术社区有权对投稿进行编辑或删除；
投稿文章应尽量做到内容整洁，结构明确，标点符号规范，分段合理；
投稿文章仅为作者个人意见，不代表腾讯云技术社区官方立场；
所有投稿文章必须是原创，发现抄袭者一律删除；
投稿文章中的配图务必从本地上传，文件名尽量使用英文和数字，并保证清晰；
投稿文章中不能包含商业推广信息、公众号二维码和联系信息等推广内容。

若不符合以上要求，腾讯云技术社区有权拒绝发布如果是软文新闻稿公关稿，小编将直接删除，谢谢理解。
另外，本站作者在发表、上传作品时，还禁止包含以下内容：
 、反对宪法所确定的基本原则的； 、危害国家安全，泄露国家秘密，颠覆国家政权，破坏国家统一的； 、损害国家荣誉和利益的； 、煽动民族仇恨、民族歧视，破坏民族团结的； 、破坏国家宗教政策，宣扬邪教和封建迷信的； 、散布谣言，扰乱社会秩序，破坏社会稳定的； 、散布淫秽、色情、赌博、暴力、凶杀、恐怖或者教唆犯罪的； 、侮辱或者诽谤他人，侵害他人合法权益的； 、含有法律、行政法规禁止的其他内容的。
如作者违反上述规定的，腾讯云技术社区有权立即无条件删除作者账号及其账号下发表的任何内容，不另行通知。
常见问题

投稿文章有问题需要修改，怎么更新？在我的文章页面找到想修改的文章，点击文章链接进入详情页，点击页面右上方的「编辑」按钮即可直接修改。一旦文章被修改，则需要重新审核。

投稿的文章多久可以审核发布？投稿的作品都会由编辑进行校稿，如作品不适合或需要修改，编辑会返回文章并给出对应说明。因稿量较大，我们承诺会在小时内审核完毕节假日可能延后。


一些参考文章示例
热点技术内容使用腾讯云学习深度学习：传统机器学习的回顾  勒索病毒用户处置指南 
深度技术文章高性能服务器架构思路一——缓冲策略 华尔街见闻：基于腾讯云容器服务的微服务架构实践 数据库的高可用性分析 
云计算实践使用心得，经验总结云中漫步，做个公众号方便生活、取悦自己 网站使用之后禁止用户真实访问的方法 
腾讯云技术社区运营团队 更新作者介绍：韩伟，年大学实习期加入初创期的网易，成为第号员工，年间从程序员开始，历任项目经理、产品总监。年后创业年，开发过视频直播社区，及多款页游产品。年后就职于腾讯游戏研发部公共技术中心架构规划组，专注于通用游戏技术底层的研发。

分布式编程复杂度
以前我们的代码，从上往下执行，每一行都会占用一定的时间，这些代码的直接顺序，也是和编写的顺序基本一致，任何一行代码，都是唯一时刻的执行任务。当我们在编写分布式程序的时候，我们的代码将不再好像那些单进程、单线程的程序一样简单。我们要把同时运行的不同代码，在同一段代码中编写。就好像我们要把整个交响乐团的每个乐器的乐谱，全部写到一张纸上。为了解决这种编程的复杂度，业界发展出了多种编码形式。
在多进程的编码模型上，函数可以说一个非常典型的代表。在一段代码中，调用之后的部分，可能会被新的进程中执行。要区分当前代码的所在进程，要靠的返回值变量。这种做法，等于把多个进程的代码都合并到一块，然后通过某些变量作为标志来划分。这样的写法，对于不同进程代码大部份相同的“同质进程”来说，还是比较方便的，最怕就是有大量的不同逻辑要用不同的进程来处理，这种情况下，我们就只能自己通过规范附近的代码，来控制混乱的局面。比较典型的是把附近的代码弄成一个类似分发器的形式，把不同功能的代码放到不同的函数中，以之前的标记变量来决定如何调用。  动态多进程的代码模式  在我们使用多线程的时，情况就会好很多，我们可以用一个函数指针，或者一个带回调方法的对象，作为线程执行的主体，并且以句柄或者对象的形式来控制这些线程。作为开发人员，我们只要掌握了对线程的启动、停止等有限的几个，就能很好的对并行的多线程进行控制。这对比多进程的来说，从代码上看会更直观，只是我们必须要分清楚调用一个函数，和新建一个线程去调用一个函数，之间的差别：新建线程去调用函数，这个操作会很快的结束，并不会依序去执行那个函数，而是代表着，那个函数中的代码，可能和线程调用之后的代码，交替的执行。
由于多线程把“并行的任务”作为一个明确的编程概念定义了出来，以句柄、对象的形式封装好，那么我们自然会希望对多线程能更多复杂而细致的控制。因此出现了很多多线程相关的工具。比较典型的编程工具有线程池、线程安全容器、锁这三类。线程池提供给我们以“池”的形态，自动管理线程的能力：我们不需要自己去考虑怎么建立线程、回收线程，而是给线程池一个策略，然后输入需要执行的任务函数，线程池就会自动操作，比如它会维持一个同时运行线程数量，或者保持一定的空闲线程以节省创建、销毁线程的消耗。在多线程操作中，不像多进程在内存上完全是区分开的，所以可以访问同一份内存，也就是对堆里面的同一个变量进行读写，这就可能产生程序员所预计不到的情况因为我们写程序只考虑代码是顺序执行的。还有一些对象容器，比如哈希表和队列，如果被多个线程同时操作，可能还会因为内部数据对不上，造成严重的错误，所以很多人开发了一些可以被多个线程同时操作的容器，以及所谓“原子”操作的工具，以解决这样的问题。有些语言如，在语法层面，就提供了关键字来对某个变量进行“上锁”，以保障只有一个线程能操作它。多线程的编程中，很多并行任务，是有一定的阻塞顺序的，所以有各种各样的锁被发明出来，比如倒数锁、排队锁等等。库就是多线程工具的一个大集合，非常值得学习。然而，多线程的这些五花八门的武器，其实也是证明了多线程本身，是一种不太容易使用的顺手的技术，但是我们一下子还没有更好的替代方案罢了。
多线程的对象模型
在多线程的代码下，除了启动线程的地方，是和正常的执行顺序不同以外，其他的基本都还是比较近似单线程代码的。但是如果在异步并发的代码下，你会发现，代码一定要装入一个个“回调函数”里。这些回调函数，从代码的组织形态上，几乎完全无法看出来其预期的执行顺序，一般只能在运行的时候通过断点或者日志来分析。这就对代码阅读带来了极大的障碍。因此现在有越来越多的程序员关注“协程”这种技术：可以用类似同步的方法来写异步程序，而无需把代码塞到不同的回调函数里面。协程技术最大的特点，就是加入了一个叫的概念，这个关键字所在的代码行，是一个类似的作用，但是又代表着后续某个时刻，程序会从的地方继续往下执行。这样就把那些需要回调的代码，从函数中得以解放出来，放到的后面了。在很多客户端游戏引擎中，我们写的代码都是由一个框架，以每秒帧的速度在反复执行，为了让一些任务，可以分别放在各帧中运行，而不是一直阻塞导致“卡帧”，使用协程就是最自然和方便的了——就自带了协程的支持。
在多线程同步程序中，我们的函数调用栈就代表了一系列同属一个线程的处理。但是在单线程的异步回调的编程模式下，我们的一个回调函数是无法简单的知道，是在处理哪一个请求的序列中。所以我们往往需要自己写代码去维持这样的状态，最常见的做法是，每个并发任务启动的时候，就产生一个序列号，然后在所有的对这个并发任务处理的回调函数中，都传入这个参数，这样每个回调函数，都可以通过这个参数，知道自己在处理哪个任务。如果有些不同的回调函数，希望交换数据，比如函数的处理结果希望函数能得到，还可以用作为把结果存放到一个公共的哈希表容器中，这样函数根据传入的就能去哈希表中获得函数存入的结果了，这样的一份数据我们往往叫做“会话”。如果我们使用协程，那么这些会话可能都不需要自己来维持了，因为协程中的栈代表了会话容器，当执行序列切换到某个协程中的时候，栈上的局部变量正是之前的处理过程的内容结果。

协程的代码特征
为了解决异步编程的回调这种复杂的操作，业界还发明了很多其他的手段，比如表达式、闭包、模型等等，这些都是希望我们，能从代码的表面组织上，把在多个不同时间段上运行的代码，以业务逻辑的形式组织到一起。
最后我想说说函数式编程，在多线程的模型下，并行代码带来最大的复杂性，就是对堆内存的同时操作。所以我们才弄出来锁的机制，以及一大批对付死锁的策略。而函数式编程，由于根本不使用堆内存，所以就无需处理什么锁，反而让整个事情变得非常简单。唯一需要改变的，就是我们习惯于把状态放到堆里面的编程思路。函数式编程的语言，比如或者，其核心数据结果是链表——一种可以表示任何数据结构的结构。我们可以把所有的状态，都放到链表这个数据列车中，然后让一个个函数去处理这串数据，这样同样也可以传递程序的状态。这是一种用栈来代替堆的编程思路，在多线程并发的环境下，非常的有价值。
分布式程序的编写，一直都伴随着大量的复杂性，影响我们对代码的阅读和维护，所以我们才有各种各样的技术和概念，试图简化这种复杂性。也许我们无法找到任何一个通用的解决方案，但是我们可以通过理解各种方案的目标，来选择最适合我们的场景：

动态多进程——同质的并行任务

多线程——能明确划的逻辑复杂的并行任务

异步并发回调——对性能要求高，但中间会被阻塞的处理较少的并行任务

协程——以同步的写法编写并发的任务，但是不合适发起复杂的动态并行操作。

函数式编程——以数据流为模型的并行处理任务


分布式数据通信
分布式的编程中，对于时间片的切分本身不是难点，最困难的地方在于并行的多个代码片段，如何进行通信。因为任何一个代码段，都不可能完全单独的运作，都需要和其他代码产生一定的依赖。在动态多进程中，我们往往只能通过父进程的内存提供共享的初始数据，运行中则只能通过操作系统间的通讯方式了：、信号、共享内存、管道等等。无论那种做法，这些都带来了一堆复杂的编码。这些方式大部分都类似于文件操作：一个进程写入、另外一个进程读出。所以很多人设计了一种叫“消息队列”的模型，提供“放入”消息和“取出”消息的接口，底层则是可以用、共享内存、甚至是文件来实现。这种做法几乎能够处理任何状况下的数据通讯，而且有些还能保存消息。但是缺点是每个通信消息，都必须经过编码、解码、收包、发包这些过程，对处理延迟有一定的消耗。
如果我们在多线程中进行通信，那么我们可以直接对某个堆里面的变量直接进行读写，这样的性能是最高的，使用也非常方便。但是缺点是可能出现几个线程同时使用变量，产生了不可预期的结果，为了对付这个问题，我们设计了对变量的“锁”机制，而如何使用锁又成为另外一个问题，因为可能出现所谓的“死锁”问题。所以我们一般会用一些“线程安全”的容器，用来作为多线程间通讯的方案。为了协调多个线程之间的执行顺序，还可以使用很多种类型的“工具锁”。
在单线程异步并发的情况下，多个会话间的通信，也是可以通过直接对变量进行读写操作，而且不会出现“锁”的问题，因为本质上每个时刻都只有一个段代码会操作这个变量。然而，我们还是需要对这些变量进行一定规划和整理，否则各种指针或全局变量在代码中散布，也是很出现的。所以我们一般会把“会话”的概念变成一个数据容器，每段代码都可以把这个会话容器作为一个“收件箱”，其他的并发任务如果需要在这个任务中通讯，就把数据放入这个“收件箱”即可。在开发领域，和对应的服务器端机制，就是这种概念的典型实现。

相关推荐
上一篇 高性能服务器架构思路三——分布式系统概念
下一篇 高性能服务器架构思路五——分布式缓存
缓存系统在游戏业务中的特异性游戏社交化是近年来游戏行业发展的重要趋势，实时互动的实现和社交平台的能力是游戏社交化的两大关键。游戏中玩家的沟通协作从最初的文字交流，逐渐发展为音、视频结合的多场景下的实时互动，是游戏中社交关系建立和维持的关键因素。另外，游戏社交需依托于平台，如何构建玩家间的社交网是各大游戏厂商的重要考虑点，这对平台的能力提出了很高的要求。
本期腾讯云沙龙，与您一一探讨！
演讲主题：如何免费运营亿级手用户？
嘉宾简介 梁育榕    手游运营能力开放业务负责人手游资深运营经理，负责腾讯精品手游在手平台运营的策略。深耕游戏运营领域，对用户精细化运营、平台分发策略及游戏强结合社交玩法有深入独到的经验和理解。
演讲概要：针对手游上的社交能力、用户规模、运营效果，介绍腾讯游戏如何运用社交能力为玩家构建完整的生态闭环。同时，手游将通过腾讯云首次向广大游戏厂商开放核心社交资源，帮助游戏在手游平台深度挖掘用户价值。
下载：                                       

关于：系列沙龙由腾讯云主办，旨在为游戏开发者提供一个自由的交流分享平台。沙龙将围绕游戏行业趋势、研发技术、运维和推广等热点进行探讨。每期沙龙将邀请国内外游戏领域专家，分享游戏开发及运营过程中的思考和实践。
访问沙龙官网，了解最新沙龙资讯和更多往期回顾。本文为作者翻译文章，原文链接      “    ”
在给一个表创建外键时，总是会出现提示：
       
这信息基本是啥都没说，下面就来说说几种常见的导致错误的情况：

父表不存在
    
         
    _ 
      _  ````
    
       
    
   

解决方法：

先创建父表，再创建子表；
 __=后，创建子表，再创建父表； __=这备份常用方式


标点符号使用不对
错误方式
       _  ``
正确方式
      _  ````
      _  
      _  ``


父表或者父表中相关列的名字写错了错误
      _  
正确
      _  


父列和子列数据类型不一致    
         
    _   
    _   
    _   
    _      _
     ____ _ _
     __ _
    
      
 错误：父表中是类型，子表中_是类型
   
     
_   
  _  ````
  


父表中相关列上没有任何索引    
         
    _   
    _   
    _   
    _      _
     ____ _ _
     __ _
    
错误：因为父表_列上没有任何索引
   
     
__ 
  __  ```_`
  
正确
     ___
   
     
__ 
  __  ```_`
  

父表相关列有索引，但索引是一个多列索引，同时该列不是该做索引最左列    
         
    _   
    _   
    _   
    _      _
     ____ _ _
     __ _
    
错误：因为父表_列不是____索引的最左列
   
     
__ 
  __  ```_`
  
正确
     ___
   
     
__ 
  __  ```_`
  

父表和子表表列的字符集 或 排序集 不同    
         
    _   
    _   
    _   
    _      _
     ____ _ _
     __ _
    
错误：因为子表__ 列排序集是__而父表_列排序集是_
   
     
__      __
  __  ```_`
  
正确
   
     
__      _
  __  ```_`
  

父表不是  `` 
``   
  ``
 =  =
修改表为
   =


 后只有父表表名，没有列信息错误
   
     
_   
  _  
  
正确
   
     
_   
  _  _
  

父表是分区表  `` 
``   
  ``
 =  =
    
   
删除分区
    


父表中相关列是一个“虚拟列”而不是实际存储列版本以上

   
       
  _   
  _   
  _   _  _  
   __ _
  
修改方法
     _   _   _  _   
正确
   
       
  _   
    _  _
  

创建外键失败的更多提示信息：   
  `` 
  ``   
  ``     
   `__` ````
 =  =
  `` 
  ``   
  ``     
   `` ``
 =  =

        ````      
       
   \


   

          __
    ````      
         
         
架构师，首先要是一个高级攻城狮，熟练使用各种框架，并知道它们实现的原理。虚拟机原理、调优，懂得能让你写出性能更好的代码池技术，什么对象池，连接池，线程池……　　反射技术，写框架必备的技术，但是有严重的性能问题，替代方案字节码技术，没什么好说的，值得注意的是”直接内存”的特点，使用场景多线程同步异步各种集合对象的实现原理，了解这些可以让你在解决问题时选择合适的数据结构，高效的解决问题，比如的实现原理，好多五年以上经验的人都弄不清楚，还有为什扩容时有性能问题不弄清楚这些原理，就写不出高效的代码，还会认为自己做的很对总之一句话越基础的东西越重要，很多人认为自己会用它们写代码了，其实仅仅是知道如何调用而已离会用还差的远。　　熟练使用各种数据结构和算法，数组、哈希、链表、排序树…，一句话要么是时间换空间要么是空间换时间，这里展开可以说一大堆，需要有一定的应用经验，用于解决各种性能或业务上的问题。　　熟练使用操作系统，必备，没什么好说的 。　　熟悉协议，创建连接三次握手和断开连接四次握手的整个过程，不了解的话，无法对高并发网络应用做优化 熟悉协议，尤其是头，我发现好多工作五年以上的都弄不清和的生命周期以及它们之间的关联。　　系统集群、负载均衡、反向代理、动静分离，网站静态化 。　　分布式存储系统了解他们的优缺点，适用场景 。　　分布式缓存技术，提高系统性能必备，一句话，把硬盘上的内容放到内存里来提速，顺便提个算法一致性 。　　工具必备技能超级好用，高性能，基本不会挂掉的服务器，功能多多，解决各种问题。　　数据库的设计能力，必备，最基础的数据库工具，免费好用，对它基本的参数优化，慢查询日志分析，主从复制的配置，至少要成为半个 。其他数据库如。　　还有队列中间件。如消息推送，可以先把消息写入数据库，推送放队列服务器上，由推送服务器去队列获取处理，这样就可以将消息放数据库和队列里后直接给用户反馈，推送过程则由推送服务器和队列服务器完成，好处异步处理、缓解服务器压力，解藕系统。　　以上纯粹是常用的技术，还有很多自己慢慢去摸索吧因为要知道的东西很多，所以要成为一名合格的架构师，必须要有强大的自学能力，没有人会手把手的教给你所有的东西。　　想成为架构师不是懂了一大堆技术就可以了，这些是解决问题的基础、是工具，不懂这些怎么去提解决方案呢这是成为架构师的必要条件。　　架构师要针对业务特点、系统的性能要求提出能解决问题成本最低的设计方案才合格，人家一个几百人用户的系统，访问量不大，数据量小，你给人家上集群、上分布式存储、上高端服务器，为了架构而架构，这是最扯淡的，架构师的作用就是第一满足业务需求，第二最低的硬件网络成本和技术维护成本。　　架构师还要根据业务发展阶段，提前预见发展到下一个阶段系统架构的解决方案，并且设计当前架构时将架构的升级扩展考虑进去，做到易于升级否则等系统瓶颈来了，出问题了再去出方案，或现有架构无法扩展直接扔掉重做，或扩展麻烦问题一大堆，这会对企业造成损失。
架构师学习路线图如下：

架构师学习路线导语
各位老司机晚上好啊，上篇文章主要采用了 进行曲线分类，这篇文章主要采用机器学习的方法来实现曲线分类，基本思路是对训练集先用聚类方法如和等进行聚类，对数据打上标签，然后在对测试集采用分类方法决策树，等进行分类，决定测试集中曲线的类别，实现曲线较为准确的分类。主要内容包括数据处理，聚类分类算法讨论和结果分析。
一 数据处理
首先是数据采集，数据采集这一部分我在之前的文章”实习生的程序优化从到”已经详细描述了数据采集的全过程，这里主要关注的是数据特征的提取和数据的标准化方法。
 数据特征提取
数据特征的提取，可以把把数据特征分成三个部分统计特征，时域特征，频域特征。当然还有很多中分法，比如在我的下一篇文章，时序特征分析的，可以将数据分为四个部分趋势特征，周期特征，季节特征和随机特征。
先来说说数据的统计特征，统计特征主要集中在数据的中心趋势和离中趋势，中心趋势例如均值，中位数，众数，中列数等，离中趋势例如方差，极差，四分位数四分位数极差 ，变异系数   等
在统计特征方面，主要选择了均值，中位数，方差，变异系数。下面来解释下为啥选择这四个数值作为统计特征。
均值 这里没有直接使用均值的定义，因为均值极易受到极端值的影响。这里使用了截断均值 ，就是去掉极端值后剩余的数据做一个平均，在计算均值前，去掉了极端值正负的数据。这样就可以较为客观的反映出数据的中心趋势。
中位数 其实本来想用众数的，不过数据归一化后，众数就不太好找了，也可以用中位数来表达数据的集中趋势，反映出数据的分布情况。
方差 经常被用来描述数据的离散情况，就是离中趋势和分散度。这里也是用来描述数据的离散程度
变异系数    变异系数定义为标准差与均值的比值，是数据离散程度归一化的一种描述。主要用于均值大于的情况，优点是不需要参照数据的平均值。这个是为了消除测量尺度差距导致的误差，因为采样曲线有在好几万的数量级，也有在个位数的数量级。当然在使用变异系数时，最好将均值和标准差列出，变异系数的大小，同时受平均数和标准差两个统计量的影响。
其次是数据时域方面的特征。时域方面选择了自相关系数和信息熵作为参考。
自相关系数 也称为序列相关，直观的理解，这个系数是反映的是同一事件在两个不同时期的相关程度，就是度量自己过去的行为对现在的影响。这个系数主要在具有周期性的数据分析比较有用，可以有效的区分出具有周期的曲线数据。
信息熵 这个特征表示曲线的不确定性，换句话说，如果曲线呈现不规则或者随机的变化，则信息熵越大，反之，呈现周期性或者规律性变化，则信息熵越小。这个特征可以有效分辨出不规则的毛刺数据。
最后是频域特征，频域特征我处理的比较粗糙，就是将曲线进行小波变换得到一系列小波系数低频系数， 高频系数。
小波变换的实质是：原信号与小波基函数的相似性。小波系数就是小波基函数与原信号相似的系数。英文文献中是这样解释：                                      。
所以，处理的时候我就是简单的将小波系数去平均值，来描述曲线和基函数的相似度，区分不同特征的曲线。这一点确实有问题，关键是我对小波理论没有理解。哪位老司机带带我，怎样更好的使用小波变换描述信号的频域特征
当然除了这些特征，我还加入了一些自己造出来的特征，例如，为了识别下面的定时任务，我加入了一个”连续为时间长度”这样一个特征，用来专门区分定时任务。
 
图  定时任务数据类型
 数据标准化方法


还有其他的方法，比如用反函数正弦，余弦，正切等将数据映射到区间上，也可以实现规范化，效果也不错。 
二．聚类算法实现过程
数据特征提取完之后，把数据集分为训练集和测试集，先用测试集做聚类无监督学习打标签，并观察输出聚类结果，调整参数直到聚类结果达到较好的效果。
聚类算法首先选用的是，这是一种选定初始质心，不断更新质心的值直到聚类结果不在发生变化的算法，的基本步骤如下

从中随机取个元素，作为个簇的各自的质心。

分别计算剩下的元素到个簇中心的相异度，将这些元素分别划归到相异度最低的簇。

根据聚类结果，重新计算个簇各自的中心，计算方法是取簇中所有元素各自维度的算术平均数。

将中全部元素按照新的中心重新聚类。

重复第步，直到聚类结果不再变化。

将结果输出。


在实际应用时采用中的函数，可以指定簇的个数_ 选定质心的方式是随机还是 官网上的例子一般是选的 给出的解释是可以提高算法效率还有质心误差控制，就是说在迭代过程中，如果质心的变化小于 则算法结束。
主要调整的参数就是这三个，算法结束后会返回计算出的标签值_，聚类结果如下图所示，共条数据分钟粒度作为训练集主要展示毛刺，定时任务和周期性变化的数据。

图  周期性数据天数据，一天不明显

图 毛刺天数据

图 定时任务天数据
关于聚类算法的总结，昨天看到了一篇老司机的总结，写的太好了，这里就不一一总结了文末有链接，已收藏。我来说说我用过的方法和一些聚类算法的思考。
聚类算法 算法是一种层次聚类算法 ，适用场景主要是大规模数据和较多的簇，基本原理是构建一颗树特征树，通过将节点不断的加入到树中，调整树的结构，最后完成聚类。算法是一种增量的俄聚类算法，如果簇不是球形的，不能很好的工作，因为方法用了半径的概念控制聚类的边界。
簇半径表示簇中所有点到簇质心的平均距离。中存储的是簇中所有数据点的特性的统计和，所以当我们把一个数据点加入某个簇的时候，那么这个数据点的详细特征，例如属性值，就丢失了，由于这个特征，聚类可以在很大程度上对数据集进行压缩。所以，半径和质心的选择会影响树的规模。
中算法主要调整两个参数，一个是_簇的个数，另一个是_计算标签。还有一个_主要用于调整树的规模，这个我不太会调，因为我不太清楚这个参数和样本规模之间的准确关系，所以我是使用的默认值。如果有老司机知道的话，快带我上车。
聚类算法 基于质心的一种算法。这个算法不用指定簇的个数，而是给出一个_这个值，由这个值来决定簇的个数。基本思路是通过一个不断移动的高维圆，规定一个向量，向概率密度高的地方不断移动，将概率密度高相似的的数据归为一类。
这个算法结果也不错，在使用过程中_这个值对最后结果产生主要影响。中_有两个参数我理解的是计算向量所需要的样本百分比 _每次计算所需要的样本数。对于采集到的样本，=，_=聚类结果较为合理，将数据集聚类为种，定时任务和毛刺数据可以区分。
这里就介绍了运行结果比较好的算法，关于其他的聚类算法。老司机们可以参考官网文末有链接。
三．分类算法实现过程
训练集聚类完成打上标签过后，就可以对测试集进行分类了。分类算法我主要尝试了两种，决策树和。
先来看下决策树，中提供了很多参数，详细的解释如下图所示，实际应用的时候我只调整了一个参数就是选择采用信息熵还是基尼系数构建决策树。
决策树明显的优点就是结果易于解释，整个过程也比较好理解。看了一些论文和博客，感觉决策树算法很像人类做决策的过程。计算复杂度还好，泛化能力高，预测出来的结果较为准确。只需要少量的数据就可以做出较为精确的预测。
决策树的缺点就是容易过拟合，设置叶节点所需的最小样本数__可以避免这个问题。还有就是通过剪枝也可以避免过拟合的问题，关于如何剪枝我没有进行深入的研究，哪位老司机懂得话，萌新求上车，带带我啊。还有就是决策树生成的时候一般采用的是贪心算法，可能会陷入局部最优解，达不到全局最优。
采用决策树方法分类的结果如下图所示

图 毛刺数据天数据

图 定时任务天数据

图 周期性规律数据天数据
可以看出，决策树分类算法比较有效，可以将毛刺数据和定时任务和周期性任务加以区分。
但是决策树生成的规则有点复杂，我用一天的数据进行训练，决策树一共生成了近条分类规则。这些过于复杂的分类规则会不会影响测试集的分类结果呢，这个有待进一步深究，就分类效果看来，复杂的规则没有对分类结果产生重大的影响。
再来看下近邻算法，这种被称作懒惰学习的方法。是基于距离的一种分类方法，基本思路是如果一个样本在特征空间中的个最相似即特征空间中最邻近的样本中的大多数属于某一个类别，则该样本也属于这个类别。
的优点就是简单，不需要估计参数和训练，适合对多分类问题进行分类。
的缺点是计算量大，因为对于每一个待分类的数据都要计算距离，开销大。而且当出现样本倾斜时，可能会使分类效果变差。
算法现在出现了一些变种算法，采用权值的方法和该样本距离小的邻居权值大来改进，等人于年尝试利用贪心法，针对文件分类实做可调整权重的最近邻居法     ，以促进分类效果；而等人于年提出由于不同分类的文件本身有数量上有差异，因此也应该依照训练集合中各种分类的文件数量，选取不同数目的最近邻居，来参与分类。
其他的一些分类算法比如说这个比较适合二分类，随机森林这个我也尝试了下，直白点就是多个决策树做决策，效果不错。还有一些基于贝叶斯的分类方法，比如中的这个我没有尝试，因为没有完全理解算法原理，回学校会关注下贝叶斯分类器的原理。
四．结尾
这篇文章的思路和做法和之前在上的文章很类似，这里只是详细的描述曲线分类过程中自己遇到的问题和解决方法。但是还是有一些缺陷的，比如对于定时任务的分类
可以看出，定时任务数据中混入了一些其他的数据，仔细观察了下属于毛刺数据。一开始怀疑是聚类或者分类算法没有选好，但是在分析试验多个算法过后，范县结果并没有明显的改善。仔细分析过后，觉得是数据特征提取的问题，之前虽然加入了一个”连续为的时间长度”这样一个特征，然而还是没有区分出来。或许可以考虑小波变换，从频域的角度考虑下这个问题，因为看起来毛刺数据和定时任务应该在频率上有明显的分别，这个我回去好好学一下小波变换相关的知识。
下一篇文章萌新想从时间序列挖掘方面对监控平台的曲线预测做的工作做一个介绍，时间序列模型我觉得还是挺有意思的。
 
图 定时任务混入了一些毛刺数据
参考文献
官方网站   搜索框输入可以看到所有聚类算法的说明和对比
数据挖掘概念与技术 第二版数据特征提取和处理方面的参考书
维基百科关于数据频域时域特征的解释小波变换，自相关，信息熵等
麦子学院的机器学习课程，关于机器学习的方法我就是看这个课程入门的
聚类方法的总结：机器学习：基于层次的聚类算法作者 |何龙编辑 | 顾乡
一、背景
近期在进行资源调度管理平台的重构工作，其中的数据库设计，在没有更加优化的方案前，打算沿用当前平台的数据库结构；这就需要对当前平台的数据库结构进行剖析研究，并对其性能进行测试与分析，得出的数据结果作为后续设计和优化的参考。
二、测试方法
、测试工具：，是之后自带的基准测试工具，该工具可以模拟多个客户端同时并发的向服务器发出查询更新，给出了性能测试数据而且提供了多种引擎的性能比较。官方介绍：，使用方法：
、测试流程：建立测试数据库和待测试的表 → 根据的结构，利用脚本生成一定数量的有效随机数据 → 利用对相应语句进行测试 → 结果数据的分析。
、关键语句：考虑到资源平台的实际应用情况，通过资源属性查询资源的操作为主要操作，且这类操作的耗时占总操作耗时的比例为最大，故对应这类操作的查询语句为关键语句，对整个数据库性能影响很大，我们可以通过测试这个关键语句得出的结果来评估整个数据库的性能。
三、测试过程
、建表：
通过属性查询资源需要两张表：设备表和设备属性对应表。表对应资源，记录资源的基本信息，如，，，等等；表对应资源和属性的关系，记录每个资源的每个属性和属性值；它们的结构如下所示：

通过多个属性组合查询表，获得相应的 ，即是满足条件的设备，进而能直接在表中查询得到其基本属性。
本次测试的关键语句即是从表中组合查询出满足条件的，故本测试只需要用到一张表。
、生成随机数据并插入相应的表中：
这里编写了几个生成随机数据的函数_，_，_，_，并编写了存储过程_，用来将一定量数据批量插入表中。
然后将整个建表和存储数据的过程写进一个脚本中，并在中运行这个脚本，待测试的表和数据就建立好了。脚本在附录如下图所示，生成的随机数据有条：
 
、利用进行测试：
   整个数据库的关键操作为通过属性查询资源，该操作的关键语句就是  
            ；
   例：查询拥有或者属性的所有资源的为：
      = ‘’   = ‘’   
   在建立好待测数据库后，就可以利用进行测试，命令如下所示：
   = =     =  =       
 以上语句表示：使用数据库，使用所指定的语句，测试个并发查询，每一个查询次。
该语句的测试结果如下图所示：
 
结果中可以看到执行语句的平均耗时，最大耗时和最小耗时，并发线程数等等。
四、结果分析
在不同数据容量，不同并发数，不同查询属性数的条件下进行多次测试并取平均值，所得到的数据分以下几种情况进行分析：
、在表数据容量为条，并发数分别为、、、、、，查询属性数分别为、、、、的情况下，查询语句的耗时：

从上表可以看出，在查询属性数相同条件下，并发数增长一倍，耗时也基本增加一倍；在并发数以下时，查询耗时不超过毫秒；在并发左右的实际应用情况下，耗时在毫秒左右；性能基本满足新资源平台的要求。
、在并发，表容量分别为、、条，查询属性数从至的情况下，查询语句的耗时：

从上表可以看出，在并发数一定的情况下，随着语句中查询属性数的增多，耗时线性增加，这种线性关系数据容量无关。
、在并发，查询属性数为，不同数据容量的情况下，查询语句的耗时：
从上表可以看出，在其他条件一定的情况下，随着数据容量的增长，耗时呈线性增长，在贴近实际条件的情况下左右数据容量，左右并发数，左右查询属性，耗时为毫秒，满足新资源管理平台的需求。
附录：
生成测试数据的脚本：
 

    
    _
    _
    _
    _
    _
    _

      

   
 
     
 
 
 
  


  

   
 



  

 
 
 


 

  _
 

 _   
    
  = 
 
    _ = 
    _ = 
    _ = 
    _ = 
    _ = 
    _ = 
    _ = 
    _ = 
    _ = 
    _ = 
  _ = 
 
 _


  _
 

    
  = 
 


  _
 

 _   
    
  = 

    _ = 
    _ = 
  _ = 
 
 _


  _
 

 _   
 _ = 
 _


  _    

    

 =
   ___
  =
 


  _    

    

 =
   _
  =
 


 _
 _

相关推荐
基于的云数据库搬迁实例解析数据库的高可用性分析数据库设计总结接上篇 《腾讯云 部署  实践》
环境准备
设置 服务开机启动
  
安装
  
_ 
配置
 
__  
指定配置文件
  
指定守护的程序配置
 
在最后增加

=
配置开机启动
新建一个“”文件
     
   

= 


=
=  
= 
= 
=
=
=


=
将文件拷贝至：“”
执行命令：  
配置守护
新增配置
 

=    =
=
=
_=
_=
=_=
=
=
重加载配置
 

  
查看是否被守护进程拉起

重启电脑查看是否自动启动

访问站点


相关推荐【腾讯云的种玩法】 部署  实践【腾讯云的种玩法】 部署眼下，人工智能已经成为越来越火的一个方向。政府和企业对人工智能产业越来越重视，云计算使得  工程师的门槛逐步降低。如何成为一名工程师，俨然成为程序员重点讨论的热门话题之一。
年，人工智能产业或将爆发
今年的两会上，国务院总理李克强发表政府工作报告，指出要加快培育壮大包括人工智能在内的新兴产业，人工智能首次被写入了政府工作报告。
不仅政府重视， 企业更是投入重金。百度已经将人工智能列为核心发展战略，腾讯也广招人才，成立  实验室等部门。
再加上云计算等配套计算环境的成熟与完善， 云服务器、 云服务器相继推出如腾讯云，人工智能产业今年或将迎来一个爆发式发展时期。
用数据告诉你：什么样的人可以成为工程师？薪酬如何？
基于腾讯云上的  爬虫，我们抓取了几家主流招聘网站的  相关的技术岗位，剔除重复数据和非工程师类的岗位需求， 相关的技术岗位样本量为份。

最高薪酬的个岗位万，万两档，要求硕士以上学历的个，比例，比工程师中硕士学历要求的平均比例，要高一倍。

可以看到对于  相关的技术岗位，万万年薪基本上是比较主流的收入水平，相较于其他技术岗位，基本上是年以上工作经验的架构师的收入水平。
份样本数据中，万以下年薪份，万年薪份，万份，万份，面议类的份，局限在于很多年薪数百万的岗位不会被猎头发布出来。

薪酬和地域相关也与行业有关，万以下的岗位个，有个在二线城市，同时个万以下收入岗位属于非行业。
领域目前在招的初级岗位较多，行业很缺资深人士。份招聘岗位需求中：年工作经验要求占比，年的，年只占比。      
不同类型的企业也拿出了各自的高招来吸引优秀的人才，比较有意思的比如创新工场旗下的人工智能研究院拿出“李开复亲任院长”这样的职位诱惑参与人才抢夺战。其他常见的招揽手段，除了高薪，依次为：补助份岗位，弹性工作份岗位，双薪份岗位，期权份岗位，聚餐份岗位，旅游份岗位。
不过做为一位普通程序员，我还是觉得给期权和双薪比较能吸引我。至于说聚餐和旅游，如果不是去美国和南北极，真心对我吸引力不大。

但是，人工智能行业的门槛，显然比网站开发、 开发等成熟岗位更高。我们来看某国内招聘网站的一则  工程师招聘：
上面的岗位要求，简单来说就是要全球顶级名校毕业，在知名期刊发表过论文。这个岗位薪资非常可观，要求虽然只有两条，但没有人会觉得门槛低。曾经的百度广告变现算法核心负责人戴文渊曾说，“我自己从什么都不会，学到今天这个水平可能花了年的时间。”
不过，人工智能产业的门槛正在慢慢降低。许多云计算公司都将内部积累的人工智能技术，与云计算结合起来，提供诸如语音识别、图像鉴黄、机器翻译等人工智能服务，如腾讯云甚至开放了多达种人工智能能力。
普通工程师甚至可以借助这些开放出来的能力，做出效果不错的人工智能产品。曾有技术专家畅想，如果未来技术得到大幅改进，通过以深度学习为代表的技术革新，大幅地用机器替代人工，可以让一个普通的技术人员培训个月就可以成为一个‘科学家’。如果这成为现实，那么未来人人可能都可以成为工程师。

相关阅读人人都可以做深度学习应用：入门篇本文作者： 程柳锋 

开发工具过程中，为了便于扩展，将的实现分为基础功能和扩展功能。基础功能包括、、、等伴随工程从初始化到最终发布到生产环境，也即为 的。扩展功能包括规范检测、代码生成、图片上传等和多个平台集成的开发配套服务设施。本篇文章将会叙述如何优雅的实现插件机制，通过插件扩展子命令和开放的生态。
初始化流程
运行某个命令时，的初始化加载如下图：第一步，判断当前用户信息，获取用户的名字。然后读取的配置信息，包括的根目录，插件目录路径。之后加载内部核心插件和安装的外部插件，最后整个初始化过程完成。外部插件加载先读取根目录一般设在目录下，比如下的里的和内容，过滤掉不是以开头的包。然后通过的方式加载各个插件。

     {
          {
              = _
              =  

              
              {
                   
            } {
                { }     
            }
        }
    }

    
         
      
     {
          = _ 
          = _

            
          {
               

                 
              {
                  = 
                  =  ||  || {}

                 
            }
        } {
                     
             |\  

                 
              =  
             
        }
    }
外部插件执行
外部插件包从本地的目录读取之后，接下来就需要执行插件代码了。那么插件包里如何获取的上下文环境呢？这里有一个非常巧妙的设计，需要使用提供的和模块，这样通过 的文件，都可以通过变量注入到插件里的全局变量访问到的实例，从而能够访问上的各种属性，比如 和一些等。
  = 
  = 


      {
          = 
          {
              =  
             = 
             = _

              {
                 
            }

             =  {
                 _ 
            }
             = 
             = _
             = _

            =    __ __ { 
                 }

              =  
                  
        }
    }
插件的
插件代码执行过程中，需要获取某个命令是否有注册过，及注册新的子命令及子命令的处理方法。
  {

     {
         = {}
         = {}
    }

     {
         = 
         
    }

     {
         
    }

        {
              

          {
              {
                   ===  {
                     = 

                       ===  {    
                         = 
                         = 
                    }  {    
                         = {}
                    }
                }  {
                          
                }
            }  {
                  
                   ===  {
                     = 
                     = {}
                     = 
                }  {
                          
                }
            }
        }

            {
             = 
        }  {
             = 
        }

          =  = 
         = 
         = 

         = 
    }
}
通过方法来注册的命令会将子命令及其处理函数存储在上下文的里面。比如：

  {
      
}
之后就可以通过运行 来运行插件扩展的命令了。  
子命令调用
初始化完成后，用户输入命令都会从上下文的来查找是否有注册过该命令。
  =    {
       ===  {
     = 
     = {}
  }

    = 

      {
      = 

      {
        
    }  {
        `    `     
    }
  }
}
存在的问题
上述实现方式存在一个问题，每次运行一个命令都需要重现初始化一次。后续考虑编写一个来守护进程。

原文出处：社区 未经同意，禁止转载系列推荐
机器学习概念总结笔记二机器学习概念总结笔记三机器学习概念总结笔记四
前言
，机器学习算法分类
监督学习： 有 ， 里面的取值已知。
无监督学习：有   里面的取值未知。
半监督学习：有 ，  里面的取值有些知道有些不知道。
增强学习： ， 无 。
，常见算法

，算法概念学习
最小二乘回归
最小二乘回归英文名：   ， 又叫  是常见的线性回归方法。最小二乘法的基本原则是：最优拟合直线应该使各点到直线的距离的和最小，也可表述为距离的平方和最小。
 经典线性回归模型的基本假设：，残差具有零均值； ∞即残差具有常数方差，且对于所有值是有限的；残差项之间在统计意义上是相互独立的；残差项与变量无关；残差项服从正态分布；
如果满足假设－，由最小二乘法得到的估计量具有一些特性，它们是最优线性无偏估计量   ，简记。线性：意味着与随机变量之间是线性函数关系；无偏：意味着平均而言，实际由样本数据得到的的参数值与其总体数据中的真实值是一致的；最优：意味着在所有线性无偏估计量里，估计量具有最小方差。
回归常见的个必须要解决的问题在于：
异方差性： 残差的方差不为常数， 残差与相关，变大，残差变大， 违反了假设和
自相关性：残差项之间自相关，违反了假设
多重共线性：多个之间不独立，即与之间存在相关性。
岭回归
岭回归英文名：   是一种专用于共线性数据分析的有偏估计回归方法，实质上是一种改良的最小二乘估计法回归，通过放弃最小二乘法的无偏性，以损失部分信息、降低精度为代价获得回归系数更为符合实际、更可靠的回归方法，对病态数据的拟合要强于最小二乘法。
一般线性回归是最小二乘法回归，残差计算是平方误差项。岭回归 是在平方误差的基础上增加正则项，通过确定的值可以使得在方差和偏差之间达到平衡：随着的增大，模型方差减小而偏差增大。

岭回归是对最小二乘回归的一种补充，它损失了无偏性，来换取高的数值稳定性，从而得到较高的计算精度。通常岭回归方程的平方值会稍低于普通回归分析，但回归系数的显著性往往明显高于普通回归，在存在共线性问题和病态数据偏多的研究中有较大的实用价值。
备注：回归问题时，如果选择个数太多，会导致模型复杂度膨胀性增大。如果选择太少，可能导致模型的预测能力不够。选择数目过多，一方面太复杂，另外一方面会使得构建出来的模型对 的数据，导致这个模型应用于 时效果并不好。因此需要有一个机制来做特征选择，即需要对的集合有所取舍。特征选择有种类型：子集选择；收缩方法 ，又叫做正则化，这里就会出现岭回归方法和回归方法。维数缩减，即降维
回归
回归英文名：      其实本质是一种降维方法， 由提出。这种算法通过构造一个惩罚函数获得一个精炼的模型；通过最终确定一些指标的系数为零，算法实现了指标集合精简的目的。这是一种处理具有复共线性数据的有偏估计。的基本思想是在回归系数的绝对值之和小于一个常数的约束条件下，使残差平方和最小化，从而能够产生某些严格等于的回归系数，得到解释力较强的模型。
回归
回归英文名：   ，最小角回归。于年提出的一种变量选择的方法，类似于向前逐步回归 的形式。从解的过程上来看它是回归的一种高效解法。
最小角回归和模型选择比较像，是一个逐步的过程，每一步都选择一个相关性最大的特征，总的运算步数只和特征的数目有关，和训练集的大小无关。最小角回归训练时的输入为特征矩阵 ={}，和期输出向量={}， 是长度为的矩阵，表示训练集的大小，则是特征的数目。还有一点需要注意的是，向量 和  都是正则化之后的向量，即它们的元素的均值为，且每个向量的长度都是，这样做的目的是为了后面计算相关性以及角度的方便。
有点像 向前逐步回归，但和 不同点在于， 每次都是根据选择的变量子集，完全拟合出线性模型，计算出，再设计统计量如对较高的模型复杂度作出惩罚，而是每次先找出和因变量相关度最高的那个变量 再沿着的方向一点点调整这个的系数，在这个过程中，这个变量和残差的相关系数会逐渐减小，等到这个相关性没那么显著的时候，就要选进新的相关性最高的变量，然后重新沿着的方向进行变动。而到最后，所有变量都被选中，估计就和相同了。
的算法实际执行步骤如下：  对进行标准化去除不同尺度的影响，对 进行中心化去除截距项的影响，初始的所有系数都设为，此时残差  就等于中心化后的 。  找出和残差相关度最高的变量_。  将_的系数_ 从开始沿着只有一个变量_的最小二乘估计的方向变化，直到某个新的变量_与残差的相关性大于_时。 _和_的系数_和_，一起沿着新的【  最小二乘估计】加入了新变量_的最小二乘估计的方向移动，直到有新的变量被选入。 重复，，，直到所有变量被选入，最后得到的估计就是普通线性回归的。
支持向量回归
支持向量回归英文名：  。支持向量机  是一种比较好的实现了结构风险最小化思想的方法。它的机器学习策略是结构风险最小化原则 为了最小化期望风险，应同时最小化经验风险和置信范围
支持向量机方法可以用于回归和分类， 它的基本思想：  它是专门针对有限样本情况的学习机器，实现的是结构风险最小化：在对给定的数据逼近的精度与逼近函数的复杂性之间寻求折衷，以期获得最好的推广能力；  它最终解决的是一个凸二次规划问题，从理论上说，得到的将是全局最优解，解决了在神经网络方法中无法避免的局部极值问题；
  它将实际问题通过非线性变换转换到高维的特征空间，在高维空间中构造线性决策函数来实现原空间中的非线性决策函数，巧妙地解决了维数问题，并保证了有较好的推广能力，而且算法复杂度与样本维数无关。
目前，  算法在模式识别、回归估计、概率密度函数估计等方面都有应用，且算法在效率与精度上已经超过传统的学习算法或与之不相上下。 对于经验风险，可以采用不同的损失函数来描述，如不敏感函数、函数、函数、函数等。核函数一般有多项式核、高斯径向基核、指数径向基核、多隐层感知核、傅立叶级数核、样条核、  样条核等，虽然一些实验表明在分类中不同的核函数能够产生几乎同样的结果，但在回归中，不同的核函数往往对拟合结果有较大的影响。
支持向量回归算法主要是通过升维后，在高维空间中构造线性决策函数来实现线性回归，用不敏感函数时，其基础主要是  不敏感函数和核函数算法。若将拟合的数学模型表达多维空间的某一曲线，则根据 不敏感函数所得的结果，就是包括该曲线和训练点的“ 管道”。在所有样本点中，只有分布在“管壁”上的那一部分样本点决定管道的位置。这一部分训练样本称为“支持向量”。为适应训练样本集的非线性，传统的拟合方法通常是在线性方程后面加高阶项。此法诚然有效，但由此增加的可调参数未免增加了过拟合的风险。支持向量回归算法采用核函数解决这一矛盾。用核函数代替线性方程中的线性项可以使原来的线性算法“非线性化”，即能做非线性回归。与此同时，引进核函数达到了“升维”的目的，而增加的可调参数是过拟合依然能控制。
回归
英文名：    分类回归树，是一种很重要的机器学习算法，既可以用于创建分类树 ，也可以用于创建回归树 。 将用于回归分析时就叫做回归。
算法的重要基础包含以下三个方面：二分 ：在每次判断过程中，都是对观察变量进行二分。算法采用一种二分递归分割的技术，算法总是将当前样本集分割为两个子样本集，使得生成的决策树的每个非叶结点都只有两个分枝。因此算法生成的决策树是结构简洁的二叉树。因此算法适用于样本特征的取值为是或非的场景，对于连续特征的处理则与算法相似。单变量分割    ：每次最优划分都是针对单个变量。剪枝策略：算法的关键点，也是整个算法的关键步骤。剪枝过程特别重要，所以在最优决策树生成过程中占有重要地位。有研究表明，剪枝过程的重要性要比树生成过程更为重要，对于不同的划分标准生成的最大树 ，在剪枝之后都能够保留最重要的属性划分，差别不大。反而是剪枝方法对于最优树的生成更为关键。
当数据拥有众多特征并且特征之间关系十分复杂时，构建全局模型的想法就显得太难了，也略显笨拙。而且，实际生活中很多问题都是非线性的，不可能使用全局线性模型来拟合任何数据。一种可行的方法是将数据集切分成很多份易建模的数据，然后利用线性回归技术来建模。如果首次切分后仍然难以拟合线性模型就继续切分。在这种切分方式下，树结构和回归法就相当有用。
　创建回归树时，观察值取值是连续的、没有分类标签，只有根据观察数据得出的值来创建一个预测的规则。在这种情况下， 的最优划分规则就无能为力，则使用最小剩余方差  来决定 的最优划分，该划分准则是期望划分之后的子树误差方差最小。创建模型树，每个叶子节点则是一个机器学习模型，如线性回归模型。
回归树与分类树的思路类似，但叶节点的数据类型不是离散型，而是连续型，对稍作修改就可以处理回归问题。算法用于回归时根据叶子是具体值还是另外的机器学习模型又可以分为回归树和模型树。但无论是回归树还是模型树，其适用场景都是：标签值是连续分布的，但又是可以划分群落的，群落之间是有比较鲜明的区别的，即每个群落内部是相似的连续分布，群落之间分布确是不同的。所以回归树和模型树既算回归，也称得上分类。
回归是为了处理预测值是连续分布的情景，其返回值应该是一个具体预测值。回归树的叶子是一个个具体的值，从预测值连续这个意义上严格来说，回归树不能称之为“回归算法”。因为回归树返回的是“一团”数据的均值，而不是具体的、连续的预测值即训练数据的标签值虽然是连续的，但回归树的预测值却只能是离散的。所以回归树其实也可以算为“分类”算法，其适用场景要具备“物以类聚”的特点，即特征值的组合会使标签属于某一个“群落”，群落之间会有相对鲜明的“鸿沟”。如人的风格是一个连续分布，但是却又能“群分”成文艺、普通和三个群落，利用回归树可以判断一个人是文艺还是，但却不能度量其有多文艺或者多。所以，利用回归树可以将复杂的训练数据划分成一个个相对简单的群落，群落上可以再利用别的机器学习模型再学习。
模型树的叶子是一个个机器学习模型，如线性回归模型，所以更称的上是“回归”算法。利用模型树就可以度量一个人的文艺值了。回归树和模型树也需要剪枝剪枝理论和分类树相同。为了获得最佳模型，树剪枝常采用预剪枝和后剪枝结合的方法进行。
树回归中，为成功构建以分段常数为叶节点的树，需要度量出数据的一致性。分类决策树创建时会在给定节点时计算分类数据的混乱度。那么如何计算连续型数值的混乱度呢？ 事实上， 在连续数据集上计算混乱度是非常简单的–度量按某一特征划分前后标签数据总差值，每次选取使数据总差值最小的那个特征做最佳分支特征为了对正负差值同等看待，一般使用绝对值或平方值来代替上述差值。为什么选择计算差值呢》差值越小，相似度越高，越可能属于一个群落咯。那么如果选取方差做差值，总方差的计算方法有两种：计算数据集均值，计算每个数据点与的方差，然后个点求和。计算数据集方差，然后_ = ，为数据集数据数目。 中可以利用方法求得数据集方差，因此该方法简单、方便。
与 对离散特征和连续特征的处理方法类似，多值离散特征需要选择最优二分序列，连续特征则要找出最优分裂点。那么，每次最佳分支特征的选取过程为： 先令最佳方差为无限大=。依次计算根据某特征次迭代划分数据后的总方差，计算方法为：划分后左右子数据集的总方差之和，如果，则=返回最佳分支特征、分支特征值离散特征则为二分序列、连续特征则为分裂点的值，左右分支子数据集。
分类
当将用于分类问题时需要构建分类树。
创建分类树递归过程中，每次都选择当前数据集中具有最小信息增益的特征作为结点划分决策树。算法和算法虽然在对训练样本集的学习中可以尽可能多地挖掘信息，但其生成的决策树分支、规模较大，算法的二分法可以简化决策树的规模，提高生成决策树的效率。对于连续特征，也是采取和同样的方法处理。为了避免过拟合，决策树需要剪枝。预测过程当然也就十分简单，根据产生的决策树模型，延伸匹配特征值到最后的叶子节点即得到预测的类别。
与的不同之处是节点分裂建立在指数这个概念上，指数主要是度量数据划分或训练数据集的不纯度为主。值越小，表明样本的纯净度越高即该样本只属于同一类的概率越高。衡量出数据集某个特征所有取值的指数后，就可以得到该特征的  ，也就是。不考虑剪枝情况下，分类决策树递归创建过程中就是每次选择最小的节点做分叉点，直至子数据集都属于同一类或者所有特征用光了。
因为二分的特性，当训练数据具有两个以上的类别，需考虑将目标类别合并成两个超类别，这个过程称为双化。指数是一种不等性度量，通常用来度量收入不平衡，可以用来度量任何不均匀分布，是介于之间的数，完全相等，完全不相等。分类度量时，总体内包含的类别越杂乱，指数就越大跟熵的概念很相似。对于一个数据集，其计算方式为：

分析分类回归树的递归建树过程，不难发现它实质上存在着一个数据过度拟合问题。在决策树构造时，由于训练数据中的噪音或孤立点，许多分枝反映的是训练数据中的异常，使用这样的判定树对类别未知的数据进行分类，分类的准确性不高。因此试图检测和减去这样的分支，检测和减去这些分支的过程被称为树剪枝。树剪枝方法用于处理过分适应数据问题。通常，这种方法使用统计度量，减去最不可靠的分支，这将导致较快的分类，提高树独立于训练数据正确分类的能力。决策树常用的剪枝常用的简直方法有两种：预剪枝和后剪枝。预剪枝是根据一些原则及早的停止树增长，如树的深度达到用户所要的深度、节点中样本个数少于用户指定个数、不纯度指标下降的最大幅度小于用户指定的幅度等；后剪枝则是通过在完全生长的树上剪去分枝实现的，通过删除节点的分支来剪去树节点，可以使用的后剪枝方法有多种，比如：代价复杂性剪枝、最小误差剪枝、悲观误差剪枝等等。常采用事后剪枝方法，构建决策树过程中的第二个关键就是用独立的验证数据集对训练集生长的树进行剪枝。
更多详见：机器学习概念总结笔记二机器学习概念总结笔记三机器学习概念总结笔记四     什么是分布式集群
为了理解分布式集群这个概念，我们先说说这两个概念：“集群”和“分布式”。艺术来源于生活，计算机科学亦是如此。我们先通过例子，来了解一下现实生活中的“集群”和“分布式”。
从开餐馆说起：你开了一家餐馆，自己掌勺后厨即做菜。随着生意越来越好，发现自己忙不过来。于是你聘请了两个厨师，你们三位厨师就是一个“集群”。主要的职责是：洗菜、配菜、炒菜。你们关系如下：

随着生意越来越好，两种方式增加后厨的生产力：继续增加厨师—相当于扩大集群；引入流水线的机制，精细化分工。找人分担厨师洗菜、配菜等工作。类似下图。

其实，流水线提现了分而治之的思想。即将一个大任务分解为多个小任务，提高小任务的生产力，从而提高了整体的生产力。而“分布式”解决问题的思路：正是吸取了将大任务分步为多个小任务的思想，才得到通过跨地域的分布解决大问题。
从解决问题的角度，说一下分布式与集群的差异：

分布式是以缩短单个任务的执行时间来提升效率的；

集群则是通过提高单位时间内执行的任务数来提升效率。


从软件部署的角度，说一下分布式和集群的关系：

分布式是指将不同的业务分布在不同的地方；

集群则是将几台服务器集中在一起，实现同一业务；

分布式中的每一个节点，都可以做集群；

集群并不一定就是分布式的。


综上所述，一个较为理想的分布式集群应该是这样的：一个分布式系统，是通过多个节点组成的，各节点都是集群化，并且各集群还是分布式的。
     什么是负载均衡
一台服务器的处理能力，主要受限于服务器自身的可扩展硬件能力。所以，在需要处理大量用户请求的时候，通常都会引入负载均衡器，将多台普通服务器组成一个系统，来完成高并发的请求处理任务。
提到的负载均衡，大家都想到了什么？，，，，反向代理，还是大名鼎鼎的？下面针对这些负载均衡技术做了分类和归纳。

其实上面描述的解决方案，通常都是互联网接入方案的负载均衡。而的服务方式是：通过简单易记的域名，屏蔽内部网络真实服务的，从而保证了内部服务器安全和可靠。基于这种服务方式，服务提供商可以在两处做负载均衡：

解析查询式，域名服务器在进行域名到服务反向解析的时候，根据用户网络接入特点等电信、网通等 ，将就近的服务列表返回给用户。鹅厂是这方面的翘楚，大家有兴趣可自行。

转发式，经过了上面就近接入，当用户请求到就近服务的时。通常的做法是引入转发节点通常是或者，通过均衡策略，将数据发送给多台 。


在介绍负载均衡的技术后，小伙伴们有没有这样的疑问。分布式系统各节点间的集群是如何做负载均衡呢？的负载均衡是否适用于分布式节点间呢？等等。
其实不同的技术为了解决不同场景的问题，下图就罗列的常用的负载均衡使用场景。

上图通过三种颜色包括图标和线条的部分，分别说明了不同场景下的负载均衡。

蓝色部分：用户通过查询式，获取到了就近接入的业务服务。

绿色部分：将用户请求集中转发的方法，完成了业务接入层的负载均衡。

红色部分：说明了通常分布式系统内部节点间的负载均衡。


其中，蓝色部分和绿色部分就是上面介绍的负载均衡部分。下面一章我们重点分析一下如何考虑分布式节点间的负载均衡。
     分布式集群的负载均衡
分布式各节点间的集群要做负载均衡的话，完全可以参考负载均衡的方式来做，即查询式和转发式。但是通常后台开发的皮皮虾们基本不会这么做，根本原因就是不同场景下，考虑的侧重点是不同的，导致均衡的方式也有很大的差别。
我们先说一下两个服务的基石：简单和安全。

简单：使用域名的服务，就是让用户通过简单易记的域名替代地址的访问方式，所以说“简单”应该说是用户的诉求。

安全：而“安全”是服务提供商的诉求。就是对外服务时最大程度上屏蔽内部服务器的地址、网络部署，从而保证内部服务的安全。


针对上述两点，就需要在提供服务时部署相应的节点支撑。如解析，转发、反向代理等。这些节点在保证服务的简单和安全时，也对系统服务引入了关键路径，增加了系统服务复杂性。
那么思考一下：分布式的各系统间，需要引入这么多节点来解决负载均衡的问题吗？
皮皮虾们的答案一定是：不需要☺。引入更多的节点意味越难保证系统的稳定性、可靠性。为什么这么说呢？
首先，分布式系统相对于集中式系统，是通过节点间相互传递消息通信协调工作的。节点间通信的不可靠性、不稳定性是分布式系统常态。这就导致系统的设计和开发时，需要针对每一种通信异常都有自身重试、恢复的解决方案。所以，引入更多的节点就意味着更复杂的重试、容灾、恢复等成本。
小伙伴们，有没有一种出师未捷身先死的感觉呢？  。还没有考虑负载均衡，仅仅是分布式系统间稳定性和可靠性，就已经很让人头疼了呢？所以说分布式的皮皮虾是苦逼的，落寞的，高贵的。请珍惜您身旁的每只皮皮虾☺
皮皮虾们不要皮，大司马出题了。
大司马：如果敌方打野没有在小地图的视野中，那么分布式系统的负载均衡要怎么做呢？
在学习了大司马的“正方形打野”，“边缘”，“你皮任你皮后”，这个问题我是这么看的。
我：更少的节点，更简单可靠的通信模式下，才能较好的完成负载均衡。
大司马：这位同学你很有灵性嘛。看不懂段子的，看加粗字字哈☺
怎么做好负载均衡呢？总结一下上面的段子就是一句话：  皮皮虾耳朵听出茧子了吧。

更少的节点：分布式业务节点数，需根据业务自身的特点确定。原则是：少且够用。

简单可靠的通信模式：这里给一个简单的通信方式，请求发送 服务确认。这种模式下可以减少因链接管理造成的服务器资源消耗。


如果自身系统的还是很复杂的话，其实也是有迹可循的。下面我整理一下，考虑负载均衡的要点。大家多多思考，根据自身业务特点取舍，最终一定会做出不错的负载均衡效果。

再强调一个关键点，小伙伴们一定要先找到系统中的均衡要点是什么？这里在说一下：请求均衡和数据均衡上图右下角。
请求均衡理想效果是：每个服务处理的请求是差不多的。
数据均衡理想效果是：每个服务处理存储的数据量是差不多的。
公司内部也有很好的均衡算法组件等自行哈，可以较好支持的请求均衡。使用这种组件也有一些限制，大家确认是否适合自己的系统哈。
最后，我们回顾负载均衡的本质，小伙伴们千万不要为了负载均衡而均衡：

功能：单台服务器能力有限。当处理大量用户请求时，通过需要多台服务器组成系统，从而完成高并发的请求处理。

描述：个客户端访问个服务端的问题。通常：，

难点：将的请求数据均匀分摊到多个操作单元上执行，关键是均匀。


同学们，下课啦 ！
：由于分布式和负载均衡是两个比较大的课题，本篇文章讲解的内容只是针对具体的场景下阐述。如果没有讲解到小伙伴们想了解的方面，同学们可以自行，。☺一、理解的浮点数
由标准制定，中所有的数字都是双精度浮点数，即位编码数字。大多数的算术运算符可以进行整数、浮点数或者两者的组合进行计算。但是位运算符比较特殊，不会直接把操作数作为浮点数进行运算。需要这些步骤完成运算：
、把操作数和转换成位整数；
、每一位按位或运算；
、把结果转换成位浮点数。比如
  |    
  |  = 
浮点数的计算是不精确的，浮点运算只能四舍五入到最接近的可表示的实数。当执行一系列的运算时，随着舍入误差的积累，运算结果会越来越不精确。比如
    
       
加法中的结合律在中对于浮点数有时候并不成立：
       
       
小心浮点数，解决其计算不精确的一个简单策略就是将浮点数转换成整数进行运算，整数的运算是精确的，不用担心舍入误差。
二、当心隐式的强制转换
中，运算符既重载了数字相加，又重载了字符串连接操作，这取决于其参数的类型，简单总结如下：
如果两个操作数都是数值，执行常规加法运算
如果有一个操作数是字符串，则将另一个操作数转换成字符串，再进行字符串的拼接
如果有一个操作数是对象、数值或布尔值，如果  方法存在并且返回原始类型，返回  的结果。如果 方法不存在或者返回的不是原始类型，调用  方法，如果  方法存在，并且返回原始类型数据，返回  的结果。其他情况，抛出错误。如果是、、会调用函数取得字符串值’’、’’、’’，再按照情形进行运算
算数运算符、、、和在计算之前都会尝试将其参数转换为数字，简单总结如下：
如果两个操作数都是数值，执行常规运算
如果有一个数是，则结果是
如果有一个操作数字符串、布尔值、或，则先调用方法将其转换为数值，再进行运算
如果有一个操作数是对象，如果  存在，且返回原始类型数据，返回  的结果。如果  存在，且返回原始类型数据，返回  的结果。其他情况，抛出错误。再按照上面规则进行运算。
因此，和方法应该被同时重写，并返回相同的数字字符串或数值表示，才不至于强制隐式转换时得到意想不到的结果。　　逻辑运算符||、可以接受任何值作为参数，会将参数隐式的强制转换成布尔值。中有个假值：、、“”、、和，其他所有的值都为真值。因此在函数中判断参数是否是不能简单的使用，而应该使用：
 {
       === {    或者 === 
           
    }
}
三、避免对混合类型使用==运算符
 == { { }}   
相等操作符==在比较两个参数时会参照规则进行隐式转换，判断两个值是否相等，使用全等操作符===是最安全的。简单总结一下==的隐式转换规则

四、尽量少用全局对象，始终声明局部变量
定义全局变量会污染共享的公共命名空间，可能导致意外的命名冲突，不利于模块化，导致程序中独立组件间的不必要耦合。全局变量在浏览器中会被绑定到全局的对象，添加或修改全局变量会自动更新全局对象，更新全局对象也会自动更新全局全局命名空间。
  
  =  
   
 = 
  
会把没有使用声明的变量简单地当做全局变量，如果忘记声明局部变量，改变量会被隐式地转变成全局变量。任何时候都应该使用声明局部变量。
   {
      =     使用声明局部变量，否则会变成全局变量
     = 
     = 
}
五、理解变量提升
不支持块级作用域，变量定义的作用域并不是离其最近的封闭语句或代码块，而是包含它们的函数。来看一个例子。
  {
      =     {
          = 
    }
     
}
  
在循环中声明了一个局部变量，由于不支持块级作用域，重新声明了函数参数，导致最后的结果并不是我们传进去的值。
理解变量声明需要把声明变量看作由声明和赋值两部分组成。隐式地提升声明部分到封闭函数的顶部，而将赋值留在原地。也就是变量的作用域是整个函数，在=语句出现的位置进行赋值。下面第一种方式会被隐式地提升声明部分，等价于第二种方式那样。建议手动提升局部变量的声明，避免混淆。
  {                                {
                                  
                                           
    {                                           {
                                               
          =                               = 
                                               
    }                                           }
}                                            }
没有块级作用域的一个例外是异常处理，语句将捕获的异常绑定到一个变量该变量的作用域只是语句块。下面的例子中语句块中的值的改变并没有影响最初声明的的值，说明该变量的作用域只是语句块。
 {
      =   = 
    
    {
         
    } {
         = 
    }
    
     
}
   
六、熟练掌握高阶函数
　　高阶函数是那些将函数作为参数或返回值的函数，是一种更为抽象的函数。函数作为参数其实就是回调函数在中被大量使用：
{
      {
         
    }
      {
         
    }
     
}   

  =   
{
     
}     
学会使用高阶函数通常可以简化代码并消除繁琐的样板代码，如果出现重复或者相似的代码我们可以考虑使用高阶函数。
  =    
  = 
  =     {
     =   
}
  

  = 
  =     {
     = 
}
  

  = 
  =     {
     =     
}
  
这三段代码有相同的基本逻辑，按照特定的规则拼接字符串。我们使用高阶函数来重写这段代码
  {
      = 
      =     {
         = 
    }
     
}

  =    
  =  {
       
}
  =  {
     
}
  =  {
         
}
相比之下，高阶函数更简捷，逻辑更清晰，掌握高阶函数会提高代码质量，这需要多读优秀的源码，多在项目中实践才能熟练的掌握。
七、在类数组对象上复用通用的数组方法
中的标准方法被设计成其他对象可复用的方法，即使这些对象没有继承。
在中很常见的类数组对象是中的。类似这样的操作会查询页面中的节点，并返回作为搜索的结果。我们可以在对象上面使用通用的数组方法，比如、、。
 = 
 {
    
}
类数组对象有两个基本特征：
具有一个整形属性
属性大于该对象的最大索引。索引是一个整数，它的字符串表示的是该对象中的一个
可以用一个对象字面量来创建类数组对象：
  = {       }
  =  {
     
}
    
字符串也可以使用通用的数组方法
  =  {
     
}   
只有一个方法不是通用的，即数组连接方法。这个方法会检查参数的属性。如果参数是一个真实的数组，则会将该数组的内容连接起来作为结果；否则，参数将以一个单一的元素来连接
  {
     
}
     
可以使用方法来达到我们的目的
  {
     
}
       
在类数组对象上复用通用的数组方法可以极大的减少冗余代码，提高代码质量前言
前段时间  发布了  版本，提供了自动记录依赖树，下载使用强校验，重写缓存系统等功能升级和改造，吸引了不少关注。本文将对  的新功能和变化点在进行实践使用后进行介绍和总结，并和  进行简单对比。
更新一览
通过官方的   我们可以看到  的主要新功能和大改动主要有下面几点后面将会详细介绍：

默认新增  来记录依赖树信息，进行依赖锁定，并使用新的  格式。

 变成了默认参数，执行  依赖包时默认都会带上，除非加上 。

 依赖优化：支持指定  版本安装；含有  脚本时将安装其  并执行脚本。

使用本地目录文件作为  类型依赖安装时，使用创建  的方式替代原来的文件拷贝方式，提升速度。

脚本更改：在     时新增  和  脚本； 脚本运行优先级提升到最前，并且可以修改 _。

包发布将同时生成  和  校验码，下载依赖时将使用强校验算法。

重写整个缓存系统和   系列命令。废除   等命令，缓存系统将由  自身维护，无需用户介入。

 策略调整：配置优先级高于锁文件中记录的优先级；除非使用不同  的包，不再支持不同的包使用不同的 。


除此之外还包含一些细节优化：

离线安装时将不再尝试连接网络，而是降级尝试从缓存中读取，或直接失败。

锁文件 将包含 。

本地包 具有   或  后缀时才会被安装。

新增  为默认 。

 在  提供对  的支持。

移除 ，使用  代替。


下面就来对主要的修改点做详细介绍和对比：
特性一：锁文件

本次  新增了  文件，在操作依赖时默认生成，用于记录和锁定依赖树的信息。使用过  的同学应该能感觉到，这次  的很多改动都有参考 ，这里估计也是在  的  大受欢迎的背景下做出了这个修改其实之前的  版本并不是没有 ，后面会提到。
在首次执行   后，会默认创建  文件。

之后再次  将根据此文件中的记录进行安装。

如果对依赖进行了修改新增依赖、  或   指定不同版本的包，都将更新记录到此文件中。


 新增的  文件和之前通过   命令生成的  文件的格式完全相同，文件内记录了版本，来源，树结构等所有依赖的 。需要注意的是   并不是一个新功能特性，而是从  就开始有的功能。也就是说在  之前的版本也是可以通过  锁定依赖的。在这一点上，其实  也是早期在使用   等功能时无法满足需求才导致了现在  的出现。可以阅读  的这篇文章了解他们开发  的动机。
而最新的  在生成了  之后，再运行   命令，会发现就是把  重命名为  而已。

因此  表面上看只是把  作为了默认创建，为何还要新建一个文件呢？官方对于此也给出了答复和解释：新增  主要是为了使得  可以向下兼容，保证旧版也可使用比如已有  文件的项目，或是回滚旧版的场景。另外  的名称也比  相对更加直观。
具体可以查看  核心开发者在  上的这篇解释。
除此之外， 和  在使用场景上也有以下不同点：

 用于开发人员锁定版本使用，应该提交到版本控制，不应该跟随发布。其只在项目顶级有效，放在依赖包中时此文件无效。

 可以作为库的依赖锁进行发布。当依赖包有此文件时，将按照此文件安装其下游依赖。

当两个文件同时存在时， 有高优先级， 文件将被忽略。

已有  文件时，不会再创建  文件。


具体规范文档可以参考：








过渡升级
关于  文件，还要注意之前的版本是不包括  的，而这次升级  后  将被包括进来。所以如果使用旧版时已有  文件，这次升级后再次  时会把这些缺少的依赖加进去 之后会通过  字段来判断  的版本。因此多人开发时要注意大家同步升级，避免产生新旧混用的情况。

适用场景
综上我们能总结出  和  在项目中的适用场景：

开发时提交和使用  来保证不同环境、人员安装依赖的一致性。

发布包时如果有锁定的需求，可以用   命令把  转为  随包发布。

如果项目中已经在使用 ，可以继续使用但要注意从旧版本升级到  后  时会被更新，其优先级高于 ，并且不会再被重复创建。


和  的差异
手动修改  依赖版本
我们已经知道，生成  后，重复执行   时将会以其记录的版本来安装。这时如果手动修改  中的版本，重新安装也不会生效，只能手动执行   命令指定依赖版本来进行修改。

而这一点  是可以做到的。猜想  在执行前是先对比了一遍  和  中的版本，如果版本范围完全不符的话会重新安装并更新 。

 优先级
在  中，配置的  优先级要高于  内记录的  的优先级。如果设置的  和  中的不同，将使用设置的  安装命中缓存时除外。

这一点也和  不同。 在有  时会完全忽略  中的 。个人感觉  的设定更加合理，否则有频繁切换  需求的用户可能会比较难受。
特性二： 依赖支持优化
新版本对  依赖支持了通过  版本号安装指定的版本。例如我可以通过以下命令安装  上的   版本：
  

这个特性在需要安装大量内部项目例如在没有自建源的内网开发，或需要使用某些依赖的未发布版本时很有用。在这之前可能需要使用指定 _ 的方式来控制版本。
除此之外，这次升级还对  依赖增加了  脚本的支持。声明  脚本时，依赖被安装时将会同时安装它的 ，然后执行脚本。详细可以看开发人员在  上的这个演示。
特性三：文件依赖优化
在之前的版本，如果将本地目录作为依赖来安装，将会把文件目录作为副本拷贝到 _ 中。而在  中，将改为使用创建  的方式来实现使用本地  包除外，而不再执行文件拷贝。这将会提升安装速度：
  
  

使用文件安装依赖这个功能仅有  支持，目前  还不支持截至 。
有关新的  规范描述可以参考官方的 。
具体修改和实现可以参考这个 。
特性四：缓存优化
新版本重写了整个缓存系统，缓存将由  来全局维护不用用户操心，这点也是在向  看齐。升级新版后，用户基本没有手动操作   的场景。   将必须带上  参数才能执行，并且会收到警告：

  也已废除。同时在离线安装等场景将会提高缓存使用的优先级，提升安装速度。
速度对比
这里使用目前最新的  版本，和  版本，分别在使用各自的官方  和   的情况下进行以下几种场景的速度对比：

首次安装

有缓存，有  情况重复安装

有缓存，无  情况重复安装

无缓存，有  情况重复安装

无缓存，无  情况重复安装

删除 _，有缓存，有  情况安装

删除 _，有缓存，无  情况安装

删除 _，无缓存，有  情况安装




 
 
 

用于测试的 

{
   
   
   
   {
     
     
     
     
     
  }
   {
     
     
     
     
     
  }
}
测试机型 
         
网络无

评测结果



场景

 

 




首次安装






有缓存 有 






有缓存 无 






无缓存 有 






无缓存 无 






有缓存 有  删掉 _






有缓存 无  删掉 _






无缓存 有  删掉 _







通过对比可以看出， 的速度在大部分正常场景下还是略高一筹，不过相比之下  的差距已经很小。
单从数据来看最佳的搭配组合竟然为  和官方 ，甚至更换   之后速度反而有所下降，目前还不知道  是否在自己的源上也有做了特殊优化。
注：单机测试样本不足，也可能有波动或误差，数据仅供参考，感兴趣的读者也可以用自己的项目和网络测一下。
详细测试过程可以查看视频：

　
 　

总结
通过以上一系列对比，我们可以看到  在速度和使用上确实有了很大提升，值得尝试。但从速度上来说  貌似还是更快一点，也没有足够的理由停止使用 。
综上我个人的建议是如果你已经在个人项目上使用 ，并且没有遇到更多问题，目前完全可以继续使用。但如果有兼容  的场景，或者身处在使用 ，， 的团队，以及还没有切到  的项目，那现在就可以试一试  了。另外如果对稳定性要求比较高，鉴于现在才刚发布不久，也可以先了解一下当前的   进行衡量。
以上内容均为原创，如有缪误请指出！热点事件  投资事件
清华副校长施一公放话人工智能：不担心是否取代人类 愿赌服输施一公清华大学副校长，中国科学院院士于今日在京举办的未来科学大奖颁奖典礼暨未来论坛年会获得年未来科学大奖生命科学奖。在未来科学大奖获奖者媒体见面会上，施一公谈了自己对未来科学大奖的看法。在谈到人工智能时，施一公表示他并不担心会不会取代人类，并放话机器人： ，  ，我愿赌服输！新浪科技
上海“无人面馆”被叫停：涉嫌超范围经营 需备案后重新开业上海街头和一些商务楼内近日出现了一种类似于自助贩卖机的“无人面馆”，这种自动提供热食的柜机，能够方便快速的为用户提供一碗热腾腾的面条。对于这种全新业态，上海市徐汇区市场监管局相关负责人表示，无人面馆确认经营者的营业执照和食品经营许可属实，但现场餐饮的制作环节，并不在许可允许的经营范围内，涉嫌超范围经营，现已被要求暂停销售，待补齐相关许可证后有望再度经营。
三星启动活动：台 变身比特币挖矿机三星近期启动了名为“”活动，致力于在老旧智能手机上发掘新的能力。台 配合三星为活动推出了全新操作系统打造的比特币挖矿机。三星是专门研发创新项目的工程团队，近期在旧金山召开的开发者会议上，将这些老旧手机转换成为各种有趣的应用。除了挖矿机之外，团队还将一台平板打造成为笔记本，使用 来监控鱼缸，通过软件将带面部识别的旧手机，以猫头鹰的形象放在房门口。
李飞飞：图像识别使图片变短句 已达认知心理学水平李飞飞斯坦福大学终身教授、谷歌云首席科学家在未来科学大奖颁奖典礼暨未来论坛年会计算机科学人工智能研讨会上称，通过图像识别技术将图像“变”短句，这与认知心理学实验结果“非常接近”。李飞飞认为，视觉是人类发展的重要基石，在过去的几亿年中，不同生物的视觉系统不断发展，至今已成为人类大脑中最复杂的系统。在计算机识别领域，视觉系统同样是重要研究，各国专家在视觉识别方面发明了众多技术，近年时间，视觉识别的错误率已降低了倍。新浪科技
年深圳机器人产业规模预计将突破亿元毕亚雷中科院深圳先进技术研究院院长助理、产业合作与发展处处长、深圳市机器人协会秘书长日在深圳表示，深圳机器人产业尤其是服务机器人产业近年来发展十分迅猛，预计今年深圳机器人产业规模将突破亿元。近年来深圳机器人产业产值平均增长速度超过，去年全市机器人产业产值规模就已经达亿元。未来数年来内，深圳机器人产业发展水平将达到全市战略性新兴产业的整体水平。中新网
汽车的应用场景：威马量产车将实现车外交互功能沈晖威马汽车创始人、董事长兼透露，威马的首款量产车，将搭载车窗智能交互等智能化功能，除了一般性的车内交互，还将首次实现车外交互。这种车外交互的场景大概是：用户接近车时，车会感知识别到车主的身份，在主驾驶车窗显示问候信息、续航里程、行程安排及路线推荐等，并同步开启隐藏式车门把手。此外，这项功能还将通过识别驾驶者身份，为车主、家庭成员、授权用户或访客开启相应权限，并为每一个对应提供个性化的服务。
百度与首汽约车达成合作，拟联合探索自动驾驶专车试运营百度与首汽约车宣布达成战略合作伙伴关系，双方将重点推进自动驾驶、车联网的商业化运行，并进一步探索自动驾驶网约车商业运营模式，共建智慧交通网络。共享出行是自动驾驶率先落地的重要场景之一，平台将向首汽约车输送自动驾驶的技术和能力，打造自动驾驶网约车队，推动自动驾驶技术在网约车业务和景区中的示范运营。在车联网方面，百度将为首汽约车提供开放平台内的智能车联解决方案，助力首汽约车的智能化升级。
北京交管部门将启用机器人查处应急车道停车等违法行为北京高速公路：一种能够在高速公路护栏上“巡逻”，自动拍摄应急车道内违法停车、行车等行为的机器人即将上岗。机器人接近一个旅行箱大小、重约公斤，一名民警可以轻松搬运安装。在高速公路护栏上，机器人可以以公里的时速自动前行、倒行，一次充电可持续行走至小时。这种机器人高度集成智能引导移动模块和具有自动抓拍功能的摄像头、度监控云台，可实现对应急车道内停车、行车等违法行为自动抓拍并通过无线链路自动上传。新华网
新型停机坪，让你的无人机用上无线充电 公司专注于无人机和机器人无线充电的美国公司推出了一块超大型充电板 。用户在无人机上安装上对应的无线充电模块， 就能为无人机充电。这款  看起来像是一张普通的四脚桌子，无线充电用到的部件收纳在桌面下方的空间内。此外， 在测试时还有一张超薄圆形面板，能够停泊大疆  那一类较大型的飞行平台。
亚马逊推“智能锁”快递服务，允许快递人员进入家中亚马逊本周宣布，将推出一套智能锁系统，允许快递人员直接将包裹送到客户家中。这套系统名为“ ”，由一把智能锁和摄像头系统组成。用户可远程控制，从而让快递人员直接将包裹送到家中。当然，用户也可以远程为好友或其他服务人员创建一次性密码，让他们临时进入房间。亚马逊表示，该服务将于月日在美国个地区推出。新浪科技

本文来源腾讯  加速器微信公众号导语：“从入门到第一个模型”差点就成了“从入门到放弃”。本文是机器学习在运维场景下的一次尝试，用一个模型实现了业务规律挖掘和异常检测。这只是一次尝试，能否上线运转还有待考究。试了几个业务的数据，看似有效，心里却仍然忐忑，担心哪里出错或者有未考虑到的坑，将模型介绍如下，请大侠们多多指教，帮忙指出可能存在的问题，一起交流哈。

背景
业务运维需要对业务基础体验指标负责，过去的分析都是基于大数据，统计各个维度及其组合下关键指标的表现。比如我们可以统计到不同网络制式下打开一个的速度耗时，也可以获取不同命令字的成功率。针对移动类业务，基于经验，我们在分析一个指标时都会考虑这些因素：版本、指标相关的特有维度比如图片下载要考虑、图片类型； 视频点播类要考虑视频类型、播放器类型等、用户信息网络制式、省份、运营商、城市等。这些维度综合作用影响关键指标，那么哪些维度组合一定好，哪些一定不好？耗时类指标的表现往往呈现准正态分布趋势，其长尾永远存在并且无法消除，这种情况要不要关注？ 针对命令字成功率，有些命令字成功率低是常态，要不要告警？过去我们会通过在监控中设置特例来避免告警。有没有一种方法，能自动识别常态与非常态？在机器学习如火如荼的现在，也许可以试一试。
目标：

挖掘业务潜在规律针对耗时这类连续值指标，找出引起长尾的因素

监控业务指标时，找出常态并忽略常态，仅针对突发异常产生告警并给出异常的根因。


之后就是艰苦的屡败屡战，从入门到差点放弃，最终搞出第一个模型的奋战史了。最大的困难是没写过代码，不会，机器学习理论和代码都要同步学习；然后就是在基础薄弱的情况下一开始还太贪心，想要找一个通用的模型，对不同业务、不同指标都可以通用，还可以同时解决两个目标问题，缺少一个循序渐进入门的过程，难免处处碰壁，遇到问题解决问题，重新学习。好在最终结果还是出来了，不过还是要接受教训：有了大目标后先定个小目标，理清思路后由点及面，事情会顺利很多。
接下来直接介绍模型，过程中走的弯路就忽略掉因为太多太弱了，有些理论是在遇到问题后再研究才搞明白。
基本思路：

通过学习自动获取业务规律，对业务表现进行预测算法，预测命中的就是业务规律，没命中的有可能是异常请注意，是有可能，而非绝对；

将的结果分别输入决策树进行可视化展示；用预测命中的部分生成业务潜在规律视图；用未命中的来检测异常，并展示根因。

步骤简介以耗时这个指标为例：
 准备两份不重合的数据，一份用于训练，一份用于预测
例：视频播放类业务的维度如版本，机型，视频来源，视频编码类型等各种已有特征，及耗时数据
 将目标问题转化为分类问题，有可能是常见的二分类，也有可能是多分类，视情况而定
将耗时这种连续性指标转为离散值，目标是产生三个分类：“极好的”，“一般的”，“极差的”，将耗时按分位数拆分，取第份或者前份作为“极好的”样本，中间几份为“一般的”的样本，最后或者份为“极差的“样本 。 这里的“极差的”其实就是正态分布的长尾部分。如下图，第一列是耗时区间未加人工定义阈值，自动获取，第二列是样本量。

 特征处理
 特征数值化
     这里表现为两类问题，但处理方式都一样：
文本转数值
无序数值需要削掉数值的大小关系比如这类，本身是无序的，不应该让算法认为
方法：编码 如性别这个特征有三种取值，和，转换为三个特征====== 条件满足将其置为，否则置为
实现方式种：自己实现；调包；的_方法。
编码后特征数量会剧烈膨胀，有个特征是手机机型，处理后会增加几千维，同时也要根据情况考虑是否需要对特征做过于细化的处理。
 特征降维
是否需要降维，视情况而定，我这里做了降维，因为特征太多了，如果不降维，最终的树会非常庞大，无法突出关键因素。
所谓降维，也就是需要提取出特征中对结果起到关键影响因素的特征，去掉不重要的信息和多余信息，理论不详述了，参考：_
本文用了的_这个特性做降维，将维的数据降至左右
 用算法随机森林的变种，训练一个分类模型三分类
 评价模型的指标选取
 对于分类算法，我们首先想到的准确性 这个指标，但它对于样本不均衡的场景下是失效的。举个例子，我们有个二分类成功和失败场景，成功的占比为。这种样本直接输入训练模型，必定过拟合，模型会直接忽略失败的那类，将所有都预测为成功。此时成功率可达，但模型其实是无效的。那么应该用什么？
对于二分类，可用__，对于多分类，可用_和 
 样本不均衡问题处理
本文用的例子，显然和的数量非常少，的数量是大头。为了不对这种类型产生过拟合，可对和这两类做过抽样处理。
常见的有两类算法：
直接复制少数类样本
过抽样算法细节略
这里两种算法都用过，最终选了，不过本文研究的数据上没有看出明显差别。
少数类的过抽样解决了大类的过拟合问题，同时也带来了小类的过拟合，不过这里的模型正好需要让小类过拟合，我们就是要把表现“极好”和“极坏”的部分找出来，表现平平的在异常检测时加入关注。过拟合这个问题，不用过于恐惧，反而可以利用。举个例子，“患病”和“不患病”这种分类场景，宁可将“患病”的检出率高一些。如下图这个分类报告，对于小类样本和，我们需要利用高的特性，即把它找出来就好；而对于大类样本，我们需要高的特性，用于做异常检测。

 模型参数选取
有现成的方法可用，可以看看不同参数组合下模型的效果。对于树类算法，常用的参数就是深度，特征个数；森林类算法加一个树个数。
 _这个参数需要尤其注意，深度大了，容易过拟合，一般经验值在以内。
 模型训练好后，用测试数据预测，从中提取各个类别预测正确的和不正确的。
例：
预测正确的部分：获取预测为，实际也为的样本标示；
预测错误的部分：获取预测为和，实际为的样本标示根据情况调节
 输入决策树进行可视化展示分别做业务规律挖掘和异常检测
这里算法仅用于展示，将不同类别的数据区分开，必要时仍然要设置参数，如__ __，以突出关键信息。
还可以通过的内置_对象将想要找的路径打出来
以下分别给出例子：
 业务规律挖掘
视频点播场景，取和这两类预测正确的部分，输入，如下图，自动找出了业务潜在规律，并一一用大数据统计的方式验证通过，结论吻合。这个树的数据相对纯净，因为输入给它的数据可以理解为必然符合某种规律。

 异常检测
本文模型还在研究阶段，未用线上真实异常数据，而是手工在测试数据某个维度或者组合上制造异常来验证效果。
针对成功率，可以视容忍程度做二分类或者三分类。
二分类：取一个阈值，如，低于为，异常，否则为正常。缺点是如果某个维度上的成功率长期在以下，如，当它突然下跌时会被当做常态忽略掉，不会告警。
三分类：以上为   为，低于为，这种方式会更灵活。 三种分类也分别对应其重要性。重点关注，普通关注，忽略。
下图是一个二分类的例子手工将平台为和播放端为的置为异常：

最后：这里只是一次小尝试，如果要平台化上线运转，还要很多因素要考虑，首要就是模型更新问题定时更新？避免选取到异常发生时段？，这个将放在下阶段去尝试。本文作者： 程柳锋

当的性能遇到瓶颈，或者需要增强能力的时候，就需要依赖模块来实现了。
应用场景
日常工作中，我们经常需要将原生的模块做为依赖并在项目中进行使用。下面有个列表，你可能对它们的名字很熟悉

 将文件编译成文件
 扩展的时间精度
 ：进行调试
：性能及内存使用分析

通常，我们开发原生模块包括但不仅限于以下原因：

对性能有比较苛刻要求的应用。尽管得益于，在异步操作很有优势，但遇到数字计算时并不是一个很好的选择。
使用更加底层的，比如操作系统层面的。
在和之间创建一个，进行通信。

什么是原生模块？
 是动态链接的可共享对象，由编写而成。可以在中通过方法进行调用，使用起来像调用普通模块一样。 —— 来自官方文档
这意味着如果处理得当的话，模块调用者使用由编写的原生模块的方式和由编写的模块一样。想要编写 ，你需要了解一些基本知识：


  
 

推荐阅读这些资料。
创建的原生扩展模块
下面我以一个常见的动态规划问题青蛙跳台阶为例子来说明如何创建一个原生的模块。青蛙跳台阶描述为：一只青蛙一次可以跳上一级台阶，也可以跳上级台阶，求该青蛙跳上级台阶的共有多少种跳法？
首先创建一个_原生文件，的意思是  ，扩展名也可以是。  建议使用，那么此处还是以做为扩展名吧。代码如下：
  



            
 
   {
   

   = 
   = 

     =   =     {
     =       
  }
   
}


     
 
    {
    = 

     
      {
      
         
  }

    =   
    =  

  
}

    
   {
  __  
}

__ 
对这段代码的解释：

 是里面引入头文件的方式，具体源码：，链接时会加载这个头文件。头文件里面引入了命名空间，我们可以通过标志来访问的接口。访问所有的类型，都需要使用标志
通过对象来访问传递过来的参数，通过也可以获取调用相关信息。
通过可以获取函数作用域，可以像里面一样进行变量赋值，而不用担心垃圾回收问题，垃圾回收器会自动进行。
可以对函数返回的结果进行设置。
任何原生模块都需要调用_，_是一个宏，它会进行模块注册操作。
 有丰富的内置类型来保存数字或者字符串，但是只能识别里面定义的类型。因此，将的变量赋值给时，需要转换成可以被识别的类型，也即是定义的类型。比如、。

编译原生的模块
一旦源代码编写完成，需要将它编译成二进制的文件，之后才能被 。为了完成编译操作，需要在项目的根目录创建文件，里面定义了的配置。的内容是一个。
 {
   
    {
      _ _
        _ 
    }
  
}
编译环境配置：

 以管理员的身份运行    ，这个会安装所有编译依赖的工具。
 安装 、和
 安装

虽然内置了一个版本，但是该版本没有开放给开发者进行调用。 的时候会调用它来进行编译和安装工作。因此，开发者想要调用必须自己安装一个全局的版本。
    
  
  
运行 命令会生成一个跨平台的文件，环境会生成，环境会在目录里面生成。 
运行 命令会生成可被调动的二进制文件。
中调用原生模块
   = _

  青蛙跳到第个台阶的所有方法
项目源代码：
后续
，即   。它基于 接口，兼容所有版本，目前的最佳实践是基于来扩展原生模块，而不是直接使用 。
，官方推出的用来编写原生扩展模块，是和的替代，目前处于实验阶段。

原文链接：导语：记  上半年公司级技术突破奖金奖团队「 腾讯云高可用云主机性能提升项目 」背后的故事

说起来也算幸运，每次聊起云计算，我们都能以一个行业从业者的自豪挺起胸膛，就像小时候作为少先队员，每次给国旗敬礼都会觉得胸前的红领巾更红一点。
说起来也挺幸福，我们能够在腾讯云实验室拿到最先进的黑科技产品，那种兴奋不亚于一个女人买到了全球限量的包包，实在不理解那些看起来都一样的鞋子和包包有什么好发朋友圈的，明明我手里的这根内存和硬盘的结合体看起来屌倍啊。 
说起来也不知道是不是幸运，每天睁开眼都要瞅一眼今天的科技头条，哪家的云服务又被测评了，然后想一想我们的数据，反思一下我们有没有被后浪拍死在沙滩上。
说起来我们应该是工作后从事的工作和专业契合度最高的工种，产品小妹的案头书都是《计算机网络》《图解协议》……毕业了，大学教材不用卖，带来工位，保证你工作几天就想再回回炉心中升起对算法和数据结构老师的无限思念 。
 这些就是腾讯云基础研发团队的日常。 
在一个成长的行业， 如果你站在一个第三方的视角，你会看到行业里风起云涌的竞争，不断得有厂商被淘汰，也不断得有黑马进来，情节跌宕起伏，大家争当武林霸主；而身处其中的我们，其实只有最朴实的愿望，把可用性做好，把客户服务好，争取在这个领域把性能做到最高。谈不上风雨，也谈不上彩虹，低头做事，而已。
自我翻新，原地踏步就是退步
从年月日，公测上线开始，我们在公有云市场上的赛跑就从来没有停过，竞争对手不给你机会喘息，行业不给你机会休息，客户更不会坐在门口等你长大……我们在市场上售卖的每一款产品，也许就跑在竞品的测试环境里，无时无刻不在对比着，你主机的单线程性能，多线程性能怎么样，你的网络吞吐，虚拟机时延，都是完全公开，容不得半点美化，如果我们提供的主机性能比竞品落后，随时会被揪出来公开吊打，要想反击，只有拿出我们的硬实力，拿出实际的测试数据说话，在这一点上实际的测试数据无法，比得就是硬实力。 
所以我们才要在短短几年时间内，不断推出二代服务器，三代服务器，、等异构服务，尤其是今年月推出的代云服务器， 网络，性能提升，网络性能相比上一代提升倍。在正式推出前，还没有正式环境的情况下，研发同学手工虚拟化压测，一点一点调优，当厂商提供的驱动和版本不匹配时，我们还有大量的回合的工作，既要保证性能比上一代更优，还要保证现网所有功能不受影响，时间有多短，我就不说了，毕竟，这也是我们的竞争力。产品小妹每天盯着性能数据比看天气预报还上心，查现网运营数据，着急了干脆用写脚本自己去数据库搂，让开发哥轮刮眼眶…… 
在这个行业，原地踏步，就是退步，一切都要用数据说话。
专业专业 ，用技术能力为用户护航
现在大家都有一个感受，丢手机比丢钱包还严重。我们的衣食住行几乎都可以靠手机解决，你买东西可以上购物，吃饭前上各种美食推荐网站搜一下，存钱理财可以用互联网银行，而这些我们时时都在用的 有的就是我们自己的客户。也就是说我们面对的客户有可能是比我们还要专业的运维和研发。 
客户对我们要求越来越高，我们要想办法比客户走得更快一点。 
在弹性高可用的底层，是成千上万的物理机，而物理机不可能没有故障，物理机有故障，不能影响客户业务，一旦客户业务中断，带来的有可能是几千万的损失，想想，如果你是游戏玩家，突然服务连接中断，你会不会骂人？ 这个时候就要用到云的弹性能力，热迁移。在客户服务不断的情况下，将客户的主机从有隐患的机器上迁移到健康的机器上，保证用户使用稳定的高性能服务。迁移这两个字，说起来容易，做起来有多难，谁做谁知道。要保证数据一致性，保证迁移速率，要预测母机负载，不能影响客户原有服务性能。近一年来，我们向社区贡献了个核心 来源于社区，同时又回馈社区，我们做到了。
器以载道，匠心为之，他们是一群不善言辞的人
说到团队里的同学，实在不知道该怎么去描述这一群被我“摧残”的兄弟们。 
他们是一群很无趣但也非常有趣的动物。 
恤，短裤，运动鞋，一年天固定造型，冬天可能会穿个长裤。 
头发剪没剪，其实也不大看得出来，毕竟剪了跟没剪也没多大差别，除非哪天烫了个头大变形象来上班，没准是前两天刚整出一个突发受刺激了。
周末不出去浪，坐在万利达调代码，别说看过凌晨点的万利达，他能给你讲出凌晨三点、四点和五点的万利达有什么区别…… 
可是就这么一群无趣的开发哥，也能轻轻松松得跑个半马；午休的时候抱起吉他来一首指南针乐队的歌；甚至在知乎上洋洋洒洒写出连载文章，嬉笑得把周遭调侃一遍，收获迷妹无数；当然还有他们经常自娱自乐的其实不怎么好笑的冷笑话。 
就是这么一群人，二半夜爬起来接告警，处理故障；周末怀里还抱着娃，电话会议说开就开；大半夜做演习，为了几的优化吵个不停；迎面走过来的某个低调眼镜哥，就是活跃在社区里的头号大牛，在社区粉丝无数；不过从他们那，我听过最动听的话还是： 可以提测了……
未来已来，努力在当下
随着大数据，的行业应用，除了在计算、网络底层能力上不断深挖，高性能网络、异构计算服务等为客户打造极致用户体验；同时，我们还会在和中间件服务上探寻更多可能性，为行业和用户提供更多前瞻性服务。 
下一代指日可待，未来已来，努力就在当下。
感谢兄弟团队，继续携手
感谢所有的兄弟团队，陪伴我们无数个凌晨变更，小时在线服务客户，坚守每一个地域的发布，一遍一遍得验证价格配置是否正确……执手相看泪眼，竟无语凝噎。感谢所有的基础研发团队，我们通力合作，才能给客户提供完整的产品需求；感谢来自各个行业的客户，你们的信任，也催促着我们成长，我们会继续努力，让你们愿意来，愿意留下，愿意和我们一同成长。
仅以此文，献给现在还在万利达码代码、写需求的各位，目标尚未达到，同志仍需努力。作者：

已经陪伴了我们很多年，随着我们的网络带宽条件越来越好，的性能问题日益凸显，而标准的推出正是可以解决这个问题。为了直观的看到使用协议所带来的优化效果，本文将介绍如何使用腾讯云以及万象优图来实现一个简单的。
的优势

多路复用

在中，浏览器并发多个请求，必须使用多个链接，而浏览器会对单个域名有的个数限制，因此出现了散列域名等优化策略；
而在中，同域名下多个请求和响应可在单个连接上完成 请求之间并行处理。
考虑到大部分网站中图片请求是占比比较高的，随着请求数这部分的优化。

头部压缩

中使用专门设计的来对进行压缩处理，这里的性能提升相对较小，本文暂不讨论

 

目前服务端支持较少，本文暂不涉及
一图胜千言

或者直接访问 
注意：需要使用支持的浏览器，建议使用谷歌或者浏览器高速内核
具体浏览器支持可以查询 =
该示例的代码在
 样例的解析
页面组成
在本例子中，为了对比和在多图片加载情况下的性能差异，我们需要准备个页面：

 入口页面，我部署在这个域名了，也可以部署在其他域名，或者本地打开都可以

 测试页面，我部署在这个域名，该页面内嵌了个小图片

 测试页面，我部署在这个域名，该页面内嵌了个小图片


样例架构

测试效果
在我的网速 的条件下测试，全部个图片加载完毕约，而只需要，加载时间大大缩短！
注意：不同的网络，机器环境下，测试数据可能会有差异，因此为了更准确与公平，建议您获取代码后部署到自己的环境上再进行测试
基本原理
和以的形式嵌入到里。俩个测试页面分别使用了组图片分别进行加载，每组包含个图片，每组图片部署在不同的域名，在每组图片完全加载完毕之后统计页面加载总时间。
为了保证公平，当打开的时候，会先加载的内容，等完全加载完毕之后，再开始加载的内容。
注意：由于的资源是通过协议加载的，默认都启用了证书，为了保证公平，内的资源也必须用访问
图片生成
这里有一个难点，就是如何用大图生成个小图？如果我想更换其他图片，或者切分成更细的粒度，改动成本是很高的。
所以我这里用到了万象优图的图片裁剪功能，简单介绍一下，当图片上传到万象优图的内之后，可以直接根据访问的进行图片裁剪！
举个例子，在上面的示例中，我的原图是
使用万象优图的裁剪接口的话，比如我要获取左上角坐标宽高是那块图片，则可以直接访问
聪明的你一看就明白，图片裁剪就是在后面加上
{}{}{}{}
其中是你需要裁剪的图像宽度像素值，表示高度，表示距离左上角原点的横坐标距离，表示距离左上角原点的纵坐标距离
就是这么简单！通过参数，我就可以获得图片的任意一小块，可以大大减少图片切分的工作量！并且可以通过程序生成各种想要的版本
样例构建过程
下面我会介绍一下这个例子完整的搭建的过程，这代表阅读完本文之后，您也可以完全用自己的资源搭建一个的示例网站用于测速比较。对于开发者来说，图片存储，图片切割处理以及证书获取 静态服务器支持等都是比较繁琐的事，而使用腾讯云可以比较方便的解决上述问题。其中

：加速访问，免费申请证书，支持开关

腾讯云对象存储 支持各种文件存储

万象优图：支持图片在线实时裁剪处理


自己构建有什么好处吗？
在上面的示例中我使用了腾讯云的一个大小的图片，分割成共块大小来进行页面展示，您通过自己构建的话，可以很方便的替换图片自定义，自己定分块的大小比如分成的块来测试不同并发数情况下的优化效果。
资源准备

准备个域名，其中一个作为主域名放置页面，另外两个做静态资源域名，静态资源域名需要分配个子域名进行对比。

在前面的示例中，我使用了作为我的主域名存放入口页面，使用以及作为我的静态资源域名存放具体的资源对比页面。
如果您还没有域名，可以到购买 点击购买域名

注册腾讯云，开通  万象优图的功能

申请开通 功能，点击申请

创建 ，这一步比较简单，也可以参考文档 创建 ，创建完成之后，您可以上传任意类型的文件到中，而其中图片类型的文件可以使用万象优图进行处理

创建万象优图 这一步与上一步类似，注意的是创建的时候选择已有 即可，也可以参考文档创建万象优图 

选择一个图片测试文件上传到万象优图的里。建议选择一个正方形的图片，建议不要太小，在前面的示例中，我选择的是一个的图片，大小在左右，可以参考下。 万象优图图片上传

关联。图片上传后，通过万象优图提供的源站域名是可以直接访问的，但源站尚未支持，我们需要接入，在万象优图的域名管理里面，添加我们的静态资源域名注意是个哦，可以参考文档万象优图自定义域名设置

设置证书。在控制台，找到我们的个静态资源域名，配置证书，可以使用自己的证书或者申请免费证书，证书管理

开启设置。在控制台，进入我们域名的高级配置，开启即可。设置


样例代码修改
我下载了样例的代码，我想用其他图片测试的效果，或者我想切分成的分块看看效果，怎么做呢？

本地环境准备，需要您的环境安装以及 之后再安装 这一步骤资料很多，本文不在赘述；

将代码下载到本地，进入代码目录，运行  安装依赖

修改里的配置参数，然后运行 将会自动生成和，这个时候可以直接浏览器打开看看效果，确认之后，再把目录下的和部署到您的主域名里即可

里的配置参数说明
 __ = 用于的测试图片
 __ = 用于的测试图片
 _ = 测试图片的宽度
 _ = 测试图片的高度
_ = _ = 测试图片分块数，这里填就意味着分割成=个小图



注意：每次修改的参数后，记得重新运行一下这样保证生成的页面是最新的。
关于示例的

为什么我本地调试的时候，有时候看到整个一组图的加载时间只有几十毫秒？答：有可能是因为缓存，在浏览器里可以打开调试面板，切换到标签，勾选 ，这样就能避免缓存带来的影响

为什么一定要申请证书呢？协议实现里并没有强制要求。答：虽然协议里没有要求，但目前主流浏览器都默认实现的协议必须要支持，同时为了测试对比的公平性，在的示例中也开启了。

有时候看到示例页面里的请求耗时特别长比正常加载慢很多？答：观察一下具体的每个请求的情况，目前示例里是计算总的加载时间的，有时候因为某些网络原因导致某个请求超时了，就可能拖慢整体的加载时间

我有自己的文件分割工具，不用优图的实时切割可以吗？答：当然可以，但是需要您把图片分割好之后，上传到指定的域名，然后修改页面里生成标签的对应的代码即可。但是这样就比较难实现动态修改参数生成页面。

我如何确定静态资源是通过来访问的呢？答：在浏览器里，可以打开调试面板，切换到标签，可以看到请求的如果没看到，点击这一列，勾选即可



我自己的网站静态资源都是请求的，怎么样尽快切换到呢？答：把你的静态资源域名接入腾讯云，然后在控制台开启即可。域名接入文档

我自己的网站静态资源都相对稳定了，部署在我自己的域名里，我想用万象优图的图片处理功能可以吗？答：可以参考这里自定义域名接入

我用抓包发现都是请求的？答：因为目前还没支持协议的抓包，会自动降级到


小结
本文主要介绍了对比在性能上的突出优势，通过支持请求与响应的多路复用来达到低延迟的效果，同时实现了一个在线的对比样例，并具体介绍了使用腾讯云以及万象优图搭建这个样例的过程。如果你的网站还没使用，赶快来试一试吧！作者：梁定安，腾讯织云负责人，目前就职于腾讯社交网络运营部，开放运维联盟委员，腾讯云布道师，复旦大学客座讲师。

熟悉运维的兄弟姐妹都知道  是一款抓包分析利器，其灵活的过滤规则和对表达式的支持能够让我们在众多的数据报文中抓取到理想的关键信息。本文在介绍  的基本使用方式的同时，会向大家说明海量业务中进阶应用场景。在开始阅读之前请兄弟姐妹们现在脑海中思考一下这几个问题，看看读完本文后会有些什么收获。
、怎么使用？、海量业务系统中又怎么使用？、除了抓包还能能做什么？
一、基础
是一个对网络数据包进行截获的包分析工具。 可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、端口等的过滤，并支持与、或、非逻辑语句协助过滤有效信息。命令使用规则如下：

过滤方式有很多，可以依据所需设置过滤条件，较常用的三种：
、可以按过滤，例如：       
、可以按过滤，例如：           
、可以按过滤，例如：             
下面来看一下过滤规则的具体使用：我们在服务器上搭建了一个服务用来作为服务端，作为客户端客户端对其发起访问。我们使用前面提到的按 、 以及 的组合条件来执行。
          
 
不同的协议类型有不同的数据包格式显示，以包为例，通常对数据包的显示格式如下：
  ：       ＞ ：表明从源地址到目的地址：包中的标志信息， 是标志， ， ， ， 没有标记：是数据包中的数据的顺序号：是下次期望的顺序号：是接收缓存的窗口大小：表明数据包中是否有紧急指针：选项
我们执行抓包过程中输出的这八行数据其实包含了三次握手和四次挥手的交互过程，我们详细分析下看看：
                
                  
            
              
            
              
              
            
第一至三行为建立链接的三次握手过程，包状态为：、、，第四至五行为传输数据的过程，包状态为、；第六至八行为关闭链接的四次挥手过程延迟发送未禁用，所以这里只看到三个包，包状态为、、。
第一行：客户端向服务器发送了一个序号 给服务端；
第二行：服务端收到后将序号加一返回 ；
第三行：客户端检查返回值正确，向服务端发 ，建立了链接；
第四行和第五行：具体的数据交互，命令可以显示出具体内容；
第六行：客户端发一个序号 说明要断开链接；
第七行：服务端在收到后序号加一返回 ，同意断开链接；
第八行：客户端检查返回值正确，向服务端发，链接断开。
以上的分析是我们使用基本的过滤条件组合获取的，如果想要获取到限制条件更严格的报文数据应该怎么写命令呢？比如在数据交互时状态为 即，如果我们要抓去为的包应该怎么抓取呢？这里先挂一下包头的桢格式详解可参考协议，以便我们进一步的使用的过滤功能，头部固定为字节，每行字节，根据协议规则可以看到各个字节中存放的内容的含义。

图中可以看到控制标志位在第字节从开始计数 从右往左这些位被依次编号为到 而位在号，在第位，因此我们想抓取状态为的包表达式应写为=。
执行命令             =，此时我们加上参数可以以进制和码形式打印出包数据，便于观察。抓取到的数据如下图，可以看到我们很方便的抓到了特定状态的包。
 
如果我们要抓取业务中的请求包，怎么做呢？首先查码表得空的十六进制是，因此表达式应为=。
执行命令             =，此时我们加上参数以码方式显示数据包。抓取到的输出如下如，可以看到请求的具体信息了。以此推论，我们还可以把用来统计、请求的访问次数等。

二、自动抓包工具的实现
第一部分中讲解了的一些基本用法和过滤方式，但都还停留在命令行层面。那么在海量运维系统中如何让发挥其作用呢？一个命令又是怎么来构建访问关系的分析平台呢？构建平台后又是怎么利用分析结果的呢？这里要先说明一下我们业务中所使用的一款自动抓包工具的实现原理。抓包工具由两部分脚本组成，调度脚本和工作脚本。调度脚本通过权衡服务器的负载状况来控制工作脚本的执行计划；工作脚本实现命令的基础封装。核心实现是根据服务器监听的和端口，对抓取的报文进行分析后，将分析结果上报到网管，其工作原理如下流程图：
 
、定时执行调度脚本
业务的访问是随机并持续的，我们采用抽样抓包的方式来获取访问关系数据。所以设定为每三十分钟执行一次调度脚本，将脚本的执行写入到中：    
、负载判决
短持续的抓包指令会带来一定的负载消耗，所以抓包的执行需要避开服务器高负载状态。因此调度脚本需要进行负载判决，每次执行前判断负载是否在可执行抓包的阈值内。此时我们计算负载，代码如下图。
 
基本原理是采样两个足够短的时间间隔的快照来计算这段时间内的平均使用率作为服务器当前的负载：
   |  得到的信息 = =  秒 再次  |  得到的信息 = =  得到在秒内的平均使用率：_  _  _  _  
得到的使用率后就可以进行判决了，可以假定阈值为，在负载阈值内即可启动抓包脚本，否则终止。示例代码如下。
 
、读取服务器的网络接口和地址
此处用来获取网卡和对应的地址，一般抓取内网即可。
 
、获取服务器监听的端口
示例代码如下：需要排除掉绑定为的部分

、执行抓包
此处就到了返璞归真的时候了，运用我们第一部分讲到的过滤基础设定好过滤条件，后面的工作就是按条件组合来获取我们想要的报文数据了。此处设定了空包、端口出入包、入包、出包、所有包的几个条件：

执行抓包后将数据结果按一定的结构组合上报到网管属性。
 
以上就是自动抓包工具的工作原理和实现方式，将此工具嵌入在服务器的初始化部署中，所有服务器在工作的同时可以上报业务的访问关系数据。至此我们就完成了对所有服务器访问报文的上报和收集，后续的进阶应用都是在此基础上发展起来的。
三、基于访问关系的业务架构树
前文提到的自动抓包工具获取分析的报文数据已经上报到了网管系统，对一个业务而言，有了访问关系数据基础，我们就可以将模块间服务器的访问关系绘制图谱，业务架构树也就应运而生。以访问关系作为骨架，业务模块作为肢体，通过图形化模型来展示业务架构，一眼就能获取更多的运营信息数据。从访问关系中就可以看到业务请求的流转方向，对不合理的调用架构比如环状或者往复迂回的调用采取优化，可以降低关键模块的请求压力。
业务架构树的绘制原理可以分为以下步骤：
、维度汇聚为功能模块维度
一个业务由若干功能模块组成，功能模块由若干服务器提供业务支撑。前文提到的抓包数据是按维度上报的，所以首先需要按的数据汇聚出业务模块的访问关系数据，这里按维度取并集即可得到。汇聚之后以模块样式呈现在架构树中。模块的附加信息包含了几种运维管理平台的抽象信息，除了各种跳转接口以外，容量信息以能量条的形式展现绿色为低负载，蓝色为正常负载。注：此处只讲解和相关的部分，其他的功能组成等以后的文章再介绍吧。
 
、确定主被调模块以及访问关系
有了模块的呈现后，平台就可以对模块附加上访问关系的连线。前文提到抓包数据的分析结果是以这种形式“本机 源 目标 包大小 时间戳 源端口 目的端口 包量 协议 方向”上报到网管的。按模块汇聚后，本机等于源时，目标汇聚的模块即为“被调”；针对这次调用本机或源汇聚的模块即为“主调”；主调到被调的方向即为主被调的“访问关系”。下图就是一个连接关系的确立模型：。对调用来说，为主调，为被调，为从到的访问关系；对来说既是关系中的被调又是关系中的主调。所以访问关系连线上来看有入也有出。
 
、选取业务自动绘制
经过、的原子说明后，就可以整体来看一个业务的架构树形态了。在上选择一个业务导入绘制架构树，平台根据抓包关系汇聚出各主调被调的节点和连线，然后通过排列算法将这些节点和连线组合，最终呈现出一份业务架构树模型。如下图所示。
 
总结
以上就是这次想讲到的主要内容，文章内容也基本回答了我对最初几个问题的理解，我们可以使用各种组合过滤条件来使用指令，在定位业务问题时事半功倍；我们也可以通过部署自动抓包工具来搭建业务访问关系的数据平台；我们还可以在数据平台的基础上绘制出直观的业务架构树状图。在平时的工作中还有很多其他运用了的进阶场景，比如服务器隔离回收、告警关联分析等等，篇幅有限，这些内容就以后再讲吧。提示：本文讨论了针对不同老板谈加薪的不同方式，以及作为老板在加薪的时候需要特别注意的几点问题。
摘要

找老板加薪的九种方式。

九种方式的各自风险。

给下属加薪需要注意的几个问题。

遇到牛逼的老板，自己卖力干活，解决问题，及时汇报，坐等加薪就是了。


引言
这是个敏感话题，然而，却也是明摆着的需求，因此，需要用光明正大的方式讲得明明白白，而不是留在灰暗的角落里放任潜规则盛行。
既然老板要求员工卖力干活是正常的，对应的，员工要求老板加薪自然也是正常的，所以，没什么说不得的。
既然要求老板加薪，那么，就一定要找个充足的理由，尤其要找一个老板认可的理由。
然而，不同的老板看中的东西却是不同的，行事的风格也各不相同。
因此，要想找老板加薪，就要对症下药，首先搞清楚自己老板看重什么。否则的话，自己找了一大堆的理由，老板反问一句：“跟我有什么关系？”这样显然达不到给自己加薪的目的。
、诉苦：工作辛苦。
向老板诉苦：“你看我最近一两年，天天加班，没有早于十点半回家的，搞到凌晨两三点睡在公司那是家常便饭，身体一天不如一天，老婆都要跟我离婚了。老板，看在我这么辛苦的份儿上，稍微照顾照顾呗？”
大多数老板确实喜欢吃苦卖力的下属，因此“诉苦”这一招经常还是有效的。
当然了，不能只是在口头上诉苦，得在平时让老板看到自己是多么的辛苦。
比如：每天离开办公室之前，瞅瞅老板在不在。如果老板在，就等老板走了自己再走。最好，在老板离开之前，主动“偶遇”一下，让老板发现你竟然还在公司加班。甚至，可以当面简短汇报一下：“今天出了几个问题，我必须解决完了再回家。”如果老板走的非常早，自己可以在晚上十点钟打电话给他，就说自己正在公司加班，遇到几个棘手的问题需要征询一下老板的意见。
碰到上述的下属，大部分老板的心中都是美美的：“好好干，小伙子，我不会亏待你的！”
、求助：生活艰难。
向老板求助：“北京房价都七八万了，买个平米都得将近万，靠现在的工资，真的是买不起啊。别说房子了，娃娃上个幼儿园都得三五千，加上房租三五千，加上生活费三五千，一万多的税后收入就这么化解于无形之中。老板啊，为了兄弟们能够安心在北京上班，照顾照顾呗。”
碰到这样的理由，大多数老板也不好反驳，而且，这个问题抱怨的人又不是一两个，加薪也是可以想象得见的。
从加薪的个体需求出发，最好能够再添加一些个性化的理由。比如：老婆最近刚刚失业，老爹得了重病需要住院治疗，还望领导多多体恤，多少照顾一下特殊情况。
、表忠：忠心可嘉。
向老板表忠：“老板，我跟着您也这么多年了，别的啥也不图，就图老板您重情重义，对兄弟们多有关照，能够遇到您这样的老板，是我的福气。以后，无论您有什么需要我出力的，兄弟我绝不含糊，鞍前马后，您吩咐就是。您指哪儿咱打哪儿，你走哪儿咱跟到哪儿。”
表忠心这个事情，绝对是功在平时，利在年终。
老板干什么，自己都要支持；老板不喜欢什么，千万不要干什么。
比如：老板喜欢喝酒，自己就是重度脂肪肝也得奉陪；老板讨厌什么人，就使劲说那人坏话；有人跟老板过不去，自己就要挺身而出；
、抱怨：不公平啊。
向老板抱怨：“老板，不公平啊，我这么卖力，收入水平竟然比别人差这么多，别说跟其他公司比了，就是在咱自己公司，我也是垫底的。工作业绩比我好、工作年限比我长的也便罢了。为什么那些刚刚入职啥都没有做出来的毛头小孩子也比我收入高？这对我太不公平了，老板您做事向来是公正公平的，这个事情你可要为我做主啊！”
跟上边的其它方式不同，抱怨这个方式，千万不能频繁多次的搞。偶尔抱怨几次，老板会觉得确实自己做事不公。如果总是抱怨，那只能说明：你是个习惯了抱怨的人。
、要挟：有你好看。
向老板要挟：“老板，外边公司给我的加薪。我觉得这对我是个好机会，毕竟在公司内部我觉得自己已经做得足够好了，却无法获得团队的认可，可能是我的能力与团队要求不太一致，也许，换个地方，我能够有更好的机会施展我的个人能力。”
这个方式通常比较有效，但是，跟“抱怨”一样，这个方式也不适合过于频繁的使用，否则会令老板觉得“无论如何都留不住这个人，还是放他走吧。”
另外，这个方式的运用，要把握好分寸，既要给老板造成压力，也要给自己留下余地，尤其是当自己还没有找好下家的时候。
比较委婉的方式，就是放出风声，利用别人的嘴巴告诉老板。
其实，上述的“自己走人”的要挟，还算是比较直爽的。威力巨大的要挟，可不仅仅是“我自己要走人”这么简单。
比如：你不给我加薪是吧？好，我什么都不干了！不仅我不干，我让我的下属也不干，甚至，我让别人也干不成！
更甚至：你以为只有我一个人离职么？我会带领一大帮人离职！
更黑暗的：你做过的那些事情，如果你不在乎，我还在乎什么？
、讲能力：我这么牛。
向老板讲自己的能力：“老板，你看我的能力这么牛，不仅仅公司内部同事佩服我，整个行业都认为我牛逼的不得了。如果大家知道能力提升意味着收入的提升，这显然能够激发其他同事提升个人能力的热情。反之，如果能力强的人收入不高，大家也都没有动力提升自己了。所以，老板，就从给我加薪开始吧！”
这个事情，显然通过别人的嘴说出来更有说服力。自己去说，难免有些自卖自夸的嫌疑。
、讲功劳：业绩突出。
向老板讲自己的功劳：“老板，你看我最近一两年的业绩，蒸蒸日上，不但替公司替团队做了这么多的贡献，而且保证了整个团队的竞争力。能够做出这样的业绩，一靠大家的共同努力，二靠老板您决策英明，而且对我个人也多有栽培。我相信在您的带领之下，未来我们公司我们团队必定会有更加光明的前途，跟着您我个人也能有更大的发展。”
这个事情，平时不妨多讲讲，免得老板记不住甚至看不见。
、等着：老板总会想起我的。
上边讲了七种策略，都是主动出击的，唯有这第八种策略，是被动等待的。
如果老板足够牛逼、足够英明，该给谁加薪的时候自然会加薪的。如果一直不给加薪，自己要反思一下：为什么老板不给我加薪，是我哪里做的不够好？老板想让我做出什么业绩来？
、策略上，先人后己。
什么意思？就是说：自己想加薪的，不要提“给自己加薪”，而是提“给别人加薪”。老板又不是傻子，这点花花肠子还是懂得的。
比如说：自己下边的兄弟多么的卖力，能力多么的突出，业绩多么的优秀，生活上却多么的艰难，收入上多么的需要增加。尽管你没提给自己加薪，老板也明白：给别人都加了，不给你加也不合适啊。
风险提示
上边讲过，不同的老板做事风格是不同的，因此，以上几种方式，分别针对不同的老板。如果针对不同的老板用错了方式，不但达不到目的，反倒会适得其反。尤其是一些非常牛逼的老板，“该给谁加薪我自己非常清楚，作为下属把你们自己该干的活儿干的漂漂亮亮的就行了，我不会亏待你们的。别整天正事不干，净琢磨些对业绩没用的，甚至搞得整个团队乌烟瘴气！”
、诉苦。
是啊，你是很苦逼，天天加班。可是，为什么别人不需要加班就能搞定的事情，你需要天天加班才能搞定？
是啊，今天又出了问题，必须要加班解决。可是，为什么总是天天出问题？难道就不能找到一个彻底解决的方案么？
总之，你加班，是否是因为你能力有问题呢？你苦逼，是否是因为你不够牛逼呢？
、求助。
是啊，北京房子很贵，你孩子需要上学，你老婆失业了，你爹又生病住院了，这跟公司有什么关系呢？是不是你七大姑八大姨的表弟表妹失业了公司都得帮忙安排个工作？是不是你想买个航空母舰公司都得帮你解决？北京房子贵，你以为老板我爽啊？光你们办公位的租金我都付出一大笔了！
生活归生活，工作归工作，想加薪，自己卖力干活，做出业绩，自然会给你加薪，扯这么多没用的干嘛？
、表忠。
是啊，你是对我很忠心，那是因为你没能耐，如果在外边能够找到更好的职位待遇，你早就走了！
再说了，你对我表忠心，是不是你的下属也对你表忠心啊？我说怎么最近业绩不太好呢，你们这帮人在下边拉帮结派，牛逼的人都被你们给挤走了！
没业绩，公司倒闭了，你还会跟着我么？
、抱怨。
是啊，你的待遇比刚入职的新员工都低，有没有想过这是为什么？新员工我让做什么人家两天就给我搞定了，让你干个活儿，磨磨唧唧的推三阻四，两天的事情你给我拖了两周。
有意见是吧？赶紧走，哪儿凉快哪儿呆着去！每天抱怨这个抱怨那个，你就不能想想自己有什么做得不够好的地方么？
、要挟。
 你牛啊，敢要挟我。行，这次我认栽了，下次有你好看！不把你摆平，以为我这个老板是吃干饭的？
你要走？还要带一批人走？好，我马上批准，我倒要看看有几个人会跟着你走的！
、讲能力。
是啊，你确实能力很牛，然而，你这么牛的能力，为什么没有带来这么牛的业绩呢？
哇靠，这个人太牛了，看来是留不住了，赶紧培养接班人吧！以后重要的事情不能交给他做，尤其其他人不能交给他带，万一他走了，公司的业务谁来负责？更甚至，万一他走的时候把我的一帮兄弟全都带走了，那可如何是好？
、讲功劳。
是啊，你确实功劳很大，然而，这些还不是我老板的英明决策？不要跟我抢功好吧？
是啊，你确实功劳很大，大到其他人都没有机会没有信心了！
是啊，你确实功劳很大，这是运气好吧？如果不是行业这么景气，你能有这样的业绩？
是啊，你确实功劳很大，可是，别人也很努力啊，你天天耀武扬威的，这样好么？
、等着。
是啊，老板英明的话，等着当然是有用的；然而，有几个人能够碰到如此英明的老板？
更何况，你确定自己做的事情老板都很清楚么？老板都很重视么？
、先人后己。
你可真会做人啊，不但自己要拿好处，还帮别人争取好处。你这么会做人，会不会有一天取我代之呢？
摸清老板的套路
总之，多个方式，各有风险，一定要提前摸准自己老板的做事风格。
比如：看看都有哪些人获得老板的器重，人家是怎么做的，自己跟着学就对了。
比如：不同方式都小心尝试一下，即提出自己的要求，也不要干的太出格，给自己留个余地。
有些人说了，这么做有点小人之举吧？
没错，就是小人之举。
我很清楚尽管自己写的这么清楚，依然有些人做不出来，这很正常，连我自己都做不出来。
这正是我们的缺点：明知道该怎么做的，偏偏由着性子、碍着面子不去做，损失只好由自己承受喽！
在这一点上，“小人”明显比我们强得多，他们能够压着性子、扔掉面子，去做对自己有利的事情。你以为人家愿意啊？还不都是为了明天的生活更美好！
更何况，老板喜欢什么自己就做什么，这有什么错么？跟老板对着干，到底是谁傻啊？
从好的一面来看，我们中国人对自己品性的坚持，对面子的坚持，是这个民族能够坚持到今天并且继续坚持下去的很重要因素。
当然了，如果自己很明确老板对自己的要求是合理的，只是对自己有点挑战甚至有些艰难，那么，无论如何，都要努力达到老板的要求。能够遇到这样的老板，是你的福气！
给下属加薪需要注意的几个问题
最后，回归到老板的角度，有几个事情需要特别注意。
 、如果有员工主动找自己谈加薪的事情，说明这个员工要么业绩突出没有被奖赏，要么业绩差到自己毫无能力扭转。
对于第一种，业绩突出的员工，如果因为老板自己的疏忽而没能看到该员工的业绩，或者因为偶然忘记了而没有对其进行奖赏，一定要及时补偿，否则的话，寒了兄弟们的心，以后谁还会卖力干活啊！
对于第二种，业绩不够好的员工，一定要跟他讲明白，怎么做才能获得加薪的机会。
对于那些频繁找自己加薪的人，尤其是只谈加薪不谈业绩的人，小心点，这种人会带坏团队的风气。你总不会希望下属成员每个人都不停地找你谈加薪的事情吧？如果谁找过来你就给他加，让那些老老实实默默干活的人情何以堪？
 、给业绩不好的员工加薪，要慎之又慎。
如果这个员工业绩差到无法扭转，停止加薪直接让他走人。
如果这个员工还是有价值的，确实是因为房价、原因需要加薪的，要说清楚，自己希望他往哪个方向更加努力。
、如果一个员工没有特殊贡献，反倒获得大幅加薪，你以为他会感激么？
非常明确地：这个员工不仅仅不会感激，反倒会想：我没有做出什么特别的业绩，这个时候给我这么高的加薪幅度，看来是我之前的工资已经低到老板都看不下去的程度了！——这是笔者饱含悔恨之心的肺腑之言。
 、自己想让下属团队形成什么样的风气，自己就奖励那样的行为，所谓“上行下效”，这个词是中性的，双刃的。
如果老板想让大家天天加班，就给天天加班的人加薪；
如果老板想让大家天天抱怨，就给天天抱怨的人加薪；
如果老板想让大家天天要挟，就给天天要挟的人加薪；
如果老板想让大家天天向上，就给天天向上的人加薪；
 、时刻了解至少定期了解下属的业绩状况，对业绩好的要及时激励如果因条件所限暂时激励不了的也要让大家心里有数，对业绩不好的要及时摸清原因并适当干预摸清原因当然是比较高的要求，适当干预绝对是底线的要求。
作为老板，其中一个最重要的职责，就是时刻关注团队问题，想尽办法保持团队激情，进而保证团队业绩的稳步提升。一个非常有效的手段，就是奖罚，其中包括是否加薪以及加薪幅度。如果老板没有主动利用加薪这个手段来优化、激发团队，而是被动的等待员工自己找上门来，这个老板，失职！
遇到失职的老板，自己不但要卖力干活，还要主动找老板谈加薪的事情。
遇到牛逼的老板，自己卖力干活，解决问题，及时汇报，坐等加薪就是了。
以上内容来自作者本人公众号【水滴的声音】关注企业文化、团队管理。对团队管理有研究兴趣的同事我们可以多交流。导语
本文整理自李力在“第六届   大会”的分享，已获作者授权。

作者介绍
李力：腾讯云的布道师、技术负责人
腾讯云调度管理系统研发负责人，腾讯云布道师，主要负责腾讯公有云私有云后台框架的设计、实现及运营，在虚拟化、、 上有多年的实践经验。

 月  日，第六届   大会在深圳召开。这是这次大会的第二站活动，第一站已在上海成功举办。据官方介绍，  过去  年已经在北京、上海、广州、珠海、杭州等地举办过十几次大会，影响达数万  开发者。

腾讯是一家大量使用  的公司，讲者当初也是作为  程序员进入该公司的。 年，开始接触了 ，很快就将其认定为一门可以”带你装逼带你飞“的语言。出于对  在云计算方面的信心，李力从  年开始在腾讯云推广使用 。






推广初期碰到了一定的阻力，这点对于任何想在公司推广新技术的人来说都是无法避免的。针对领导们的担忧，李力强调了在公有云中使用  的诸多优势：
与  系统天然贴合，系统编程  与  保持一致，以前的工具箱仍然适用。
是能够运行的伪代码，开发效率得到极大提升。
容易与 交互，使用  可以很方便地调用  代码。
更容易保持项目的整洁。
基于这些考虑，腾讯云开始慢慢尝试引入 。首先就是改造接入层，使用      改造了旧的  接口，使得开发工作更加简单，接口更加现代化。


另外，腾讯云还将  用于系统编程，开发了公有云上的宿主机包管理工具。据说这个工具上线几年来运行都没有出什么问题。一般开发者很少有将  用于系统编程的，腾讯云之所以选择 ，是由于其标准库与  规范天然贴合，具备优秀的文本处理和分析能力，而且还有完备的网络功能等原因。

接下来，他还介绍了云调度系统的框架，并分享了在大规模系统中的应用  技术的一些坑。从这周开始，每周一的文章推送将连载   开发的文章，大家有关心的题目也可以直接反馈给我，这样也可以帮助我提高后续文章的针对性。
 千里之行，始于  
话说我们入坑  之后，要怎样才能把它运用到  开发当中呢？我们作为有经验的开发人员，大家都知道  现在基本上都用  构建， 构建过程中只要加入  代码编译的相关配置，那么  的代码运用到  的问题就解决了。
这个问题有何难呢？ 团队早就帮我们把这个问题解决了，只要大家在  配置中加入：
  
就可以了，这与我们在普通  虚拟机的程序的插件不太一样，其他的都差不多，比如我们需要在  当中添加的  与普通 虚拟机程序毫无二致：
 {
    _ = 版本号根据实际情况选择
     {
        
    }
     {
         
         _
    }
}
当然，我们还要在应用的  当中添加  标准库：
 _
有了这些，你的  代码就可以跑在  上面了！当然，你的代码写在  或是  下都是可以的。这不重要了，我觉得把  和  代码混着写就可以了，没必要分开，嗯，你最好不要感觉到他们是两个不同的语言，就酱紫。
 

 
 
 

    {

        

        {
        
        _
         =   
         =  
    }
}
我们定义一个  的成员，由于我们只能在  当中初始化这个成员，所以我们只好用  来修饰它。当然，如果你不怕麻烦，你也可以选择  ，然后给这个成员初始化为 。
接着我们就用最基本的写法 、类型强转拿到这个  的引用，然后 。
运行自然是没有问题的。
不过，不过！我如果就写这么点儿就想糊弄过去这一周的文章，番茄鸡蛋砸过来估计够我吃一年的西红柿炒鸡蛋了吧我就知道，我这一年不用愁吃的了！
  已经超神
要说用  写 ， 谁人不知谁人不晓，简直到了超神的地步。好好，咱们不吹牛了，赶紧把它老人家请出来：
        
        
     
稍微提一句  的版本选择：

 ：  =   

 ：  =   

 ：  =   

 ：  = 


当然除了这些之外， 还对 、等等做了支持，大家可以按需添加，详细可以参考   
另外，也建议大家用变量的形式定义  库的版本，比如：
_ = 


 _       
 _       
 _    
好，有了  我们能干什么呢？
 = 
还记得么？变成  了，而且强转也没有了，是不是很有趣？你一定有疑问， 究竟干了啥，一下子省了这么多事儿，我们跳进去看看  的真面目：
         =   
         =   
         =   
首先它是个扩展方法，我们暂时只用到了  的扩展版本，实际上 、 都有这个扩展方法；其次，它是个  方法，并且还用到了  泛型参数，我们本来应该这么写：
 = 
由于泛型参数的类型可以很容易的推导出来，所以我们再使用  的时候不需要显式的注明。
说到这里，其实还是有问题没有说清楚的， 究竟用来做什么？其实我们就算不写  和  泛型，这个方法照样是可以用的：
       =   
 = 
不过呢，这地方用  就省了一次函数调用，并且  也可以消除  的类型检查提示，所以既然可以，为什么不呢？
当然，用  的好处不可能就这么点儿，我们今天先按住不说，谁好奇的话可以先自己去看看我就知道，你们肯定忍不住！！
 不要 
作为第一篇介绍  写  的文章，绝对不能少的就是  插件了。在  当中加配置：
  
之后，我们只需要在  的代码当中直接使用在布局中定义的  为  的这个 ，于是：
 
 

这个包会自动导入
 _

    {

        {
        
        _
        直接使用 ， 实际上是这个 在布局当中的
         =  
    }
}
只要布局添加一个 ，在 、、 中其实都可以直接用  来引用这个 ，超级爽
所以，你们不准备问下这是为什么吗？为什么可以这样做呢？
其实要回答这个问题也不难，首先   要能够从  的层面索引到  这个 ，需要  的  插件的支持别问我啥是  插件，你们用  的第一天肯定都装过；其次，在编译的时候，编译器能够找到  这个变量，那么还需要  的  插件支持我们刚刚好像  了个什么  来着？。知道了这两点，我们就要有的放矢了

“啊！” 那边的  源码一声惨叫。。。

前方高能。。我们讨论的源码主要在  目录下的  和  两个模块当中。
如果让大家自己实现一套机制来完成上面的功能，大家肯定会想，我首先得解析一下  布局文件吧，并把里面的  存起来，这样方便后面的查找。我告诉大家， 也是这么干的！

    {
    

      = _
      =  {
          = 
          =  {
              = ___  
              = 
              =    
        }
    }
    
}
这是遍历  标签的代码，典型的访问者模式对吧。如果拿到这个标签，它有  这个属性，那么小样儿，你别走，老实交代你的  是什么！举个例子，如果这个标签是这样的：

    =
     
那么， 就是  了，既然  不为空，那么调用 ，其实就是把它记录了下来。

       {
      = 

    注意到这里的  表达式就是前面的 
      =  {    
         =   
    }

     {  }

    返回所有带  的 
     
}
接着想既然我们找到了所有的布局带有  的 ，那么我们总得想办法让  它们找到这些  才行对吧，而我们发现其实在引用它们的时候总是要导入一个包，包名叫做：
布局文件名
几个意思？ 编译器为我们创建了一个包？


 
   

注意到，这里的  其实就是我们前面提到的
布局文件名
不对呀，怎么创建了两个包呢？其实第二个多了个  ，我们在  当中 导入的包是第一个，但如果是我们用父  引用子  时，用的是第二个：

 _

  {
     {
          = _ 
         = 
        
    }

    
}
好，我们现在知道了， 居然已经通过解析  帮我们偷偷搞出了这么两个虚拟的包，这样我们在代码当中能够引用到这个包就很容易解释了。
这时候可能还会有人比较疑惑点击了  的  之后如何跳转到  的，这个大家阅读一下  的源码就会很容易的看到答案。
费了这么多篇幅，其实我们只是做好了表面文章。上面的一切其实都是障眼法，别管怎么说，这两个包都是虚拟的，编译的时候该怎么办？
其实编译就简单多了，碰到这样的引用，比如前面的 ，直接生成  的字节码就可以了，我们把  =  的字节码贴出来给大家看：

  
 
   
 __ 
 
  
 
  
这个是怎么做到的？请大家阅读 ，

   
   \  

 __ 
 
    ______ 
     

好，到这里，想必大家才能对  的  代码有一个彻底的理解。
 小结
虽然是 ，但要想搞清楚其中的所有秘密，并没有那么简单，很多时候，阅读  源码几乎成了唯一的途径。
谢谢大家的关注和支持如果有什么问题可以联系我导语
 内存速度快，性能强，但容量小，而且断电会失去数据；而  闪存容量大，成本低，是非易失性的，断电后数据还在， 的   号称结合两种存储芯片优点，性能千倍于闪存而且数据是持久的。此次实测对比一下   和  等存储的性能。
一、性能测试报告与分析
以下测试 ， 使用  压力测试工具对不同类别存储分别打压，数据块大小 ， ，并发线程  个， 基本都打满情况下的测试结果。
、    与  读写速度对比

结果分析：  
  读写峰值速度在  左右，随机读写能到  左右， 读写为 ～； 和  的顺序读写速度在 ～，随机读写性能较低，在 ～ 之间；
  性能是  的 ～ 倍，且随机读写跟顺序读写性能差别不大。
、  在不同读写比例下的读写速度峰值

注：横轴为读写比例
结果分析：   在不同业务模式的读写速度差别不大，读峰值 ，写峰值 ，混合读写速度在 ～。
以上测试为  纯  压力测试，没有内存、、网络等系统相关瓶颈，后续再增加持久存储业务级测试。
二、测试环境
、硬件环境



存储类型
设备型号和容量




 
    ／   


／／
： ， ／：实验室测试设备



、软件环境



测设设备
测试软件及版本




实验室设备
 



  批量续费
 使用控制台批量续费
选中一个或多个需要续费的实例，点击批量续费操作

选择需要续费的时长，确定后进入下一步
确定订单信息后，点击确认支付。

订单支付成功，可继续查看订单，或跳转到管理中心

 批量回档
 通用说明
用户可以对腾讯云平台中的数据库或表进行回档操作。
回档是基于冷备 ，可进行实时数据回档。
云数据库回档工具通过定期镜像和实时流水重建，将云数据库或表回档到指定时间，且可以保证所有数据的时间切片一致。
期间原有数据库或表的访问不受影响，回档操作会产生新的数据库或表。回档完后，用户可以看到原来的数据库或表，以及新建的数据库或表。

注：云数据库不会改动用户的任何数据，因用户个人原因造成的数据损毁可自行回档修复。

 通过控制台批量回档
选中一个或多个需要回档的实例，点击批量回档

为每个实例指定需要回档的库表
指定回档后名称和回档时间，点击执行回档。提交成功后会显示云数据库任务列表，可查看回档进度。

找到回档实例，点击操作中的管理。进入实例页面后，点击操作日志，选择回档日志，可查看历史回档记录和当前回档进度。

 批量  操作
 通用说明
本功能可以在选择的多个实例或数据库上执行  语句，您可以利用此功能批量创建数据库表、更改表结构来完成对多个实例的初始化或者变更，使用此功能需要您保证选择的实例的用户名密码一致。
 生成待执行的  文件
待执行的  文件可以通过下面两种方法生成：注：不建议用户手工构造  文件，因为手工构造的  文件容易有语法、数据等各种错误，从而导致执行操作失败。方法一： 使用云数据库数据控制台导出功能详见：冷备数据提取导出的文件；
方法二：通过  工具  导出的数据文件：
使用  导出的数据文件必须兼容所购买的云数据库  版本的  规范，可登录云数据库通过  获取相应的  版本信息。
  导出数据的方式如下：
   _ _ 其中， 为导出选项，_ 为数据库名称，_ 为表名称。更多  导出数据说明，请参考  官方手册。
 待执行  文件限制
执行  语句的文件总大小不能超过 。 文件只支持在同一地域内进行复用，在新地域使用时请重新上传文件。
 待执行  文件数据文件字符集编码问题

云数据库执行  文件如果没有指定字符集编码，以云数据库设置的字符集编码执行。
如果执行  文件中有指定的字符集编码，则以指定的字符集编码执行。
如果执行  文件的字符集编码与云数据库当前字符集编码不同，会造成乱码。更多字符集编码问题，请参考使用限制 字符集说明。

 使用控制台批量  操作
 选中一个或多个需要  操作的实例，点击批量  操作

 选择需要操作的实例或数据库，点击进入下一步

 选择  文件，若未找到需要的  文件，请点击新增文件上传。

 确认需要操作的实例或数据库以及  文件，确定无误后输入用户名和密码进入下一步

 操作提交后可查看任务信息，若需要查看任务执行进度。任务完成之前可取消任务。导语
企鹅媒体平台媒体名片页反爬虫技术实践，分布式网页爬虫技术、利用人工智能进行人机识别、图像识别码、频率访问控制、利用无头浏览器、 进行网页抓取等相关技术不在本文讨论范围内。
是什么
大家都知道请求是无状态的，为了让请求从“无状态”  “有状态” ，  在  中描述了整个协议的状态机制，既从客户端通常是浏览器到服务器端的流转过程， 的引入使得 服务器在 接收到请求时可以区分用户和状态。


通过上边这张图，我们可以容易的发现，这个过程就好像“上车打票”一样，有普通票不记名和 也月票“记名的票”，有位伟大的程序员曾经说过“如果你的程序逻辑和实际生活中的逻辑反了，就一定是你错了”。
言归正传，为什么反爬虫
互联网有很多业务或者说网页，是不需要用户进行登录的不记名的票，你可以简单的认为这其实是一个“不需要记录状态的业务场景”注意这里是简单认为，但其实并不是无状态的，那这些不需要登录的页面，往往又会包含大量的聚合信息，比如新闻门户网站、视频门户网站、搜索引擎，这些信息是公开的，其实是可以可以被爬虫抓取的，站长甚至还要做搜索引擎优化让搜索引擎或其他网站更多更经常的去收录自己的整站，以便推广，那既然我们要做优化为什么还要 “反爬虫” ？
因为通过程序进行  请求 去获得数据的成本是很低的，这就造成大量抵质量网页爬虫在网络横行，对业务方的服务器造成不必要的流量浪费和资源消耗。
网页爬虫到底有多容易
正常打开的界面内容是这样的

查看网页源代码，看看我们要抓取的目标，这里就不在演示了，然后利用开发者工具提供的 “  ” 
                ===            __         ==      __= __= _== _= _= _= _===    
然后你会发现，与“查看网页源代码” 没有区别，说明我们已经成功获得数据内容。
反爬虫效果是什么样的？
我们通过浏览器直接打开下面这个链接 ，会发现请求到的结果是个

现在我们重复刚刚的 “  ” 的过程，看看是否依然能获得正确结果 ？ 答案是否定的，我们来验证一下
                ===            __         ==         = __= _== _= = =_    
我们会发现得到的是一个网页而不是 ，命中了反爬虫逻辑

到底发生了什么？
前面提到了 “不记名票据” 和 因推广需求网站不需要登录的场景，那针对这样的情况，是否我们就真的不需要对请求进行签名呢 ？ 答案是否定的，不花钱或花很少的钱就可以免费进入公园游玩了，游客可能本身是感受不到“票据”的存在，但其实我们还是需要对用户进行标记，这里发散一下，其实统计网站在追踪／时也是进行了类似的“标记”，下面我们通过一张图来描述下上面请求发生的过程

这里我们有两次签名过程，一次在服务器端进行，一次在客户端进行，因为在这个页面是不需要用户登录，所以在服务器端进行签名，对于爬虫来说是一个几乎没有成本的过程，它可以每次来“园子”里玩的时候，都申请一张新的票，伪装成为一个“新的用户”，为了应对如此低廉的成本，我们增加“客户端进行签名”的流程，有人说“客户端签名是不靠谱的，因为你的代码别人都是可以看到的是可以破解的”，这个地方的客户端签名不是为了数据安全，而是为了增加爬虫进行抓取的成本，因为一般网页爬虫都不具备  之行能力，这样就增加了它抓取的成本。
另外一点，签名虽然是由客户端签发的，但是却是由服务器端进行验证，我们这里是利用    进行了 和过程，且通过将服务器时间对客户端进行下发，完成有效期控制。
起到一定的防攻击的效果
通过上图我们可以看到，关键就是两次票据的签发与验证，一次由浏览器签发，一次由后台签发，但是验证真伪都是在服务端进行，这样做的最终效果就是，要对我们的界面进行抓取或攻击的人，必须按照我们设定的套路运转，就会增加他下载并执行我们的过程，如果有攻击方利用 获的肉机，对我们的域名发起攻击时，由于我们有两次票据验证，而去其中有一个票据的有效期时间很短，基本上不太可能对我们的服务器造成连续伤害了。
如果网页抓取人，通过使用完全模拟浏览器的运行环境的第三方软件、对我们进行抓取，其实效率是很慢的，基本上需要秒完成一次 基本上比一个真实的用户打开网页还要慢很多，对于这种可以当成是真是用户一样对待，数据本来就是开放的
接入这套反爬、防逻辑后，从模调系统查看数据后台服务被击穿的现象已经完成消失，异常流量已被隔离。作者：赵燕
团队：腾讯移动品质中心

从用户反馈说起
“我备份的照片怎么不见了”；
“出现服务器错误”；
“下载的照片无法显示”。
用户反馈，测试过程中经常遇到各种与后台相关的非必现问题，对于一个重后台功能的产品，包括很多业务逻辑和用户的数据都与后台强相关，若只是通过客户端来测试后台功能的话，在遇到上述问题时，分析和重现问题对于测试人员来说非常困难。
除此以外，在日常的测试中，后台相关的测试还面临以下几类问题：
、后台测试的充分性和完整性的保证；
、不与客户端直接交互的功能，无法通过客户端的用例来直接覆盖到所有功能点；
、面对一些偶现问题，无法定位问题，不知从何下手；
、后台的一些服务改动和发布，回归测试非常耗时。
为了解决后台测试面临的问题，于是开启了产品后台测试的探索之路，按照以下思路进行：分析产品的后台架构客户端交互的后台接口测试后台接口测试后台服务性能测试。
分析产品的后台架构
下图是产品后台的部分架构，由分片上传服务，业务处理服务，用户数据服务，照片压缩和照片加密服务组成。

业务处理模块：该服务主要实现业务逻辑功能，包括图片上传、图片下载、创建相册和图片分类，如下图所示。该服务中的接口都是与客户端直接交互的。可以通过模拟客户端的请求来测试业务处理模块中的接口。

用户数据服务：用户文件存储的是用户图片相关的信息，例如图片的，等，用户数据存储的是联系人信息和短信信息。

图片压缩服务：压缩图片成为各种合适尺寸的图片缩略图；
加密服务：加密服务包括加密数据接口和加密密钥接口；
用户数据服务，图片压缩服务和加密服务，这三个服务的接口是不直接与客户端进行交互的，无法通过客户端模拟请求来测试，因此针对这三种服务的接口通过访问接口的方式来进行测试的。
图存平台和等属于外部公共接口，暂时不在测试范围内。
与客户端的后台接口测试
框架接入和问题解决
通过客户端测试后台因为其他产品已有现成的框架，新产品的接入只需要分析现有框架是否适用或是否需要做二次开发。
、分析框架是否适用，产品前后台接口通信协议都是使用的协议，评估并测试后确认可以使用现有的框架来开发用例；
、分析产品的接口，我们产品的接口功能都依赖于登录态，大部分接口都需要校验登录态，因此需要搞定登录态的问题；

参考手快速登录提供的，修改其中的参数为对应产品相册的，并且把该集成到后台测试框架中；
启动测试后，根据输入的帐号密码拿到即通返回的票据，存入到卡中，票据的有效期为个月；
帐号及作为登录接口的的请求参数，解析接口的返回结果拿到登录态；
是作为后台登录态的唯一校验。
、产品接口请求参数中的是需要校验的，需要获取真实照片的。
单独出一个公共类构造中的请求参数字段；
编写获取照片的函数

接口测试用例中的请求参数直接调用赋值。
后台接口应用案例
、需求描述
新功能照片地图的照片标签功能，客户端通过上传本地照片的经纬度信息到后台，后台通过调用腾讯地图的返回城市信息给客户端，客户端显示在照片地图上显示城市信息
、测试分析
苹果系统使用的是高德地图的，而我们的产品后台使用的是腾讯地图的，需要测试城市信息是否显示一致；
选择城市的测试样本，一是参考产品用户照片地点的分布，二是参考蚂蜂窝热门旅游城市，最后综合考虑选择了蚂蜂窝的个热门旅游城市作为测试样本；
通过客户端手工测试，需要人工准备个热门城市的照片，测试结果也需要人工判断，预计耗时需要天；
分析后台接口，请求参数中填写照片经纬度信息，批量构造个热门城市的经纬度信息存入数组中，通过请求接口返回个热门城市的城市信息，预计耗时天；
照片地图照片标签功能，客户端只是上传照片的信息到服务器和显示城市信息结果，无复杂业务逻辑和交互操作，照片标签功能适合用后台接口测试来完成。
、测试效果
一共发现了六类城市信息显示问题，已经通过映射的关系解决部分重点问题，测试效率提升了，特别在后续的回归测试中分钟即可以完成一次测试。

后台接口测试
用户数据服务的接口不与客户端交互，是后台接口，通过直接访问接口来进行测试。
知识准备篇
文件：文件是框架中客户端和服务端的通信协议，是一种类语言的标识符，用于生成具体的服务接口文件，了解的语法规则，关键字，基本类型，复杂类型，名字空间和接口是做接口测试的基础。详细知识可参阅《使用指南和规范》。
：框架提供了一个的基础，使用实现的服务，需要遵从规范：原则上一个目录是一个或者程序，即只能有一个，需要包含其他库时，根据依赖关系倒序在文件底部。
框架使用：做接口测试仅需要了解客户端的使用，客户端对服务端完成收发包操作是通过通信器来实现的，通信器可以使用配置文件初始化通信器，也可以直接使用属性初始化，通信器不需要自己创建，直接采用服务框架中的通信器即可。
单个接口测试
连接服务器 定义初始化服务器变量 _服务器函数。

服务的地址，必须有 的，如果不需要来定位服务，则不需要配置。
：属性上报地址，如果没有配置，则上报的数据直接丢弃。
请求接口，选择转换文件成 语言，在生成的中找到服务的接口操作类 _ 定义变量 

以上是接口      请求服务操作，是接口名，和””是请求参数，是服务器响应结果。编译运行，写好的接口测试代码放到服务器上运行，可以通过跳板机登录，编译通过的可执行文件，发送到服务器上运行。
文件包括编译需要的文件外，还需要有编译依赖的工具类库文件，值得注意的是不同的服务文件可能不一样。
举例：加密服务和用户数据服务的文件所包含的库文件就有区别：

多个接口测试
分析接口之间的关系，其中多个接口间存在依赖关系的即前一个接口的输出结果是后一个接口的输入参数，则可以通过在一个测试类中实现多个接口测试函数来实现。

接口每日监控运行

、是由一个脚本运行所有接口的可执行文件，并把运行结果重定向到文件中；、解析接口测试生成的报告文档，将文档报告数据进行编码；、通过服务器上的邮件系统，将邮件定时发送出去，邮件模版如下图所示。

未来测试计划
本篇文章介绍的是在项目中如何从开始做后台测试，主要侧重的是项目后台架构的分析，测试后台接口功能，能解决后台功能测试的问题。涉及到接口稳定性和高负载情况下服务器处理超时问题是部分偶现问题出现的源头，因此下一步会重点研究后台性能测试。
获取更多测试干货，请搜索微信公众号：腾讯移动品质中心！众所周知，优异的应用性能是良好用户体验的坚实基础，而服务器响应缓慢、卡顿、崩溃的产品，即便设计再精美也无法留住用户的心。
年月日，百度就和用户们开了一个不大不小的玩笑，从当天的点分到点分左右，百度搜索整整宕机了分钟，众多网友戏言那分钟成为了百度最有存在感的分钟，但是从后来百度的公关文章中，可以看到其提到了“错过了大家上亿次的搜索请求”，从这个体量来看，这无论如何都是一次很大的影响了。

无独有偶，今日头条也在今年的月出现了宕机现象，系统超过分钟未响应，头条号的编辑后台也无法进入，这些现象，均给用户带来了很大的困扰，而且用户体量越大，影响的波及面就越广，不仅影响用户口碑，也影响产品收入。

如果把产品的月收入平摊到每一分钟的话，大家可以通过分钟，分钟，乃至小时，小时的停服时间计算具体的损失金额，还要加上因此产生的用户流失以及品牌口碑影响。
某国外知名游戏在上线之初冲击到免费榜第二名的时候，因为没有做好应对大量玩家涌入的准备，服务器卡死、宕机，闪退让玩家失望选择离开，下载排名一度下降到，通过两个月的服务器优化才挽回局面。
这样的例子有很多，随着重度游戏，重度产品越来越多，产品越来越重视服务器性能的优化。本文将结合腾讯团队为腾讯游戏及产品进行服务器压测的经验，分享一些方法和思路。
一、服务器性能核心指标有哪些
关于服务器压测，有很多指标。为了让大家更容易理解，举个生活中的例子：
你中午去“海底捞”吃饭。
我们可以把“海底捞”这个饭店看成一个被测系统。
你去吃饭，就是对这个被测系统发起请求，对这个系统造成了一定的负载。你带去的人越多，那么这个餐馆就越繁忙，可以说餐馆承受的负载就越大。
你开始点菜。这个时候你隔壁桌的人也开始点菜。那么你们两个对这个系统产生了并发的请求。同时，其他桌有的在吃菜，有的在等菜，这些都是并发进行的事务。一个完整的吃饭事务可以定义成包括：点菜，下单，上菜，买单四个步骤。对于一个的系统来说，可以对应于：建立连接，发送请求，接受应答，断开连接。
影响一个餐馆生意好坏的一个重要原因是上菜速度。上菜速度体现在两个方面：
一个顾客请求的处理耗时，从下单到上菜中间等待的时间，我们称之为响应时间。
这个餐馆同时为多名顾客上菜的频率，我们称之为吞吐量。
来多少顾客，这是饭店自己无法控制的，但是饭店的上菜速度、餐位多少都会制约客流量。一定有一个峰值客流量，当来的客人超过了这个峰值，那么这些客人就会等位，或者是上菜速度超慢让客人无法容忍。容量测试就是通过工具模拟足够多的顾客来吃饭的事务，希望找到这样一个客流量对饭店产生一定的负载，这个时候饭店既能接待最多的客户同时也能保证最短的等待时间。更多的，还可以对这个酒楼人员配置和餐位设置等进行调优，以期达到一个最理想的资源利用率和效率。
客流量跟进来的客人多少有关，也跟餐馆的接待能力有关。单方面增加来就餐的顾客，遭到投诉的可能性就越大，上错菜的可能性也越大。
性能指标有很多，不可能全都看，那么有哪些核心的指标呢？
、响应时间
是指所有用户的响应时间由小到大进行排序，第的响应时间，是用来评估系统容量的重要指标之一。
、性能，关注服务器的服务能力。
每秒系统处理事务通过、失败以及停止的数量。通过它可以确定系统在任何给定时刻的时间事务负载。
、支持的最大在线人数。
指同时登录站点的最大人数或者服务器同时接收下载的最大数量。
、服务器自身压测过程总、内存等的变化情况。
利用率是指：执行非系统空闲进程的时间总的执行时间；内存占用率指的是此进程所开销的内存。
、事务成功率
事务成功率=成功处理的事务所有事务，是检测服务器处理事务成功几率的重要指标。
市面上有哪些服务器压测方法
为了能够帮助用户更快捷的获得服务器的核心数据，市场产生了诸多各式各样的压测方法，但也存在各式各样的问题：
、现网数据预估
根据压力测试过程中的部分数据，对未来大量用户访问的情况机型预估。
存在问题：只适合简单的服务器拟合，复杂服务器数据就不太准确。
、真人压测
通过邀请一定数量的真实用户来玩游戏，从而对服务器达到一个测试效果。
存在问题：暴露出的性能问题有限，封测人数通常还是太少，虽然有几百或者几千用户在玩，但是并发并不够，不足以暴露服务端性能问题；另外不适合调优，真人无法完全重复相同行为，服务器就难以进行回归调优。
、接口测试
选择一些具有代表性的功能，通过以小见大的方式，来评估整套服务器性能。
存在问题：无法遍历整个服务器的接口，难以避免一些微小的问题。
、录制回放
通过抓取数据包的方式，来获取游戏时的协议，再把这些捕获的协议重新发送给服务端，通过工具放大协议量级达到性能测试的目的。
存在问题：面对复杂的协议交互，单纯的放大数据包，无法产生足够压力。
、机器人模拟
通过高还原真实玩家的用户行为，模拟高并发场景，从而得到类似很多人同时游戏的测试效果。
这些方法各有优劣，腾讯内部普遍使用“机器人模拟”的方法进行压测，而“机器人模拟”的压测方法需要充足的测试时间和很大的人力投入，为此腾讯制定了一个较为通用的测试流程，用以提升压测效率。
三、腾讯内部服务器性能的测试流程介绍
根据腾讯内部游戏和产品的使用需求，腾讯团队首先针对与协议的页面，梳理了一个通用的压测流程。
、 确定压测场景，比如登录，获取信息列表等
测试人员第一步要做的就是测试方案的确认，主要就是提前模拟实际业务中涉及的场景以及场景中用户的使用行为，通常需要确认这样几点：
 确认用户的登录状态，用户的登录态是否会不断变化
 用户登录后的访问路径之间的上下文关系
 访问路径之间的参数传递关系
、 测试人员编写测试用例
编写测试用例就是将上述模拟场景具体化的过程，包括确认压测的人数，人数递增逻辑，具体需要压的接口，接口之间的参数传递等。
、 启动机器人进行测试，渐进增加机器人数量
在确认了测试方案后，这一步就是执行的过程，根据测试方案中预估的压力人数，渐进的增加压力的人数。
、 记录分析数据及事务处理情况，查看服务器负载的变化以及服务器的当前承载能力。
上一步提到了要渐进增加机器人，那么为什么要渐进增加机器人？因为在服务器并发增加的过程中需要不断监控上文服务器的核心数据，不断挑战服务器处理能力的极限，避免上来就使用一个过高的并发数直接超过了服务器处理能力的极限，从而无法起到性能优化的目的。一般来说，在机器人增加的过程中，的突然跑满以及响应时间瞬间变长，都可能是服务器产生了瓶颈。因此压测人员需要实时监控压测上升过程中的服务器情况变化，从而定位问题所在。
、 调整配置，迭代测试，预估服务器的承载能力以及可能存在的性能瓶颈
在发现基本的测试问题后，测试人员需要通过不断的调试来定位问题，然后重新发起压测，知道实现最终的测试目的。
根据这个测试流程，腾讯内部也总结了一些压测产品所需要具备的特点 
    简单易上手
产品的业务场景是多变的，但是好的压测产品应该让这个场景配置过程变得简单易用，用户在简单输入需要压测的即可进行各个接口的测试，大部分测试配置建议提供一个默认值，用户对功能更加了解之后可以自由配置这些参数。
    进阶功能完善
除了简单易用之外，也要给用户提供一些进阶的功能，在简单输入的基础上，可以支持用户自定义变量，从文件读取变量，甚至从其他的返回值获取变量的值，可以比较真实模拟真实场景，避免请求变量单一。
    提供分布式压力机进行压测
由于单机的局限性，压测产品可以使用分布式压测的框架，根据用户配置的机器人数量动态分配多个压测机，极大提升压力上限。
    详细的测试数据统计
压测大师会记录测试过程中的多项数据，包括在线人数变化、变化、响应时间、收发包流量、服务器内存状态、压力机硬件负载、测试结果统计等，可以快速定位服务器的容量以及瓶颈。
基于这些需求，腾讯团队开发了专注服务器压测的产品“压测大师”，简化了压测配置过程，用户可以在线上部署，线上调试，线上查看报告，帮助用户成为最高效的“压测大师”。
四、测试案例：真实模拟《直播》活动场景
腾讯直播是腾讯目前发展非常迅速的直播应用，在其一场线上活动中，需要对活动的所有接口进行压力测试，提前暴露问题并解决，确保活动的顺利实施。为此，直播团队选择使用“压测大师”，对活动进行了一整套场景测试。
“压测大师”包含“页面测试”，“测试”和“高级模式”三块功能。
“页面测试”适用于、协议，可对，等页面进行压力测试，主要测试页面静态资源的压力数据，帮助提升官网推广大型运营活动时网站的稳定性；     
在“测试”中，用户可以设置用户并发增长形式，不同的上下文参数配置以及服务器监控，实现最多同时个用户场景，实现更多的场景配置；
而“高级模式”适用于及其他协议，包括自定义协议等。支持对游戏，产品协议进行压力测试，用户通过代码配置，可以根据自身需求开启协议压测。
在测试过程中，直播团队首先梳理了测试思路，一方面通过单接口压测，提前暴露核心模块的问题；另一方面通过多接口的场景设置，尽量模拟真实用户行为，使得压测结果更有说服力。
在测试过程中，《直播》利用”压测大师“的测试功能，针对“发消息”“点赞”“拉取公告”“注册”“读取房间信息”“进入房间”等各个独立行为进行单接口压测，通过设置压测起始人数，每阶段增长人数以及最大人数见下图，设计接口的压力情况。

“压测大师”测试中的“人数设置”
另外对于用户不同的访问行为，《直播》对“注册房间信息进房”进行了多场景的压测见下图，通过请求，读取一个用户的“登录态”，通过功能接口随机产生不同行为逻辑的机器人，模拟真实的用户；然后通过请求依次执行具体的业务行为，最后通过测试中的“上下文配置”，选择调用不同的功能接口，从而发现功能之间产生的逻辑问题。

“压测大师”测试中的“上下文设置”
经过几天紧张的测试，直播活动的各个场景数据都得到了大大的提升，其中“用户进入房间”场景的响应时间减少了近一半；“用户发送消息”与“点赞”场景的提升四倍，为活动的稳定开展提供了坚实的保障。

无论是游戏还是产品，腾讯经历过无数次服务器的考验，面对这些考验，腾讯也渐渐总结出了一套通用的应用性能管理解决方案，让用户能够在游戏上线之前基于真实业务场景和用户行为进行压力测试，发现服务器端的性能瓶颈，并进行针对性的性能调优。以上内容也是根据腾讯产品无数次的压测总结下来的一些经验，腾讯团队也希望通过“压测大师“这类产品，不断简化服务器压测的过程，提升压测人员的工作效率。
功能目前免费对外开放中，欢迎大家的体验 
体验地址：经常有人问我可以做什么，简单来说：
 拖拉拽就实现数据可视化，但同时能满足高阶需求
它跟的透视表类似，只需要把维度拖拉拽到面板，不需要代码，甚至还会自动帮你决定用条形图、气泡图还是箱线图。傻瓜式入门的同时，它有很多高阶功能，快速表计算、参数、等功能基本能满足所有数据展示需求，还能跟集成、调用函数和模型。
 好看
这不太好证明，但我印象很深，创始人 、 和 ，他们背景分别是风险投资人、计算机博士和奥斯卡视效专家，研发的渲染技术在《指环王》和《哈利·波特》里都有所运用。大概这就决定了除了擅长数据分析和功能能丰富之外，另一个重要基因是视觉效果。版面、配色、甚至字体，都会考虑数据可视化的需求来设计。
 交互和探索
这是最迷人的地方，它不只是一个二维的图表，通过交互可以查看不同层次和维度。它鼓励读数据的人自主探索，可以从总体看到规模趋势、也可以不断下钻看到细节。类比用户研究，相当于除了定量数据，你还能做定性研究，看到每个具体用户的信息和真实的声音。记住它擅长的事，如果你再拿它来做静态的条形图，那它真的只能是个很贵又很难用的。
下面分享一个案例，是今年我在  可视化比赛的作品。请看链接：___
数据是一些投资机构包括、红杉资本、阿里、腾讯等的投资数据。数据很简单，列行。示例如下：

数据经方处理，回报率不代表真实回报率
把数据串成一个故事
形式有  。相当于单个的图表，把多个拼成一个页面，而就把多页数据串成一个故事。
现场只有分钟完成作品，需要呈现故事性，所以我做了个页的。
感受投资风潮 ——“页面”功能实现时间轴动态
这一页只是引入，让观众感受下十年间投资的变化，展示总体趋势。图中每个圆点是一次投资，圆圈大小表示投资额，颜色深浅为时间先后，文字标注展示投资机构和投资对象的名字，每个圆圈鼠标上移有具体每个项目的信息， 页面“可以选择时间，也可以动态播放。
的年期间，这家机构在各地投资个项目，总金额超过亿元。

 永远记得你的屏幕是个平面，横竖就真的只能展示二维，每增加一个数据维度，就需要在图上增加一种能量化的元素， 比如颜色、圆圈大小。当然对时间数据，还有一个利器是动态图。元素越多、图就越难理解，一定要根据展示意图有所取舍。
 看清投资风向 ——“效果”功能实现两个图表之间的联动
这一页的上图是投资金额在各机构的分布随时间的变化，每个颜色代表一家投资机构。早期是、红杉等专业投资机构为主，年会后腾讯和阿里开始入局，在年前后逐渐成为投资巨头。
下图展示的是投资的行业分布，每个颜色为一个行业、每个小格子为一个投资对象，通过筛选器选择时间。早期投资对象为房产、旅游业，后期投资行业越来越多，涉及各个领域，在年投资行业第一名为金融业，第一名是京东金融、融资亿。

这图最妙的地方是在鼠标指到上图的某个时间、某个投资机构，下面的图会展示该机构在那个时间的投资行业和对象分布。你会看到腾讯年还只投资游戏和广告，年它投资涉及个行业，项目数都数不过来。

 每个读者关注的角度可能不一样，比如我会对腾讯的投资感兴趣，阿里的读者可能关注阿里的，因此允许用户自由探索，可以让不同的人关注到不一样的细节。
评估投资及回报——箱线图散点，展示个体和整体的水平
这个图比较简单，左图放的是整体的投资金额和回报率曲线。平均投资金额在年后暴增，平均回报率则基本稳定在。
右图放的是不同轮次的投资金额和回报率变化，投资金额从种子轮到轮融资金额越来越大，但在每一个阶段都可能得到从到的投资回报率。也可以看到，并购类的回报率整体偏高，战略投资金额很高、但回报率不高。
除了箱线图展示各轮次的整体水平，每个散点都展示了一个具体项目，鼠标上移到具体的点，就能看到超出平均水平的这些点，具体都是什么项目。

 投资金额和回报率跟什么东西有关？有些人会试图强制找到规律，做个回归曲线之类的，但这数据连续变量只有金额和回报率，他两之间并不是正相关关系，再加上极值很多、即使有模型也并不适用。通过桌面研究和整理数据后来发现，金额最重要的变量是投资轮次，而回报率，没有规律就是最大的规律。
 “探索优质项目”——聚类分析产生新变量
这一页比较复杂，首先左上角的图，根据投资金额和回报率，把所有项目通过内置的聚类算法分成类，直观的看到：高投资金额分为高回报和低回报，低投资金额分为低、中低、中高、高回报。
项目分为六类后，右上角图展示的是各家投资机构六类项目的分布，看到高投资项目主要是阿里、腾讯、红杉，而低投资的项目，除了光源资本，各家都有低、中低、中高、高回报项目，只是比例略有不同。
下图则展示的是所有投资项目获得的投资的轮次、以及每一次融资的详情，这时候这个图几乎已经把所有的数据都展示出来了。用功能计算每个项目的投资轮次、按轮次排序。

同样它可以跟上面两个图做联动。比如选择一个高投资、低回报的一次投资，投资对象是美团，可以看到美团在  轮时主要是低中低回报的，轮是低投资高回报，轮则进入高投资阶段，投资他的机构有每轮都参与的红杉，以及腾讯和阿里巴巴。

：的“提示框”，可以把所有相关的明细信息都放进去，鼠标上移的时候，就能马上看到详细的信息。
“”——展示每一个数据点
这一页只是个结尾页，没有很多信息，上面每一个点展示的是一次投资，颜色表示行业、大小表示投资额。

你是不是想投诉我图片都看不清，看不清————说明做的事情不是图片能解决的
请再看一次 链接：___作者：陈诚

如何打造一个移动端性能平台？听起来是否有点高大上，不知道如何下手。不要紧张，我们来手把手教大家打造自己的移动端性能测试平台。
【前端性能平台可以做什么功能篇】
以前我们要测试移动端性能，通常会用到远程连接抓包分析，工具诸如：，。或者是一些在线测试工具： 、   、。这些工具要么测试执行过程复杂，要么测试报告复杂，亦或者也看不出测试结果是好是坏。
所以我们希望移动端性能自动化平台能够：
、针对移动设备：从移动设备浏览器出发，测试前端性能，不是端的，不是端的，不是端的，重要事情说三遍。
、测试流程简单化：一键化测试，输入，输出测试报告，不要远程调试，不要分析数据。
、测试结果可视化：展示测试过程中的请求瀑布流，资源统计，各种时间类硬指标。
、给出测试建议：不要只有测试数据，我希望有建设性的测试意见。
【怎么样的方案才能满足上述的功能点方案篇】
整体思路：用户界面中输入被测的地址，发送给服务器，服务器收到地址后，像移动设备发送测试任务，移动设备执行测试任务，并返回测试数据，服务器解析原始测试数据，生成报表包含可视化的数据和被测结果的建议，返回给用户。就已经满足了上面我们对系统的预期。

流程就是这么简单，但是每一步具体的方案我们还要一一来敲定。
用户交互系统如何实现
这里的交互就是一个系统，无论你是采用 ，还是亦或者等等，我们认为只要是你会搭建的站点都是可以的。
服务器如何给移动设备发送测试任务
移动设备需要接受服务器的任务，所以我们需要有一个可以支持任务的管理和测试数据的采集。这里的移动设备通过数据线连接在服务器上，所以，使用命令就可以轻松操控。
请移动设备如何获取性能数据
在移动设备上如何获取性能数据，这一步是才是整个系统的重点。
这里数据分为种：请求类数据、时间类数据、性能优化建议。
请求类数据

方案一 “远程调试”

远程调试的思路和上调试一个网页本质是一样的。把调试工具对浏览器的调试转移到对移动端设备浏览器调试上。

方案二 “抓包”

 是基于驱动的命令行引擎，简单的说是一个无界面的浏览器。通过执行脚本，可以方便的获取的请求对用的包 是一个用来储存请求响应信息的通用文件格式，基于，监测工具以这种通用的格式导出所收集的数据，这些数据可以被其他支持的分析工具所使用，来分析网站的性能。包括各类资源：包括图片，，等的加载情况，请求和响应时间，请求返回码等协议的信息。这个办法的好处是获取的请求准确，且方便快捷，但是缺点是统计到的请求数据包括请求时间均是在上运行的时间，不能代表移动端真实的请求数据。

方案三“移动端抓包”

通过抓包工具对浏览器打开网页的过程进行抓包，可以真实且事实的获取展示过程中的数据包。恰好在   项目中有提到 开源工具，可以将包转化为文件，所以为了得到包，我们选择抓包工具对打开的全过程进行抓包。
所以，测试移动端性能的最好方案为方案三，监听移动设备请求，生成包，转化为后，解析文件后搜集前端性能数据。
时间类数据

方案一 “与安卓交互，插桩获取时间数据”如何获取网页加载过程中的各类时间白屏时间，首资源时间，加载时间等，首先能想到的是监听对象事件，如，在合适的地方进行插桩，搜集相关的时间数据难度不大。如使用中的：


方案二 “自带回调函数获取”在使用中，我们可以条用丰富的回调函数，在各类事件到达时触发。可是使用中的：

因为中的回调函数不多，能够统计的时间指标有限，所有最终方案为上述两种方案的结合，既有回调，也有插桩统计获得的时间
性能优化建议
优化建议是对整个测试结果的一个反馈，也需要结合上述测试的结果，并对结果做一个中肯的评估，所以，这里也对三类数据分别作了优化的建议：
资源类优化建议：资源数量大、请求数过多、缓存等；

加载过程：各类时间指标；

代码优化：压缩，屏幕适配等、重绘等。

方案一 “ 接入”

 是雅虎基于网站优化规则推出的工具，帮助你分析并优化网站性能。雅虎在个方面给网站提出优化建议，包括尽可能的减少的请求数、使用  压缩、将 样式放在页面的上方、将脚本移动到底部、减少查询等十几条规则，会根据这些规则分析你的网站，并给出评分。在下也有一套，可以帮助开发者得到建议和分数。但这套方案完全是上的性能工具，要适应移动场景，还是有些勉强。

方案二 “抓取数据手工分析”

鉴于在移动端性能分析的短板，这里可以直接增加移动端性能规则，结合已有的雅虎“条军规”，使得测试建议更加丰富和务实。已有的规则如：资源是否压缩，请求数量是否过多等，针对移动设备添加的规则如：是否针对手机屏幕做适配等。
【如何才能实现这一套实现篇】
确定了上述方案，我们才敢说我们能够搭建一套前端自动化性能测试平台。首先来规划整个平台的时序图工作流

如图流程涉及到的技术点为：
如何对页面打开过程抓包
如何解析文件
如何绘制请求瀑布流
如何通过插桩获取时间类指标
如何配置优化建议规则
重点来了，这里我们一一说明，如何做实现这些技术点。
如何对页面打开过程抓包
在上部分提到，我们使用抓取移动设备请求数据。具体流程如下：

移动设备具有权限

下载   

   \ 

    

    获得权限

 

       

   


当然，这只是抓包的过程，实际上，启动抓包和获取文件我们放在了容器的一个线程中进行。


如何解析文件
包是直接获取的网络包结果，可以通过等工具来分析，但是考虑到我们需要的仅仅是请求信息，也希望自动化分析，所以通过直接将包转化为文件能够过滤掉非请求的记录。
开源工具可以方便的将转化为。注意：要求使用环境为
说了这么久的，那么到底长什么样？
数据结构：
一个文件就是一个对象，如下：

这个对象包含了一个数组，数组中每个元素的内容就是一个请求的相应信息。用来排序的话可以加快数据导出的速度。分析工具要确保此数组是按照排序的。一个包含了一次请求的起始时间，请求耗时，缓存等丰富信息，我们所需的数据全部是从中提取的。



更多详细结构可以参考《 规范》
如何绘制请求瀑布流
有了文件，如何才能生成上图这样的瀑布流呢？笔者有幸发现了这个工具，导入文件，自动生成瀑布流，并且点开任意一条请求，可以看到该请求的详细数据。
如何通过插桩获取时间类指标
获取时间类指标如上所述，关键技术是和交互，不同的时间数据，不同的脚本，我们分别来谈。

白屏时间：用户首次看到网页有内容的时间，即第一次渲染流程完成时间。但是在传统的采集方式里，是在的标签结尾里记录时间戳，来计算白屏时间。在这个时刻，浏览器开始解析标签内的内容。而现代浏览器不会等待树和树整个标签解析完成构建完成才开始绘制，而是马上开始显示中间结果。所以经常在低网速的环境中，观察到页面由上至下缓慢显示完，或者先显示文本内容后再重绘成带有格式的页面内容。在中我们通过使用的事件来近似获得白屏时间。



首资源时间：指从网页开始加载到返回第一个资源的时间。这个资源可以是，图片，，。首资源时间可以反映请求到返回整个过程时间，通常首资源大小不会很大，所以首资源时间可以反映当前网络状况。如何获取首资源时间呢？我们可以根据包，提取第一个的完成时间。完成时间的计算公式：

其中：为中的；为当次请求耗时。

时间：指的是树构建完成时间，此时加载完页面，解析完所有标签不包括执行和。在的事件被触发时注入我们的代码，然后通过的事件来获取时间。



时间：指的是事件触发时间，必须等到网页中所有内容全部加载完毕之后才被执行。如果一个网页中有大量的图片的话，则就会出现这种情况：网页文档已经呈现出来，但由于网页数据还没有完全加载完毕，导致事件不能够即时被触发。时间的获取和树加载时间获取方式一致。



所有资源加载时间：指的是打开网页后，所有资源请求响应且下载成功的时间，和时间有什么区别呢？通常会将各种资源标签放到当中，整个解析完成，资源加载完成，触发事件。但是，移动端页面的很多资源并不是在链接指向的中显式的出现如这种标签，而是通过在执行大量逻辑下判断是否加载某个资源，此时出现在事件后还有资源陆续加载的情况，如下一个加载过程正是上述情况。获取全部资源加载时间的方式也很简单，整个页面的开始时间减去最后一个资源完成时间。


如何配置优化建议规则
从借鉴条优化建议规则，经过挑选后和新增，形成了条优化建议：
、时间类
减小时间减小全部资源加载时间
、图片类
减小图片大小小图片太多避免使用
、请求类
减少重定向次数尽量减少请求个数建议缓存资源返回大小为空的请求请求返回错误资源部署的域名过多网页总大小过大静态资源使用
、文件压缩
压缩文件压缩文件使用压缩 属性为空
、移动设备适配
针对不同屏幕的设备优化展示针对移动设备定制展示优化
、页面渲染
避免使用避免使用如何获取这条中大类规则给予的建议呢？从如下方面考虑：
、 时间类：
直接从上述各类时间指标可以判断是否打开时间过长
、 图片类：
在文件中，过滤出图片类型，获取图片大小，大于输出告警，小于的图片太多，则建议合并。
、 请求：
在文件中，每一次请求都有固定的返回码，可以判断请求返回是否为
在请求中读取所有，可以得到域名，是否太域名数太多等信息
、 文件压缩：
和的压缩可以直接查找文件中是否包含大量换行符，是否压缩，可以在中读取字段
、 移动设备适配：
检查是否添加 和数据中是否有来判断是否有对屏幕做适配
、 页面渲染：
通常和会影响到页面的重新绘制，所以尽量减少这类操作，在脚本中查询该关键词可以发现重绘问题
附：现有效果图部分


相关推荐【腾讯】移动自动化测试框架对比为什么做手游安全测试一起用 做一个简单又骚气的粒子引擎万众瞩目的  终于发布了，原定于的大会的发布时间大大提前了个月，    的正式发布是 开源跨平台的一个重大里程碑， 可以激活庞大的几年以来各大公司和社区 平台上的投资，这是个重大的事件，就像是股票的最低谷开始向上爬升的拐点。我们先来汇总下微软官方发布的  相关的博客：
   
   
     
   
    
下载地址：  
分钟入门教程：  
    包括了    ，如果下载了就不需要单独下载了。  有非常多的改进，具体参看 ，开源项目的正确姿势是参与，多读代码库，在使用  之前也要读下还有那些已知的问题没有修复 
  的数量是 的双倍以上，我们原来项目中依赖的都回来了，       都兼容了  ，这是一个飞跃，不要犹豫了，加入到 的行列，可以直接应用于你的产品中，微软的技术支持请看 。
    也正式发布了，  版本提供了对 的支持，对语言服务的改进，以及对自身的几处改动。通过几个重要的问题修复，提高了稳定性和性能。 下面几个编辑器都支持 要注意的是这次   和   是独立分开的，不要忘记了安装   
         —  日前，分布式关系型数据库公司  宣布与腾讯云正式达成合作，联手打造全新云数据库服务——  数据库 。目前  数据库  已正式上线开放内测。

中国云计算是一个千亿级市场，其中公有云部分以近  的年增速备受瞩目。 此次与腾讯云的合作，进一步丰富了公有云产品的多样性，解决了数据库领域长久以来困扰行业用户的瓶颈问题，提供真正的  云数据库服务，双方将共同探索新型数据库云上应用的更多可能性。
腾讯云专注于提供全球领先的专业云计算服务，其基于 、微信、腾讯游戏等海量业务的技术锤炼，从基础架构到精细化运营，从平台实力到生态能力建设，腾讯云将之整合并面向市场，使之能够为企业和创业者提供集云计算、云数据、云运营于一体的云端服务体验。
 是国内首家开源的新型分布式数据库公司，致力于基础架构领域的前沿技术创新实现。其独立研发的分布式数据库产品  是一款定位于在线事务处理在线分析处理     的融合型数据库产品。现已被数十家不同行业的领先企业应用在实际生产环境，涉及互联网、游戏、金融、政府、电信、制造业等多个领域。多行业场景的技术适配能力，为如今的产品上云打下了扎实的基础。
此次双方合作推出的  数据库  是一款同时支持联机事务处理和联机分析处理两种业务类型的分布式数据库产品，支持强一致性的分布式事务，在线弹性扩容，异地多活及自动故障恢复，同时兼容  协议，使迁移使用成本降到极低，旨在帮助更多企业应对大数据时代下的多元化场景需求：
单机瓶颈
互联网和大数据时代，当单机数据库容量和处理能力遇到瓶颈，不能通过硬件设备的升级或者升级成本过高时，业内普遍采用分片中间件的过渡方案，改进仍局限于单机数据库基于磁盘存储的架构，同时也增加了应用程序设计工作量和运维的成本。  数据库  的在线弹性扩容则可以很好的应对这一情况。
实时分析
传统分析业务需要将数据加载到后台分析数据库系统来运行。通过无限水平扩展可大幅提升数据库吞吐量，加上分布式的聚合和  等对复杂查询的支持，使得  数据库  无需等待  数据迁移的延迟即可胜任实时分析和商业决策的场景。
金融级跨数据中心
传统数据复制备份方案的造价高，多数据中心硬件配置需完全一致，冷备资源利用率低，出现故障人工维护成本高，使用  的用户没有原生的同步解决方案。 数据库  支持分布式事务，通过简单配置即可实现多数据中心的  同步。
数据库即服务
用户往往因为数据类型，存储量和计算能力不足需要投入大量资源扩充、升级、部署和维护复杂的数据库系统。 数据库  是真正的云数据库，提供图形监控和管理，故障自动恢复，弹性扩容，滚动升级等功能，使运维更简便，成本更低。
目前该产品已正式开放内测，企业可通过 腾讯云数据库产品一级入口  第一时间申请内测资格。
对于此次合作， 联合创始人兼  刘奇表示，随着  被越来越多的企业应用于生产环境，愈发发现数据库是企业业务发展突破瓶颈的一个重要环节。此次与腾讯云的合作，通过双方资源优势整合，打造更符合当下市场环境的云数据库服务，帮助更多企业摆脱数据库瓶颈桎梏，共同推动云计算行业发展，进一步优化产业环境。批量计算概念介绍
引题：工作负载分类
工作负载的分类方法和标准多种多样，其中  提出的一种简单的分类标准广受认可，即将工作负载分为服务型和批处理型。

服务型 
长时间运行，理论上不会停止，对服务质量敏感，主要是线上业务
例如  服务， 服务等


批处理型 
运行时间从几秒到几天不等，对短时性能波动相对不敏感，主要是离线业务
例如日志分析等



公有云上的批量计算
最初，公有云的工作负载以服务型负载为主，各大厂商也进行了诸多针对性优化。随着云计算的快速发展，越来越多的、不同行业的用户开始使用公有云，批处理型负载显著增加。针对批处理型负载的需求，我们也通过新的产品形式来满足用户。

专注业务，支持大规模自动化调度与执行，为用户屏蔽资源细节。
调度逻辑，支持  和优先级调度，满足用户复杂的业务处理逻辑。
成本优化，支持资源的动态伸缩，按需分配资源，避免资源浪费，节省成本。

腾讯云  模型

执行单元
，作业，一组关联  的集合
，任务，指明执行逻辑和资源需求
，任务实例，原子执行单元，一个  可并行执行多份


依赖
通过图拓扑表示  依赖， 是  图， 是点，依赖  是边
 是依赖关系的维护单元，不使用  作为依赖关系的维护单元是为了防止依赖关系爆炸



批量计算完整流程
上一小节是腾讯云  自身的逻辑模型。本节我们将视角提升到整个处理流程，涵盖调度、计算、存储等方面。流程示意图如下图所示。

主要步骤
用户上传应用程序和输入文件到对象存储上
用户提交  作业
 创建  实例
 实例中启动  ，从  下载应用程序和输入文件，执行任务实例
  上传输出文件到 
用户监控  作业的结果
用户在  作业完成后，从  下载获得输出文件


腾讯云闭环
整个流程在腾讯云上实现调度、计算、存储闭环
 提供调度分发能力
 提供计算能力
 提供持久化存储能力



竞品调研关键问题
在进行产品规划、系统设计的过程中，我们对公有云批量计算产品进行了较为充分的调研，涵盖     等友商其中    是   产品的一部分，专注数据处理，与其他竞品差别较大，不作为主要对比系。我们从中汲取了大量养分，同时也发现对于一些关键问题和产品规划，不同厂商采用了不同的策略。对此，我们尝试分析背后的产品逻辑和各自优劣，结合目标用户的需求，选择确定了腾讯云批量计算的产品路线。
虚拟机与任务实例的耦合关系


产品策略：作业与  生命周期解耦。一个  可以运行多个作业，作业分配到  需要装箱。
简评：  作业通过容器的方式执行，看起来可以快速启动，但是容器仍然需要运行在  之中， 的规格和启停时机难以把握。在试用过程中，我们发现   容易出现资源浪费和资源“假死锁”问题。客观来说，容器与  层概念增加了产品逻辑复杂度，而   并没有完满的处理好这方面的产品逻辑。
问题 资源浪费
在一个  产品概念，大意为计算环境可使用的  上限为的环境中，用户先提交一个的作业，   会自动创建一个的  实例执行作业。然后用户再提交一个的作业，在作业完成之后，  会复用的  实例执行作业。 的收费策略是根据  实例收费，这样存在一个问题，在执行作业的时候， 用的  执行的作业，造成了资源浪费。实际上，用户提交作业的规格和吞吐量发生变化是较为常见的事情，这样的  比较容易出现。
此外，作业执行完成后， 不会立即销毁，通常会保留数十分钟后才会自动释放，对于不持续提交作业的用户，也会造成明显的资源浪费。


问题 资源“假死锁”
在一个为的环境中，用户先提交一个的作业，  会自动创建一个的  实例来执行作业 。然后提交一个的作业。本来预期   会立即销毁现有的  实例，然后创建一个新的  实例来运行作业。但是，实际情况要略差于预期，在作业提交近一小时之后， 才创建了的  实例，完成计算环境的调整，以至于用户一度认为   出现了死锁 。虽然最终没有造成死锁，但是   的调整延迟过大，影响用户体验。





产品策略：   分为种计算环境类型， 自动集群模式和  固定集群模式。对于  模式，任务实例与  生命周期一致；对于  模式，虽然任务实例与  生命周期不一致，但是目前仍然采用对模式，即  同时只运行一个任务实例。
简评： ，特别是  模式，产品逻辑简单直接。



产品策略： 任务与  生命周期解耦。一个  可以运行多个任务。与   不同，任务分配到  不进行装箱，而是通过参数设置，即一个  可以同时运行  个任务， 可设置。。
简评：与   类似，可能出现浪费资源的问题。不进行装箱，直接为  分配  个任务的策略，对于异构化的任务，存在资源评估不准确的问题。


用户反馈
用户关心业务本身，对耦合关系无明显偏好，希望产品逻辑保持简洁直观，避免资源浪费。


腾讯云做法
 和 任务实例生命周期耦合，一一对应，执行任务实例前夕创建  实例，执行完成后立即销毁  实例。保证按需分配和使用资源，节省成本。
同时，充分利用  快速创建优势，快速响应  业务。



执行单元的层级关系


产品策略：执行单元为 ，是原子执行单元，相当于腾讯云的 。
简评：保证接口原子性。虽然可以通过指定前序  来表示  间的依赖关系，但是需要用户记录和维护前序  的唯一 ，并在提交后序  时指定前序  的唯一 ，相当于用户需要参与维护 关系。同时，  目前无法提供完成的  视图。



产品策略：、、三层单元
简评：可以在  内部实现  关系。  和  是两款产品，但是二者的  和  容易混淆。  中存在  的概念，却并非  ，而是类似  在  内部索引的概念。





产品策略：具有  和  两层单元， 其实是类似队列或者任务集合的静态概念， 是其执行单元。
简评：  中的   类似于   中的 ，二者优缺点相似。


用户反馈
希望  产品可以优雅地处理  关系，同时对用户简单。


腾讯云做法
借鉴工作流系统  的命名方式，采用 、、 三层执行单元。
 与   概念区分。虽然我们目前采用  和   生命周期一致的策略，但是二者本身不同，不要混淆。



 用户是否可见


 创建的虚拟机，在其控制台可见



 创建的虚拟机，在其控制台不可见，不可直接登录。虽然   提供了内网连通的拓展功能，但是产品体验有待提高。



 创建的虚拟机，在其控制台可见


用户反馈
多方用户提到友商  创建虚拟机控制台不可见、无法登录的痛点。当出现问题时较难定位。


腾讯云做法
保证“搭积木式”的产品观
 和用户使用相同的方式使用基础产品例如 ，保证基础产品逻辑一致



系统设计
 状态机
腾讯云  包括 、、 三层执行单元， 系原子执行单元，这里介绍其状态机。、 的状态依赖其所含  的状态，不做展开。


已经接收到  并解析拆分。
如果存在依赖项，则任务实例进入  状态，否则进入  状态。



驻留在队列中，因为等待其他依赖任务，而无法运行
在满足依赖关系后，任务实例将进入  状态。



驻留在队列中且没有任何未完成依赖项，因为没有资源或者资源配额不足而暂时无法运行
当资源足够时，任务实例会被调度运行。



任务实例完成调度开始执行和下发，任务实例尚未启动执行



任务实例在计算环境中运行
当应用程序退出时，进程退出代码将确定任务实例是成功还是失败。退出代码  表示成功，非零退出代码表示失败。



任务实例成功完成，返回码为 



在执行所有可用尝试后，任务实例失败。



系统架构与设计细节
定位为工作流  系统，适用于  场景，命名为 。

 
生成唯一 ，并将  基本信息提交到数据库中
将  完整信息发送至  中
向调用方返回 


依赖关系
 拆分时，根据有无依赖，将  的状态设置为  或者 
 完成后，会变更关联对象的状态，可能包括 、、后续 、后续  的状态。


调度策略
以  为粒度进行集中调度，查询同一 、状态为  的 ，按照优先级排序，逐个遍历
如果  有足够资源配额，则下发执行，将  信息发送至 
如果  无足够资源配额，则


 之间并行调度；同一  串行调度，避免无意义加锁。
 存储使用数据库，不使用优先级队列，避免“队列头阻塞”或者优先级变化。


 内部回滚
 和  相对复杂，需要内部回滚
例如  如果执行失败，进行回滚，销毁已经创建的  实例


 与   交互
支持两种模式，调用内部   和 
默认采用   模式，应用在腾讯公有云场景下
可选通过  模式，与  用户行为完全一致，意味着用户可以在自己的  集群中搭建  系统并直接使用。


与实例的交互
镜像只需安装 ，而无须提前嵌入  ，即可运行批量计算作业
 是业界认可的标准初始化工具，镜像制作标准规范、简易
腾讯云计划近期更新主流公有镜像，使之支持 



设计原则小结

“搭积木”
批量计算保证基础产品的原生能力，不进行封装或阉割。批量计算和用户使用基础产品的方式一致，保证产品表现一致


多调度器并发架构
多调度器并发调度，用户级别并发，类似于   的无锁乐观并发调度架构， 可提升调度系统的吞吐率。用户内部串行，保证按照优先级调度下发，同时避免无意义加锁。
在产品调度策略上，目前批量计算对所有用户采用对等公平策略。如果特定场景比如私有云环境需要采用相对公平策略，不同用户具有不同的权重值，则需要增加一个调度组件和一层调度策略，决定优先为哪个哪些用户进行调度。


轻量 
 逻辑轻量，保持快速响应
复杂逻辑交由异步消费者完成


消费者处理逻辑简洁明确
 状态机相对复杂，但是每类消费者只做一类事，相当于解耦了状态机。
例如， 负责拆分，根据  有无依赖将状态置为  或者 ； 只负责调度下发状态为  的 ，不会考虑依赖关系； 在销毁  实例之后，负责变更  状态和关联对象状态，会将已经无依赖的后续  状态从  变更为 。



核心功能与产品优势

自动托管
自动调度、下发、执行海量作业，为用户屏蔽资源细节，专注业务本身。


 依赖
通过  拓扑形式，描述任务间依赖关系，根据依赖关系保证任务的先后执行顺序。通过简单形式满足用户复杂处理逻辑的业务需求。


优先级调度
对于无依赖任务实例，基于优先级进行先后调度。


计算资源动态伸缩
资源与任务实例生命周期一致，根据业务需求动态扩展和释放计算资源，按需分配资源，避免浪费，节省成本。


天然集成
 与腾讯云基础产品天然集成，涵盖计算、网络、存储、安全安全组等多个方面，用户业务可在腾讯云上轻松闭环。
复用基础产品优势，例如腾讯云  快速创建。


调试  模式
 失败后， 实例不销毁，保留现场
批量计算创建的  实例，在  控制台可见、可登陆，便于用户观察应用运行状态。



批量计算作为一款新产品，可能还存在一些不足，也欢迎大家多多试用  反馈问题。
参考
                                                                         环境已经就绪，我们需要先调通一类简单日志作为数据上报全链路的试运行。恰好系统日志就是这样一个角色，随处可见，风险可控。
这里，我们选择了种系统日志： 和  。
一、部署
按照《【私房菜】安装部署及配置详解》在需要采集系统日志的系统上部署，然后编写如下配置：
 

  

 _ 
   
   
  _ 

_ 
_ 
 

  

        
   
       
   {}
  _ 
  _
    _ 
  _ 
   
  __ 

  
 
_ 
_ 

   
   
   

  
 

           
   
      
   
 这里我们先把  输出打开，然后启动观察输出：
{
   
   {
     
     
     
  }
  _ 
            \  \\
   
   
   
}
 可以看到输出了如上的格式数据，这些数据会原样上报或。
二、配置
在数据上报之前，我们还需要先配置下相应的 。
当然，如果不想配置也可以，在后文的  的  模块中去掉【禁止管理模板的配置】即可，也就是让  自适应导入 。
但是这样有个弊端，因为  是自适应匹配模板，可能有一些字段类型就不是那么准确，导致我们后面在里面就无法对一些字段进行聚合分析了。
根据字段内容，编写如下：
{
     
     {
       {
         {
           {
            __  
              
          }
           {
             _
             
          }
           {
             _
             
          }
           {
             
          }
          _ {
             
          }
          _ {
             
          }
          _ {
             _
             
          }
          _ {
           __  
              
          }
        }
      }
    }
}
 ：这里就不详细说明字段的含义了，请参考系列文章《 简介整理中》
将上述模板保存为  的文件，然后执行如下命令进行导入：

  _  

主机为地址和端口
_ 表示模板方法
 是我们给这个模板定义的名字
 模板文件，表示将这个模板文件导入到

正常将返回如下结果：

{
    
}
三、配置
 
 {
     {
         指定服务和端口老版本是指定服务，这里有所区别
        _ = 
         取出  数据
         = 
         指定多个为相同的 _，协同工作
        _ = 
          取出来的数据需要格式化为
         =  {
             = 
        }
         加一个标签字段，用于后面判断
        _ = {  =  }
    }
}
 {
     根据标签来处理数据
      ==  {
         {
               正则匹配
               = {  = {_} {} {_}\{_}\ {
_} }
               亮点：由于源消息是没有上报的只有主机名这里做了点改造，将传来的赋值给这个字段
              _ =   {} 
               如果成功匹配，则加一个匹配标签
              _ =   
        }
         如果标签不存在则丢弃这条消息
              {
            {}
        }
         {
             对日志里面的时间戳进行格式转换，适配的时间格式
             = _
             = 
             =           
             = 
        }
         {
             =  = 
        }
         {
             移除不需要的字段
            _ =       
            _ =       
            _ =       
            _ = 
            _ = _
            _ = 
            _ = 
            _ = 
            _ = 
        }  
    }
 {
     上报系统日志
      ==  {   
          {  =  }  信息打屏，用于
         {
             = 
             = {}
             禁止管理模板，并指定上文上传的模板
            _ = 
            _ = 
        }
    }
}
因为数据格式的不同，正则表达式也要做相应的适配，这个过程应该是配置最麻烦的地方。当然，这里我们可以用到  的在线测试工具：
同样的，我们在配置完之后，先屏蔽  的上报，然后打开：

 {  =  }
进行调试，直到打屏数据满足我们的需求后再上报至。
四、配置
有了数据之后，首次打开发现啥也看不到，此时我们需要先配置下的，图解如下：
①、如图打开索引管理：

②、如图点击创建索引：

③、如图输入指定的索引前缀，自动带出字段后选择时间戳字段，点击【】即可：

最后，回到界面就能看到期待已久的高清美图了：

本文就介绍这么多，更多的奇淫巧计请关注《私房菜系列文章之教你玩转整理中》。“过去，物流企业从代码到运维到安全到网络的众多领域，要耗费大量人力、财力。云计算则解决了这个问题：减少了物流企业成本，降低建设门槛，为企业发展减轻了负担，同时将物流产业的服务化，产生更多可以利用的数据。”——吴海波

似乎是冥冥中注定，从一开始毕业从事软件开发工作，到后来、等传统物流管理软件的研发，再到物联网技术，吴海波都与物流有着不解的缘分，而他也认为自己是幸运的，可以做自己喜欢的事，并乐此不疲。
的建立，可以说是互联网时代，吴海波一众人为了满足物流企业对物联网技术的迫切需求，在云计算、大数据对物流进行强化改进的一次尝试。

他在接受腾讯云会客厅采访时道出了的业务初衷：对于从事物流行业的人员，特别是货车司机来说，降低成本是第一要素。“如果想降低成本，就要深入地看到物流运输的底层。事实上，实现物流运输的这些人就是货车司机。”基于这样的思考，的技术团队把业务伸向了车的层面，以管车作为业务的切入点。
升级能力支撑物流大数据
“与这类典型互联网公司不同，的数据收集，并非依靠消费者与平台的交互产生。而是通过传感器设备，记录司机每一次踩刹车动作、加油门的行为，来获取物流全运输过程中的每一分每一秒的数据。”吴海波把这种数据收集，称为对车的“感知”，感知车辆每时每刻的运行情况。
他讲到这样一个事例。国家对危险品运输有着严格的规定，从哪个路口转弯，从哪条路通过，有明确标识。有一次，一位司机在通过高速路口的时候，踩了急刹车，动作随即被系统捕捉到，当即记录了踩完刹车后秒的状况。最后通过视频回放了解到，是司机过了高速路口要倒车回来，从另一个路口出去，这是十分危险的。“事情发生之后，这位司机遭受了处罚，加强了安全意识。”吴海波说，物流大数据在实时监控和指引方面起着不可忽视的重要作用。
技术团队通过大数据分析发现，车辆每个月行驶三万公里，百公里油耗控制在升以下，就会有很好的利润额。平台连接了万车辆，传感器一天要采集多条数据，如果按照万台设备来计算，一天就会有亿条数据。这是一个巨大的量级，也是对公司的极大考验。
所以思量之下，吴海波决定应将一部分业务，托管到云计算上。他认为，物流企业需要升级能力，有足够的能力支撑大数据。过去，物流企业的体统架构，需要布局从代码到运维到安全到网络的众多领域，要耗费大量人力、财力。云计算则解决了这个问题：减少了物流企业成本，降低建设门槛，为企业发展减轻了负担，同时将物流产业的服务化，产生更多可以利用的数据。

左：腾讯云副总裁曾佳欣  右： 吴海波
以云计算的方式提供物流服务
如今，全国城市配送物流市场规模已经突破万亿，而参与物流配送的数千万辆货车却有着较为严重的放空状况，针对这种情况，“智能管车”服务脱颖而出。通过将位置信息与业务场景相结合，利用位置数据为监测者建立观察点，车辆抵达节点后会自动触发信息，大幅提升了物流公司的工作效率。
“作为一个智慧物联网公司，我们非常关注云计算，将业务服务以云的方式为企业提供。”与腾讯云的合作，是上云的第一步，也是极为关键的一步。吴海波回忆，“腾讯云上线初期，我们进行了小规模试用，后来发现他们的大数据产品非常适合我们的需求。”
对于来说，如果产品定制度特别高，技术团队能驾驭、改造的空间就相对较少，他们所需要的不是一个高度封装好的产品，而是有灵活度，开放性的服务。经过技术团队的反复考核，最终敲定了腾讯云，双方快速对接起来，一拍即合。
突破点是腾讯云的分布式云数据库。  是一种兼容协议和语法，支持自动水平拆分的高性能分布式数据库——即业务显示为完整的逻辑表，数据却均匀的拆分到多个分片中；每个分片默认采用主备架构，提供灾备、恢复、监控、不停机扩容等全套解决方案，适用于或级的海量数据场景。
这让吴海波松了口气，“物联网接入的设备变多，一旦要做设备更改，产品的研发就受到了影响。但我们发现腾讯云的拿来一用，问题都解决了。我们自己无须关心分表，系统自动就帮我们解决了。”
随着越来越多的设备接入物联网，数据量增长是爆发式的，对原有产品的架构兼容也是不小的挑战，考验着双方的合作默契度。在吴海波眼中，腾讯云就像一个“管家”，提供着×小时服务，“去年、月份的某一天凌晨，我们的技术平台有一部分数据无法写入了，于是立刻与腾讯云取得联系，他们接到电话后马上召集了研发和支持团队的同学，一起协调解决了问题。”
可以说，互联网的高速发展为物流行业带来了巨大的改变，企业在机遇与挑战中权衡、迎合；而云计算、大数据则为互联网物流新平台打开了另一扇大门——云计算伙伴负责数据架构和维护，物流企业则通过数据提供更深层、定制化的服务。

【栏目介绍】：在互联网时代下，云计算正被越来越多的行业和企业认可。《腾讯云会客厅》作为云计算行业首档高端人物访谈栏目，是由腾讯云副总裁曾佳欣亲自主持，在分享云在各领域最佳实践的同时，也邀请到众多创投界资深人士和明星，分享云端创投经验，从资本、技术、渠道、服务等方面，打通整个产业链，构建云端创业生态。导语 经常可能会有的一个需求就是，一个表中会有一些默认数据，这些数据未来是可以通过管理端来配置的。所以数据库在被建立之后，会有一些默认数据被插入表中。工程跑起来后，视图函数还未被调用，所以必须要在其他地方来完成插入数据的要求。

 提供了来完成对应的需求，具体可参考官方文档。其核心是写一个  文件，然后命令行通过  来完成数据表的初始化操作。但是我们并不能在蓝鲸的线上环境中操作命令行也许有，但是我不太了解，线上环境是通过读取迁移文件来完成数据库的迁移操作的，所以可以通过把对应的代码写入 文件来完成数据库的初始操作。具体的操作方法如下：
_
 
     = 
     = _=
     ____
          {}  {} 
我们需要往 表中插入两条数据
   
   
在插入数据之前，需要先产生对应的表结构，在命令行运行
   _这条命令会产生对应的  文件

然后，我们需要我们自己的迁移文件来初始化我们自己的数据。命令行运行
    _这条命令会在刚才的  文件夹下产生一个新的文件，我们的插入数据的方法就是在这里填写

官方文档给出了文件格式。我们需要给出两个可调用对象，_ 用来执行插入数据的操作， _ 用来执行回滚操作。方法的实现如下
____
    
 ____  _

    


 _ _
     = __ 
    _ = _
    __
        = =
        = =
    


 _ _
     = __ 
    _ = _
    _==
    _==


 
     注明依赖的文件，一定要写
     = 
        _ _
    

     = 
        _ _
    
然后执行
  对应的表和数据就都创建好了本文作者：  

导语

在上一篇利用构建项目的构建项目介绍文中提到过一个 的 。当时提到“每一个添加进去的方法都会在调用的时候被调用，而且通常来讲，这些方法是按照顺序调用的”以及简单介绍了的方法执行顺序，这篇文章将仔细分析 的具体实现。

 
所谓的 是开发中的一个概念，具体来说是一个与线程相对应的对象，用它来实现线程自动释放池、延迟回调、触摸事件、屏幕刷新等功能。线程一般在执行完任务后就直接退出， 这个循环会让线程处于接受消息等待处理的循环中，直到接受到退出的信号才会结束循环。中的 概念是说存在多个时，在我们给每一个类都定义了一系列具有优先级关系的属性事件用于构建不同的项目文件，每一次实例化的时候运行我们的构建程序，多个的组合使用就需要一个 处理来接收用户发出的构建事件，等待用户输入，按优先级的顺序处理构建程序的循环。参考 
核心库
使用来处理 。有自己的事件生命周期，在前文中提到过，按照顺序列出来是，，，，，，，，开发者在中定义的方法名如果不在上面列出的事件中，那么将作为事件，在和中间被调用。用来管理一个存在于内存中的任务队列，引用库后返回一个构造函数。  = 接受一个可配置的数组也就是任务组作为参数，任务组中的元素为字符串，第一个字符串将是第一个调用的任务，第二个字符串是第二个任务，以此类推。实例有一个方法    ，向任务组中添加任务，参数

任务名
任务方法
配置对象如果没有指定组的名字，会使用。每一个任务方法都会收到一个作为参数，这个必须在定义的任务中被调用来进入下一个任务。 向任务队列中增加任务、
    {
     一些完成一些事情，同步或异步，
    如果是同步则在最后调用
    如果是异步，则在异步回调中调用
  
}


这样就可以构建一个任务队列，事件将按顺序被调用，每次调用，队列都会执行一次：
  =    

  = {
      
    
}

  = {
      
    
}

  = {
      
    
}

  = {
      
     
}

 按顺序输出     任务
队列实现
的源码并不复杂，其核心就是维持一个对列对象，这个对象已任务名为，以任务数组为，然后按照任务对列的顺序调用。继承了对象的属性，可以利用订阅发布来调用事件。先来看整体的实现代码有删减：
    {
       = 

     存放任务数组
     ____ = {}

       {
           ____ =  
    }
}

  {
     每一个任务的子任务
      ____ = 
}
可以看出用私有属性对象维护任务队列，我们传入的任务队列在内部用于生成任务数组的数组，调用方法实际上就是往对象中的相应的任务数组中添加新的方法元素。上面的例子就会有如下结构
{
        
      
      
｝
在看看运行代码有删减：
 =  {
        
       = 

    _ {
         = 
         任务队列中的任务都运行完就触发事件
         _________ ===  {
              
        }
    }
}

_ =    {
        = 
     取出任务队列
      =  ____ 

      =   {
        
         没有任务了执行
           =    
         执行相应下的的方法
        ____    _  
    }

    
}


 实例的方法
   跳过执行_的
   指向_，从头执行任务队列

 =     {
      如果数组中没有方法元素就跳过
        ____ ===    
     取出数组中的方法，将也就是作为第一个参数传入
         
}
每次调用任务队列会重新执行一次。每次重新执行时，之前的任务的数据已经都是空的，所以会直接跳过，执行下一个。每一个任务都是使用在下一个事件循环中调用， 中添加了一个标志，在方法中判断，如果是状态则直接返回，不会调用，等到调用才会执行来保证执行顺序。
简单实现的生命周期
明白了 的使用方法后原理后可以简单模拟 的生命周期实现，首先定义任务队列：
  = 
  
  
  
  
  
  
  
  

然后提供一个基类给每一个继承：
  = 
  = 

  {
     {
         =  

        
    }

     {
          = 
          =  =  == _   == 
         过滤方法名
          = 
          = 

         = {
              = 
              = 

             自定义方法归入队列
             {
                 = 
            }

              = {
                 处理异步事件
                  {
                     
                }
            }
        }
    }
}
实现一个类：
    {
     {
        

        
    }

     {
            = {
             = {
                
                
            } 
        }
    }

     {
        
    }

     {
            = {
             = {
                
                
            } 
        }
    }

     {
        
    }
}

  =  
 输出  
          隔秒
            隔秒
         
         

原文出处：社区缘起
  在看到一篇机器学习入门的文章，回想自己磕磕碰碰走过的弯路，颇有感触，因此对自己从懵懂到稍稍入门过程中看过的教程做一个简单的介绍，希望帮到后来人；
脉络
   机器学习这个词起源于世纪年代的 ，是人工智能研究到一定阶段的必然产物；机器学习的定义比较多，笔者比较认同的是给出的定义：如果一个程序在一个数据集上通过学习能提升的性能，那么认为这个程序是一个能够学习的程序；
  这里的不是通常所说的后台同学理解的性能和、吞吐率有关的意思，而是指一个模型或者算法在一个问题上的正确率、召回率等指标；
  从发展历程来看，经历了以逻辑规则为代表的推理学习阶段、以决策树位代表的符号主义学习、以神经网络为代表连接主义学习阶段以及以等技术为代表的统计学习阶段；至于年前后兴起的 ，则是神经网络因为硬件条件、训练算法的提升的有一次走红，所以不单独介绍；
   从实际的业务来看，机器学习算法更多是以一种数据处理、数据分析方案的角色出现，这个阶段统计学习相关的算法是绝对的主流；本文也是从这个角度出发来给想入门而不得的同学提供一个入门的阅读；
推介
   限定在统计学习这个范围后，机器学习所涉及到的只是主要包括：数学算法编程；其中数学又可分为分析概率；汇总起来，数学分析概率统计算法编程大概是机器学习入门的基本要求了，下面从这三个角度给出笔者看过觉得比较优质的一些书籍供大家参考
分析
数学要用到的主要知识是数学分析和凸优化的一部分理论；
数学分析：首推北大张筑生版的数学分析新讲一套三册；全面深入细致讲解了数学分析的方方面面，如果觉得实数系构造这一块不够严谨，可以参考陶哲轩的实分析前面一两章；
如果不求严谨，无力啃下完整的数学分析又想学习算法的同学，则推荐浙大版高等数学；再次一点可以看华中科技大出版的一元分析学和多元分析学这两本书；名字虽然叫分析学，实际比浙大高数还要简单一些；
优化理论：满分推荐《最优化导论》这本书，作者是，亚马逊有中译本；这本书是我苦寻很久才找到的一本，填补了从高数到学习算法之间那一环的不二法本；第二本推荐是凸优化，不过目前只有英文版，门槛稍高，但是内容清晰简练，非常值得一读；
线性代数：推荐 的   ；不解释，网易上有对应的视频，满分推荐
概率
概率论：我对这一块一直不太看得上，所以书比较杂，这里推荐陈希孺的教材吧；
贝叶斯：当之无愧的经典是  的《统计决策理论与贝叶斯分析》，微盘上有中文版的；国内比较好的是茆诗松写的《贝叶斯统计》这本书；这里有个奇怪的现象，似乎八十年代贝叶斯在国内火过一段时间，然后就沉寂下去了，导致这块我们实际理论知之甚少，如果不是研究的时候反复查找才找到这两本书，估计我也是傻乎乎的停留在贝叶斯公式的基础上了；
算法
这一块书籍特别多，重点推荐两部我深度看过的和两部还没看但是绝对是经典的书籍
统计学习方法：李航博士写的，李航是华为诺亚方舟的负责人，在统计学习上的造诣非同一般，这本书以极短的篇幅，系统介绍了几乎所有常见算法的数学原理和证明，可以作为常备手册，反复阅读；配合之前推荐的最优化导论，简直天生绝配；
机器学习：周志华版本；版本内容稍稍陈旧，周志华版本如果打一个比方的话，就是陈近南交给韦小宝的那本绝世秘籍目录一样；绝世秘籍有很多，但是目录只有薄薄的一本；这本书深入浅出的勾勒了机器学习的大体面貌，并不晦涩艰深，但是对一些基础东西讲的很透，非常适合入门学习；
我还没来得读的有两本：一本是，中文名叫模式识别与机器学习，没有官方的中文版貌似，网上有非官方翻译的版本；另一本是，统计学习基础；贴出来供大家参考；
结语
机器学习的坑很大，里面涉及的内容也非常多，尤其与大数据结合在一起，有一系列的框架、基础设施有待研究；本文只是一个基础入门的介绍，有进一步需求的可以单独聊，或者后面再写一个进阶版吧；
能够给到的一点个人感受就是机器学习不嫌你懂得数学多；有精力、有实力的同学可以在分析的基础上继续往上攀爬：实分析、泛函分析、微分几何、拓扑。。。总有机会可以用到的，否则看到类似再生核希尔伯特空间的高逼格词汇还是和我一样干瞪眼：

相关推荐人人都可以做深度学习应用：入门篇上深度学习入门实战一像一样算法生成梵高风格画像机器学习入门系列，简介在一线做了十年的开发，经历了网易、百度、腾讯研究院、 等几个地方，陆续做过  游戏、 页游、浏览器、移动端翻译  等。
积累了一些感悟。必然有依然幼稚的地方，就当抛砖引玉，聊为笑谈。
一、对于团队而言，流程太重要了
行军打仗，你需要一个向导；如果没有向导，你需要一个地图；如果没有地图，至少要学习李广，找一匹识途的老马；如果你连老马也没有，那最好可以三个臭皮匠好好讨论，力图胜过一个诸葛亮；如果三个臭皮匠连好好讨论也做不到，那就是典型的乌合之众了，最好写代码前，点上三炷香，斟上一杯浊酒，先拜拜菩萨，再拜拜谷歌。
我个人属于性格温和的程序员大多性格不错，但确实见过少数强势的人，说很多强势的话。在技术上一言而决，一听到任何反对就上升到私人恩怨。这样的风格，到底是刚愎自用，还是胸有成竹，就需要仔细判断了。
为什么说流程重要呢？实际上，如果团队上有孙悟空存在，去西天取经，大概也不需要什么流程，只要方向就可以了。 但作为普通的战士，应该先虑败。找人算命时，应该先听听不好的地方，好的地方就不用听了，总归是好的，不好的地方一定要听，这样才能规避。
这就是我的态度：先悲观一点，划清底线，考虑在这个底线上你该怎么做？
这是我做开发的一个习惯，但这个习惯肯定不适用于买房。
怎么划清底线呢？就是假想团队中没有孙悟空了，光靠你唐玄奘、猪八戒和沙和尚，应该怎么去取经。
这个月走什么地方，遇到山怎么走，遇到河怎么过，遇到路上有妖怪劫道，谁去抵挡。遇到路上有少女要搭救，怎么办？这就是流程，是原则。
我经历过一个流程很混乱的阶段。都是很多年前的事情了，可以拿出来说说，不涉及单个人。
年在百度浏览器团队时遇到几件让人影响深刻的事情。 有一次开会，产品拿出  某个产品的 ，里面有一段很酷炫  效果，要求开发加上，只给天时间，大家目瞪口呆。后续的开发为了赶节奏，导致非常多的  ，又为了修改  ， 将所有的  按照人员平均分配，导致不同模块间的同学相互修改实在难以想象。好比让做花卷的厨子，去修改西湖醋鱼的味道。
最初的现象是：下降的慢，延伸  反而增加，每个人都累的半死，代码风格极其杂乱，为了赶工导致的临时方案层出不穷；
到了中期：人员离职越来也多，代码难以维护，新加的需求与之前的临时方案冲突。
到了后期：想做一些修复，想调整架构，又要保证正常运行，其难度好比在一架飞行的飞机上拆换零件。
然后我也急忙离职了实在看不到成功的可能性。
后来到了腾讯的团队，感觉流程就规范多了。需求和  有  跟踪，产品发布按照节奏，需求提出前会和开发反复讨论可行性，有专门的质量跟踪，有专门的用户反馈，每天知道要做什么，也知道明天要做什么。有产品需求，也有开发需求！这个非常重要。很多团队，都是只有产品需求，开发好像牛一样，耕完地就不管了？
流程其实没那么复杂，就是各司其责节奏。我们都是“哆瑞咪发梭拉西多”中的一员，各自有各自的责任，然后组合在一起，按照一个节奏跑起来。把该做的事情与该跑的节奏定好。
二、不要炫技，老老实实写代码
网上有一个段子，说有人要用实现一个简单的功能，然后朋友给他推荐了几十个库。
真的有必要吗？具体情况具体分析。
居家过日子，你只需要一套普通的工具就可以了；如果你是修车的，你需要一套修车的工具；如果你是光头强，你需要一台伐木机。   吃饭用筷子，用刀叉，都可以，但不要用杀猪刀，不要用丈八长矛！，当然也不能用牙签。
用什么工具，用什么库，问问过来人，多在上搜索一下。举个例子： 上加密，用 就可以了，微信也在用，你当然可以学习；数据库  思想，用  上推荐的  就可以了； 上  引擎，用就可以了；小型游戏 ，用  足够；写 ，用  足够。
首先想想：一些大库  的住吗，后续发展如何？这些库对安装包的体积影响有多大？有没有调研过同样的产品在用什么？
想清楚了再决定用什么，最好是跟随成功项目的脚步。
三、架构上实用适用
很喜欢曾国藩的一句话：结硬寨、打呆仗。
一字长蛇阵、八门金锁阵，哪个好？ 都是单个进程，微信  版本以前是单进程，以后有独立的网络进程；  浏览器的进程架构更加复杂， 进程、内核进程、 进程，而且还有根据页面多少的进程调节模型。
这些设计都很好，各有各的道理，都适用于当前的产品。所以我的观点是：首先分析当前产品的规模、性质，然后再设计架构。
在当前阶段达到：开发效率架构的平衡；并向后展望个月，或者半年左右，看看架构能不能适应。
我做腾讯翻译君时，曾反复犹豫要不要模仿微信加入独立的网络进程。后来逆向了有排在第一二位的竞品，最终采用了现在的主功能单进程模型。
 产品规模、人员规模、功能阶段，具体问题具体分析。
四、既要有攻城之力，也要有熬战之气——
产品开发完成后，必然有  。其实开发人员在工作过程中，是有一定的直觉或者心理预判的，即：某个功能模块的质量如何。 这里面的质量包括：可维护性、扩展性、算法\渲染效率，还有就是与崩溃率。
功能开发完成后，就要开始守城了。
，一部分产生是由于架构带来的，例如比较复杂的架构，会导致复杂的实现细节；
 但还有很大部分，其实是基于如下三个原因产生的：
   对于某个的不了解，或者对于某个平台，或者  版本的不了解。 举例而言：里面非主线程，是不能直接处理相关的事情的； 的内存释放也不是绝对的，相互指向是无法释放的；函数个数是有问题制约的这些的产生，也是开发人员摸索学习的过程，经历过一次就不会再犯了。这是学习广度与熟练度的问题；
   还有一些，是由于粗心大意导致的。例如空指针的问题，野指针的问题。在  的开发中，野指针的问题， 句柄的释放问题，这些都是严谨的代码需要避免的； 而又一些工具，或者方法是可以规避这些问题的，例如 中 的利用  和  加强空指针检测等方法；
   还有一些，是由于“使用情况各异导致的”。例如：偶现在某个模块。这里的本质还是因为逻辑的异常边界没有处理好。例如  上的  问题，还有  上  焦点导致的对象释放问题。这些异常情况，一部分靠测试发现，一部分靠用户反馈，还有一部分就靠自己的异常处理。例如中的 机制，其实就是遇到异常了，你能纠正错误的机会。
五、自审
每过一段时间，都要站在高空俯视自己，问问：到底是在承担过去，还是在改变未来。
如果之前程序代码质量不好，后面修改问题的时间就会比较多。到了开发的中期，得多问问自己，你在不停的改正以前的错误，还是在做新的东西。 如果修改错误的时间多一点，那就要注意自己的代码质量了！
六、注释
我很喜欢写注释。有大牛说：代码就是最好的注释。 可惜我还没有达到那个程度。所以，我会把注释写的非常清楚。其一：为了自己以后维护的方便； 其二：为了其他人接手的方便。


这是我在翻译君项目中写注释的方式。：对于很复杂的逻辑，务必用的顺序依次写清楚； ：对于函数中的某个参数，需要解释为什么要设置这个参数，尤其是公用工具类里面的函数说清楚参数的背景含义，可以让其他调用者理解的更加清晰。
我一般不用英文写。虽然这样看起来格调很低，但胜在大家都能轻松的看懂。写代码不能太傲娇，写注释也不要太傲娇，目的是让你的搭档或者接手者，更轻松的理解，让她他少加班。
七、代码结构
 代码结构要清晰。有按照功能划分的，有按照  结构划分的。还有公用工具类，有数据管理，有主逻辑控制。不管用哪种思想，有序的代码结构，可以让每个人感觉很干净。好比日本的收纳整理技巧让很多小资推崇，无非就是干净、整洁、便于管理。
 而且，还有一个重要的好处：代码结构表现出来的其实是——程序的一个模块\逻辑思想——让大家工作在不同的区域。
八、代码风格
代码风格统一！好比一家人，有叫  的，有叫安东尼的，还有叫流川枫、石破天、圣杰夫拉斯基，无所适从。理论上，看一个函数，就能从名称上区分哪些是成员变量，哪些是局部变量，哪些是全局静态值。
除了命名统一外，还有一行代码最大的宽度，函数的连续调用长度等，头文件的包含风格，也最好有一个约定。类的出现时间，创建人名，最好也加上，看起来没用，但到了追踪问题时，就能看出时间线的好处。
九、安全与逆向
这是针对说的，还有插件也需要考虑。 上首先要防止被别人逆向，我成功逆向并重新打包过有第一位和第二位的竞品。这似乎有点不可思议，但确实做到了。加固混淆代码判断，最好都有。
安全上，可以看金刚扫描的漏洞，逐一修改就行。公司很多工具很好用的！
十、开发效率
开发效率可以用这些方式提升：
  构建公用工具类，方便大家使用
   使用开源的一些包，例如  思想的数据库等
   可以很快的找到问题。开发中，找  的时间，往往是很多的。我用的方法有个： 使用  ； 拦截所有  到我指定的地方；超多的 ， 有统一的控制开关。
  借力：数据上报用灯塔，崩溃上报用 ，公司  上很多经验，拿过来用。 
十一、安装包体积
    压缩图片
   删除无效的资源文件
十二、渲染效率
 是用户的第一感觉； 快并稳定，第一感觉就不会差太多；管理好内存，基本管理好了一半 ；管理好 ，等于管理了人机交互感受。
 上的开发是：渲染效率与渲染效果的平衡。
很匆忙的写的，必然有很幼稚的地方，欢迎斧正。全球化在整个互联网领域仍是大势所趋，而在红海时代来临的游戏行业，“游戏全球化”已成为近年来的热点。游戏全球化运营，对节点分布、网络稳定、网络加速、安全防护等云端基础能力提出了很高要求。腾讯云作为国内游戏行业领先的公有云，腾讯云的全球化布局一直走在快车道，更好地助力游戏厂商实现全球化运营。本期腾讯云沙龙北京站，与来宾聚焦探讨腾讯云在全球化方面的技术布局，并邀请到了游戏全球化先行者的代表分享实践与洞察。
演讲主题：绿洲全球化案例分享
嘉宾简介：

张振华   香港绿洲运维总监从事多年游戏运维工作有丰富的游戏云使用经验，现任香港绿洲运维总监。
演讲概要：
随着全球游戏覆盖的持续扩大，全球同服游戏已经成为游戏架构的发展趋势，通过《坦克争霸》《虎豹骑》案例，讲述绿洲如何实现全球同服架构，如何有效运维全球同服架构。
视频回放：

关于：系列沙龙由腾讯云主办，旨在为游戏开发者提供一个自由的交流分享平台。沙龙将围绕游戏行业趋势、研发技术、运维和推广等热点进行探讨。每期沙龙将邀请国内外游戏领域专家，分享游戏开发及运营过程中的思考和实践。    访问沙龙官网 ，了解最新沙龙资讯和更多往期回顾。导语
本演讲整理来自“全球云计算开源大会”且演讲文稿等已获得作者授权。

作者介绍

邹辉：腾讯云技术负责人

腾讯高级工程师，现任职腾讯云团队技术负责人，先后在华为、腾讯等国内知名的企业从事研发和设计工作。有近年的 、 后台系统开发设计经验，对云计算相关技术、分布式存储系统、后台逻辑系统 有比较深入的研究，擅长典型的互联网海量系统的设计。

尊敬的各位同行大家下午好，我叫做邹辉，来自腾讯公司云平台部。我们容器服务也是采用的近几年容器技术是最热门的技术之一，很多公司或者行业已经把容器作为自己的测试环境以及正式环境，正式上跑一些业务。而腾讯也不例外，早在三年之前腾讯基础平台部门已经开始容器方面的技术，经过三年时间的积累，腾讯很多业务已经跑在容器平台上，所以说腾讯内部对容器这块也积累了很多经验和教训。差不多年下半年开始我们决定把这些经验以及容器方面的技术放在云上，为云上的客户提供容器方面的解决方案。我这次分享的主题，当我们把容器服务放在云上的时候，我们碰到的一些问题，以及我们针对这些问题的解决方案。

当我们决定在云上提供我们容器服务的时候，实际上我们内部面临两种选择去做一个技术选型的时候。第一种选择，因为腾讯内部已经有一个容器平台，我们通过自研把腾讯内部容器平台做一个修改，放在云上去，对腾讯云上客户提供解决方案。第二个选择开源解决方案，跟行业一起快速把容器服务放在云上，对用户提供这样一个服务。之所以有这样两种选择，如果放在前几年大概是年之前的腾讯，可能我们好不容易选择自研，已经撸起袖子开始写代码了，为什么有这样一个选择？因为腾讯内部近几年开始流行开源意识和文化。所以第二种选择，就是我们使用开源的解决方案。

当我们选择作为我们容器服务解决方案之后，我们投入研发人员做一些研究。结果发现一个问题，我们研发人员把集群搭建起来，构建起来网络方案，花了差不多一周的时间，我们研发人员可能研究一下的概念，同时把它存储，最终使用去搭建一个完整服务的时候，又花了几周时间，一个完整流程下来，我们开发人员花了差不多接近一个多月的时候完全把上手。我们用对外部客户提供服务的时候，我们担心上手门槛很高，所以我们解决第一个问题，就是应用性方面的问题。我们希望腾讯云的容器服务能够简化弱化的概念，让大部分客户使用容器服务的时候，可以更简便。容器更多像黑盒，用户登录虚拟机跟登录物理机一样，定位你问题可能难度比较高，在易用性上我们更希望把容器黑盒打开，让更多用户更多看到容器里面的东西，比如说登录、监控。还有一些高级用户，使用更高级的功能，我们希望容器把架构放开出去，让我们高级用户完全使用的功能。所以关于易用性和开放性的考虑，我们设计容器里面是第一个需要解决的问题。

接下来看我们在架构怎么解决这样的问题的，这是典型的容器集群，在外面我们加了一层管控系统，管控系统两个目的：第一个它会把一些概念封装成用户更加容易理解的概念开放给用户。第二管控系统跟腾讯一些资源打交道。经过封装之后用户创建一个服务，用户可能简单理解我需要镜像是什么？我需要多少计算资源？大小是多少？我对外开放还是对内开放？就可以完成这样一个服务申请，由我们管控系统负责跟集群里面的，申请一些概念。当我们做了一段时间之后我们发现如果把对外提供出去可能存在一些问题，所以我们做了改进，把所有跟腾讯层打交道的工作放在到了的插件里面去，由插件跟腾讯云资源做交互，然后我们完全开放出去，这样用户既可以使用腾讯云的管控平台，又非常方便使用容器服务，又可以的完全操控里面所有的功能，这是我们易用性和开放性方面的考虑。另外易用性方面我们借助开源一些组件，让用户非常方便登录到容器里面去，去定位问题，察看问题，支持直接从上传和下载文件。举个例子，如果我们容器服务运行过程当中发现一个网络问题，我们需要抓包实现，这时候我们怎么操作？很简单直接登录抓包，然后通过下载工具直接把文件下载到本地，然后做一些深入的分析。关于上传和下载，我们借助的本身，把文件完成上传下载的操作。

除了登录容器这块我们还做了其他的操作，在页面上把容器标准输入、标准输出、标准试错的日志输出到页面，这样可以很方便察看。另外我们把容器的监控数据也跟我们一些监控系统打通，在每个容器的节点上部署一个功能，采集容器方面监控信息，比如说、内存、网络、带宽这样的信息，采集完成之后这些信息上报到我们监控系统，这个监控系统也是有等一些开源软件构成，这一套系统出来以后，用户可以把监控异常点进行一些报警，同时可以用察看容器的应用信息，这是我们在易用性和开放性在容器落地方面的考量。

另外大家也知道容器技术本身上就是 英文技术，跟其他虚拟化的技术相比，在隔离性和安全性天生具备一些弱势，所以如果我们把容器服务对外开放，提供给我们用户用，在隔离性和安全性也是我们必须解决的第二方面的问题。隔离性上我们这样考虑的，首先我们认为一个集群属于一个用户，不同的用户去使用不同的集群，一个集群是构建在用户自己的层基础资源之上。而用户具备操作层所有的权限，通过这样一个划分，我们就保证了用户之间通过物理机或者资源虚拟机的来达到隔离性的效果。其次在实际使用经验中我们建议同一个用户他们测试环境以及运行环境也通过不同的集群做区分和隔离，达到安全方面的效果。

每个用户有不同的集群，这时候我们面临另外一个问题解决，当一个用户初始设立一个集群，我们怎么样在我们平台上把搭建起来，集群需要升级的时候，我们又怎么样把集群升级到一个新版本。在每个机器上有一个，除了监控数据采集，还具备创建集群和集群升级的功能。当这个启动的时候，去拉去这台机器属于哪个集群，证书的信息。拉取以后这个是常用的进程，这个库里面存储所有集群的节点，包括版本信息和状态信息，当我们需要为进程进行升级的时候，我们跟新一些任务信息。分三种，一种是下载任务，从远端下载，第二个删除任务，第三个启动一些执行的命令。所以通过 库，我们可以很方便用进行创建，完成整个集群的创建和操作。这是我们在单租户集群问题解决方案。

刚才更多谈到隔离性方面的问题，接下来看我们安全性问题怎么解决的。首先我们把的开放给用户，让用户访问集群的时候，我们设置双向的证书加密码，用户访问这个集群首先下载这个集群证书和使用密码。其次一个集群里面部署对用户不感知的，一旦被损害造成不可逆的结果出来，部署对用户不可见，但是用户可以通过，完全操作里面的资源。其次当我们插件访问基础资源，我们根据来源做一些操作，只有属于本用户的机器才能访问对应的资源。最后我们把集群独立出去，访问集群的时候，保证本集群只能访问本地的资源，同时这个只能在发起，不能从其他地方访问。

除了集群的访问上，在镜像仓库访问上我们也做了一些措施。我们镜像仓库为每个镜像做一个权限控制。比如说这里一个公司的负责人，他为他的员工分配镜像的访问权限，这时候员工用自己账号拉取镜像，上传镜像时候，权限通过员工才有拉取的权限，我们镜像仓库授权达到最小。这是隔离性和安全性方面腾讯做的考量。当这个解决之后我们面临第三个问题是什么？这个问题也是我们投入时间最长的问题，我们需要把和腾讯一些基础的的资源打通，比如说负载均衡、网络、存储等其他一些资源，这个章节我重点说一下网络方面，存储方面，怎么样跟腾讯内部资源进行打通。

网络方面有五种场景：第一种场景容器之间的互访是怎么设计的？第二种场景集群内部的服务之间互访是怎么设计的？第三种跨集群之间的服务之间它又是怎么互访的。第四种从外部访问集群内部的服务是怎么完成的？最后一种如果从外部去访问集群内部多个服务又是怎么完成的？
接下来首先看一下容器之间互访我们是怎么设计的？做这个设计根据我们需求有一个基本诉求。第一容器距离独立的，第二容器与节点之间也可以通信，第三容器可以访问外网。第四从容器外面集群方面跨网络都会有一些访问到容器里面。
我们基于这样一个诉求我们把容器网络跟腾讯的网络打通。我们把容器网段跟腾讯的网段打通做了一个扁平化的网络。我们从想访问到，在上完成一个查找过程，查找我容器网段位于哪一个节点上，查这个路由节点做一个封装包，包含原容器，目标容器的，外网包含原容器，目标容器的，转发到节点上，在节点上把这个包发送到里面去。通过这样一个设计整个容器网络是扁平化网络。另外我们借助的网关，来自我们外部访问请求，来自不同的访问请求，都可以通过不同网关访问到容器，或者对应的里面，这是容器互通我们设计的理念。除了容器之间的互通、服务之间的互通基本上采用了的原生方案，通过去做一些转发操作。

接下来我们看一下除了容器内部服务的访问，从外部如何访问到集群里面的服务的。这会涉及到另外一个概念负载均衡，我们把腾讯内部负载均衡跟容器网络打通分两层。第一层外乎访问一个容器服务的时候，我们为这个容器服务分一个域名，用户可以通过这个域名到腾讯接入层，这边有一个路由表做一些封装，把这些请求按照负载均衡的算法落到集群里面每个节点上，这是第一层用户一个请求怎么样到达主机。到达主机之后后面转发工作就是原生的基础方案，把这个请求做一个原目标的存储，把请求平均分发到容器所在节点上去，这是负载均衡实现的原理。

除了说是容器外部用户直接访问集群里面的服务之外，还有一种场景，这种场景当然比较少，就是说根据域名转发，这要求我一个用户访问一个容器访问一个域名根据不同的地址转发到不同的场景里面去。我们采用了 的方案。当一个访问到达，根据不同的路径，把这些请求转发到不同的 上，这些和节点有可能在一个集群里面，当然也可能在多个集群上面，这样解决了跨集群部署问题，通过跟的打通，实现一对多的解决方案。除了网络的解决方案还有一个比较关键的点就是存储侧的解决方案。在存储侧相对比较简单。我们腾讯做了两件事，用户创建容器的时候，我给用户指定一个网络磁盘，这时候我们创建容器之前，在本地去率先把网盘部署在节点上，然后容器可以使用本地磁盘使用网盘。如果容器发生一些故障需要做迁移，我们也会做这样的操作，首先把故障机器路由节点网盘做处理，新的起点上我们把容器启用，同时做一遍启用方案。我们把层的加入到社区，深度参与，推进社区的发展。谢谢大家，今天我演讲就结束了。谢谢。近期，核心开源团队一行来到腾讯云进行深度交流。双方就项目中已实现的加密形式、算法进行讨论外，还共同探讨了“量子加密”“后量子时代的密码学”等行业前沿议题，探索“未来密码”，解锁未来互联网的无限可能。 团队还分享了即将推出的新版本，以及未来半年的。
同时双方还就协议的改进、版本特性以及未来更多技术层面的合作进行了深入的交流。腾讯云负载均衡团队也和团队介绍了性能优化的一些解决方案，包括异步并行计算，共享、协议实现等。团队十分认可腾讯云网关团队的技术实力， 认为腾讯云网关支持协议具有很强的创新性，并且十分有难度，是业界首创的举措。后续团队也会考虑支持协议。
是一个开源的、用于协议的加密工具，是互联网加密传输的核心基础组件，由加拿大的 等发起编写的，当前互联网安全传输的大部分场景如均使用开源项目，其作用主要有：数据加解密、数据签名、证书签发和校验等。当前，作为协议的开源实现，得到了非常广泛的使用。
腾讯云网关团队，通过腾讯年的业务实践及技术累积，已经实现一套多网统一接入，支持自动负载均衡的系统。具有可靠性高，扩展性强，性能高，抗攻击能力强等特点，在腾讯公司内部业务中广泛使用。同时，腾讯云负载均衡，底层采用腾讯云网关架构，使用进行协议加密，支持  等版本，在协议性能调优，卸载等方面有深入的理解。腾讯云一直致力于开源社区的贡献。未来，腾讯云网关团队也将把团队在的调优技术开放出去，如异步计算、速度统计、全局的实现方法等，积极拥抱开源生态，成为开源领域的贡献者。感谢阅读腾讯 微信号第篇文章。本文将详解我们入选的八篇论文，及我们对机器学习未来研究方向的一点思考。

被誉为神经计算和机器学习领域两大顶级会议之一的另一个为近日揭晓收录论文名单，腾讯 共有八篇论文入选，位居国内企业前列，其中一篇被选做口头报告，该类论文仅占总录取数的，我们将在下文解析，也邀请大家在的现场跟我们进一步交流与讨论。
欢迎大家留言评论：你觉得今年会有哪些亮点？
插播一下，腾讯 今年还在其他几大顶级会议上斩获颇丰，包括机器学习领域另一顶会四篇入选、计算机视觉领域顶会六篇入选，以及自然语言处理领域顶会三篇入选等。
本届  共收到篇论文投稿，创历年新高，其中篇被选为大会论文，录用比例。其中有篇口头报告和篇亮点报告。会议门票也在开售不到一小时内售罄，参会人数预计将超过去年的人，火爆程度可见一斑。

机 器 学 习 未 来 研 究 的 一 点 思 考
的内容涵盖认知科学、心理学、计算机视觉、统计语言学和信息论等领域，可由此窥见机器学习最为前沿和备受关注的研究领域。而在思考未来方向时，我们认为研究者们可追本溯源，沉下心来关注一些本质问题。
比如机器学习研究方向之一，是探索如何在特定知识表达体系下有效利用不同资源，这里的资源包括计算资源时间复杂性和数据资源样本复杂性。这个方向上的主流思路是使用基于深度网络的模型，但近几年的研究更较偏和，而未来则更可能会是在深度模型的知识表达体系下进行探索。深度模型带来的最大挑战是非凸性，这从本质上有别于传统的计算与统计理论，也值得研究者们产生一些全新的思考。
深度学习是目前毋庸置疑的大趋势，近几年来此类研究空前火热，如果我们回到初心，将部分不真实的内容逐步澄清，能促进研究走上良性发展之路。
腾 讯   八 篇 入 选 论 文 详 解
论文按标题英文首字母排序
 论文 去中心化算法能否比中心化算法效果更佳－一个关于去中心化的随机梯度方法研究              
本论文与苏黎世联邦理工学院、加州大学戴维斯分校和合作完成。并行优化和计算效率是从大数据发掘智能的核心竞争力。为了提高效率，大多数的并行优化算法和平台集中在研究中心化的算法，比如、及。中心化的算法的主要瓶颈是上百个计算结点与多个中心节点之间的通讯代价和拥堵，严重的受制于网络的带宽和延迟。而这篇文章里则考虑去中心化的思路以减少通讯的代价。
尽管在去中心化的方法在控制领域已经有所应用和研究，但是考虑的是在特殊的去中心的拓扑结构的情况下，如何交换融合信息。而且已有的研究都没有表明如果二者都能用的情况下去中心的算法相对对于中心化的算法会有任何优势。这篇文章的主要贡献在于研究了一个去中心化的随机梯度方法，并且第一次从理论上证明了去中心化的算法可以比对应的中心化算法更加高效。同时本文通过大量的在深度学习上的实验和比较验证了作者理论。
这个发现将会打开未来大家对并行算法的思路，给并行系统带来更多的灵活性和自由度。我们相信将会对未来的机器学习平台和算法开发产生较大影响。

本文入选  口头报告，论文占比为。

线性动态系统上的高效优化及其在聚类和稀疏编码问题上的应用            
本论文与清华大学和澳大利亚国立大学合作完成，其中的线性动态系统模型是用于时空数据建模的一种重要的工具。尽管已有的理论方法非常丰富，但利用进行时空数据的分析并不简单，这主要是因为的参数并不是在欧氏空间，故传统的机器学习方法不能直接采用。
在这篇论文中，作者提出了一种高效的投影梯度下降法去极小化一个泛化的损失函数，并利用该方法同时解决了空间上的聚类和稀疏编码问题。为此，作者首先给出参数的一种新型的典范表示，然后巧妙地将目标函数梯度投影到空间来实现梯度回传。与以往的方法相比，这篇文章中的方法不需要对模型和优化过程加入任何的近似。充分的实验结果证明了这篇文章中的方法在收敛性和最终分类精度上优于目前最好同类方法。
 通过斯坦因引理估计高维非高斯多指数模型       ’ 
本论文与普林斯顿大学和乔治亚理工大学合作完成，作者探讨了在高维非高斯设置中估计半参数多指数模型的参数化组分的方法。文中的估计器使用了基于二阶斯坦因引理的分数函数，而且不需要文献中做出的高斯或椭圆对称性假设。内部机构的研究表明：即使分数函数或响应变量是重尾分布的，文中的估计器也能实现接近最优的统计收敛率。最后，作者利用了一个数据驱动的截断参数，并基于该参数确定了所需的集中度结果。作者通过模拟实验对该理论进行了验证，对这篇文章中的理论结果进行了补充。
 基于几何梯度下降方法的复合凸函数最小化      
本论文与香港中文大学和加利福尼亚大学戴维斯分校合作完成，主要扩展了 和近期提出的处理非光滑复合强凸函数优化问题的几何梯度下降方法。文中提出“几何邻近梯度下降法”算法——能够以线性速率收敛，因此能相比其他一阶优化方法达到最优的收敛速率。最后，在带有弹性网络正则化的线性回归和逻辑回归上的数值实验结果表明，新提出的几何邻近梯度下降法优于加速的邻近梯度下降法，尤其面对病态问题时优势更大。
 基于混合秩矩阵近似的协同过滤     
本论文与复旦大学和中国合作完成，关于低秩矩阵近似方法现今在协同过滤问题上取得了优异的精确度。在现有的低秩矩阵近似方法中，用户或物品特征矩阵的秩通常是固定的，即所有的用户或物品都用同样的秩来近似刻画。但本文研究表明，秩不相同的子矩阵能同时存在于同一个用户物品评分矩阵中，这样用固定秩的矩阵近似方法无法完美地刻画评分矩阵的内部结构，因此会导致较差的推荐精确度。
这篇论文中提出了一种混合秩矩阵近似方法，用不同低秩矩阵近似的混合模型来刻画用户物品评分矩阵。同时，这篇文章还提出了一种利用迭代条件模式的领先算法用于处理中的非凸优化问题。最后，在系统和数据集上的推荐实验表明，能够在推荐精确度上超过六种代表性的基于的协同过滤方法。
 凸差近似牛顿算法在非凸稀疏学习中的二次收敛           
为求解高维的非凸正则化稀疏学习问题，我们提出了一种凸差  近似牛顿算法。我们提出的算法将近似牛顿算法与基于凸差规划的多阶段凸松弛法  结合到了一起，从而在实现了强计算能力的同时保证了统计性。具体来说，具体来说，通过利用稀疏建模结构假设的复杂特征即局部受限的强凸性和  平滑度，我们证明在凸松弛的每个阶段内，我们提出的算法都能实现局部二次收敛，并最终能在仅少数几次凸松弛之后得到具有最优统计特性的稀疏近似局部最优解。我们也提供了支持我们的理论的数值实验。
 用于稀疏学习的同伦参数单纯形方法     
本论文与普林斯顿大学、乔治亚理工大学和腾讯实验室合作完成，作者关注了一种可形式化为线性规划问题的广义类别的稀疏学习——这类线性规划问题可以使用一个正则化因子进行参数化，且作者也通过参数单纯形方法  解决了这个问题。相对于其它相竞争的方法，这篇文章中的参数单纯形方法具有显著的优势： 可以自然地为正则化参数的所有值获取完整的解决路径； 提供了一种高精度的对偶证书停止   标准； 只需非常少的迭代次数就能得到稀疏解，而且该解的稀疏性能显著降低每次迭代的计算成本。
特别需要指出，这篇文章展示了  相对于多种稀疏学习方法的优越性，其中包括用于稀疏线性回归的  选择器、用于稀疏稳健线性回归的 、用于稀疏精度矩阵估计的 、稀疏差分网络估计和稀疏线性规划判别 分析。然后作者提供了能保证  总是输出稀疏解的充分条件，使其计算性能可以得到显著的提升。作者也提供了严密充分的数值实验，演示证明了  方法的突出表现。
 预测未来的场景分割和物体运动        
本论文与新加坡国立大学、研究室和人工智能研究院合作完成。无人车和机器人这样的对智能系统中，预期未来对提前计划及决策非常重要。文中预测未来的场景分割和物体运动帮助智能系统更好地理解视觉环境，因为场景分割能提供像素级语义分割 即何种物体在何处会出现，物体运动信息能提供像素级运动状态即物体未来会如何移动。本文提出了一种全新的方法来预测未来的未观测到的视频场景分割和物体运动。用历史信息过去的视频帧以及对应的场景分割结果作为输入，文章中的新模型能够预测未来任意帧的场景分割和物体运动。
更重要的是，这篇文章中的模型优于其他分开预测分割和运动的方法，因为文中联合处理这两个预测问题以及充分利用了它们的互补关系。据内部统计，文中的方法是第一个学习同时预测未来场景分割和物体运动的方法。在大规模数据集上的实验表明，本文的模型相比精心设计的基线方法，能获得显著更好的分割和运动预测结果。另外，这篇论文也展示了如何用机构内部的模型预测汽车转向角，获得的优秀结果进一步证实了该新模型学习隐含变量的能力。
一 分 钟 数 读 
全称为        ，于 年在由加州理工学院和贝尔实验室组织的 神经网络计算年度闭门论坛上首次提出。会议固定在每年月举行。今年是第  届，将于  月  日到  日在美国西岸加州南部的长滩市 举办。
计算机学科由于成果更新迅速，更愿意通过会议优先发表成果，因此该类顶级会议大多比期刊更具权威性与影响力。和是机器学习领域最受认可的两大顶会，是中国计算机学会推荐的类会议及学术指标前五名。见如下


原文来自：腾讯实验室 公众号一、前言
受勒索病毒影响，许多遭受攻击的电脑中的大部分文件被加密而被勒索要求支付比特币以进行解密文件。当前没有完美的解密工具或者方案，但根据对病毒的分析，我们发现病毒采用加密原文件后再删除原文件的方式，于是针对被删除的文件就存在一定恢复的可能性，我们只要恢复出删除的原文件即可。
我们在号媒体采访时提到，可使用数据恢复软件通过恢复被删除的加密前的文件，能恢复部分文件，一定程度上挽回用户损失。应用户咨询和要求，本文以免费工具易我数据恢复工具为例提供加密数据恢复指南和步骤演示。
二、    恢复方法

首先安装易我数据恢复进行安装，下载链接为：_

安装完毕后点击桌面上的易我数据恢复向导打开软件，进入如下界面，按需求勾选要恢复的文件类型，进入下一步

然后选择丢失的位置即要恢复数据的硬盘，点击扫描按钮开始扫描

快速扫描后，如果未能发现你需要的文件，点击底部的深度扫描按钮

然后切换到类型选项卡，因为这里显示比较直观，也比较好找到你所恢复的文件

勾选相关文件类型，右边会显恢复出来的文件，点击恢复

选择一个磁盘或者文件夹用来存放你所恢复的文件，点击保存

软件进行进入恢复装填，等待进度条完成

恢复出来的文件，将会存在于  开头文件夹中

这是恢复后的文件


注：自月号，我们发现首例勒索病毒案例以来，腾讯云安全团队第一时间为云客户提供安全支持，多次通过短信、电话等方式通知潜在风险客户。我们会每天例行化普查勒索病毒感染情况，实时监测蠕虫舆情。如果您的企业遭受的勒索攻击，请联系我们，我们的安全工程师会协助进行安全加固和数据修复指导。
 
三、参考链接
 易我数据恢复官网： 金山数据恢复官网：在上一篇《 源码阅读笔记代码逻辑结构》中向大家介绍了  源码的逻辑结构，同时也简单介绍了  的基本情况。本篇将继续向大家介绍  源码是如何构造一颗回归树，不过在分析源码之前，还是有必要先和大家一起推导下  的目标函数。本次推导过程公式截图主要摘抄于陈天奇的论文《：    》。在后续的源码分析中，会省略一些与本篇无关的代码，如并行化，多线程。
一、目标函数优化
 和以往的    不同之一在于其将目标函数进行了二阶泰勒展开，在模型训练过程中使用了二阶导数加快其模型收敛速度。与此同时，为了防止模型过拟合其给目标函数加上了控制模型结构的惩罚项。
图   目标函数
目标函数主要有两部分组成。第一部分是表示模型的预测误差；第二部分是表示模型结构。当模型预测误差越大，树的叶子个数越多，树的权重越大，目标函数就越大。我们的优化目标是使目标函数尽可能的小，这样在降低预测误差的同时也会减少树叶子的个数以及降低叶子权重。这也正符合机器学习中的奥卡姆剃刀原则，即选择与经验观察一致的最简单假设。
图  的目标函数由于存在以函数为参数的模型惩罚项导致其不能使用传统的方式进行优化，所以将其改写成如下形式
图  改变形式的目标函数
图  与图  的区别在于图  是通过整个模型去优化函数，而图  的优化目标是每次迭代过程中构造一个使目标函数达到最小值的弱分类器，从这个过程中就可以看出图  使用的是贪婪算法。将图  中的预测误差项在_{}处进行二阶泰勒展开
图  二阶泰勒展开
并省去常数项
图  省去常数项
图  就是每次迭代过程中简化的目标函数。我们的目标是在第  次迭代过程中获得一个使目标函数达到最小值的最优弱分类器，即_。在这里累加项  是样本实例的个数，为了使编码更加方便，定义一个新的变量表示表示叶子  的所有样本实例_
图  新的变量
同时展开目标函数的模型惩罚项，并以叶子为纬度可以改写成
图  以叶子为纬度的目标函数
这里函数  是将对应实例归类到对应的叶子下，并返回该实例在当前叶子下的权重 。图  对叶子权重  求导，便得出最优的叶子权重 
图  最优的叶子权重
与此同时将权重代入目标函数，并且省去常量，便得到了目标函数的解析式
图  目标函数的解析式
我们的目标便是极小化该目标函数解析式。目标函数的解析式可以通过图  清晰形象的描绘出来
图  目标函数的解析式计算过程
从图  可以清晰看出目标函数解析式的计算过程。目标函数的结果可以用来评价模型的好坏。这样在模型训练过程中，当前的叶子结点是否需要继续分裂主要就看分裂后的增益损失 _。
图  分裂增益
增益损失 _ 的计算公式如图  所示，它是由该结点分裂后的左孩子增益加上右孩子增益减去该父结点的增益。这样在选择分裂点时候就是选择增益损失最大的分裂点。而寻找最佳分裂点是一个非常耗时的过程，上一篇《 源码阅读笔记代码逻辑结构》介绍了几种  使用的分裂算法，这里选择其中最简单的    进行讲解：
图     
图  算法的大意是遍历每个特征，在每个特征中选择该特征下的每个值作为其分裂点，计算增益损失。当遍历完所有特征之后，增益损失最大的特征值将作为其分裂点。由此可以看出这其实就是一种穷举算法，而整个树构造过程最耗时的过程就是寻找最优分裂点的过程。但是由于该算法简单易于理解，所以就以该算法来向大家介绍  源码树构造的实现过程。
如果对推导过程读起来比较吃力的话也没关系，这里主要需要记住的是每个结点增益和权值的计算公式。增益是用来决定当前结点是否需要继续分裂下去，而结点权值的线性组合即是模型最终的输出值。所以只要记住这两个公式就不会影响源码的阅读。
二、源码分析
 代码逻辑结构回顾
在上一篇结尾的时候说过源码最终调用过程如下：

|
    |
        |
        |
这里简化后的源码如下：
 
 _ 
                             _
                             _
                            _   {
    
     _
      {
        _ _
    }
｝
 是一个  向量，保存了对应样本实例的一阶导数和二阶导数。_ 是一个指针，指向对应样本实例的特征，_ 用于存储构造好的回归树。
 是为了初始化  在上一篇文章也说过  是抽象类   的指针对象定义了基本的  和  接口，该抽象的派生类定义了一系列树构造和剪枝方法。这里主要介绍其派生类  ，该类使用的即使我们前面介绍的   。
   数据结构介绍
在   定义了一些数据结构用于辅助树的构造。
_ 
   训练参数，即我们设置的一些超参数
   当前样本实例在回归树结中对应点的索引
  回归树中的结点
 _  保存将有可能分类的结点的索引
 的树构造类似于   ，它是一层一层的构造树结点。所以需要一个队列 _用来保存当前层的结点，这些结点会根据增益损失 _ 决定是否需要分裂形成下一层的结点。
   树构造源码
_ 
 
{
    _  =       ｛
         
          
    ｝
}
在   中定义了一个   类，所有的构造过程都由这个类完成。
_ 
 
{
          初始化  参数
     初始化树根结点的权值和增益
       _，_
       =    _   
    {
        给队列中的当层结点寻找分裂特征，构造出树的下一层
         _  _ _
        将当层各个非叶子结点中的样本实例分类到下一层的各个结点中
        
        更新队列，存储下一个层结点
        
        计算队列中下一层结点的权值和增益
        
        如果当前队列中没有候选分裂点，就退出循环
        _ ==  
    }
    由于树的深度限制，将队列中剩下结点都设置为树的叶子
    _  =    _   
    {
         
    }
    记录构造好的回归树的一些辅助统计信息
    
}
在以上代码中核心部分就是第一个循环里面的四个函数。我们首先来看下  是如何初始化结点的增益和权值。
 
_
|
    |_   =     _   
    |{
    |  _ = 
    |   = 
    |｝
这里点的 _ 就是前面说的结点增益，将用于判断该点是否需要分裂。 就是当前点的权值，最终模型输出就是叶子结点  的线性组合。 和  是两个模版函数，其简化的源码如下：
  
   
     _  _
{
     _  _ _   _
}  
 
   
     _  _
{
     _  _   _
}
以上两个函数就是实现了我们一开始推导的两个公式，即计算结点的增益和权重。在初始化队列中的结点后，就需要对队列中的每个结点遍历寻找最优的分裂属性。

_
|
    |寻找特征的最佳分裂值
    |_  =   _   
    |{
    |  
            | 
    |}
分裂过程最终调用了  函数，为了便于理解对代码变量名做了修改，其简化的代码如下   
_ 
 {
    建立个临时变量  用来保存结点信息
    空间大小为队列 _中结点的最大索引
      _   
     _ 结点分裂后左孩子的统计信息
    遍历当前特征的所有值
        =   =    = _｛
        得到当前特征值所对应的样本实例索引和特征值
           =   
           = 
        根据当前样本索引得到其分类到的结点索引
          _ =  
        结点分裂后右孩子的统计信息
          _ = _
        以当前特征值为分裂阈值，将当前样本归类到左孩子
        _ = _  _
        计算增益损失
         _=  _ _   
                                          __
        记录下最好的特征值分裂阈值该阈值是左右孩子相邻特征值的中间值
        __ _  
                                                              __ 
        将当前样本实例归类到右孩子结点
        _   
    ｝
}
从上述代码可以很清晰看出整个代码的流程思路就是之前介绍的    这里需要说明寻找分裂点有两个方向，一个是从左到右寻找，一个是从右到左寻找。上述代码只展示了一个方向的寻找过程。在寻找特征分裂阈值的时候分裂增益的计算函数是 其具体代码如下：
 
   
      {
            
}
上述代码就是简单将左孩子和右孩子的增益相加，而增益损失 _ 就是将左右孩子相加的增益减去其父节点的增益。

在寻找到当前层各个结点的分裂阈值之后，便可以在对应结点上构造其左右孩子来增加当前树的深度。当树的深度增加了，就需要将分类到当前层非叶子结点的样本实例分类到下一层的结点中。这个过程就是通过  函数完成的。

 函数更新 队列中的结点为下一层结点，然后在调用  更新 中结点的权值和增益以便下一次循环
三、总结
本篇主要详细叙述了  使用    构造树的方法，并分析了对应的源码。在分析源码过程中为了便于理解对代码做了一些简化，如省去了其中多线程，并行化的操作，并修改了一些变量名。在上述的树构造完成之后，还需要对树进行剪枝操作以防止模型过拟合。由于篇幅所限，这里就不再介绍剪枝操作。本篇文章只是起一个抛砖引玉的引导作用，想要对  实现细节有更加深刻理解，还需要去阅读  源码，毕竟有些东西用文字描述远不如用代码描述清晰。最后欢迎大家一起来讨论。原文【  ——   】

作为一个项目的维护者意味着什么
如果你维护者一个很多人都在用的项目，你可能就会意识到你写代码的时间变少了而回答的时间变多了。
在项目开始之初，你会不断尝试着实现自己的新想法，在知道自己 想要什么的基础上决定项目的走向。一旦你的项目开始流行之后，你会发现你的大部分时间都花在和用户以及贡献者打交道上。
维护一个项目需要的不仅仅是写代码的能力。有些时候会有一个你意想不到的的事情要应付，但是这对一个项目的成长也很重要相对于代码来说，我们收集了一些小技巧来让你的生活变得更轻松，从写文档到管理社区。
记录项目的进展
对于一个项目的维护者来说写文档是最重要的事情之一。
文档不仅说清楚了你的想法是什么，而且还帮助别人在问问题之前理解你需要什么和接下在希望做什么。
即使你不想长篇大论，对要点略说一二也比啥都不写要好。
写下你的项目的发展方向
从写下你的项目目标开始。把他们加到， 或者创建一个单独的文件。如果还有什么其他的老古董能帮助人们了解这方面的信息，比如项目管理路线图，也把他们公开吧。
有一个明确的，用文档写清楚的方向能保证你不跑偏，也不会因为其他的贡献者增加一个奇怪的需求。
比如， 发现有项目有一个明确的发展方向会帮助他决定哪个值得花时间。作为一个维护者的新手，他甚至还后悔当他接到第一个关于的时候没有坚持它项目本身的原则。

我一直都在摸索。我没有努力寻求一个完整的解决方案。与其采用那种半吊子办法，我真希望曾经对某些的提出者说：我暂时没有时间干这个，但是我会把他放到我的待办事项中。
—  “     ”

和大家交流你自己对项目的期望
制定规则是很伤脑筋的。有时候你可能觉得你像是在限制别人的行为或者说把好玩的东西都搞没了。
制定了规则，然后严格执行，当然啦，好的规则会让维护者更轻松。他们会把你从做自己不愿意做的事情中解脱出来。
大多数知道你项目的人对你或者你的处境都是一无所知。他们可能会觉得你做这个项目是有钱拿的，特别是你的项目是他们经常用的而且某种程度上有点依赖的时候。其实你只是在有时候会在项目上花很多时间，但是现在你在忙着安置新工作或者照顾刚出生的儿子。
这些都是再正常不过的事情！所以雀斑别人也知道这点。
如果你维护某个项目是临时的或者完全自愿的，能花多少时间就花多少时间。而不是你觉得项目需要你花多少时间或者别人想让你花多少时间。
这里是一些值得你写进项目里的东西：

怎样的贡献才会被复查和接受需要测试吗？提有模板吗？

你希望有什么类型的贡献？你是不是只希望在某些部分的代码上需要别人的帮助？

在合适的时候跟进项目比如说 如果你在七天之内没有收到的回复，那就先干别的去吧

你会在这个项目上话多少时间比如说 “我们每星期只会在这个项目上花个小时“


    这是一些给维护者和贡献者制定了基本规则的项目例子
保证交流公开
不管是什么时候，保证你的交流实在公共的场所就是大家都看的地方。如果有人尝试私聊你讨论一个新的需求或者功能，礼貌的引导它到公共的交流场所，比如邮件列表或者 。
如果你和别的维护者面基了，或者在私下做了一个很重要的决定，把这些信息告诉大家，即使只是把你的笔记发上去。
这样的话，每个人新加入到你们社区的人和已经呆了几年的人能够了解到的信息是一样的。
学会说不
文档你也写好了。理论上讲，每个人应该都会阅读你的文档，但是实际上，你总是要提醒有些小伙子他问的东西已经有答案了。
把所有的事情都写下来，当然，对你执行你制定的规则的时候客观分析实际情况也有帮助。
拒绝别人没啥意思，但是“你的贡献不符合这个项目的标准”比“我不喜欢你的贡献”要好听。
作为一个维护者，在很多情况下，你都要拒绝别人：不符合项目规则的 某个人脱离了讨论的重点，给别人做无关紧要的工作。
保持友好沟通
你要学会拒绝的最重要的一个地方就是和请求。作为一个项目的维护者 你会不可避免的收到你不想接受的建议。
可能某个贡献改变了项目范围或者和你的期望不合。可能想法很好，实现的很烂。
不管是什么原因，在处理这些不符合项目标准的贡献的时候都要婉转。
如果你收到了你不想接受的贡献，你的第一反应可能是忽略或者假装没看到。但是这么做会严重伤害到别人而且可能会让你社区里的其他贡献者失去动力。

管理大型开源项目的关键就是保证活跃。尽量避免让停滞不前。如果你是一个开发者，你会知道提交雷达是多么让人沮丧我也不知道这是什么意思。。你可能过了两年之后有人让你兼容一下现在的版本。
—  “   ”

别因为自己感到内疚或者想做一个好人就把你不想接受的贡献继续保留。随着时间的流逝，这些你没有回答的和会让你觉得很不爽。
更好的方式是马上关掉你不想接受的贡献。如果你的项目已经保守积压的的折磨，可以给你点儿建议，    
第二点，忽略别人的贡献给社区传递了一个负面的信号。让人感觉做一个贡献是很吓人的事情，特别是对于新手来说。即使你不接受他们的贡献，告诉他们为什么然后致谢。这会让人觉得更舒服。
如果你不想接受某个贡献：

感谢他们 的贡献

解释为什么他们的贡献不符合项目的需求范围，然后提供清楚的建议以供改善，如果你可以的话。和蔼一点，但同时也要讲原则。 

引用相关的文档， 如果你有的话。如果你发现你反复收到你不想接受的贡献，把他们加到文档以免你重复叙述。


你不需要用超过两句话来回复。比如，当一个的用户报告了一个相关的错误， 是这么回复的

如果你感觉拒绝别人很不好意思，也很正常，其实很多人都是这样。就像  说到的

我和很多来自诸如  等不同开源项目的维护者交流过，他们都异口同声的觉得做一个维护者最难的就是拒绝你不想打补丁。

对于不想接受别人的贡献这件事不要感到愧疚。如 所说开源的第一原则就是 “拒绝是暂时的，接受是永远的”当然啦，认同别人的热情还是一个好事，拒绝他的贡献和拒绝他这个人是两码事。
最后，如果一个贡献不是够好，你没任何义务接受它。对那些想对你的项目做贡献的人保持和蔼和积极的态度，但是只能接受那些你确定会让你的项目变得更好的提交。你说拒绝的次数越多，对你来说拒绝别人就越容易。谨记！
保持主动
要想减少你不想接受的贡献的数量，首先，在你项目的贡献指南中解释如何提交贡献以及怎样的贡献会被接受。
如果你收到太多低质量的贡献，让那个贡献者先多做做功课，比如：

填写一个或者的模板清单

在提交之前先开一个


如果他们不遵从你的规则，马上关掉病并引用你的文档。
当然啦这么搞一开始是不太舒服，但是你主动一点确实对双方都好。它减少了某个人花了太多事件到一个你不想要的上的可能性。而且让你管理起来更容易。


理论上，在文件里面告诉别人在他们开始干活之前如何更清楚的知道的干完之后会不会被接受。
—  “   ”

有时候，当你说不的时候，你潜在的贡献者会感到对你的沮丧或者不爽。如果他们开始找你撕逼了，     或者干脆把他们从你的社区开除，如果他们不打算和你保持建设性的合作关系的话。
接受指导
可能在你的社区里有人不断提交一些不符合项目需求的贡献。对你们双方来说不停的拒绝他的提交都很尴尬。
如果你发现有人对你的项目很上心，但是就是需要调教，那就耐心一点。给他解释明白每次它的提交为什么不符合项目需求。尝试着让他先做一些简单一点的事，比如那些标有“  ”标签的，以此让他慢慢习惯。如果你有时间的话，考虑教他怎么完成第一次贡献，或者在社区找一个人教他。
利用社区的力量
你不需要凡事亲力亲为。这就是社区存在的原因！即使你没有一个活跃的贡献者社区，但是如果你有很多用户的话，拉他们来干活儿。
分担工作量
如果你正在寻找其他人来参与 从身边的人开始。
当你看到新的贡献者不停的提交贡献，通过分配给他们更多任务来表示认可。如果别人愿意的话，记录下别人是怎么成长为领导者的过程。
鼓励别人来一起管理项目能很大程度上减轻你的工作量，就像 在他的项目上做的那样，

我曾经说过，“对，每个人都可以参与进来，你不需要有很多编程的经验。”当有申请来参加我们的活动的时候，我就在想，这是真的吗，我说了啥？有将近个人来了，我虽然不可能和每个人都单独交谈，但是大家一起来了，这说明我说的没错。只要有人知道怎么做了，他们就能教他们的邻居。
—  “  “ ”    ”

如果你需要暂时或者永久的离开的项目，大可找人来代替你。
如果别人认同项目的发展方向，给他们提交的权限或者正式把项目所有权转移给他。如果有人了你的项目而且在保持活跃的维护，考虑在你的原始的仓库放上这个版本的链接。如果大家都希望你的项目继续的话这不失为一种好办法。
 发现 由于它给他的项目写一个关于项目发展方向的文档，即使在它离开这个项目后他的那些目标仍然会被实现。

我写了一个来描述我想要啥和为什么。不知道为啥，项目的维护者就开始推动项目朝那个方向发展，这对我来说还是有点惊讶的。他们会一点不差的按照我的意愿去做这个项目吗？不总是这样，但是总是会把项目推动到离我的理想状态更近的位置。

让别人尝试他们自己想要的解决方案
如果有贡献者关于项目有不同的意见，你可以礼貌的鼓励它在他自己版本上继续工作。
一个项目不什么坏事情。能复制并且修改别人的代码是开源项目最大的好处之一。鼓励你的社区成员在他自己的仓库上继续工作是在不和你的项目冲突的基础上，给实现他们的想法最好的出口。

我迎合的用户需求。但是如果你是那中的一个，那么我的项目吧。我不会介意的！我的公开的项目是用来解决那些最常见的问题的。我尝试着让别人我的项目然后在上面拓展得更加简单。
—  “   ”

这对于那些强烈的需要某个你没时间实现的解决方案的用户来说也是一样的。提供或者自定义的钩子帮助他们更好的实现自己的需求而不需要改动源码。发现鼓励在上使用插件导致了很多有趣的想法的诞生。

一旦一个项目变大之后，维护者对怎么增加新代码变得保守是不可避免的事情。你可能很会拒绝别人的需求，但是很多人提的都是合法的需求。所以，你不得不把你的一个工具变成平台。

使用机器人
就像很多工作别人可以帮你做一样，也有很多工作不需要人来做。机器人是你的朋友，用他们让你的维护者生活变得更容易。
引进测试和别的检查来改善你的代码质量
让你项目自动化的最重要的方法之一就是引进测试。
测试能够帮助贡献者自信他们没有弄坏什么。测试也让你复查代码和接受别人的贡献的过程更加容易。你反应的越多，社区参与的就越多。
设置自动化的测试让所有新来的贡献者都可用，而且保证你的测试可以很容易在贡献者的本地运行。保证所有的代码贡献者在提交之前都运行你的测试。你还得为所有的提交设置一个基本的标准。
如果你添加了测试，确保在文件里面解释他们是怎么工作的。

我相信测试对所有的代码都是需要的。如果代码被完整的覆盖了测试，以后就不需要改了。我们只需要在代码崩溃或者需要某个功能的添加代码。不管你在修改什么，测试对于检查那些你可能不小心制造的问题都是必须的。
—  “’  ”

用工具来自动化日常的维护工作
对于维护一个流行的项目来说，一个好消息是别的维护者也可能遇到过类似的问题而且已经找到一个解决方案。
这里有各种各样的工具帮你自动化一部分的维护工作。一些例子：

 自动化版本发布

 可能的贡献者来帮你复查代码

 帮你自动复查代码


对于报告和其他常见形式的贡献，有      你可以用来降低沟通成本。你也可以设置邮件过滤来管你你的邮件提醒。
如果你想逼格更高，代码风格指南和能让你项目收到的贡献更规范，而且更同意复查和接受。
当然啦，如果你的标准太复杂了，反倒会增加了贡献的难度。所以保证你只添加一个让每个人工作起来更容易的规则。
如果你不确定用什么工具，看一看别的流行项目是怎么做的，特别是和你在一个生态系统的。比如，其他的模块的贡献流程是怎么样的？用想死的工具和方法会让你项目的贡献流程对贡献者更熟悉。
不干了也没关系
开源项目曾经让你开心，但可能现在开始让你不开心了。
可能当你想到你的项目的时候感觉到亚历山大。而同时，和又纷至沓来。
疲倦在开源工作工作中是一个常见的问题，特别是在维护者中间。作为一个维护者，你做的开心对项目的生存来说是一个没有商量余地的条件。
虽然你不需要跟谁请假，但是也不腰拖到自己疲倦不堪的时候才去度假。，一个的核心开发者，决定在年的义务劳动之后休一个月的假
就像其他工作一样，有规律的休息会让你对工作保持舒适愉快的心情。

我发现最好的平衡点就是每周在日常的工作安排中花小时在这上面。这会让我从感觉太累到保持持续的激情。因为我给我需要解决的表上了优先级，从而我能够在我认为重要的事情上有所进展。
—  “  ’         ”

我是的维护者，我发现我需要首先让自己开心，在开源项目和其他事情之间设定清楚的界有时候，当你感觉大家都离不开你的时候请假去休息是一件很难的事情。甚至人们会让你因为离开而感到愧疚。
在你离开项目的时候尽可能的在用户和社区中间寻求支持，如果你找到支持你的人，还是休息吧。在你不工作的时候还是要保持和别人交流，这样人们不会因为你的失联感到奇怪。
休息并不只是独家。如果你周末不想做开源项目的工作了，或者在本该工作的时候不想干活了，和别人说，这样他们才知道这个时候不该打扰你。
首先照顾好自己！
维护一个大型项目需要和在项目开始成长时不同的技能。作为一个维护者，你会将自己的领导力和个人能力提示一个层次，而这是很少人能体会到的。但是与此同时，管理项目，设定清晰的界限，制作你感到舒服的事情会让你保持开心，活力，高产的状态。最近在做  版本升级时    发现了  疑似“内存泄露”现象，但通过  等工具检测后，并没发现类似的问题。因此，需要深入学习  的虚拟内存管理方面的内容来解释这个现象。
 的虚拟内存管理有几个关键概念：

每个进程有独立的虚拟地址空间，进程访问的虚拟地址并不是真正的物理地址

虚拟地址可通过每个进程上页表与物理地址进行映射，获得真正物理地址

如果虚拟地址对应物理地址不在物理内存中，则产生缺页中断，真正分配物理地址，同时更新进程的页表；如果此时物理内存已耗尽，则根据内存替换算法淘汰部分页面至物理磁盘中。


基于以上认识，这篇文章通过本人以前对虚拟内存管理的疑惑由浅入深整理了以下十个问题，并通过例子和系统命令尝试进行解答。

 虚拟地址空间如何分布？  位和  位有何不同？

 是如何分配内存的？

 分配多大的内存，就占用多大的物理内存空间吗？

如何查看进程虚拟地址空间的使用情况？

 的内存真的释放了吗还给   

程序代码中  的内存都有相应的  ，就不会出现内存泄露了吗？

既然堆内内存不能直接释放，为什么不全部使用  来分配？

如何查看进程的缺页中断信息？

如何查看堆内内存的碎片情况？

除了  的  ，还有其他第三方实现吗？


一 虚拟地址空间如何分布？  位和  位有何不同？
 使用虚拟地址空间，大大增加了进程的寻址空间，由低地址到高地址分别为：

只读段：该部分空间只能读，不可写，包括代码段、  段  常量字符串和  定义的常量

数据段：保存全局变量、静态变量的空间

堆 ：就是平时所说的动态内存，  大部分都来源于此。其中堆顶的位置可通过函数  和  进行动态调整。

文件映射区域 ：如动态库、共享内存等映射物理空间的内存，一般是  函数所分配的虚拟地址空间。

栈：用于维护函数调用的上下文空间，一般为  ，可通过  – 查看。

内核虚拟空间：用户代码不可见的内存区域，由内核管理。 


下图是  位系统典型的虚拟地址空间分布来自《深入理解计算机系统》。

 位系统有  的地址空间，其中 是用户空间，  是内核空间，包括内核代码和数据、与进程相关的数据结构如页表、内核栈等。另外，  执行栈顶，往低地址方向变化；  函数控制堆顶往高地址方向变化。
可通过以下代码验证进程的地址空间分布，其中  函数用于返回栈顶指针。 
 
 
 
 
   _ = 
  __  = {}
    
{
         _ = 
         _ = 
            \ 
          _ \ _
          __   \ __ __
            \ _
            \ 
        _ =     
          _  \ _
              \ 
        _
        _ = 
              \ 
         
}
 位系统的结果如下，与上图的划分保持一致，并且栈顶指针在  和  一个  的存储空间时都发生了变化增大和缩小。 
    
  _ 
  __   
    
    
  _  
      
      
但是，  位系统结果怎样呢？  位系统是否拥有  的地址空间吗？
 位系统运行结果如下： 
    
  _ 
  __   
    
    
  _  
      
      
从结果知，与上图的分布并不一致。而事实上，  位系统的虚拟地址空间划分发生了改变：

地址空间大小不是  ，也不是  ，而一般是  。因为并不需要  这么大的寻址空间，过大空间只会导致资源的浪费。  位  一般使用  位来表示虚拟地址空间，  位表示物理地址，这可通过  来查看
          

其中， 表示用户空间， 表示内核空间，共提供  的寻址空间。这两个区间的特点是，第  位与  位相同，若这些位为  表示用户空间，否则表示内核空间。

用户空间由低地址到高地址仍然是只读段、数据段、堆、文件映射区域和栈 


二 是如何分配内存的？
 是  中内存分配函数，也是最常用的动态内存分配函数，其内存必须通过  进行释放，否则导致内存泄露。
关于  获得虚存空间的实现，与  的版本有关，但大体逻辑是：

若分配内存小于  ，调用  ，将堆顶指针向高地址移动，获得新的虚存空间。

若分配内存大于  ，调用  ，在文件映射区域中分配匿名虚存空间。

这里讨论的是简单情况，如果涉及并发可能会复杂一些，不过先不讨论。


其中  就是修改栈顶指针位置，而  可用于生成文件的映射以及匿名页面的内存，这里指的是匿名页面。
而这个  ，是  的默认配置，可通过函数  来设置，可通过以下例子说明。
 
 
 
 
 
 
 _
              _
              _
        _     __


{
            \
    _ __ _ 

}
    
{
         _ _ _ 
         _ _ _ 
         __
            \ 
        _ = 
        __ _ 
        _ = 
        __ _ 
        _ = 
        __ _ 
        \
        __ = 
        ___ __ 
        
        _ = 
        __ _ 
          __  
        __ 
         __  \
        _ = 
        __ _ 
        _ = 
        __ _ 
         
}
这个例子很简单，通过  申请多个不同大小的动态内存，同时通过接口 _ 打印变量大小和地址等相关信息，其中  可返回堆顶指针位置。另外，粗体部分是将  分配的临界点由  转为  ，再打印变量地址的不同。
下面是   位机器的执行结果后文所有例子都是通过  位机器上的测试结果。 
    
  _       
  _       
  _       
  __       
  _       
 __  
  _       
  _       
三 分配多大的内存，就占用多大的物理内存空间吗？
我们知道，  分配的的内存是虚拟地址空间，而虚拟地址空间和物理地址空间使用进程页表进行映射，那么分配了空间就是占用物理内存空间了吗？
首先，进程使用多少内存可通过   命令 查看，其中关键的两信息第五、六列为：

 ，    ，表示进程总共使用的虚拟地址空间大小，包括进程地址空间的代码段、数据段、堆、文件映射区域、栈、内核空间等所有虚拟地址使用的总和，单位是 

 ，    ，表示进程实际使用的物理内存空间，  总小于  。


可通过一个例子说明这个问题： 
 
 
 
 
 
 
 _
 _
              _
              _
        _     __


{
                 \
                 _ __ _ 
        _
}

    
{
         __ __ __ __
        _ 
         = 
        _   |   |    
        __ = 
        ___ __ 
        __ = 
        __  
        ___ __ 
        __ = 
        __  
        ___ __ 
        __ = 
        __  
        ___ __ 
         
}
该代码扩展了上一个例子_能力，处理打印变量信息，同时通过   命令获得当前进程的  和  值。并且程序  一块内存后，会  内存的若干  内容。
执行结果为 
  __       

                          _

  __       

                          _

  __       

                          _

  __       

                          _
由以上结果知：

 并不是每次  后都增长，是与上一节说的堆顶没发生变化有关，因为可重用堆顶内剩余的空间，这样的  是很轻量快速的。

但如果  发生变化，基本与分配内存量相当，因为  是计算虚拟地址空间总大小。

 的增量很少，是因为  分配的内存并不就马上分配实际存储空间，只有第一次使用，如第一次  后才会分配。

由于每个物理内存页面大小是  ，不管  其中的  还是  、  ，实际占用物理内存总是  的倍数。所以  的增量总是  的倍数。

因此，不是  后就马上占用实际内存，而是第一次使用时发现虚存对应的物理页面未分配，产生缺页中断，才真正分配物理页面，同时更新进程页面的映射关系。这也是  虚拟内存管理的核心概念之一。 


四 如何查看进程虚拟地址空间的使用情况？
进程地址空间被分为了代码段、数据段、堆、文件映射区域、栈等区域，那怎么查询这些虚拟地址空间的使用情况呢？
 提供了  命令来查看这些信息，通常使用    高版本可提供   查询，如下所示： 
 ___   

 _

                     

                       __

                      __

                      

                     

                    

                       

                       

                       

                  

                    

                    

                       

                  

                    

                    

             
从这个结果可以看到进程虚拟地址空间的使用情况，包括起始地址、大小、实际使用内存、脏页大小、权限、偏移、设备和映射文件等。  命令就是基于下面两文件内容进行解析的：
   

  
并且对于上述每个内存块区间，内核会使用一个 __ 结构来维护，同时通过页面建立与物理内存的映射关系，如下图所示。 


相关推荐下一篇 十问  虚拟内存管理  二 性能监控—— 常用操作及命令导语：感谢阅读腾讯 微信号第篇文章。在昨日举办的腾讯全球合作伙伴大会上，腾讯 披露了发展布局的最新动态。本文整理了四个重磅演讲的干货内容，包括腾讯的发展路线图、游戏研究的挑战与应对、多媒体从图片到视频的演进，及惊艳全场的同声传译产品，以飨读者。完整文章可到官网阅读。

一、腾讯路线图：共享是大势所趋

《共享：让无处不在》演讲人：腾讯 主任 张潼博士
张潼博士的演讲勾勒了行业未来发展的路线图：共享的三大关键元素：企业共享研究应用成果、行业共享发展平台，到学界共享新思路的「共享时代」。

「在设定 作为企业级实验室的愿景时，我们希望能代表腾讯打造世界级的能力，让科技以创新的方式去解决人类所面临的困难与挑战，未来能让无处不在  。」张博表示，腾讯的发展路线图，将围绕企业、行业到学界的共享共联展开。
第一是企业内外部共享研究应用成果，缩短技术迭代时间，小步快跑构建核心技术竞争力。
在研究上，腾讯 自成立一年来，本着「学术有影响，工业有产出」的发展目标，在计算机视觉领域的、自然语言处理领域、机器学习领域的和等衡量机构研究能力的多个顶级学术会议中，被收录论文多篇，位居国内企业前列；此外还在人脸识别检测 、前沿的图片描述生成数据集微软 中排名第一。
在应用上，除了技术已落地到微信、、音乐和视频平台，还围绕游戏、内容和社交等核心业务有的放矢进行技术突破，通过技术提升用户的游戏体验，内容中文字、图像和视频的理解、生成与推荐，及社交中的终端硬件与全新交互方式等。

第二是行业共享大生态，赋能中小从业者和传统产业。
一方面是针对中小从业者与合作伙伴，共享基础能力，如通过腾讯开放平台，将算法、数据到模型等基础能力开放，并为从业者提供方便易用的以和为主的服务解决方案。
另一方面针对传统行业，通过对「行业」计划与创业者的扶植开放腾讯能力，推动在更多垂直领域台落地。比如腾讯发布的首款医学影像产品「腾讯觅影」，使用 技术发现早期食管癌的准确率已高达；而此次论坛发布的「生态计划」将从场景、技术、人才、资本四个方面全面扶植创业者，与合作伙伴共建共享行业生态。

第三是学界共享新思路，将工业界资源、经验反向输入到人才「造血库」。
我们宣布启动全球博士生奖学金计划，前者会授予入选博士生丰厚的奖学金，到 实地研究，接触真实需求和数据的机会，与学界联合培养领域的顶级人才。
此外每年一届的学术论坛也打造为吸引国外顶级学者到华学术研究交流的顶级平台。
二、游戏：赋能现实世界，研究的奥义远不止于游戏

《游戏：虚拟世界对物理世界的赋能》演讲人：腾讯 机器学习中心负责人 刘晗博士

我们最想强调的，是游戏研究的奥义——远不止于游戏本身。这是一个富有挑战而令人振奋的研究课题，研究当中累积的经验、方法与结论，能在更广大深远的范围被利用。首先是打通虚拟与现实世界的藩篱，从而赋能物理世界，比如无人车和机器人的发展；其次，游戏中对话智能的研究，或能成为通向强人工智能的重要路径；第三，研究游戏中人、智能体和环境的交互，能让智慧城市这样复杂而意义深远的项目受益。
游戏是人工智能与博弈论的一个交叉领域。从小的方面来说，游戏研究如何用人工智能技术来提升人类玩游戏的体验。从大的方面来说，游戏研究人，智能体，以及环境之间的复杂交互关系。 游戏驱动了人工智能的发展，从国际象棋到围棋击败人类顶尖高手，而目前所挑战的游戏已从棋盘类转向《星际争霸》  和《 》    等游戏。

游戏涉及到三个核心能力：对外界环境的感知，根据状态做出的决策，人与智能体之间的对话。比如在围棋的游戏场景，可以通过感知棋盘的全局表达状态决定在哪里落子。而现实中的无人车，同样可以通过视觉，激光雷达的感知对方向盘，刹车等动作做出决策。

理解了游戏的三个核心能力。接下来我解释研究中三个核心挑战，及腾讯的解决方案。
第一个挑战是游戏的状态空间过大。比如很多战略型游戏的状态空间是无穷维，远大于围棋空间。腾讯提出了一套整合了模型，算法，与计算体系结构的解决方案，叫做腾讯机器大脑，整个系统的核心是使用深度神经网络来建模超大规模的状态空间。
第二个挑战是许多复杂的多玩家游戏需要多个智能体协调操作，目前这方面理论比较缺乏。为设计出一个完善的多智能体，一个核心问题是将强化学习的价值网络与描述宏观战略的行为树进行互操作，并使其融合。
第三个挑战是绝大部分游戏是用模拟器在一个理想化的虚拟世界中开发。如何打通虚拟与现实，又是一个核心挑战。我们的解决方案结合反向强化学习及动态探索机制，对游戏中的参数进行贝叶斯升级。这样得到的系统能保证在现实世界花最小的成本，就能成功部署。

这一套感知、对话与决策模块，形成了一套通用系统，未来有望在现实中被应用到更多场景中，这就是我们说的虚拟对现实的赋能。
多媒体：从图片到视频的深度内容探索

《多媒体：睁开机器之眼》演讲人：腾讯 计算机视觉中心负责人 刘威博士

我们正在进入一个「多媒体内容消费」的时代，每个中国人每天都在消费大量的多媒体内容，也在提供大量的多媒体数据。在领域，多媒体将赋予计算机处理、识别、理解内容的综合能力。从图像到多媒体，数据维度大大提升，我们希望走出一条自主的创新之路，因此发展了三个基础能力：处理、识别、理解。

我们的目标是要打造最好的多媒体技术，通过建立一个有效的技术矩阵，涵盖产生、处理、识别、理解、分发等多种基础能力，应用上从视频制作到视频推荐覆盖完整的视频产业链。
数字化内容是腾讯的战略之一，内容是腾讯 四大应用方向之一，而多媒体则首当其冲。我们的愿景，是在全球范围内做内容的引领者、实践者和贡献者。

我们也取得了一些科研成果。比如在  ，译为光学字符识别任务中取得六个第一，其中三项是针对网络图片文本，另外三项是针对聚焦场景文本。我们把算法识别精度提高到了以上，这是巨大的升级。

第二个是视频人脸检测和识别。需要克服视频中人脸的低分辨率、姿态、遮挡、表情、妆容、光照等挑战。我们在这方面也取得了比较好的结果。

还有图像描述生成技术。我们对整个深度学习架构包括卷积神经网、长短时记忆网、多阶段注意力进行端对端的训练，实现图像到文本的有机过渡，得到一个很好的模型。这项技术目前在最权威的 数据集上排名第一。
基于这项技术，机器可在人们上传图片到空间后知道图片在说什么；进行图像搜索、图像推荐和图像文本间的对话；帮助视障人群看到图像世界。
翻译：同声传译亮相惊艳全场

《翻译：重建巴别塔》演讲人：腾讯 机器翻译平台侧负责人 杨月奎

准确、自然而流畅的同声传译产品惊艳全场
时至今日，翻译已成为具有千亿规模的巨大市场。一方面，人工翻译价格高昂、供给不足，机器翻译的水平则在日益提升带来了更低的成本和更高的效率；另一方面，机器翻译的研究牵涉到自然语言的分析、转换与生成，可作为的重要研发平台，也是人工智能的里程碑式目标。

年，随着神经网络机器翻译的出现，错误率大幅下降，各互联网巨头也陆续推出了自己的机器翻译平台。可惜也未提供完美的解决方案，面临众多挑战。首先是译文忠实度问题，存在译文丢失或跑飞的可能。其次是对低频词的训练难度更大，一些实体词很可能翻译不出来；最后是对训练数据的规模，也有着更高的要求。
针对面临的这些挑战，我们也相对应地做了一些优化工作。为了提高译文忠实度，我们使用交互式的模型来增强机制，利用重构模型加强翻译完整性的学习，利用模型选取更优的译文；为了加强对低频词的训练，我们引入子词模型；为了提升训练效率，我们采取并行训练框架，支持多机多卡并行训练。除此之外，我们也加入了深层网络、残差网络和模型融合等技术。
目前我们已支持中文、英语、粤语、日语、韩语、法语、德语、西班牙、越南语等多种语言。

有了这样的机器翻译技术，我们也在公司内外积极谋求应用落地，包括结合语音识别技术的同声传译、结合图像识别技术的拍照翻译、结合人机交互能力的辅助翻译等。一方面应用于公司内部的微信、手机和微云等产品，另一方面开放能力，赋能更多合作伙伴。

这些能力我们都已经在腾讯开放平台上推出了，而在出境游、商务会议、跨国交流等场景上我们期待能有更广泛应用。

原文来自：腾讯实验室 公众号导语：工作也有几多年了，无论是身边遇到的还是耳间听闻的，多多少少也积攒了自己的一些经验和思考，当然，我并没有接触太多高大上的分布式架构实践，所以总结的经验相对比较零碎，欢迎大家随时补充。

俗话说得好，冰冻三尺非一日之寒，滴水穿石非一日之功，罗马也不是一天就建成的，对于开发人员来说，一个好的架构并不是一蹴而就的。
初始搭建
最开始，就是各种框架一搭，然后扔到  容器中跑，这时候我们的文件、数据库、应用都在一个服务器上。

服务分离
随着系统的上线，用户量也会逐步上升，很快一台服务器已经满足不了系统的负载，这时我们就要在服务器还没有超载时，提前做好准备。
由于我们是单体架构，优化架构在短时间内是不现实的，增加机器是一个不错的选择。这时，我们可能要把应用和数据库服务单独部署，如果有条件也可以把文件服务器单独部署。

反向代理

为了提升服务处理能力，我们在  容器前加一个代理服务器，一般使用 ，当然你如果更熟悉  也未尝不可。
用户的请求发送给反向代理，然后反向代理把请求转发到后端的服务器。
从严格意义上说， 是属于  服务器，一般处理静态 、、 请求；而  属于  容器，专门处理  请求，当然  也是支持  的，只是效果没  好而已。
反向代理的优势，如下所示：

隐藏真实后端服务。
负载均衡集群。
高可用集群。
缓存静态内容实现动静分离。
安全限流。
静态文件压缩。
解决多个服务跨域问题。
合并静态请求后已经被弱化。
防火墙。
 以及 。

动静分离

基于以上  反向代理，我们还可以实现动静分离，静态请求如 、、 等请求交给  处理，动态请求分发给后端  处理。
 升级到  可以开启  时代，加速网站访问。当然，如果公司不差钱， 也是一个不错的选择。
服务拆分
在这分布式微服务已经普遍流行的年代，我们没必要踩过多的坑，就很容易进行拆分。
市面上已经有相对比较成熟的技术，比如阿里开源的 官方明确表示已经开始维护了， 家族的  ，当然具体如何去实施，无论是技术还是业务方面都要有很好的把控。
 

 

服务发现—— 
客服端负载均衡—— 
断路器—— 
服务网关—— 
分布式配置——  

 微服务与轻量级通信

同步通信和异步通信
远程调用 

消息队列

持续集成部署
服务拆分以后，随之而来的就是持续集成部署，你可能会用到以下工具：、、、。
基本拓扑结构如下所示：

整个持续集成平台的架构演进，如下图所示：

服务集群
 集群主要分成三大类：

高可用集群。
负载均衡集群。
科学计算集群。

我们最常见的也是生产中最常接触到的就是负载均衡集群。

 负载均衡实现
负载均衡实现的三种方法：

 负载均衡，一般域名注册商的  服务器不支持，但我用的阿里云解析已经支持。
四层负载均衡、，工作在  协议下。
七层负载均衡、，工作在  协议下。

 分布式 
大家都知道，服务一般分为有状态和无状态，而分布式  就是针对有状态的服务。
分布式  的几种实现方式：

基于数据库的  共享。
基于   容器本身的  复制机制。
基于  进行  共享。
基于  进行  共享。

分布式  的几种管理方式：

  方式管理 即  复制。简介：将一台机器上的  数据广播复制到集群中其余机器上。使用场景：机器较少，网络流量较小。优点：实现简单、配置较少、当网络中有机器  掉时不影响用户访问。缺点：广播式复制到其余机器有一定延时，带来一定网络开销。
   方式管理。简介：即粘性 、当用户访问集群中某台机器后，强制指定后续所有请求均落到此机器上。使用场景：机器数适中、对稳定性要求不是非常苛刻。优点：实现简单、配置方便、没有额外网络开销。缺点：网络中有机器  掉时，用户  会丢失、容易造成单点故障。
缓存集中式管理。简介：将  存入分布式缓存集群中的某台机器上，当用户访问不同节点时先从缓存中拿  信息。使用场景：集群中机器数多、网络环境复杂。优点：可靠性好。缺点：实现复杂，稳定性依赖于缓存的稳定性、 信息放入缓存时要有合理的策略写入。

目前生产中使用到的：

基于  配置实现的   缓存管理  实现麻烦。
基于   和  组播的方式实现网络影响。
基于  的方式实现最适合。

 负载均衡策略
负载均衡策略的优劣及其实现的难易程度有两个关键因素：负载均衡算法，对网络系统状况的检测方式和能力。
 轮询调度算法
顾名思义，轮询分发请求。优点是实现简单，缺点是不考虑每台服务器的处理能力。
 加权调度算法
我们给每个服务器设置权值 ，负载均衡调度器根据权值调度服务器，服务器被调用的次数跟权值成正比。优点是考虑了服务器处理能力的不同。
 原地址散列
提取用户 ，根据散列函数得出一个 ，再根据静态映射表，查出对应的 ，即目标服务器 。一单目标机器超负荷，则返回空。
 目标地址散列
同上，只是现在提取的是目标地址的  来做哈希。优点是以上两种算法都能实现同一个用户访问同一个服务器。
 最少连接
优先把请求转发给连接数少的服务器。优点是使得集群中各个服务器的负载更加均匀。
 加权最少连接
在  的基础上，为每台服务器加上权值。算法为：活动连接数非活动连接数÷权重 ，计算出来的值小的服务器优先被选择。优点是可以根据服务器的能力分配请求。
 最短期望延迟
 跟  类似，区别是不考虑非活动连接数。算法为：活动连接数÷权重，同样计算出来的值小的服务器优先被选择。
 永不排队
改进的  算法，我们想一下什么情况下才能“永不排队”，那就是服务器的连接数为  的时候，那么假如有服务器连接数为 ，均衡器直接把请求转发给它，无需经过  的计算。
 基于局部性的最少连接
均衡器根据请求的目的  地址，找出该  地址最近被使用的服务器，把请求转发之，若该服务器超载，则采用最少连接数算法。
 带复制的基于局部性的最少连接
均衡器根据请求的目的  地址，找出该  地址最近使用的“服务器组”，注意，这里不是具体某个服务器，然后采用最少连接数算法，从该组中挑出具体的某台服务器出来，把请求转发之。
若该服务器超载，那么根据最少连接数算法，从在集群的非本服务器组的服务器中，找出一台服务器出来，加入本服务器组，然后把请求转发之。
读写分离
 主从配置，读写分离并引入中间件，开源的 ，阿里的  都是不错的选择。
如果是对高可用要求比较高，但是又没有相应的技术保障，建议使用阿里云的  或者  相关数据库，省事省力又省钱。
全文检索
如果有搜索业务需求，引入  或者  也是一个不错的选择，不要什么都塞进关系型数据库。
缓存优化
引入缓存无非是为了减轻后端数据库服务的压力，防止其罢工。
常见的缓存服务有：、、、，它们都是主流经得起考验的缓存技术实现，特别是  已大规模运用于分布式集群服务中，并证明了自己优越的性能。
消息队列
异步通知：比如短信验证，邮件验证这些非实时反馈性的逻辑操作。

流量削锋：应该是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。
日志处理：系统中的日志是必不可少的，但是如何去处理高并发下的日志却是一个技术活，一不小心可能会压垮整个服务。
工作中我们常用到的开源日志 ，为嘛中间会加一个  或者  就是这么一个道理一群人涌入和排队进的区别。
消息通讯：点对点通信个人对个人或发布订阅模式聊天室。
日志服务
消息队列中提到的  开源日志组件对于中小型创业公司是一个不错的选择。

安全优化
以上种种，没有安全做保证，一切都会归于零：

阿里云的  虚拟专有网络以及安全组配置。
自建机房的话，要自行配置防火墙安全策略。
相关服务访问，比如 、、 等如果没有特殊需求尽量使用内网访问并设置鉴权。
尽量使用代理服务器，不要对外开放过多的端口。
 配合  也是个不错的选择。

架构师必备词汇
 高可用

负载均衡负载均衡算法
反向代理
服务隔离
服务限流
服务降级自动优雅降级
失效转移
超时重试代理超时、容器超时、前端超时、中间件超时、数据库超时、超时
回滚机制上线回滚、数据库版本回滚、事务回滚
 高并发

应用缓存
 缓存
多级缓存
分布式缓存
连接池
异步并发

 分布式事务

二阶段提交强一致
三阶段提交强一致
消息中间件最终一致性，推荐阿里的 。


 队列

任务队列
消息队列
请求队列



扩容
单体垂直扩容
单体水平扩容
应用拆分
数据库拆分
数据库分库分表
数据异构
分布式任务

 网络安全

 注入
 攻击
 攻击
拒绝服务，　　攻击

架构师必备工具
 操作系统
必备、某软的
 负载均衡
、、、、、、负载均衡
 分布式框架
、、
 数据库中间件
 、、 、 不维护了
 消息队列
、、、、
 注册中心
、
 缓存
、、、
 集成部署
、、、
 存储
、、、
 数据库
、、、、、
 网络
专用网络 、弹性公网 、
作者：张志朋简介：资深  爱好者，深耕于在线教育领域。来源：技术栈微信公众号 \ 自上次发表了 ：初次使用及前端构建经验 后，前端同学  对笔者说， 不太好用，现在我们项目中已经不用了，现在用 。什么？那你赶紧给笔者我介绍一下。 抠着鼻屎对我说，你去看我的笔记就好啦！好吧，看完后，笔者又整理了一篇关于我们在项目中，使用  的前端文章分享给大家。

 初试用
在用了  的一段时间内，越来越觉得自己离不开构建工具。但是， 的构建速度让我有点苦恼，即使是编译  也需要花上一段时间。于是，我开始试用 ，结果意外地让我惊喜。
下面代码是使用  初次来编译 ，由于一直都有点习惯了  那编译速度单位为秒级别的速度，刚输入命令还没反应过来，就已经以毫秒级的速度编译完了。
  = 
  = 
  = 

  编译
  {
   
    
    { } 
    
    
}
比较一下  与  编译同一套  代码下所花费的时间：

并不是说  就比  不好，也有  办不到  办得到的事情。但是就运行速度相比， 的速度确实是完胜。
 打包 
目前我的项目是一个页面一个  入口，比如登录页面的入口是 ，而主页面的入口是 ，它们都是在同一个目录下。
├─ 
    ├─ 
        ├─ 
            ├─ 
            └─ 
        ├─ 
            ├─ 
            └─ 
        └─ 
├─ 
└─ 
 每个页面的引入是这样子的：
 = =____
 = =____ =____

 的  文件如下：
  = {
   {
     
     
  }
}
接下来就是使用  对  文件进行打包，用到的是「」，由于项目是多入口文件，所以需要批量打包，打包的代码如下：
  = 
  = 

   {
   
    {
       
       
        
      
    }
    
}
运行相应命令，即可完成打包：
  
 自动刷新浏览器
项目本地后端开发语言是是基于  的 ，域名为 。刚开始想实现浏览器  自动刷新使用到的是  和  插件， 也有对应的方法，参考  教程之 。但是，它需要浏览器安装  插件才能使用， 的插件需要翻墙下载， 的插件不起作用，其它的浏览器也无法实现自动刷新。
后来，我发现了 。简直就像是找到了宝藏一样，同样支持  和 。以下代码是使用代理去实现：
  = 
  = 

   {
    {
         
    }

     
}
运行命令，默认的浏览器会自动打开  链接
 
如果想多个浏览器都可以自动刷新，只需要打开其它浏览器，把刚刚的链接输入即可。还有，由于项目原因，开发的时候不能使用到  ，想换成  配置的域名怎么做？直接把  链接换成  即可， 实际就是监听  端口来实现刷新浏览器。
基于  的前端构建
之前使用  时总结了一篇「基于  的前端构建」。在使用了  的一段时间后，我发现了  的运行速度比  快很多，于是便从  转移阵地到了 。以下的构建思路跟  的构建很类似。如果你也使用过 ，那我相信你一定能够很快地切换到 。当然如果你没有接触过 ，我相信你一定也能够很快上手 。
目录结构
├─                     配置目录
    ├─                任务配置目录
        ├─         图片配置
        ├─         其它配置
        ├─        脚本配置
        ├─         样式配置
        └─          页面配置
    └─                配置文件
├─                     开发目录
    ├─                存放  的目录
        ├─             可提取复用的页面模块
        └─            各页面入口文件
    ├─              存放图片的目录
        ├─          不需要合并的图片
        └─          需要合并的图片
    ├─                  存放  的目录
        ├─             可提取复用的脚步模块
        ├─             第三方  库
        ├─            各页面入口脚本文件
        └─         的配置文件
    └─                存放  的目录
        ├─             可提取复用的样式模块
        └─            各页面入口样式文件
├─                 参数配置文件
├─               入口配置文件
└─              包管理文件
 目录
参考： 前端 | 重构 。其中专门创建一个  目录用来存放  代码，为了能够将任务更加细化，职责单一，方便日后的维护更新。
└─                     配置目录
    ├─                任务配置目录
        ├─         图片配置
        ├─         其它配置
        ├─        脚本配置
        ├─         样式配置
        └─          页面配置
    └─                配置文件
命令
             说明帮助              本地编译            语法检测           包含依赖编译              开发监控，浏览器不自动刷新            开发监控，浏览器自动刷新            打包上线开发阶段
执行   命令， 会进行一系列构建操作，最后在  目录下生成可运行文件，并实时监听源文件，一旦源文件改动会执行相应的操作。
 开发监控，浏览器不自动刷新
  {
    
        
        
            
        
        
    
}
执行   命令， 会执行跟   一样的操作并监听源文件，唯一不同的是它在执行后会监听某个端口，一旦有文件改动它会帮你自动刷新浏览器，帮你省下了按  的力气。当然在同时开上多个浏览器测试页面时它将会很有帮助。
 开发监控，浏览器自动刷新
  {
    
        
        
            
        
        
    
}
上线打包阶段
参考：张云龙的  大公司里怎样开发和部署前端代码？。通过以下代码一个大体知道，上线打包主要是对图片样式脚本进行打包处理。所以接下来的工作就是职责分工，独立完成各自的构建工作。
  {
    
        
        
        
        
        
        
        
        
    
}
第一个步骤主要是对图片进行处理，包括图片合并压缩  戳等。其中对  代码处理是为了替换合并后的图片路径。
 打包图片
  {
    
        
        
        
        
        
        
    
}
第二个步骤主要是对  文件进行处理，其中还包括替换已经  的图片资源，并生成  戳。
 打包  文件
  {
    
        
        
        
        
    
}
第三个步骤是  文件的打包，打包  代码可以根据依赖进行  文件的合并压缩，最终每个页面都打包一个  文件为单入口。
 打包  文件
  {
    
        
        
        
        
        
    
}
第四个步骤是  文件的打包，替换掉前面已经  的静态资源即可。
 打包  文件
  {
    
        
        
        
    
}
最终生成的代码依然在  目录下，也就是说在开发阶段与上线打包阶段构建生成的代码都在同一个目录下，只不过在开发阶段代码是未进行合并压缩，上线打包阶段代码是经过合并压缩打上  戳的。所以建议该目录下的代码不需要添加到版本控制中。
未解决的问题
开发阶段：对  的路径配置 与  中的配置感到困惑迷糊，多创建一个目录就路径不匹配打包不成功。
上线打包阶段： 若添加第三方库，需要手动修改  代码。摘要：
众所周知，“光棍节”是西方文化席卷中国后的产物。现如今，“光棍节”华丽地演绎了屌丝大逆袭，成为家喻户晓的购物狂欢节。面对巨大的购买流量，电商企业如何应对支付洪峰？稳健的架构、优异的性能、独到的热点更新技术，不仅可让核心交易系统数据库从容面对秒杀及巨量订单交易等场景，而且可有效降低成本。

分布式数据库，腾讯内部代号””，是解决类似于电商、的订单交易、购买支付场景的利器。
为什么说最适用于电商、等业务呢？众所周知，电商等互联网模式和碎片化的行为，无异给核心交易数据库带来巨大的挑战。即使是某些银行高大上的业务系统，其平均约在，常规峰值约倍；而在互联网场景中，任何智能设备都是交易终端，加上电商等经常出现限时抢购、秒杀等运营活动，无论哪种活动，从数据库角度就都意味着短时间并发和请求总量都远高于正常水平。在类似“双十一”这样的购物狂欢节中，电商系统若不做好措施，结果就是花钱推广，反而砸掉自己招牌。通过总结，互联网场景的交易系统数据库可能经常遭遇以下情况：
峰值超过正常值数倍的业务请求。秒杀等场景将带来大量的线程影响性能。故障是常态，如何确保故障数据不错不丢，且不影响全局。性价比是业务重要考量点。
峰值超过正常值倍以上的请求洪峰：以腾讯米大师为例，系统对接了腾讯内外十余万业务的支付交易。这些业务会不定期发布营销运营活动，如电商大促、春节红包、国庆献礼、游戏推广等。在全年出现了多次均值倍的请求洪峰， 有次甚至超倍。下图为近期某业务做午间大促，导致整个平台请求量猛增倍蓝线是上一日对比数据，红线是当日数据。

类似问题也是电商等业务常见场景，而米大师的经验是，除了通过架构将支付系统按场景、业务、流量进行解耦，利用云的弹性和云的冗余资源池，在活动时快速自动的部署业务服务器。并区分业务单元域部署，前置调度，做分流和异常隔离和缓存外，采用支持水平拆分的分布式架构的数据库。
因为数据库本身无法像逻辑层一样做隔离请求，而将几张大表水平拆分分表。能够让数据库可以随时横向扩展，因此平时只需要在性能方面预留一定冗余，确保偶发性小峰值并不影响整个数据库性能。如果遇到可预见的超高峰值，例如年度大促、春节活动等，由业务部门决定是否进行水平扩容。当然，分布式数据库的原来使得水平扩容十分简单，而且通过自动再均衡方案，扩容可以仅影响集群中的少数节点，而其他节点可以在扩容时仍然正常运行不会受到影响。热点更新技术，从容应对秒杀等场景： “秒杀”场景下，大量的用户在极短的时间内请求少量商品。在数据库中，一个商品是一行存储，所以秒杀会导致大量的线程来竞争行锁，当并发度越高时等待的线程也会越多，导致下降上升。这会导致什么问题呢？要么秒杀时，抢购一个商品但整个平台出故障；要么就出现个库存卖出去个等各类异常。当然，业内也有一些从数据库层面的解决方案，例如：把热点商品放到单独的热点库中；通过缓存系统如消息队列等缓存热点请求；或让业务层将修改的多条合并减少。而的热点更新功能，是通过一个全局表存储有请求的热点对象，制定热点请求过来时，先查找表中有无对应的热点对象，有就获取，会被阻塞；没有该热点对象，那么创建该热点对象的方式进行。这种方案通过简单扩展语法和参数，使得业务不改变架构，仅需修改几行的情况下，便可以快速应对秒杀等场景原理如下图。当然，配合缓存使用，可以进一步为业务提高性能，减少击穿的概率
根据测试，我们发现应用和不应用的热点更新技术会的效果差异非常明显测试数据如下图。

故障是常态，重要的是如何应对故障：    如果业务是规模比较大，那么无论是网络、硬件、软件或人为的故障都是难以避免。因此，数据库系统必须做到以下几点，才能尽可能小的影响业务

只有保障数据强一致了才能保证故障切换的时候数据不错不丢。
故障能不能影响全局，且尽量做到业务无感知。
支持同城双活、两地三中心等架构
立体组合的监控系统，能快速判断故障，定位问题。
必须要有风险控制策略等措施保证数据安全

而腾讯分布式数据库发展了年，早已默认数据强同步复制，任何节点故障，只要是已应答均可保证数据不错不丢。也可设置多种同步方案，不同的业务数据库采用不同复制策略以求在业务逻辑和数据一致性之间平衡。
的分布式架构允许任意节点故障，并不会影响全局，且每个从节点都可用做只读访问。在某些仅软件故障的场景， 的保持连接技术，可用软件故障，确保逻辑层和数据库连接不断开，且自动重发失败请求。此时业务是来说，感受就是某个请求时间稍长；即使是数据库事务，或自动回滚，或直接报错，数据不会错乱的。
由于的设计之初就是应用于腾讯内部金融支付类业务，因此同城双活、年底三中心对其来说早已成熟，常用方案如下图：
通过对系统从硬到软、从模块到流程、从系统升级到常规运维的立体化监控，并结合 “自愈”能力，可让常见故障自动解决，仅的故障需要人工干预，自动化的流程极大提高了故障修复响应效率。
当然，也是腾讯首个将完整的信息安全要求和风控体系做到整个数据库系统中的产品之一。包括业务和运维系统，我们提供恶意打击、稽核、实时风控等能力；在数据库层面，也提供了安全审核平台，数据库防火墙等一系列安全能力。

此外，成本控制是互联网企业成功的要素之一，如果是采用商业数据库，先互联网这种体量成本将是天价。而采用基于开源协议的分布式数据架构和腾讯云服务，按需使用且无高昂的费用，将极大的节省业务使用数据库成本。
目前，作为支撑了腾讯内外超过亿以账户，亿以上的交易流水和海量的虚拟交易的数据库，腾讯云分布式数据库已经广泛应用在银行、保险、理财、电商、等核心系统中。作者：

 年四月，微信正式推出了小程序码。小程序码的使命及诞生的过程， 扫码背后藏了什么秘密？小程序码又为何长得像菊花？ | 你问鹅答 一文已经作过一番介绍。本文将为你剖析更多关于小程序码的技术细节。
小程序码的前世
初见小程序码，犹如一朵盛开的菊花。

其实这种脑洞大开的异形码并非微信首创，、、 等公司都研发了自己体系的码。

从设计的图形上，我们把上述方案简单分成：
 • 平面类 如   
 • 环状类 如   
考虑到专利风险，又要兼顾优雅美观，我们最终选择放射状作为我们的  方案，也就是最后面世的“菊花码”。
小程序码的构成
小程序的  个“牛眼”用来定位，放射线条编码信息，这是一个大家都懂的原理。但”麻雀虽小，五脏俱全“，小程序码与  类似，同样包含了定位区，编码信息区，元信息区等部分，除此以外，我们还加入了自定义  区，下面让我们来解剖一下小程序码。

如何生成一个小程序码
”万丈高楼平地起“，那小程序码是如何一砖一瓦构建起来的呢？我们以一个实例来演示小程序码的生成 。
 定位点
定位点主要用于标记小程序码的大小及在图中的位置，与  类似我们采用了  的方案， 个主定位点加一个辅助定位点。可以发现，定位点的对角连线交点刚好是码的圆心， 个主定位点又刚好组成一个等腰直角三角形。以上的特征，非常有利于定位识别。

 信息编码区
我们会把原始编码的字符串，转换成  的序列，再加入纠错码，得到最终  序列。我们只需要把  序列按一定的编码路径，填充到信息编码区的方格中即可 为白， 为黑。小程序在图案编码阶段，也是按点编码的的，并没有线的概念。

 掩码图案
填充好编码区之后，我们发现图案与设计稿大相径庭，并没有发射状线条的感觉。究其原因，是因为黑色点过于稀疏。所以我们还要做 加上掩码图案。
 的原理其实就是拿一个掩码图案与原图做  操作，在解码阶段，再做一次  操作，两次  操作，我们得到了原始的数据区。

我们按照一定的规则，预先设定了  种  模板。在码生成阶段，会寻找一个最佳的 让我们的黑白分布更具线条感。 完成后，我们得到了下面的效果图。

 元信息区
前面我们提到，小程序码分为多个版本，每个版本有  个纠错 同时  阶段又有一个独特的  。这些信息，我们称之为元信息，需要独立编码到图案中，并且本身具备纠错能力。

至此，我们已经把所有必不可少的信息写入到图案中，码本身已经是可识别的了。为了让整体更加美观，需要对内外圈再进行一些处理。
 轮廓填充区
为了凸显  的形状，我们在内圈留了一些区域作为轮廓填充区。

 边缘补全区
最外圈也不带有编码信息，用于勾勒图案的轮廓，总体上我们有以下两种方案

方案一更突出图案更加圆的特点，但方案二可以让线条显得更加错落有致，也是我们的最终选择。
可扩展

为了让小程序码在编码容量上的需求，我们设计了  线， 线， 线三种版本，每个版本支持由低到高 ，，， 四种纠错等级，分别能纠错 ，，，的信息。



不同的版本，在不同的纠错  下，采用不同的字符集，其最大编码容量如下


编后语
从小程序码设计上，有以下几个特点

高识别度 保留最核心的中间区域给使用者自定义，让每个品牌商都有自己的专属码

高容错 实际应用中，大部分  由于中间部分被  覆盖，有效编码区域丢失。而小程序码是无损的，在相同纠错等级的情况下，容错性更高。

更安全  由于其开放性，容易成为“病毒”的温床。而小程序码采用完全私有的协议，只有微信可以生成，也只有微信可以解码，用户可以放心的打开扫一扫。


最后我们再通过下图，感受一下小程序码这朵“菊花”绽放的过程。上周一个叫   的数据科学家，在他的  发表了一篇文章      ，介绍他建立的一个自动的机器学习框架，几乎可以解决任何机器学习问题，项目很快也会发布出来。这篇文章迅速火遍 ，他参加过多个数据科学相关的竞赛，积累了很多宝贵的经验，看他很幽默地说“写这样的框架需要很多丰富的经验，不是每个人都有这样的经历，而很多人有宝贵的经验，但是他们不愿意分享，我呢恰好是又有一些经验，又愿意分享的人”。当然这篇文章也是受到争议的，很多人觉得并不全面。
我最近也在准备参加 ，之前看过几个例子，自己也总结了一个分析的流程，今天看了这篇文章，里面提到了一些高效的方法，最干货的是，他做了一个表格，列出了各个算法通常需要训练的参数。
这个问题很重要，因为大部分时间都是通过调节参数，训练模型来提高精度。作为一个初学者，第一阶段，最想知道的问题，就是如何调节参数。因为分析的套路很简单，就那么几步，常用的算法也就那么几个，以为把算法调用一下就可以了么，那是肯定不行的。实际过程中，调用完算法后，结果一般都不怎么好，这个时候还需要进一步分析，哪些参数可以调优，哪些数据需要进一步处理，还有什么更合适的算法等等问题。
接下来一起来看一下他的框架。
据说数据科学家 ％ 的时间都花在数据清洗和应用模型算法上面，这个框架主要针对算法的应用部分。


什么是 ？
是一个数据科学竞赛的平台，很多公司会发布一些接近真实业务的问题，吸引爱好数据科学的人来一起解决，可以通过这些数据积累经验，提高机器学习的水平。
应用算法解决  问题，一般有以下几个步骤：

第一步：识别问题
第二步：分离数据
第三步：构造提取特征
第四步：组合数据
第五步：分解
第六步：选择特征
第七步：选择算法进行训练

当然，工欲善其事，必先利其器，要先把工具和包都安好。最方便的就是安装 ，这里面包含大部分数据科学所需要的包，直接引入就可以了，常用的包有：

：常用来将数据转化成  形式进行操作
：里面有要用到的机器学习算法模型
：用来画图
以及 ，， 等。

第一步：识别问题
在这一步先明确这个问题是分类还是回归。通过问题和数据就可以判断出来，数据由  和  列构成， 可以一列也可以多列，可以是二进制也可以是实数，当它为二进制时，问题属于分类，当它为实数时，问题属于回归。
第二步：分离数据

为什么需要将数据分成两部分？
用   来训练模型，用   来检验这个模型的表现，不然的话，通过各种调节参数，模型可以在训练数据集上面表现的非常出色，但是这可能会是过拟合，过拟合就是太依赖现有的数据了，拟合的效果特别好，但是只适用于训练集，以致于来一个新的数据，就不知道该预测成什么了。所以需要有  来验证一下，看这个模型是在那里自娱自乐呢，还是真的表现出色。
在   包里就有工具可以帮你做到这些：分类问题用 
 _  
回归问题用 
 _  
第三步：构造特征
这个时候，需要将数据转化成模型需要的形式。数据有三种类型：数字，类别，文字。当数据是类别的形式时，需要将它的每一类提取出来作为单独一列，然后用二进制表示每条记录相应的值。例如：

  性别 女 ：性别 女 ：性别 男

转化之后就是：

         女 男    ：  ： 

这个过程  也可以帮你做到：
   
或者
   
第四步：组合数据
处理完  之后，就将它们组合到一起。如果数据是稠密的，就可以用  的 
   
 =   
如果是稀疏的，就用  的 ：
   
 =   
组合之后，就可以应用以下算法模型：








但是不能应用线性模型，线性模型之前需要对数据进行正则化而不是上述预处理。
第五步：分解
这一步是为了进一步优化模型，可以用以下方法：

：  ，主成分分析，是一种分析、简化数据集的技术。用于减少数据集的维数，同时保持数据集中的对方差贡献最大的特征。
   
对于文字数据，在转化成稀疏矩阵之后，可以用 
   
：  ，奇异值分解，是线性代数中一种重要的矩阵分解，它总能找到标准化正交基后方差最大的维度，因此用它进行降维去噪。
第六步：选择特征
当特征个数越多时，分析特征、训练模型所需的时间就越长，容易引起“维度灾难”，模型也会越复杂，推广能力也会下降，所以需要剔除不相关或亢余的特征。
常用的算法有完全搜索，启发式搜索，和随机算法。
例如， ：
   
或者 ：
   
对于稀疏的数据，一个比较有名的方法是 ：
 _  
 _  
第七步：选择算法进行训练
选择完最相关的参数之后，接下来就可以应用算法，常用的算法有：

      
  

在－里可以看到分类和回归的可用的算法一览，包括它们的原理和例子代码。
在应用各算法之前先要明确这个方法到底是否合适。为什么那么多算法里，只提出这几个算法呢，这就需要对比不同算法的性能了。这篇神文             测试了种分类模型在所有的个数据上的性能，发现  和  性能最好。我们可以学习一下里面的调研思路，看看是怎么样得到比较结果的，在我们的实践中也有一定的指导作用。

各算法比较
但是直接应用算法后，一般精度都不是很理想，这个时候需要调节参数，最干货的问题来了，什么模型需要调节什么参数呢？

虽然在的文档里，会列出所有算法所带有的参数，但是里面并不会说调节哪个会有效。在一些课程里，有一些项目的代码，里面可以看到一些算法应用时，他们重点调节的参数，但是有的也不会说清楚为什么不调节别的。这里作者根据他多次比赛的经验，列出了这个表，我觉得可以借鉴一下，当然，如果有时间的话，去对照文档里的参数列表，再查一下算法的原理，通过理论也是可以判断出来哪个参数影响比较大的。
调参之后，也并不就是大功告成，这个时候还是需要去思考，是什么原因造成精度低的，是哪些数据的深意还没有被挖掘到，这个时候需要用统计和可视化去再一次探索数据，之后就再走一遍上面的过程。
我觉得这里还提到了很有用的一条经验是，把所有的  都保存起来，方便在  数据集上面应用：

文章里介绍了分析问题的思路，还提到了几条很实用的经验，不过经验终究是别人的经验，只能借鉴，要想提高自己的水平，还是要看到作者背后的事情，就是参加了多次实战，接下来就去行动吧，享受用算法和代码与数据玩耍的兴奋吧。最近在处理一个蓝牙设备播放没有声音问题时，发现是设置音量的问题，顺便学习了一下系统的音量构架原理及设置方法。这里主要参考了同学写的有关音频及音量分析的文章，加了一些自己的理解及源代码分析。下面以 为例来说明。
一、音频流、音频设备、音量三角关系
要了解系统的音量构架原理，我们先要了解一下系统的音频流有哪些。下面是在中定义的音频流格式：
 __ =     电话

 _ =    系统

 _ =   响铃和消息

 _ =    音乐

 _ =   闹钟

 _ =   通知

 __ =   蓝牙

 __ =    强制系统声音

 _ =   双音多频

 _ =   语音
总共种音频流，因版本不同可能存在差异。在中也定义了，但它是引用了的定义。
音量与音频流是息息相关的。每种音频流至少对应一种音量，当然也可以多种音频流对应一种音量。在中定义了这种对应关系，具体如下：
   ___ =   {
     __
    __
     _
    _
     _      
    _
     _            
    _ 
     _       
    _ 
     _      
    _
     __       
    __
     __
    _
     _    
    _ 
     _     
    _      
}
从上面定义可以看到系统音频流，响铃与消息音频流，通知音频流，强制声音音频流，这五种音频流共用一个音量，音乐与语音是共用一个音量。上面这个定义是用于通话的平台上的比如手机，还定义了两种，分别用在电视或者机顶盒上的定义：
   ___ =   {
     __
    _
     _     
    _
     _     
    _
     _    
    _
     _  
    _
     _ 
    _ 
      __ 
    _
     __   
    _ 
     _  
    _
      _ 
    _       
}
和是其它设备的定义：
   ___ =   {
         __
        __
         _  
        _
         _      
        _  
          _    
        _
          _   
        _  
         _
        _    
          __  
        __
         __
        _    
         _
        _ 
         _     
        _       
}
系统通过来存储当前是那种平台。
我们知道在使用手机扬声器播放音乐时调整音量后，如果插入耳机，从耳机听到的音量并没有变化。在系统中，定义了一系统输入和输出设备，针对每个输入与输出设备的音量也是不一样的。下面是系统在定义的部份音频设备。输出设备：
___                  =  听筒
___                   =  扬声器
____             = 线控耳机
____           = 普通耳机
____             = 单声道蓝牙耳机
_____     = 蓝牙电话 
_____      =  车载免提蓝牙设备
____                 =  立体声蓝牙耳机
输入设备，比如：
____     = ___ |  手机自带
____     = ___| 电话
可以说每个音频流对应到每种设备都有一个音量。比如，对于同一个_流，对扬声器和耳机的音量是分开存储的。不考虑相同的情况，音量个数=音频流音频设备。
二、音量的缓存与持久化
音量的缓存是通过的内部类来设置。属性指示哪个音频流，通过定义：
    =  
按照 = 的键值对，每个元素对应一个设备的音量，将用于播放这种音频流的设备的音量保存在其中。在中定义了所有音频流及所对应的设备的音量，具体如下：
  
我们在使用手机调整音量后，关机后再开机，发现音量是我们最后调整的音量。那么这说明音量已经持久化了。音量的持久化在 以前是保存到设置数据库的表中，具体如下：

上图中后缀为的就是耳机相关音量，比如：耳机铃声音量，耳机音量。
在 及以后的版本为了加快响应速度，采用了的形式来存储的。
在用户做音量调整时，会保存到数据库或者中以实现音量的持久化。如果系统没有使用过音量，音量的初始值是什么呢？在中定义了各种音频流的默认音量，如下：
   __ =   {
           __  
           _
           _      
          _     
           _     
           _ 
           __ 
           __ 
          _
           _
}
同样在中定义了每种流的最大音量与最小音量：
        
   __ =   {
       __
       _
       _
      _
       _
       _
      __
       __
      _
       _
}
        
   __ =   {
       __
       _
       _
       _
       _
       _
       __
       __
       _
        _
}
通过以上两个数组来控制各种流音量的最大最小值。
三、音量的设置流程
设置音量通常有以下方法：通过来设置通过来设置
通过来设置
我们先看一下音量的设置过程

图音量设置流程
只是一个轻量级的封装类，由创建，工作在进程中，通过的机制，负责与层的音频服务进行交互。
类提供了方法来对一种 对应的音量进行设置：
        {
      = 
     {
           
    }    {
             
    }
}
从代码中可以看出，就是通过调用的方法，用一个类图来表示和的关系：

图   
通过代理对象访问工作在中的服务，调用其方法来设置音量。
上面说过通过来缓存各种音频流的音量，并且通过来记录各种音频流的音量。设置音量最终是通过  _函数调用函数来传入类型、音量以及类型，告知音频系统，“使用这种播放这种类型的音频播放操作，都将使用这个音量”。代码如下
_ ___ 
                                            
                                           __ 
{
       = ___
      ==   _
       
}
主要对进行了封装，所以接下来的操作都是由来完成的。
是通过调用了的函数，继承了类，他有一个类的成员指针，实际上就是指向了，最终是调用了的函数。实际上是通过成员指针访问，而则通过访问。
调用后会引发执行一个_的在这个中调用了的静态方法具体如下
_ ___   
        ___ 
{
     _ = __  _
       = __
      ==   _
      
     _
}
在这个函数里调用了的。在的中调用了的
通过方法，通过传入句柄___，来定位到具体的，调用其方法，这个方法将音量值缓存到对应的__对象中，这样，便知道每种对应的音量了。具体如下
_ ___   
        ___ 
{
    
      ==  {
         _  =      {
             
        }
    }  {
         
    }

     _
}
在的中只是保存当前音量值，然后发送通知在输出音频时按新的音量计算。
 通过来设置
  的音频子系统中，每一个音频流对应着一个类的一个实例。每个在创建时会注册到中，在的辅助下，为每个对象建立与某个具体的工作线程的对应关系，并通知这个工作线程创建了一个对象与这个进行对应。由把所有的进行混合，然后输送到中进行播放。最多可以创建个音频流。
进行混音的时候，需要知道每个播放音频的音量，这个音量是由音量、音量和音量相乘出来的，音量就是设置进来的， 由用户设置， 由调用者通过来设置。所设置的 ，是一个取值为的浮点数通常，和并不在同一个进程中，它们通过中的机制建立联系。
通过设置音量后，会记录入共享内存中，然后由去读取。
四、小结
整个音量设置还是比较复杂，其中包括持久化及各个模块的缓存及同步更新。所涉及到的音频系统子模块包括、和，每个子模块都用各自的数据结构缓存了音量，持久化在设置数据库的表中或者中。， 年加入腾讯，有年的存储经验，在弹性块存储技术方面经验丰富，本文将其在 上的分享内容进行整理，干货满满，内容包含腾讯云云硬盘产品的后台系统的演进历程、核心技术以及大道至简的方法论。

什么是云硬盘？
云硬盘，  ，简单来讲就是云上的硬盘。
云硬盘提供硬盘所有的能力：就像大家个人电脑中的硬盘，可以创建文件系统，可以存电影，可以读写文件；甚至更多：因为云硬盘的数据存在云端，可以充分发挥云的能力，提供更丰富的功能，例如：快照，可以把云硬盘某一时刻的数据做快照，当数据发生异常是，用户可以任意的将数据回滚到这些快照时刻。
用户只需要在腾讯云上购买一台云主机，就可以方便的使用腾讯云硬盘。
如何实现云硬盘弹性块存储系统？
云硬盘起初是依赖腾讯已有的个分布式系统：提供冷数据存储、提供热数据存储和提供分布式锁，用这三个分布式系统做简化整合从而产生了 存储后台。
其实最开始是将这个分布式存储系统拼凑在一起，并在前端封装一个的块存储服务，这就是。
但是这个的产品依赖个庞大的分布式系统，链、运维支撑链太长，系统臃肿，可用性极差；所以又把这个分布式系统在代码层面做了简化整合，从而产生了。
的架构是怎样的？
首先，前端是一个接入集群：，即客户端，让服务器呈现一块硬盘；，即块设备的后台接入层，前端的云硬盘通过它才能将数据放到云端；和专业名次叫 和 ，就像大家比较熟悉的结构一样；，集群总控节点，控制和协调整个集群的工作。
同时后端是一个分布式存储集群：就像经典的分布式存储系统架构，首先接入模块提供接入访问服务；存储模块负责数据存储；同样它也是一个分布式系统，同样也有一个总控节点，就是。

系统的运营状况怎样？
目前的系统在线上已经安全运行了很久；为数十万商业客户提供服务；几十万块云硬盘在线上安全运营；存储规模百级别。
大家可能对这个规模没有概念，打个比方，如果把存储的数据用书本记录下来的话，那将耗尽地球上的森林。这个规模还在快速增长。
腾讯云硬盘提供种规格的产品：介质的普通云硬盘、混合介质的高效云硬盘和高性能的云硬盘；产品可靠性达到个的级别，在业界处于领先地位。
的运营过程中的难题？
首先是成本问题：成本是永恒的主题，特别是互联网海量存储中，任何的成本优化都会带来巨大的经济收益，特别是规模快速增长阶段的腾讯云硬盘。
还有一个问题是高性能场景的使用性问题：在前边的架构图里可以看到，腾讯云硬盘的数据请求从用户到数据落地存储，经过了两个集群、四个层次，每一层的网络延时在几十个微秒级别，而这和作为高性能场景的存储介质的操作时延在一个数量级，所以数据在访问路径上的耗时占比就太大了。
如何去解决这些问题？
契合文章的主体：大道至简，做减法，简化系统，去掉接入层。

具体来说：上图左边是，也就是当前系统上规模运营的系统。它由接入系统和存储系统两个分布式集群组成；而腾讯云硬盘是个存储系统，接入是为了支撑存储的存在而存在的。
所以最直接的想法，把接入层去掉，简化成两层架构，只保留客户端在主机上呈现硬盘设备，模块提供数据落地存储，总控节点负责整集群的管理。

上图就是两层架构实现的的软件逻辑架构，和物理架构的三个节点对应：
，对应物理架构中的模块，在软件实现上称为。
，提供副本存储的存储引擎。
，总控节点，多机互备提供高可用性。
两层架构的的技术难题？
一、数据组织：数据按什么样的数据结构存在后台分布式系统中。
二、数据路由：怎么确定数据存放的位置。
三、路由同步：路由信息怎么在集群节点之间同步。
四、数据多副本：作为一个高可靠性的存储系统，三副本数据存储在不同机架的服务器上。
五、故障恢复：海量存储中，硬件故障是一种常态，怎么在故障中快速恢复服务和数据。
六、数据迁移：设备异常时或者集群扩容时，怎么讲数据从一个服务器迁移到另一个服务器。
这些都是分布式存储系统设计中经常碰到的难题，而和两层分布式架构关系最紧密的是前三条，所以重点介绍：数据组织、数据路由和路由同步。
数据组织：

先看看数据组织中最基础的问题：数据怎么分片，或者说数据的分片粒度应该多大。
如果数据分片粒度太小会那么路由信息太大，导致路由同步时机群的负担太大，特别是在两层分布式架构中，路由需要同步给成千上万的节点，过大的路由信息对总控节点崩溃。
反过来如果数据分片太大，因为每个数据分片是分配给一个用户使用的，如果用户只写入数据，而分配一个的数据分片，那会造成存储系统空间的浪费，导致空间利用率低。
为了解决这个矛盾，在数据组织上引入了虚拟分区的概念。在物理上硬盘被分为多了固定大小的，物理上每个属于一个硬盘，而在逻辑上又将多个组织为一个，和硬盘的关系是固定的，但是和的关系只是为了完成特定的功能需求而存在的。
数据路由：

基于的数据组织方式，数据怎么路由呢？即数据怎么定位到存储的位置呢？
当前端数据访问时，它携带、或者说、 快照号，系统将这个参数通过一致性哈希，计算出对应的；而和物理服务器、物理硬盘的对应关系是在集群初始化的时候配置的，这样前端的数据请求就路由到了需要存储的物理位置，这就是基于虚拟分区的数据路由方式。
路由同步：

在两层架构中，没有接入节点，实际上会导致所有的节点都会成为接入节点，因为每一个都需要有路由信息进行数据访问；而接入节点成千上万，需要总控节点和成千上万的去同步巨大的信息，实际上总控节点会被压垮。
为了解决这个问题，参考了一种懒汉做事的方法：尽量少做事、晚做事、非做不可的时候再去做。
在架构中：是个懒人，当总控节点发生路由变更的时候，本来需要将路由信息推送到所有的模块，但是因为是个懒人，它只简单的把路由信息推送到模块；也是个懒人，收到路由推送之后，它也只是简单的将路由信息存到了本地；发起数据访问的时候，检测中携带的路由版本和本身的路由版本是否一致；如果不一致，通知需要路由更新，虽然懒，但很负责；收到存储节点的通知，它尝试从存储节点更新路由；如果因为宕机或其他异常不能及时响应的更新请求，就向发起路由更新请求，具有最高的权威，它将正确的路由信息反馈给你，最终完成路由同步；整个路由推送处处体现懒人风格，谁都尽量少做事、晚做事、非做不可的时候再去做，当然懒人没问题，但一定要是一个负责人的懒人。
王银虎团队给这种懒人风格的路由推送算法起了个名字：路由同步或者叫惰性路由同步。
用虚拟分区的方式进行数据组织和路由，用路由同步的算法进行路由同步，从而解决了两层架构中最关键的数据组织、数据路由、路由同步问题。
两层架构的效果怎么样？
两层架构的已经上线，上线后普通云硬盘的成本降低；两层架构的提供了一个统一的平台，不仅支持通用的普通云硬盘，也支持高性能场景的高效云硬盘和云硬盘。
业界对比

在自身发展的同时，也在紧跟业界发展动态，例如目前开源里比较流行的。
和都是两层架构的实现。但是在性能方面要远高于。
支持精细化运维，有完善的监控告警系统，但只提供了一个简单的通用运维系统，如果使用，需要在运维系统方面有巨大的投入。
在可控性方面也要远高于，例如数据安全可控性，在任何场景下都不能丢数据，数据安全是一种信仰，但是在某些特定的故障场景，数据安全是没有办法保证的。
当然也有很多值得我们借鉴的东西：例如是块存储平台目前已经支持文件存储，而一开始就是作为统一存储平台设计的，同时支持块存储、文件存储和对象存储；的是镜像多副本存储，但是在支持镜像多副本的同时，还支持纠删码，特别是一些成本特别敏感的应用场景是很有优势的。

总结
的发展历程就是一个“简”的过程；在最新的两层架构设计中，体会到以简致胜的真谛，不做过度设计，提供用户真正需要的功能；所谓大道至简，简化系统架构，提供高性能、高可靠性、易用的服务，和用户创造共赢。
相关推荐
云硬盘任何一个复杂的系统，用户感知到的都只是冰山一角，数据库也不例外。
前两篇文章介绍了 、 的基本概念以及一些核心功能的实现原理，这两个组件一个负责  存储，一个负责  引擎，都是大家看得见的东西。在这两个组件的后面，还有一个叫做  的组件，虽然不直接和业务接触，但是这个组件是整个集群的核心，负责全局元信息的存储以及  集群负载均衡调度。
本篇文章介绍一下这个神秘的模块。这部分比较复杂，很多东西大家平时不会想到，也很少在其他文章中见到类似的东西的描述。我们还是按照前两篇的思路，先讲我们需要什么样的功能，再讲我们如何实现，大家带着需求去看实现，会更容易的理解我们做这些设计时背后的考量。

为什么要进行调度
先回忆一下  第一篇文章 提到的一些信息， 集群是  数据库的分布式  存储引擎，数据以  为单位进行复制和管理，每个  会有多个 副本，这些  会分布在不同的  节点上，其中  负责读写， 负责同步  发来的  。了解了这些信息后，请思考下面这些问题：

如何保证同一个  的多个  分布在不同的节点上？更进一步，如果在一台机器上启动多个  实例，会有什么问题？
 集群进行跨机房部署用于容灾的时候，如何保证一个机房掉线，不会丢失   的多个 ？
添加一个节点进入  集群之后，如何将集群中其他节点上的数据搬过来
当一个节点掉线时，会出现什么问题？整个集群需要做什么事情？如果节点只是短暂掉线重启服务，那么如何处理？如果节点是长时间掉线磁盘故障，数据全部丢失，需要如何处理？
假设集群需要每个   有  个副本，那么对于单个   来说， 数量可能会不够多例如节点掉线，失去副本，也可能会 过于多例如掉线的节点又回复正常，自动加入集群。那么如何调节  个数？
读写都是通过  进行，如果  只集中在少量节点上，会对集群有什么影响？
并不是所有的  都被频繁的访问，可能访问热点只在少数几个 ，这个时候我们需要做什么？
集群在做负载均衡的时候，往往需要搬迁数据，这种数据的迁移会不会占用大量的网络带宽、磁盘  以及 ？进而影响在线服务？

这些问题单独拿出可能都能找到简单的解决方案，但是混杂在一起，就不太好解决。有的问题貌似只需要考虑单个   内部的情况，比如根据副本数量是否足够多来决定是否需要添加副本。但是实际上这个副本添加在哪里，是需要考虑全局的信息。整个系统也是在动态变化， 分裂、节点加入、节点失效、访问热点变化等情况会不断发生，整个调度系统也需要在动态中不断向最优状态前进，如果没有一个掌握全局信息，可以对全局进行调度，并且可以配置的组件，就很难满足这些需求。因此我们需要一个中心节点，来对系统的整体状况进行把控和调整，所以有了  这个模块。
调度的需求
上面罗列了一大堆问题，我们先进行分类和整理。总体来看，问题有两大类：
作为一个分布式高可用存储系统，必须满足的需求，包括四种：

副本数量不能多也不能少
副本需要分布在不同的机器上
新加节点后，可以将其他节点上的副本迁移过来
节点下线后，需要将该节点的数据迁移走

作为一个良好的分布式系统，需要优化的地方，包括：

维持整个集群的  分布均匀
维持每个节点的储存容量均匀
维持访问热点分布均匀
控制  的速度，避免影响在线服务
管理节点状态，包括手动上线下线节点，以及自动下线失效节点

满足第一类需求后，整个系统将具备多副本容错、动态扩容缩容、容忍节点掉线以及自动错误恢复的功能。满足第二类需求后，可以使得整体系统的负载更加均匀、且可以方便的管理。
为了满足这些需求，首先我们需要收集足够的信息，比如每个节点的状态、每个   的信息、业务访问操作的统计等；其次需要设置一些策略， 根据这些信息以及调度的策略，制定出尽量满足前面所述需求的调度计划；最后需要一些基本的操作，来完成调度计划。
调度的基本操作
我们先来介绍最简单的一点，也就是调度的基本操作，也就是为了满足调度的策略，我们有哪些功能可以用。这是整个调度的基础，了解了手里有什么样的锤子，才知道用什么样的姿势去砸钉子。
上述调度需求看似复杂，但是整理下来最终落地的无非是下面三件事：

增加一个 
删除一个 
将  角色在一个   的不同  之间 

刚好  协议能够满足这三种需求，通过 、、 这三个命令，可以支撑上述三种基本操作。
信息收集
调度依赖于整个集群信息的收集，简单来说，我们需要知道每个  节点的状态以及每个  的状态。 集群会向  汇报两类消息：
每个  节点会定期向  汇报节点的整体信息
 节点与  之间存在心跳包，一方面  通过心跳包检测每个  是否存活，以及是否有新加入的 ；另一方面，心跳包中也会携带这个  的状态信息，主要包括：

总磁盘容量
可用磁盘容量
承载的  数量
数据写入速度
发送接受的  数量 之间可能会通过  同步数据
是否过载
标签信息标签是具备层级关系的一系列 

每个   的  会定期向  汇报信息
每个   的  和  之间存在心跳包，用于汇报这个  的状态，主要包括下面几点信息：

 的位置
 的位置
掉线  的个数
数据写入读取的速度

 不断的通过这两类心跳消息收集整个集群的信息，再以这些信息作为决策的依据。除此之外， 还可以通过管理接口接受额外的信息，用来做更准确的决策。比如当某个  的心跳包中断的时候， 并不能判断这个节点是临时失效还是永久失效，只能经过一段时间的等待默认是  分钟，如果一直没有心跳包，就认为是  已经下线，再决定需要将这个  上面的  都调度走。但是有的时候，是运维人员主动将某台机器下线，这个时候，可以通过  的管理接口通知  该  不可用， 就可以马上判断需要将这个  上面的  都调度走。
调度的策略
 收集了这些信息后，还需要一些策略来制定具体的调度计划。
一个  的  数量正确
当  通过某个   的心跳包发现这个  的  数量不满足要求时，需要通过   操作调整  数量。出现这种情况的可能原因是：

某个节点掉线，上面的数据全部丢失，导致一些  的  数量不足
某个掉线节点又恢复服务，自动接入集群，这样之前已经补足了  的  的  数量多过，需要删除某个 
管理员调整了副本策略，修改了  的配置

一个   中的多个  不在同一个位置
注意第二点，『一个   中的多个  不在同一个位置』，这里用的是『同一个位置』而不是『同一个节点』。在一般情况下， 只会保证多个  不落在一个节点上，以避免单个节点失效导致多个  丢失。在实际部署中，还可能出现下面这些需求：

多个节点部署在同一台物理机器上
 节点分布在多个机架上，希望单个机架掉电时，也能保证系统可用性
 节点分布在多个  中，向单个机房掉电时，也能保证系统可用

这些需求本质上都是某一个节点具备共同的位置属性，构成一个最小的容错单元，我们希望这个单元内部不会存在一个  的多个 。这个时候，可以给节点配置  并且通过在  上配置  来指名哪些  是位置标识，需要在  分配的时候尽量保证不会有一个  的多个  所在结点有相同的位置标识。
副本在  之间的分布均匀分配
前面说过，每个副本中存储的数据容量上限是固定的，所以我们维持每个节点上面，副本数量的均衡，会使得总体的负载更均衡。
 数量在  之间均匀分配
 协议要读取核写入都通过  进行，所以计算的负载主要在  上面， 会尽可能将  在节点间分散开。
访问热点数量在  之间均匀分配
每个   以及   在上报信息时携带了当前访问负载的信息，比如  的读取写入速度。 会检测出访问热点，且将其在节点之间分散开。
各个  的存储空间占用大致相等
每个  启动的时候都会指定一个  参数，表明这个  的存储空间上限， 在做调度的时候，会考虑节点的存储空间剩余量。
控制调度速度，避免影响在线服务
调度操作需要耗费 、内存、磁盘  以及网络带宽，我们需要避免对线上服务造成太大影响。 会对当前正在进行的操作数量进行控制，默认的速度控制是比较保守的，如果希望加快调度比如已经停服务升级，增加新节点，希望尽快调度，那么可以通过  手动加快调度速度。
支持手动下线节点
当通过  手动下线节点后， 会在一定的速率控制下，将节点上的数据调度走。当调度完成后，就会将这个节点置为下线状态。
调度的实现
了解了上面这些信息后，接下来我们看一下整个调度的流程。
 不断的通过  或者  的心跳包收集信息，获得整个集群的详细数据，并且根据这些信息以及调度策略生成调度操作序列，每次收到   发来的心跳包时， 都会检查是否有对这个  待进行的操作，通过心跳包的回复消息，将需要进行的操作返回给  ，并在后面的心跳包中监测执行结果。注意这里的操作只是给   的建议，并不保证一定能得到执行，具体是否会执行以及什么时候执行，由   自己根据当前自身状态来定。
总结
本篇文章讲的东西，大家可能平时很少会在其他文章中看到，每一个设计都有背后的考量，希望大家能了解到一个分布式存储系统在做调度的时候，需要考虑哪些东西，如何将策略、实现进行解耦，更灵活的支持策略的扩展。
至此三篇文章已经讲完，希望大家能够对整个  的基本概念和实现原理有了解，后续我们还会写更多的文章，从架构以及代码级别介绍  的更多内幕。如果大家有问题，欢迎发邮件到  进行交流。

作者简介：申砾，  ，前网易有道词典服务器端核心开发，前奇虎  新闻推荐系统  地图基础数据与检索系统  。

 源码地址：导语
前端的技术革新从来没有停止过，但从最近的趋势来看，貌似有一个“新”名词出现，那就是函数式编程， 。、这些热门的框架都多多少少有点涉及到函数式编程的领域，甚至已经开始有一些以函数式编程作为主范式的框架出现，比如说。那么，为什么函数式编程会如此重要呢？或许我们可以先从函数式编程的认识聊起。
 何为函数式编程？
 什么是纯函数？
让我们回想一下初中数学，我们知道一个函数有定义域和值域，对于定义域里面的每一个值，都会对应值域中唯一确定的一个值。这种函数的基本性质在编程里面却不一定成立，因为代码中的函数可能依赖于外部环境：
  = 
  {
        {
         
    }  {
         
    }
}

  
  
正如上面的代码，函数依赖了外部变量，导致相同的输入却得到不同的输出。在函数式编程有个概念称之为副作用 ，指的是函数的执行依赖于外部环境，这里的依赖可能是读取了外部变量，也可能是修改了外部变量。
一个函数如果依赖外部环境，那么它的行为就会变得不可预测。因为你不知道外部环境什么时候会被改变，有句话貌似流传已久，很直接地指出了副作用给代码组织可能带来的问题：
       可共享可修改的变量是所有罪恶的根源
纯函数 的概念就是指没有副作用的函数，在理论上它等价于我们数学世界里面的函数概念。纯函数的优势在于，它向我们保证了其纯粹性，同样的输入无论调用多少次，都会是一样的输出，并且不用担心调用过程会修改外部环境。每个函数都是足够独立足够抽象的个体，我们可以放心地将函数进行组合，这让我们在做代码复用或者重构时，不用去担心函数是否会影响到其他地方。
 是什么而非怎么做
函数式编程是声明式编程 的一种形式，你可能会联想到命令式编程 。命令式编程通过编程语句声明了每一步的具体操作，如何修改变量以及按照什么样的顺序，这里强调的是 。而函数式编程关注的点在于是需要哪些变量，需要什么样的操作，这里强调的是  。
直接看例子更容易理解：
  =          

 
  = 
   =      {
       {
         
   }
}

 
  =  =   
  =  =   
从上面的代码能看出一些问题来，对于命令式编程来讲，我们需要关注对数据的操作，如何创建数组，如何遍历元素，如何插入元素等等。而函数式编程写出来的东西更像是一系列声明语句：什么奇数，什么是平方。
很难说这两种编程范式哪种更好，命令式编程符合人类的线性思维，首先做什么，然后做什么，步骤详细具体但稍显繁杂。同时也因为涉及到变量状态的共享和修改，在非线性并行计算里面，就会存在数据同步的问题。
而函数式编程抽象层次更好，代码编写和组织要求的门槛相对更高，不过其代码往往更能直接体现问题核心，同时对于并行计算有天然的支持。
 关注计算而非数据
我们都知道对于冯诺依曼架构的计算机来讲，核心是存储和计算。这两个概念体现到编程中，分别就是数据以及对于数据的操作。
编程范式也有相对应的，我们熟知的面向对象编程，关注点在于数据的抽象，如果你对大学的编程课还有印象的话，应该会知道，如果有一组固定的操作，为这些操作添加新的数据类型是很简单的事情。相对应的，函数式编程注重对数据的操作，在数据类型不变的情况下，想要添加新的计算方法很简单。相反如果要添加新的数据类型，那么你就不得不将大部分函数都进行修改。
这两种范式没有孰好孰坏之分，只是适用于不同的场景。
 前端中的函数式编程
函数式编程出现的时间很早，但在近几年才慢慢在前端中有所表现，个人觉得主要原因在于，前端技术的快速发展虽然足以支持日益复杂的页面交互需求，但我们仍然需要一种能够更好表达交互的范式或者框架。而函数式编程在这方面还是挺适合前端的，列举我觉得最重要的两个点：
前端麻烦的异步问题，可以由函数式编程中的异步计算来解决声明式编程基本被业界证明是前端编程的一种最佳实践方式当然这些共性问题已经被发现了，前端领域有很多特性、库或者框架来支持和应用函数式编程。
 函数式语言
有很多语言都是支持函数式编程的，当然我们的 也支持。一门高级语言是否支持函数式编程，只要看其函数是否是一等公民 ：函数能够作为其他函数的参数或者返回值。这个概念其实跟高阶函数 差不多，只是两者描述的主体不一样。
中的语法：
  {
     
}

  {
      {
          
    }
}
 
从  开始成为原生支持的语法，大家也应该不会陌生。作为处理异步的一种方式，它的特点在于通过将异步操作封装起来，让你可以像操作同步代码一样去进行操作：
  =  {
     {
        
    } 
}

  {
       
}

  {
       
}

  
如果你对函数式编程熟悉的话，可能会意识到  其实就是一种 。函数式编程中对于有一整套完善的操作，可以将异步函数和同步函数统一起来，完美地支持函数的组合。目前已经有类似的库来完成封装，比如， 等。
 主流框架与函数式编程
目前主流的前端框架，比如，，大部分都是支持函数式编程的，甚至已经开始有一些以函数式编程为主范式的框架开始出现，比如 ，。这里有必要讲一下主流框架为何支持函数式编程。
在为了满足更多样化的需求的同时，前端页面变得越来复杂。页面视图从最开始的静态页面，到服务端动态渲染，再到前端渲染。而渲染过程实际上是数据到视图的一种映射，传统的基于  直接操作视图的方式，在前端渲染时开始显得很麻烦，一个主要的原因在于命令式编程的抽象层次不够高，它将操作的细节完全暴露给开发者，所以很难建立直观、有效的映射关系。
前端开发者更希望有一种所见即所得的编程方式，可以完全将如何操作、如何更新等工作隔离开来，只要关注最核心的部分，数据和视图的映射关系。幸运的是，前端模板技术的 快速发展满足了这个需求，比如中使用了  来作为抽象视图层：
 
  {
      
      
}

 
  {
      
     
      
          {  }
          {  }
     
   
}
抽象视图层的引入打开了前端函数式编程的大门，正如上面的例子，第二个就是一个纯函数，它帮我们隐藏操作的细节渲染实际上是一种副作用，只保留了最纯粹的映射关系。从因果关系上来讲，很难说是因为函数式编程才引入了抽象视图层，而应该是抽象视图层的选择反而无意中促进了函数式编程在前端中的应用。
其实正如第部分一开始讲的，函数式编程本身的异步处理、声明式等特性是很适合前端开发的，所以才导致前端技术发展过程中，多多少少有点向函数式编程靠近、借鉴的原因。
 一种新的编程范式 – 
最后再讲一种以函数式编程为基础引申出更具体的编程范式：响应式函数编程，  。目前已经有基于这种范式而开发的库或者框架，比如、、等。
要理解  其实很简单，函数式编程的概念在第部分大致讲了，响应式编程的介绍不细讲，有兴趣可以看这篇文章：       。这里简单讲响应式编程跟函数式编程的关系。首先重新讲一下函数式编程的基础，即纯函数。我们知道纯函数不会对外部环境造成影响，那么问题来了：
假设我们写了一堆纯函数，并完美地将它们组合起来，但无论如何你都不能输出到外部，那我们的代码还有什么意义？我们又怎么知道这些代码运行了没有？最终我们不得不承认，一个完美的项目其实离不开副作用比如前端的操作，请求等都属于副作用。
但既然前面我们已经讲述了这么多函数式编程的特性和优点，我们不想让副作用毁了这个美好抽象的函数世界，而是希望找到一种优雅的方式来隔离它们，一种有效的方式就是响应式编程。
中通过构建一种特殊的 ，这种  可以通过被观察订阅的方式即响应式编程的方式来抽离副作用。可能通过  的来说明更容易理解：
  = 
  = 
  = 

  =  
  =  

 
  = 
  = 
  =   {
       
} 

 
 {
     = 
}
 总结
函数式编程在前端中的应用广泛，在某些语法、框架中实际上都借鉴了函数式编程的思想，但我们可能并没有发觉。从前端目前的发展趋势来看，个人觉得函数式编程的应用还会继续下去，希望大家可以一起关注。作者介绍：于广游，腾讯云后台开发工程师。欢迎加入腾讯云容器服务交流群。

什么是滚动升级
滚动升级是一种多副本服务的升级方式，其特点是能够保证升级过程中服务不中断，对外界无感知。其原理大致为循环的执行以下步奏直至所有容器都被更新。

启动一个新的容器

将绑定到新的容器上

将老的容器从上解绑

停止老的容器


使用说明

我们有以下两个镜像。

镜像_启动的容器，对其端口路径执行操作会返回： {}。
   
{}

镜像_启动的容器，对其端口路径执行操作会返回： {}。
   
{}

首先，我们使用_镜像创建一个带有外网的服务，名为，点击“更新服务”按钮。

在弹出的更新服务页面中修改镜像版本为。

\\\\\{}
点击开始更新前，在云主机上执行以下命令，其中部分为服务外网的，并点击开始更新按钮。

 

  


回到容器服务控制台，服务列表页，会看到状态变为更新中，此时点击查看进度按钮，在弹窗中可查看服务更新进度。

随着更新进度的变化，会看到刚才执行脚本的云主机上，返回值中{}的占比越来越大最终全部变为{}。
{}
{}
{}
{}
{}
{}
{}
{}
{}

{}
{}
{}
{}
{}
{}
{}
{}
{}
{}
{}
{}

{}
{}
{}
{}
{}
{}
{}
{}
{}
{}
{}
{}

暂停更新
在更新过程中，您随时可以点击暂停更新按钮来暂停滚动升级，此时服务状态会变为“暂停更新”，您也可以点击继续更新按钮来继续服务的更新。


回滚更新
在更新过程中，您也可以随时点击“回滚”按钮来终止本次更新并将已升级的容器恢复到原始版本。


相关推荐容器服务安全组设置在 上使用腾讯云  镜像加速构建高可扩展高性能容器管理服务前言
看完  这篇  有一段时间了，但是一直没有去网上搜集相关的实现代码，去把它调试跑通，并将之应用到实际的项目中。这两天终于抽空做了实现，并和自己项目中常用的集成算法、做了简单对比。下面总结一下整个算法的  实现过程，以及将它应用到自己的数据集上出现的问题和解决办法。
一、运行环境要求
 版本： 以上；
 版本： 以上；
 版本： 以上；
 版本： 以上。
解决办法： 可以直接在  官网 去下载对应操作系统的   ；然后在  上去选择对应版本的  ；之后可以在  列表中查看上述包对应的版本，不符合要求的可以直接更新。这样，整个  算法的  运行环境就  了。
二、 实现
 算法在  上已经有大神实现了，版本也有好几个，我自己把其中一个版本地址：  到本地，并做了调试实现。
  算法实现
 算法的实现代码相对较多，直接以附件的形式上传，名称：可以直接将该附件导入工程就可以了。
示例——验证算法能否跑通
为了验证算法的可行性，写一个小的  去测试，至于  中的参数详细说明见具体实现类， 个参数，一点儿也不多可以根据自己的要求去调试，代码如下：

   
____ = 

 _  
   _
 _  __
   _
 __  _
   

   
 = _
 = 
 = 

_ _ _ _ = __  _=

 = _=  =  =
_ _

 方法预测的是每一条样本的分类类别，结果 _ 是一个 的 
_ = _
 = __=_ _=_ 用  数据的真实类别和预测类别算准确率
  {}

  _ 方法预测的是每一条样本为 ，类别的概率，结果是这样的：
  概率 ，概率 ， 概率 ，概率 ，的 
 表示取出序号为  的列，也就是预测类别为  的概率值结果是一个数组
___ = __ 
___ = __ 
下面是算  值，不理解的可以置之不理
  _  __ ___
  _  __ ___
上面的代码中要导入我们已经实现了的  类第三行，后面的模型训练和预测分类结果，跟正常的  调用  中的方法一样，都是 ，_ 等；代码最后两句是计算训练样本和测试样本的  值，读者可以不用管，不影响程序的可运行性运行的时候可以注释掉。
用自己的数据集去跑模型
自己的数据： 文件， 个样本有点少，但是不影响测试算法， 个特征；
代码实现如下：
   
____ = 

   
 
   
 _  __
 _  
 __  _
   _

 
    _ = \\__\\_____
    _ = __
    __ = 
     = 
     = ___ = =
     = 
     先将  和 转化成 
     = 
     = _
     = 
     = 

    _ _ _ _ = __  _=

     = 
      
     _ 默认是 ，但是用到   时，需要用到，我理解的是特征的数量对于序列数据
     ：滑动窗口的大小
     ：滑动步长，默认是 
     ：提升的精度小于  时，就停止整个过程。
     _= __= _=
     _= _=__=
     __= = _=
     = _= _= =
                   = __= _=
                   _= _= __=
                   __= = _=
    _ _

    _ = _
     _
     = __=_ _=_
      {}

    ___ = __ 
    ___ = __ 

      _  __ ___
      _  __ ___

     整个模型的训练预测耗时为：  

 ____ == ____
    
用自己的数据集去跑  算法的时候，还是会遇到很多问题，特别是数据格式方面，可以根据自己的数据格式去做一系列的调试和格式转换。
算法对比
自己通过调参，简单的和线上的算法以及另外一个集成学习算法  做了对比，由于  算法中要做多粒度平滑处理和训练级联森林，所以当参数中的森林数量和对应树的数量较多时，训练模型的时间比  和  都长；效果嘛， 也稍逊一点。
说明：其实本篇文章的重点是实现测试  算法，并对其做一个简单的应用尝试，初衷也不是和其他算法在自己数据集上做性能对比，本身这个算法的优势是做序列数据和图像数据，对于一般的常规数据样本，效果不好也可以理解，加上自己用的样本数量也太少了点，可能或多或少影响了  的精度。
写的比较仓促，或许会存在一些问题，希望看到的伙伴能不吝赐教，或者是有兴趣的同事，我们可以一起探讨交流，谢谢！导语
目前的火爆不亚于当初的，本人对写代码有洁癖，代码也是艺术。此篇是准备篇，工欲善其事，必先利其器。我们先在代码层面进行优化，对我们完成整个技术架构是起到基础作用的。此准备篇是独立的，即使你们的项目不使用，也不影响文章的阅读，是代码的基础优化。
一、前言
目前的火爆不亚于当初的，本人对写代码还是有一定洁癖的，代码也是艺术。很长时间在找寻最适合自己的前端开发框架，包括在最火的时候，我依然在坚持寻找，但在我心目中并不完美。认识的时候，还是阶段，发现其理念和我心目中的理念相当接近。
文档友好，简洁易懂，申明式的模板我的最爱，的架构，同步异步组件化等等。一路跟随走来，从到，逐步成为世界级的框架。作为见证者还是挺开心的。
我们最新上线的项目是基于的前端后端同构一体化实现的，运用了  。从代码的编写和维护角度上，已经比较不错了。而且本身的开发效率就很高，所以目前我们团队还会在这块继续深挖。
此篇是准备篇，工欲善其事，必先利其器。我们先在代码层面进行优化，对我们完成整个技术架构是起到基础作用的。此准备篇是独立的，即使你们的项目不使用，也不影响文章的阅读，是代码的基础优化。
二、代码优化方向
技术选型没有最好的，只有最适合业务的。目前我们的业务是用打包构建的。目前有几个痛点：
、代码冗余。我们经常引入了一个大的库，实际上只是引用了这个库中的一个方法，但是却打包了整个库，代码的冗余和浪费。随着引入的文件越来越多，这种问题也会变得越来越明显。无论是基于代码洁癖，还是代码体积来看，都有优化的必要。
、异步流程控制。随着前端的发展，我们站着大牛的肩膀上，逐步摆脱了回调地狱，以及各种异步流程的坑。有着目前来看最好的异步流程解决方案「方案」。 版本已经正式支持了此特性，端也可以统一，达到前后端同构的目的。清晰的异步流程控制对于团队代码的理解和维护都有着积极的意义。
、代码洁癖的考虑，引入箭头函数，简化代码。利用箭头函数不绑定的特性，解决「漂移」问题。
三、代码优化实施
、优化方向一，其实通过的能力就可以做到了。我们使用来实现我们的能力。但这里我们要注意一定要用的来实现。代码如下：



模块的继承
   _

定义变量或常量
  = 

定义私有函数
 _{
    
}

定义公有函数
   {
    
}

   {
    
}

   {
    
}

_

   {
    
}

_

     

改造好代码后，通过执行命令，我们可以得到如下结果：


注意一下红框部分的内容，在非压缩模式下，实际上并不是完全意义上的，还是有把没有使用的方法打入文件中，但是会提示「  」这样的提示。
然后我们执行一下的压缩命令：


压缩代码中只有「」，也就是  这三个被标记为「  」的方法在压缩版本中移除了，只有由于被引用，所以保留了。证明我们的是成功的。而且要看到是基类模块的方法，证明在继承的情况下，也是正确执行的！
尽量使用     隐式语法而无须使用 {}  这种显式语法。
使用前者非常方便的在调用的时候使用这种写法，而且是可以正确解析的。比如代码中只调用了，那么  是可以过滤掉的。而不用特意地指定 {}  
这种隐式的写法极大的方便了我们代码的灵活性。而不需要调用一个，我就要在的地方显式的加一个！看，一切都很美好。是很智能的！
阶段性小结：
用来改造代码，这是的基础，的模块支持继承，可以正确执行。
的打包非压缩的情况下会保留 ，压缩版才会真正去掉。
尽量使用     隐式语法而无须使用 {}  这种显式语法。
我们的业务接入特性后，代码体积有减少。
、优化方向二，在侧我们的异步流程控制其实并没有特别复杂，毕竟使用场景上还是没那么多的回调地狱。通常我们的解决方案就是简单地就用回调处理，复杂的逻辑，可能有用类似，这种类库来解决。代码从可读性上还是可以的，比如：

这个示例中综合了同步和异步代码，从代码的表现形式上还是可以理解为同步的流程。但这种类库本质还是的方式，采用的方式是我们未来的趋势，而且直接上方案，争取一步到位。改造后我们的代码可以类似如下图所示：

类比可以看出，我们的代码在可读性上又上了个台阶。会有种摆脱了垃圾代码的舒畅感。
在后端 已经正式支持了语法，所以后端直接升级即可。在前端而言，我们这里还是有不少工作要做的。不想看过程的朋友，直接下载本文结尾的自行实践
首先我们的浏览器端对对象还有兼容问题：

我们必须引入才能安心在浏览器端使用。经过我们业务的实践和筛选，我们最终选择了这个，这个的优点是代码少，该有的核心方法都有，满足我们的业务需要。不要使用自带的，代码太冗余了。所以我们在文件中引入：
   
其次我们要通过来翻译语法，翻译前：

翻译后：

其实这样看起来并没有特别的差别，但这样运行是会报错的。会提示：

这里主要是缺少的定义，所以我们需要人为的补上去，在文件头部引入：
 
就可以愉快地在前端使用啦
阶段性小结：
需要配置好以及的配置，这个参考。
在需要进行的文件引入

虽然可以支持浏览器的语法，我们看到实际编译的文件还是很大的：

此问题待解决。
四、配置以及
参考来看，有些配置的地方还是要注意一下的。
、，由于是，和并不完全一样，这里需要修改兼容一下。
、的配置推荐使用，这是目前最新的解决方案，会非常灵活的通过参数指定来兼容当前的环境。

、一定要升级最新的正式版的，版的有一些会导致编译不过。

、由于进行编译估计比较慢，建议开发阶段不要开编译。现在的浏览器版本以上都支持语法，在开发模式中模拟调试的时候，完全可以不开编译。在进行真机调试的过程中，的最新浏览器和新系统的最新浏览器也都是支持语法的，也不用编译。
所以做两个文件是一个方法，比如以及。我们编译的过程放到提测阶段即可。这样节省开发编译的时间和效率，这是个小技巧。
_
下载之后运行
 
 无压缩版
  压缩版导语 自从苹果月日在 上出自己在计算机视觉和领域又一重磅新科技——后，我们真是喜忧参半，喜的是 等技术的出现加速了深度学习在移动端的落地，忧的是对于正在研究模型小型化与加速的我们来说，如果苹果的做的足够好，那么还需要我们做什么呢？『思考』『思考』

俗话说的好，知己知彼，百战不殆。为了找出对手的优缺点，研究对手的技术核心，在召开近多天后，终于有时间静下心来研究一下苹果这个机器学习——。
的官网主页如下：主页上对的核心定位是：能够方便地将机器学习模型移植到移动端中，即下图所示：
有其自定义的模型类型，并且支持目前几种主流模型到的转换，包括、 、等。苹果在主页给出了几种现成的，包括、、和四种。网上关于直接利用这几种模型进行图像分类的参考例程已经很多了，所以这里主要讲一下如何转换自己的训练模型并进行应用的参考过程。
一、软件准备
由于目前仅支持和，因此需要先对移动设备升级到，并且下载 版本。戳这里下载   
二、下载转换工具
苹果提供了开源的转换工具 ，在安装前，需要安装基本依赖包 ， ，如果需要转换、、、等，还需安装对应的依赖包      、 、 、等使用可以很方便地安装依赖包和   安装完成后就可以使用了。
三、转换模型
这里以模型 为例浏览这里 下载进入命令行引入

  
调用转换函数进行模型转换
  = _


__=_=_ =  
针对以上调用参数，有几点进行说明：如果打开安装目录下的源码__，可以看到的函数的定义：

  __= _=
            _= _= _= _=
            _= _= __=
其中，即原始 模型，是一个元组，可以有三种形式： ‘’ 只包含原始模型 ‘’ ‘’包含原始模型与模型结构文件 ‘’ ‘’’’包含原始模型、文件和均值文件一般需要同时提供模型和文件，否则转换程序无法找到输入的维度定义。同时，一般在文件开头会指定输入的名称和维度，如下形式： “__”_ _ _ _ 这与默认的形式是一致的，所以我们无需再做任何修改。对于需要做均值减除操作的模型，需要同时提供均值文件。需要注意的是，对于三通道彩色图像，均值文件需与输入图像通道顺序一致。剩下的参数根据模型自身特点进行设置：__这个参数可以不用设置，但如果采用上述形式的，转换后的模型经解析后，会将输入解析成形式，对于输入的话还需要进行转换，不够灵活方便，因此强烈建议对该参数进行设置，而设置也很简单，只要将其设为输入层的名称即可，如我的中输入名为，则令__=’’即可。设置此项参数后，转换后的模型经解析，输入就变成了类型，可以方便地与进行转换。_这个参数很直观，也很重要，用于标明输入彩色图像的顺序。通常情况下，模型由于采用做为读取图像的接口，因此，输入的图像均为顺序，因此需要将此参数设置为。_ 这个参数和__参数一样，都是为分类模型设计的，对图像分类很有用。_允许开发者提供一个包含所有类名的文件，每类一行，用以将分类预测的结果映射到类名中，从而可以直接输出 的直观分类结果。如果设置了该项参数，模型经过解析后，输出就包含了两部分，如下原本网络输出维概率值，这里被进一步加工成对应的和由每一类及其概率组成的字典型结构。而相比之下，如果不设置该参数，则输出即被解析为数组形式，需要开发者自己完成后续计算和类别映射：
__ 用于对 模型输出类别名称进行重命名，默认为上面图中的“”，开发者根据自身喜好和方便设置即可。
剩下几项参数由于没有用到，故不再赘述，大家可参考函数定义，苹果写的还是很详细的。保存转换模型

 
至此模型就转换完毕了。
四、将模型应用到中
 打开   ，新建一个工程，语言我选择的是 将第三步生成好的模型放在工程目录下，同时，将模型拖入到左侧工程导航栏中。点击该模型，会出现相关信息，如下图

可以看到模型的输入和输出定义。这里我的模型输入是 类型，即大小为的三通道图像，输出则是包含和的结构体，对应每个类的类名和其概率，以及的类名。模型对应的接口文件可以在 中名称右侧的小箭头点击查看。这里出现了一个小插曲。正常情况下，将拖入工程后，会自动解析并生成对应的接口文件，但是最初我的模型接口文件一直无法生成，谷歌后发现，不知道是的还是设置问题，拖入到工程中的文件，还需手动勾选 ，在界面右侧导航栏，勾选后就能生成对应的接口文件了。 编写处理接口在生成的对应接口文件中，可以了解对应的模型类名称和接口函数
    {  主处理函数
      =   首先定义并初始化模型
      定义返回错误
      =    将输入图像到
      =     图像得到，此即模型输入大小
      =   将转到
      =    前向计算得到输出
      =  {

               
             
    }


       =  
       输出类名

}

   {
    
        
      = 
    
     
}

  {
       ||   
    {
               
          
    }
      =     
      =   

      =  
    

     
}
    {
      = 
      =  
                               
                               
                             

      = 

      = 
      = 


      = 
                                          
                                          
                                          _
                                          __  
                                          

     ==    = 

     
      = 
     = 

      = 

      = 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
    
     
     
                                           
                                           
                                           
                       
    
    

     

     
}
能够为每个模型生成对应的接口函数，极大程度的减少了调用成本，除去图像处理步骤，核心代码只有两句：定义模型：  =   前向计算：  =   是不是很意外？很惊喜？如此一来调用起来简直快捷方便，为开发者提供了极大的便利。
体验下来发现，精度基本与原始无损，速度由于目前只在上进行了测试，模型处理耗时约，可以大概确定的是，苹果内部应该没有对模型参数进行量化等操作，主要应该还是只对原始浮点型运算进行了相应的硬件加速，正在研究如何设置开启多核和使用，但仅若是单核，此处理速度也算不上是特别惊艳，也许苹果还有所保留，估计会逐步开放提升其前向运算能力。本文作者： 

市面上现在流行两种沙箱模式一种是使用还有一种是直接在页面上使用   进行执行。 殊途同归主要还是防止一些们 吃饱了没事干收别人钱来  你的网站。 一般情况 我们的代码量有业务安全 剩下的就看天意了。接下来我们来一步一步分析如果做到在前端的沙箱文末 看俺有没有心情放一个彩蛋吧。
直接嵌套
这种方式说起来并不是什么特别好的点子因为需要花费比较多的精力在安全性上
执行
最简单的方式就是使用进行代码的执行  
 但如果你是直接这么使用的话    因为 的特性是如果当前域里面没有则会向上遍历一直到最顶层的  比如以及他还可以访问内的变量看
 
{
    = 
   =  {   }  相当于直接
}

 =  
    
    
 那有没有什么办法可以解决这个特性呢？ 答 没有 除非你不用 那我就不用 我们这里就可以使用  来代替。
 
 就是用来放回一个 的 用法参考  所以上面的代码放在 中可以写为    
 这样做在安全性上和没有多大的差别不过他不能访问的变量即通过来调用而且他的性能比要好很多 那有没有办法解决 的办法呢？ 有啊 只是有点复杂先用在用

这个特性也算是一个比较鸡肋的他和并列为两大特性 不说无用 还多安全性就没谁了 但是 的套路总是有人喜欢的在这里我们就需要使用到他的特性因为在的里面所有的变量都会先从定义的上查找一遍。
   = {
    
}
  =
{
     等价于
}
 所以第一步改写上面的 将里面变量的获取途径控制在自己的手里。
    {  
   =   {    }
     
}
 这样所有的内容多会从这个上面获取但是找不到的则又会向上进行搜索 为了解决这个问题则需要使用 

 提供的特性说起来也是蛮牛逼的 可以将获取对象上的所有方式改写具体用法可以参考 超好用的 这里我们只要将给换掉即可 有的就好没有的就返回
   {
   =   {    }
    =   

     {
      =   {}
     
  }
}

 相当于检查 获取的变量是否在里面  
    {
   
}


 这样的话就能完美的解决掉 向上查找变量的烦恼了。 另外一些，大神发现在新的里面有些方法是不会被  影响的 这里主要是通过 这个特性来检测的比如
  
      
    
 不过经过本人测试发现也只有上面带有这个属性 尴尬 所以一般而言我们可以加上  也可以不加。
  还是加一下吧
   {  
   =   {    }
    =   

     {
      =   { }
     
  }
}

    {  
   
}

    {  
 这样访问里面的  之类的方法就可以保证安全 算了就当我没说真的没啥用
    ===   
   
}
 现在基本上就可以宣告你的代码是 的位安全数反正不是就行
设置缓存
如果上代码每次编译一次时都会实例一次 这样做会比较损性能 所以我们这里可以使用来进行缓存。 上面生成代码改写为
   {
     =   {    }
      =   

       {
         
    }

       {
          ===   
         
    }

      {
         _ 
          {
              == _ {
                _ = 
                 =   {   }
            }
             
        }
    }
}
 不过上面这样的缓存机制有个弊端就是不能存储多个 不过你可以使用来解决或者更好的使用 这里我们两个都不用用来解决这个  主要的问题在于他可以完美的实现内部变量和外部的内容的统一 最大的特点在于他存储的值是不会被垃圾回收机制关注的 说白了 引用变量的次数是不会算在引用垃圾回收机制里 而且 如果存储的值在外部被垃圾回收装置回收了里面的值也会被删除同步效果所以毫无意外 是我们最好的一个 则代码可以写为
  =  
  {
     =   {    }
      =   

       {
         
    }

       {
          ===   
         
    }
      {
          {
              =   {   }
             
        }
         
    }
}
 差不多了 如果不嫌写的丑可以直接拿去用如果出事纯属巧合本人概不负责
接着我们来看一下如果使用来实现代码的编译 这里就是使用这种办法
 嵌套
最简单的方式就是使用属性 该属性可以说是真正的沙盒 把加载里面那么你这个基本上就是个标签而已 而且支持性也挺棒的比如   =””
 这样已添加那么下面的事你都不可以做了
 脚本不能执行
 不能发送请求
 不能使用本地存储，即等
 不能创建新的弹窗和 比如  =_
 不能发送表单
 不能加载额外插件比如等
 不能执行自动播放的 比如  
 看到这里，我也是醉了。 好好的一个，你这样是不是有点过分了。 不过，你可以放宽一点权限。在里面进行一些简单设置  =”” =””
 常用的配置项有



配置
效果





允许进行提交表单



运行执行脚本



允许同域请求比如



允许能够主导进行页面跳转



允许中弹出新窗口比如=_



在中可以锁定鼠标，主要和鼠标锁定有关



可以通过在里，添加允许进行的权限  =”  ” =””
 这样，就可以保证脚本的执行，但是禁止里的执行 = 。 更多详细的内容请参考    
接下来我们来具体讲解如果使用来  里面的原理还是用到了
 脚本执行
上面说到我们需要使用进行方法的执行所以需要在上面添加上 的属性当然你也可以使用  这个随你 这里的框架是使用 一个用来通信一个用来执行 先看代码
  
 

 
    
   
        {
      相当于
        = 
         = 
        {
          = 
       }   {
          =    
       }
         就是原来的
        
     }
   
 

 这里顺便插播一下关于的相关知识点
 讲解
主要做的事情有三个
页面和其打开的新窗口的数据传递

多窗口之间消息传递

页面与嵌套的消息传递
 具体的格式为   
 是传递的信息指定的窗口内容取值为 表示是否可以用来对进行序列化相当于 不过一般情况下传时会自己先使用进行一遍 具体说一下 的写入格式一般为即  另外也可以写为 用来表示 传到任意的标签页中 另外就是接受端的参数接受传递的信息一般是使用监听事件
  

 
{
    =  ||            
    == 
    

   
}
 里面会带上个参数

 传递过来的数据 
 发送信息的 比如 
 发送信息的源页面的对象 我们实际上只能从上面获取信息

该常常用在和的信息交流当中 现在我们回到上面的内容
  
 

 
    
   
        {
      相当于
        = 
         = 
        {
          = 
       }   {
          =    
       }
         就是原来的
        
     }
   
 

 里面已经做好文档的监听然后我们现在需要进行内容的发送直接在写入
 部分
 =
 =    
 设置基本的安全特性
 =
        =
        =

 部分
  {
    = 
    = 
     只想同源的标签页发送
}

 

 同时设置接受部分

      {
        = 
       进行信息来源的验证
        ===    === 
           
    }
 实际可以参考 
常用的两种沙箱模式这里差不多讲解完了 开头说了文末有个彩蛋这个彩蛋就是使用来做一下沙箱 比如像 牛客网的代码验证就是放在后端去做代码的沙箱验证
彩蛋沙箱
使用的沙箱很简单就是使用提供的 即可 直接看代码吧
   = 
  = {     }
 =    
  =  

 在构建出来的里面没有任何可以访问的全局变量除了基本的

原文链接：最近我在复习《软件测试的基础知识》，在边学习边总结的过程中，我把我的笔记贴出来做一个学习记录。今天要讲的话题是我在早上来上班的地铁上整理出关于黑盒测试的相关理解。
一什么是黑盒测试？
黑盒测试：其实是测试中把我们的被测软件或者系统看成一个不能打开的盒子，在完全不考虑程序内部结构和内部特性的情况下，通过相关暴露出来的接口对程序进行测试。
黑盒测试只检查程序的功能是否按照我们的需求规格说明的规定，能正常的使用；能够有正确的输入输出信息。着眼于程序的外部结构，不考虑程序的内部的逻辑。
一般来说关注对软件的界面和可见的功能。从用户的视角，通过不同的数据或者事件驱动系统，通过输出结果进行判断。
二黑盒测试的优缺点？
优点：    容易实施，不需要关注内部实现    更贴近用户的实用角度
缺点：    测试覆盖率较低，一般只能覆盖到代码的    针对黑盒的自动化测试，复用率较低，维护成本较高。
 一般我们的软件产品在研发迭代过程中，最容易变化的就是功能。所以说特别是界面的产品，或者互联网的产品非常频繁的变化，今天搞个活动，明天搞个升级，变化非常快。所以针对功能的自动化测试，测试用例重复的利用率较低，功能频繁变，脚本的维护成本代价相对比较大。
三黑盒测试主要测试什么？
是否有不正确的或遗漏的功能？在接口上，输入是否能正确的接受？能否输出正确的结果？是否有数据结构错误或者外部信息例如数据文件访问错误？性能上是否能满足要求？
四黑盒测试的主要设计方法？
我们在写测试用例的时候，要围绕需求要点，考虑用户不同的复杂场景用下图的设计测试用例方法，尽可能细致的写出用例。常见的用例设计方法如下图：

 善于做笔记，总会有收获

相关推荐
【腾讯】测试分析？就这么简单！
测试工具用法小结
注册即可领取代金券，实名认证后优惠再升级作者微信：


泡沫前，我们怎么办？这是《中美两国人工智能产业发展全面解读》课题时候遇到的一个沉甸甸的问题。
无论中美，全球许多国家都对充满了憧憬与渴望。人们坚信，一个新的世界即将到来。人工智能是当前人类所面对的最为重要的技术社会变革，可谓是互联网诞生以来的第二次技术社会形态在全球的萌芽。
所谓人工智能，是人类在利用和改造“机器”的过程中所掌握的物质手段、方法和知识等各种活动方式的总和。赋予了机器一定的视听感知和思考能力，不仅会促进生产力的发展，而且也会对经济与社会的运行方式产生积极作用。
但是，站在新世界起点，我们也看到一些似曾相识的情形，作为见证过互联网发展热潮的人，不免会发现现在的领域像极了当年的互联网在年勃兴两年后又遇到寒冬的情形。近年来厚积薄发，主要因深度学习获得了突破，创业和投资由此情绪高涨。
我们要保持冷静的认知。深度学习仍有难以克服的缺陷。接下来几年，你发现投资越来越多，公司越来越少，项目越来越贵，而深度学习自身的不足并没有快速得到解决，商业化之路其实有点力不从心。
在行业即将出现泡沫的时候，不宜设定过高的期望。美国积余年之功，全面领先全球，其他国家的创新尚处于萌芽阶段。赶英超美，并非朝夕可成，我们需要把有限的资源用到核心环节上，方能在未来占有一席之地。
中美顶层设计相仿
一种乐观观点认为，人工智能的发展将在年内深刻改变人类社会生活、改变世界，因此，中美两国均在为这一时代的到来积极准备，在顶层设计方面有许多堪可玩味的地方。
从顶层设计来看，中美有近乎相仿的重视程度。
第一，美国和中国政府都把人工智能当作未来战略的主导，出台发展战略规划，从国家战略层面进行整体推进。美国人工智能报告体现了美国政府对新时代维持自身领先优势的战略导向。作为最大的发展中国家，中国也在战略引导和项目实施上做了整体规划和部署。
第二，美国和中国都在国家层面建立了相对完整的研发促进机制，整体推进人工智能发展。但在应用系统中，美国走的较远，已经开始将装备到军事领域。
第三，美国一直处在人工智能基础研究的前沿，保持全球领先地位。中国在全球跻身第一梯队，但在基础算法和理论研究方面，与美国还有相当大的差距。
产业真实差距较大

但从产业发展实际情况来看，情形就显得不那么乐观了。本报告进行了七个维度的全面对比，结果非常出人意料。完全没有发现可以弯道超车的迹象，实际上中国只在局部有所突破。
第一，美国的企业数量遥遥领先全球。
在全球范围内，人工智能领先的国家主要有美国、中国及其他发达国家。截止到年月，全球人工智能企业总数达到家，其中美国拥有 家，占据；中国其次，拥有家，占据。中美两国相差家。其余家企业分布在瑞典、新加坡、日本、英国、澳大利亚、以色列、印度等国家。
从企业历史统计来看，美国人工智能企业的发展早于中国年。美国最早从年萌芽；进入发展期；后开始高速成长期；后发展趋稳。中国企业诞生于年，年产业进入发展期。在年达到峰值后进入平稳期。
第二，美国全产业布局，而中国只在局部有所突破。
美国产业布局全面领先，在基础层、技术层和应用层，尤其是在算法、芯片和数据等产业核心领域，积累了强大的技术创新优势，各层级企业数量全面领先中国。
基础层主要为处理器芯片企业数量来看，中国拥有家，美国家，中国仅为美国的。
技术层自然语言处理计算机视觉与图像技术平台，中国拥有家，美国拥有家，中国为美国的。
应用层机器学习应用智能无人机智能机器人自动驾驶辅助驾驶语音识别，中国拥有家，美国拥有家，中国是美国。
第三，从人才队伍来看，美国梯队完整，中国参差不齐。
产业的竞争，说到底是人才和知识储备的竞争。只有投入更多的科研人员，不断加强基础研究，才会获得更多的智能技术。
美国研究者更关注基础研究，人工智能人才培养体系扎实，研究型人才优势显著。具体来看，在基础学科建设、专利及论文发表、高端研发人才、创业投资和领军企业等关键环节上，美国形成了能够持久领军世界的格局。
美国产业人才总量约是中国的两倍。美国家人工智能企业约有名员工，中国家公司中约有位员工，约为美国的。
美国基础层人才数量是中国的倍。美国团队人数在处理器芯片，机器学习应用，自然语言处理，智能无人机大热点领域全面压制中国。
在研究领域，近年来中国在人工智能领域的论文和专利数量保持高速增长，已进入第一梯队。相较而言，中国在人工智能需要在研发费用和研发人员规模上的持续投入，加大基础学科的人才培养，尤其是算法和算力领域。
第四，从行业热点领域来看，中美各有优势。
深度学习引领了本轮发展热潮。究其原因，在于算力和数据在近十年来获得了重大的突破。当下，人工智能产业出现了九大发展热点领域，分别是芯片、自然语言处理、语音识别、机器学习应用、计算机视觉与图像、技术平台、智能无人机、智能机器人、自动驾驶。
在美国创业公司中排名前三的领域为：自然语言处理家，机器学习应用  家，以及计算机视觉与图像家。
在中国创业公司中排名前三的领域为：计算机视觉与图像家，智能机器人家以及自然语言处理家。
第五，从投资趋势来看，中美差异较大。美国投入资本雄厚，中国这种近些年奋起直追。
自年美国第一笔人工智能风险投资出现以后，全球加速发展，在年内，投资到人工智能领域风险资金累计亿元。
截止至目前，美国达到亿元，在融资金额上领先中国，占据全球总融资；中国仅次于美国，亿，占据全球；其他国家合计占。
中国的亿美元级大型投资热度高于美国，共有笔，总计亿元。美国超过亿美元的融资一共笔，总计亿，超过中国亿。
第六，从创业投资领域角度来看，美国面向全产业投资，投资领域遍及基础层、技术层和应用层，而中国接受融资的企业主要集中在应用层。
中国人工智能企业中，融资占比排名前三的领域为计算机视觉，融资亿元，占比；自然语音处理，融资亿元，占比以及自动驾驶辅助驾驶融资亿元，占比。中国的自动驾驶辅助驾驶企业虽然数量不多，只有家，而融资额却是第三，意味着中国的投资者非常看好这一领域。
美国融资可能在年前突破亿。预计在年之前，美国累计公司数量将会超过家，累计融资将达到惊人的亿人民币。
中国企业增势不明朗。根据行业发展周期来计算，中国人工智能产业将会在年回暖，新增公司数量会上扬到以上，预期融资累计量将会达到亿人民币，仍和美国有较大差距。
第七，从主导产业发展的巨头实力来看，美国具有先发优势。
由于产业核心技术掌握在巨头企业手里，巨头企业在产业中的资源和布局，都是创业公司所无法比拟的。因而引领产业发展的技术竞赛，主要是巨头之间的角力。
当前，苹果、谷歌、微软、亚马逊、脸书，这五大科技巨头无一例外投入越来越多资源抢占人工智能市场，甚至整体转型为人工智能驱动的公司。国内互联网领军者“”也将人工智能作为重点战略，凭借自身优势，积极布局人工智能领域。
巨头通过招募高端人才、组建实验室等方式加快关键技术研发。同时，通过持续收购新兴创业公司，争夺人才与技术，并通过开源技术平台，构建生态体系。
出现泡沫的信号

行业泡沫即将出现。主要信号有两个：
一是资金多而项目缺。
具体到美国未来趋势而言，美国领域的融资可能在年前突破亿。原因在于特朗普上台后采取了一系列改革措施，促进了美国经济的恢复。美国资本迅速回流，资本市场正在加大对企业的投资。由此推动美国产业融资持续上升。预计在年之前，美国累计公司数量将会超过家，累计融资将达到惊人的亿人民币。
具体到中国来看，中国企业增势不明朗，但资金仍在增加。
根据历史数据推断，中国在年成立的新公司将不超过家，融资增长也较前两年放缓，预计融资总额将会在年年末达到亿，是美国同期预计值的。从行业发展周期来看，中国人工智能产业将会在年回暖，当年新增公司数量会上扬到家以上，预期融资累计量将会达到亿人民币，整体上仍和美国有较大差距。
在这段时期内，创投圈将会发现，找到一个新的有潜力的项目越来越难，由于新增企业数量稀少，经常只能跟投一些项目。
二是周期长而营收难。
通俗的说，现在的人工智能市场被高估了。深度学习起源于上世纪八九十年代的神经网络研究。在很多情况下，前沿研究是由对已有方法的微小改动和改进组成，而这些方法在几十年就已经被设计出来了。
尽管如此，市场热炒的人工智能技术和产品的成熟度仍然有限。许多项目和技术，并不能直接获得消费者欢迎，还需要相当长的时间才能走向成熟。
这种前提下，创业项目不得不舍弃大众消费场而致力于解决企业级问题，创新公司的商业模式回归到类似传统厂商的角色，进一步加大了营收难度。
综合来看，资金多而项目缺，周期长而营收难，项目却一天比一天更加昂贵，这是资本泡沫即将出现的信号。但对于创业公司，它们将过上一段顺风顺水的好日子。
中国未来在哪里？
放眼技术社会变迁，时代联盟一统江山；互联网时代，谷歌、亚马逊异军突起雄霸天下；移动时代，又有苹果谷歌引领世界潮流。
现在，人工智能正在缓缓揭开时代变迁的新篇章。
人工智能拥有令人难以置信的力量，可以全面提升一个国家的实力。中国政府高度重视产业发展战略，中国正在快速形成商业应用开发能力，行业创投领域正在紧追美国，并在应用层的一些领域显现出竞争实力，部分指标达到了与美国相近的水平。
与互联网相似，中国将会成为应用的最大市场，拥有丰富的应用场景，拥有全球最多的用户和活跃的数据生产主体。我们需要进一步加大基础学科建设和人才培养，以便让中国有机会走得更远。
国家实力的提升来源于科技企业创新。美国以绝对实力处于领先地位，一批中国初创企业也在蓄势待发。时代未来必然也会产生类似英特尔、微软、谷歌、苹果这样的全球级企业。我们相信中国企业有机会成为人工智能时代的弄潮儿，在领域占有一席之地。
群雄逐鹿，天下未定，机遇和挑战同在。
多些实干，少些浮躁。
让我们保持冷静的头脑，见证这个伟大的时代吧。

接下来，腾讯研究院联合桔子即将推出中美产业创投研究报告，更多一手数据披露，告诉你一个不同的产业真相。欢迎各位关注腾讯研究院公号，抢先收获一手资料！
中美产业创投真相

研究团队与数据说明
课题团队与分工：

数据采用和处理说明
本文从政策、企业、项目、投资、巨头，应用，人才等多个维度对中美进行了最完整的对比和分析，力图展现出中美各个角度的差异并以此来分析中国未来人工智能企业的走向和趋势。
对 ， ，， 等国内外九大专业数据库进行了详细比对，确定了 和桔子为基准，并以此进行数据清洗和处理。
数据统计截止：年月
我们对每一个公司信息都进行了复审、整理和添加标签等以确保数据的准确统一性，在剔除了异常数据后，最终确定了中国公司数量家，美国家，分为个领域，大层面的数据框架。这些数据以创业公司为主，著名的巨头公司则予以专文分析。
在经过多次讨论和考证，汇总多方专家意见后，根据基础层，技术层和应用层三个产业层面的划分，最终确认了人工智能领域的九大热门领域。
请点击文末附件下载《中美两国人工智能产业发展全面解读》报告精简版，报告全文近期会在知乎电子书发布，敬请关注。推荐 ： 胡永波翻译 ： _成龙编辑 ： 鸽子

有两个身份，但她只在上公开了其中一个。
作为一名性工作者，她非常希望将自己作为普通人的生活，和作为性工作者的生活分隔开来，互不干扰，避免自己遭受羞辱、逮捕甚至专业的反击，以及避免那些可能的纠缠不休或更糟的客户。
她在上公开的”真实身份”为：本文使用名称均为化名，居住地加利福尼亚州，她经常发表一些关于政治的帖子。
为了保护自己性工作者的身份在社交网络上不被人知晓，她一直小心翼翼，坚持使用不同的电子邮件地址，不同的电话号码和不同的网络昵称。
今年早些时候，当她看到自动推荐的”你可能认识的人”的时候，非常震惊地发现，居然可以在里面看到她作为性工作者曾经服务过的一些客户。
尽管她已经竭力保持不让自己性工作者的身份暴露到中，但没想到依然发现了她的秘密。
更令人恐惧的是，这些人也有可能在”你可能认识的人”中，知道她的日常身份。 
但因为一直没有公开，其是如何将一个用户和另一个用户联系到一起，所采用的方法和数据，因此，也无从知晓她的身份是如何在互联网上被辨别出来的，应该如何采取措施来防止这样的事件再次发生。
 “不仅仅是性工作者要小心保护自己的身份，”通过对的记者说到。 
继续说道，“那些与性工作者发生过关系的人，也对保护自己的身份信息十分在意，所以他们也常常使用替代的电子邮件和替代昵称。
在进行色情交易时，虽然他们也交换电话，但这只有在他们想和人发生性关系的时候，才会使用的电话号码。跟日常的电话号码完全不一样。总的来说，客户和性工作者双方对于安全性都比较在意，大家都不想透露身份。
可是万万没想到，掩盖那么好，竟然还是被发现了，还被悄悄地连接了起来，最恐怖的是，还都是各自的真实身份。真是要命啊！”
这些性工作者都有自己的秘密支援团队。
当在秘密支援团队中咨询自己该怎么办时，团队中相当多的人也表示同感——他们有同样的遭遇。

“我们的预防措施那也是相当到位了，电话号码都是专用的，真是见鬼了，居然在上给联系上了，还他¥妈¥的显示各自的真实姓名和工作？你……¥大¥爷¥的，以后出事了叫我怎么有脸见人？”秘密支援团队的另一个人抱怨到。

说：“性工作者，最恐怖的噩梦就是把你的真实姓名留在那里，这样把人连接起来，让这个噩梦成真了。” 
 那么，到底是如何做到的呢？
至今为止，并没有将“你可能认识的人”到底用的什么推荐算法，进行公开这个算法在内部称为黑匣子。一直强调，其推荐的建议“来自”共同好友，共享网络或群组，或用户上传的联系人。
然而，这样的说法，经不起考验。
发言人今年夏天曾告诉记者，参考的因素超过了项。所有像这样的人——即和客户没有任何共同好友，共享网络或群组，或者联系人关系，却被算法判定为可能认识的人——他们竟然能被推荐认识，其数据一定来自其他方面。
怀疑收集了手机上其他应用的联系信息，或者使用了她位置信息，从而发现她和她的客户的智能手机同时出现在同一个地方。
但是的发言人通过电子邮件否认了这件事。
邮件写道：”我们不会使用第三方应用程序中的信息来作为”您可能认识的人”中的朋友建议的参考。 之前也已经说过，”你可能认识的人”的推荐算法并不会使用位置信息作为参考因素。
虽然的发言人对这一问题进行了坚决的否认，但我们在上发现，南加利福尼亚大学信息科学研究所的研究人员 的一篇的回答已经被前顾问悄悄点了赞。
这篇点赞量，浏览量将近万的回答表示，如果双方都对开放了位置权限不管是在移动端还是在网页端，并且多次访问过相同的地方。那么的推荐系统便会使用你们在相同地点的共同事件和发生频率在提供好友建议。
比如，你访问了、、、、、，你的邻居访问了、、、、、。在这种情况下，、、就是你们共同访问的共同场所。那么你们两个就很有可能会互相认识，因为你们都访问过类似的地方特别是在同一时间。
现在让我们慢慢的增加访问次数

现在，因为你们两人都曾多次访问这些地点，这就增加了你们互相了解的可能性。在这里因为访问频率超出其他，所以很可能被判定为你的家。
当然，除了单纯的位置因素，也有很多其他和位置有关的因素，比如位置语义信息，可以用来推荐。举个例子，例如，如果你和某个人同时访问了某个特定的地点，那么你们就很可能有相似的兴趣，并且可能会愿意成为朋友。
如果你对详细的技术算法感兴趣，还可以参考南加州大学的这篇论文：一种从时空数据推断社会关系的基于熵的模型

 

无独有偶，年月，刊登在上的一篇文章，似乎也将矛头指向推荐系统中所透露的地理位置信息。
在这篇名为《          》 建议精神病医生与病人相互交往的文章中，是一位精神病医生，他的病人，都是一些身心发育有严重问题的患者，这里面包括艾滋病患者，自杀倾向严重的抑郁症患者，有暴力倾向的狂躁症患者
为了保护患者隐私，她在中从来没有将有关任何病人的任何资料，以及任何相关的内容放上去，可是，突然从某天开始，她所有患者的全名和个人资料开始出现在她的好友推荐里。
她无比惊讶，不知道是怎么做到的。
有分析称，正是因为通过智能手机定位发现了这些秘密。因为，她和她的病人都在同一个地方，同一个时间出现，并且反复出现。
看来，关于第三方应用的信息使用与否，看来发言人的回复也不是那么可信 。而在另一个赞，万浏览量的回答里，答主 表示，其实早在年的时候，就收购了。而至于为什么要收购，其原因正是获取数据，并用于推荐系统。读者也可以参考这篇文章

          

这些数据公司悄悄获取你的各种邮件和其他应用程序，以及联系人列表，并以此将你与其他人进行连接。
比如：

通过邮件列表匹配的方式：也许你邻居的账号只在你的新账号联系人列表里保存着，但在你的旧账号中，因为你的名字和你的新账号一样，因此你的邻居就有可能通过这样的方式和你的旧邮箱匹配到一起。
通过应用程序匹配的方式，可以这样理解，在启动后，会将手机当前位置和当前手机通讯录内容搜集起来，进行匹配。
而通过将上述几种方式匹配的结果结合起来，再进一步组成社会关系网，你们共同的朋友，朋友的朋友也就可以被计算出来

基于这些数据，他们就能够对谁可能是你可能认识的人做出有力的判断。
还有用户发现，同为旗下的中的联系人信息也可能已经被在内部“共享”了。
当用户在中同一些人交换过文件之后，的好友推荐列表里就会出现这些人。
此外，很可能还会搜集用户的搜索数据。
那些在上搜索过你的人哪怕他们删除了搜索记录，这依然可以作为活动日志被找到、那些在朋友的照片或相册中标记过你的人、拥有大量共同好友的人、隶属于同一个社交网络学校、工作、城市等、参加过同样的活动或者链接到同一个媒体账号的朋友，甚至于那些被你拉黑的人的朋友都有可能被列入“你可能认识的人”列表中。
而且这些建议不仅仅是基于“搜索”，用户设备上的其他程序和应用中出现的任何地方的名字都可以被的算法所识别。
可以访问其正在使用的设备，笔记本电脑，手机上可能包含某人姓名的任何内容，然后将该人标记为“可能认识的人”。例如，当我将日历用于我的商务约会时，会向我建议的“你可能认识的人”中很多来自我最近在日历中约定的客户。
回到的例子。
无论 所采用的算法究竟工作原理是什么，这样的机制，很有可能会对性工作者和色情行业的人造成严重后果。
在这个隐私权极其被看中的圈子，每一次精准推荐都会让当事人战栗。
是加利福尼亚的一个成人内容表演者，他说到一件令所有人最为尴尬的事件，那就是：当性工作者的账户被推荐给了他们在现实生活中认识的亲人、朋友时，那种丢人，让人恨不得找个地缝钻起来。
在网站负责管理虚拟现实成人广播，他从事色情行业已经有八年之久，但她的家人不知道。
“我不希望因为我在上的帐户被推荐给亲人，让我岁的表弟发现我竟然是一个色情明星。”说道。
为了避免这种情况，她几乎每隔几周就会在上搜索一次家人和家族成员的姓名，看看她的亲戚是否已经加入了，或创建了一个新帐户。如果有的话，就赶紧拉黑他们。
曾经用她的真实身份注册过第二个私人账号，用于和她在正常生活中认识的人进行联络，但是有些她在色情网站上的粉丝却在“可能认识的人”中推荐给了她的这个正常的私人号，从而让粉丝们知道了她真实身份。
她说，从那以后，这些人开始骚扰她，并试图跟踪她的家人。
“我们正生活在一个恐怖的时代，你都不知道个人信息是怎么泄露的，泄露后又是如何被别人当作武器来攻击你”，说，她不知道是如何将她是色情工作者的身份与她公开的身份联系起来。于是，她不得不删除了她的私人账号。“我对于无时无刻不在收集着我的信息，简直不安。”
“对于性工作者来说，这是一个巨大的威胁，生死攸关的大事，”说。

原文地址前言
腾讯云对大学生有元云主机的优惠项目，就买了一个，开启了我的云端之旅。搭建博客是技术宅的入门必备技能。所以就从最简单的  开始练手吧。整个过程顺利的话只需要十来分钟。
首先了解一下什么是：
 =      
如果对安装不太了解：

安装过程要选择  的都选 

忘记上一步输过什么可以用键盘的 ↑↓ 进行查看

句子开头是表示一条新的命令，句子后面的后面的内容表示注释

下面的地址使用你自己的公网，在云主机信息上可以看到


 安装
   配置文件处于
   启动
    设置为开机启动

测试：你的公网 打开公网  可看到  的页面。
 安装
  
   |  “”
    安装社区版，快可分钟，慢或分钟

    启动
__  安全安装，密码初始为空，自己设置

  
   创建数据库
 
 或者

 安装
安装
   
    启动
    设置开机启动

 
   
在登录主机
菜单选项编辑器默认编码，选择 
设置好：高级验证密钥文件
密码是云主机的密码，修改密码要先关机
修改配置文件
打开下的，其中部分修改如下：
 {
            _
            _
    _  
             

            
     

      {
         
        _   
    }

       

      \|||||||||||||||||||||||||||||| {
                _  __   
    }

      \ {
        _  =
        ___ \
        _ 
        _ 
        _ _ ___
         _
    }

}
保存后重载
  
在 目录中创建 
测试： 或者解析好的域名 可以看到   
安装
搭建站点
下载并解压好安装包，用将下的文件夹和文件全部上传到目录下。修改的  数据库信息，里面  主机就填 ，而不是公网之类的。
保存后访问  填写站点信息，接近成功了！
权限设置
但是会发现写博时不能上传图片，后台不能安装插件和主题，这时候就是权限问题。
文件最后加上下面这句：
‘_’ “”
再去执行命令
    这里的是递归子目录、文件
  
相关推荐
【腾讯云的种玩法】云服务器搭建环境【腾讯云的种玩法】搭建属于自己的服务器接系列文章
《 海量之道系列文章之弱联网优化 一》《 海量之道系列文章之弱联网优化 二》《 海量之道系列文章之弱联网优化 三》
前面我们在介绍基础理论知识的时候，【图九 链接建立、传输和关闭示意】中最后四个数据报文就是链接关闭的过程，俗称四次挥手，分手总是难以割舍的，所以链接建立只需三次握手，分手得要四次回首。
设计目标是可靠传输，哪怕在分手时也得确保成功。为此，在链接关闭阶段设计了繁杂的状态机，在【图十四 状态变迁图】的左下角虚线框中的四个状态_、_、、_，代表着主动关闭链接这一方的可能状态，前三个状态最终都会进入到等待响应最后一个的的这个阶段，即_状态，并且在此停留倍  ，倍报文段最大生存时间，规定为分钟， 中协议栈采用的是秒，这个值的选择是有讲究的，它是一个物理上的约束，表示一个数据报文在地球上最长的存活时间，意思就是即便收不到这个，也会给时间让它最终在地球的某个角落里消失时长。这样处理的原因是在四次挥手过程中，主动关闭方需要确保自己最后发送响应对端的能被对端收到，如果对端出现超时重传了，则意味着自己上次发的丢失了，那么自己还有机会再次发送确认，乘以就是为了给重传的充裕的到达时间。
真是太缠绵了，感天动地。在创造的年代，窄带宽、高时延、不稳定的网络状态，这样的设计相当必要，要分手也得大家都确认才行，爱情片里太多这样的误会了，不学习网络知识生活中是要吃大亏的。
 
【图十四 状态变迁图】
回归正题，前面的基础知识告诉我们，只有链接的主动关闭方会进入_状态，这会给链接主动关闭方所在的协议栈带来什么样的影响呢。归纳一下主要有两个方面：
        协议栈随机端口资源耗尽
铺垫一个基础知识：对每个链接用一个四元组来唯一标识，分别是源、目标、源端口、目标端口。通常在使用一个特定的目标服务时，目标即服务器和目标端口即服务器知名私有端口是固定的，源通常也是固定的，因此链接主动发起方的最大数量就由源端口的最大数量决定， 规定端口号是无符号短整型，那么这个最大值就是。
假设一个服务器即作为链接的主动打开方通常是作为客户端角色，它使用本地随机分配的临时端口又是链接的主动关闭方，则大量主动关闭的链接会进入到_状态，如果大伙在这个状态都折腾秒 缺省为秒，为秒，这台机器相关的资源会被快速占用、堆积并很快因为源端口的限制而耗尽，以后该协议栈上运行的其程序作为链接的主动打开方再想链接同一个目标服务器时，就只能等待释放，从应用角度来看就是链接建立失败，用户要承受精神和肉体双重折磨，无法接受。
        协议栈相关数据结构大量消耗内存
假设一个服务器作为链接的被动打开方通常是作为服务器角色和主动关闭方，则大量主动关闭的链接会进入到_状态，如果大伙在这个状态都折腾秒，本地机器协议栈维护的数据项会快速堆积并占用大量内核内存资源，最关键的是因为此时四元组碰撞概率极低因为源、源端口大多都是不同的，导致的积压几乎不受限制而野蛮生长，这对于一个高负载又要求高性能的服务器而言，感情上是相当痛苦的，肉体上勉强能接受。
基于以上分析，为了提高服务器网络效能，一些服务器选择配置启用快速回收真的需要配置吗，配置真的有效果吗，后面逐步会谈到来优化性能。然而，新的问题出现了，三藏说：看，现在是妹妹要救姐姐，等一会那个姐姐一定会救妹妹的恩恩怨怨何时了啊。
【问题】如果客户端通过同一个链接应用服务器时，客户端链接可能被拒绝或者无响应、响应缓慢。我们来具体分析一下成因，作为代理层面向服务器时，客户端侧的源会被收敛成的地址，通常有三种情况：
        为公网代理，比如公司内大伙用手机通过上网就属于这种模式，逻辑结构类似【图十五 客户端通过上网示意】。另有一点背景交待：我们上网冲浪时发起的链接绝大多数都是短链接；

【图十五 客户端通过上网示意】
        为后端服务器集群做四层或七层 以下简称，比如或的四层模式、的七层模式，典型场景是客户端请求经过转发到后端的服务器集群。与服务器集群之间大多也是采用短链接，逻辑结构类似【图十六 服务器通过做】；

【图十六 服务器通过做】
        上述第和第中情况的组合，具体可以参考【图十七 典型客户端连接服务器链路示意】，后面会有专门的讨论，此处不再赘述；
 的协议栈在开启链接_状态快速回收时，只需等待一个重传时间可能很短，甚至都来不及在 中看到_状态后就释放而无需等待通常的超时。被释放的链接的信息同时也就就清除了。那么，问题来了，如果短时间内有新的链接复用了这个，就有可能会因为收到之前已释放的链接上，因延迟而刚刚到达的，从而导致新链接被意外关闭。实际上，还会有链路被串接的问题。
为了规避这些问题，协议栈在快速回收释放后，又利用层协议栈中维护的链接对端数据结构信息中的对端、最后一次数据报文时间戳等信息注：对端端口信息此时已经在层被清除掉了，对链接通过快速回收和重用到新链接上做了一系列约束，在中有相应的描述。简单讲就是在同时满足以下条件时，不能重用从_状态快速回收的，此时的表现是不响应或对请求响应：
来自同一台机器的链接数据报文中携带时间戳字段；
之前同一台机器仅仅指，端口信息因链接被快速释放而缺失 的某个报文曾在秒之内到过本服务器；
新链接的时间戳小于机器上次到来时的时间戳；
条件已经相当苛刻，碰撞概率应该很低了。但由于只有的而缺少的端口信息作为判断链接另一端唯一性的约束，不能重用的概率便放大了倍。假设是一台单独的机器，问题不大，因为一台机器上的时间戳是单调增长的，一旦出现时光倒流，则可以确定是旧的数据报文延迟了，直接丢掉即可。但是，如果很多客户端通过同一台设备接入进来，那么问题就严重了，因为工作在四层的不会修改客户端发送的报文内的时间戳，而客户端们各自的时间戳又无法保持一致，服务器只认时间戳最大的那个，其它通通丢掉或者对请求直接响应，太冤了。
我们的业务服务中，典型模式是客户端使用短链接通过接入服务器使用业务服务，且这些接入服务器基本都是以方式在运行，接入服务器与业务服务器之间则大多为直接链接或通过代理调度，无论是有线互联网的架构，还是移动互联网的架构都是如此。客户端用户也大多数都是通过上网的。参考【图十七 典型客户端连接服务器链路示意】可以有更直观的了解。

【图十七 典型客户端连接服务器链路示意】
基于前述知识，我们以【图十七 典型客户端连接服务器链路示意】为基础来观察，可以分三种情况讨论快速回收配置参数的合理使用：
        链接主动打开方和主动关闭方均为客户端
         如服务器工作在七层且在公网提供服务，则它与服务器集群之间一般都是短链接，此时，服务器符合随机端口资源耗尽的模式。因为它的时间戳是单调递增的，故无需担心链接碰撞，符合 快速回收重用的条件，但由于服务器部署在公网对客户端提供服务，客户端有可能通过代理访问外部网络，便无法保证时间戳单调递增，故建议关闭快速回收选项；
         如服务器工作在四层模式，自身不受影响，故关闭快速回收选项；
         服务器集群与层级靠后的业务服务器之间大多都是短链接，服务器的情况与前述第点类似，如果它在七层服务器之后部署，且与层级靠后的业务服务器之间没有，则可以考虑启用快速回收选项，除此之外，都建议关闭快速回收选项；
        内网服务器业务服务器、逻辑代理服务器等之间有相互调用时，建议优先采用长链接方案。如果确实需要使用短链接方案时，则层级靠前的服务器往往即是链接的主动打开方，又是链接的主动关闭方，符合随机端口资源耗尽的模式。考虑到单台服务器能确保自己时间戳单调递增，开启__也能符合快速回收重用的条件，且不用担心碰撞，因此建议启用快速回收选项。这里需要注意两个特殊情况：
         如果层级靠前的服务器有一端直接在公网为客户端提供服务，而客户端有可能通过代理访问外部网络，则不宜启用快速回收选项；
         如果层级靠前的服务器与层级靠后的服务器之间有四层隔离，也需要谨慎考虑。除非服务器间系统时钟同步精准，能确保层级靠前的服务器集群总体时间戳在毫秒级的精度上能单调递增，否则建议关 闭快速回收选项；
        服务器集群被模拟客户端逻辑攻击，此时服务器会主动关闭链接，从而导致大量出现_状态，服务器因此符合协议栈相关数据结构内存大量消耗的模式但，考虑到客户端可能处在之后，建议保持关闭快速回收选项。我们应利用提前部署的安全机制在三次握手期间及早拒绝链接来解决此类问题；
服务端系统架构千变万化，较难穷举，总结一下上述的讨论：
        服务器如果直接在公网服务于客户端时，因为客户端有可能通过代理访问外部网络，故建议关闭快速回收选项；
        服务器各层级在内网互联时，同时作为链接的主动发起方和链接的主动关闭方，建议开启快速回收。上述建议例外场景是：如服务器层级之间有层，则需要考察层级靠前的服务器集群时钟同步的精度水平是否能到毫秒级，通常建议关闭快速回收选项；
【问题】转发的包时间戳有乱跳的情况，也会遇到类似问题的现象。因为现在的用户越来罕见，就不展开了；
⑥　协议：打开的_选项
协议栈为了提升传输效率，避免大量小的数据报文在网络中流窜造成拥塞，设计了一套相互协同的机制，那就是 和  。
算法 是以发明人 的名字来命名。 在年首次用这个算法来尝试解决福特汽车公司的网络拥塞问题 ，该问题的具体描述是：如果我们的应用程序一次产生个字节的数据典型的如、等应用，而这个个字节数据又以网络数据包的形式发送到远端服务器，那么就很容易使网络中有太多微小分组而导致过载。
因为传输个字节有效数据的微小分组却需花费个字节的额外开销即包头字节  包头字节，这种有效载荷利用率极其低下的情况被统称为愚蠢窗口症候群  ，前面我们在谈时也提到过，如果为一头猪开个大卡车跑一趟，也够愚钝的。对于轻负载广域网或者局域网来说，尚可接受，但是对于重负载的广域网而言，就极有可能引起网络拥塞导致瘫痪。
算法要求一个链接上最多只能有一个未被确认的小分组数据长度小于的数据包，在该分组的确认到达之前不能再发送其它小分组。此时如果应用层再有新的写入数据，协议栈会搜集这些小分组并缓存下来，待以下时机发出：
        收到接收端对前一个数据报文的确认；
        当前数据属于紧急数据；
        搜集的数据达到或超过；
【图十八 算法未开启和开启数据报文交互示意】对比了算法未开启左侧图示和开启右侧图示的数据报文交互过程。

【图十八 算法未开启和开启数据报文交互示意】
   也是为了类似的目的被设计出来的，它的作用就是延迟包的发送，使得协议栈有机会合并多个或者使可以随着响应数据一起返回，从而提高网络性能。  定义了一个超时机制，默认超时时间是，超过这个时间，则不再等待立即发送延迟的。
如果一个连接的一端启用了 ，而另一端启用了  ，而发送的数据包又比较小，则可能会出现这样的情况：发送端在等待接收端对上一个数据报文的才发送新的数据报文，而接收端则正好延迟了这个的发送，那么正要被发送的新数据报文也就同样被延迟了。
上述情况出现的前提是连接的发送端连续两次调用写接口，然后立即调用读接口时才会出现。那么为什么只有  时才会出现问题，我们可以分析一下 的伪代码：
      

      =      = 

        

  

            

               

    

        

     

   

 
代码显示，当待发送的数据比  小时，先判断此时是否还有未确认的数据报文，如果有则把当前写的数据放入写缓冲区，等待上个数据报文的到来。否则立即发送数据。对于的调用秩序，发送端第一个会被立刻发送，此时接收端  机制期待更多的数据到来，于是延迟的发送。发送端第二个会命中发送队列中还有未被确认的数据的逻辑，所以数据被缓存起来。这个时候，发送端在等待接收端的，接收端则延迟了这个，形成互相等待的局面。后面等到接收端延迟超时比如，接收端就会立即发出这个，这才能触使发送端缓存的数据报文被立即发出。
现代 协议栈默认几乎都启用了这两个功能。
我们在移动的设计实现中，请求大部分都很轻数据大小不超过，为了避免上述分析的问题，建议开启的_选项，同时，我们在编程时对写数据尤其要注意，一个有效指令做到一次完整写入后面会讲协议合并，是多个指令一次完整写入的设计思想，这样服务器会马上有响应数据返回，顺便也就捎上了。
接下文《 海量之道系列文章之弱联网优化 五》作者简介：朱海洋，高级工程师，增值产品部会员营收团队负责人，目前团队负责会员、靓号、、大王超会等项目，有丰富的前端架构经验。

导语
随着软硬件的发展，在和移动端浏览器上进行 开发的条件已经基本成熟了，出现了不少 库，是 库中的佼佼者。国内也有企业开始做一些应用尝试，某宝年双就用做了一个比较酷炫的宣传页面刷爆了朋友圈。
下图是用绘制的一个立方体动画的截图，在这个里，立方体会动态的旋转， 行代码就可以完成这么一个。让没有丰富编程经验的前端开发人员，也可以快速上手开发 应用。

是什么
官网对的介绍非常简单：“  ”。是一个跨平台的绘图标准，则是在浏览器上的一个实现。前端开发人员可以直接用接口进行编程，但只是非常基础的绘图，需要编程人员有很多的数学知识、绘图知识才能完成编程任务，而且代码量巨大。对进行了封装，让前端开发人员在不需要掌握很多数学知识和绘图知识的情况下，也能够轻松进行 开发，降低了门槛，同时大大提升了效率。
应用场景举例
、 游戏

、模型展示
下图的例子中，用户可以跟浏览器交互，通过鼠标操作度查看汽车，点击车门进入到车内，查看车内立体视图，如同身临其境。

、数据可视化

、 

的基本要素
编程跟编程有较大不同，因此需要掌握一些编程的基本概念。的基本要素包括以下几个方面：场景、相机、光、物体。
场景：是一个三维空间，所有物品的容器。可以把场景想象成一个空房间，接下来我们会往房间里面放要呈现的物体、相机、光源。相机：必须要有往场景中添加一个相机，相机用来确定观察位置、方向、角度，相机看到的内容，就是我们最终在屏幕上看到的内容。在程序运行过程中，可以调整相机的位置、方向、角度。想象一下，在房间里放了一个摄像机，你不在房间里面，但可以远程控制相机移动，摄像机传给远程电脑上展示出来的画面，就是在屏幕上呈现的画面。
光：假如没有光，摄像机看不到任何东西，因此需要往场景中添加光源。为了跟真实世界更加接近，支持模拟不同光源，展现不同光照效果，有点光源、平行光、聚光灯、环境光等。
物体：有了场景、相机、光，就可以往场景中放物体了，在中，物体由形状和材质两部分组成，形状决定物品的轮廓，材质则是物体的材料和质感。
渲染
绘制的东西，最终需要在屏幕一块矩形画布上显示出来。为了实现动画效果，我们需要有一个重绘机制。由于视神经元的反应速度问题，图像消失后仍然会在人眼残留秒，只要一秒内绘制的帧数超过就能实现流畅的动画效果。提供了重绘接口，我们有两种方式去调用接口实现重绘。一种是，以固定的时间间隔去调用，可以用于我们对渲染帧数要求比较高的场景，但事实上由于是单线程的，这种方式并不能保证相同的时间间隔调用，如果浏览器繁忙可能会导致的延迟执行；第二种方式是，让浏览器自行根据当前负载等情况决定何时重绘，达到最佳帧率。
位置
为了方便描述位置，引入了坐标系，使用的是右手坐标系，如下图所示。坐标系的原点位于渲染画布的几何中心。我们对物体的位置的描述，也是指物体的几何中心的位置。
相机
相机有正交投影相机和透视投影相机两种。透视投影跟人眼看到的世界是一样的，近大远小；正交投影则远近都是一样的大小，三维空间中平行的线，投影到二维空间也一定是平行的。大部分场景都适合使用透视投影相机，因为跟真实世界的观测效果一样；在制图、建模等场景适合使用正交投影相机，方便观察模型之间的大小比例。
中的相机跟真实世界的相机不完全一样，这里相机的可见区域是一个立方体，称为相机的示景体。
正交投影相机
示景体是一个长方体，由个参数确定：     ，这个参数规定了相机示景体的左、右、上、下、前、后六个面的位置。
透视投影相机
示景体是一个梯形体，由四个参数确定：   
是相机在竖直方向的张角，则是宽高比，即，通常设为画布的宽高比，和分别是近平面和远平面与相机的距离。
投影的大小
考虑一种比较简单的场景，相机示景体的远近平面和坐标系中的平面平行，从而示景体远近平面上的内容刚好可以垂直投影到画布上，并且示景体中与平面平行的任何一个平面，投影到画布上刚好等于画布大小。假如透视投影相机的近平面的大小为，远平面大小为，则一张大小的纸放在近平面上，投影到画布时刚好铺满整张画布；放到远平面上则只能占据画布面积的远平面的面积是近平面的倍。正是因为透视投影相机的示景体近小远大，才会导致同样一个物品放在不同位置显示出近大远小的效果。而正交投影相机因为远近平面大小一样，所以同一个物品距离相机的远近不影响物体在画布上投影展示的大小。
物体
物体由几何形状和材质组成。同样的几何形状，不同材质构成了不同物体，比如球状，有篮球、玻璃球、水晶球等。
形状
提供了一些常见的几何形状，有三维的也有二维的，三维的比如长方体、球体、圆柱体、环等，二维的比如长方形、圆形、扇形等。如果默认提供的形状不能满足需求，也可以自定义，通过定义顶点和顶点之间的连线绘制自定义几何形状，更复杂的模型还可以用建模软件建模后导入。
计算机是如何绘制几何形状的呢？我们知道，计算机只能绘制直线，那么曲线和形状如何绘制出来呢？
、绘制圆形。如下图所示，通过绘制多边形实现近似的圆形效果，当多边形的边数足够多的时候，两条边之间的过渡就显得平滑，多边形看起来就足够圆了。
、绘制模型。常用的做法是用三角形组成的网格来模拟，如下图所示，用足够多的三角形时，兔子的身体看起来就足够平滑，跟真实兔子比较接近。著名的斯坦福兔子模型用了个三角形。

材质
提供了几种比较有代表性的材质，常用的有漫反射、镜面反射两种材质，还可以引入外部图片，贴到物体表面，称为纹理贴图。
外部模型
现实世界丰富多彩，不是的几种默认几何形状和材质所能表达的，实际运用中，很多时候需要用到外部模型，通过建模软件构建物体的三维模型并导出模型文件，导入模型文件进行使用。

光照
光源主要是以下几种：、环境光，所有角度看到的亮度一样，通常用来为整个场景指定一个基础亮度，没有明确光源位置；、点光源，一个点发出的光源，照到不同物体表面的亮度线性递减；、平行光，亮度与光源和物体之间的距离无关，只与平行光的角度和物体所在平面有关；、聚光灯，投射出的是类似圆锥形的光线。
小结
本文对编程做了一下简单介绍，目的是让读者对编程有个基本认识。纸上得来终觉浅，绝知此事要躬行！建议到官网首页看看那些有趣的，着手写一些简单的进行实践。目前 应用因为浏览器渲染性能、模型体积过大等原因，并没有大规模使用起来，只限于在品牌宣传等部分领域尝试使用。我刚好经历过浏览器数据可视化绘图由向转变的过程年前后，相信随着软硬件性能的提升和网络速度的提升， 应用也会慢慢的推广使用起来。

文章来自：小时光茶社 公众号