作者： 

作为容器编排生态圈中重要一员，是大规模容器管理系统的开源版本实现，吸收借鉴了过去十年间在生产环境上所学到的经验与教训。 提供应用部署、维护、 扩展机制等功能，利用能方便地管理跨机器运行容器化的应用。当前支持、、、、等平台，除此之外，也可以直接运行在物理机上是一个开放的容器调度管理平台，不限定任何一种言语，支持等各类应用程序 。
是一个完备的分布式系统支持平台，支持多层安全防护、准入机制、多租户应用支撑、透明的服务注册、服务发现、内建负载均衡、强大的故障发现和自我修复机制、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力完善的管理工具，包括开发、测试、部署、运维监控，一站式的完备的分布式系统开发和支撑平台。 
一 系统架构
系统按节点功能由和组成。


作为控制节点，调度管理整个系统，包含以下组件：
 作为系统的入口，封装了核心对象的增删改查操作，以接口方式提供给外部客户和内部组件调用。它维护的对象将持久化到。
：负责集群的资源调度，为新建的分配机器。这部分工作分出来变成一个组件，意味着可以很方便地替换成其他的调度器。
 ：负责执行各种控制器，目前有两类：

 ：定期关联和关联信息由对象维护，保证到的映射总是最新的。

 ：定期关联和，保证定义的复制数量与实际运行的数量总是一致的。



是运行节点，运行业务容器，包含以下组件：
：责管控容器，如启动停止、监控运行状态等。它会定期从获取分配到本机的，并根据信息启动或停止相应的容器。同时，它也会接收的请求，汇报的运行状态。
 ：负责为提供代理。它会定期从获取所有的，并根据信息创建代理。当某个客户要访问其他时，访问请求会经过本机做转发。
借用一张网图，表达功能组件之间关系：

二基本概念

是集群中相对于而言的工作主机，在较早版本中也被称为。可以是一台物理主机，也可以是一台虚拟机。在每个上运行用于启动和管理的服务——，并能够被管理。在上运行的服务进程包括、和 。
的信息如下：
地址：主机的地址或者。的运行状态 。  描述状态的运行条件，目前只有一种条件，表示处于健康状态，可以接收发来的创建的指令。系统容量：描述可用的系统资源，包括、内存、最大可调度数量等。

 是  的最基本操作单元，包括一个或多个紧密相关的容器，一个  可以被一个容器化的环境看作应用层的“逻辑宿主机”   。一个  中的多个容器应用通常是紧耦合的。 在  上被创建、启动或者销毁。
为什么  使用  在容器之上再封装一层呢？一个很重要的原因是 容器之间通信受到  网络机制的限制。在  的，世界中，一个容器需要通过  方式才能访问另一个容器提供的服务端口。大量容器之间的  将是一个非常繁重的工作。通过  的概念将多个容器组合在一个虚拟的“主机”内，可以实现容器之间仅需通过  就能相互通信了。
一个中的应用容器共享一组资源，如：
命名空间：中的不同应用程序可以看到其他的进程网络命名空间：中的多个容器能够访问同一个和端口范围命名空间：中的多个容器能够使用  或消息队列进行通信。命名空间：中的多个容器共享一个主机名。共享存储卷：中的各个容器可以访问在级别定义的。

是系统中的一个核心概念。以键值对的形式附加到各种对象上，如、、、等。定义了这些对象的可识别属性，用来对它们进行管理和选择。可以在创建对象时附加到对象上，也可以在对象创建后通过进行管理。
在为对象定义好后，其他对象就可以使用 来定义其他作用的对象了。
 的定义由多个逗号分隔的条件组成：“” {    “” ””    “” ””}
 
 是系统中的核心概念，用于定义副本的数量。在的 进程通过的定义来完成的创建、监控、启停等操作。
根据 的定义，能够确保在任意时刻都能运行用户指定的“副本”数量。如果有过多的的副本在运行，系统会停掉一些；如果运行的副本数量太少，系统就会再启动一些，总之，通过的定义，总是保证集群中运行着用户期望副本数量。
服务
在的世界里，虽然每个都会被分配一个单独的地址，但这个地址会随着的销毁而消失。这就引出一个问题：如果有一组组成一个集群来提供服务，那么如何来访问它们呢？
的就是用来解决这个问题的核心概念。一个可以看作一组提供相同服务的的对外访问接口。作用于哪些是通过  来定义的。
的地址是 根据网桥的地址段进行分配的，但的 地址是系统中的虚拟地址，由系统动态分配。 的地址相对于的地址来说相对稳定，被创建时即被分配地址，在销毁该之前，这个地址都不会再变化。
由于对象在  池中分配到的只能在内部访问，所以其他都可以无障碍地访问到它。但如果这个作为前端服务，准备为集群外的客户端提供服务，我们就需要给这个服务提供公共了。
支持两种对外提供服务的的定义：和。
存储卷
是中能够被多个容器访问的共享目录。的概念与的比较类似，但并不完全相同。中的与生命周期相同，但与容器的生命周期不相关。当容器终止或重启时，中的数据也不会丢失。另外，支持多种类型的，并且一个可以同时使用任意多个。
一个 是在分配到时创建的。从它的名称就可以看出，它的初始内容为空。在同一个中所有容器可以读和写中的相同文件。当从上移除时，中的数据也会永久删除。
：在上挂载宿主机上的文件或目录。通常用于：容器应用程序生成的日志文件需要永久保存，可以使用宿主机的高速文件系统进行存储；需要访问宿主机上的引擎内部数据结构的容器应用，可以通过定义为宿主机目录，使容器内部应用可以直接访问的文件系统。
使用这种类型的表示使用谷歌计算引擎   上永久磁盘 上的文件。与不同，上的内容会永久保存，当被删除时，只是被卸载，但不会被删除。需要注意的是，你需要先创建一个永久磁盘才能使用。
：与类似，该类型的使用提供的  的 ，并可以挂载到中去。需要注意的是，需要先创建一个 才能使用。
：使用网络文件系统提供的共享目录挂载到中。在系统中需要一个支行中的系统。
：使用存储设备上的目录挂载到中。
：使用开源网络文件系统的目录挂载到中。
：使用块设备共享存储  挂载到中。
：通过挂载一个空目录，并从库一个 以供使用。
一个 用于为提供加密的信息，你可以将定义在中的直接挂载为文件让访问。 是通过内存文件系统实现的，所以这种类型的总是不会持久化的。
：从中申请所需的空间，通常是种网络存储，如、、、等。
命名空间
命名空间是系统中另一个非常重要的概念，通过将系统内部的对象“分配”到不同的中，形成逻辑上分组的不同项目、小组或用户组，便于不同的分组在共享使用整个集群的资源的同时还能分别管理。
集群在启动后，会创建一个名为“”的。接下来，如果不特别指明，则用户创建的、、都将被系统创建到名为“”的中。
使用来组织的各种对象，可以实现对用户的分组，即“多租户”管理。对不同的租房还可以进行单独的资源配额设备和管理，使得整个集群配置非常灵活、方便。
注解
与类似，也使用键值对的形式进行定义。具有严格的全名规则，它定义的是对象的元数据，并且用于 。则是用户任意定义的“附加”信息，以便于外部工具进行查找。
用来记录的信息包括：信息、信息、镜像信息等，如时间戳、 号、号、镜像值、 地址等。
典型流程
以创建一个为例，典型的流程如下图所示：

三组件
 
为了区分 中的 副本控制器和资源对象 ，我们将资源对象简写为，而 特指“副本控制器”。
 的核心作用是确保在任何时间集群中一个所关联的都保持一定数量的副本处于正常运行状态。如果该类的副本数量太多，则 会销毁一些副本；反之 会添加副本，直到该类的副本数量达到预设的副本数量。最好不要超过直接创建，因为 会通过管理副本，实现自动创建、补足、替换、删除副本，这样就能提高系统的容灾能力，减少由于节点崩溃等意外状况造成的损失。即使应用程序只用到一个副本，也强烈建设使用来定义。
 管理的对象是，因此其操作与的状态及重启策略息息相关。
副本控制器的常用使用模式：
重新调度：不管想运行个副本还是副本，副本控制器能够确保指定数量的副本存在于集群中，如果节点故障或副本被终止运行等意外情况，将会重新调度直到达到预期的副本正常运行。
弹性伸缩：手动或通过自动扩容代理修改副本控制器的属性值，非常容易实现扩大或缩小副本的数量。
滚动更新：副本控制器被设计成通过逐个替换的方式来辅助服务的滚动更新。推荐的方式是创建一个新的只有一个副本的，若新的副本数量加，则旧的的副本数量减，直到这个旧的副本数量为零，然后删除该旧的。
在滚动更新的讨论中，我们发现一个应用在滚动更新时，可能存在多个版本的。事实上，在生产环境中一个已经发布的应用程序存在多个版本是很正常的现象。通过的标签选择器，我们能很方便地实现对一个应用的多版本的跟踪。
 
 负责发现、管理和监控集群中的各个节点。在启动时通过 注册节点信息，并定时向 发送节点信息。 接收到这些信息后，将这些信息写入。存入的节点信息包括节点健康状况、节点资源、节点名称、节点地址信息、操作系统版本、版本、版本等。节点健康状况包含“就绪”、“未就绪”和“未知”三种。

  在启动时如果设置了—参数，那么为每个没有设置的生成一个地址，并用该设置节点的属性，这样的目的是防止不同节点的地址发生冲突。
逐个读取节点的信息，多次尝试修改中的节点状态信息，将该节点信息和 的中保存的节点信息比较。如果判断中没有收到发送的节点信息、第一次收到节点发送的节点信息，或在该处理过程中节点状态变成非“健康”状态，则在中保存该节点的状态信息，并用 所在节点的系统时间作为探测时间和节点状态变化时间。如果判断出在某一段时间内没有收到节点的状态信息，则设置节点状态为“未知”，并且通过 保存节点状态。
逐个读取节点信息，如果节点状态变为非“就绪”状态，则将节点加入待删除队列，否则将节点从该队列中删除。如果节点状态为非“就绪”状态，且系统指定了 ，则 调用 查看节点，若发现并节点故障，则删除中的节点信息，并删除和该节点相关的等资源的信息。
 
作为容器集群的管理平台， 也提供了资源配额管理这一高级功能，资源配额管理确保指定的对象在任何时候都不会超量占用系统资源，避免了由于某些业务进程的设计或实现的缺陷导致整个系统运行紊乱甚至意外宕机，对整个集群的平稳运行和稳定性有非常重要的作用。
目前支持三个层次的资源配额管理：
容器级别，可以对和内存的资源配额管理。
级别，可以对内所有容器的可用资源进行限制。
级别，为可以用于多租户级别的资源限制，包括：数量、 数量、数量、数量、数量、可持有的 数量。的配额管理是通过准入机制 来实现的，与配额相关的两种准入控制器是和，其中作用于和上，则作用于上。此外，如果定义了资源配额，则在调度过程中也会考虑这一因素，确保调度不会超出配额限制。
典型的资源控制流程如下图所示：

 

用户通过 可以创建新的并保存在中， 定时通过 读取这些信息。如果被标识为优雅删除设置删除期限，属性被设置，则将该的状态设置为“”并保存到中。同时 删除该下的、、、、、、和等资源对象。当的状态被设置为“”后，由 的插件来阻止为该创建新的资源。同时，在 删除完该中的所有资源对象后， 对该执行操作，删除的域中的信息。
如果 观察到设置了删除期限即属性被设置，同时 的域值是空的，那么 将通过 删除该资源。
安全控制
 和 是与安全相关的两个控制器。 在 启动时被创建。它监听 的删除事件和的创建、修改事件。如果在该 的中没有  ，那么 为该 的创建一个 。
在 的启动中添加“—_=”后， 在启动时会自己创建一个和和，然后在启动时添加参数____=，这样启动 后，就会发现在创建 时系统会自动为其创建一个。
如果 在启动时指定参数为，而且该参数所指定的文件包含一个的编码的算法的私钥，那么， 会创建 对象。
 
 对象监听 的创建、修改和删除事件，并根据事件的不同做不同的处理。如果监听到的事件是创建和修改 事件，则读取该 的信息；如果该 没有  即用于访问 的，则用前面提及的私钥为该 创建一个 ，将该和 如果启动时参数指定了该  放入新建的中，将该新建的放入该 中，同时修改中 的内容。如果监听到的事件是删除 事件，则删除与该 相关的。
 对象同时监听的创建、修改和删除事件，并根据事件的不同做不同的处理。如果监听到的事件是创建和修改事件，那么读取该中所指定的 信息，并根据需要为该创建一个和其 相关的；如果监听到的事件是删除事件，则删除和相关的 的引用关系。
  

 是一个定义集合的抽象，或者被访问都看作一个访问策略，有时也被称为微服务。中的是种资源对象，各所有其他资源对象一样，可以通过 的接口创建一个新的实例。在下面的例子代码中创建了一个名为“”的，它包含一个标签选择器，通过该标签选择器选择所有包含标签为“=”的作为该的集合。集合中的每个的端口被映射到节点本地的端口，同时指派一个集群即虚拟给该。
{
    “” ””
    “” ””
    “” {
        “” ””
    }
    “” {
        “” {
            “” ””
        }
        “” 
            {
                “” ””
                “” 
                “” 
            }
        
    }
｝
四功能特性
 集群访问流程服务发现

在集群中的每个上都运行着一个叫“”的进程，该进程会观察节点添加和删除“”和“”的行为，如图中第步所示。
为每个在本地主机上开一个端口随机选择。任何访问该端口的连接都被代理到相应的一个后端上。根据 算法及的粘连决定哪个后台被选中，如第步所示。
最后，如第步所示，在本机的中安装相应的规则，这些规则使得将捕获的流量重定向到前面提及的随机端口。通过该端口流量再被转到相应的后端上。
在创建了服务后，服务模型会创建后端的和端口列表包含中对象中，就是从这个列表中选择服务后端的。集群内的节点通过虚拟和端口能够访问后台的。
在默认情况下，会为指定一个集群或虚拟、 ，但在某些情况下，希望能够自己指定该集群。为了给指定集群，用户只需要在定义时，在的域中设置所需要的地址即可。
调度
在整个系统中承担了“承上启下”的重要功能，“承上”是指它负责接收 创建的新，为其安排一个落脚的“家”——目标；“启下”是指安置工作完成后，目标上的服务进程接管后继工作，负责生命周期中的“下半生”。
具体来说，的作用是将待调度的新创建的、 为补足副本而创建的等按照特定的调度算法和调度策略绑定到集群中的某个合适的上，并将绑定信息写入中。在整个调度过程中涉及三个对象，分别是：待调度的列表、可用列表、以及调度算法和策略。简单地说，就是通过调度算法调度，为待调度列表中的每个从列表中选择一个最适合的。
随后，目标上的通过 监听到产生的绑定事件，然后获对应的取，下载镜像，并启动容器。

调度策略
当前提供的默认调度流程分为两步：
预选调度过程，即遍历所有目标，筛选出符合要求的候选节点。为此内置了多种预先策略 供用户选择。
确定最优节点，在第一步的基础上，采用优先策略 计算出每个候选节点的积分，积分最高都胜出。的调度流程是通过插件方式加载的“调度算法提供者”具体实现的。一个其实就是包括了一组预选策略与一组优选策略的结构体，注册的函数如下：     它包含个参数，  参数为算法名；
参数为算法集合用到的预选策略集合 参数为算法用到的优选策略集合 中可用的预选策略包含个，每个节点只有通过、、、、 个默认预先策略后，才能初步被选中，进入下一个流程。
每个节点通过优选策略时都会算出一个得分，计算各项得分，最终选出得分值最大的节点作为优选的结果也是调度算法的结果。，选择资源消耗最小节点：
计算出所有备选节点上运行的和备选的占用量
计算出所有备选节点上运行的和备选的内存占用量
计算每个节点的得分，计算规则大致如下：=，根据策略打分，选择资源使用最均衡节点
计算出所有备选节点上运行的和备选的占用量
计算出所有备选节点上运行的和备选的内存占用量
计算每个节点的得分，计算规则大致如下：=  
节点管理
节点管理包含节点的注册、状态上报、管理、容器健康检查、资源监控等部分。

节点注册
在集群中，在每个节点上都会启动一个服务进程。该进程用于处理节点下发到本节点的任务，管理及中的容器。每个进程会在 上注册节点自身信息，定期向节点汇报节点资源使用情况，并通过监控容器和节点资源。
节点通过设置的启动参数“—”，来决定是否向 注册自己。如果该参数为，那么将试着通过 注册自己。作为自注册，启动还包含下列参数：
，告诉  的位置；，告诉在哪儿可以找到用于访问 的证书；，告诉如何从云服务商那里读取到和自己相关的元数据。
状态上报
在启动时通过 注册节点，并定时向 发送节点新消息， 在接收到这些信息后，将这些信息写入。通过的启动参数“—”设置每隔多少时间向 报告节点状态，默认为秒。
管理
通过以下几种方式获取自身上所要运行的清单：文件：启动参数“”指定的配置文件目录下的文件。通过—设置检查该文件目录的时间间隔，默认为秒。
端点：通过“—”参数设置。通过—设置检查该端点的数据时间间隔，默认为秒。
 ：通过 监听目录，同步清单。
所有以非 方式创建的都叫作 。将 的状态汇报给 ， 为 创建一个 和其相匹配。 的状态将真实反映 的状态。当 被删除时，与之相对应的 也会被删除。通过  使用的方式监听“当前名称”和“”目录，将获取的信息同步到本地缓存中。
监听，所有针对的操作将会被监听到。如果发现有新的绑定到本节点的，则按照清单的要求创建该。如果发现本地的被修改，则会做出相应的修改，如删除中的某个容器时，则通过 删除该容器。如果发现删除本节点的，则删除相应的，并通过 删除中的容器。
读取监听到的信息，如果是创建和修改任务，则做如下处理：
为该创建一个数据目录。
从 读取该清单。
为该挂载外部卷 。
下载用到的。
检查已经运行在节点中的，如果该 没有容器或容器没有启动，则先停止里所有容器进程。如果在中有需要删除的容器，则删除这些容器。
用“”镜像为每个创建一个容器，该容器用于接管中所有其他容器的网络。
为中的每个容器做如下处理：
为容器计算一个值，然后用容器的名字去查询对应容器的值。若查到容器，且两者值不同，则停止中容器进程，并停止与之关联的容器进程；若两者相同不做任何处理。
如果容器被中止了，且容器没有指定的重启策略，则不做任何处理。
调用 下载容器镜像，调用 运行容器。
容器健康检查
通过两类探针来检查容器的健康状态。一个是探针，用于判断容器是否健康，告诉一个容器什么时候处于不健康的状态。如果探针探测到容器不健康，则将删除容器，并根据容器的重启策略做相应的处理。如果一个容器不包含探针，那么认为该容器的探针返回的值永远是“”另一类是探针，用于判断容器是否启动完成，且准备接收请求。如果探针检测到失败，则的状态将被修改。 将从的中删除包含该容器所在的地址的条目。
参考
《权威指南》

文章来源 公众号小时光茶社 


相关推荐    容器服务健康检查详解作者罗伟 年加入腾讯，长期从事腾讯业务的运营支撑、监控系统的建设，曾主导建设、 手机、手机等业务监控系统及监控平台的建立和运营，目前负责黑石产品架构工作。
导语：本文介绍了腾讯业务监控体系的层级构成，用代表性的监控系统阐述每个监控层次的实现方法，以及与监控体系配合，业务做了哪些容灾和调度的方案。从而和大家分享腾讯最完整的关于做监控系统的思考。

首先很荣幸在这里给大家分享腾讯在做业务监控的一些心得和经验，当然今天所提及的只是腾讯业务运营监控体系中的小部分，也欢迎大家一起在运营体系建设、精细化运维等方面共同探讨和学习。
我们用一个红包开始今天的分享吧。
表面看是抢红包这么简单的一个功能，其实光抢红包这个动作，它所关联的监控系统就有好多个！

如图所示，腾讯的业务从逻辑上可以抽象总结成四个层次：用户层、手机、智能硬件等、接入层、逻辑层和数据层包括数据缓存层和持久化层。腾讯业务的监控系统是立体化覆盖，总结来说也是由四个层级组成： 
基础设施层
基础设施层的监控覆盖范围很广，在腾讯包括：与运营商互联出口、专线包括城域和广域、机房包括各类物理设施如机架、制冷、配电、消防、安防等、网络设备交换机、路由器、防火墙等等。
基础设施层的监控又分为状态、性能、质量、容量、架构等几个层面。举例说明
状态监控包括网络设备的软硬件状态如设备存活状态、板卡、电源、风扇状态，设备温度、光功率、状态、生成树状态等；性能监控包括设备、设备内存大小、数量、端口流量包量、内存溢出监控、内存使用率等；质量监控包括设备错包、丢包率，针对网络设备以及网络链路的探测延时、丢包率监控等；容量监控包括设备负载使用率、专线带宽使用率、出口流量分布等；架构监控包括路由跳变、缺失、绕行，流量穿越监控等。
 
服务器层
服务器是业务部署运行起来的载体早期服务器就是我们传统观念上的“物理机操作系统”，现在已经扩大到虚拟机或者是容器等范畴。服务器层的监控包括硬件层面和软件层面。
硬件层面的监控主要包括如下内容

硬盘：硬盘读写错误、读写超时、硬盘掉线、硬盘介质错误、硬盘硬盘温度、硬盘寿命、硬盘坏块率；
内存：内存缺失、内存配置错误、内存不可用、内存校验；网卡：网卡速率；
电源：电源电压、电源模块是否失效；风扇：风扇转速；
卡：卡电池状态、电池老化、电池和缓存是否在位、缓存策略。

软件层面的监控主要包括：整体使用率、各核使用率、 负载、内存应用内存、整体内存、等、磁盘读写速率、、平均等待延时、平均服务延时等、网络流量、包量、错包、丢包、连接各种状态的连接数等、进程端口存活、文件句柄数、进程数、内网探测延时、丢包率等。
业务程序层
业务程序层的监控手段是最为丰富和立体化的，这里只是介绍几个核心和典型的系统。
容量管理系统
容量管理系统基于“服务器层”在软件层面的监控指标，并且配合业务增长、运营活动等因素而建设，用于客观衡量业务负载高低情况，并结合扩缩容调度，实现业务的负载和成本间的平衡。
具体原理是根据服务器所在业务层级接入层、逻辑层还是数据层的不同，设置不同的容量参考指标、指标参考基准、指标计算规则、高低负载判别规则，设置业务模块由相同功能的多个服务器构成的业务集群的扩缩容规则；由系统计算出服务器、业务模块的负载情况，决策出是否需要扩容或缩容，触发业务模块的扩缩容操作。
 
说明：服务器、业务模块的负载计算规则也是由业务可以自定义配置。
模块间调用
在腾讯内部简称“模调”，年开始已经广泛应用于各大业务，用于实时监测后端服务与服务之间调用的质量，可以细化到服务模块、接口、命令字甚至代码层面现在看来，其实就是各个厂商在大力宣传和推广的产品。

针对使用标准化组件在腾讯内部业务，用户层使用的标准组件是；接入层使用的标准组件是、；逻辑层使用的标准组件是；数据层使用的标准组件是、等的业务，由标准组件上报模调监控数据；

针对自定义业务，提供模调上报的或，由业务自主上报服务间的每次调用成功与否，每次调用的延时；

模调系统支持业务从用户层接入层逻辑层数据层，全路径用唯一的序列号通常由时间、功能模块、、随机值等因素构成此值来对业务请求染色，方便业务展现出每次请求完整的从前到后的调用链路。



用户体验
测速系统
收集用户真实访问业务的速度、性能、成功率数据。类业务由上报或者客户端程序监控模块上报，移动类业务通过引入腾讯分析上报到监控系统。测速系统的价值不仅仅在于实时监控，还有一个比较有意义的作用是：业务架构优化前后，对比用户访问业务的速度，指导和衡量业务架构优化的客观效果。
云拨测
通过模拟用户访问业务并校验返回数据结果，监测业务是否可用、访问质量及性能、逻辑功能正确性的监控系统。当然和云拨测同类的产品或者公司也挺多的，比如基调、监控宝、博睿等等。我们自己要建立云拨测其中的一个原因是：腾讯业务需要监控业务逻辑是否正常，而不仅仅是接入层网站类业务是否能访问，访问的速度是否快，业务逻辑的验证就涉及到鉴权、关系数据的自动化获取等，外部监控服务商无法实现这一点。
以上的内容简单介绍了目前腾讯业务核心的几个监控系统，当然还有很多其他系统没有提及到，比如自动化测试监控、组件特性监控、业务染色等。接下来讲下告警关联和业务容灾的内容。
告警智能关联
有这么多监控系统，如果没有告警智能关联，我们会怎么样？简单举一个例子，如果某个业务在数据层的服务器假设安装的是有硬件故障，前端业务也没有做好足够的容灾切换，那么该业务的接入层、逻辑层、数据层在用户体验、业务程序层将产生大量的告警，形成告警风暴。为了解决该问题，腾讯内部有一个系统，基于业务架构，结合业务数据流访问关系，通过时间相关性、面积权重等算法，将监控告警进行分类、关联，发掘出告警的根源所在。 说明：告警关联的一个基本思路是，越靠近业务后端逻辑层处于接入层的后端，数据层处于逻辑层的后端的告警越趋近于故障根源；越靠近基础设施层的告警越趋近于故障根源。还是刚才所举的例子：监控系统在关联所有告警后，发给运维和研发的告警将是分析后的结论：所在服务器硬件故障，导致业务请求量下降，业务整体流量下降。
业务容灾调度柔性
我们始终认为： 监控系统、运维工具不是万能的。如果要业务可用性不断靠近，需要业务侧做很多容灾、调度、柔性的工作。
腾讯业务在容灾、调度、柔性上做了哪些工作呢？由于篇幅有限，不能完全列举，我仅分享几个比较有代表性的思路和方法。
、在用户端，为了应对网络环境复杂的情况，腾讯移动类业务采用公司统一的业务接入框架维纳斯。
【维纳斯，  又名移动连通服务，是一个为提供高连通、高可靠、强安全的网络连接通道的服务；它利用、微信海量接入数据来持续优化调度算法，并集成了用户就近接入、腾讯直通车、加密通道透传功能等等，提供了手机端，业务不必关心网络细节，即可安全与业务后台简单可靠的通讯】。
、业务接入层：业务接入层大多数是无状态设计或者是有规则的分号段接入，在运营部署规划的过程中，根据业务规模大小，选择不同程度的容灾，通常有跨交换机、跨机架、跨机房、跨地域容灾。
业务全量接入腾讯云网关实现负载均衡，避免单个服务器、交换机、机房出现故障时，业务完全瘫痪。
、业务逻辑层：业务间的逻辑调用都是通过组件名字服务负载均衡访问，组件基于服务器初始配置信息，通过自适应算法，以两个关键指标请求成功率和请求延时为依据，周期性计算出每个被调服务器的权重，再使用高效的配额算法分配各个主调服务的访问路由，主调服务器上的业务进程通过来取得这些路由，调用结束时通过来反馈路由的好与坏。
、网络调度：主要有同城跨运营商调度和同运营商跨城调度。假设上海电信出口有故障，我们将通过域名解析指向调度到同城其他运营商的接入集群，实现容灾；
腾讯有几个核心的节点，多个节点之间有专线互联，所以我们也可以将上海电信接入的这部分用户牵引到北京电信或者深圳电信进行接入，实现业务的容灾这就是同运营商跨城调度。调度的过程，业务完全无感知。
、柔性：分基础设施层面的柔性和业务逻辑功能上的柔性。柔性是容灾、调度切换等手段的补充。

基础设施层面的柔性，举一个例子：当运营商网络、专线网络拥塞的时候，我们可以根据业务的服务等级不同启动不同等级的流量控制。

业务功能上的柔性 也举一个简单易懂的例子：某个业务如果提供了文字、语音、视频、互动等功能，当网络高负载或者业务整体高负载时，可以通过柔性开关控制关闭掉某些高消耗资源的功能和服务。


总结
监控体系是业务运营体系中非常重要的一个环节，但业务可用性的提高是需要基础设施支撑团队、业务运维团队、业务研发团队一起通力合作，才能做到更好。篇幅和时间有限，我的分享结束了，感谢各位。
欢迎关注【腾讯织云】公众号，获取最新技术资讯。什么是
™ 是一个采用数据流图  ，用于数值计算的开源软件库。节点在图中表示数学操作，图中的线则表示在节点间相互联系的多维数据数组，即张量。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个或，服务器，移动设备等等。
 最初由大脑小组隶属于机器智能研究机构的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。
当前最新的开源版本是  。
什么是数据流图

数据流图用“结点”和“线”的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入 的起点输出 的终点，或者是读取写入持久变量 的终点。“线”表示“节点”之间的输入输出关系。这些数据“线”可以输运“可动态调整”的多维数据数组，即“张量”。张量从图中流过的直观图像是这个工具取名为“”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。
的关键特性
高度的灵活性
 不是一个严格的“神经网络”库。只要可以将计算表示为一个数据流图，就可以使用来构建图，描写驱动计算的内部循环。提供了有用的工具来帮助你组装“子图”常用于神经网络，当然用户也可以自己在基础上写自己的“上层库”。定义顺手好用的新复合操作和写一个函数一样容易，而且也不用担心性能损耗。当然万一发现找不到想要的底层数据操作，也可以自己写一点代码来丰富底层的操作。
真正的可移植性
 可以在和上运行，比如说可以运行在台式机、服务器、手机移动设备等等。想要在没有特殊硬件的前提下，在你的笔记本上跑一下机器学习的新想法？也可以办到。准备将你的训练模型在多个上规模化运算，又不想修改代码？也可以办到。想要将你的训练好的模型作为产品的一部分用到手机里？可以办到这点。你改变主意了，想要将你的模型作为云端服务运行在自己的服务器上，或者运行在容器里？也能办到。
将科研和产品联系在一起
过去如果要将科研中的机器学习想法用到产品中，需要大量的代码重写工作。那样的日子一去不复返了！在，科学家用尝试新的算法，产品团队则用来训练和使用计算模型，并直接提供给在线用户。使用可以让应用型研究者将想法迅速运用到产品中，也可以让学术性研究者更直接地彼此分享代码，从而提高科研产出率。
自动求微分
基于梯度的机器学习算法会受益于自动求微分的能力。作为用户，你只需要定义预测模型的结构，将这个结构和目标函数 结合在一起，并添加数据，将自动为你计算相关的微分导数。计算某个变量相对于其他变量的导数仅仅是通过扩展你的图来完成的，所以你能一直清楚看到究竟在发生什么。
多语言支持
 有一个合理的使用界面，也有一个易用的使用界面来构建和执行你的。你可以直接写程序，也可以用交互式的界面来用尝试些想法，它可以帮你将笔记、代码、可视化等有条理地归置好。当然这仅仅是个起点——鼓励创造自己最喜欢的语言界面，比如，，，，或者是。
目前开源的版本暂时只看到对于的支持，并且的比的还是要更成熟易用。社区已经有针对和的支持。
性能最优化
比如说你有一个具有个内核、个显卡的工作站，想要将你工作站的计算潜能全发挥出来？由于 给予了线程、队列、异步操作等以最佳的支持， 让你可以将你手边硬件的计算潜能全部发挥出来。你可以自由地将图中的计算元素分配到不同设备上，可以帮你管理好这些不同副本。
在的应用


超过项线上产品在使用；
数据科学家和工程师都在使用；
用构建下一代的智能应用；
已经被开源，并部署到 上；

在公司内的实践

尝鲜，数据平台部；
玩转从零开始用部署，数据平台部；
玩转词向量模型，数据平台部；

社区活跃度

的安装
支持二进制包和源码包等多种安装方式，支持在、  、等多个平台上进行安装，并且可以运行在之上，官网上有比较详细的安装文档。
最简单的安装方式是通过进行安装，如果条件不允许例如无外网的条件下，需要通过源码进行安装，的源码编译依赖 版本，以及进行编译。
整体来说的安装过程还是比较简单的。
基本术语

一块可以用来运算并且拥有自己的地址空间的硬件，比如和。

 的一个方法，返回  的值。触发任意一个图计算都需要计算出这个值。只能在一个已经启动的会话的图中才能调用该  值。

 的一个概念：把一个  直接连接到一个会话图表中的任意节点。 不是在构建图的时候创建，而是在触发图的执行操作时去申请。一个  临时替代一个带有  值的节点。把数据作为 方法和 方法的参数来初始化运算。方法运行结束后，替换的  就会消失，而最初的节点定义仍然还在。可以通过 把特定的节点指定为  节点来创建它们。

中的一个概念：为了取回运算操作的输出结果。取回的申请发生在触发执行图操作的时候，而不是发生在建立图的时候。如果要取回一个或多个节点的  值，可以通过在  对象上调用 方法并将待取回节点的列表作为参数来执行图表。

把运算任务描述成一个直接的无环图形，图表中的节点代表必须要实现的一些操作。图中的边代表数据或者可控的依赖。 是系统中描述一个图表的协议，它由一个  集合组成。一个可以转化成一个更容易操作的图表对象。

在   中， 仅仅在第一维上对  有所体现。如果一个  有维，那么一个  实例在逻辑上代表一个沿着这个  第一维的维切片的集合。切片的索引被连续储存在一个单独的一维向量中，而对应的切片则被拼接成一个单独的维 。如果  不是受限于第一维空间，请用 。

图中的一个元素。 把启动一个特定操作的方式称为特定运算图表的一个节点，包括任何用来配置这个操作的属性的值。对于那些多形态的操作，这些属性包括能完全决定这个节点签名的充分信息。

在  的运行时中，它是一种类似  或  或 的运算。可以用    中的方法来向运行时添加新的操作。
在  的中，它是图中的一个节点。在类中列举出了这些操作。一个操作的  属性决定这个节点的操作类型，比如和。

在一个运行的图中执行某种操作的行为。要求图必须运行在会话中。
在  的  中，它是  类的一个方法。可以通过  来订阅或获取 操作。
在的中，它是类 的一个方法。

启动图的第一步是创建一个  对象。 提供在图中执行操作的一些方法。
在  中，使用。
在  的中，是用来创建一个图并运行操作的类。

 的维度和它们的大小。
在一个已经启动的图中，它表示流动在节点之间的  的属性。一些操作对  有比较强的要求，如果没有  属性则会报告错误。
在  中，用创建图的  来说明  的  属性。 的 属性要么只有部分已知，要么全部未知。详见
在中， 类用来表示  的维度。。

在   中，它用来表示在  中稀疏散落在任意地方的  。 以字典值格式来储存那些沿着索引的非空值。换言之，个非空值，就包含一个长度为的值向量和一个由列索引组成的矩阵。为了提升效率， 需要将 索引按维度的增加来按序存储，比如行主序。如果稀疏值仅沿着第一维度，就用 。

是一种特定的多维数组。比如，一个浮点型的四维数组表示一小批由，，组成的图片。
在一个运行的图中，它是一种流动在节点之间的数据。 在  中， 类表示添加到图的操作中的输入和输出，见，这样的类不持有数据。
在中，是方法 的返回值，见，这样的  持有数据。
上手难度
 和 在描述维数据方面是非常相似的，不同的是除了能定义维数组，还能创建维数组的方程，并能自动计算求导，做更多的事情。




对比两者之间的区别
 
可见在中许多基础的操作都是类似的，这让很多接触过进行数据分析的人员都能很自然的上手。
体验
以下借助我实现了一个简单的单变量线性回归程序：

   
   
   

 定义输入数据
_ =   
 =   
_ =   _  

  输入数据
 = 
 = _  
_ _



 定义数据大小
_ = 

 转换成向量
_ = _ _ 
_ = _ _ 

 定义占位符
 =  = 
 =  = 

 定义学习的变量
 = _  
                    =__
 = _ 
                    =_
_ =    
 = __  _

 梯度下降
 定义优化函数
 = 
 = 

   
     初始化变量
    __

     = 
         
        _ _ =   
                               _={ _  _}

            == 
             
                

            _ = _ _={ _}
             = _ _  =
            

    
通过简单的定义目标函数和选择优化算法，就可以开始训练我的模型了。

结果我并没有亲手实现梯度下降算法，就达到了训练样本的目的。开发人员可以只关注模型本身，剩下的事情  帮你搞定的妥妥的！这只是小试牛刀， 可以训练更加复杂的模型：循环神经网络，卷积神经网络，递归神经网络等等。

 提供了一个内置的可视化工具叫做 。有了  可以更方便  程序的理解、调试与优化。你可以用  来展现你的  图像，绘制图像生成的定量指标图以及附加数据。
通过简单的改写，我就可以在上面的例子中使用了：


   
   

 定义输入数据
_ =   
 =   
_ =   _  

 定义数据大小
_ = 

 转换成向量
_ = _ _ 
_ = _ _ 

 _
     定义占位符
     =  = 
     =  = 

 定义学习的变量
 _
     _
         = _  
                            =__
     _
         = _ 
                            =_
     _
        _ =   
     _
         = __  _
        _ 

 梯度下降
 定义优化函数
 _
     = 
     = 

   
     = __
     =      

     初始化变量
    __

         
        _ _ =   
                               _={ _  _}

            == 
             =  _={ _  _}
            _ 
再次执行上面的代码，会在子目录下生成一个日志文件。通过在打开  的时候指定日志目录加载这个日志文件，我们就可以通过浏览器访问  了。
 =
通过  我们可查看定义的模型：

同时我们也可以通过  观察我们定义的损失量有没有按照预期的收敛，收敛的过程如何：

 是一个很好用的工具，官网文档有关于  更为详尽的描述。
总结
 作为一款机器学习的库，提供了类似  数据结构，支持，等多种语言，可以在或者上运行，安装简单，上手容易，社区活跃，文档目前还不够丰富，好在通俗易懂，但是目前的示例还比较少特别是以外的示例。
更多资源
神经网络和深度学习入门教程  介绍 视频 下载官方宣布开源 简化版接口   使用样例 与   对比 作者：赵丽娜

简介
移动  的  自动化测试长久以来一直是一个难点，难点在于的”变” 变化导致自动化用例的大量维护。 从分层测试的角度，自动化测试应该逐层进行。 最大量实现自动化测试的应该是单元测试 最容易实现也最容易在早期发现问题 其次是接口级测试 以验证逻辑为目的进行自动化 由于接口的相对稳定 自动化测试成本相对也可以接受 自动化成本最大的便是级自动化测试 然而界面是直接反馈给用户的效果展示适度的尤其是级的自动化测试也是非常必要的。 本文通过分析几种自动化框架的异同 使测试人员在选择自动化框架时有所参考。

自动化框架
 
  
 是自带的一个测试框架，是很多其它测试框架的基础，可以在同进程中加载被测组件。它有很多丰富的高层封装，使用者可以使用基于的其他框架，避免过多二次开发量。但不支持跨应用导致基于的框架都继承了这个缺点。
 

是基于框架开发的一个更强的框架 对常用的操作进行了易用性的封装 用于开发功能性、系统和验收测试场景。它运行时绑定到组件。它安装了一个测试用例套件作为在设备或仿真器上的应用程序，并提供用于执行测试的真实环境。
优点： 容易在最短的时间内编写测试脚本，易用性高。 自动跟随当前。 由于运行时绑定到组件，所以相比，它的测试执行更快，更强大。 不访问代码或不了解实现，也可以工作。 支持、、、、 和其他 控件。
缺点： 不能处理和组件。在旧设备上会变得很慢。 由于不支持设备当自动化测试同时覆盖 与的情况时，测试会被中断。 没有内置的记录和回放功能，使用记录功能需要  和   这样的收费工具。
 

是由谷歌提供的测试框架，它提供了原生 和游戏的高级测试。这是一个包含的库，用来创建功能性测试，还有运行测试的执行引擎。该库自带 。
优点：它在运行访问不同的进程时，会给测试案例特权。库由谷歌社区支持和维护。 
缺点：仅支持   及以上。 不支持脚本记录。 支持的重点是。 你不能获得当前活动或仪表化。 目前不支持视图。 库仅支持使用，因此很难和使用的混合。如想支持框架，建议使用自己的框架，例如。
 
 
是的开源自动化测试框架。相对于和，它的特点是规模更小、更简洁，更加精确，编写测试代码简单，容易快速上手。因为是基于的，所以不能跨。
 

是一个适用于和开发者的跨平台测试框架，可用来测试屏幕截图、手势和实际功能代码。开源免费并支持语言，能让你用自然的英语语言表述的行为，实现  ，行为驱动开发。 中的所有语句使用定义。
优点： 有大型社区支持。 列表项 简单，类似英语表述的测试语句 支持在屏幕上的所有动作，如滑动，缩放，旋转，敲击等。 跨平台开发支持同样的代码在和设备中都适用。
缺点： 测试步骤失败后，将跳过所有的后续步骤，这可能会导致错过更严重的产品问题。测试耗费时间，因为它总是默认先安装。 需要框架安装在的文件中， 因此测试人员必须要有的源码。 除了，对其他语言不友好。
 

是一个开源的、跨平台的自动化测试工具，支持、和平台。 通过，开发者无需重新编译或者做任何调整，就可以测试移动应用，可以使测试代码访问后端和数据库。它是通过驱动苹果的和的框架来实现的双平台支持，同时绑定了 用于老的平台测试。开发者可以使用兼容的任何语言编写测试脚本，如， ， ， ，， ， ， 和语言。
 
 
 是一个基于的一个框架 完全兼容协议。  可以在模拟器和实际设备上使用，也可以集成网格节点作为缩放和并行测试。
 

 是一款单元测试框架，但它并不依赖于提供的测试功能，它通过实现一套能运行的代码，然后在 运行的时候去截取相关的代码调用，然后转到实现的代码 去执行这个调用的过程。因此它不像模拟器或设备需要 编译器将类文件编译成设备上的 使用的格式、打包、部署和运行的过程，大大减少了测试执行的时间。实验室声称使用可以在秒内运行个测试。
除了实现里面的类的现有接口，还给每个类额外增加了很多接口，可以读取对应的类的一些状态。比如它为提供了方法，测试者可以通过接口来确定是不是正确显示了期望的。
 

是一个开源的测试框架，它提供了简单的编写行为驱动开发规范的方法，使用语言，支持 库。合并了和的功能。
 

是百度出品的一个基于的测试框架，它提供了跨进程的测试解决方案。
 

 是出的一个移动测试框架，它支持和。部分是基于，在原有的类基础上进行了扩展，提供了一整套面向对象的。 上的自动化测试包括注入式自动化框架，和基于录制的自动化框架_ 。
 其他
其他自动化框架还有应用于稳定性测试的系列   其中 支持 和 ，它可以为应用进行真实的，功能性交互测试。 提供简单的  ，复杂数据驱动的测试套件。 支持原生，移动和混合应用，真实设备或者模拟器。 使得场景捕获非常容易，可以记录高级别，可读的测试脚本。还有适用于浏览器自动测试的 ，可以真实测试用户行为，用户交互如触摸、手指滚动、长按等，还支持的一些特性，比如本地存储、存储、应用缓存等。而则是应用于兼容性测试的自动化工具， 大部分是基于和仪表盘技术编写的。还扩展了自动化测试过程，可以自动执行用例，自动收集和汇总测试结果。采用配置文件的方式将这些测试用例分组成多个测试计划第三方也可以创建自己的。
总结
各个测试框架的继承关系如下 继承关系决定了有些框架的先天优势或先天不足。在实际应用中可以集成多个框架。

基于的测试框架，比如，，等，都不能支持跨使用。 如自动化测试中有跨操作，可以二次开发或者结合实现。

支持的自动化框架比较少，可以在 和 及之间选择。

若想同时支持和，可选框架有和，或。

若为单元测试选择框架，可选或。实现了  类，耗时短。


自动化框架
 
__ 
是苹果在 和引入的一个简单而强大的测试框架，它的测试编写起来非常简单，并且遵循风格。的优点是与深度集成，有专门的导航栏，但因为受限于官方测试，因此功能不是很丰富。
 
 
是苹果提供的自动化测试框架，使用编写。基于有扩展型的工具框架和驱动型的框架。扩展型框架以扩展库方法提供了很多好用工具，注入式的框架通常会提供一些或者是，要求测试人员在待测应用的代码工程中导入这些内容，框架可以通过他们完成对的驱动。驱动型  在自动化测试底层使用了 库，通过通信的方式驱动 来完成自动化测试，通过这种方式，编辑脚本的语言不再局限于。
 
 
是平台一款非常受欢迎的测试框架，它使用语言来编写测试用例， 包含一个强大的“ ”，可以用它来获得运行中的详细信息，便于开发者将来进行测试回顾。 它允许使用编写结构化英语句子的测试场景。 要求测试时在应用程序内部编译，这意味着对源代码的改变是强制性的。操作方式为使用和组合命令，将命令发送到在本地应用程序内部运行的服务器上，并利用运行命令。 
优点： 测试场景是在的帮助下，用可理解的英语句子写的。 强大的实时检查工具。 活跃的社区支持。 不断扩大中的库。 
缺点： 对手势的支持有限。 在设备上运行测试有点难。 修改配置文件需要在实际设备上运行。 记录功能不可用。
 
 
是  项目的缩写，是一款 功能性测试框架，使用语言编写，对苹果开发者来说非常容易上手，更是一款开发者广为推荐的测试工具。 使用私有来了解中的视图层级。但缺点是运行较慢。
 
详见 描述。
 

是另一款与集成的框架。与不同的是，它基于编写，旨在对开发者隐藏中一些复杂的细节。
 

是对的一个完整替代，使用风格编写测试。 带有自己的一套工具集，包括、、，甚至还支持异步测试。它是一个适用于 开发的  库，优点在于其简洁的接口和可用性，易于设置和使用，非常适合新手开发者。使用语言编写，易于开发人员上手。
总结
自动化测试框架继承关系如下。 与  的  直接集成使用简单 但其不支持和 所以单使用框架的较少。 是一个平台十分好用的行为驱动开发的测试框架，有着非常漂亮的语法，可以写出结构性强，非常容易读懂的测试。  是官方提供的自动化测试的解决方法但接口不够丰富。

、、都是通过使用代码的形式来模拟事件触发，使得被测代码就像是由用户行为所触发的一样。但这样的代价是插入一个额外层的复杂度。

测试框架中支持的有 和。

可选用的单元测试框架有，，等，而，和更适用于级验收测试。


一些有趣的自动化测试框架
  图形化编程技术

 是由  的研究团队发布的新型图形化编程技术。它以图像检索技术为基础，提供了一套基于  的脚本语言以及集成开发环境。使用者可利用屏幕截图直接引用  元素进行编程，完成交互操作。 的脚本编写遵循  语法规范。由于  基于 ，其核心代码由  编写，可在用户自定义的  工程中将其作为  标准类库进行引用。
它的脚本是这样式的：
将  对象的屏幕截图作为函数的参数直接引用，整个代码的语义清晰明了，可读性极强。脚本执行过程中，利用图像检索算法分析匹配当前屏幕中对应的控件，并对其应用相应的鼠标或键盘操作。这种方式使得我们在脚本编写时，既无需关心繁琐的应用程序相关  亦不用获取  内容对象。
它的缺点是：

仅支持， ，和平台，还不支持移动平台。

依赖屏幕截图，使得在不同平台，不同分辨率，不同操作系统上需要维护一套图形源文件，不利于跨平台移植；若出现程序逻辑外的界面遮挡，则影响程序执行。


但作为现有自动化测试工具的补充，尤其是对无法获取的工程，比如 动画， 是非常有效的。
   框架 
虽然不是一流的测试框架，但也有所长。它可以帮开发者将自己的应用与其他众多同类型应用进行多方面比较，比如图形和功能。通过对比结果，开发者可以更有针对性地提高和改进自己的应用。目前仅支持平台。
    框架 
是一个优秀的  测试框架，可为挑选最佳的。会基于外观和易用性等众多因素返回测试结果，进而帮开发者解决问题。用进行测试无需向 重新提交应用或者大幅更改代码，只需要在中添加一行代码，节省了不少时间。

相关推荐 微信读书排版引擎自动化测试方案【腾讯】基于模型的自动化测试工具——前言
在上一节我们学习了 的基本用法，归根结底它是一个没有界面的浏览器，而且运行的是  脚本，然而这就能写爬虫了吗？这又和有什么关系？说好的爬虫呢？库都学完了你给我看这个？客官别急，接下来我们介绍的这个工具，统统解决掉你的疑惑。
简介
 是什么？一句话，自动化测试工具。它支持各种浏览器，包括 ，， 等主流界面式浏览器，如果你在这些浏览器里面安装一个  的插件，那么便可以方便地实现界面的测试。换句话说叫  支持这些浏览器驱动。话说回来，不也是一个浏览器吗，那么  支持不？答案是肯定的，这样二者便可以实现无缝对接了。
然后又有什么好消息呢？支持多种语言开发，比如 ，，等等，有  吗？那是必须的！哦这可真是天大的好消息啊。
嗯，所以呢？安装一下  的  库，再安装好 ，不就可以实现＋＋ 的无缝对接了嘛！ 用来渲染解析， 用来驱动以及与  的对接， 进行后期的处理，完美的三剑客！
有人问，为什么不直接用浏览器而用一个没界面的  呢？答案是：效率高！
 有两个版本，目前最新版本是 

 ，又名 ，它的主要新功能是集成了   以及  曾经是  的竞争对手。也就是说   是  和  两个项目的合并，即   兼容 ，它既支持   也支持  。

更多详情可以查看  的简介。



嗯，通过以上描述，我们应该对  有了大概对认识，接下来就让我们开始进入动态爬取的新世界吧。
本文参考内容来自

官网
文档

安装
服务器是腾讯云

首先安装 
  
或者下载源码

下载源码

然后解压后运行下面的命令进行安装
  
安装好了之后我们便开始探索抓取方法了。
快速开始

初步体验

我们先来一个小例子感受一下 ，这里我们用  浏览器来测试，方便查看效果，到真正爬取的时候换回  即可。
   

 = 

运行这段代码，会自动打开浏览器，然后访问百度。
如果程序执行错误，浏览器没有打开，那么应该是没有装  浏览器或者  驱动没有配置在环境变量里。下载驱动，然后将驱动文件路径配置在环境变量即可。

浏览器驱动下载

比如我的是  ，就把下载好的文件放在  目录下就可以了。

模拟提交

下面的代码实现了模拟提交提交搜索的功能，首先等页面加载完成，然后输入到搜索框文本，点击提交。
   
   

 = 

   
 = ___
_
_
 _
同样是在  里面测试，感受一下。

                        “”            ’                       

其中方法会打开请求的， 会等待页面完全加载完成之后才会返回，即程序会等待页面的所有内容加载完成，渲染完毕之后才继续往下执行。注意：如果这里用到了特别多的  的话，程序可能不知道是否已经完全加载完毕。

             _                ___ 

 提供了许多寻找网页元素的方法，譬如___的方法。例如一个输入框可以通过  ___ 方法寻找  属性来确定。

                        

然后我们输入来文本然后模拟点击了回车，就像我们敲击键盘一样。我们可以利用  这个类来模拟键盘输入。
最后最重要的一点
获取网页渲染后的源代码。
输出_属性即可。
这样，我们就可以做到网页的动态爬取了。

测试用例

有了以上特性，我们当然可以用来写测试样例了。
 
   
   

 

     
         = 

     ____
         = 
        
         
         = ___
        _
        _
              _

     
        

 ____ == ____
    
运行程序，同样的功能，我们将其封装为测试标准类的形式。

                                                                                                                    

测试用例是继承了  类，继承这个类表明这是一个测试类。方法是初始化的方法，这个方法会在每个测试类中自动调用。每一个测试方法命名都有规范，必须以  开头，会自动执行。最后的  方法会在每一个测试方法结束之后调用。这相当于最后的析构方法。在这个方法里写的是  方法，你还可以写  方法。不过  方法相当于关闭了这个  选项卡，然而  是退出了整个浏览器。当你只开启了一个  选项卡的时候，关闭的时候也会将整个浏览器关闭。
页面操作

页面交互

仅仅抓取页面没有多大卵用，我们真正要做的是做到和页面交互，比如点击，输入等等。那么前提就是要找到页面中的元素。提供了各种方法来寻找元素。例如下面有一个表单输入框。
 = = = 
我们可以这样获取它
 = ___
 = ___
 = ____
 = ___=
你还可以通过它的文本链接来获取，但是要小心，文本必须完全匹配才可以，所以这并不是一个很好的匹配方式。
而且你在用  的时候还需要注意的是，如果有多个元素匹配了 ，它只会返回第一个匹配的元素。如果没有找到，那么会抛出  的异常。
获取了元素之后，下一步当然就是向文本输入内容了，可以利用下面的方法
_ 
同样你还可以利用  这个类来模拟点击某个按键。
_  _
你可以对任何获取到到元素使用 _ 方法，就像你在  里面点击发送键一样。不过这样会导致的结果就是输入的文本不会自动清除。所以输入的文本都会在原来的基础上继续输入。你可以用下面的方法来清除输入文本的内容。

这样输入的文本会被清除。

填充表单

我们已经知道了怎样向文本框中输入文字，但是其它的表单元素呢？例如下拉选项卡的的处理可以如下
 = ___=
_ = ____
   _
        _
    
首先获取了第一个  元素，也就是下拉选项卡。然后轮流设置了  选项卡中的每一个  选项。你可以看到，这并不是一个非常有效的方法。
其实  中提供了一个叫  的方法，可以帮助我们完成这些事情。
   
 = ___
__
___
__
如你所见，它可以根据索引来选择，可以根据值来选择，可以根据文字来选择。是十分方便的。
全部取消选择怎么办呢？很简单
 = ___
_
这样便可以取消所有的选择。
另外我们还可以通过下面的方法获取所有的已选选项。
 = ___
__ = __
获取所有可选选项是
 = 
如果你把表单都填好了，最后肯定要提交表单对吧。怎吗提交呢？很简单
___
这样就相当于模拟点击了  按钮，做到表单提交。
当然你也可以单独提交某个元素
方法， 会在表单中寻找它所在的表单，如果发现这个元素并没有被表单所包围，那么程序会抛出  的异常。

元素拖拽

要完成元素的拖拽，首先你需要指定被拖动的元素和拖动目标元素，然后利用  类来实现。
 = ___
 = ___

   
_ = 
___ 
这样就实现了元素从  拖动到  的操作。

页面切换

一个浏览器肯定会有很多窗口，所以我们肯定要有方法来实现窗口的切换。切换窗口的方法如下
__
另外你可以使用 _ 方法来获取每个窗口的操作对象。例如
   _
    __
另外切换  的方法如下
__
这样焦点会切换到一个  为  的  上。

弹窗处理

当你出发了某个事件之后，页面出现了弹窗提示，那么你怎样来处理这个提示或者获取提示信息呢？
 = __
通过上述方法可以获取弹窗对象。

历史记录

那么怎样来操作页面的前进和后退功能呢？



处理

为页面添加 ，用法如下
    


           
 = {‘’  ‘’ ‘’  ‘’}
_
获取页面 ，用法如下
     


           
_
以上便是  的处理，同样是非常简单的。
元素选取
关于元素的选取，有如下的单个元素选取

______________________________

多个元素选取

___________________________

另外还可以利用  类来确定哪种选择方式
   

_ = 
_ 
 类的一些属性如下
 = 
 = 
_ =  
__ =   
 = 
_ =  
_ =  
_ =  
更详细的元素选择方法参见官方文档

元素选择

页面等待
这是非常重要的一部分，现在的网页越来越多采用了  技术，这样程序便不能确定何时某个元素完全加载出来了。这会让元素定位困难而且会提高产生  的概率。
所以  提供了两种等待方式，一种是隐式等待，一种是显式等待。
隐式等待是等待特定的时间，显式等待是指定某一条件直到这个条件成立时继续执行。

显式等待

显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，那么便会抛出异常了。
   
   
   
   _  

 = 
___

     =  
        ___ 
    

    
程序默认会  调用一次来查看元素是否已经生成，如果本来元素就是存在的，那么会立即返回。
下面是一些内置的等待条件，你可以直接调用这些条件，而不用自己写某些等待条件了。


_
_
___
___
_
____
_____
______
_______
___
___ –     
_
___
____
____
_____
__


   _  

 =  
 = ___

隐式等待

隐式等待比较简单，就是简单地设置一个等待时间，单位为秒。
   

 = 
_  
___
 = ___
当然如果不设置，默认等待时间为。
程序框架
对于页面测试和分析，官方提供了一个比较明晰的代码结构，可以参考。

页面测试架构


到最后，肯定是放松最全最重要的了，比较多，希望大家可以多加练习。



结语
以上就是  的基本用法，我们讲解了页面交互，页面渲染之后的源代码的获取。这样，即使页面是  渲染而成的，我们也可以手到擒来了。就是这么溜！
相关推荐
基础及示例腾讯云搭建环境过程本文作者： 

接 《 全面进阶  直播上》
  
在没有  出现之前，前端对  的操作，仅仅局限在对视频文件的操作，而并不能对视频流做任何相关的操作。现在  提供了一系列的接口，使开发者可以直接提供  。
那  是如何完成视频流的加载和播放呢？
入门实例
这可以参考  的  简介
   = 

  {
    =  
   = 
   
}  {
         
}

  {
  
    =  = 
    = 
    = 
    = 
  
     {
       
    }
     {
        {
            ===  {
          
        }
      }
      
    }
}
 可以从上面的代码看出，一套完整的执行代码，不仅需要使用  而且，还有一下这些相关的 。











我们简单讲解一下上面的流程。根据  的阐述，整个过程可以为：


第一步，通过异步拉取数据。
第二步，通过  处理数据。
第三步，将数据流交给  标签进行播放。

而中间传递的数据都是通过 的形式来进行传递的。

中间有个需要注意的点， 的实例通过  创建的  并不会同步连接到 。换句话说， 只是将底层的流和  连接中间者，一旦两者连接到一起之后，该对象就没用了。
那么什么时候  才会和  连接到一起呢？
创建实例都是同步的，但是底层流和  的连接时异步的。 提供了一个 事件给我们进行这项异步处理。一旦连接到一起之后，该   就没用了，处于内存节省的目的，可以使用  销毁指定的 
 。 
 

 {
    
}
 对流的解析
 提供了我们对底层音视频流的处理，那一开始我们怎么决定以何种格式进行编解码呢？
这里，可以使用来设置相关的编码器：
  =  =   
    = 
 然后通过，异步拉取相关的音视频流：

={
     
}
={
    
}
 如果视频已经传完了，而相关的  还在占用内存，这时候，就需要我们显示的中断当前的  内容。那么最终我们的异步处理结果变为：

={
     
}
 {
        {
       是否有持续更新的流
            ===  {
         没有，则中断连接
          
        }
      }
      
    }
 上面我们大致了解了一下关于    的大致流程，但里面的细节我们还没有细讲。接下来，我们来具体看一下  一篮子的生态技术包含哪些内容。首先是， 

 可以理解为多个视频流的管理工具。以前，我们只能下载一个清晰度的流，并且不能平滑切换低画质或者高画质的流，而现在我们可以利用  实现这里特性。我们先来简单了解一下他的 。
 的创建
创建一个    =  
相关方法

该是用来返回一个具体的视频流，接受一个  表示该流的编码格式。例如：
   =  = 
  = 
  是直接和视频流有交集的 。例如：
  _ {
    = 
    = 
     {
      _ {
      
      
    }
     通过  添加视频 
    
  }
}
 它通过直接添加视频流，实现播放。不过，在使用  创建之前，还需要保证当前浏览器是否支持该编码格式。

用来移除某个 。移除也主要是考虑性能原因，将不需要的流移除以节省相应的空间，格式为： 

用来表示接受的视频流的停止，注意，这里并不是断开，相当于只是下好了一部分视频，然后你可以进行播放。此时， 的状态变为：。例如：
   = 
    = 
     {
      _ {
        结束当前的接受
        可以播放当前获得的流
    }
    
  }

该是用来检测当前浏览器是否支持指定视频格式的解码。格式为：  =   返回值为 
  可以为  或者   。
例如：
  不同的浏览器支持不一样，不过基本的类型都支持。
  ，这里应该为  
  
 =   
 这里有一份具体的  参考列表。
 的状态
当  从创建开始，都会自带一个 属性，用来表示其当前打开的状态。 有三个状态：

 当前  没有和  比如： 相关联。创建时， 就是该状态。
  打开，并且准备接受通过  添加的数据。
 当  执行完成，会变为该状态，此时， 依然和   连接。
  =  
  默认为 
当由  变为  状态时，需要监听  事件。
 = 
 
 针对这几个状态变化，提供了相关的事件：，，。

 当    或者    时触发。
 当    时触发。
 当    或者    时触发。

 还提供了其他的监听事件 ，，，，，，，，， 这里主要选了比较重要的，其他的可以参考官方文档。
 属性
比较常用的属性有 ，。

 获得当前媒体播放的时间，既可以设置，也可以获取。单位为 秒
 =   设置媒体流播放的时间
  =   获得媒体流开始播放的时间
在实际应用中为：
  _ {
    
     =   设置当前流播放的时间
    
  }

 获得当前  的状态。取值上面已经讲过了，，。
  =  
此时的  状态为 
以及：
  _ {
     调用该方法后结果为：
   
 }
除了上面两个属性外，还有 ，这两个属性。用来返回通过  创建的  数组。这没啥过多的难度。


接下来我们就来看一下靠底层的。

 是由 创建，并直接和 接触。简单来说，它就是一个流的容器，里面提供的 ，来进行流的操作，它可以包含一个或者多个  。同样，接下来，我们再来看一下该构造函数上的基本属性和内容。
基础内容
前面说过  主要是一个用来存放流的容器，那么，它是怎么存放的，它存放的内容是啥，有没有顺序等等。这些都是  最最根本的问题。，接下来，我们来看一下的它的基本架构有些啥。
参考 ，可以基本了解到里面的内容为：
     {
                        
                   
                
                            
            
            
             
                            
                
                      
                      
                      
                      
                      
      
     
         
}
 上面这些属性决定了其  整个基础。
首先是 。上面说过， 里面存储的是  就是你每次通过  添加进去的流片段。 有两种格式：

 乱序排放。通过  来标识其具体播放的顺序。比如：的 ， 的  等。
 按序排放。通过  的顺序来决定每个  添加的顺序。 根据  自动产生。

那么上面两个哪个是默认值呢？
看情况，讲真，没骗你。
当   天生自带，那么  就为  ，否则为 。所以，一般情况下，我们是不用管它的值。不过，你可以在后面，将  设置为  这个是没毛病的。反之，将  设置为  就有问题了。
  = 
  ==  {
   = 
}
 然后另外两个就是  和 。

：返回一个  对象。用来表示当前被存储在  中的 。
 返回 ，表示当前  是否正在被更新。例如    调用时。

另外还有一些其他的相关属性，比如 ，这里就不多说了。实际上， 是一个事件驱动的对象，一些常见的处理，都是在具体的事件中完成的。那么它又有哪些事件呢？
事件触发
在  中，相关事件触发包括：

： 当  由  变为 。
：当  方法被成功调用完成时， 由  变为 。
  已经结束
 在  过程中发生错误， 由  变为 。
 当  过程中，使用  方法废弃时，会触发。此时， 由  变为 。

注意上面有两个事件比较类似： 和 。都是表示处理的结束，不同的是， 比  先触发。
   {
     当指定的  加载完后，就可以开始播放
      
      
    }
相关方法
 处理流的方法就是  ：  。另外还有一个中断处理函数 。

：用来添加 。该  一般是通过  的  来获取的。
 ： 用来移除具体某段的  。   都是时间单位。用来表示具体某段的   的范围。

 用来放弃当前  流的操作。不过，该方法的业务场景也比较有限。它只能用在当  正在更新流的时候。即，此时通过 已经接受到新流，并且使用  添加，此为开始的时间。然后到  事件触发之前，这段时间之内调用。有一个业务场景是，当用户移动进度条，而，此时  已经获取前一次的  ，那么可以使用 放弃该操作，转而请求新的  。具体可以参考： 使用


上面主要介绍了处理音视频流需要用的  技术，后面章节，我们接入实战，具体来讲一下，如何做到使用  进行  和 。

原文链接：如何搭建数据可视化系统，使复杂和庞大数据用丰富的设计语言清晰表达，并形成鲜明的设计风格？我们把数据可视化的元素进行拆分并建立相应的规范体系。
图表设计
图表基本类型
六种基本图表涵盖了大部分图表使用场景，也是做数据可视化最常用的图表类型：

柱状图 用来反映分类项目之间的比较；
饼图 用来反映构成，即部分占总体的比例；
折线图 用来反映随时间变化的趋势；
条形图 用来反映分类项目之间的比较；
散点图 用来反映相关性或分布关系；
地图 用来反映区域之间的分类比较。

基本图表类型都有通用的样式，不过多的展开讲解。我们更多的考虑如何选择常用图表来呈现数据，达到数据可视化的目标。基本方法：明确目标 — 选择图形 — 梳理维度 — 突出关键信息。
、明确目标
明确数据可视化的目标，通过数据可视化我们要解决什么样的问题，需要探索什么内容或陈述什么事实。
、选择图形
围绕目标找到能提供信息的指标或者数据，选择合适的图形去展示需要可视化的数据。
  整理的图表类型选择指南图示，将图表展示的关系分为四类：

、选择维度
分辨哪些是有价值的值得关注的维度，选择数据展示的视角。基本图表一般有哪些可用维度呢？
基本图表维度
 
对照以上图形维度，制作可视化图形。
、突出关键信息
根据可视化展示目标，将重要信息添加辅助线或更改颜色等手段，进行信息的凸显，将用户的注意力引向关键信息，帮助用户理解数据意义。 使用率监控案例，可视化的目标就是检测  的使用情况，特别是异常使用情况。所以图中将 最高临界线使用特殊的颜色和线形标识出来，异常的使用段用颜色帮助用户识别。

图表排布
在可视化展示中，往往有多组数据进行展示。通过信息的构图来突出重点，在主信息图和次信息图之间的排布和大小比例上进行调整，明确信息层级及信息流向，使用户获取重要信息的同时达到视觉平衡。
常用的图表排布方式 
以扶贫展示项目为例，以地图的方式展示出扶贫的概况信息，两边排布扶贫的具体内容信息，在构图和上突出主次。并在主要信息的背景上做动画处理，进一步加强信息层级及视觉流向的引导。
 
动效设计
目前越来越多的可视化展示的数据都是实时的，所以动效在可视化项目中的应用越来越广泛，动效设计肩负着承载更多信息和丰富画面效果的重要作用。
、    信息承载
在可视化设计中经常遇到，非常多的数据信息需要展示在一个大屏幕上。遇到这种情况，需要对信息进行合并整理或通过动画的方式，在有限的屏幕空间里承载更多的信息，使信息更加聚合，同时使信息展示更加清晰，突出重点。
、    画面效果
增加细节及空间感，背景动效使画面更加丰富。单个图表的出场动画，使画面平衡而流畅。减少了图表在出现或数据变化时的生硬刻板。
数据可视化动画在设计上重要的原则是恰当的展示数据。动画要尽量的简单，复杂的动画会导致用户对数据的理解错。动画要使用户可预期，可使用多次重复动画，让用户看到动画从哪里开始到哪里停止。
配色方案
由于图表的特殊性，数据可视化的配色方案和配色要求具有独特性。配色方案要充分考虑到特殊人群对数据图的可读性。丰富的色系，至少  种才可满足图表应用的各种场景。同时配色需要有可辨识性，色彩选择需要有跨度。
背景色定义
配色体系分为深色底、浅色底、彩色底的图表设计。背景色的选择与可视化展示的设备相关。
、大屏背景色
在大屏设备中普遍用黑色深色作为底色，以减少屏幕拖尾，观众在视觉上也不会觉得刺眼。所有图表的配色需要以深色背景为基础。保证可视化图的清晰辨识度，色调与明度变化需要有跨度。
淘宝双  大屏设计
 
、中小屏背景色
中小屏幕显示选择范围就比较广，浅色、彩色、深色均可以做出很好的设计，但是相比之下，浅色底会使数据更加突出。
中小屏幕浅色、深色、彩色设计
 
图表色定义
在图表的颜色运用上，色彩是最直接的信息表达的方式，往往比图形和文字更加直观的传递信息，不同颜色的的组合也能体现数据的逻辑关系。
、色彩辨识度
要确保配色非常容易辨识与区分，对于使用单一色相配色，明度差异需要全局考虑，明度跨度一定要够大。可以在灰度模式下测试配色的辨识度。
 
 
、色彩跨度
多色相配色在数据可视化中是相当常见的，多色相配色使用户容易将数据与图像联系起来。如何有效利用色调的变化来传达数据信息？
带明度信息的色环
 
当需要的颜色较少时，避免使用相近的色相同类色和相近色。尽量选择对比色或互补色，这样可以使不同属性数据在图表中展示更加清晰。
例如：美国大选，使用红色和蓝色两种对比色，将清晰的将选票结果展示于地图上。
 
当图表需要的颜色较多时，建议最多不超过  种色相。通常情况下人在不连续的区域内可以分辨  种不同色相。过多的颜色对传达数据是没有作用的，反而会让人产生迷惑。如何让多种色相的颜色看来和谐？有几种取色的方法：
色环提取法：选择同一饱和度和明度的不同色调作为可视化图表的配色，这样可以使图表看起来协调统一。
 
渐变色取色法：不同明度和色相的取色，淡紫到深黄的过渡，与淡黄到深紫的过渡，感觉是一样的配色，但是实际两种配色实际感觉却差别很大。
 
淡黄到深紫的过渡看起来更加自然，这是因为我们在自然中大多存在的都是淡黄向深紫的过度。如下图，所以采用仿自然的配色方式会让图表更加自然。
 
在取渐变色时，可以在  中根据数据的数量，拉辅助线到取色点的位置，从断点处选取颜色，然后对渐变进行测试与调整，测试配色在实际运用中的效果，选取最优的配色。
 
取色的实际应用：
 
字体设计
文字是数据可视化的核心内容之一，文字和数字是数据信息传达的重要组成部分，为了更加清晰精确的传达信息，增加信息的可读性，从字体选择，到字体大小，字体间距都有特定的要求。
字体选择
、 辨识度
 设计中使用无衬线字体是  界的共识，但是对于数据可视化设计而言，字体大小的跨度可以非常大，所以在无衬线字体中需要选择辨识度更高的字体，大的宽度比值和较高的  值的字体有更高的辨识度，选择字母容易辨识不会产生奇异的字体更有利于用于数据可视化设计。
 
、 更加灵活的字体字体需要更加灵活，应该支持尽可能多的使用场景，数据可视化项目经常显示在不同大小、不同的终端上，需要选择更加灵活的字体可以在低分辨率的小屏或超大屏幕上运行良好。
、 字间距
宽松的字母间距字母之间的间距应小于字偶间距和合适的中文字间距。
 
字体大小
文字的可读性对数据可视化起着至关重要的作用，设置小字体的极限值，以保证在最小显示时不影响对文字的辨认与阅读。
中西文间隔
中西文混排时，要注意中文和西文间的间隔，一般排版的情况都是中文中混排有西文，所以需要在中西文间留有间隔，帮助用户更快速的扫视文字内容。
 
极限处理
很多数据是多种多样不可预知的，所以在可视化时需要处理各种极限问题，才能使数据清晰表达。
数据展示细节处理
如下图，当水平排列数据时，图表空间不够，导致数据不可辨识，对数据进行旋转处理，不利于阅读，可以选择简写的方式来排布展示数据，或通过改变图表形式来解决问题。
 
选择合适的图表形式
虽然饼图可以展示份额，但过多的分项已经使饼图不堪重负，不能很好的传达数据的意义，所以需要使用横向柱状图。
 
小结
我们生活在大数据时代，越来越多的数据被可视化。在构建可视化体系时，无论图表、颜色、字体、都是承载和传达数据信息的元素，设计的核心是“让数据清晰传达”。
参考：       一、优点分析
内网传输：和阿里云  一样，腾讯云  同样支持内网和外网文件传输，对于腾讯云服务器，使用内网传输绝对是最快、最稳定的备份方案！
免费方案：看了下腾讯云  的定价说明，发现对于备份网站来说简直是绝佳搭档，甚至可以说是钻了个空子希望腾讯云的同事看到别打我。。。！为啥这么说？
看下定价方案：
、入流量免费
相当于我们上传文件的流量都是免费的，不区分内外网哦！内网就不说了，都懂。

、各种免费额度
以七天循环备份份压缩包以来算，单压缩包支持×≈，应付一般网站的备份绝对是足够足够足够了！

二、准备工作
、开通，并创建
访问腾讯云开通对象存储服务，然后如图创建：

：我们只用于备份，且为私密资料，所以选择私有读写。
、添加密钥
接着，我们点击左侧的密钥管理，进入密钥界面如图创建密钥，如果先前已经有密钥了，则可以直接使用：

三、备份脚本
人生苦短，我用，这里就继续选择 来实现。
、环境准备
如下顺序安装腾讯云   插件
安装
  

升级装的可能版本比较旧
   

安装腾讯云 插件
  _
如果不是，请自行搞定，这里不再赘述。
、上传脚本
参考官方文档，写了一个简单够用的上传脚本：
    
     

 _  
 _  
 

 =  替换为所在区域，可选华东华南华北西南

脚本需要传入个参数
     
          = 
    _  = 
    _ = 
         = 
         = 
     = 
     = 

        _ _     
    

认证和上传
_ =  _ _
 =        
__ 
__ = __
                 __ 
使用方法：将上述代码保存为 ，并上传到服务器，执行如下命令可开始上传文件到：
   _ _ 名称 域名 _
其中：

个参数是、认证和认证密钥，也就是前文创建并备忘的密钥信息；

第个参数是前文创建的名称，比如；

第个参数是需要备份的域名新增的：主要是为了区分下；

第个参数是要上传的本地文件的绝对路径。

 特别说明：更新到版本后，才发现还需要传入一个地域的参数，这里就不再修改脚本代码了，请直接修改上述代码的 的值，否则会报错误！目前可选有华东华南华北西南，具体请看自己的所在地域以及腾讯云关于地域的文档。

执行后，就能在的界面看到了上传的文件：

四、定时备份
有了上传脚本，继续结合之前张戈博客分享的七天循环备份脚本，实现循环备份到了，既安全还节省空间。
、适合七天循环备份脚本


                
       

   ©                  


=
=
={}
=
       
=    
   ||    
= 
=` `
= 
= 

 新增的上传文件函数请按照实际情况修改，认证、认证密钥和名称

{
       认证 认证密钥 名称  
              ==  
    
              
    
}


{

 
===================================== =========================================
    
    
     
     
     
     
     _
     

    _   

    
    \
     
     _
     _
     

     
=====================================  ==============================================


 
}


{
    =
    =
    =
    =
    _=
      _ ||   _ ||  _           
     _
    如果是要备份远程，则修改如下语句中为远程地址
          = _\__\
      _\__\ ||            
       _\__\ \__\  \
      _\__\
}


{
    =
    _=
    _=
      _ ||  _           
      _ ||   _ ||  _           
      _\_\    _\_\
       _\_\ _  \
      _\_\    
}

    
      
         |  
             
        
        
         |  
           
          
        
         
        
        
        
    


、使用方法
将上述代码作如下修改：
、根据实际情况修改上述代码中的上传函数代码，比如密钥对和名称参考前文；
、替换代码中的=为自己设置的压缩包密码，不修改的话压缩文件解压密码为。
然后，将代码保存为，上传到服务器建议存放到和前文脚本的相同目录，比如 ，最后如下添加定时任务：
编辑
   

然后添加如下内容：

备份数据库参数依次为：、域名、数据库名称、数据库用户名、对应密码、备份路径 可选： 删除本地压缩包
               

备份网站文件参数依次为：、域名、网站根目录、备份路径 可选： 删除本地压缩包
            

按下键盘，输入  保存即可
全部完成后，就能实现本地天循环备份和远程备份了！
在文章的最后，为了方便广大代码小白朋友，特提供本文涉及脚本的打包下载：
五、幕后花絮
在折腾的时候，第一眼其实被腾讯云的说明文档虐到了：

只说了如何安装插件，然后直接来个函数，然后就没然后了，到底如何这个？一脸懵逼。。。最后在的  中才找到了完整的：
在这懵逼期间，我甚至用上了腾讯云做好的本地迁移工具，实际也是非常好用，简单配置下就能在后台定时上传更新的文件到了：

篇幅有限，这里就不深入介绍了，除此之外，还提供了其他非常实用的工具，比如工具、七牛以及迁移工具等，感兴趣的朋友只需要看下 官方文档 就会弄了！

相关推荐【腾讯云的种玩法】 整合  对象存储服务，享受无限容量存储服务【腾讯云的种玩法】如何腾讯云存储上搭建一个博客反向代理腾讯云的一个坑作者 | 宋迎军

一些预先准备的环境 
             
安装 
     
配置
 编辑 
  
把下面换成腾讯云服务器的外网，其他的不用修改。
  
_= 
_= 
= 
= 
  
= 
= 
  
= 
= 
= 
= 
= 
= 
= 
= 
=  
= 
= 
=
编辑
  
  
    
换成腾讯云服务器的外网 你自己定一个。
 修改添加 并生效
 
在的末尾加上如下内容。
_ =  
_ =  
_ =  
_ =  
_ =  
_ =  
__ =  
_ =  
_ =  
____ = 
生效上面的修改使用如下命令 
 
验证运行状态 
  

 
如果出现如下内容，说明已经成功 
            
      
  _  
       
    
     _  
      _  
      
        
        
     
      
     
   
 编辑  
  写客户端的内网段， 写客户端内网 
  
  
  =  
  =  
  =  
  =  
  =  
 =  
  =  
 =  
  = 
配置用户名密码编辑 
  写登录的用户名， 写登录的密码 
      
     
   
重启 
  
添加自启动 
   
   
  
接下来就是你通过电脑连接首先，需要修改注册表 
__ 的值修改为 
如果没有项，需要点击右键新建，重命名为，值设置为
其次，重启你的本地电脑必须重启哦
再次，创建一个连接，可以参考下面的链接
原文链接：===

相关推荐
后台系统搭建记录【腾讯云的种玩法】系统文件权限的系统阐述与演示运维安全是企业安全保障的基石，不同于安全、移动安全或者业务安全，运维安全环节出现问题往往会比较严重。就此，《安全智库》记者采访了《日志易》产品总监饶琛琳，让我们跟随记者，一起来听听。
记者：服务和传统软件产品或云服务在安全方面有哪些差异？
饶： 主要体现在几个方面一个方面就是传统软件本身的安全性，也就是本身已经在一个内网之中，更多的考虑的就是，对方会不会进入到我们的内网来，或者说进到内网以后，怎么来保障像注入等这种软件架构上的事情。而或者云服务，要把很多的精力放在传统的内网服务，而不会去考虑用户基本就是我们内部的人。
但是或者云服务是不一样的，比如前段时间出的这样一个事情，就是有人问说阿里云上怎么不同的客户互相之间，二层的网络之间居然不是隔离呢？阿里云说其实我们本来是应该做隔离的，但是由于不方便，就把默认选项改了。这其实就是云服务很需要去关注的。云平台之上的隔离，当身处内网之中，是不需要去考虑太多的，但是在做云服务或者服务的时候，不同的租户之间的隔离是非常重要的。
记者：在云环境下，运维工作有哪些挑战？您是如何应对的？
饶：云环境下，我觉得运维的挑战跟之前比，有一些可能不太统一的地方，主要在于，以前传统的地方从底层的机架、服务器都会有人在管，但是在云环境下，更多的是需要调用，比如说调用创建了一台主机，调用去生成了一个服务，可能给运维人员的一个感觉就是，我们的重要性是不是在下降？当初我们做的很多活现在就被机器代替了！这其实是一个从表面上看起来很有挑战性的事情，这就是促进运维人员应该去面对的一个现实，就是我们运维真正的目的，不是管好服务器就，这其实不应该叫运维工程师，而是应该叫机房管理员。
运维工程师真正该做的事情是怎么去提高好运维的站点。运维站点可能是网站的站点，普通网站，也可能现在纯粹的后面没有太多的只是一些接口，运维的站点，服务好客户，而服务好的话，除了保证稳定性、提高性能等，我们应该抓住一些实质，其实调不调没有关系，而是我知道服务好不好，有没有办法让它更好。调去新创建几台主机，这个很简单，不管是运维人员还是开发人员做的，这个都，但是什么时候该调这个去创建主机？这台主机我创建的是有价值的。这个时间点的把握，怎么把这个事情运用在最恰当的时候，这是在云环境下运维工程师们应该重点去考虑的一个方向，以后应该是往这条路上去走的。
记者：谈谈现在火热的人工智能，运维会不会逐步被机器学习取代
饶：我刚刚前面其实讲云的时候其实已经提到了一点，运维有一些工作是迟早要被机器去代替的，但是另外一部分，可能是不太一样的地方，除了一些标准的部署上架的工作之外，剩下的一部分工作，刚刚我们提到保证服务的可用性和提高服务的性能，这里保证可用性就涉及到一个很大的问题就是故障定位，出了一个问题怎么找到它，它的根源在哪儿？
这块目前我看到的情况，我们可以通过一些机器学习的算法，比如说监控了有个机器指标，大概可能有二三十个跟报警的那个差不多，那下一步人就要去操作了，因为这是机器学习很重要的一点，就是机器学习是不讲因果性，只讲相关性，所以我们经常看到有人在讲人工智能的时候有一些笑话，今天下雨了，明天怎么样，这个其实是相关的，从这个曲线上来看，发生了了也发生了，它其实是相关性，并不是因为所以，这一点在目前的运维工作上也是类似的道理，这个时候是需要运维人员通过经验来弥补后来的这一段的。
记者： 近几年，运维领域有什么重要进展？
饶：运维领域这些年的进展主要两个方面。一个方面的是在容器编排这块，就是所谓的，这几年确实发展的很快，尤其包括在之上，，等，它是大大方便了运维部署，降低了部署成本，所以这也是运维以后部署这件事情，可能以后运维真的就不用做了。以前在虚拟化时代，其实因为虚拟化本身部署也挺辛苦的，但是现在确实把成本降得很低。
另一个方面就是我们日志易在做的事情 ，怎么更快的提高数据 对服务的可用性以及性能提高的这一部分，就是降低，或者降低，这一部分原先其实也是很靠经验的。你可能工作了年了，看见这个事情有经验了，可能就会去猜，觉得是这个样子，然后我们就去查，但是现在有一套数据分析的平台在支撑，之后这种大概、可能、猜测尝试的时间就会被大大的缩短，故障的时间就会随之降低下来。因为运维本质其实是一个试错的工作，你有个思路，赶紧去试第一个，不对，赶紧放弃去试第二个，如果原先靠人的话，试个大概就需要个小时，是现在有这样一个统一的平台，你可能试个，可能也就需要分钟或者分钟，那问题就一定被解决了。
记者：对于一些中小客户，在安全零基础的情况下，您对安全建设有哪些建议？资源短缺、人力极少的情况下做好安全运维您有哪些高招？
饶：如果安全基础的话，就是卡好最容易被攻破的地方，比如简单密码或者一些基础的端口，不要成为最短板。
如果资源短缺、人力也少的话，安全事大，我们有必要来投入钱或者资源，去采购一些，至少能够保证最关键的东西，核心数据确实是需要去投入的，不管投入的是什么，有资源投资源，有人投人，如果都没有，那就投点钱吧
本文采访内容仅代表嘉宾观点，不代表《安全智库》观点。可能是互联网公司里面熬夜最多，背锅最多的岗位之一，腾讯云数据库团队的同学结合自身的成长经历，用漫画的形式为我们分享了一位是如何从菜鸟成长为大神，走上升职加薪，迎娶白富美之路的。



相关阅读：在云端快速构建一个站点【腾讯云的种玩法】构建企业级应用环境之数据层面优化一【腾讯云的种玩法】构建企业级应用环境之数据层面优化二以西游记之大圣归来的背景，创作出的手游《大圣归来》，在发行之初就选择了腾讯云。下面来跟着云一起看看这款游戏上了腾讯云所得的收益。在上一篇文章中，我给大家分享了，如何能快速入门。是一个用于在浏览器中绘制图形的库，其底层实际是对浏览器提供的 进行了封装。作为一个好奇宝宝，看到了那些神奇的绘制图形，又怎么能抑制住想要钻进去一探究竟的冲动呢？所以今天的文章，就来给大家分享一下本身。
全写  是一种绘图标准，这种绘图技术标准允许把和  结合在一起，通过增加  的一个绑定，可以为 提供硬件加速渲染，这样开发人员就可以借助系统显卡来在浏览器里更流畅地展示场景和模型了，还能创建复杂的导航和数据视觉化。
以上是在百科上的一段介绍，说白了，就是通过浏览器提供的接口，我们能直接和底层的库打交道。由于能直接调用底层接口，并且有硬件加速，因此要比普通的  性能要高出不少。这里有一个对和  的性能对比实验___。在实验中，通过加载一幅图片并随机显示在中的某个位置，通过定时修改图片的颜色，并记录页面的。

从结果中可见，当需要执行大量绘制任务时，的性能远远超越了  ，达到了后者的倍。
即然性能这么高，为什么没有看到在日常开发中有大规模的应用呢好吧，可能是我写的代码太少了。 我想至少有以下两个原因。第一，由于是直接调用底层的，这使得的接口十分晦涩，对于一般的开发人员来说，门槛比较高。第二，的兼容性并不好，从上，我们可以看到：

只有和对有比较好的支持，则要到后的版本才支持，则只是部分支持。因此，一般的情况，我们都会对浏览器做 ，如果浏览器不支持，就需要有一个  的降级方案，而就是这么处理的，在里，除了有一个，还有一个，以备不时之需。
接下来，我们就通过代码，直接感受一下的高冷。为了能让大家有一个直观的感受，我同时使用  和，在上绘制一个红色的矩形：

 =__

      = 
      = 

       

     = 
       


上面这段代码，我们应该比较熟悉，  给我们提供了非常直观的接口，直接就可以在中绘制。显示的效果如下：

接下来我们再来看看的版本：
 =__

      = 
      = 

     _ = `
          _

          {
            _ = _
        }
    `

     _ = `
          

          {
            _ =    
        }
    `

      = _

     _
    

      = _

     _
    

      = 

     
     

    
    

      =  
            
             
           
            
    

      = 

    _ 
    _  _

     _ =  _

    _     
    _

       
    __

    _  


就是这么酸爽┬＿┬。即使是绘制一个矩形这么简单的任务，都不能让你省心，就更别说要在里绘制图像了。但希望各位小伙伴不要被上面这堆东西吓唬到。让我来带这大家一步一步的解读上面的代码。
要解读上面这段代码，我们首先要重新包装一下，把那些细枝末节先隐藏起来，毕竟裸露不一定就代表性感。通过函数的抽象，上面的代码可以写成下面的样子：
 =__

      = 

     获取上下文
      = 

     编译着色器代码
     _ _

     往顶点数据缓存冲写入数据
     

     使着色器代码中的_变量，指向顶点数据缓冲区
     _   

     清除颜色缓冲区中数据
        

     根据着色器代码绘制图像
     


是不是觉得没那么心塞？简化了代码后，我们就一步一步来解读。首先明确一点，也是基于标签的，只是获取的上下文不一样而已，在中我们获取的上下文对象是，但由于大部分浏览器并没有全面支持，而是通过这样一个带前缀的上下文来提供实验性质的功能。
有了的上下文，我们就可以开始调用为我们提供的接口。不过和  不同，并没有直接可以绘制图像的接口，而是需要我们一笔一划的告诉它如何绘制图像。因此，你首先得教会要如何绘制，而中表示如何绘制的方式称为着色器。
着色器并不是直接由来编写，而是用一种叫做 的语言来编写。该语言与语言很接近，但内置了一些方便计算机绘图的工具方法，具体可看这个地址，这里我就不详细说明了。
 =__

     顶点着色器
     _ = `
          _
          {
            _ = _
        }
    `

     片元着色器
     _ = `
          
          {
            _ =    
        }
    `


在中着色器分为两种，一种叫顶点着色器 ，会根据你提供的图形顶点数据，逐个顶点的执行顶点着色器来组装图形。另外一种叫做片元着色器 ，利用顶点着色器组装好图形后，就会进行图像栅格化，图像栅格化后，你就得到了对应的片元，你可以想象成屏幕上的像素，然后就会逐个片元的执行片元着色器来给图像上颜色，最终把绘制好的图像传给颜色缓冲区显示在屏幕上：

通过方法，我们已经教会了如何绘制图像。接下来，我们就要给告诉，你要绘制的是什么，也只是说，用于控制图形的顶点数据。然而要和的着色器沟通，我们并不能直接向着色器传入数据其实也是可以的，不过比较低效，我们需要先在内存里开辟一块缓冲区，然后通过提供的接口，把数据写入缓冲区，这就是方法的功能。

内存中有了数据后，我们就可以通过调用方法把着色器里的变量指向该块内存，这样当逐个顶点的执行顶点着色器时，就可以从对应的内存分块中读取到顶点数据。
一切准备就绪，我们终于可以开始绘制图像了，在绘制之前先调用方法，清除颜色缓冲区中的数据类似  中的最后调用方法，真正绘制出图像。终于松一口气。
通过上面的这个例子，我们明白了，要在中绘制图像，首先得教会如何绘制编写着色器，然后告诉要绘制什么创建缓存区，写入顶点数据，并关联到着色器变量上，最后清理一下之前绘制的东西，把准备好的图像绘制到屏幕上。
最后，我把上面用到的每一个方法补上：

 =__

      {
         
    }

        {
          = _

         
        

          = _

         
        

          = 

         
         

        
        

         = 
    }

       {
          = 

        _ 
        _  _
    }

          {
          =  

             
        
    }

          {
           
        __
    }

       {
        _  
    }


这就是我今天要给大家介绍的基础，以上！适用范围本文主要针对中小型互联网公司，特别适用于手机或者的后台架构，基本可以支撑万日活本文会对可能用到的相关技术进行技术选型的说明，以及技术的架构介绍，技术架构的介绍课程后面有地址，可以点进去查看。技术指标
说一下一些技术指标的计算过程可以作为其他同学的参考， 如果是万日活，使用集中在每天的小时，每个用户大概产生的请求，那么平均下来，我们系统大概应该支撑的请求为：         =  
业务数据 业务量，我们自己是新闻业务，可能会有其他的业务，比如游戏，商城等等，基本每天新增的业务数据都会在同一个量级， 每日， 另外跟用户相关的信息也是比较大的一块，比如用户的订阅等行为，一共万的用户，保存相关信息可能大概需要条的数据。缓存大小 主要业务数据和用户相关的热点数据限时保存在缓存中， 大概需要个左右。日志大小 用户日志和请求日志。 大概每天个左右
技术架构
整体架构因为是小公司，我们基于阿里云来搭建，对图中的内容和技术选型进行一下说明：
负载均衡可选方案：  要收钱，但是比较便宜，有保证，不会挂。 但是可配置的很少，不能根据域名做映射 没啥缺点，需要一定的知识。建议：    绑定域名作为统一的入口，然后每个服务器上再搭建
用于缓存静态文件等等。 七牛和阿里的都还可以。七牛要做的久一点， 各种图片处理的接口要完善一些阿里的要稍微好一点点， 但是没有不安全的访问方式，访问稍微没有那么灵活。 图片处理功能弱一点。
分布式调用框架目前可选的有         。 阿里的服务治理框架，已经不维护了，切换反应有点慢 当当基于搞的，还在维护可以一用，推荐。 微博的服务治理矿建， 刚开源，需要学习一下， 推荐。 阿里云服务，要收钱，侵入型很强，不推荐
可选的有：  ， 各有好处， 但是考虑到运维的难度，推荐。
用来做缓存， 自建成本有点高，需要 分片，集群，主从等等，很麻烦。 建议直接用阿里的
数据库主要基于读写分离和主从复制考虑，目前可以自建和选用阿里的。 要花钱，成本较高，没有必要自建， 不用中间件，直接写只读， 然后配置读写分离的数据源，内网进行读集群。解决之。
搜索建议， 可以自动同步数据库，除了搜索引擎的功能外，还可以做日志搜索，监控系统。
一些典型的业务场景说明把业务底层做成模块，通过分布式调用框架对外提供服务。后期进行到微服务的改造都会涉及。单独做一个小的系统来运行定时任务热点数据放缓存，然后通过来更新缓存日志等数据有必要可以考虑上个
可以参考：现在维护着一个新浪微博爬虫，爬取量已经亿，使用了部署分布式。
运行时会输出日志到本地，导致日志文件会越来越大，几十个，这个其实就是控制台的输出。但是这个日志其实有用的部分也就是最后那几百行而已，如果出错，去日志查看下出错信息就好了。
所以现在可以写一个脚本，来定时更新日志文件，将最后的行保存下来就好了。
默认的日志目录是在用户文件夹下的目录。
所以在这里我们指定=
新建脚本，内容如下：


 {
     
  
        
    
       
    
       
      =  
         
    
  
}

=
 
新建这样的一个脚本，然后命名为 ，我的直接放在了用户文件夹下。
然后创建定时任务。
执行
 
我们想要一分钟清理一次日志文件。
输入
      
然后退出之后，就可以每隔一分钟执行一次，清理日志了。
这样我们就不怕日志文件大量占用主机空间啦导语
在领域，文件上传，是一个古老的话题。对于不少网站而言，它是一个基础的功能。近些年以来，技术突飞猛进，唯独文件上传这一块却貌似依然停留在的年代。对于用户来说，最不能忍受的事情，大概就是上传到的时候突然卡住不动然后被告知要从头开始了。因此断点续传一直是网页开发者们着力解决的技术难题。早期由于技术限制，在网页上实现断点续传的唯一途径是使用插件。直到出现以后，基于以及 ，断点续传问题才得以较好地解决。
文件上传技术
文件上传的最基本形式，是使用表单元素：
 = = =
     = = 
     = =  

这种方式最简单也最直接，而且所有浏览器都支持：

选择文件后，点击 按钮就可以上传文件了。然而这种方式缺点也是特别明显的，首先它是“同步”上传的，也就是说，点了上传按钮后，页面就处于锁定状态。而且如果页面报错，已填写的内容可能会丢失，文件也要重新上传。
文件上传技术
表单的上传是“同步”的，有没有办法像请求那样，不刷新页面也能提交文件呢？在出现以前，只能用来做到这一点。方法是，生成一个，里面的内容是一个表单，当我们点击上传的时候，触发该表单进行提交，并在中返回一段进行回调处理即可。基于这个原理实现的组件，可以参考
该方案很好地解决了表单同步提交方式的不少问题，但上传的过程中无法看到进度。用户可能会等得比较焦虑，有没有方法在上传的时候看到进度条呢？
文件上传技术
曾经是网页世界里最闪亮的一颗星星。他除了播放多媒体以外，还提供了不少底层的文件操作接口。以后就开始提供类，例如使用可以打开文件选择器选择单个文件，选择多个文件 开始上传 把文件内容载入内存。通过这些方法，再结合方法与页面的进行交互，我们就可以做成一个基于的文件上传组件，常见的组件有比如，  。
从上面的分析来看，不仅能在上传的时候显示进度，而且一次可以选择多个文件。由于它能把文件的内容载入内容，因此理论上可以实现断点续传。然而，这种一次性把整个文件全部载入内容的方式太占用系统资源，决定了它并不适合来对大文件进行断点续传。
此外，由于已经逐步退出市场，基于它来实现文件上传的组件，可能无法在、等设备上使用。
文件上传技术
实际上，在早期除了上面说的三种技术外，还有用浏览器插件来实现文件上传的，例如早期的邮箱超大附件。但浏览器插件的兼容性比较差，开发维护成本也高，所以也逐步退出。
标准提出以后，网页开发者可以不借助第三方技术，只用就写出支持断点续传的上传方法。所谓断点续传，就是在上传文件的时候，每次向服务器发送一小片数据，当出现中断时可以跳过已发送的部分而续传。可以看出，断点续传的重要基础是分片。的 提供了文件的分片操作，但传统的不支持发送二进制数据，因此还需要利用的提供的来发送已读的文件片段这部分片段用对象封装起来。此外，如果要实现真正意义上的断点续传，也就是当页面刷新后对同一个文件续传，还需要在前端对文件进行识别，即或者等技术。
可见，基于实现一个断点续传的功能，可以不依赖任何第三方插件。然而，当前的浏览器市场里，浏览器，特别是不支持的依然占有相当高的份额。对于这部分浏览器用户，我们不得不继续沿用来兼容。
总的来说，一个好的上传组件，除了要支持断点续传，能提供上传进度显示，支持文件多选等操作，还要兼容各种常见的浏览器，保证基本的上传功能可用。本文所介绍的上传组件—— ，基于开源组件改造而成。除了支持基本的断点续传，还支持文件识别即支持秒传、刷新页面后续传，并提供了丰富的来支持上传进度显示，支持多文件与文件目录上传，并可以自定义文件格式过滤。对于现代浏览器，它自动启用的特性，完成快速的断点续传；对于老式的浏览器，它自动切换到上传方式，提供基本的上传功能。
 的功能截图：
 
该组件的使用比较简单，除了传统的标签引入之外，它还支持方式引入，引入方法：
 = =
或者使用引入：
 _=  {
    ___{
           __   最多上传的文件数量
           _  是否支持同时传多个文件
           __  地址，适配
            {__  _ { 图片  }}  文件大小选择与格式过滤
            {
                   {
                    文件添加的回调
                }    {
                     = 
                    文件上传进度回调
                }
                    {
                    文件上传完毕回调
                     {
                        
                         = 
                          = 
                          {
                            提示上传失败
                        }  {
                             = _
                        }
                    }   {
                        提示上传失败
                    }
                }
                   {
                     错误处理
                     提示
                }
            }
        }
}
这就完成了前端组件的引入。然而，断点续传的实现，离不开后台的支持， 组件除了提供前台的完整支持外，在后端还提供了配套的服务：

后台支持续传、重传、秒传；

文件格式识别与处理：图片文件自动转存到并提供尺寸变化缩略图、鉴黄、水印等服务；音视频文件自动转码并转存到，提供多种画质的在线点播服务；文件自动解析并提供在线预览服务等；

下载链接防盗链；

用户存储空间管理，垃圾文件定期自动回收管理等


有关后台架构的介绍，将会在另外一篇文章专门介绍。导语
这个系列其实是写给自己的云计算知识学习笔记——作为一个没有专业背景的小白，从零开始理解云计算的过程。王良明的《云计算通俗讲义》是一本入门的好书，本文根据书中的内容进行了思考提炼，尝试从通俗易懂的角度理解云计算的分类。
上篇文章解释了什么是云计算，这一篇介绍云计算的分类。云计算可以按照层次分为四类：、、、；或者按照所有权分为三类：私有云、联合云和公共云。本文将着重解释前一种分类的由来。
一、环境组成
要理解什么是、、、，要先了解环境的组成。环境组成对技术小白来说听起来比较陌生，为了帮助理解，我们先从简单的如何组装个人计算机说起。组装一台个人计算机大致有下面几个步骤：

一台计算机系统包括 硬件、软件 和 数据资料。软件可分为 平台软件如操作系统、数据库软件和 应用软件如聊天软件、办公软件、上网软件、音视频软件等。计算机的层次结构如图所示：

类似的，企业也需要使用计算机来处理日常事务，随着企业的日益发展，企业中的计算机网络也会越来越复杂。为了了解企业中较为复杂的环境结构，不妨举个例子：当一家企业购买了一栋办公楼，需要计算机工程师把应用环境搭建起来，大致会有下面几个步骤：

根据上面的步骤，我们可以总结出如下图的企业应用环境的逻辑层次结构：

如图所示，一个典型的应用环境从逻辑上分为层，施工时也是严格按照从第层到第层的顺序进行的。九层归并之后分成四层结构：基础设施层、平台软件层、应用软件层和 数据信息层。基础设施层、平台软件层和应用软件层可以进一步归并到的首字母，表示技术，数据信息层就是的首字母，表示信息，这也就是的含义。
应用环境的四层结构是最为普遍并被广泛接受的划分方法，了解了这些，也就自然能够明白什么是、、和了。
二、、、 和 
 
 是     的缩写，意思是 基础设施即服务，即把环境的基础设施层作为服务出租出去：由云端公司把环境的基础设施建设好，然后直接对外出租硬件服务器或虚拟机，云端公司负责管理机房基础设施、计算机网络、磁盘柜、硬件服务器和虚拟机，租户自己安装和管理操作系统、数据库、中间件、应用软件和数据信息。

那么，租户是如何使用这些租来的虚拟机和硬件服务器的呢？
这些设备位于计算机网络的另一端，出租之后并不是把这些设备从云端搬到租户的办公室来使用，而是通过网络使用。租户交了租金，会收到云端公司发送的账号和密码，用以登录云端自助网站，租户可在此管理自己的计算设备：启动和关闭机器、安装操作系统、安装和配置数据库、安装应用软件等。除了启动机器和安装操作系统必须在云端公司提供的自助网站上完成外，其他的操作都可以直接登录到已安装了操作系统并配置好了网卡的硬件服务器或虚拟机中完成。
型计算设备，对租户而言最大的优点是灵活性高，可以自主决定安装什么操作系统、需不需要数据库及安装什么数据库、安装哪些应用软件、要不要中间件等。
但相应的，型计算设备有着管理难度大、计算资源浪费严重的缺陷。因为操作系统、数据库和中间件本身要消耗大量的计算资源、内存和磁盘空间，比如可能出现这样的极端情况：用户租了一个为核，内存为，硬盘空间是的机器，然后他自己安装了 的操作系统、数据库，由于操作系统和数据库已经把、内存和磁盘空间消耗殆尽，他还想安装运行一个绘图软件都做不到，需要升级机器的配置才行。
 
 是     的缩写，意思是 平台即服务，即把环境的平台软件层作为服务出租出去：云端公司要做的事情更多，他们需要准备机房、布好网络、购买设备、安装操作系统、数据库和中间件，把技术设施层和平台软件层都建好，然后在平台软件层上划分小块又称为容器对外出租。相反，租户要做的事情更少了，只需要安装、配置和使用应用软件就可以了。

比如，想要搭建一个个人博客网站，就可以租一个支持语言和数据库的容器，然后采用开源建站工具，只需几步就能完成搭建。
我们知道，平台软件层包括操作系统、数据库、中间件和运行库四部分，但这并不意味着在搭建平台软件层时这四部分软件都要安装，需要哪部分以及安装什么种类的平台软件要根据应用软件来决定。根据平台软件层中安装的软件的种类多少，又分为以下两种类型：
半平台：平台软件层中只安装了操作系统，其他的留给用户自己解决
全平台：安装了应用软件依赖的全部平台软件
相对于，租户的灵活性降低了，他不能自己安装平台软件，只能在有限的范围内选择；而这样的优点在于，租户可以从高深繁琐的技术中解放出来，专注于应用和业务。
 
 是     的缩写，意思是 软件即服务，即把环境的应用软件层作为服务出租出去：云端公司需要搭建整个层基础设施层、平台软件层和应用软件层，对外直接出租应用软件，他们一般会选择使用面广且有利可图的应用软件，如企业资源计划、客户关系管理、商业智能等，并精心安装和运维，租户直接使用即可。

适合做的应用软件一般有如下特点：

 
 是     的缩写，意思是 数据即服务。此时，云端公司成了数据处理公司，他们搭建了全功能的应用环境，一方面收集有用的基础数据，另一方面对这些基础数据做分析，最后销售分析结果或算法的编程接口。云端公司需要从 数据积累、数据分析、数据交付 三个方面积累自身的核心竞争力。

租户需要自己输入日常数据，并做相应的处理，在规定的时间输出结果，需要掌握相应的软件操作技能。而用户在需要的时候只需要直接询问 “ 把资产负债表给我 ”、“ 告诉我现在的准确位置 ” 、“我今天吃什么最好” 等等，就能得到相应的结果反馈。
是大数据时代的特征，在因果关系、相关关系、预测、残缺信息补齐方面有广泛的用途。
三、私有云、联合云 和 公共云
前面按照云端架构的纵向划分，将云计算分为、、和四类，下面我们根据云端的所有权来分类，简单介绍什么是私有云、联合云和公共云。
 私有云
终端用户自己出资建设云端，并拥有全部的所有权和使用权，即为私有云。云端的所在位置没有要求，可以在单位内部，也可以在别人的机房，比如将服务器托管在电信机房。云端的管理页没有严格限制，可以自己维护，也可以外包给他人维护。
私有云可分为 家庭私有云 和 企事业单位私有云：
家庭私有云可以说是最小的云端：用一台配置好些的计算机充当云端，客厅、书房、卧室等地方各放一些终端如手机、平板电脑、电视等。
企业私有云用终端替换办公电脑，程序和数据全部放在云端，并为每个员工创建一个登陆云端的账号，这样相比传统的计算机有如下好处：

 联合云
几个单位联合出资共同建设云端，分享云端使用权，且满足各个单位的终端用户需要，即为联合云。具有业务相关性或隶属关系的单位组建联合云的可能性更大，因为一方面能够降低各自的费用，一方面还能共享信息。
比如，深圳地区的酒店联盟组建酒店联合云，以满足数字化客房建设和酒店结算的需要；再比如一家大型企业牵头，与他的供应商一起组建联合云。但如果由卫生部出资组建云端，然后要求各家医院接入，这样的云端就不是联合云，而是公共云。
 公共云
终端用户只租用云端计算资源而对云端没有所有权，云端公司负责组建和管理云端并对外出租，那么这样的云端对于用户来说就是公共云比如亚马逊的、微软的、腾讯云的、深圳的超算中心等等。公共云的管理比私有云复杂得多，还涉及到租户管理、结算管理、更高要求的安全管理等。
同一台终端可以同时接入多个云，也可以同时接入多个不同类型的云，比如同时接入私有云、公共云等。
这个系列的下一篇将进一步说明云计算相较传统计算的优势：

相关推荐
从零开始理解云计算 ：什么是云计算从零开始理解云计算 ：云计算的优势导语  从事前端有年的时间了，从最开始的美工到重构再到偏向逻辑开发的前端开发，一直在前端这个行业里面摸索和学习，我现在将自己这些年的一个心得体会来个系统性的梳理写成一篇关于性能优化的主题文章，希望对大家有点帮助，也欢迎大家提出各种意见和建议。

前端工程师是一个最近这年才开始慢慢被互联网公司重视起来的一个职业，可以说是一个新兴行业，我用一张简单的思维导图带大家回顾一下前端技术发展的历程以及未来一个展望：

时代没什么说的，、打天下的时代，那个时候你会用开发个计算器就牛逼到不行。时代是最好的时代，新技术、新思想蓬勃发展，堪称前端的工业革命，前端人员的地位得到了充分认可，门槛也有一定的提升。前端性能优化的涉及点从服务器到协议再到宿主环境本身都要有比较深刻的认识，业界目前主要还是以雅虎总结出来条前端性能优化的黄金军规 为参考。今天我想将这些年对前端的性能优化的经验思考整体来个串烧，带大家鸟瞰一下前端性能优化目前的一些通行做法以及这么做的出发点。文章初衷主要是对一些性能优化基础知识回顾和体系梳理，不对具体技术点做深入分析，点到为止，个人理解不对的地方欢迎各位大神拍砖，抛砖引玉。
引入话题前我还是先从一个老生常谈的话题开始：
“从用户输入到页面展示给用户浏览器客户端的过程中发生了什么？”
这里用个图表简单描述一下几个步骤：

优化的目标就是如何让用户更快、更简单易用、更流畅的使用我们的服务，对于前端开发而言就是如何让我们的资源体量更小、数量更精简、内容更早呈现、交互更加人性化。
性能优化有个大家比较公认的二八原则，就是资源从服务器处理完下发到客户端的浏览器上上图第步所占的时间比例大概是整个过程的，也就是说服务器端可以优化的空间的效率提升并不会很明显，前端性能优化成为性能优化重点考虑的领域，我下面将会从以下几个维度去做了自己的一个思考跟条军规有一定重叠和总结：

一、浏览器宿主环境
、突破单线程解析渲染阻塞限制
浏览器是一个单线程解析模式去解析渲染从服务器端拿到的文本，加载的过程中会对后续的脚本资源加载造成阻塞，脚本的加载也会阻塞后续结构的解析造成页面的留白时间增长，雅虎的条军规中有一条就是样式文件放在头部，脚本文件放在节点最末尾，减少阻塞。这里还有几个针对脚本文件的优化：

针对不需要操作主要考虑是需要操作的脚本往往需要获取一些样式信息的脚本可以采用动态创建的方式载入，动态载入的脚本不阻塞后续资源的加载。
脚本文件加载可以加上或者属性标识防止阻塞关于两者区别可以参考

、利用事件冒泡特性
浏览器的事件模型的冒泡的特性浏览器事件模型不清楚的自行搜索了解我觉得是最牛逼的设计之一，解决了浏览器因为解析模型不同步导致开发者往对象注册事件回调找不到对象的问题。
浏览器事件注册有个级别定义， 级事件注册利用元素行内事件属性注册事件回调， 级事件注册利用元素对象的  在外部注册事件回调， 级事件注册利用利用元素对象的  在外部注册事件回调。这里性能优化的建议就是利用级在目标的父标签大部分框架是在标签统一注册事件监听注册回调，收拢事件监听入口同时节约了节点引用开销。
、避开性能
是前端作为前后台登录态校验最通常用的缓存方案，但鉴于浏览器在每次都会往同域的任何资源的请求中自动带上信息的情况，这里有必要进行优化一下，因为像、、这些资源请求是不需要信息的，会无端造成请求带宽的浪费想象一下我们的大小假设为，个请求就是近的大小，高并发下以我们现行网络带宽也是蛮大的一笔负担了。 性能优化方案的处理方式是异域静态资源服务器部署我们的前端、、资源。
以自己目前负责的香港跨境汇款为例

页面路径下的资源的请求：

资源加载的请求：

通过对比分开部署的资源请求并没有带上信息。
、突破浏览器并发连接限制
浏览器针对而非页面做并发连接限制的特性， 的技术优化方案的处理方式是将资源划分域分开部署，但因为过多的域划分会增加多余的开销，这里通行的数量是个以内。目前我们的港菲汇款业务只有两个域名分开部署，一个主站，一个，我个人建议可以将中的图片资源再单独再分一个域名部署会更好些，为什么单独把图片抽出来，后面会讲到。
、利用硬件加速浏览器渲染
针对一些界面渲染过程比较耗时的情况下，可以利用属性开启来加速渲染我们的，开启很简单一般我是用假属性来唤起系统加速渲染功能，关于为什么会这样，我这里做个简单的解释：
对于我们的浏览器而言，拿到我们的文本串开始按顺序解析成树，并与同步解析出来的匹配生成渲染树跟树的节点不是一一对应，比如的节点就不会插入渲染树

图片来源 
浏览器将渲染树的节点用一个图层表示，这样层层叠加在一起生成，有点像的图层叠加的概念可以通过火狐浏览器开发者工具维展示更直观，一般情况下对节点的任何涉及尺寸的改变都会引起的重排重绘重排和重绘是造成浏览器渲染的最大性能损耗的因素，但有种开小灶的情况 复合图层直接交给我们中单独的合成器进程处理，自身变化不会引起其他层的位置变化，不会引起重排重绘。 属性是可以悄悄的告诉我们的浏览器把元素解析作为复合图层交给单独进程去处理的。
注：这里有个原则，不能滥用我们的加速，因为过多开启硬件加速会消耗更多的用户内存空间，也会比较耗电，一般针对动画建议开启
二、维度
、减少请求数量
、通行解决方案

、合并：、都能够很简单的通过任务脚本的方式去自动化解决，目前我们团队是用我们自研的前端构建工具配合我们的库做的发布前的资源打包任务，核心就是用的。
 雪碧图：将网站常用的一些小图片整合到一张大图上来，样式里面通过二维坐标定位找到自己的图片。这里有个原则，一般是将网站复用率较高的，不太容易变动的图标和图片，比如按钮、平铺背景小图片等。
字体图标：字体图标库的使用，是一个非常有创新的方式，因为是矢量的，解决位图像素放大变虚的问题，体验很好，相比同样矢量的来说使用更简单，一个的就可以像平时设置字体一样使用，淘宝是国内这方面的先行者，有自己的一套很开放的矢量图标库平台。淘宝自身的许多小图标都是用的字体图标来展示的。




图片编码传输：图片编码后，可以让浏览器减少自身的一次请求，但因为自身的一些缺陷，不能滥用即使一个很小的图片编码后都会有一大串字符，增加了我们体积，性能不降反升，我的建议是针对那些全站通用或者体积很小不好整合到雪碧图里面的图标进行编码，当然还有很多不同的场景大家自己权衡。

图片延时加载：主要是为了减少首屏一次性图片的加载量。具体做法是给图片或者标签设置一个私有行内属性当然可以自己随便定义存放目标图片地址信息，监听浏览器的滚动事件，标签到了浏览器可视区域就将图片地址放入图片的属性中或者作为标签的样式的背景图片中展示。淘宝首页的做法是用一个来做延时图片加载，通过背景图片来展示最后的图片。


图片展示前：
 
图片展示后：
 
、缓存机制

协议缓存方案：利用缓存协议头做缓存，或者更精确的设置依据资源的修改时间来设置缓存方案。但目前更有效或者极端的做法是利用，设置资源的最大缓存时间假设为年的长缓存，更新采用非覆盖式更新的方式是目前大公司通行的做法。这样每次资源请求的时候都是只从客户端缓存读取， ，而不是还要跑一次请求到服务器端拿到状态。还是以一张淘宝首页图片长缓存的截图为例：



 应用缓存方案：离线应用缓存是提供一个比较有效的离线应用方案，利用 、对象、服务器以前是配置文件保证在脱机下的移动应用照常能用，如果要做数据的离线还要加上做离线数据的保存。这里简单说一下接入离线应用需要的几个步骤：

、给需要做离线缓存的页面标签设定属性，指定缓存的配置文件     可以设定任何扩展名，只要在服务器端配置为就行。
 、创建上一步指定的配置文件，按以下截图说明来配置资源
 
 、在服务器端配置配置文件的扩展名映射的为

离线方案诟病太多，目前接入的不多，有种慢慢变弃儿的趋势，这里提出来让大家权衡

  方案：谷歌提出的一套全新的离线方案，利用配置文件、对象来实现类原生体验的离线应用方案，可以说是浏览器应用缓存的一个脱胎升级方案鉴于文章篇幅，这里不做介绍了。

、减轻数据请求大小
、通行解决方案

 、、图片压缩：这些可以或者自动化脚本里面定义脚本任务来完成。

服务器开启压缩：一般现在服务器都有开启压缩，压缩率通常都是以上，效果还是不错的。


原图：

压缩后：


图片服务器动态响应方案：这个方案对应上面宿主环境维度 单独出来一个独立域名部署图片资源的方案介绍。图片资源是网站请求资源中一个非常大头的开销，以前大家可以在静态资源服务器中建个目录存放就完事，随着网站服务发展，图片不仅面临多样化、高并发带来的压力，在移动端站点中更是要针对不同的分辨率屏幕下图片尺寸动态适配的场景以为了节省带宽的需求。图片服务器的单独架构有一定的复杂度如果考虑到高并发下的容灾、缓存机制的话不亚于一个大型网站集群的搭建，这里有篇文章推荐大家阅读，这里只讨论一下其中负责切图服务部分的服务器简称切图服务器功能，切图服务器对外提供一个的调用，比如图片路径图片名_ 告诉切图服务器将“图片路径”下的图片等比压缩成的图片尺寸并返回，这块服务可以使用我们前端比较熟悉的创建，当然也可以用来提供。

、页面切片预加载方案
性能优化静态资源维度最后一块内容就是针对页面，如何尽早输出页面模块，减少留白时间是一个思考点。应用的方案是个很不错的借鉴思想，还有淘宝也有首页做了相应的切片方案，对页面合理的分块，在服务器和客户端建立某种对应机制，让各个页面块并行的在服务器端拼接完成并吐出来，目前我对这块没有太深的了解，这里只是提出的方案供大家参考。
三、维度
连接中的次握手、慢启动的一些特性注定了连接通道的利用效率成为制约性能的一个很大的因素。因为是基于的应用协议，层维度考虑还得从几个版本的发展历史来看：

时期：连接是基于一种单通道顺序等待请求响应方式客户端每发一个请求都要重新建立连接，特定历史背景下产生的，低效率很难跟上时代发展，年在基础上修订出版本，并沿用至今。
时期：在请求头信息加入 保持连接的一定活性当然也加入了 节约带宽、特性等，允许在一个连接通道生命期内重复发送不同的应用请求，一定程度上减轻了连接资源利用效率问题，但当用户浏览网页时间大于连接活性周期再次请求的时候仍然要重新建立这些请求，在大型科技公司对高并发高可用性下资源高效利用的背景下，版本还是难满足大公司对高性能条件下网络资源的高效率利用的要求。

谷歌叒是谷歌，牛逼率先在年基于开发出全新应用协议，解决了多路复用请求优化、服务器推送的痛点问题，也为后面的推出奠定了基础。我们可以做的优化：减少一些不必要的请求扫除死连接、请求用我们的长缓存机制去优化，尽量减少一些不必要的连接请求数。
四、代码实现
鉴于语言本身的灵活性，以及每个人的开发习惯，很难有很好的一个方式去验证开发者的代码实现的效率目前更多的是用打点测速的方式去监控代码的执行时间，更多的是一种建议，大家有更好的建议可以提出来分享。

单线程限制：利用异步回调多线程突破语言单线程带来的内存开销利用不充分的问题，现有可以利用的一些异步方式的回调都可以尝试利用比如推荐用它多线程的方式有。这里推荐日本的一个开发者开发的一个多线程前端库它是作者用和来模拟的多线程，可以自行网上搜索了解。

重点优化代码中的循环结构体：就代码本身而言影响执行效率的大部分是循环体结构和算法设计不合理导致的时间复杂度和空间复杂度的增加。这里放两段实际项目中的代码截图来对比：


实例功能需要：实现输入框每个字符一个空格隔开的效果
低效实现方式，用循环

改进后的方式
 

合理使用设计模式优化代码结构：设计模式的合理利用不能滥用可以起到内存优化提高执行效率效果，比如单例和简单工厂在创建请求对象中的利用：创建一个简单工厂向外面提供对象，工厂内部用闭包开辟一个数组队列单例用来存放对象，当调用者需要对象时工厂就从队列里取出状态为空闲的对象否则重新创建并放入队列中。在有大量对象请求的应用下可以最大限度节约创建消耗的内存开销，这里用个简图来描述一下思路：



其他一些优化建议：比如减少频繁操作节点的次数这个本来想放在宿主环境维度减少浏览器的重排重绘；比如针对标签对象主要是针对下对象的引用会被回收遗漏的问题、闭包内部的引用类型的变量用完过后记得要及时释放，避免造成内存泄漏。

五、产品交互逻辑
性能优化一般都是从技术角度去入手，但我们的目标之一“让用户简单易用”也是性能优化的一环。当技术性能缺陷难于避免的时候，作为前端交互实现的执行者，更应该配合产品和交互设计师提出一个我们认为更好的交互逻辑体验方案去让我们的数据加载不那么让用户有等待的感知，让我们的提示更加的人性舒服。交互设计师更加专业，我这里不敢班门弄斧
时代的前端展望：
文章最后对时代做个自己的猜想，目前在业内还没有很明确定义，大家可以大胆猜想前端行业未来形态。我在这先一下，人工智能、大数据广泛应用应该会成为推动前端进入的时代的最好契机，以此引发的前端新的革命：

浏览器成为一个系统生态至于哪个浏览器现在不好说，现在谷歌浏览器方案提供给前端类开发方案就有这个趋势，以后都不需要装系统了。前端不再是数据的搬运工，在领域很有可能除了底层维护数据库的工程师们继续深耕外主要切入云计算领域，其它的都可以转到前端做浏览器系统生态哎妈呀，有种翻身农奴做主人的感觉∩_∩。
传统的语义性的超文本标记语言已经很难承载更多的信息化数据，继续深度发展，不再只是浏览器专用的标记语言，可能会成为跨平台标准的信息表示层，信息表示多样化前所未有，可能到时候不叫了。
成为一个广泛试用的标准，并进一步深化，安全校验层做到类似区块链去中心化的思路，做到极致安全估计可以下岗了。
成为跨平台公认的标准实现语言目前前端跨平台基础形态已经有了，随着的广泛推广和深度改进，可能就不会像现在这么灵活，更加像一个合格的标准“高级”脚本语言。
以上猜想纯属个人理解，没有权威认证，大家可以畅所欲言
结语：刚来鹅厂不久，作为前端攻城狮进入到国内顶尖互联网公司感到骄傲，性能优化是一个永恒的话题，每个阶段都有聊不完的性能优化的话题，我将我这些年的一些不成文的理解整理了一下，希望对大家有点帮助。第一次发文章，有错误的地方请大家指点一二。美国雇主评价网站  在  月中旬发布的「美国薪酬最高的  大科技公司」榜单中，许多人并不熟悉的阿卡迈公司位列其中，其员工人均年薪为  万美元，是美国平均薪酬的两倍多。
阿卡迈是美国、也是全球最大的  公司，在过去的  年，总营收达到  亿美元，盈利  亿美元， 家券商分析师中，有  家给出了买入建议， 家建议投资者继续持有，只有一家建议卖出。
专业  厂商依然处于发展的高峰，在中国市场独占鳌头的网宿科技同样增长迅猛。网宿科技在  月发布的最新财报显示， 年全年实现营业收入超过  亿元，净利润超过  亿元，其中海外业务在总盘子中比重超过 。
赢者通吃的行业秘密：三大门槛筑起盈利墙
网民在享受到  技术所带来的流畅上网体验时，很少能够想象这个行业的竞争之残酷。
在全球范围内，阿卡迈和网宿科技，可能是唯二两家在盈利的专业  公司。中国市场位居老二位置的蓝汛通信， 年亏损了  亿元。在美国，阿卡迈之外的  公司无一盈利。
与许多科技公司「一招鲜吃遍天」不同， 是一个拥有较高进入门槛的行业，只有具有一定的规模、技术和运营能力的行业老大才有可能实现大规模盈利。
从规模上看，低于  带宽储备，少于  个有质量的  节点，基本很难实现规模化效应，也很难为大客户提供服务，只能沦为边缘化公司
从技术上看， 本身是以技术为出发点的一项服务，需要根据市场需求不断深化技术能力，否则无法提供良好的服务
从运营上看， 业务是需要提供持续性经营和服务的，需要为客户提供  小时的可靠服务，如果没有一个良好的团队和运营平台用四五年的运营经验去运营的话，很难实现良性运转。
高耸的规模、技术、运营门槛，使得业务高度集中在头部公司，进而形成了「老二以下无意义」的赢者通吃市场。
网宿科技营销中心总经理孙靖泽在今年  月举办的亚太  峰会上表示，自  年以来持续的价格战，已经让大部分从业公司在亏损经营，通过负毛利的方式争抢客户。同时，也推动  市场趋于成熟，在市场参与方充分竞争下，我们预计今年乃至明年，自建量会逐步流出，外包会成为更加主流之选，因而第三方  的市场蛋糕反而会扩大。
云计算、物联网、： 下半场的边缘计算新变革
今天， 正在进行二次变革：从以传输服务为主转变为倚重边缘计算。
特别是在云计算风起云涌的当下， 本身就是天生的分布式云平台，其节点经过改造后也可升级为具备存储、计算、传输、安全功能云计算节点，形成处理高频、高交互的海量数据的能力。
 竞争无疑会更激烈，但好在市场的蛋糕还在越做越大。随着物联网、 的商业化普及、视频时代的到来，市场对  需求将呈现几何式增长。
   数据显示全球  年至  年间的  市场复合年增长率为 ，达到  亿美元，预计全球 市场规模  年会达到  亿美元，年复合增长率达 。国内  市场快速发展，年复合增长率几乎达到国际  市场的  倍。
在接下来的一波的市场增长中，视频和直播将成为一股重要的推动力量。
今年  月底，通过与亚马逊集团  合作，美国  首次实现了来自太空的  超高清分辨率 直播，视频流通过  编码软件在国际空间站进行编码，然后传输到地球表面的约翰逊航天中心 ，进而实现了这一次超高清的视频对话。这一太空直播预示着未来  将成为视频行业最新风向标。
据思科公司的研究预测，到  年，每个用户可消费  的月流量，比  年的  提升了 。视频是助力流量大爆发的重要因素，思科预测  视频将占  年全网流量的 ，较  年增长 。
这可能有助于提升网宿科技未来的市场地位。目前，全国有近八成的直播网站使用了网宿科技提供的加速服务。民生证券在今年  月发布的一份报告称，视频直播已逐步成为一种流行的互联网应用，前景广阔。针对流媒体直播业务，网宿科技抢占了先机边缘计算等新技术已经应用到直播解决方案中。
以时下最火热的弹幕为例，弹幕分发已经成为直播平台很大的一个关注点，某种程度上弹幕呈现的好坏，直接决定了直播平台的转化率。网宿基于边缘计算的方式，成功研发出边缘弹幕分发技术，所有的弹幕在网宿平台上直接进行分发，不用再回源，解救了直播平台弹幕压力大的一大痛点。
当前高清视频、\、大数据、物联网、人工智能的普及，传输需求剧增，仅仅通过集中式大型云计算中心，很难承担所有数据的存储、计算及交互，将给网络带宽带来极大压力，这要求  必须从传统的以缓存业务为中心的  密集型系统演化为边缘计算系统，构架内容计算网络，以解决未来物联网带来的连接挑战，在这一过程中， 行业也必将完成二次迭代。
：作者介绍：王鹤，腾讯前端高级工程师，参与过情侣、星影联盟、个性化装扮等项目的研发工作。秉承「不想当产品经理的程序员，不是好的设计师」。除敲敲代码外，对产品、设计、摄影也有一定的兴趣。 

一、前言
框架是目前比较火的框架之一，简单易上手的学习曲线，友好的官方文档，配套的构建工具，让在大放异彩，大有赶超之势。前不久 正式版已出，在体积优化相比减少了、性能提升相比提升、优化等各方面都更上一层楼。
本文是系列文章，主要想通过对于 源码的分析，从代码层面解析的实现原理，帮助读者能够更深入地理解整个框架的思想。此篇文章主要介绍前端渲染部分。
不足之处还请批评指正，欢迎一起交流学习。
二、的初始化
我们在使用的时候，最基本的一个使用，就是在引入的库文件，并写如下一段代码：
  =  {
   
   {
      
  }
}
 ，本质就是生成一个的对象，我们来了解一下这个生成对象的过程是怎样的：
首先，的入口是，这是由配置文件决定的。

这个入口文件中了很多文件，其中有一条主要的脉络：
引用了引用了引用了
其中是最核心的初始化代码，其中：

红框部分，就是整个的类的核心方法。其含义给读者解读一下：
初始化的入口，各种初始化工作
 
数据绑定的核心方法，包括常用的方法

事件的核心方法，包括常用的，，方法

生命周期的核心方法

渲染的核心方法，用来生成函数以及

其中 就是执行下面的这个函数：

_方法就是中的_方法。

至此，程序沿着这个_方法继续走下去。
三、的渲染逻辑——函数
在定义完成对象的初始化工作之后，本文主要是讲渲染部分，那么我们接上面的逻辑，看是如何渲染页面的。在上图中我们看到有一个的方法：

在该方法中会执行红框部分的内容：

而方法就是整个渲染过程的起始点。具体定义是在中，根据代码整理成流程图：

由此图可以看到，在渲染过程中，提供了三种渲染模式，自定义函数、、均可以渲染页面，也就是对应我们使用时，三种写法：
 自定义函数
 {
       {
         
                    标签名称
              子组件中的阵列
        
    }
     {
         {
             
             
        }
    }
}
写法
  =  {
     {
         以一个空值声明 ``
         
    }
     {{}}
}
写法这个就是入门时最基本的写法
  =  {
     
     {
          
    }
}
这三种渲染模式最终都是要得到函数。只不过用户自定义的函数省去了程序分析的过程，等同于处理过的函数，而普通的或者只是字符串，需要解析成，再将转化为函数。
记住一点，无论哪种方法，都要得到函数。
我们在使用过程中具体要使用哪种调用方式，要根据具体的需求来。

如果是比较简单的逻辑，使用和比较好，因为这两种都属于声明式渲染，对用户理解比较容易，但灵活性比较差，因为最终生成的函数是由程序通过解析优化得到的；

而使用自定义函数相当于人已经将逻辑翻译给程序，能够胜任复杂的逻辑，灵活性高，但对于用户的理解相对差点。


四、的渲染逻辑——对象方法
根据上面的结论，我们无论怎么渲染，最终会得到函数，而函数的作用是什么呢？我们看到在中有这么一段代码：
_ =    = {
    __ 
} 
意思就是，通过的绑定，每当数据发生变化时，执行_的方法，此时会先执行_，在这个_中，我们的函数会执行，而得到对象。

对象是什么？就是 中的 ，在 中，相较 引入了 的概念，这也是 性能提升的一大关键。 有多种实现方式，但基本思路都是一样的，分为两步：
 模拟模型树
在 中模拟模型树就是，函数执行后都会返回对象，为下一步操作做准备。在中，我们可以看到的具体数据结构：

的数据结构中还有、、，这些数据结构都是对节点的一些描述，本文不一一介绍。读者可以根据源码来理解这些数据结构。：使用了，标识了参数的静态类型，对理解代码很有帮助_
 模型树通过 算法查找差异，将差异转为真正节点
我们知道函数执行生成了，而只是 ，我们还需要通过 之后，来生成真正的节点。在 中，是通过中的  方法来完成的。
该方法有三个参数表示旧，表示新，表示是否直接使用服务端渲染的元素，这个本文不作讨论，在服务端渲染篇再详细介绍。
其主要逻辑为当为真实元素或旧的和新的完全相同时，直接调用方法生成真实的树，当新旧存在差异时，则调用方法，通过比较新旧节点，根据不同的状态对做合理的添加、删除、修改这里的算法有兴趣的读者可以自行阅读方法，鉴于篇幅不再赘述，再调用生成真实的树。
五、的渲染小结
回过头来看，这里的渲染逻辑并不是特别复杂，核心关键的几步流程还是非常清晰的：

 ，执行初始化
挂载方法，通过自定义方法、、等生成函数
通过监听数据的变化
当数据发生变化时，函数执行生成对象
通过方法，对比新旧对象，通过 算法，添加、修改、删除真正的元素

至此，整个 的渲染过程完毕。

文章来源公众号 小时光茶社 


相关推荐
前端开发框架简介和
腾讯工程师的前端书单前言
大部分网页可以直接请求爬取，但是如果页面是渲染的该怎么办呢？如果我们单纯去分析一个个后台的请求，手动去摸索渲染的到的一些结果，那简直没天理了。所以，我们需要有一些好用的工具来帮助我们像浏览器一样渲染处理的页面。
其中有一个比较常用的工具，那就是。
是一个无界面的可脚本编程的浏览器引擎。它原生支持多种 标准： 操作，选择器，， 以及。
另外还有一个与配合使用的类库叫做，二者配合可以完成复杂渲染页面的爬取。
下面我们来讲解下二者的安装过程。
安装

安装方法有两种，一种是下载源码之后自己来编译，另一种是直接下载编译好的二进制文件。然而自己编译需要的时间太长，而且需要挺多的磁盘空间。官方推荐直接下载二进制文件然后安装。
大家可以依照自己的开发平台选择不同的包进行下载
下载地址
当然如果你不嫌麻烦，可以选择
下载源码
然后自己编译。
下载解压之后将所在路径加到环境变量。
安装完成之后输入命令：
 
如果正常显示版本号，那么证明安装成功了。如果提示错误，那么请重新安装。
安装
 是什么？一句话，自动化测试工具。它支持各种浏览器，包括 ，， 等主流界面式浏览器，如果你在这些浏览器里面安装一个  的插件，那么便可以方便地实现界面的测试。换句话说叫  支持这些浏览器驱动。话说回来，不也是一个浏览器吗，那么  支持不？答案是肯定的，这样二者便可以实现无缝对接了。
然后又有什么好消息呢？支持多种语言开发，比如 ，，等等，有  吗？那是必须的！哦这可真是天大的好消息啊。
嗯，所以呢？安装一下  的  库，再安装好 ，不就可以实现 ＋＋ 的无缝对接了嘛！ 用来渲染解析， 用来驱动以及与  的对接， 进行后期的处理，完美的三剑客！
有人问，为什么不直接用浏览器而用一个没界面的  呢？答案是：效率高！
 ，又名 ，它的主要新功能是集成了   以及  曾经是  的竞争对手。也就是说   是  和  两个项目的合并，即   兼容 ，它既支持   也支持  。
安装比较简单，如果有了，可以直接用安装。
  
如果是，则可以使用。
  
下载源码安装也可以，源码地址
解压之后直接运行如下命令即可：
  
如此以来就完成了的安装。
后记
以上我们完成了和的安装，如果要学习更多内容，可以参考官方文档。



相关推荐
【腾讯云的种玩法】云服务器搭建爬虫环境
操作  云爬虫初探
注册即可领取代金券，实名认证后优惠再升级导语
年“云未来”峰会即将在深圳盛大举行，本次峰会 技术专场将在月日下午举行。  专场给各家提供了针对  应用以及背后填坑之路作深度探讨的机会。现在让我们一起回顾下去年各位嘉宾在在现场分享了哪些云上的心得体会以及 云原生架构上的亲身实践。
本文是微影时代技术中心副总裁杨森淼在年腾讯“云未来”峰会 专场有关《微票儿的   实践之路》分享的回顾。
杨森淼：《微票儿的   实践之路》
微影时代技术中心副总裁杨森淼在年腾讯“云未来”峰会 专场，分享了国内首个领域的 实践分享。微票儿是今年备受关注的互联网购票平台：估值近百亿、年增长率超、覆盖全国个城市多家影院，日出票达万张，峰值万张。而在其业务迅猛增长的背后，一个高速、敏捷、弹性、灵活的技术架构必不可少。

微票儿的 实践，采用的是微服务的方式，以实现从研发测试到部署运维的全系列。其技术部分构建在传统的、、三个层面。在实践的过程中其优点非常明显：业务逻辑简单、耦合小、独立部署、方便隔离、使用不同的技术栈……但是另一方面，该系统也存在调用开销增加、服务依赖复杂、难以保证数据的一致性、运维成本增加等问题。

为了解决这些问题，微票儿在做微服务的时候针对组织结构进行了变革，年研发管理就是前端、平台、运维，到了年变成了打散的方式。

微服务对运维的成本成倍的增加，微票儿通过敏捷的基础设施，为微服务提供弹性，按需计算、储存和网络资源能力，所以又有了三个相应的微服务需要执行的点：
第一个是有支撑微服务的平台，我们选择的是；
第二个是有符合微服务平台的规范；
第三是有微服务的核心技术点，需要配置、代码分离、服务注册和发现，路由和容错，还有的边缘服务，这又增加了很大一部分的工作量。


以上是微票儿整个微服务的平台，将开发、发布、运行这三个阶段严格地做了一个拆分，在不同的环境使用不同的相应的服务。

关于微服务平台规范的要符合  因子的规范，杨森淼对此举了几个例说明。首先，对不同的环境参数的配置是通过环境变量进行注入的，代码和配置分离，代码中不允许出现在生产环境的配置信息中，部署相关的  的时候是公开的，配置中的隐私是不能公开的，部署的过程中经过代码和配置的合并。本身这样又会造成  也变成了代码，它也需要一定的测试和维护。
其次，日志作为统一的事件流，统一处理服务和进行收集、聚合、搜集、分析，每个程序的开发都要看到数据，他们每天要看所有的数据是否打算，自己的请求耗时大概是多少，自己的请求返回时间是多少，它吃的带宽是多少，都可以通过自己的数据和日志查找到相应的自己服务的相关报表，整个后面还有一系列的报警。

微服务的技术特点 ，是版本控制的分布式配置中心，服务注册和发现，尽早发现问题，尽早解决，成本越小。持续集成保证代码始终处于可用的状态。

微票儿借助于微服务和，实现从研发到运营的全系列流程，支撑高速增长过程中的敏捷的产品迭代 ，从而提高整个系统的可维护性和稳定性。

微服务还有很重要的核心技术点就是监控，微票儿有业务单元的监控，红包是否存在异常，是否有黄牛每天不断地在领红包，订单的状态是否一致，是否微信支付会有延长，是否微信支付的回调会有异常。然后还有接口级别的监控，每个接口的成功、错误率，调用的时间。通过业务、接口、基础监控和日志处理分析来监测服务是否异常。

微票儿通过使用，其运维团队可以在某一天随机干掉某几个微服务，还不影响到其它服务。好处就是微服务给我们造成了这样好的环境，能提高你的断路和降级。不再担心它是一条链，没办法隔离。因此提高了断路和降级。

以上所有的 实践，都是通过腾讯云来实现的。有人会说，你本身的虚机再铺一层会不会把资源浪费，可能会浪费，但是通过你整体的服务来讲，杨森淼认为资源是在下降的，服用是在下降的，而且这里可以看到我们所有的资源开销的占比，看起来最贵的还是带宽，但是这一块就是因为我要有很多的调度系统去实现我的微服务调度和使用资源的调度，都会使用带宽，这一块的成本会增加，但是储存成本和主机成本都在下降。作者介绍： 王甲坤 腾讯云工程师

数据加密是数据库被破解、物理介质被盗、备份被窃取的最后一道防线，数据加密，一方面解决数据被窃取安全问题，另一方面有关法律要求强制加密数据。  的数据加密相较于其他数据库，功能相对完善，加密方法较多。通常来讲，数据加密分为对称加密和非对称加密。对称加密：加密与解密使用同一密钥，密钥需要传输，安全性较弱，但性能较非对称要好。非对称加密：加密与解密使用不同密钥公钥和私钥，较对称密钥安全性较好，但是算法较复杂，带来性能上的损失。因此，折中的方法是使用对称密钥加密数据，使用非对称密钥加密对称密钥。这样既保证高性能，又提高密钥的可靠性。
同样，  就使用了折中的方法，所以  加密功能包含个部分：数据加密和密钥管理
一数据加密
说道数据加密，我们不得不说下加密算法， 支持多种加密算法：

二密钥管理
 加密层次结构

由图可以看出，加密是分层级的。每一个数据库实例都拥有一个服务主密钥  这个密钥是实例的根密钥，在实例安装的时候自动生成其本身由提供的数据保护进行保护  ，服务主密钥除了为其子节点提供加密服务之外，还用于加密一些实例级别的信息，比如实例的登录名密码或者链接服务器的信息。
在服务主密钥之下的是数据库主密钥  ，这个密钥由服务主密钥进行加密。这是一个数据库级别的密钥，可以用于为创建数据库级别的证书或非对称密钥提供加密，每一个数据库只能有一个数据库主密钥。
模块，这个比较特别，全称可扩展密钥管理模块，该功能增强密钥管理的能力，允许将密钥存储到数据库之外，包括一些硬件，如智能卡、设备或硬件安全模块；并且允许使用第三方产品来管理密钥和进行加密；另外，有条件的可以使用更高性能的模块来加解密，减少加解密上性能的损失。
 加密方式
对象定义加密
未保证触发器、存储过程、视图等定义信息，我们可以在定义对象的时候添加 字段来加密对象。
列数据加密
通过函数加密表中的某一列数据。可以通过密码、对称密钥、非对称密钥、证书等中方式加密。其中，还包括 带有验证器的加密函数，验证器用来解决密文替换问题，验证器一般选用不更改独一无二的，这样就算密文替换，验证器不对，一样失败。
连接加密
通过证书的方式对连接加密，一般用于镜像，主从机器之前的连接就是通过这种方式。
透明数据加密
透明数据加密，顾名思义，是在用户不感知的情况下完成加解密操作。
它的加密是在页级别进行，是在写入磁盘前加密，读入内存时解密，针对数据和日志文件，做到实时加密，并且备份文件也会一同加密。
密钥存在数据库引导记录中，收到证书或者非对称密钥的保护，也可以与模块一同使用。官方说法，额外占用的资源。
也有一些缺点：
压缩率小，由于它是先加密再压缩的，所以无法显著压缩备份。
备份同样是加密的，所有恢复的时候要小心，注意备份证书和密钥，才能在另个实例中还原数据库，性能有一定损耗。
备份加密 
支持备份的过程中进行加密，并且支持先压缩在加密，保持高压缩比，打破了使用透明数据加密后几乎没有压缩率的窘境。
因此，使用原生备份加密无论在将数据备份到异地数据中心，还是将数据备份到云端，都能够以非常低的成本对数据提供额外的安全保障。
全程加密
全程加密，数据永远是加密状态，你可以在加密数据上执行操作，无需先对它们解密，也就是说加密的敏感信息不会有机会变为明文。
全程加密针对列做处理，在创建列主密钥，列加密密钥后，可以在创建表的时候设置列加密。
加密模式分为两种：确定型加密与随机型加密。
确定型加密能够确保对某个值加密后的结果是始终相同的，这就允许使用者对该数据列进行等值比较、连接及分组操作。确定型加密的缺点在于有可能揣测出原文，而随机型加密能够保证某个给定值在任意两次加密后的结果总是不同的，从而杜绝了猜出原值的可能性。官方建议需要搜索和分组的列使用确定性加密，而注释和其他敏感不会进行搜索分组的信息使用随机性加密。
最后附上开通示例


参考链接：加密：=可扩展密钥管理模块 ：=透明数据加密：=

更多数据库文章，请关注腾讯云数据库公众号 

相关推荐  简单性能测试与分析  加密特性及使用方法《梦幻诛仙手游》是由祖龙天津科技有限公司研发的一款角色、场景的回合制手游，该作由腾讯游戏运营，自年月正式公测以来，凭借着良好的游戏性和稳定性，成功延续了网游的火爆人气，在今年年初斩获风云榜十大最受欢迎手游奖，也成为了国内端游移植手游的成功范例之一。 

据悉，在《梦幻诛仙手游》正式上线前，就与腾讯手游安全测试团队合作，对自身游戏的安全性进行了系统检测，在技术上保证了手游上线后的良好游戏体验，最大程度完成了原有粉丝的转化积累。腾讯从年初就开始对手游安全测试进行探索和技术积累，该测试已经逐渐成为腾讯在研和运营手游项目上线前的必经环节。目前，腾讯手游安全测试服务已经通过腾讯云全面开放，服务广大的游戏项目。
腾讯云上的到底是怎样保障游戏的安全质量？我们向腾讯团队成员进行了详细访谈，希望从火热游戏《梦幻诛仙手游》的案例中，挖掘出更多内容。
一问：测试服务是如何针对手游进行测试的？答：手游安全测试团队基于对腾讯游戏多年的测试经验，归纳出手游安全漏洞主要出现在客户端、游戏逻辑和服务器三个层面，因此测试服务会从三个层面出发，根据不同手游玩法制定对应的策略以达到整体与侧重兼顾的检测效果。
其中，客户端层面的检查项主要有游戏数据加密、游戏协议保护、变速判定、敏感日志四类监测内容；游戏逻辑安全层面的检查则包含了系统架构、盗刷漏洞和外挂漏洞三类直接关乎游戏平衡和盈利根本的内容；服务器安全层面则对服务器宕机漏洞进行专项检测，为游戏树立阻挡恶意攻击的高墙。
二问：手游安全测试团队对《梦幻诛仙手游》进行了哪些重点测试？答：考虑到不同手游玩法检测需要使用不同的技术实现，因此在《梦幻诛仙手游》安全测试之初，团队对游戏进行了详细的分析与拆解，并制定了有针对性的测试策略。
由于《梦幻诛仙手游》核心玩法包括回合制的与多人，战斗实时性要求很弱，客户端的每次操作均有协议上报，属于服务器强校验游戏。因此，手游测试团队确定了协议安全的测试方法为主，函数修改与内存修改测试方法为辅的策略。
以《梦幻诛仙手游》某个版本为例，手游测试团队根据迭代新增内容，聚焦了以下测试重点：、经济系统：商会、商城、摆摊、交易行、背包出售。、战斗力相关：角色属性，技能、装备、法宝、羽翼、宠物、仙侣等。、进行、负值，数据溢出攻击，并发等漏洞挖掘方式。
三问：在《梦幻诛仙手游》的安全测试中，手游团队遇到的最大难题是什么？答：在团队服务《梦幻诛仙手游》的过程里，如何在短时间内全面地完成全量内容的安全漏洞挖掘是当时面临的最大挑战。
由于《梦幻诛仙手游》属于重度游戏，游戏功能系统包含战力成长相关系统、交易系统、宠物系统、门派、上古战场、世界、跨服战、家园系统，各种类型副本以及运营活动等超过个功能系统，短时间完成全量检测难度极大。
而手游安全测试团队采取的是全量自动化分析检测结合风险性优先级评估深度分析的方式解决这一难题：一方面利用智能自动化检测锁定系统、盗刷、拒绝服务攻击等漏洞，另一方面则对高风险高优先级的功能系统如战斗系统、成长系统、交易系统等采取专项分析和漏洞挖掘，同时完成了对游戏核心功能深度检测和整体系统的全方位检测。
四问：测试团队最终发现了《梦幻诛仙手游》哪些严重？在根据测试前分析确定测试重点后，我们利用安全测试工具对《梦幻诛仙手游》的风险项目进行了逐一验证，发现了两类致命级漏洞，而这两类漏洞均在测试阶段发现，并在版本发布前已全部修复，在此仅作为案例分享。
致命安全风险一：角色属性系统
检测结果显示，《梦幻诛仙手游》角色属性加点对各个正常逻辑字段均有校验，唯独对加点数值未做负值判断和溢出处理，导致可以通过发送负值获得超大正值结果，从而获取更多点数分配到主要属性，严重破坏游戏玩法。降低其他成长属性从而增强主要成长属性物攻职业削减法术属性以增强其他战斗属性
致命安全风险二：宠物系统前期测试中，《梦幻诛仙手游》的宠物系统也出现了与一同样的问题——对加点数值未做负值判断和溢出处理，导致修改次要属性为负值可以获取更多点数分配到主要属性。
宠物加点协议发送一键异常值后导致宠物战力猛增，宠物直接战斗无敌。通过录制宠物加点协议，然后修改字段的值为 ，导致宠物战力值异常增大，严重影响游戏平衡。 通过修改数值导致宠物战斗力异常增大
五问：手游安全测试如何处理这些漏洞？答：对于盗刷类漏洞，我们建议游戏开发团队在研发初期要规范游戏通信协议定义，对协议结构中字段数和字段类型进行安全性检查。在面对服务器，理购买、结算等物品发放请求时，需要加强对请求中各项信息合法性校验，另外运营侧可以接入运营经分系统，对各种道具和金钱的产出进行实时监控与告警。
而对于宕机类漏洞修复起来比较简单，在因程序健壮性导致的服务器宕机漏洞被检测出之后，针对性做好异常值处理就能够修复。
六问：《梦幻诛仙手游》进行安全测试的最终结果是怎样的？答：在《梦幻诛仙手游》项目测试阶段，手游安全测试团队累计挖掘出了个致命级漏洞，个高危级漏洞，个中危级漏洞，将游戏中潜在的盗号、物品盗刷、伪造身份、服务器宕机等各类致命级、高危级漏洞提前揭露出来，提前制定修复方案进行修复，并评估和验收结果与风险，为《梦幻诛仙手游》上线半年来稳定运行提供了坚实的技术保障。
关于腾讯云手游安全测试腾讯云手游安全测试 ，是由腾讯游戏团队开放的独家手游安全漏洞挖掘技术，能够有效杜绝游戏外挂损失。产品为企业提供私密安全测试服务，通过主动挖掘游戏业务安全漏洞诸如钻石盗刷、服务器宕机、无敌秒杀等多种漏洞，提前暴露游戏潜在安全风险，提供解决方案及时修复，最大程度降低事后外挂危害与外挂打击成本。
腾讯云上的测试服务目前包括手游安全测试、手游兼容性测试、专家兼容性测试和远程调试服务。其中，手游安全测试服务已为部落冲突、保卫萝卜、皇室战争、王者荣耀、梦幻诛仙等著名手游提供了可靠保障。最近一段时间，我在 以下简称中查看网站数据时，发现一个非常可疑的信息：

这什么鬼？
“”这一项一般是 “” “” “” “” “”等，它是由用户浏览器设定的。但用户浏览器不可能把语言项设置为这些：

ɢ              
       
   ☆｡゜ﾟ･ヽᴗﾉ･゜ﾟ｡☆ ¯_ツ¯ಠ益ಠಥ‿ಥʘ‿ʘლಠಠლ ͡° ͜ʖ ͡°ヽﾟДﾟﾉʕ•̫͡•ʔᶘ ᵒᴥᵒᶅ= =
     

分析请求
很明显，这是一种新的 垃圾信息，希望吸引目标人群可能就是我们这样的网络管理员的注意力。
仔细地观察这些请求，会发现几个特点：

请求数有明显的波峰，在几天内会达到高峰，然后又降下去
  的比例非常高，达到了以上


分析其它受攻击的栏目
仔细查看  统计项目的这些请求，发现  一栏也比较可疑地出现了这些：







ĸ


这其中有一些非常正规的域名。比如是的母公司的官网，也是一个开发者媒体。
这些网站本身没有问题，但其实该网站上并没有任何一个链接指向我的博客，更谈不上我的访客“来自”该网站了。当我访问回去，发现并没有实际上的链接，只是广告，倒也罢了，更可怕的是可能会有钓鱼、病毒等。
综上，这是一波二维攻击假的语言项和假的  项，目的是吸引你的注意力。
分析攻击怎么产生的
总的来说，这种垃圾信息有两种攻击方式。一种是真正会访问你的网站的网络爬虫；另一种是不访问你的网站，而是将假冒的“点击”事件直接发送到服务器。事实上，第二种攻击方式由于成本低，因而更加常见。
 的统计逻辑是，当用户访问你的网站，会在前端运行一段   代码，然后把用户的一些访问情况通过  请求发送给  服务器，告诉  发生了一次“访问”。而这个  请求可以很容易地被伪造，所以垃圾信息发送者无需真的访问你的站点，它直接发送大量  请求即可达到目的。
除了  请求， 还支持更方便的  ，开发者可以发送一个原始数据 给，来一次性传输大量用户行为。这个协议的初衷是让开发者可以统计所有环境下的用户行为，比如开发者可以将离线状态下的用户行为记录下来，当在线时一次性发送。或者当内网不支持外部访问时，先记录下用户行为，随后再定时一次性发送到 。
初衷是好的，不幸的是，这个过程仍然是无需认证身份，所以更方便了垃圾信息发送者。垃圾信息发送者可以通过一次请求即发送大量假数据，他只需要得到你的 即可。
在这个原始数据包中，一切皆可伪造。？没问题！？全改了！ ？当然也可以改……
如何避免
对网站主来说，这种垃圾信息有几点危害：、浪费时间，就像传统垃圾邮件一样。、干扰  状态栏，特别是如果网站流量不是很大比如我。、传播病毒。
所以，有没有完美的解决方法呢？实际上，没有。
要知道，数据一旦录入到 ，就没有办法删掉了。能做的只有两件事，一是阻止垃圾信息进一步加入到 ，二是在视图中过滤掉已经添加进来的垃圾信息，眼不见为净。
第一步：使用过滤器阻止未来的垃圾信息
在语言项中，一般字符数是个，很少有超过个的，所以我们可以认为语言项超过个字符的就一定是垃圾信息。
此外，有一些字符是不可能出现在合法的语言项中，但垃圾信息会利用这些字符来组成，比如： “  ” “” “”，所以我们也一并排除空格、点号、逗号、惊叹号。
{}|\\\|\||\|\
在中选择，然后新增一个如图所示的过滤器即可。

设置好了之后，可以验证一下是否会拦截掉我们想拦截的内容：

没有问题，未来的语言项垃圾信息会直接被拦截掉。
第二步：通过净化已有数据
过滤器从你开始设置时生效，而历史信息无法修改。不过  提供了   功能，在生成报告时，选择性过滤掉一些数据。
 就是数据片段，指的是在完整的数据中取出我们需要的片段进行分析。比如我们可以单独取出岁以下的用户的行为，对比岁以上的用户行为有何不同。而这个功能正好可以让我们把“语言”不规范的数据过滤掉。
如下图，在 的旁边有一个    的按钮，点击之后就可以配置我们的 。 
一定要注意是选择“   ”，里面填上之前的正则。

创建好了新的  之后，就会看到过滤之后的全新报告。

下次再进入时，又会默认进入到   视图，这时可以在   里的  里找到我们的自定义 ，勾选即可。
如果经常需要查看这个 ，推荐点击  来新增快捷方式。

它会保存当前的  和排序等，下一次可以直接从  项目进入到这个快捷目录。
以上就是完整的过滤方法了，这样应该可以过滤掉大部分语言的攻击。提供的  和  的功能很强大，如果后续发现有新的垃圾信息，可以继续通过今天学习的方法来更新完善我们的过滤器。

参考资料：
   –      
       作者介绍：年大学实习期加入初创期的网易，成为第号员工，年间从程序员开始，历任项目经理、产品总监。年后创业年，开发过视频直播社区，及多款页游产品。年后就职于腾讯游戏研发部公共技术中心架构规划组，专注于通用游戏技术底层的研发。

在中国的互联网诸多业务领域中，游戏一直是充当“现金牛”而存在的。但是，在游戏服务器端开发领域中的很多重要问题，并没有被明确的分辨出其特异性，从而得到专门的对待。我们不管是在业界开源领域，还是内部分享中，很少会有专门针对游戏业务特征进行专门设计的组件、类库或者框架。我们从游戏的客户端方面来看，一款专业的游戏客户端引擎，已经是游戏开发的标配，比如最早的 ，到后期的，，；但是服务器端，我们几乎找不到同样重量级的产品。
在游戏服务器端开发所有要面对的问题中，有两个是最核心和最普遍的：一是和客户端的通讯；二是游戏登录用户的数据处理。对于和客户端通讯的这个问题，大量的游戏开发者会使用“通用”的开源组件，比如 ，，，等等通信或框架。虽然针对游戏，还是要做大量的改造，但一般都有很多现成的代码可供修改。但是对于第二个问题，不管是还是，或者是，都不能完全满足游戏开发者的需求。很多团队尝试过各种组合和修改，试图创造出利用现有开源软件，建设既能迎合灵活的需求变化，又具备高延迟和高可用的数据处理系统，但最后这些努力基本上都很难圆满成功。因此我们在游戏服务器端代码中，还是充斥着大量的内存、缓存管理，数据同步、落地等等代码。而且每个游戏都要重新去写一遍这些类似的功能，不能不说一种浪费。
如果我们要想出一种能满足“游戏”这个业务领域的数据系统设计，那么就一定要搞清楚为什么在如此之多的开源项目和游戏团队中，没能实现完美契合的原因。
电子商务一般互联网类业务的数据处理流程
、、在一般互联网业务中的应用非常广泛。而且基本上能很好的应对各种常见的应用场景，包括类似的社区、新闻门户、电子商务类系统。在企业内部信息系统中，这一类数据软件也能发挥非常好的功效。由于电子商务类是其中最复杂的系统，所以我在这里以此为例说明，一般数据处理的流程是如何的。
 
假设我们浏览了一个网店，选中了一个商品，点击了下单这个流程，实际上需要的后台流程可能是下图所示：

从上面的分析大概可以总结出几个特点：

忍受延迟：每个操作的延迟要求较低，操作频率不会太高。一般我们页面在秒内打开，都不会引起太多客户的抗议。所以，就算我们处理一个请求的时候，后台进行多次的进程间调用，产生的延迟和带宽消耗也是可以忍受的。

在线交互少：互联网业务大多数是基于浏览器的，所以在线用户之间很少实时交互。

数据分散：一般来说，互联网应用的数据可以在多个不同的业务系统中共用，但是需要专门的业务模块来做管理，以维持数据的一致性。

数据变更面广：系统需要持续处理很多数据变更，互联网业务有很大一部分数据是来源于普通用户、网络编辑、店主等等使用者，在使用的过程中，他们会大量的修改系统所存储的数据。


以上四个特点，导致了我们一般会把后台要处理的数据，分别用系统和系统来处理。并且，我们一般会按业务功能划分模块，同时也划分业务系统。由于延迟和在线交互的需求较弱，所以使用大量进程来做模块隔离，依然是非常可行的，总体来说，就是一种比较“分散”的数据使用方式。
游戏类业务的数据处理流程
在各种游戏中，是数据处理最为复杂的一类，也是最典型的一种“重服务器端”的游戏类型，因此可以作为游戏业务中通用性的参考标准。在中，我们可以发现，数据的处理需求，和一般互联网业务大相径庭，它体现出的是一种明显的“集中”式的数据处理需求。我们可以从一般的服务器架构中体现出来：

在游戏业务中，一般我们都会发现以下的特点：

延迟敏感：游戏中用户会产生大量操作，都要求“实时”进行反馈，所以一般都不能忍受秒以上的延迟，在大量动作类型的游戏中，一般都会要求服务器的反馈时延在左右。因此游戏开发者都习惯于尽量减少后台进程间的交互，尽管这对提高系统吞吐量很不利。所以大部分游戏服务器端都有一个所谓“”，里面运行了游戏以上的功能。

大量实时交互：在线游戏的特点，就是很多玩家可以通过服务器“看见”彼此，能实时的互动。因此我们必须要把用户的在线数据，集中到一起，才能提供互相操作的可能；而且用户操作用户的数据，是最常见的数据操作，所谓战斗玩法，就是互相修改对方的数据的过程。

数据集中：游戏是一个几乎完全虚拟的世界，在游戏中的数据，实际上很少能在其他系统中产生价值。而游戏逻辑也禁止通过游戏以外的方式，修改游戏的数据。所以游戏中的数据，一般都会集中存放在单独的数据库中。由于没有数据共用的需求，所以也不需要把里面集中的逻辑划分出很多单独的进程模块来。

数据变更少：实际上游戏的数据变更还是很快的，比如游戏中的每次中弹，都要减少的数值。但是游戏里的数据，一般都遵守这样一个规则：“变化越快的数据，重要性越低”。也就是说，游戏中是可以容忍一定程度的数据不一致和不完整的。而游戏中的数据，一般会分成两类：玩家存档和游戏设置。对于玩家存档来说，其单条数据量一般不大，但会有大量的记录数，因为每个玩家都会有一个存档。但是其读取、修改，一般很典型的和玩家的登录、登出、升级等业务逻辑密切关联，所以其缓存时机是比较容易根据业务逻辑来把握的。而对于游戏设置数据来说，几乎只有升级游戏版本的时候才会修改，大部分运行时是只读的，其缓存简单的读入内存就解决问题了。


一般的缓存系统的特点在游戏中的问题
根据以上的分析，我们可以看到，普通的缓存系统，如和，实际上其特点是不太适合游戏业务的：

一般跨进程的缓存系统，无法解决游戏要求的低延迟问题。级别是同机房，每次数据存取都需要的时间，对于游戏战斗中大量的数据读、写来说，是很难接受的。但是一些回合制战斗、低频操作还是有用的。

通用型的缓存系统或者数据库，一般都比较难集结多个进程，形成一个完整的数据存储网格。这让玩家间的互相交互产生了额外的难度，开发者必须先想办法确定玩家的数据在哪个后台进程上，然后才能去读写。一般的数据库或缓存系统，为了保证数据的一致性或者完整性，往往会需要牺牲一些分布式的能力。而这种牺牲在游戏业务中，其实是一种浪费，因为游戏的很多数据都无需这种能力。

通用性数据系统一般不依赖于特定的语言，所以很少能直接把某种“对象”存入到数据系统中。在游戏开发中，需要存储的数据结构数量往往是非常大量的：一个普通的游戏，基本上都会超过种数据结构。对于每个数据结构，都去建表或者编写序列化反序列化配置，是一种非常累人的工作。——明明在代码中，已经用编程语言定义了他们的结构，还要重复的搞一次。


根据上面说的这些问题，我们实际上是需要另外一种完全不同设计思想的数据系统。
本地分布式缓存服务的特点和优势
对于游戏业务来说，一个好用的数据系统，应该包括这样一些特点：

可以利用进程内的内存进行自动化的缓存管理。由于进程往往集中了大部分的逻辑运算，所以大部分的数据缓存也应该在这个进程中，这样才能符合游戏所需的延迟要求。

自动进行数据落地和容灾管理。由于游戏数据中有大量的“过程数据”，所以其一致性和完整性要求会稍微低于其他业务，所以应该利用这一点，让本身也可以是分布式的程序，从而提高系统整体的吞吐量。

具备良好的编程易用性。最好是能直接存取编程中的对象，避免反复对数据结构的描述，节省大量的开发时间。



相关推荐经典游戏服务器端架构概述 浅谈全区全服架构的游戏后台作者：卢少娜

快速互联网的状态下，测试的价值体现在哪里？俗话说，长江后浪推前浪，前浪拍死沙滩上。我们在新人面前标签应该不仅限于工龄属性上的增长，在经验累积上也是有加分项的。那么问题来了，能体现我们经验值的有什么呢？
今年比较喜闻乐见的词并且能体现测试的价值体现——测试分析。术业有专攻，每个行业都有行业的专长，个人认为“快准猛”是可以拿来衡量每个行业的价值所在，无论是传统行业，还是互联网行业。比如，医生可以很快的定位出病人的病痛；测试人员可以很快找到所在。而测试分析目的是为了通过分析，可以更快的找到。
怎么快速提升测试分析呢？我们测试分析的对象是产品的需求，是开发写的代码。那既然是读需求，读代码，如何用简单易用的办法快速提升自己准确的读需求，读代码能力？
这里插入一个段子，女朋友产品让男朋友开发做个需求：你回来的路上，去超市买点橙子回来；如果看到西瓜，就买个西瓜。男朋友在路上看到西瓜，就只买了西瓜回来。这可以说是程序员思维的 ，但是也是没好好读好需求，注孤生的节奏啊。今天手把手把产品跟开发拿下，无论说什么都能完美的理解。
一、读需求
文绉绉的需求，怎么快速的理解需求，并且转换成我们想要的内容呢？产品的少女心特别难俘虏跟读懂，从获取需求，定义需求的边界，获取业务用例是一个系列的过程，教你两招读心术：
多想想破坏，扣字眼
破坏：读需求的时候，存在一万个怎么办，需要任何怎么办都需要有路径进行解决，这种办法可以比较快的确定需求的边界，这种可以选择典型的探索性摸索。要是产品要买西瓜的时候，如果没有西瓜呢，问一下要不买个苹果？还是不买了？
扣字眼：语言是一种语言模型，讲一句话需求划分为很多种类型的词汇，通过对词汇的深刻理解，进行理解需求，也是目前做需求分析的很热门的一种方式。产品说要买一个苹果纳尼，我要问问是块钱一斤的苹果，还是一斤的那个苹果。
这两个都在里面是热门文章，有兴趣的人请详细阅读。
探索性日常采用的方法总结

典型案例解析
多画建立业务模型分析
产品哪天跟我说了好几个路径，又买苹果，又买橙子，又买西瓜的，我头都听大了，还要从中华广场买的苹果，从维多利亚买的橙子，在华景路买的西瓜，想想都心塞，最后她自己都不知道自己要什么。这个时候从需求分析的时候，动手建立业务模型。业务模型的建立，有易于我们对需求的理解，而且建立一个平等的可以互相理解的沟通平台。白纸黑字很多时候也会存在歧义，所以我们要对一个信息进行二次确认的时候，建议使用建模语言。
一份优秀的需求的特性是：完整的，正确的，精准的，可行的，必要的，无歧义的。从优秀的需求上出发，在做需求分析的过程中，我们就可以更好的理解需求的含义。
二、读代码
  这是一门偷窥开发每日做什么的最佳手段，但是一般人肯定不想身边有个测试妹子碎碎问。所以要采用下面的几个读心术的工具，来知道我们的开发怎么实现某些功能。学习代码其实是上一门编程课程，但是我们的老师是谁呢？应该把我们的开发当做我们的老师，多听，多看他们是怎么实现需求。
多听手段 
全称叫做，当我们完全没有基础的情况下，多上，认真听讲，认真做笔记，甚至后自己写一遍伪代码来学习功能模块。面向的对象是全部人员，主讲人是开发，讲述的是新功能的实现逻辑，每个是怎么封装的，每个跳转是怎么实现的，这个是怎么布局的。大家会有谈论环节，多人讨论主要讨论点：
  这个可能会出现异常？这样子字符串转换会出现。
  这里函数会有性能问题？为什么要前台进程执行？
  这里会不会存在安全性问题？
  这个可能会有性能问题，提取的时间比较长
  这里的  的范围不对，这里锁的范围不准
通过我们可以学习到需求是怎么实现的原理，还可以学习关于性能，安全的问题。在听讲的过程，不断思考自己的测试路径是否会覆盖到这些异常路径，测试过程是否存在优化。
比如这类型的结果，我们要学会是否在测试用例中能够覆盖，后续怎么避免该类型的问题，用例的设计以及选取方便是否可以更精简的路线
多听手段 根因分析
这里的根因分析面向的对象也是开发。每个版本末，开发对这个版本里面出现的的根因进行总结，并且给讲解。根因分析是的完美闭环，在项目开发过程中，发现的时间延后，版本质量风险更大，为此我们也在前期做了冒烟测试；做了总结分析，是否可以把提前发现，根因分析这类型的在是否可以被提前发现，是否有类似问题可以总结归纳成方法。比如上次通过适配的问题，总结了当前主要采用还原的集中方式主要有：
根因分析讲解的是为什么会出现，这个的实现逻辑是怎么样子的，怎么解决这个，是沟通问题？问题？需求问题？等
根因分析是测试分析的二次解读，是否自己的测试分析能够覆盖到这个路径；是否下次遇到类似问题，我们可以怎么减少时间去测试且不漏测。
多看手段 看更新代码
自已看开发每日更新代码
通过关注开发的提交的代码，大知识难消化，那么就切成多个小部分的查看。通过观察开发每日提交的代码，查看这个代码的修改点是什么，是否在自己的覆盖范围内，完善自己的测试分析。
在的累计基础上，小部分的代码消化会比较快，而且测试路径也比较准，测试分析的时候关注影响的测试范围点是什么。

每日 关注
多看手段 看
如果你不懂某一行代码的意思，那么你就把这个代码给注释掉去运行，查看是否会有什么明显的变化。“对比“是一种很好的学习办法，  就是测试分析的利器，今天突然需求增加；今天突然砍掉这个功能；今天只修改了这个你测试一下？……
这里主要介绍两个  的利器，客户端
客户端，是腾讯自研的一个客户端，
从上图可以看出，客户端里面可以根据一个的基版本跟右版本进行对比，并且输出对比文件，双击文件可以查看到 的内容。
，是自带的工具，可以查看开发提交的日志，通过多选的记录，右键，   再拷贝到记事本里面可以查看连续的几个开发的日志，并且修改的文件
多想如果是你，你怎么做
大胆猜测如果你的角色是开发，你会怎么做实现这个功能，怎么抽象表结构，类方法，属性，页面等，从模型设计到接口设计。测试分析要做那么多么？如果是小需求的话，其实在脑海里能够转换就行了；如果是比较大的需求，我们可能需要多涂鸦，从整体上查看是否有实现漏洞，或者需要多关注哪一些环节的测试要点。
多写多动手
不会写程序的产品不是好测试，摆脱开发做根因分析
孰能生巧，这绝对不是说假的。一个不懂开发的人，写了年的代码，也是可以写出一些代码来。实践是唯一快速上手的事情，从写一个 开始，到写一个日志，到尝试协助开发定位问题，在这个过程也会受益良多，并且比自己看半天代码的收益会很多，并且在这个过程，你对每个的使用会更加的熟练，评估内容更加准确。
摆脱开发做根因分析，以往我们可能常常问下开发，为什么这样子，为什么会出现那样子，如果学会自己定位，第一次可能定位到的问题，第二次定位到的问题，再定位到，细化到哪一行，哪一个调用，哪一个根因。逐渐的提升自己的代码能力，对测试分析评估是起了很大作用。
三、总结
上述的动作，词汇可能很简单，但是做起来其实是有难度的，学习最好的过程就是放下身段把自己当做新人进行学习，多听少讲。
测试分析感觉听起来像是一个开发，其实不然，测试分析没有必要跟着开发一样实现代码，但是至少能看懂开发的代码，知道开发解决的是什么问题，会不会影响以前的逻辑，会不会造成其他的。这个也是开发跟测试岗位的术业与专攻，我们关注的是从代码里面发觉更准确的测试路径，提前把更早的发现。
巧妙的使用好上述手段，其实我们已经完美的俘虏了产品跟开发的内心，更好的合作的前提就是互相了解，互相读懂，才能更好的做下一步的操作，并且通过简单的操作提升测试自身的能力。

相关推荐
【腾讯】和开发一起写代码，让测试左移起来
手游兼容性测试
【专项测试】—冲突测试大多数程序猿都用过全球最大的托管平台，上面有丰富的开源项目。在上托管开源项目是免费的，但是私有项目需要收取管理费。对于拥有云服务器的开发者或者团队，可以使用本文介绍的平台。话不多说，我们来看看具体的步骤。系统环境：腾讯云服务器，配置核心内存，系统
初始化服务器环境
、设置系统。根据官方的介绍，硬件建议使用双核内存的配置。本文主要介绍安装和配置方法，选用的是单核内存的机器，为了提高系统的响应，设置大小的。设置过程简略，参考连接  设置完成后运行，可以看到设置成功。
___   
                                         
                                                          
                             
、安装为了使所有流量走端口，本文使用做反向代理。在官方的源中是没有这个软件包的，需要运行
  
添加源，腾讯云的上已经包含了源，直接运行
___    
即可安装这里需要注意的是腾讯云在云服务器的控制台这里配置了安全组策略，默认的安全策略组没有打开端口，需要手动添加端口的规则。、安装安装非常方便，直接运行
___     
、启动
___     
___    
                                                                               
目前服务还没有任何容器、更新镜像源由于的镜像服务器在国外，直接拉取镜像的时候速度非常慢。有很多国内的镜像，本文以为例，在注册后，会得到一个更新镜像源的命令：
___    _ |   
  = 
{ 
     
}

            
___    
到这里就已经初始化好了运行的环境
安装
、镜像选择官方在上有镜像，一些第三方开发者也上传了自己的镜像，通过运行搜索命令可以看到可用的镜像：
___    
                                                                                                   
                                                     
                                                                     
                                                                                          
                                                       
                      这是汉化的  社区版                                        
                                                     
                                                       
                                                         
我们可以根据自己的喜好选择镜像。本文使用的是一个的镜像有关这个镜像的详细说明参考 、拉取镜像根据镜像的说明，还需要使用数据库和，也可使用镜像，如 中介绍的镜像。本文使用的是已建好的和资源，
___     
___   
                                                                  
                                        
由于我们之前设置了镜像源，拉取镜像的过程只需要两分钟就完成了。、创建容器
___           \
          \
     _=  _= \
     _=  _= \
     _=__ \
     _=  _=  _=\
     _=  __= \
     ____= \
     ____= \
     ____= \
     ___= \
      \
    
检查容器运行情况
___    
                                                                                                                                                
                                     
___   
    
                                     
                                              
                                                    
                                                              
                                              
                                              
                                                           
说明的容器已经正常运行起来了。
安装
、镜像选择类似，先搜索镜像
___    
                                                                                           
                                            
                                                  
                                                    
                                            
                                                                         
                                                                                          
官方没有提供镜像，本文选择镜像
___    
、创建容器本文采用的登录方式，需要在先注册一个账号，注册内容如下
___    \
  \
  \
  \
 = \
 _= \
 _= \
 _= \
 ____= \
 ____= \
 ___= \
 ___= \
 _ \
 
___    
                                                                                                                                                      
                                                                  
                                          
___   
    
                                     
                                               
                                              
                                                     
                                                              
                                              
                                              
                                              
                                                           
说明的容器已经正常运行起来了
与配置及使用
由于我们的服务器安全组只开了端口，而与都不是工作在端口，因此考虑使用做反向代理。的反向代理很简单，在目录下新建
___   
___   
输入以下内容并保存
 

{
     
    _ 
      {
        _ 
        __  
        __  _
        __  ____
        _ 
    }
}
 

{
     
    _ 
      {
        _ 
        __  
        __  _
        __  ____
        _ 
    }
}
测试配置文件有无错误并给发送指令
___   
       
      
___    
在浏览器中分别输入 以及到这里就完成了与的安装导语： 本文提出一种利用无序数组、双向链表、位标记进行视野管理的算法，可以将每次增、删、查视野列表的复杂度降为。

 视野管理的必要性
在大型多人在线游戏  中，多个玩家在同一场景，此时玩家需要能看到其附近的玩家，同时不需要看到与其距离远的玩家。这就是视野管理需要做的事情：为每个玩家维护一个视野列表，管理每个玩家可见视野内的其他玩家。
游戏中，视野对服务器造成的压力主要来源于两点：
一，玩家频繁移动造成视野列表的频繁更新的压力；二，广播视野列表的带宽压力。
因为视野列表中的玩家频繁变化，有的玩家离开当前玩家的视野，有的玩家新进入当前玩家的视野，因此当前玩家的视野列表需要进行频繁的增、删、查操作，因此增、删、查操作的时间复杂度要尽可能的低，从而缓解视野列表频繁更新的压力。如果当前视野列表中有个玩家，每个玩家都移动了一段距离，为了让其他玩家看到自己的移动，每个玩家都需要被通知其他个玩家的移动，这就需要广播个数据包，随着地图中玩家数目增加，造成广播量急剧增加，对带宽造成极大压力，因此玩家的视野列表需要有规模限制，从而缓解带宽压力。
本文提出一种利用无序数组、双向链表、位标记进行视野管理的算法，可以将每次增、删、查视野列表的复杂度降为。
 视野管理算法
 九宫格
游戏中地图用来承载阻挡、静态建筑、非玩家控制角色： 、点等。玩家在地图上移动，其可见的其他玩家即发生变化，如果玩家的每次移动，都更新视野列表，时间成本太高，因此只有当玩家离开某个区域时，才更新视野列表，而在这个区域内的移动，并不更新视野列表。为了划分这个区域，引入九宫格概念，如图所示，九个格子的总面积大于一个手机屏幕，小于两个手机屏幕。大于一个手机屏幕的原因是，可以预先计算当前屏幕外的一些玩家，但又没有必要预先计算太多的屏幕外玩家，因此小于两个手机屏幕，玩家可见的范围为以玩家为中心周围九个格子内的其他玩家。如果玩家在格子内移动，则不主动更新视野列表，玩家可见范围为红色和绿色格子内的玩家如果玩家视野列表内的玩家从一个格子移动到另一个格子，导致和不可见，也会导致玩家的视野列表发生更新，称为被动更新，如果玩家从格子移动到格子则主动更新视野列表，玩家可见范围为紫色和绿色格子内的玩家。

图 玩家从九宫格的格子移动到格子
 视野管理的数据结构
视野管理共采用三个数据结构：无序数组、双向链表、位标记。无序数组的增删时间复杂度为；双向链表可以在遍历视野列表时避免遍历整个无序数组；位标记在判断两个玩家是否相互可见时时间复杂度为。
 无序数组
视野管理的数据结构首先是采用无序数组：每个玩家有两个数组，一个数组存储其他玩家信息的对象指针，对象包含三个元素：其他玩家的指针、当前玩家在其他玩家视野数组中的索引、其他玩家在当前玩家视野数组中的索引，第二个索引供双向链表使用，数组某些元素可能空置；另一个数组辅助管理数组，数组元素是一个结构体，成员变量为：标识变量、记录的空闲位置的变量，数组的规模与数组规模大小相同。其中，数组的第个元素中的标识变量表征数组的第个元素是否被分配。另外，设置两个指针在数组上移动，分为头指针和尾指针，用于维护、快速查找数组上空闲的位置，如果分配空闲位置，头指针向右移动，如果回收已分配位置，尾指针向右移动。
如果从的视野列表中删除，首先查找在的数组的索引，单独查找索引的算法并非的算法，但批量查询索引的算法是的算法，详情见下文：视野管理的流程。 通过索引可以直接查到该玩家在的数组中存储位置，然后清空的数组中该玩家信息，并将的数组对应的位置的分配标记置为空闲，数组的尾指针位置记录新空闲位置，尾指针右移；如果要加入一个玩家，通过的头指针查询到的数组中存储的第一个空闲位置，并检查数组中该位置的分配标记，如果分配标记为空闲，即可将新入玩家放到的数组中该位置，并将的数组中该位置置为已分配，头指针右移。
假设视野列表大小为，下面以表格的形式演示本文算法，表格的前三行对应数组每个元素对应三元组，其中是数组元素位置索引，是数组中空闲的位置索引，是数组中该位置是否被分配只是为了校验：值为表示数组该位置未被分配，可在该位置存储新进入视野列表玩家；值为表示该位置已分配，存储了视野列表中的玩家。表格的第四行行，标记在数组游走的两个指针的游走位置，：表示头指针；表示尾指针。下面展示数组在为数组分配和回收位置时的变化。
初始状态如表所示，初始状态视野列表为空，即数组中不存储任何可见玩家，数组中记录数组全部位置：、、、、；数组中全部为，表示数组全部为空；数组中的两个指针都指向第一个位置。
假设需要分配数组中三个空闲位置给进入视野列表玩家，此时遍历指针和指针中的位置，因为这两个指针之间的位置存储的都是空闲位置，每分配一个空闲位置，都将对应标记为，同时指针右移动，分配的位置为数组中的、、。结果状态如表所示。
接着，假设删除一个玩家该玩家在数组中索引为，则将指针所指位置的改为，同时指针右移，表示和指针中的空闲位置多了，将数组中位置处的改为，表示数组中索引为的位置空闲。状态结果如表所示。
然后，再分配数组中两个空闲位置给新进入视野列表玩家，此时遍历头指针和指针中的位置，将数组中位置为、分配给新玩家，将数组中、处的改为，移动到处，状态结果如表所示。
最后，清空数组中所有玩家个玩家索引分别为、、、，将指针所指位置的改为位置处的改为，指针右移，直到所有玩家清空，状态结果如表所示。
表 初始状态，视野列表为空

表分配三个位置给进入视野列表玩家的结果状态

表删除数组中位置为的玩家的结果状态

表分配两个位置给进入视野列表玩家的结果状态

表删除数组中全部玩家后的结果状态

 双向链表
采用无序数组的一个弊端是数组中存在很多碎片，有些位置并没有存储玩家。这就导致遍历玩家的视野列表时，需要把整个无序数组全部遍历一遍，极端情况下玩家的视野列表一个玩家都没有，但也需要遍历整个数组。因此采用双向链表辅助存储，双向链表中每个节点存储的元素和无序数组存储的元素一样，存储其他玩家信息的对象指针，对象包含三个元素：其他玩家的指针、当前玩家在其他玩家视野数组中的索引、其他玩家在当前玩家视野数组中的索引，但所有节点都是有效的，如果视野列表无其他玩家，则双向链表为空。遍历玩家的视野列表时，只需要遍历双向链表即可，不用遍历整个无序数组。双向链表增删时间复杂度均为，将一个玩家加入无序数组时，将其插入双向链表尾部；将一个玩家从无序数组删除时，因为无序数组和双向链表存储的元素一样，从无序数组中拿到存储元素，将该元素从双向链表删除即可。
 位标记
游戏中需要频繁的判断两个玩家是否相互可见，然而采用无序数组双向链表的数据结构，最快只能采用遍历双向链表的方法，该时间复杂度为，因此采用第三个数据结构：位标记辅助完成这项工作。每个场景中的数量是有限的，我们游戏每个场景的数目最大为，编号从到，每个玩家是否可见用一个表示。所以每个玩家共需要个表示是否与其他个可见，即。假设的为，判断是否可见，只需要查看的第个位标记是否为即可。
 视野管理的流程
如图所示，玩家从格子移动到格子，老视野可见的玩家为红色和绿色格子内的玩家，新视野可见的玩家为紫色和绿色格子内的玩家。首先遍历的双向链表，对所有老视野列表的玩家打上标签，然后遍历紫色和绿色格子内的玩家，如果玩家已打标签，则将玩家打上标签，说明玩家在新视野和老视野都可见；如果玩家没打标签，则说明玩家是新进视野的玩家，加入；重新遍历的双向链表，如果玩家仍然是标签，说明玩家只在老视野，没在新视野中，加入，同时记录玩家在玩家视野数组中的索引。例如在格子时老视野列表里的玩家为：、、、、、；移动到格子时，紫色和绿色格子内的玩家有、、、、、。首先对双向链表到六个玩家打标签；然后对到打标签，因为到已打标签，所以对这个玩家打标签，而、没打标签，所以这两个玩家加入；再遍历双向链表、因为仍然是标签，所以将这两个玩家加入，同时记录这两个玩家在视野数组中的索引、。
对的两个玩家、，首先根据的索引从的视野数组中删除，并将的数组对应的位置的分配标记置为空闲，数组的尾指针记录新空闲位置并右移；将双向链表中对应的节点删除；将位标记对应的置为。因为视野是相互的，根据的数组中记录的在的数组中的位置，将也从的视野列表中删除。对采用同样操作。
对中的玩家，需要按照优先级高低放到不同的桶里，比如队友的优先级比其他玩家优先级高。然后按照优先级高低的顺序加入视野列表，如果视野列表已满，优先级高的玩家仍然没进入视野列表，需要从视野列表中删除优先级低的玩家，以便腾出空间将优先级高的玩家加入。对的两个玩家、，通过的头指针查询到的数组中存储的第一个空闲位置，并检查数组中该位置的分配标记，如果分配标记为空闲，即可将新入玩家放到的数组中该位置，并将的数组中该位置置为已分配，头指针右移；将对应的节点插入双向链表尾部；将位标记对应的置为。因为视野是相互的，也需要将加入的视野列表。对采用同样操作。导语：
本文主要围绕介绍提升网站后台开发工作效率的实践经验。前半部分主要介绍用优化网上性能问题的经验总结，后半部分介绍笔者基于开发的一个小工具，用于定位接口调用相关的问题开发遇到最多的一类问题，最后提出笔者针对开发工具建设的一点思考。
背景：
首次注意到这款工具，是因为笔者长期参与建设并维护的一款运维产品，经过两年多不断的修修补补，部门内运维同事用起来也越来越顺手了。然而产品中暴露出来慢的问题也日益突出，作为早期开发人员之一，有点心塞的感觉，跟组长沟通之后准备花点时间优化一下。刚开始着手优化的时候按照一贯的办法，找出响应慢的，再在工程中加或来查看究竟哪些地方慢，这种方式效率特别低，加代码测试查看性能数据定位问题原因优化代码重新测试，整个过程走下来，一个小小的优化就要花上半天时间。
晚上回家后就琢磨着怎么提升速度，就感觉这件事不能这么玩下去，如果有一款工具可以快速直观的定位出问题原因，那么这事就好办多了，团队内其他同事也可以参与进来一起优化。这就是本文要讲的工具，为了简洁，本文后面统一简称为。
：
该说下是个什么东西了，简单说它就是一个开发调试工具集，集成了许多相互独立的调试工具，这些可以在前端直接展示调试信息。
关于更详细的说明可以参考官方文档，笔者这里只打算介绍个人觉得最有用的两个。
一是，它能记录每个请求及耗时情况，并提供按钮给我们直接分析慢的原因，另外还可以统计出类似查询的次数比如循环中的查询。另外一个是，它可以跟踪响应的整个函数调用过程及时长，这样可以帮助我们快速定位出最耗时的函数。
__ = 

     
    _   配置，比如启动时陪在环境变量中的一些值 
    _   查询时间、重复查询、
    _   性能分析

工作原理：
整个框架的核心就是中间件，通过中间件的方式加入到工程中，中所有的也是类似中间件的形式被调用。
下面结合请求处理过程来说明是如何工作，图请求响应处理过程
中黄色区域标记的是中间件处理函数，中间件实现了中间件、中间件和中间件，在中间件和中间件中一次调用所有的中间件进行处理，最后在中间件中收集所有采集的信息，并以的形式注入到 中 这就是的大致工作流程。更具体一点，我们通过几个的例子进行说明：
： 这个很简单，仅仅在中间件调用时读取 信息，并输出成页面片段：比如说描述的就是在该启用的时候对 进程，进行一个操作，这样每次外层视图函数内部进行操作时，就可以记录起来，在中间件调用时输出结果，同时进行操作。：又比如说模块是在调用中间件的时候直接用调用视图函数，并收集数据。
使用总结：重点部分
下面是项目中的实践总结出来的一点经验，希望能给大家提供点有用的信息：
问题处理前面讲时提到 将调试信息以的形式注入到返回的内容中，由于请求返回更多的是数据，如果直接将信息插入返回内容会导致真实的返回内容被破坏。目前网上最为成熟的解决方案是
需要注意的页面冲突问题及解决办法将调试信息以的形式注入到返回的内容中带来的另外一个问题就是容易引起页面，比较容易想到的重复加载会导致两次加载之间初始化的第三方插件被清空。为了防止引起页面，比较保守的方式是采用中提到的方案，我在附件中提供了一小段代码供参考。
是否可以将应用到现网？我们在开发、维护过程中往往有一些直接在现网定位问题的需求，特别是开发环境往往系统的熵、数据量都不够，另外，现网发现问题往往要以最快的速速找到原因和解决方案，在开发环境重现问题效率特别低，如果能够直接在现网定位问题，很快情况下将会大大加快问题跟进处理周期，对开发人员本身也能一定程度提升工作效率。
将用于现网需要几个方面的问题：
 性能：其实开启对单次请求具有一定影响，特别是执行耗时非常大，它是默认不开启的唯一一个。由于只是调试工具，并不用于监控，可以仅在需要时打开。另外所有功能都处于关闭状态，对系统和单次请求的性能影响都非常小只是几个逻辑判断，因此将用于现网性能方面是可行的。
 稳定性：这一块是最难确认的，为了简化问题分析，我们将服务进程生命周期按开启前后分成三个阶段。从未开启之前，的代码是没有执行到，对服务进程是没有影响的。由于开启时可能会向代码中注入一部分代码，因此对于关闭之后对稳定性是否有影响要看注入的代码是否恢复，经过检查中代码，可以确定，关闭之后代码是恢复了的。比如前面工作原理
提到的在中间件调用时有操作。最后开启过程中，可以从服务模式进行考虑。如果服务工作在进程模式，由于进程必须处理完一个请求再处理另外的请求，因此进程模式下开启过程中只会对当前请求有影响。最后线程和协程的服务模式可能因为全局代码被而受到一定影响，因此对于这种开启会进行操作会对线程和协程模式有短暂影响，进程模式是安全的。
 安全：任何系统被任意查看系统内部信息都很危险，开启和查看都只能管理员才能进行操作。
总结：仅在服务是进程模式时部署到现网环境才是可信的。另外，所有应该是默认关闭的，只有管理员和开发人员才允许开启和查看的信息。
是否可以应用于代码环境目前官方的仅支持及以后的版本，是不支持的，由于笔者实践的项目是基于开发的，笔者针对对进行了一个代码调整，除了，其它都可以用到环境。附件中提供了修改后的代码供参考。
应用到蓝鲸开发环境
一个记录第三方接口调用的：
前面提到的和是中非常重要的两个功能，个人感觉中最重要的是它可以作为构建自己开发工具的脚手架，提供了很多开发工具构建思路的同时，还可以减轻构建开发工具的工作量。笔者的另外一个项目中应用了大量第三方接口服务，前期接口对接和后面的运营过程中遇到了很多接口问题，定位和反馈问题很是耗费时间，最终笔者写了一个 它可以在不用修改接口调用代码的情况下，记录第三方接口调用的详细输入输出，欢迎大家试用。
展望：
我在使用的过程中也总结了一些痛点和可改进的地方，希望有兴趣的同学可以一起完善开发工具。

性能分析工具不够完善，基于开发的，缺少更细致的性能分析，如果能结合的功能定位出大致慢的函数，然后可以方便的用定位具体慢的行，这个性能分析工具将会更棒。

缺少一个好用的定位的。 程序异常退出位置有时定位比较耗时，如果有一个能直接显示出响应轨迹，那么定位异常位置会更直观更快速。 程序异常的往往因为非预期的变量值，但是往往靠猜测然后确认，如果能直接显示感兴趣的变量值，可以节省不少时间。一、前言
的核心是双向绑定和虚拟下文我们简称为，关于双向绑定可以参阅木琴的文章《剖析原理实现双向绑定》，是树状结构，其节点为，和浏览器中的一一对应，通过的属性可以访问到对应的。
因为是纯粹的对象，所以操作它会很高效，但是的变更最终会转换成操作，为了实现高效的操作，一套高效的虚拟 算法显得很有必要。
的算法是基于改造过来的，感兴趣的朋友可以选择查阅。

这是一张很经典的图，出自《’  》，的算法也同样，即仅在同级的间做，递归地进行同级的，最终实现整个树的更新。那同级 的细节又是怎样的呢？正是本文所要讲的。
二、例子
我们在下文中将使用这个简化的例子来讲述的过程

如上图的例子，更新前是到排列的列表，更新后是乱序排列的列表。罗列一下图中有以下几种类型的节点变化情况：
、头部相同、尾部相同的节点：如、
、头尾相同的节点：如、处理完头部相同、尾部相同节点之后
、新增的节点：
、删除的节点：
、其他节点：、、、、
三、简单的
简单的算法可以这样设计：
逐个遍历的节点，找到它在中的位置，如果找到了就移动对应的元素，如果没找到说明是新增节点，则新建一个节点插入。遍历完成之后如果中还有没处理过的节点，则说明这些节点在中被删除了，删除它们即可。
仔细思考一下，几乎每一步都要做移动的操作，这在整体结构变化不大时的开销是很大的，实际上变化不大的情况现实中经常发生，很多时候我们只需要变更某个节点的文本而已。
接下来我们看一下的实现
四、的实现
上图例子中我画上了，这样对指针，分别对应和的起点和终点。起止点之前的节点是待处理的节点，不断对进行处理同时移动指针直到其中任意一对起点和终点相遇。处理过的节点会在和中同时将它标记为已处理标记方法后文中有介绍。通过以下措施来提升的性能。
一、优先处理特殊场景
、头部的同类型节点、尾部的同类型节点
这类节点更新前后位置没有发生变化，所以不用移动它们对应的
、头尾尾头的同类型节点
这类节点位置很明确，不需要再花心思查找，直接移动就好
处理了这些场景之后，一方面一些不需要做移动的得到快速处理，另一方面待处理节点变少，缩小了后续操作的处理范围，性能也得到提升。
二、“原地复用”
“原地复用”是指会尽可能复用，尽可能不发生的移动。在判断更新前后指针是否指向同一个节点，其实不要求它们真实引用同一个节点，实际上它仅判断指向的是否是同类节点比如个不同的，在上它们是不一样的，但是它们属于同类节点，如果是同类节点，那么会直接复用，这样的好处是不需要移动。再看上面的实例，假如个节点都是，那么整个过程中就没有移动的操作了。
“原地复用”在的官方文档中有提到，虽然带来了好处，但是也会产生一些问题，朋友们可以复习一下

用管理可复用的元素
五、按步解剖实例
一、整体视图

先看一张整体视图，整个分两部分：
、第一部分是一个循环，循环内部是一个分支逻辑，每次循环只会进入其中的一个分支，每次循环会处理一个节点，处理之后将节点标记为已处理和都要进行标记，如果节点只出现在其中某一个中，则另一个中不需要进行标记，标记的方法有种，当节点正好在的指针处，移动指针将它排除到未处理列表之外即可，否则就要采用其他方法，的做法是将节点设置为。
、循环结束之后，可能或者中还有未处理的节点，如果是中有未处理节点，则这些节点是新增节点，做新增处理。如果是中有这类节点，则这些是需要删除的节点，相应在树中删除之
整个过程是逐步找到更新前后的差异，然后将差异反应到树上也就是，特别要提一下的是即时的，并不是打包所有修改最后一起操作则是将更新放入队列后集中处理，朋友们会问这样做性能很差吧？实际上现代浏览器对这样的操作做了优化，并无差别。
二、逐步解析
、处理头部的同类型节点，即和指向同类节点的情况，如下图中的节点
这种情况下，将节点的变更更新到，然后对其进行标记，标记方法是和后移位即可，过程中不需要移动更新或许是要的，比如属性变更了，文本内容变更了等等

、处理尾部的同类型节点，即和指向同类节点的情况，如下图中的节点
与情况类似，这种情况下，将节点的变更更新到，然后和前移位进行标记，同样也不需要移动

、处理头尾尾头的同类型节点，即和，以及和指向同类节点的情况，如下图中的节点和节点
先看节点，其实是往后移了，移到哪里？移到指向的节点即节点后面，移动之后标记该节点，将后移位，前移一位

操作结束之后情况如下图

同样地，节点也是类似的处理，处理完之后成了下面这样

、处理新增的节点
来到了节点的位置，在中找不到节点，说明它是新增的
那么就创建一个新的节点，插入树，插到什么位置？插到指向的节点即节点前面，然后将后移位标记为已处理注意中没有节点，所以标记过程中它的指针不需要移动，处理之后如下图

、处理更新的节点
经过第步之后，来到了节点的位置，在中能找到它而且不在指针位置查找中到区间内的节点，说明它的位置移动了
那么需要在树中移动它，移到哪里？移到指向的节点即节点前面，与此同时将节点标记为已处理，跟前面几种情况有点不同，中该节点在指针下，可以移动进行标记，而在中该节点不在指针处，所以采用设置为的方式来标记一定要标记吗？后面会提到

处理之后就成了下面这样

、处理、、、节点
经过第步处理之后，我们看到了令人欣慰的一幕，和又指向了同一个节点即都指向节点，很简单，按照中的做法只需移动指针即可，非常高效，、、、都如此处理，处理完之后如下图

、处理需删除的节点
经过前步处理之后实际上前步是循环进行的，朋友们看跨过了，它们相遇啦！而这个时候，和还没有相遇，说明这个指针之间的节点包括它们指向的节点，即上图中的节点、节点是此次更新中被删掉的节点。
，那我们在树中将它们删除，再回到前面我们对节点做了标记，为什么标记是必需的？标记的目的是告诉它已经处理过了，是需要出现在新中的节点，不要删除它，所以在这里只需删除节点。
在应用中也可能会遇到的起止点相遇了，但是的起止点没有相遇的情况，这个时候需要对中的未处理节点进行处理，这类节点属于更新中被加入的节点，需要将他们插入到树中。

至此，整个过程结束了
的算法与动态规划算法中的经典案例“计算到的最小编辑距离”看上去有些相似，实际完全不同，的相对来说轻量很多，感兴趣的朋友可以查阅相关资料进行了解。
好啦，感谢你的阅读，希望能帮助你理解的算法，在阅读过程中遇到的问题也欢迎一起交流！作者：

导语
为了解决模式下的占用空间问题，曾经花了一个半月时间实现分平台合成。 后对内联的新发现，似乎再一次认证了热补丁不是请客吃饭这句话。研究或填坑的路可能永远不会停，但团队有决心与信心可以陪大家一起走下去。
 背景
 是在版本中引入的新虚拟机环境，在版本正式取代了 。环境下，安装时其包含的文件将被预编译成目标平台的机器码，从而提高了的运行效率。在这个预编译过程中，对目标代码的优化过程与 下的有较大区别，尤其是在版本以后环境下新增的方法内联优化。由于方法内联改变了原本的方法分布和调用流程，对热修复方案势必会带来影响，本文将分析下方法内联策略，并总结方法内联对现有的主流热修复方案造成的影响。
浏览源码可知，用来生成文件的有多种实现，各版本中存在的实现类型和默认使用的类型如下：



版本
类型
默认使用
备注







此版未引入方法内联优化



  

是半成品，未实际使用



 

从此版本开始，加入下文归纳的新内联特性














其中 的方法内联条件可以从__里的方法开始分析，篇幅关系这里直接给出结论。对于 ，当以下条件均满足时被调用的方法将被：

不是版本的；
被调用方法的实现满足下列条件之一： 
 空方法； 
 仅返回方法参数； 
 仅返回一个方法内声明的常量或； 
 从被调用方法所在类的非静态成员获取并返回获取的值；注意， 成员会被优化成常量，此时要参照 
 仅设置了被调用方法所在类的非静态成员的值； 
 仅设置了被调用方法所在类的非静态成员的值，并返回一个方法内声明的常量或。



注：条件隐含了一个条件，就是被调用的方法的字节码不超过条。
 的内联条件可以从里的方法开始分析，篇幅关系这里同样直接给出结论。对于 ，当以下条件均满足时被调用的方法将被：、不是版本的；、被调用的方法所在的类与调用者所在的类位于同一个；注意，符合 命名规则的多个要看成同一个、被调用的方法的字节码条数不超过通过指定的值，默认为，默认为；、被调用的方法不含块；、被调用的方法不含非法字节码；、对于版本，被调用方法还不能包含对接口方法的调用。指令
此外， 的方法内联可以跨多级方法调用进行，若有这样的调用链：，则在四个方法都满足内联条件的情况下，最终内联的结果将是包含，，的代码，包含，的代码，以此类推。但这种跨调用链内联会受到调用时通过参数指定的值的限制，默认为，即超过层的调用就不会再被内联到当前方法了。
 主流热修复方案
目前主流热修复方案可分为派和派，派的做法大致有以下两种：

用新方法的描述结构体覆盖旧方法的描述结构体，从而替换旧方法的逻辑。

将旧方法修改为类型，并将其实现指向一个公共分发函数，由该函数负责调用新方法
派的做法也有两种：

将修改过的类汇集成一个，插入到的的最前面，这样在加载类时就会优先加载修改过的类

对每个方法插一段逻辑，此逻辑判断方法是否被打补丁，是则执行新逻辑
显然，对派而言，如果修改的方法被内联到了调用者的代码里，则修改将不会生效，因为内联的代码不再需要方法调用，也就不会涉及到额外的层方法描述结构体。对于派而言，插入一段逻辑的做法基本不受影响，因为内联时会将被修改的方法连同插入的那段逻辑一起复制到调用者的代码里，结果和内联之前是等价的。但通过优先加载补丁里的类来取代旧类的做法会受到怎样的影响呢？这就需要进一步分析了。
 方法内联对的影响
通过让优先加载补丁里的类来使补丁生效，即派里的第一种方案。在没有考虑到内联的影响之前，这套方案有些兼容性问题已得到解决，但在最近的灰度过程中，我们又发现了这样的：

诡异的 前面有的行表示补丁里包含该类。

方法的字节码，报错的为，因为为空
其中的实例在类里是定义时赋值给字段的，按理说不该为，看着好像又是地址错乱的问题了，于是按照之前的经验，了栈顶附近几个方法的机器码，发现方法内联了方法，不过现在还不能肯定是不是内联带来的问题，于是跟着方法的机器码走一段：

方法的机器码
图里 = ，对应的；   = ，对应的。图里提到的是一个缓存数组，用来存放过的类的地址。由机器码的这一行 
     
可知，用来检查是否过的是从的结构里的某个字段获取的，这样我们只要知道的是的还是的就可以了。于是回到上面判断那部分，我们跟着机器码跳到的位置：

这个实际上就是方法，看__就知道了。从方法开始又依次调用了  ，经过几个不同原型的之后最终调到了，从开始就是经典的加载类的流程了，大家可以参考老罗的这篇文章：运行时加载类和方法的过程分析。根据这个流程，最后被加载的来自，所以保存在它的描述结构体里的就是的了。
搞清楚这个问题之后，我们再来看为何会报。回到方法的机器码，我们看第二部分，在从这个位置拿到之后，接着就会判断是否被，然后问题就来了，既然这个是的，那机器码里用这个里的来访问究竟靠谱吗？和之前那个地址错乱的问题类似，这里会遇到三种情况：



情况
后果




里的恰好就是里的
没事，补丁正常生效


里的 = 的的长度
被干掉， 为数组下标越界


里的在的里指向了其他类
无法预料，可能崩溃，可能导致程序流程异常



如果你的补丁变更规模很小，一般会大概率命中第二种情况；如果你的补丁变更规模很大，则会有很大概率命中第三种情况。微信这次灰度报的对应的就是第三种情况了，所以最后通过去拿成员的值的时候会拿到，于是就报了。
 可能的应对方案
参考里的内联条件，如果阻止方法内联，就可以避免出现机器码里用旧去新里查找类的情况了。对我们来说比较方便的条件就是在每个方法前面插入一个空块，这样这些方法就不会参与内联了。不过考虑到的内联触发条件随时都在更新，保险起见并没有这样做。
另外一个思路是把修改类的整个调用链调用修改类的类，与调用调用修改类的类的类，一直递归下去都放到补丁中，需要包括所有可能被影响的类。这套规则的主要问题在于整个完整调用链的类会非常庞大，很有可能与全量差别不大，其次不排除未来有新的优化导致这样的方式会失效。
最终采用的应对方案是去掉环境下的合成增量的逻辑，直接合成全量的，这样除了类，所有方法统一都用了里的，也就不怕有方法被内联了。至于全量新在系统之后触发可能导致启动时的问题，是通过在进入之前判断是否变化来得知系统是否进行过，然后根据判断结果手动触发多线程加以缓解的。
 总结
方法内联之所以会导致优先加载补丁的方案出现上述问题，本质上是因为补丁只覆盖了旧里的一部分类，一旦被覆盖的类的方法被内联到了调用者里，则加载类的过程还是正常的，即从补丁里加载了新版本的类。但由于内联，执行流程并未跳转到新的方法里，于是所有关于新版本的类的方法、成员、字符串的查找用的就都是旧方法里的索引了。这里“用旧索引找新目标”的场景又出现了，自然可能出现异常。
 及之后的 通过相对激进的内联策略，进一步提升了的运行效率，但这也为各类热修复方案带来了一些麻烦。通过分析，理论上我们确实可以通过破坏内联条件强行让所有的方法都不参与内联，但这样一来的运行时性能就会受到较大影响，而且今后如果内联标准更新了，我们还需要持续跟进，这也是不太现实的。因此通过这次灰度发现的问题，我们最终还是用了相对保守的方案来解决。
最后，通过分析这个问题，我们也更加深刻地认识到了的复杂性。时间仓促，关于方法内联的策略及其带来的问题还有许多细节并没有在这篇文章里提及，如果有补充的知识或者更好的应对方案，欢迎一同交流学习。

本文来源于： 微信公众号在新加坡中心区域一栋名为的  层建筑，跟随工作人员经过  重门禁关卡，密密麻麻的金属架子上，数量众多的服务器不时闪烁着蓝色的光。这里是腾讯在新加坡布局的数据中心，腾讯云近日在此召开了一场新闻发布会。

腾讯云副总裁曾佳欣在发布会上透露，腾讯云今年全球化布局全面提速，年内将新增五大海外数据中心，包括刚刚开放的美国硅谷数据中心，以及德国法兰克福、韩国首尔、印度孟买、俄罗斯莫斯科数据中心，目的是为走出去的中资企业和海外企业拓展全球业务提供云服务。
记者了解到，近半年来，腾讯在国内也扩增了北京、上海、广州等多地的数据中心，连同分布在亚太、欧洲、北美、南美的  大海外合作数据节点，目前已开放的全球服务节点达  个，是全球云计算基础设施最广泛的中国互联网云服务商。
与数据提供商合作快速布局海外
工信部印发的《云计算发展三年行动计划 年》显示，到  年我国云计算产业规模将达  亿元，并提出争取国内涌现出  至  家世界级有竞争力的云计算企业的目标。
在快速崛起的云计算产业领域，依然备受关注。主要以中小企业、初创企业为服务对象的阿里云，不仅达成了云服务在企业端的广阔覆盖，并且快速成为非常赚钱的一项业务。百度的云计划则更具科幻感，将人工智能、大数据和云计算三者融合发展。以游戏、社交著称的腾讯，其云领域并不满足于这些。
在  一层大厅，有一幅特殊的世界地图，以众多中心城市为圆心发出的射线覆盖了整张地图。腾讯云海外  高级运营经理李宇明告诉记者，数据中心在选址就在这些圆心城市上。以新加坡为例，其作为亚太区最大的网络枢纽，汇集了最密集的各类数据，堪称网络马六甲海峡，在此落地数据中心将能帮助企业连接多个国际及区域级网络。
以海外数据中心为支撑的云计算是一艘邮轮，在大船上迎接风暴和波浪肯定要比小船要稳当。乘风破浪，也保驾护航。曾佳欣说，出海的中国企业选择云服务，将节省大量网络基础设施和运营成本。腾讯云副总裁王慧星也表示：希望通过更完善的海外服务节点、更优惠的价格，降低中国企业出海的成本，帮助中国企业在海外更快速地开展业务。
作为一家中国公司，要在海外建设数据中心，无疑会面临当地法律、政策等各方面的掣肘。腾讯云海外  高级运营经理李宇明介绍，腾讯的做法是选择合作，在每个海外数据中心点选择适合的数据提供商，将自己的需求以公开招标采购的形式进行发布。这种合作带来的结果是，腾讯云目前在海外新建  个数据中心耗时仅需  个月至  个月不等。
例如在德国，腾讯的数据中心提供商是 ，后者是欧洲领先的数据中心提供商，此外腾讯云在美国西部地区、新加坡、中国香港等地均选择和全球市值第一的数据中心提供商  合作。
数字文化产业出海需求迫切
腾讯云的海外业务增量主要来自互联网、游戏、金融、视频等行业，主要服务的客户分别是有出海需求的国内企业、海外入华企业和拓展全球业务的海外企业。曾佳欣认为，继第一波中国制造业出海热之后，强互联网属性的企业将成为第二波出海大军，这波热潮快速将中国云计算推向全球市场。
目前，腾讯云在海外业务中已经吸引了包括游族网络、绿洲游戏等一批龙头游戏企业，以及猎豹、快手、直播 、好未来、邢帅等视频直播平台，也聚集了 、、、 等海外知名公司。
记者查阅今年  月公布的腾讯去年第四季度财报发现，腾讯其他业务板块的收入同比增 ，该项增长主要由于腾讯的支付相关服务及云服务收入的增长。从全年来看，腾讯云在游戏及视频行业已成为行业领导者，这部分业务离不开腾讯云海外业务的快速增长。
凭借服务能力建立差异化优势
腾讯云的域名最近由改为了。曾佳欣认为，腾讯近几年来，正由一个相对封闭的闭环生态系统走向开放，国人对其的认知也不再仅仅是  和微信，腾讯的品牌影响力在海外要大过微信和 。
在海外，要和亚马逊、谷歌、微软等巨头公司进行直接竞争，来自深圳的腾讯，优势在哪里？
腾讯云方面透露，一是为企业提供更优质的基础设施，二是技术能力的开放。例如腾讯的优图实验室、腾讯自主研发的人脸识别技术等，这些技术能力将面向腾讯的合作对象进行全面开放。
李宇明则向记者举了一个这样的例子。一家中国数字文化内容公司去年进入美国开展业务，选择了一家硅谷著名科技公司提供的云服务，其数据存储在洛杉矶一处数据中心中。他们当时遇到非常多的问题，机器坏了没人帮修，网络出故障了没人处理，打电话过去客服也都是讲英文。李宇明说，这样的服务方式导致了该公司的产品宕机了好几天，这对于一家初创企业来说无疑是致命的打击。
跟出海企业进行合作，更核心的还是考验云的服务能力。曾佳欣表示，在腾讯云所有海外数据中心，不分节假日都会有驻场工程师  小时值班，只要有故障就能第一时间响应和解决。另外，相比一些国外巨头，腾讯在价格方面也有一定优势。
经过对海外市场的多年耕耘，腾讯云已经在全球化市场建立了自身的差异化优势。同时，腾讯云在为企业构建全球服务生态链，通过联合微信、、广点通等腾讯内部优势业务，为出海企业提供从流量、入口到云技术的一体化落地服务，降低出海企业上云的门槛。
：圈《大话  》系列文章通过通俗易懂的语言并结合基础实验，用最简单的描述来讲解  中的重要概念。让读者对分布式存储系统有一个清晰的理解。
引言
， ，中文翻译为归置组，在  中是一个很重要的概念，这篇文章将对  进行深入浅出的讲解。
  是什么？
就是目录！
我事先搭建了一个个 每个有个的集群，集群使用副本，_为。集群状态如下：
    
               
                                         
                                           
                              
                              
                              
                                           
                              
                             
                              
                                           
                              
                              
                             
每一个  都有一个 ，系统默认生成的  池的  号为 ，那么  池内的所有  都会以  开头，让我们看一下  下面的  目录的内容：
   
_   _  _  _  _  
省略部分内容
_  _  _  _  _
每个  的  目录下都保存了部分的 ，而  池的  则以 _ 的目录形式存在！
现在我们通过  向集群写入一个文件，在集群内保存名为  通过下面的指令查看该文件实际保存的位置：
      
                 
可见，文件会保存在 中，而这个位于中，之所以有这里有三个，是因为集群副本数为，可以在  这三个的下找到_目录。而同一份文件比如这里的  的三个副本会分别保存在这三个同名的中。
执行指令，将文件存入集群，并查看各个的目录内容：
        
 _   
_
     月    _____
     月    _____
 _   
_
     月    _____
     月    _____
 _   
_
     月    _____
     月    _____
可见，这三个  保存了这个文件的三个副本，这就是  的多副本的基础，将一份数据保存成多个副本，按照一定规则分布在各个中，而多副本的数据的一个特点就是，他们都保存在同名的  下面，也就是同名的目录下。这样，我们就对  有了一个直观的理解。
 想说爱你不容易
   是  的健康状态，然而  也会生病有的是小感冒，有的则可能是一级伤残，下面就是集群进入恢复状态时的一个截图，这里面聚集了各种老弱病残，现在就来分析下每种病症的原因
这里再次回忆下集群的配置： =  _ = 
、
降级：由上文可以得知，每个有三个副本，分别保存在不同的中，在非故障情况下，这个是 状态，那么，如果保存  这个  的  挂掉了，这个  是什么状态呢，操作如下：
     
===  === 
      
    _ | 
                    
这里我们前往  节点，手动停止了 ，然后查看此时   的状态，可见，它此刻的状态是当一个  所在的  挂掉之后，这个  就会进入 状态，而后面的的意义就是还有两个  的副本存活在  和  上。那么现在可以读取刚刚写入的那个文件吗？是可以正常读取的！
 _       
 _   

降级 就是在发生了一些故障比如挂掉之后， 将这个  上的所有  标记为 ，但是此时的集群还是可以正常读写数据的，降级的  只是相当于小感冒而已，并不是严重的问题，而另一个词 意思就是当前存活的  数为 ，小于副本数，将其做此标记，表明存货副本数不足，也不是严重的问题。
、
那么，什么才是的大病呢， 算是一个，刚刚我们关闭了，集群里还活着两个 ，现在我们关闭，查看下的状态：
 _    
===  === 
      
    _ | 
                    
可见，现在只剩下独苗苗活在 上了，并且  还多了一个状态：，英文的意思是仔细看，这里我们可以理解成协商、搜索，这时候读取文件，会发现指令会卡在那个地方一直不动，如此来解释_的作用，在  中，它的全名叫做 ____，这里大家就会问了，不是还活着一个呢吗，为什么就不能读取内容了，因为我们设置的 _= ，在  中的意义就是，如果存活数少于了，比如这里的  ，那么  就不会响应外部的请求。
在这里如果执行指令将 _ 设置为  
       _ 
    _ | 
                    
可以看到，没有了  状态，并且文件可以正常读写了，因为_=时，只要集群里面有一份副本活着，那就可以响应外部的请求。
，我们这里可以将它理解成它在等待其他兄弟姐妹上线，这里 _ = 也就是  和  的任意一个上线就可以去除这个状态了，处于  状态的  是不能响应外部的请求的，外部就会觉得被挂起。
、
 强大的自我恢复能力，是我们选择它的一个重要原因，在上面的试验中，我们关闭了两个 ，但是至少还有一个  存活在  上，如果那两个盘真的坏了， 还是可以将这份仅存的数据恢复到别的上的。
在  挂掉 分钟  ____ =  之后，这个  会被标记为  状态，可以理解为  认为这个  已经不属于集群了，然后就会把   到别的上去，这个  到哪些  上也是按照一定的算法计算得到的，重映射之后呢，就会在另外两个  上找到  这个 ，而这只是创建了这个目录而已，丢失的数据是要从仅存的上回填到新的上的，处于回填状态的就会被标记为。
所以当一个处于状态时，可以认为其处于自我克隆复制的自愈过程。
、 
这里我们先来做一个实验，首先开启所有  使得集群处于健康状态，然后前往  的  下面删除_____这个文件，再通知 扫描这个：
 _     _____ 
_
 _    
 _    | 
             
可见， 多了个  状态，顾名思义，发现了这个  的不一致状态，这样就可以理解这个  的意义了。
想要修复丢失的文件呢，只需要执行    ，就会从别的副本中将丢失的文件拷贝过来，这也是自愈的一个情形。
现在再假设一个情形，在  挂掉的过程中呢，我们对  文件进行了写操作，因为集群内还存在着两个副本，是可以正常写入的，但是  内的数据并没有得到更新，过了一会，上线了， 就发现，的文件是陈旧的，就通过别的  向  进行数据的恢复，使其数据为最新的，而这个恢复的过程中，就会被标记为 。
总结
至此，我们对  在磁盘的具体意义进行了分析，相信大家也对有了更深入的理解，同时，对常见的状态进行了剖析，今后看到了长长的病例单也不会有所畏惧了。最后，本文对  状态的解释都基于作者对 浅显的理解，如果有错误的地方，恳请指正！
大话系列文章
《大话》之那点事儿《大话 》之  那点事儿《大话  》之  那点事儿

本文来自： 公众号作者 | 张镇圳编辑 | 迷鹿

张镇圳，腾讯前端高级工程师，对内部系统前端建设有多年经验，喜欢钻研捣鼓各种前端组件和框架。

导语
前面写了一篇文章，叫《一个只有行代码的流程框架》，虽然该框架基本已经能实现一个流程正常的逻辑流转，但是在分模块应用下还是缺少一定的能力，无法将一个页面中的不同模块很好的连接在一起，于是对之前的框架进行了升级，新增了子流程的概念。
子流程
什么是子流程？在这个升级后的框架里当然代码已经不止行了，不要在乎标题，每个步骤不但可以是一个，还可以引用另一个流程，这个被引用的流程就叫子流程。先看个简单的例子：
{
    {
        步骤步骤步骤
        
    }
    步骤{
        
    }
    步骤{
                {
                        子步骤子步骤子步骤
                        
        }
        子步骤{
                        
        }
        子步骤{
            
        }
        子步骤{
                        
                }
    }
    步骤{
        执行 步骤
                                                                                    当前流程运行的轨迹：
                                                                                    
    }
}
上面这个例子中，步骤对应的对象就是子流程。
还可以有另一种写法，也是对分模块应用的更好的实现：
定义子流程
子流程 {
    {
        子步骤子步骤子步骤
        
    }
    子步骤{
        
    }
    子步骤{
        
    }
    子步骤{
        
    }
}
父流程
{
    {
        步骤步骤步骤
        
    }
    步骤{
        
    }
    步骤子流程
    步骤{
        执行 步骤
                当前流程运行的轨迹：
                
    }
}
可以看到，父流程的 步骤 引用了前面定义的 子流程，这样对于一些公共的流程逻辑就可以单独抽取出去作为子流程，被其他父流程引用。而子流程与父流程的交互，我们可以在代码中通过  来实现。
在子流程的每一步中都可以获取 ，得到的是当前子流程对应的步骤，这个步骤跟其他步骤一样也具有同样的详见上一篇文章《一个只有行代码的流程框架》对步骤的介绍。
另外，需要说明的一点：这次的升级，并没有对流程步骤的做改变，仅仅是引入了子流程的使用方式，其实就是定义子流程，然后引用子流程，接着就是父流程和子流程之间的交互。
同样，按照规矩，贴上例子的序号接上前篇文章的序号，从开始
最简单的子流程使用方法
{
    {
                执行 
        步骤步骤步骤
        
    }
    步骤{
        执行 步骤
        
    }
    步骤{
                {
                        执行 子步骤 
                        子步骤子步骤子步骤
                        
        }
        子步骤{
            执行 子步骤
            
        }
        子步骤{
            执行 子步骤
            上一步 ： 打印：子步骤
            当前步 ： 打印：子步骤
                        下一步 ： 打印：子步骤
                        
        }
        子步骤{
            执行 子步骤
            
        }
    }
    步骤{
        执行 步骤
                当前流程运行的轨迹：
                
    }
}
执行结果：

子流程和父流程 通过  进行交互
{
    {
                执行 
        步骤步骤步骤
        
    }
    步骤{
        执行 步骤
                {}
                {}
        
    }
    步骤{
                {
                        执行 子步骤 
                        子步骤子步骤子步骤
                        
                }
                子步骤{
                        执行 子步骤
                        {}
                        {}
                        
                }
                子步骤{
                        执行 子步骤
                        父步骤的上一步 ：打印：步骤
                        父步骤的步骤名 ：打印：步骤
                        父步骤的下一步 ：打印：步骤
                        父步骤的数据：
                        打印： { }
                        打印： { }
                        上一步 ：打印：子步骤
                        当前步 ：打印：子步骤
                        下一步 ：打印：子步骤
                        当前步的数据：
                        打印： { }
                        打印： { }
                        
                }
                子步骤{
                        执行 子步骤
                        {}
                        {}
                        
                }
    }
    步骤{
        执行 步骤
                打印： { }
                打印： {   }
                当前流程运行的轨迹：
                
    }
}
执行结果：

多个子流程并行执行
{
    {
                执行 
        步骤步骤 步骤步骤
        
    }
    步骤{
        执行 步骤
        
    }
    步骤{
                {
                        执行 子步骤 
                        子步骤子步骤子步骤
                        
        }
        子步骤{
                        执行 子步骤
                        
                }
                子步骤{
                        执行 子步骤
                        
                }
                子步骤{
                          = 
                        这里打印的时间和 子步骤 的时间一样
                        执行 子步骤 时间：   
                        {
                                
                        } 
                }
    }
    步骤{
                {
                        执行 子步骤 
                        子步骤子步骤子步骤
                        
                }
        子步骤{
                        执行 子步骤
                        
                }
                子步骤{
                        执行 子步骤
                        
                }
                子步骤{
                          = 
                        这里打印的时间和 子步骤 的时间一样
                        执行 子步骤 时间：   
                        {
                                
                        } 
                }
    }
    步骤{
        这里打印的时间比上面的子流程的时间晚秒，因为两个子流程是并行执行的
        执行 步骤 时间：   
                当前流程运行的轨迹：
                
    }
}
执行结果：

定义子流程和引用子流程
子流程 {
    {
        子步骤
    }
    子步骤{
        执行 子步骤
        当前步骤：打印：子步骤
        父步骤：打印：步骤
        
    }
}
子流程 {
    {
        执行 子步骤 
        子步骤子步骤子步骤
        
    }
    子步骤{
        执行 子步骤
        
    }
    子步骤{
        执行 子步骤
        
    }
    子步骤{
        执行 子步骤
        当前步骤：打印：子步骤
        父步骤：打印：步骤
        
    }
}
子流程 {
    {
        执行 子步骤 
        子步骤子步骤子步骤
        
    }
    子步骤{
        执行 子步骤
        
    }
    子步骤{
        执行 子步骤
        
    }
    子步骤{
        执行 子步骤
        当前步骤：打印：子步骤
        父步骤：打印：步骤
        
    }
}
{
    {
                执行 
        步骤步骤 步骤步骤
        
    }
    步骤子流程
    步骤子流程
    步骤子流程
    步骤{
                当前流程运行的轨迹：
                
    }
}
 执行结果：

从上面几个例子可以看到，子流程和父流程之间的信息交互非常简单，其实就是通过来获取到父步骤，通过父步骤来获取和传递数据，因此也能让这个流程框架拥有更大能力来适应更多的应用场景。
为了方便交流学习，上面例子完整代码可通过附件下载，最后同样贴上框架源码：机器学习最近大红大紫，既有这个契机为何不乘机好好学习一番。本文不是科普文，本人作为初学者也没有能力教别人，仅仅用此篇文章记录自己学习及尝试结合业务场景进行的一些实验过程。
机器学习与平时编程解决问题的区别
我们平时编程解决问题，主要是基于规则，而通过机器学习来解决问题是通过建立模型。

基于规则


我们通过经验或者智慧，主动发掘可以解决问题的规则也许就是一条条  语句，然后将许多规则结合在一起形成解决问题的方案。就比如图中判断垃圾邮件的过程，标题是否包含某种词……等就是明确的规则。这种方法修改起来非常方便，只要根据场景的演变，不断修正规则集。

基于模型


机器学习就是通过模型来解决问题，首先需要一堆数据假设为 ，然后通过某一种算法进行学习这里的某种算法多种多样，需要了解但不需要精通，毕竟不是专业人士，数据学习算法 就会产生一个模型模型这里我们认为是一个复杂的函数 。有了这个函数，当有新的数据来需要预测的时候，就代入函数得到函数的结果函数结果也即为问题结果。
这里有两个问题：
这个模型是由算法数据 训练产生的，而不是人工干预形成的，所以当你觉得模型不满意的时候，你没法直接调整模型，因为模型对于你来说是一个黑盒。你只能通过调整数据或者调整算法来间接调整模型，已达到优化解决方案的目的。所以有一个尴尬是，当你遇到一个新的问题场景，你想说像基于规则的程序那样，我们快点给模型加一个规则来修正模型以解决新问题吧，抱歉，臣妾做不到……必须重新训练模型。
通过模型计算出的结果往往不太好解释，不像规则产生的结果可追溯形成的过程，从而完成修正
机器学习问题类型
对问题进行分类，能够帮助我们更好的找到适合机器学习发挥的场景，一般有四大类型：

分类：在训练数据上建模，对于新样本，判断它的类别。如垃圾邮件识别中判断是否垃圾邮件二分类、 的入门教程手写数字识别多分类 等

回归：在训练数据上建模，对于新样本，判断它的标注值。标注值与分类问题不同，分类问题的标注是离散值，而回归问题中的标注是实数连续的。如股价预测、房价预测、监控曲线预测等

聚类：给出了一些相似度衡量标准，用来判断两个不同数据的相似程度，然后根据这些标准将数据进行划分。如在一堆未给出名字的照片中，自动的将同一个人的照片聚集到一块。

规则抽取 ：发现数据中属性之间的统计关系，而不只是预测一些事情。如啤酒和尿布的关系。商品推荐就是最典型的应用场景


然后，针对这些问题能够用来建立模型的算法更多，算法分类可以参考 机器学习算法概览
尝试的场景
运维的工作中，经常需要对重要的指标曲线进行观察，来判断系统是否正常  异常。这个场景广泛发生在包括监控告警、运营变更、容灾演练等情况下，但是通过一些固定阀值特定检测算法的方法并不能满足不断变化的情况。所以第一个尝试的场景就是：
根据某一指标曲线的历史数据判断当前未来数据点是否异常
在实践上述问题的过程中，发现因为机器学习毕竟是基于历史预测未来，如果历史本就没有值得学习的价值，那判断是否异常就会导致不可理解的结果就是某些指标图形效果不好，继而产生另一场景：

把指标曲线进行分类，把不同图形特征的指标曲线分成若干类，分而治之

指标曲线异常检测
提前想清楚的问题

数据有哪些？针对某一条指标曲线，假设是每一分钟为一个 ，那么一天就是  。又因为我们秒级监控的数据是保存两周，那么 × 个 

数据需要提取特征吗？常规的机器学习都需要通过专门设计、特征工程等方法来提取特征。直接怼原始数据这种适用于深度学习的方法，应该是基于海量数据，略过…

指标曲线异常检测是什么类型的问题？二分类问题，判断  是否异常

应该使用什么算法？因为数据本身并不具备标记，且通过设计方法来标记数据的成本也很高 太多，每个都要标记，所以只能采用无监督算法来建立模型

每一个指标曲线都建立一个唯一模型理论上，针对异常分类，每个指标曲线单独一个模型肯定是最优的，因为可以避免其他指标曲线的干扰。但是因为实时性、资源等实际情况，需要针对应用场景自己决定，此处单独建模。


特征提取
时序数据如何提取有关于异常检测的特征。采取的方法是：每个  单独提取特征向量可能变化  时间窗口为 。每个  提取特征的过程，是使用很多比较“流行”的异常检测器来完成。 经过每个检测器的提取之后，会得到一些被检查器量化过的，可以衡量数据异常程度的数值，称为 ，然后采各种不同的  组合形成  对应的特征向量。举例  的方法：

比如常见的正态分布的方法，假设某一时间点纵向上看，不同天但同时同分 的数据符合正太分布，即  个  符合正太分布，计算  个点的μ和σ，然后对于某个点  的 =|μ|  σ。另外其他能够预测指标曲线值的方法可以使用  = |预测值  实际值|    的方法来度量异常程度。

如下图所示的思想，把每一个  分别转换为不同的检测器产生的 。这样做的思考是，通过聚集不同检测器的能力，检测出不同情况下的异常，再通过机器学习来区分哪些是真正的异常点。经过转化之后有效的去除了时间、数值等带来的影响。

我们最终实现了的检测器包括：移动平均法、加权移动平均、时间序列分解法、差分、同环比、高斯分布、一次指数平滑、三次指数平滑、自回归积分华东平均 等
训练模型
训练模型，采用是  的  库来实现。经过对比和实验，选取的机器学习算法是无监督的分类异常检测算法 孤异森林。该算法的特点是：无监督、速度快、效果好已经有  同学在登录异常检测中尝试过。放一张某天  系统异常时某核心指标曲线的检测效果：

上图为当日异常曲线与昨日正常曲线对比图，下图为经过模型判断之后的图，红色表示判断为异常点。该模型已经尝试在一体化流程系统的上线验证模块使用。
指标曲线分类

曲线分类，同样是机器学习中典型的分类问题，而且针对这个问题已经有同学进行过尝试，可参考智能告警算法曲线识别模型。接下来简单描述下不同的地方：

特征的设计：采用了开源工程提取特征和人工设计特征相结合的方法，开源时序特征工程为  和 。因为开源特征较多，可以使用一个特征选择的方法，进行筛选之后使用，第一版本的模型，使用了  个特征。

标记的训练数据：并没有采用  的方法来形成标记数据，反而使用了人工标记的方法标记了  个不同的曲线，花了一天时间。之前也参考其他同学的方法先用  聚类打标，但是效果一直不太好，且聚类完成之后也要人工挑选确认样本，所以一不做二不休直接人工了，

监督分类算法：监督分类算法很多，比如 、、神经网络等。因为我们训练数据不多，最后采用的是随机森林


人工划分了  个类别：周期较光滑曲线、周期较粗糙曲线、类心跳曲线整体起伏不大，在某一个范围内反复上线跳动、类错误率曲线绝大部分情况为恒定值，比如 ，偶尔有异常突起或下陷。该模型在脚本大师上建立了一个体验任务，可是输入秒级监控的曲线体验分类。
总结
 特征很重要：”数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。“由此可见，特征工程尤其是特征选择在机器学习中占有相当重要的地位。在实践中，大部分时间也都花在了特征选择与提取上。怪不得深度学习如此火，跳过这步还是很伟大的，
 数据难获得：实践中，数据的获取，特别是有标记的数据获取，感觉是十分困难的。看似有很多数据，但是不知道怎么把看似大量数据变成问题所需要且能够使用的数据，还真是个世界难题
 应用场景难选取：想在运维实践中运用机器学习获得良好的效果，需要丰富的运维经验，又要深厚的机器学习功底。 世纪什么最重要？人才、人才、人才。好好学习把，童鞋们背景
对于经常和动画开发打交道的开发者对于这个动画库不会陌生，它把一些常见的动画效果都封装起来了，非常实用。但是有时候在开发中，仅仅只是需要某一两个动画效果，把整个文件都引入，这样不是太好。
需求就出现了，能不能有一个工具可以直接预览对应的动画效果，并且生成对应的动画代码呢？
作为一个开发，平时跟浏览器打交道最多，于是就整了一个插件可以及时预览对应中的动画效果并生成对应的动画代码，这样在实际开发中碰到一些需要使用到中的动画效果时，可以大大的提高我们的开发效率。
插件安装地址，快来安装体验吧！
作为一个程序员，捣鼓些小工具，不但可以学些新技术还可以提高我们的开发效率，何乐而不为呢。
下面就以一个简单的对齐预览的插件为例，讲讲使用开发插件的开发体验和效率。
扩展如下图所示：

并且还实时根据用户选择的对齐方式，显示对应的代码，方便我们可以直接拷贝代码使用。
插件开发基本知识
在应用商店中下载下来的插件基本上都是以为文件后缀，该文件其实就是一个压缩包，包括插件所需要的、、、图片资源等等文件。
开发一个插件就跟我们平时做开发流程没多大的区别，就是先搭好基本的页面，然后使用来写交互逻辑等功能。
比如我这个插件的目录文件如下：

文件
文件中需要注意一下的这个文件，这个文件的作用是提供插件的各种信息，例如插件能够做的事情，以及插件的文件配置等等信息。下面是一个清单文件的示例，
{
  _ 

    
          
   

   
    
  
  _ {
    _ 
    _ 
  }
}
第一行声明我们使用清单文件格式的版本 ，必须包含版本  是旧的，已弃用，不建议使用。
接下来的部分定义扩展程序的名称、描述与版本。这些都会在  浏览器中使用，向用户显示已安装的扩展程序，同时在  网上应用店中向潜在的新用户显示您的扩展程序。名称应该简练，描述不要比一句话左右还长后面将会有更多的空间用于更详细的描述。
最后一部分首先请求权限，用于访问  上的数据，并声明该扩展程序实现了一个浏览器按钮，同时在这一过程中为它指定一个默认图标与弹出窗口。
定义浏览器按钮时指向了两个资源文件： 与 。这两个资源都必须在扩展程序包中存在，图片是扩展的显示，是扩展具体运行的基础文件。
具体详细的开发教程可以看看官方的这个文档，非常简明的入门教程。
功能实现实践
整个插件的核心交互功能非常简单，如文章开头的动图所示，用户选择对齐方式，代码区域显示对应的代码。这种简单数据交互使用再适合不过了。
这里需要注意的一点是， 扩展的运行环境有一些特殊要求，称为    ，使得通常的  不能被正常使用。如果用的是  ，那么可以下载  版本，在 这里。如果是  版本，请参考官网文档的这一段。
核心代码如下所示。
：
 


   =
   引入样式 
   = =
     = =


     =
       =对齐就是这么简单
    
     =
       =
         =   =
          {{  }}
        
      
        {{  }} 
       =
         = =
           = 
              对齐
          
           = 
            对齐
          
           = 
            对齐
          
        
      
       =
         =
             =
               {{  }}
            
        
      
    
     先引入  
     =
     引入组件库 
     =


就不列出来了，可以在源代码中查看。
下面来使用来实现插件的功能。
功能实现
使用  指令根据一组数组的选项列表进行渲染。  指令需要以    形式的特殊语法，  是源数据数组并且  是数组元素迭代的别名。
而下拉框列表的渲染，就可以使用中的方法来渲染下拉列表选项，下拉选项数据写在中的对象中的中。用方法来绑定的值，代码如下所示：
 =
         =   =
          {{  }}
        

在中可以用  指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。这里在中使用方法来监听选中的值。
为了能预览不同对齐的效果，先在中写好和下拉框中值相同的对应的类名样式，这样当用户选中不同的值的时候能显示不同的效果。
 = =
           = 
              对齐
          
           = 
            对齐
          
           = 
            对齐
          

下拉框这块功能就这样，简简单单几行代码就实现了。想想要是用或者是原生的来实现同样的功能，不仅代码量要大而且写起来也没有这么舒服。
接下来是代码同步功能，即在代码区域显示对应对齐的代码。
开始之前先讲讲中的属性方法，可计算属性   就是不存在于原始数据中，而是在运行时实时计算出来的属性。
对应到我们这个实例，就是当用户选择不同的对齐方式的时候，及时同步对应的代码到代码预览区域。简单起见，直接把几个不同的代码写到中：
 {
         
        {
              \\ \\ \\ 
              \\ \\ \\ 
              \\ \\ \\ 
        }
         
          {  居中对齐  }
          {  两端对齐  }
          {  间隔相等  }
        
    }
根据不同的名字对应不同的代码。然后使用方法来根据用户选取的值实时取出对应的代码：
{
        {
            
             
        }
    }
完整代码如下：
  =  {
       
       {
         
        {
              \\ \\ \\ 
              \\ \\ \\ 
              \\ \\ \\ 
        }
         
          {  居中对齐  }
          {  两端对齐  }
          {  间隔相等  }
        
    }
    {
        {
            
             
        }
    }
}
最后在中绑定通过方法得到数据也就是：
 =
         =
             =
               {{  }}  
            
        
      
开发好之后，可以直接在中运行来调试。打开扩展面板，勾选开发者模式，然后加载刚开发扩展所在的目录就可以直接运行了。

完整的源代码已上传在附件，可以下下来直接运行。
一个简单的插件就完成了，通过这一个简单的插件就可以体验到在开发中简单、优雅的魅力，还有什么理由不用起来呢。作者：

 全称为：  。它是为了解决  端无法捕获音视频的能力，并且提供了 就是浏览器间的视频交互。实际上，细分看来，它包含三个部分：

捕获音视频流
传输音视频流一般用在  的场景
 用来上传音视频二进制数据一般用到流的上传

但通常， 的场景实际上应用不大。对比与去年火起来的直播业务，这应该才是  常常应用到的地方。那么对应于  直播来说，我们通常需要两个端：

主播端：录制并上传视频
观众端：下载并观看视频

这里，我就不谈观众端了，后面另写一篇文章介绍因为，这是在是太多了。这里，主要谈一下会用到  的主播端。简化一下，主播端应用技术简单可以分为：录制视频，上传视频。大家先记住这两个目标，后面我们会通过  来实现这两个目标。
 基本了解
 主要由两个组织来制定。

      组织：定义浏览器 
      标准组织：定义其所需的协议，数据，安全性等手段。

当然，我们初级目标是先关心基本浏览器定义的  是啥？以及怎么使用？然后，后期目标是学习期内部的相关协议，数据格式等。这样循序渐进来，比较适合我们的学习。
 对于音视频的处理，主要是交给   处理的。处理过程为：


音频：通过物理设备进行捕获。然后开始进行降噪，消除回音，抖动丢包隐藏，编码。
视频：通过物理设备进行捕获。然后开始进行图像增强，同步，抖动丢包隐藏，编码。

最后通过   暴露给上层  使用。也就是说  是连接   和底层物理流的中间层。所以，为了下面更好的理解，这里我们先对  做一些简单的介绍。

是作为一个辅助对象存在的。它承载了音视频流的筛选，录制权限的获取等。 由两部分构成：  和 。

 代表一种单类型数据流。如果你用过会声会影的话，应该对轨道这个词不陌生。通俗来讲，你可以认为两者就是等价的。
 是一个完整的音视频流。它可以包含 = 个 。它主要的作用就是确保几个轨道是同时播放的。例如，声音需要和视频画面同步。

这里，我们不说太深，讲讲基本的  对象即可。通常，我们使用实例化一个  对象，就可以得到一个对象。
 里面还需要传递 ，或者其他  作为参数。
 这里只为演示方便
  =  
我们可以看一下  上面带有哪些对象属性：

表示当前  是否是活跃状态就是可播放状态。
 对当前的  进行唯一标识。例如：
 当  为  时，触发该事件
 当有新的  添加时，触发该事件
 当  为  时，触发该事件
 当有  移除时，触发该事件

它的原型链上还挂在了其他方法，我挑几个重要的说一下。

 对当前的  流克隆一份。该方法通常用于对该  流有操作时，常常会用到。

前面说了， 还可以其他筛选的作用，那么它是如何做到的呢？在  中，还有一个重要的概念叫做 。它是用来规范当前采集的数据是否符合需要。因为，我们采集视频时，不同的设备有不同的参数设置。常用的为：
{
        是否捕获音频
     {   视频相关设置
         {
               当前视频的最小宽度
              
        }
         {
               最小高度
             
        }
         {
               最小帧率
              
        }
    }
}
那我怎么知道我的设备支持的哪些属性的调优呢？这里，可以直接使用  来获取可以调优的相关属性。不过，这一般是对  进行设置。了解了  之后，我们就要开始真正接触  的相关 。我们先来看一下  基本。
 的常用  如下，不过由于浏览器的缘故，需要加上对应的 
                               

                  
        
      
                  
不过，你可以简单的使用下列的方法来解决。不过嫌麻烦的可以使用  来弥补
 =  ||  || 
这里，我们循序渐进的来学习。如果想进行视频的相关交互，首先应该是捕获音视频。
捕获音视频
在  中捕获音视频，只需要使用到一个 ，即，。代码其实很简单：
 =  ||
     || 

  = {  设置捕获的音视频设置
   
   
}

  = 

  {
   =   这就是上面提到的  实例
    {
     =   用来创建  可以播放的 
  }  {
     = 
  }
}

  {
     
}
 这是  的基本格式
  
详细  可以参考：。不过，上面的写法比较古老，如果使用  来的话， 可以写为：

    
上面的注释大概已经说清楚基本的内容。需要提醒的是，你在捕获视频的同时，一定要清楚自己需要捕获的相关参数。
有了自己的视频之后，那如何与其他人共享这个视频呢？可以理解为直播的方式在  中，提供了  的方式，来帮助我们快速建立起连接。不过，这仅仅只是建立起  的中间一环。这里包含了一些复杂的过程和额外的协议，我们一步一步的来看下。
 基本内容
 利用的是  方式来进行传输视频包。这样做的好处是延迟性低，不用过度关注包的顺序。不过， 仅仅只是作为一个传输层协议而已。 还需要解决很多问题

遍历  层，找到指定的 
双方进行基本信息的协商以便双方都能正常播放视频
在传输时，还需要保证信息安全性

整个架构如下：

上面那些协议，例如， 等，我们后面会慢慢讲解。先来看一下，两者是如何进行信息协商的，通常这一阶段，我们叫做 。
 任务
 实际上是一个协商过程。因为，两端进不进行  视频交流之间，需要知道一些基本信息。

打开关闭连接的指令
视频信息，比如解码器，解码器的设置，带宽，以及视频的格式等。
关键数据，相当于  中的   用来确保安全连接。
网关信息，比如双方的 ，

不过， 这个过程并不是写死的，即，不管你用哪种协议，只要能确保安全即可。为什么呢？因为，不同的应用有着其本身最适合的协商方法。比如：

单网关协议适用于呼叫机制，  。
自定义协议
多网关协议


我们自己也可以模拟出一个  通道。它的原理就是将信息进行传输而已，通常为了方便，我们可以直接使用  来建立  提供信息交流的通道。
 的建立
假定，我们现在已经通过  建立起了一个信息交流的通道。那么我们接下来就可以进入  一节，进行连接的建立。我们首先应该利用  进行基本信息的交换。那这些信息有哪些呢？ 已经在底层帮我们做了这些事情    。我们利用  传递相关的 ，来确保双方都能正确匹配，底层引擎会自动解析  是  帮的忙，而不需要我们手动进行解析，突然感觉世界好美妙。。。我们来看一下怎么传递。
 利用已经创建好的通道。
  =   
 正式进入  。这相当于创建了一个  端。
  =  {} 

{   }


  {
   
   通过  来生成本地的 
   { 
     
     
  }
}

  {  }
那  的具体格式是啥呢？看一下格式就 ，这不用过多了解：
=
=     
=
= 
=  
= 
=               
=  
=   
=
=
= 
=
=
= 
=
=

上面的过程，就是  的协商流程。这里有两个基本的概念，，。

 主播端向其他用户提供其本省视频直播的基本信息
 用户端反馈给主播端，检查能否正常播放

具体过程为：


主播端通过  生成  描述
主播通过 ，设置本地的描述信息
主播将   发送给用户
用户通过 ，设置远端的描述信息
用户通过  创建出自己的  描述
用户通过 ，设置本地的描述信息
用户将   发送给主播
主播通过 ，设置远端的描述信息。

不过，上面只是简单确立了两端的连接信息而已，还没有涉及到视频信息的传输，也就是说  传输。 传输本来就是一个非常让人蛋疼的活，如果是  的模型话还好，直接传就可以了，但这偏偏是  的模型。想想，你现在是要把你的电脑当做一个服务器使用，中间还需要经历如果突破防火墙，如果找到端口，如何跨网段进行？所以，这里我们就需要额外的协议，即， ，来帮助我们完成这样的传输任务。

在  传输中，我们不可避免的会遇见   服务器。即，它主要是将其它网段的消息传递给它负责网段内的机器。不过，我们的  包在传递时，一般只会带上  的 。如果，此时你没有目标机器的  的话，那么该次  包将不会被转发成功。不过，如果你是  的形式的话，就不会遇见这样的问题。但，这里我们是  的方式进行传输，无法避免的会遇见这样的问题。

为了解决这样的问题，我们就需要建立  的连接。那办法是什么呢？很简单，就是在中间设立一个  用来保留目标机器在  中的 。常用协议有   和 。那他们有什么区别吗？

：作为最基本的   服务器，保留指定机器的 
：当  出错的时候，作为重试服务器的存在。
：在众多    服务器中，选择最有效的传递通道。

所以，上面三者通常是结合在一起使用的。它们在  中的角色如下图：

如果，涉及到  的话，我们在实例化   时，还需要预先设置好指定的  服务器。
  = { 
     { } 
       一般需要自己去定义
     {
       =
       =
       
    }
    {
       =
       =
       
    }
}

  =  
  =    在实例化   时完成。

{   }  

  {
    将流添加到  中。

   {
     
  }
}

 通过 ，监听是否有用户连接
 =  {
    ==  { 
       {
              
         
      }
  }
}

在  处理中，里面还分为  和 。在代码中反应的就是：
   =  {
    
    

  }
   =  {
    
    
  }
当然，起主要作用的还是 。

 用来检测本地  的状态。其有以下三种状态：
 该  刚刚被创建
  正在收集本地的 
  完成本地  的收集


 用来检测远端  的状态。远端的状态比较复杂，一共有  种 

不过，这里为了更好的讲解  建立连接的基本过程。我们使用单页的连接来模拟一下。现在假设，有两个用户，一个是 ，一个是 。 捕获视频，然后， 建立与  的连接，完成伪直播的效果。直接看代码吧：
    = 
              
   =  =  
   监听是否有新的  加入
   =  {
     
  }
              
   =  =  
   =  {
     
  }
   =  {
     
  }
   =  {
     
  }
   一旦  添加成功，则将  播放
   = 
    作为播放端，先将  加入到  当中。
  

  
    
  
    
    
  

  {
    就是  的数据
  
     {
      
    }
    
  
    

   省去了  的发送通道
  
     {
      
    }
    
  
    
  
    
    
  
}
看上面的代码，大家估计有点迷茫，来点实的，大家可以参考 单页直播。在查看该网页的时候，可以打开控制台观察具体进行的流程。会发现一个现象，即， 会在  协商还未完成之前就已经开始，这也是，该  设计的一些不合理之处，所以， 已经将该  移除标准。不过，对于目前来说，问题不大，因为仅仅只是作为演示使用。整个流程我们一步一步来讲解下。

  
     的  
     的 
   
     的  
     的  
     的 
     的 
   ，此时，接收端已经可以播放视频。接着，触发  的  监听事件。获得远端的  ，注意此时  的  协商还未完成。
此时，本地的   的状态已经改变，触发  。开始通过  方法将  添加进去。
     的 
     的 
  。 添加成功
触发  检查  远端  的状态。当为  状态时，则会触发   事件。
  。

此外，还有另外一个概念， 我这里就不过多涉及了。如果有兴趣的可以参阅  性能优化 进行深入的学习。

原文链接：


相关推荐【腾讯云的种玩法】  整合微视频上传管理能力，轻松打造视频后台如何用腾讯云打造一款微视频 是一个全球范围的测速网站。一些大型的主机商会使用它来进行测试，当然，在某些时候，我们自己也有需要，需要对自己的服务器进行测试。今天我就来教你在自己的服务器上配置  。
系统需求

云主机
  操作系统
 链接软件

安装  
首先登陆到云主机上。
然后执行命令，安装 
   

接下来，安装相关的组件
      

下载 
执行命令，下载安装包
 

然后解压安装包，并放在  的  目录下
 
  
   

执行完成上述命令后，我们来修改  的代码文件
 
  

启动
执行命令，启动
  

访问测试页面
使用浏览器，打开 服务器页面，就可以看到的测试页面了


相关推荐
腾讯云主机上测试编译
免费体验云服务器，提供最佳上云实践机会
【腾讯云的种玩法】搭建属于自己的服务器导语
相信大家跟我一样，偶尔会疑惑：曾经年少的时候学习过的那么多的复杂的数学函数，牛逼的化学方程式，各种物理原理、公式，到底有什么用？但事实是，我们所学习过的东西，虽然很多不能够准确地记得全部，但已经潜移默化地影响到我们的思维模式，很多时候给我们解决一些工作、甚至是生活中的问题，提供了建模的方案，比如，在实现某个需求的时候需要做动画衰减，可能就能够通过匀减速运动公式去实现，再比如，本文所要介绍这个案例，整个实现过程其实并没有多么难多么复杂，但从实际问题到模型建立的思维推导过程，笔者认为还是很有意思也很有意义的，所以，也希望能够分享给大家。
一、        背景问题
有个需求是要将每日消费数据以柱状图形式呈现，我们有追求的设计师希望柱子高度在超过某个限额设为时不再正比增长，而是越来越缓慢地增长，目的是使柱子高度不会出现有些特别高，有些特别矮的情况，那么，要怎么才能够实现这个需求呢？下面将介绍对于这个问题的思路梳理及实现过程。
二、        思路梳理
      模型建立：
首先，回到最初目标：使柱子在超过之后，高度增长速度越来越慢。也就是说，在消费金额小于等于时，柱子高度成正比增长；大于时，大于的部分，所占高度随着值的增加增长速度越来越慢。其次，整个柱状图的高度是一定的设为，毋庸置疑，最大的消费金额值设为的柱子高度就是。然后我们对于值的柱子的高度设定为。这样，这个问题最终就转换成这样的模型：

其中就是超过的部分的高度在 – 中所占的比例，要求值随消费金额值的增加而增加；增加速度逐渐趋缓；值的变化区间是；
那么，根据这个模型，我们需要确定的有以下三个值：值如何取；值如何取；值的计算方法如何确定。这里和值可能需要根据业务不同要求等来具体确定，并且在整个程序的生命周期内，不会发生变化，我们下面主要讨论值的计算方法。
      值的函数设计：
根据中的模型对值的要求，最先想到了渐进函数，最简单的渐进函数 =  函数图如下：

在时，值随值增加而越来越小，并且减小速度逐渐趋缓，最后无限趋近于
 = 

在时，值随增加而越来越大，并且增长速度逐渐趋缓，最后无限趋近于。这个函数变化趋势已经跟我们所要的效果很像了，区别在于：我们要求从开始逐渐趋近于，继续改造
 =  – 

 =  – 

当时，从开始逐渐增加，并且增长速度逐渐趋缓，最终趋近于，这就是我们要的效果了。
      应用于实际场景：
中所得函数式运用于中模型，就是，就是，那么，也就是说当=是， =  =时， = 。那么在实际该消费数据的场景下，相当于高于值块的消费金额就占了部分的一半高度，之后随着值继续增加，其高度的增加范围只是部分的一半，显然是不合理的，因此这里函数式要进一步加参数调整，调整为： =     = ，这样，当 = 时，的高度就是  。
到这里中模型就变为：

接着，就剩下确定  的取值如何确定的问题了，通过实验，最终选用了是某个月份的消费日均值设为，是整个柱状图高度的，是的一半。这样，这个模型就具体化为：

化解为：

将一个实际例子套用到该模型中，月份总消费金额是元，该月日均消费金额是元，假定 = ，整体函数示意图如下所示：

可以看出这是完全符合我们最初设计要求的：在消费金额小于等于日均消费金额值时，柱子高度随金额值增加成正比增长；之后，随着消费金额值的增加，柱子高度仍然不断增长，但增高幅度越来越缓慢，最终无限趋近于柱状图总高度。
三、        实现效果：
最终实现效果如下

完美！导语
在前后端分离框架中， 文档频繁交接。如果涉及到第三方接口调用，多方合作场景下， 和文档变更可能会更快。为了方便维护  和交接文档，这里给大家推荐一款文档生成工具  。
 简介
 是一个基于  的  文档生成工具，从代码注释中提取特定格式的内容，生成  文档。
目前支持的语言有：、 、、、、、、、、、、、、、 和 。
特点：

跨平台，、、 等都支持。
支持语言广泛。
支持文档版本管理。
支持多个不同语言的多个项目生成一份文档。
输出模板可自定义。

举个例子
以  为例，在  函数中写注释
    
     
     {}  获取应用详情  
       
     获取应用详情  
       
       
      请求成功  
        
    {  
           
           
           
         成功说明  
    }  
     {}    
     {}   数据列表  
     {}    
     {}  说明         
      
生成的  文档

 支持的关键字
 通过抽取代码注释，根据关键字语法生成  文档。所以，如果想生成理想的  文档，一定要遵循  的相关关键字语法。下面是一个关键字语法的 ，{ }表示需要替换的变量， 表示可选参数：

 {}  。只有使用 标注的注释块才会在解析之后生成文档， 会被解析为导航菜单 下的小菜单 可以有空格，如{ }

 。分组名称，被解析为导航栏菜单

 。接口名称，在同一个 下，名称相同的 通过 区分，否者后面 会覆盖前面定义的

 。接口描述，支持  语法

 。接口版本， 的形式

 。 会忽略使用 标注的接口， 为描述

 。接口测试地址以供测试，发送请求时，  必须为  等其中一种

   。定义一个注释块不包含，配合 使用可以引入注释块在 内部不可以使用

 。引入一个 的注释块

  {} = 。请求参数

  {} = 。头部参数

  {}  。响应错误时参数

  {}  。成功时参数， 表示参数的分组， 表示类型不能有空格，入参可以定义默认值不能有空格

 {}  。参数请求用例

 {}  。头部请求用例

 {}  。错误请求用例

 {}  。成功请求用例 表示的是  的语言类型，  内容会被直接解析显示。

 。 必须独一无二，描述 的访问权限，如 


安装配置 

安装 

这里默认已经安装了 ，如果没有安装，请自行下载安装。全局安装    
          

配置

配置是可选的，没有配置并不影响文档的生成。只是缺失部分  文档信息而已。在工程的根目录下，创建  文件，配置文档的基本信息 
{  
 项目  文档  
   
 项目  文档说明  
 项目  文档  
}     

生成文档

在  所在的目录下，执行命令：
    
 参数表示输入的目录，默认生成的文档在当前目录下的，也可以通过 参数指定。
 自动生成
每次更新代码注释之后，执行一次  才能看到  文档，比较麻烦。能不能每次修改注释之后，自动生成  文档呢？当然可以。

安装 

 是基于  的文件监控项目。
      

编写监控代码


  =   
  = _  

 {  
    {  
   {  
          
          
      }  
    }  
}  

 {  
  =   _  
       {  
生成      
    }  

       {  
生成出错     
    }  
}  

  
  
正在监听  

执行监控

只需要更新注释之前，执行一次命令即可。
   
项目实践建议
 文档的交接方式
建议将  文档生成在前端的  目录下，以链接的形式交接，比如 。
 后端注释组织方式
以  为例，由于  需要的注释量比较大，有两种选择：

一种是将注释直接写在每个  函数中，
一种是单独使用一个文件或文件夹来写注释。

 中建议   ， 中少些代码，多写注释，第一种方案比较合适。同时，注释和接口实现放在一起，可以降低二次维护学习成本。
 使用  和 
由于前后端，常常会约定固定格式的返回。可以将格式固定的部分，使用  定义为一个注释块，在其他地方使用  引用。可以有效减少注释量。
定义注释块，注意：一个注释块应该被定义为一个单独的注释：
  
   
  请求成功  
    
{  
       
       
       
     成功说明  
}  
 {}    
 {}   数据列表  
 {}    
 {}  说明    
  

  
   
  请求失败  
     
{  
       
       
       
     失败提示  
}  
 {}    
 {}   空  
 {}   错误码  
 {}  提示   
      
其他地方引用   
    
     
     {}  获取应用详情  
       
     获取应用详情  
       
       
       
      
 合理使用  分组
、 会被拼接到  中，比如：。给 、 取个容易理解的名字很重要。合理使用 ，将前端相关的功能聚集在一起，有利于前端理解  的用途。
参考



为了满足日益增长的业务变化，京东的京麦团队在京东大数据平台的基础上，采用了等热门的开源大数据计算引擎，打造了一款为京东运营和产品提供决策性的数据类产品北斗平台。
一、的应用业务分析
大数据是不能用传统的计算技术处理的大型数据集的集合。它不是一个单一的技术或工具，而是涉及的业务和技术的许多领域。
目前主流的三大分布式计算系统分别为、和：
当前大数据管理标准之一，运用在当前很多商业应用系统。可以轻松地集成结构化、半结构化甚至非结构化数据集。
采用了内存计算。从多迭代批处理出发，允许将数据载入内存作反复查询，此外还融合数据仓库，流处理和图形计算等多种计算范式。构建在上，能与很好的结合。它的是一个很大的特点。
用于处理高速、大型数据流的分布式实时计算系统。为添加了可靠的实时数据处理功能
是使用编写，允许分布在集群，使用简单的编程模型的计算机大型数据集处理的的开源框架。 框架应用工程提供跨计算机集群的分布式存储和计算的环境。 是专为从单一服务器到上千台机器扩展，每个机器都可以提供本地计算和存储。
适用于海量数据、离线数据和负责数据，应用场景如下：
场景：数据分析，如京东海量日志分析，京东商品推荐，京东用户行为分析
场景：离线计算，异构计算分布式计算天文计算
场景：海量数据存储，如京东的存储集群
基于京麦业务三个实用场景
京麦用户分析
京麦流量分析
京麦订单分析
都属于离线数据，决定采用作为京麦数据类产品的数据计算引擎，后续会根据业务的发展，会增加等流式计算的计算引擎，下图是京麦的北斗系统架构图：图一京东北斗系统
二、浅谈的基本原理
分布式处理框架核心设计
 ：   分布式文件系统
： 是一种计算模型及软件架构
 
  ，是的分布式文件存储系统。
将大文件分解为多个，每个保存多个副本。提供容错机制，副本丢失或者宕机时自动恢复。默认每个保存个副本，为个。将按照映射到内存当中。图二数据写入
图三读取数据
 
是一个编程模型，封装了并行计算、容错、数据分布、负载均衡等细节问题。实现最开始是映射，将操作映射到集合中的每个文档，然后按照产生的键进行分组，并将产生的键值组成列表放到对应的键中。化简则是把列表中的值化简成一个单值，这个值被返回，然后再次进行键分组，直到每个键的列表只有一个值为止。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。但如果你要我再通俗点介绍，那么，说白了，的原理就是一个分治算法。
算法：
计划分三个阶段执行，即映射阶段，阶段，并减少阶段。
映射阶段：映射或映射器的工作是处理输入数据。一般输入数据是在文件或目录的形式，并且被存储在的文件系统。输入文件被传递到由线映射器功能线路。映射器处理该数据，并创建数据的若干小块。
减少阶段：这个阶段是：阶段和阶段的组合。减速器的工作是处理该来自映射器中的数据。处理之后，它产生一组新的输出，这将被存储在。图四
 
是基于的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供完整的查询功能，可以将语句转换为任务进行运行，这套 简称。使不熟悉 的用户很方便的利用 语言查询，汇总，分析数据。而开发人员可以把己写的 和 作为插件来支持 做更复杂的数据分析。图五体系架构图 
由上图可知，和是架构的根基。架构包括如下组件：  、、 、 、和、和。 
三、走过来的那些坑
进行操作的时候，写的不当，容易造成数据倾斜，大致分为这么几类：空值数据倾斜、不同数据类型关联产生数据倾斜和的数据偏斜。只有理解了的原理，熟练使用，就会避免数据倾斜，提高查询效率。
本文出处：前言
随着今年深度学习的热潮的来临，神经网络已经被应用在越来越多的应用中。而在印象中对于神经网络进行训练的往往需要借助大量的计算资源与数据。其实通过一定的方法，配合预训练好的网络，我们完全可以在自己的上训练出一个准确率较高、实用性也非常不错的网络。下面我就以上的一个竞赛为例，带领各位司机训练一个对驾驶行为进行分类的网络。
首先我们了解一下需要解决的问题 我们有一位老司机，可惜开车时不太专心，一会儿喝饮料一会儿打电话又或是在玩手机， 并在驾驶过程中不断的变化着自己的姿势。碰到这样的老司机，我们有没有办法提醒他安全驾驶呢？
设想如果我们能在他的汽车上装上一枚摄像头，并通过实时图片采集他的行为。最终通过神经网络分析他的动作行为，善意的提醒他安全驾驶的姿势。
这看起来是不是很酷 装上摄像头的汽车采集到的数据，就像下图这样

接着这一问题转换成了神经网络，即对种类型的图片进行分类预测的问题，这种行为分别是

正常开车 

右手玩手机

右手打电话

左手玩手机

左手打电话 

操作收音机

喝东西

向后伸手

化妆

说话



而训练数据所需要用的数据库，大家可以在网页上自行下载，这里是网址 
 训练准备
 下载训练数据
了解了问题之后，我们开始准备我们的训练数据。 第一份数据可以在网站上下载到。在下面图中的这个页面中，我们只需要下载这个的文件即可。

下载完成之后，我们将这个包解开，将看到下面这样的目录结构

└── 
    ├──
    │   ├── _
    │   ├── _
    │   ├── 
    ├──
    ├──
    ├──    
└── 
    ├──
    ├──
    ├──
    ├──
稍微解释一下，目录是给我们训练用的目录，里面一共有到十个分类，对应我们刚刚列出的 正常开车 右手玩手机 右手打电话 等十种行为。在这个训练集中一共包含张图片。
而目录是给我们校验的目录，也同样是到十个分类，但它只有张图片，主要的作用是用对训练好的神经网络进行校验，稍后我们也会用到它。
 自己拍摄数据
由于训练数据比较少，加上 死磕自己，娱乐大家 的的精神，作为老司机我也上“车”试上一把。
纯手工打造一台“汽车”并参与到训练中去并不难，而所需要的东西如下


就这样不停的变换姿势，一共拍摄了张不同姿势的开车照片，并依照不同的类别放置在刚刚的的目录对应的分类中。同时也放少量的照片到目录中，注意要保证和目录中的照片不重复。
 产生更多数据
最后，如果数据还觉得不够的话，我们可以对数据再做一次 ，这样可以产生更多的训练数据。
比如对同一张照片做颜色和角度偏移就可以得到多张不同的照片，如下图所示，这些照片对训练也是相当有帮助的。

好啦万事俱备，各位老司机坐好了，我们马上准备开车了
 开始训练
 迁移学习
终于到了训练的步骤，问题是我们手头上只有一台普通的开发机器 内存，。比起各大云服务器上动辄几百几十个核心的服务器，需要通过这样一台机器训练一个稍显复杂的网络真的是有点难堪。
所以这里向各位老司机推荐迁移学习中的一个小，名曰 。关于的更详细的步骤大家可以在这里得到配有源码   
而这里提到的如果总结一下的话，主要原理可以理解成如下三步骤
 首先我们需要获得一个预先训练好的网络，如下图中的网络。
 我们将网络中的后三个全连接层去掉，只留下前面的卷基层和层。
 加入新的全连接层， 冻结之前所有层，仅仅训练新加入的全链接层。

了解了基本原理之后，我们开始根据自己的实际做 。注意，这里我们要处理的是一个十分类问题，也就是说，我们的网络最后要有个输出。所以我大概做了这样一个包含一个隐藏层的全连接网络，附加到的末端
      上接  
      一个隐藏层
       输出个分类
 训练网络
之后我们将的前面层冻结，开始训练后面的三层。冻结网络层，其权重值在训练过程中不会发生任何变化。

有了之前的工作，这个训练就变得和普通全连接网络的训练过程完全一样了。
在我的   上用了个小时， 一共跑了个，每个将我们准备好的张照片作为输入。学习速率我这里设置到这样一个数值，
最终函数值稳定在。看到函数呈现如下图中基本上不下降了之后，即可以结束训练了。

 检验结果
 简单预测
 ，进过漫长的等待。我们终于可以使用这个网络了 现在开始使用刚刚数据库中的校验集，也就是目录中的图片。先简单的传入张图片看看网络的预测结果呗。这张图片的正确类型的动作行为编号分别是         。而网络输出的结果是         。貌似还不错，只是有点小错误。如下是正确结果和预测结果的比较
           
           
如果将结果用输出出来的话会更加直观。如下图是输入网络的个照片，每张图片的标题是预测结果，发现只有红框中的那一张出现了预测错误的问题。

我们再尝试对 数据库中的照片做一下分类，张照片中同样发生了一个错误的预测红框内为错误的预测

 结果分析
那是不是我们可以认为网络的准确率在呢？网络最容易出现错误的预测是哪几类图片呢？
对于这两个问题，尝试对所有的校验集数据做一个预测，并将最终的结果打印成一个_就会有答案了。在这个矩阵中，用每一行表示神经网络预测的结果，每一列表示正确的结果。输出以后它是这个样子的
_
                                 
                                   
                                  
                                  
                                   
                                  
                                 
                                  
                                  
                                  

分析一下， 我们可以将对角线上的所有数据加起来，得到网络的准确率是。
再具体一点，可以看出最难区分清楚的是左手玩手机、 左手打电话 ，后续如果增加、这两个分类的话，那么网络的准确率还有更大的提升。
 结语
通过整个实验过程，我们发现通过神经网络解决复杂图片的分类问题并不复杂，只需要通过一些小的技巧，训练网络的计算资源也并非很大。的正确率这一结果也还比较理想
最后我把本文中用到的一些重要的资料再列举一下，原文、源码、数据都在了，各位老司是不是跃跃欲试了 
    
    
  
本文发表于，转载请联系作者获得授权。前面我们已经发过一篇介绍  泛型的文章了，相比大家对于泛型已经有了较为深刻的理解。这块儿内容的重点和难点是对于型变的理解，而我们今天就要给大家展示一段有坑的代码。本文需要你对泛型和反射有相对深入的了解，反正。。阅读过程中有任何不适，本人概不负责。：逃
 有坑自远方来。。
话说呀，我们有一个很简单的需求，就是为很多个类添加一个  方法，这个方法的返回值就是这个类的属性名以及值，例如下面这个类：
      

它的  方法的返回值应该是这样：
  
这个东西很通用，于是我们决定用扩展方法加反射的方式来输出，于是：
      
        = 
         {
            {} {}
        }
         = 

看上去很美是吧，不过呢，这段代码是编译不过的！为什么？ 这一句看上去很合理， 是一个属性的反射引用，通过  传入调用者  来获取当前属性的值，很正常嘛，我们在  中都是这么干的呀。然而，并没有什么用，这里就是报错。
 坑亦有理
那我们就来分析下吧，报错的原因也很简单，编译器说  的类型是 ，而  需要的参数类型是  ，什么鬼，这里居然还有协变的事儿？？
本着息事宁人的态度，类型不匹配我强转下不就得啦
     错误的！！

可问题是你老人家仔细瞅瞅，协变类型强转的事儿，真是没听说过
这就有意思了，我明明用的是  的实例，怎么后面的属性的泛型参数是  ？我们看下下面的属性的反射引用类型的定义也就是  的类型：
          { 

        

    
}

 的类型从哪儿来的呢？当然是从获取反射引用的  对象来的，也就是  这个对象了，这个对象难道不应该是  吗？，是  ！看上去有点儿不可思议，不过仔细想想，这样是否有道理呢？
   =  

对于这样的情况， 如果返回的是 ，那么在后续的反射访问属性的操作中，我们将什么都得不到，毕竟  什么属性都没有。可这不对呀， 不应该拿到的是对象真实的类型吗？没错，为了照顾到这一点，又不让类型系统出错，  选择将   的类型置为   来解决问题。
其实  也有类似的操作，请看文章：中方法的返回值类型
 相当于  的 ，尽管这个方法的签名是这样的：
   

但这个返回值实际上是协变的：
    = 

不过  毕竟与  不一样，它的反射传参要求非常简单，没有严格的类型限制，只要是  就照单全收：

   

总结下， 和  对于   当中或者  当中的处理方式是一致的，返回值都是协变的，但对于反射来说， 对参数类型要求几乎没有，而  则非常严格，这样会导致的问题就是  的反射使用起来有些难受。
对于这一点，官方论坛中也有人提出了类似的质疑：  ，说  怎么能酱紫搞呢，这么完美的代码居然给我报了个协变的错误，真是不可思议！

                    

反射嘛，本来就是黑科技，类型整那么复杂真的有必要吗？
 遇坑填坑
有坑不填，不是好码农啊。
前面抛出这么个大坑，说实在的，不给出解决方案我都不好意思写这篇文章。
 类型强转方案
谁说类型强转不行了？谁说的？？既然  不好使，我们给他来个类似  反射的版本，我们对参数类型不做任何限制：
       {
       
}

那么我们的  扩展就可以稍作修改啦：
      
        = 
         {
            {} {} 注意这里的修改
        }
         = 

没毛病。
  反射方案
 反射不能用？不用还不行了么，打不起还躲不起吗，什么世道。。
      
        = 
         {
            注意我们访问的  属性对于  来说是  的， 是  的
             = 
            {} {}
        }
         = 

 我和我的小伙伴们都惊呆了的方案
这。。什么鬼。。
不知道大家怎么看这件事儿， 对象获取  实例的方法其实不止  这样一种，还有一种叫做： ，这货的类型是 ，没有 ，，没有  ！
所以我们的代码还可以改成这样：
      
        = 
         {
            {} {}
        }
         = 

哇靠， 官方的开发者，你们太不厚道了。。
我当时就惊呆了，还以为这两种获取  的方式有什么重大差别呢，结果跟了下源码，是的， 这种写法在调试的时候也是可以强制跳入调用栈的反编译看字节码也可以，二位居然都是调用了下面的方法来获取  实例的：
   {

         {
         
    }

    
}

嗯，人家哥们直接用了  的  类型，在  调用处做了一次类型强转，一个强转成了  ，一个强转成了  。。。
我就问一句，你们这么搞，良心不痛吗？
 小结
这篇文章讲述了一个因  泛型类型严格导致某些情况下反射代码编译不通过的故事。这个故事呢，你说  事儿多也行，说它严谨也行，反正，解决方案咱都有，大不了，大不了我去天桥上贴膜。。什么破代码，不写了！

关注公众号  ，获取最新的  动态。每天分钟，用去食堂吃饭的时间解决一个知识点。

存在的意义
上一篇《分钟梳理关系数据库基础知识二：存储结构》中有强调，我们优化的目标，是尽量减少磁盘  的次数。树这种数据结构就很适合这种场景。因为它高扇出，长得矮矮胖胖的，一层是一次。
为了直观地展现效果，我们可以做一个简单的估算。之前提到的块，在  中被称作页，大小是可以设的，默认为。假设一行记录为个 ，即每个块中能存行记录。高度为的 树，可存放的记录数就是：×××=行。而目前机械盘的一般在～，即使以计算，次意味着时间只需要秒。是不是很美好？
当然这只是一个粗略的估算，大家感受下树存在的意义就好。
在哪里
树是树的一个变种。与树主要有两个值得一提的不同，一是为了存放更多的指针，树在非叶子节点中只存放，叶子节点中才有数据；二是叶子节点之间是有指针相联系的，这就方便了范围查询。
来，种一棵树
为了让大家有个更直观的认识，我手工画了一棵树构造的过程：

上图做了简化，没有考虑填充因子 。填充因子指的是叶子节点满的程度，要求是在半满和全满之间，方便插入和删除。具体数值在中是可以指定的，一般是，当然，要求至少半满，所以可设的最小值是。
相关阅读十分钟入门关系型数据库一：三范式 分钟梳理关系数据库基础知识二：存储结构分钟梳理关系数据库基础知识四：两阶段多路归并排序分钟梳理关系数据库基础知识五：查询优化与连接算法我们对种用于数据科学的开源深度学习库作了排名。这番排名基于权重一样大小的三个指标：上的活动、 上的活动以及谷歌搜索结果。
排名结果
下面是种用于数据科学的开源深度学习库的排名，按照上的活动、 上的活动以及谷歌搜索结果来衡量。该表显示了标准化分数，这个值表示高于平均值平均值=一个标准偏差。比如说，高于活动方面的平均值一个标准偏差，而接近平均值。

方法详见如下
结果和讨论
排名基于权重一样大小的三个指标：星标和分支、 标签和问题以及谷歌结果总体增长率和季度增长率。这些是使用可用的获得的。制作一个全面的深度学习工具包列表很棘手——最后，我们列出了我们认为有代表性的五个不同的列表参阅下面介绍的方法，可了解详细信息。计算每个度量指标的标准化分数后，我们就能看到哪些软件包在每个类别中脱颖而出。完整排名在这里___ ，原始数据在这里__ 。
凭最大的活跃社区一路领跑
在所有衡量指标中，比平均值高出至少两个标准偏差。相比第二大流行框架：，的分支数量几乎是其三倍， 问题更是其六倍以上。最初由谷歌团队于年开源，发展势头已超过历史更悠久的库，比如第位和第位，跃居我们榜单的首位。虽然附带在引擎上运行的 ，但本榜单上的几种库可以使用作为后端，提供各自的接口。这些库包括第位，很快将成为核心的一部分和第位。之所以人气这么高，可能是由于它结合了通用深度学习框架、灵活的接口、外观整洁的计算图形可视化以及谷歌庞大的开发者和社区资源。
尚未被所取代
在本榜单上排名第三，上的活动比其所有竞争对手除外都要多。历来被认为比更专门化，当初专注于图像处理、对象识别和预训练的卷积神经网络。于年月发布了第名，已经跻身于深度学习库的上半部分。是一种更轻量级、模块化、可扩展的，它包括循环神经网络。和是独立的代码库，所以数据科学家可以继续使用原来的。然而，一些迁移工具比如 为使用来驱动现有的模型提供了一种手段。
是最流行的深度学习前端
第位是排名最高的非框架库。可以用作第位、第位、第位、第位或第位的前端。在所有三个衡量指标方面的表现均胜过平均值。之所以人气很旺，可能归功于其简单性和易用性。允许用户快速建立原型，代价是直接使用框架所带来的灵活性和控制性方面欠缺一点。颇受对数据集使用深度学习的数据科学家的青睐。由于 最近发布了使用的面向的接口，的发展和人气指数不断提升。
即便没有行业的大力支持，依然名列前茅
在众多新的深度学习框架中，第位是本榜单上历史最悠久的库。率先使用了计算图，在整个深度学习和机器学习研究界当中仍很受欢迎。实际上就是面向的数值计算库，但可以与像第位这样的高级深度学习封装库一起使用。谷歌支持第位和第位，支持第位和第位，而第位是亚马逊网络服务的官方深度学习框架，微软设计并维护第位，虽然没有得到哪家技术行业巨头的官方支持，但依然颇受欢迎。
是发展最快的库
年年初，谷歌的公开发布了第位的代码，这是一种以为基础的面向对象的高级库。这个季度相比上个季度，的谷歌搜索结果中返回的页面数量增加了，这是我们排名的所有库中增幅最大的。虽然谷歌在年收购了这家英国人工智能公司，但和谷歌仍拥有基本上独立的团队。专注于强人工智能，可以帮助用户在特定的想法和研究的基础上构建神经网络。
是深度学习接口的首选语言
第位是其单一接口使用的一种框架，它是本榜单上发展速度第二快的库。与上季度相比，的谷歌搜索结果多了。在我们排名的种开源深度学习框架和封装库中，只有三种没有使用的接口：第位、第位和第位。接口和接口分别用于种库中的种库和种库。虽然数据科学界在使用方面几乎趋于一致，但是深度学习库方面还是有许多选择。
限制
与任何分析一样，我们一路上做出了决定。所有源代码和数据都在我们的页面上。深度学习库的完整列表来自几个来源。
当然，一些历史更悠久的库会有更高的指标，因而排名更高。唯一考虑到这一点的指标是谷歌搜索季度增长率。
数据带来了几个难题：
 和 是专有的，已被剔除又叫微软认知工具包，但是我们只使用了原来的名字改成了 改成了一些库显然是其他库的衍生版，比如和。如果这些库有独特的代码库，我们决定将它们分开来对待。
方法
所有源代码和数据都放在我们的页面 上。
我们先从五个不同的来源制作了种开源深度学习库列表，然后为所有库收集了指标，以得出排名。数据基于星标和分支， 数据基于含有软件包名称的标签和问题，谷歌结果基于过去五年的谷歌搜索结果总数和过去三个月较之前三个月计算出来的季度结果增长率。
其他一些注意事项：

几个库是常用词、和，因此用来确定谷歌搜索结果数量的搜索词包括库名和“ ”这个术语。
任何缺少的 计数一律转换为零计数。
计数标准化，均值为，偏差为，然后求平均值，以获得和 分数，最后结合搜索结果得出总分。
进行一番手动检查，确认的代码库位置。


文章来源：微信公众号 全球人工智能  工程
工程  路径：_____
工程结构介绍
目前框架内部主要为四个部分：

 — 应用主体业务部分 
 —  源码部分  
 —  公共源码部分
 —  代码，包含第三方控件与 、以及业务相关代码目前为  集合展示

配置  路径 
如果有修改  代码重新打包新的  的需要，请在工程的  中将  参数设置为 ：  

此开关决定是否开启编译时  自动构建默认为关。当打开时若  部分代码存在改动编译运行时会自动编译生成最新的  打入 但是需要  规定的  版本的环境。请参照工程中提供的  文件修改指定的  路径。  

各平台的  下载链接如下：

    _
   _
   _
   

编译运行
快捷键：      是不是很熟悉～ 是的，就是它的快捷键：  

如果需要单独编译 ，也可以尝试在工程根目录下命令行输入： 
打包 
目前项目中使用的内置  暂命名为 ，对应注册名为 ，放置在  下。
如上文结构中提到， 代码在  文件夹下，若需要编译打包新的 ，可以考虑直接在  目录下直接命令行运行   下载需要的依赖。下载完成后，可以尝试打包 ，打包命令为：            将生成的  放置在上文的路径即可。
：后面会支持读  卡的外部 。
 源码修改记录与同步
考虑到  对  的版本升级仍处于一个较为频繁的节奏，因此原则上我们需要尽量避免对  源码进行修改，减少升级同步代码所带来的工作量。然而由于业务或工程需要打入 、修复隐藏的坑等等，不得不修改源码时，请将修改的部分在工程中的  文件中做好记录方便所有成员周知，例如：

 中新增  方法、新增  成员变量… …—— 成员 

 中  方法修改… …—— 成员 


具体请参照  内已修改部分即可。
 源码升级
：若需要升级  源码请知会       
当需要升级  版本时，请确保从  上拉到的是已稳定  版本的  源码！ 
从新的源码工程中提取出  与  部分，替换至本工程对应的部分，需要注意的几点如下：

打开  开关参考配置  路径
拷贝过来后按照  补齐对应的修改
删减不需要的平台的 ：修改  模块下  中 _ 参数，调整为 _ = 
移除  相关的无用文件
对比更新  模块下的  中的下载编译逻辑，一些包括文件名与下载地址在内的常量信息同步更新至 ，并将最新的需要下载的文件提前下载好更新至  目录下
升级完成后提交修改时，不要忘记提交最新的编译好的 

混淆代码部分
待补充
常见问题
、：打开  开关后编译报错：           ：请修改  版本为  版本，参照上文配置  路径。
、：接 为什么我修改了还是报这个错？：试试先   ，再运行工程。
、：为什么打开  开关后，我的  代码修改没有生效打进新的  中？：请关闭   功能  = ，并设置强制每次编译强制安装最新的 ：  


、：为什么   很慢，一直卡在那里不动了？：请切换到  再运行。
、：为什么最新的  官方源码工程打开后一直在  ？：请切换到  再运行。本文档用于总结在使用  时候的一些最佳实践，主要涉及  使用、 优化技巧，特别是一些  专有的优化开关。建议先阅读讲解  原理的三篇文章讲存储，说计算，谈调度，再来看这篇文章。
前言
数据库是一个通用的基础组件，在开发过程中会考虑到多种目标场景，在具体的业务场景中，需要根据业务的实际情况对数据的参数或者使用方式进行调整。
 是一个兼容  协议和语法的分布式数据库，但是由于其内部实现，特别是支持分布式存储以及分布式事务，使得一些使用方法和  有所区别。
基本概念
 的最佳实践与其实现原理密切相关，建议读者先了解一些基本的实现机制，包括 、分布式事务、数据分片、负载均衡、 到  的映射方案、二级索引的实现方法、分布式执行引擎。下面会做一点简单的介绍，更详细的信息可以参考  公众号以及知乎专栏的一些文章。

 是一种一致性协议，能提供强一致的数据复制保证， 最底层用  来同步数据。每次写入都要写入多数副本，才能对外返回成功，这样即使丢掉少数副本，也能保证系统中还有最新的数据。比如最大  副本的话，每次写入  副本才算成功，任何时候，只丢失一个副本的情况下，存活的两个副本中至少有一个具有最新的数据。
相比  方式的同步，同样是保存三副本， 的方式更为高效，写入的延迟取决于最快的两个副本，而不是最慢的那个副本。所以使用  同步的情况下，异地多活成为可能。在典型的两地三中心场景下，每次写入只需要本数据中心以及离得近的一个数据中心写入成功就能保证数据的一致性，而并不需要三个数据中心都写成功。但是这并不意味着在任何场景都能构建跨机房部署的业务，当写入量比较大时候，机房之间的带宽和延迟成为关键因素，如果写入速度超过机房之间的带宽，或者是机房之间延迟过大，整个  同步机制依然无法很好的运转。
分布式事务
 提供完整的分布式事务，事务模型是在   的基础上做了一些优化。具体的实现大家可以参考这篇文章。这里只说两点：

乐观锁

 的事务模型采用乐观锁，只有在真正提交的时候，才会做冲突检测，如果有冲突，则需要重试。这种模型在冲突严重的场景下，会比较低效，因为重试之前的操作都是无效的，需要重复做。举一个比较极端的例子，就是把数据库当做计数器用，如果访问的并发度比较高，那么一定会有严重的冲突，导致大量的重试甚至是超时。但是如果访问冲突并不十分严重，那么乐观锁模型具备较高的效率。所以在冲突严重的场景下，推荐在系统架构层面解决问题，比如将计数器放在  中。

事务大小限制
  由于分布式事务要做两阶段提交，并且底层还需要做  复制，如果一个事务非常大，会使得提交过程非常慢，并且会卡住下面的  复制流程。为了避免系统出现被卡住的情况，我们对事务的大小做了限制：

单条   不超过 
  的总条数不超过 
  的总大小不超过 
在  的   上面，也有类似的限制。




数据分片
 自动将底层数据按照  的  进行分片。每个  是一个  的范围，从  到  的左闭右开区间。 中的  总量超过一定值，就会自动分裂。这部分用户不需要担心。
负载均衡
 会根据整个  集群的状态，对集群的负载进行调度。调度是以  为单位，以  配置的策略为调度逻辑，自动完成。
  
 自动将  结构映射为  结构。具体的可以参考这篇文档。简单来说， 做了两件事：

一行数据映射为一个 ， 以  构造前缀，以行  为后缀
一条索引映射为一个 ， 以  构造前缀，以索引值构造后缀

可以看到，对于一个表中的数据或者索引，会具有相同的前缀，这样在  的  空间内，这些  会在相邻的位置。那么当写入量很大，并且集中在一个表上面时，就会造成写入的热点，特别是连续写入的数据中某些索引值也是连续的比如   这种按时间递增的字段，会再很少的几个  上形成写入热点，成为整个系统的瓶颈。同样，如果所有的数据读取操作也都集中在很小的一个范围内 比如在连续的几万或者十几万行数据上，那么可能造成数据的访问热点。
 
 支持完整的二级索引，并且是全局索引，很多查询可以通过索引来优化。如果利用好二级索引，对业务非常重要，很多  上的经验在  这里依然适用，不过  还有一些自己的特点，需要注意，这一节主要讨论在  上使用二级索引的一些注意事项。

二级索引是否有多越好
二级索引能加速查询，但是要注意新增一个索引是有副作用的，在上一节中我们介绍了索引的存储模型，那么每增加一个索引，在插入一条数据的时候，就要新增一个 ，所以索引越多，写入越慢，并且空间占用越大。另外过多的索引也会影响优化器运行时间，并且不合适的索引会误导优化器。所以索引并不是越多越好。



对哪些列建索引比较合适
  上面提到，索引很重要但不是越多越好，我们需要根据具体的业务特点创建合适的索引。原则上我们需要对查询中需要用到的列创建索引，目的是提高性能。下面几种情况适合创建索引：

区分度比较大的列，通过索引能显著地减少过滤后的行数
有多个查询条件时，可以选择组合索引，注意需要把等值条件的列放在组合索引的前面
这里举一个例子，假设常用的查询是       =    =      那么可以考虑建立组合索引     ，这样可以用查询条件构造出一个索引前缀进行 。



通过索引查询和直接扫描  的区别
   实现了全局索引，所以索引和  中的数据并不一定在一个数据分片上，通过索引查询的时候，需要先扫描索引，得到对应的行 ，然后通过行  去取数据，所以可能会涉及到两次网络请求，会有一定的性能开销。
  如果查询涉及到大量的行，那么扫描索引是并发进行，只要第一批结果已经返回，就可以开始去取  的数据，所以这里是一个并行   的模式，虽然有两次访问的开销，但是延迟并不会很大。
  有两种情况不会涉及到两次访问的问题：

索引中的列已经满足了查询需求。比如   上面的列  有索引，查询是         这个时候，只需要访问索引，就可以拿到所需要的全部数据。这种情况我们称之为覆盖索引 。所以如果很关注查询性能，可以将部分不需要过滤但是需要再查询结果中返回的列放入索引中，构造成组合索引，比如这个例子：          要优化这个查询可以创建组合索引    。
表的   是整数类型。在这种情况下， 会将   的值当做行 ，所以如果查询条件是在  上面，那么可以直接构造出行  的范围，直接扫描  数据，获取结果。


查询并发度
  数据分散在很多  上，所以  在做查询的时候会并发进行，默认的并发度比较保守，因为过高的并发度会消耗大量的系统资源，且对于  类型的查询，往往不会涉及到大量的数据，较低的并发度已经可以满足需求。对于  类型的 ，往往需要较高的并发度。所以  支持通过   来调整查询并发度。

___
  在进行扫描数据的时候的并发度，这里包括扫描  以及索引数据。

___
  如果是需要访问索引获取行  之后再访问  数据，那么每次会把一批行  作为一次请求去访问  数据，这个参数可以设置  的大小，较大的  会使得延迟增加，较小的  可能会造成更多的查询次数。这个参数的合适大小与查询涉及的数据量有关。一般不需要调整。

___
  如果是需要访问索引获取行  之后再访问  数据，每次通过行  获取数据时候的并发度通过这个参数调节。



通过索引保证结果顺序
  索引除了可以用来过滤数据之外，还能用来对数据排序，首先按照索引的顺序获取行 ，然后再按照行  的返回顺序返回行的内容，这样可以保证返回结果按照索引列有序。前面提到了扫索引和获取  之间是并行   模式，如果要求按照索引的顺序返回 ，那么这两次查询之间的并发度设置的太高并不会降低延迟，所以默认的并发度比较保守。可以通过 ____ 变量进行并发度调整。

逆序索引
  目前  支持对索引进行逆序 ，但是速度要比顺序  慢  倍左右，所以尽量避免对索引的逆序 。


场景与实践
上一节我们讨论了一些  基本的实现机制及其对使用带来的影响，本节我们从具体的使用场景出发，谈一些更为具体的操作实践。我们以从部署到支撑业务这条链路为序，进行讨论。
部署
在部署之前请务必阅读  部署建议以及对硬件的需求。
推荐通过 部署  集群，这个工具可以部署、停止、销毁、升级整个集群，非常方便易用。
具体的使用文档在这里。非常不推荐手动部署，后期的维护和升级会很麻烦。
导入数据
如果有   并且业务端可以保证数据中没有冲突，可以在  内打开这个开关：  ___=
另外为了提高写入性能，可以对  的参数进行调优，具体的文档在这里。
请特别注意这个参数：

 默认为 ，表示强制将数据刷到磁盘上。如果是非金融安全级别的业务场景，建议设置成 ，
 以便获得更高的性能。
 = 
写入
上面提到了  对单个事务的大小有限制，这层限制是在  层面，反映在  层面的话，简单来说一行数据会映射为一个  ，每多一个索引，也会增加一个  ，所以这个限制反映在  层面是：

单行数据不大于 
总的行数  索引个数  
一次提交的全部数据小于 

另外注意，无论是大小限制还是行数限制，还要考虑  做编码以及事务额外  的开销，在使用的时候，建议每个事务的行数不要超过  行，否则有可能会超过限制，或者是性能不佳。
建议无论是 ， 还是  语句，都通过分  或者是加  的方式限制。
在删除大量数据的时候，建议使用         这样的方案，通过循环来删除，用   ==  作为循环结束条件，这样避免遇到事务大小的限制。
如果一次删除的数据量非常大，这种循环的方式会越来越慢，因为每次删除都是从前向后遍历，前面的删除之后，短时间内会残留不少删除标记后续会被  掉，影响后面的  语句。如果有可能，建议把  条件细化。举个例子，假设要删除  当天的所有数据，那么可以这样做：
     
     _  
         _ =   _    
    _ =  _
上面是一段伪代码，意思就是要把大块的数据拆成小块删除，以避免删除过程中前面的  语句影响后面的  语句。
查询
看业务的查询需求以及具体的语句，可以参考这篇文档可以通过  语句控制  执行的并发度，另外通过  控制  物理算子选择。
另外  标准的索引选择  语法，也可以用，通过     控制优化器选择索引。
如果是个  和  混合类型的业务，可以把  请求和  请求发送到不同的  上，这样能够减小  业务对于  业务的影响。 承载  业务的  推荐使用高配的机器，比如  核数比较多，内存比较大。
监控  日志
 系统是了解系统状态的最佳方法，建议所有的用户都部署监控系统。 使用  监控系统状态，如果使用  部署集群，那么会自动部署和配置监控系统。
监控系统中的监控项很多，大部分是给  开发者查看的内容，如果没有对源代码比较深入的了解，并没有必要了解这些监控项。我们会精简出一些和业务相关或者是系统关键组件状态相关的监控项，放在一个独立的面板中，供用户使用。
除了监控之外，查看日志也是了解系统状态的常用方法。 的三个组件  都有一个  的参数，如果启动的时候设置了这个参数，那么日志会保存着参数所设置的文件的位置，另外会自动的按天对  文件做归档。如果没有设置  参数，日志会输出在  中。
文档
了解一个系统或者解决使用中的问题最好的方法是阅读文档，明白实现原理， 有大量的官方文档，希望大家在遇到问题的时候能先尝试通过文档或者搜索   寻找解决方案。官方文档在这里。如果希望阅读英文文档，可以看这里。
其中的 和故障诊断章节建议大家仔细阅读。另外  还有一些不错的工具，也有配套的文档，具体的见各项工具的  页面。
除了文档之外，还有很多不错的文章介绍  的各项技术细节内幕，大家可以关注下面这些文章发布渠道：

公众号：微信搜索 
知乎专栏： 的后花园
官方博客

 的最佳适用场景
简单来说， 适合具备下面这些特点的场景：

数据量大，单机保存不下
不希望做  或者懒得做 
访问模式上没有明显的热点
需要事务、需要强一致、需要灾备


作者简介：申砾，  ，前网易有道词典服务器端核心开发，前奇虎  新闻推荐系统  地图基础数据与检索系统  。 源码地址：近日，腾讯云宣布举办系列游戏开发者技术系列沙龙。沙龙围绕游戏行业趋势、研发技术、运维和推广等热点进行探讨，首站活动将于月日在京正式开启。沙龙计划在未来半年围绕大主题跨越城，每期沙龙将邀请国内外游戏领域专家，分享游戏开发及运营过程中的思考和实践。

半年三期六城，打造游戏开发技术圈子
在各行各业纷纷拥抱云计算的趋势下，游戏行业对云的接受程度是最高的。腾讯游戏云总经理黄世飞曾指出：“当前国内有超过的游戏开发商或发行商已经是腾讯云的客户，并且从原来只用到计算、存储、网络等基本元素，过渡到和的服务。”
为此，腾讯云已陆续开放了包括全球应用加速、蓝鲸一站式运维体系、手游测试、游戏语音、游戏更新、游戏存储、智营网优等腾讯独有的技术能力。腾讯云更开放超过个服务节点，覆盖全球五大洲，为游戏全球化提供了强大的云计算服务支撑。
为了帮助游戏行业开发者洞察热点技术、了解腾讯云最新能力、连接腾讯游戏生态资源，腾讯云举办的系列游戏开发者技术沙龙将跨越整个下半年，涵盖游戏全球化、增值与服务、腾讯游戏生态大主题 ，在北京、广州、成都、上海、厦门、深圳全国座城市 先后召开。

剖析游戏全球化实践，沙龙相约北京
游戏行业面临激烈竞争，“游戏全球化”已成为行业热点。游戏全球化运营，对节点分布、网络稳定、网络加速、安全防护等云端基础能力提出了很高的要求。沙龙北京站 ，将聚焦探讨腾讯云在全球化方面的技术布局，活动还邀请到了游戏全球化的先行者分享各自的实践与洞察。

此次沙龙上，腾讯云海外资深工程师李宇明将分享“游戏全球化”面临的文化及国情差异。在复杂的各国生态中，腾讯云如何务实地打造开放我们的本地能力，精细化整合属地化能力，打造面向出海客户的灵活、极致、强大的海外平台。
腾讯网络平台部资深网络工程师文景，将介绍通过架构布局、部署模板化、运维工具化等方法，实现运营商资源互联，全球网络拓展、动态网络质量管控等方面的心得和经验。
腾讯游戏云资深产品经理马亮，将带领大家一同关注如何满足游戏厂商新兴市场的布局需求，如何让全球同服架构更简单、安全、可靠，并对腾讯云全球化的最佳解决方案和案例进行分享。
猎豹移动技术总监佟卉斌，将从《弓箭手大作战》和《钢琴块》等游戏经验出发，分享怎样提高研发效率、规避研发风险、降低研发周期，同时解读如何才能实现全球玩家数据同步、如何选择服务器运营商、如何配置全球网络。
香港绿洲运维总监张振华，将通过《坦克争霸》《虎豹骑》案例，讲述绿洲如何实现全球同服架构，如何有效运维全球同服架构。
腾讯游戏语音资深产品经理张程，将分享腾讯游戏语音技术的产品特性和技术特点，以及产品的全球化之路。
目前沙龙第一期游戏全球化，月日北京站的报名仍在火热进行中，具体详情可在腾讯云官网查看：理想的互联网服务后台框架的九个要点
对于互联网服务后台团队，开发框架的选择是非常关键的一个问题，多年的海量服务经验和教训使得我们团队深刻的认识到：

要尽早规范团队的开发服务框架，避免到了后期，各种开发语言混杂、各类存储组件充斥、重复编码、每个模块形态不统一、文档缺失、监控瘫痪、人员离职造成大量信息丢失，最后积重难返、痛苦不堪。

没有框架来规范，团队的随意性就太大，合作效率就大打折扣，甚至于内耗、反复的挖坑填坑，系统的成败过于依靠人的意识和水平。

规范，不能靠文档、不能靠劳动纪律、不能靠苦口婆心、不能靠人员意识、不能靠运动式的整顿，要靠技术框架上切实的限制与贴心保护。


如果有机会从开始定义一个理想的开发框架，需要考虑哪些点？我们觉得主要有如下个方面：

同步编码异步执行：兼顾运行效率和编码效率，希望代码写起来是同步和顺序的，而执行的时候是异步的。

：支持接口描述语言和，减少网络协议相关的重复工作，协议有比较好的扩展性；远程调用友好且高效，做到覆盖主要的开发语言。

：对服务间的调用选路进行统一的管理，对单机故障和网络波动等常见情况有自动容错，我们简称 。

存储服务化：这个其实和开发框架关系不太紧密，这里提一下，强调存储应该有统一的组件且由专业的团队运维，就像共有云一样。

过载保护：框架必须有成熟自带的过载保护机制，不需要业务开发人员关注或者关注很少。

基础的监控和告警：调用、机器的网络活动、任务并发度、时延、进程监控和秒起等基础信息，要有上报、统计和告警，不需要业务开发人员关注。

完整的业务流转呈现：统一日志，在一个地方能够清晰的呈现某次业务处理过程的流转详细情况：经过了哪些模块间调用，调用参数是怎样的，每个模块处理的重要分支和结果是怎样的，最好图形化呈现。支持染色和不同的日志详细级别。


中央总控：整个系统的配置和文档等重要信息，例如每个模块有哪些机器，分布在哪些机房、容量冗余情况、模块间调用关系、访问控制的配置动态管理甚至电子流，都希望能统一在一个地方化的管理起来，并且与运营的系统是直接联系直接生效的。

云调度：容量的自动调度。例如要进行某个运营活动需要大量的扩容，只需要把设备放进去，就能自动的扩缩容。当某个城市机房故障，能够自动调度容量到其他城市。

基于上面的总结，我们团队开源了一个服务开发运营框架，叫做毫秒服务引擎。
毫秒服务引擎 取英文名    的首字母组合是腾讯的一个开源框架，集、名字发现服务、负载均衡、业务监控、灰度发布、容量管理、日志管理、存储于一体，目的是提高开发与运营的效率和质量。
毫秒服务引擎的创作冲动和构建经验，来自后台团队超过年的运营思考。它是一整套解决方案，但也可以拆分的来使用其中的监控、存储单品。
详细可见官网，或在腾讯云服务市场联系我们
典型用户群体
使用毫秒服务引擎，用户可以快速拥有一套具备监控、名字发现服务、负载均衡、灰度发布、配置管理、日志、存储等功能的系统化的开发与运营框架，特别适合互联网初创公司。
毫秒服务引擎非常容易搭建和上手，使用它，初学者从零开始开发一个分布式后台并运行起来，只需要个小时。基本上是一个小时完成框架搭建，一个小时完成开发上线。
功能与优势

模块间访问采用的方式，开发者不用关注网络与报文格式，像写单机程序一样开发分布式服务

负载自动均衡与容错，对于单机故障、局部网络波动等状况自动应对，服务高可用性

支持与语言，后续还将继续丰富；如果选择语言，支持协程，兼具开发和运行效率

化的管理界面，在界面完成配置、发布、监控、日志、­存储集群管理等所有操作

需要复杂部署的服务器都采用镜像的方式安装，使得部署与上手非常容易

相比使用其他开源组件拼凑起来的解决方案，毫秒服务引擎更加的体系化，对团队的规范更加到位



毫秒服务引擎也提供了微信公众号，欢迎大家关注，参与讨论和反馈。


相关推荐
后台服务标准化运营谈谈后台服务的和路由管理谈谈后台服务的灰度发布与监控爬虫之自动化终极杀手
  
导语：
最近写了好几个简单的爬虫，踩了好几个深坑，在这里总结一下，给大家在编写爬虫时候能给点思路。本次爬虫内容有：静态页面的爬取。动态页面的爬取。自动化终极爬虫。
分析：
数据获取主要靠爬虫

静态网页爬取
动态网页爬取

数据存储 存储

 操作保存结果

数据获取实战：
百度音乐静态网页
分析步骤  打开百度音乐：
  打开浏览器调试模式，选择模式

  搜索框搜索歌曲 ，查看控制台


过滤请求：   输入搜索关键字
依照请求接口的特点，查看主请求
分析请求 、 、

 通过以上分析：获取到有效信息：

歌曲搜索请求接口为=歌曲名
获取请求方式、百度音乐搜索歌曲为请求
请求伪装浏览器，避免被拒绝请求
请求返回结果  百度音乐的返回结果为。

 通过有效信息来设计爬虫，获取数据

伪装浏览器。需要导入库，比起、等库更加方便，这里不做赘述。要点是添加请求头、等
发起请求
等待请求返回
处理返回数据。因为百度音乐才用的是作为返回数据。因此要祭出我们的  是一个可以从或文件中提取数据的库它能够通过你喜欢的转换器实现惯用的文档导航查找修改文档的方式 会帮你节省数小时甚至数天的工作时间。这可是爬虫的福音，终于不用再写那么复杂的正则表达式了—引用，详细教程可访问  教程进行学习，本次使用的方法不多，会在后边介绍。
将解析到的有用数据进行保存。

代码实现
  提供准对参数进行访问并返回结果的方法
  

     
       待爬取的链接
     
     
      从中获取
       = 
       = 

      伪装浏览器，避免被
      = {
          
                    
          ==
           
          =
     }

      代理
      = {
          
          
     }
      利用封装的方法请求，并添加请求头和代理，获取并返回请求结果。并进行异常处理
     
          =  = =
          = 

          _ == 
              请求成功
              获取网页内容，并返回
              = 
              
         
              
        
          异常处理
         
          
 __ 提供对参数_进行歌曲搜索并获取搜索结果
  ___
     
     获取百度音乐搜索歌曲结果
      _ 待搜索歌曲名
      搜索结果
     

      
         
         静态网页分析，利用，轻松获取想要的数据。需要对有了解。
         
         

          初始化对象，并指定解析器为 。还有其他的解析器：、等
          详细教程可访问：《爬虫利器二之 的用法》
          =  
          常用方法之一 _          
          _ 方法搜索当前的所有子节点 并判断是否符合过滤器的条件
          标签名为的并且标签类名为_参数可为 、 、 
         __ = _ _=     

            __
               方法搜索当前的所有子节点 并返回符合过滤器的条件的第一个结点对象
             __ =  _=
              =  _=
              =  _=

              此部分需要对页面进行分析，一层层剥开有用数据并提取出来
              __
                  获取结点对象内容，并清洗
                 __ = _
             
                 __ = 
              
                  = 
             
                  = 
              
                  = 
                  
                      获取标签属性值
                      方法二：属性值 = 属性名
                      = 
                         = 
                          = 
                 
                      = 
             
                  = 
               _   |      |   
             __  

      = 
      = _
      = _=_ _=
      = 
       
          
     
      = _=_ _=
      = 
     
      
就这样我们获取到了百度网页歌曲搜索结果的数据。然后就是保存数据，这个我们最后再谈谈。
网易云音乐 动态网页
在我们以上一种静态网页获取数据方式来获取网易云音乐的数据的时候，可能会遇到这样的问题：网页查看源代码并没有可用的数据，仅仅只有网页的骨架。数据完全找不到，可是打开开发者工具查看树却能找到想要的数据，这时候我们是遇到了动态网页，数据是在动态加载进去的。无法获取网页数据。

目前解决方案有两种：

通过查看访问动态数据接口来获取数据。
通过自动化工具来获取网页源代码以获取数据。目前网易云简单通过访问已经不能获取到数据了，我们可以采用自动化工具和来实现网页源代码的获取


方案一实现通过查看访问动态数据接口来获取数据：

打开网易云音乐：
打开浏览器调试模式，选择模式
搜索框搜索歌曲 ，查看控制台

过滤请求为发现请求怎么都一样，这时候我们翻看这些查看到 里找到关键字的请求，这个请求是一个请求。这个应该就是获取搜索数据的接口，通过查看或者来查看请求返回结果。正是我们想要的。
我们先不要高兴的太早了，目前我们还没有搞清楚 是怎么构成的。  到底是怎么生成的。在看过网络上有关抓取网易评论的爬虫《如何爬网易云音乐的评论数？》，得知这个网易针对做了加密处理。由于个人道行太浅参悟不透这里的加密参数顺序和内容。因此这个方案就此作罢。实在不甘心，只好换方案二。
方案二实现
既然方案一暂时走不通，也不能影响我们的工作进度，换个思路继续走，想到使用自动化测试工具可以实现模拟人工操纵浏览器。这样导出网页数据应该不是问题，想到立马动手。
环境配置

安装推荐使用包管理工具自动：    其他方式可参考：  自动化测试环境搭建

 安装

是一个基于的 。它使用作为它核心浏览器的功能，使用来编译解释执行代码。任何你可以在基于浏览器做的事情，它都能做到。它不仅是个隐形的浏览器，提供了诸如选择器、支持标准、操作、、、、等，同时也提供了处理文件的操作，从而使你可以向操作系统读写文件等。的用处可谓非常广泛，诸如网络监测、网页截屏、无需浏览器的  测试、页面访问自动化等。

下载
 目前官方支持三种操作系统，包括\ \这三大主流的环境。你可以根据你的运行环境选择要下载的包

安装

下载完成后解压文件，可将放在的目录下\\。这样后续加载不需要指定目录。也可以放在特定目录，使用的时候指定路径即可。双击打开验证安装是否成功。如果出现下图，即安装成功了。

 代码步骤实现：

初始化浏览器获取网页数据

  _
     
     使用自动化工具获取网页数据
       待获取网页
      页面数据
     

      初始化浏览器
      = 
      浏览器访问
     
      坑：不同间的转换网易云在数据展示中会将数据动态添加到_这个框架中，如果不切换，会报元素不存在错误。
     __
      隐式等待秒，可以自己调节
     _
      设置秒页面超时返回，类似于的选项，没有选项
     ___
      获取网页资源获取到的是网页所有数据
      = _
      坑：退出浏览器，必须手动退出。
     
      返回网页资源
      


解析网页获取数据，同百度音乐省略

  ___
     
同样是通过对网页资源进行对象化，在通过对对象的筛选获取得到数据。没想到网易云音乐的数据也能这样拿到。能做到这里已经可以对付大部分网站了。
选用看中其不需要可视化页面，在内存占用上比较省。可是也是出现问题，各位看官请继续往下看。眼看着就要完成了。
 

使用搜索功能，需要登录账户比较不好申请，申请好几次都没有成功
登录成功后，天不遂愿啊，打开搜索页面，竟然没办法查看网页原代码。单独通过请求搜索：  也没办发获取网页数据，会报出权限问题。后边依次解决。

解决方案：

通过使用自动化获取数据。
通过请求动态数据接口来获取数据

方案实施：
方案：
采用自动化工具获取数据：配置如同网易云配置，模仿用户操作浏览器进行网页打开，用户登录，进入搜索页面，获取页面数据
  _
     
     使用自动化工具获取网页数据
       待获取网页
      页面数据
     
     _ = 
     _ = 
     _ = 
      初始化浏览器
      = 

      模拟用户登录
      浏览器访问登录
     _
      休息一下等待网页加载。还有另一种方式：_
     

      获取页面元素对象方法本次使用如下：
        ___  通过标签获取元素对象 可在页面中获取到唯一一个元素，因为在规范中。一个树中标签不能重复
        ____  通过标签类名获取元素对象，可能会重复有坑
        ___  通过标签获取元素对象，类同，可获取唯一一个元素。
      获取页面元素对象用户名
      = ___
      
      坑：获取页面元素对象密码
        在通过类名获取标签元素中，遇到了无法定位复合样式，这时候可采用仅选取最后一个使用的样式作为参数，即可稳定性不好不建议使用。尽量使用_
       = ____       
      = ____
      
      获取页面元素对象登录按钮
     _ = ___
      通过 调用模拟键盘的输入用户名
     __
      通过 调用模拟键盘的输入密码
     __
      通过 调用模拟鼠标的点击操作，进行登录
     _
      休息一下等待网页加载
     _

      搜索打开歌曲
     
     
      搜索获取网页代码
      = _
      

点击运行之后，一切都风平浪静。突然代码报错了如下图。查完资料也做了代码的修改。

网络提供方案

添加对待输入元素的清除原有的字符。
更换浏览器

方案实施
方案：
在获取了对象之后添加对该对象的清除方法、
实施结果
方案失败。原因不明了，多半是对兼容性不好。
方案：
更换浏览器，本次选择使用浏览器进行自动化操作。
安装自动化控制插件。

下载插件。
将复制到的安装目录
双击验证安装

修改代码：
 初始化浏览器
 = 

再次执行代码
实施结果成功打开可视化页面并登录成功。

本以为这样就可以获取到数据了。燃鹅，还是没有获取到，又报错了如下图

到这里就应该查看请求了，找到是什么。并尝试添加到请求头中。

查看

可是在我们登录后的列表中却没有这个

预测这个应该是在播放器加载时种下的。验证一下：

由上表可知。该在加载播放器的时候种下的。
到这里问题，解决一大半了。
接《爬虫实战  爬虫之  自动化终极杀手下》有个论坛一直用的是，出来以后看到大片大片的好评，性能大幅度的提升，心里就种草了。正好官方最近也从连续升级到了、版本，解决了很多外部网络依赖导致卡死等历史问题，顺便又把也支持了，那就升级一把。
首先把服务都停掉
   
                                               
   
                                                 
查一下当前安装的模块和插件有哪些
    |  
_                                                       
_                                                   
_                                                
_                                                 
_                                                   
_                                                    
_                                              
_                                                 
_                                                   
                                                 
_                                           
_                                        
_                                          
_                                           
_                                          
_                                             
更新一下的源因为是 的系统，所以选择了这个：
   
 
         
                 
           
因为涉及的模块太多，一个一个处理容易出错，自动生成个脚本来处理一下
     \\
     |   | \\\\\\ \\\\  
这样把需要卸载的的模块都放进去了。
把卸载完了还要把对应的的模块安装回去，所以先生成一个安装脚本
    \\
    |   | \\\\\\\\\\ \\\\ 
不过不是所有的包都能够顺利升级的，要检查一下这些的模块是不是都有对应的的包
    |   | \\\\\\\  \\\\ |    |
     
  
发现这个包没有对应的版本，那就只能一下，把这个包从 里面删除掉了。
好了，现在一切准备就绪，开始移除
   
   
   
 
   



安装
   
   
   
     
   
  _ 
 


       

    
   
    
安装检查的时候报告了一个   _  。可以先以后修改，再来也可以先把其他的安装包都装好了再单独处理这个包。
检查一下这个包怎么了
  
原来从开始，只支持模块，不再支持古老的原生模块了。可以修改一下把改成 
      
___    
   
   
     


       

    
   
    


 _        



中间有部分安装包报告的，似乎缺少签名，键入跳过。看看是不是安装成功了
  
           
     
       
试试启动一下服务
   
                                               
  
                                                 
看起来蛮好。试试访问起来怎么样：
 
   
  
  || 
       
     
报告一个错误，检查一下是什么问题：
  _
                     
通过转发被拒了，看看的监听配置
   
 = 
_ = 
原来变成默认的监听端口的方式了，那还是改为方式吧。
  
    =  = \\  
   
 = 
_ = 
   
                                               
                                               
   
  

   
  
  || 
       
  
   
  || 
      
  
至此服务已经恢复，可以打开浏览器验证了。作者介绍：吴洪辉 腾讯云工程师

在版本中加入了支持表加密和表空间加密的特性，在版本加入了支持加密的特性，这使得我们可以对数据文件和进行加密，避免数据文件、等文件被窃取后破解出关键数据。
本文主要介绍加密特性、使用方法。
一的加密特性

表空间加密

日志加密

加密

表加密

临时文件加密


加密特性的一些限制：

元数据文件目前尚未加密

目前只有 才能解密，工具还不支持解析加密后的文件

工具目前无法备份恢复使用了加密特性的实例

慢查询日志和错误日志尚未加密，里面可能会包含原始数据


二使用加密
为了保护加密后的数据，密钥一般存放在和数据文件不同的位置。的密钥管理方式可以根据不同的保密需求来开发密钥管理插件，在默认情况下可以使用__插件，该插件以文件的方式存储密钥。
__插件：
 相关参数：
___：密钥文件位置 比如_
___：密钥文件的解密密码，如果密钥文件有加密的话则必须提供
____：加密算法 __
密钥文件格式：
    



每行密钥由两部分组成，第一部分是密钥，紧跟分隔符后面的是十六进制的密钥。每个表可以单独指定一个密钥。不过系统表空间和日志文件固定使用为的密钥来加密，所以密钥文件中一定要有为的密钥。如果存在密钥为的密钥，则会用来加密临时表和临时文件。
这里还可以对密钥文件本身进行加密来防止密钥文件外泄，例如把明文的_文件加密成__，密码为`___：
      ___  _  __`
加密选项：
： 是否加密所有表 表示强制加密所有表
： 是否加密日志文件
：秒数，如果获取到了新密钥多久更新一次页面加密 
：，最多允许用多少来做页面加密更新
：线程数，用多少个后台线程来做页面加密更新
加密选项：
：，是否加密
其他加密选项：
__：，是否加密临时文件
___：，是否加密临时表
__：，是否加密表只对_=
加密测试：
在中添加：
=__
____=_
___ = __
___ = ___



=


__
___
__
添加完成后重启服务。
创建不加密的表：
  _    =
创建加密的表，指定密钥为：
  _    = __=
修改不加密的表为加密：
  _ = __=
修改加密的表为不加密：
  _ =
插入数据：
  _   
  _   
已加密的数据文件对比未加密的数据文件：

加密：
加密开启后的主备同步：
开启加密后，主机和备机之间的传输是不加密的，由备机在写数据文件时进行加密。所以主备之间的密钥可以不同，但信息必须一致，否则建表语句在备机上无法执行成功，将会导致 线程中止。
加密和压缩：
数据加密和数据压缩可以同时使用，先做数据压缩再做数据加密，可以节约很大的存储空间。
更多数据库文章，请关注腾讯云数据库公众号 

相关推荐   数据加密功能解析导语： 体育分析是一个市场价值很大的产业，近年来异常火爆。本文简单科普了相关技术在体育产业的几个应用，希望能起到抛砖引玉的效果，吸引更多同学分享相关的资料。

很早以前看过一部体育题材的电影《点球成金》，英文名。片子讲述了布拉特皮特饰演的球队总经理和耶鲁大学经济系毕业的数据分析师一起通过对棒球比赛数据进行挖掘和分析，淘宝联盟里性价比高、拥有一技之长的球员组队，进而取得成功的光荣事迹。该片充分展现了利用数据来提升球队的价值和意义，令人印象非常深刻。一直想对其中用到的技术手段一探究竟，而 上的《        》这个实在是再合适不过了。
这个讲座由   ，    ，  三位合作，学术界工业界的模式保证了实用性。整个还是很研究范儿，数学公式比较多，但解决的问题和方法还是相对比较浅。这里可能有两个原因：这个领域人们之前并未足够重视，大部分还是依靠专业球探的经验； 这个领域价值很大 权威机构预测到年体育数据分析的市场有亿美金 更专业更有价值的方法并未公开。具体方法不再一一赘述，挑三个有趣的分享一下，更多可以参考链接。
      评估球员实力：修正的正负值指标−
正负值是评估球员实力的主要指标，该指标越高，意味着球员能力越强。以安东尼为例，就是安东尼上场的时间内，球队输了分。但该指标只考虑球员在场的得失分差，明显有很多不合理的地方。比如场上领先时，不代表每个人都对这次的成功合作做出了正面的贡献，退一步讲，即使每个人有正面贡献，贡献少 能力低的也很难通过这种数据被区分出来。
如何区分每个球员对胜利的贡献是其中的关键问题，研究者们借助线性模型对每个回合进行回归建模，因变量是每回合的得分、自变量则是所有球员，回归的结果就是每个球员会有一个权重，而这个权重代表了球员对胜利贡献。这里自变量的设计很巧妙，针对每一个回合，我方在场球员用表示，对方在场球员用表示，其他球员用表示，这样起到的一个效果就是本回合的得分和我方在场球员正相关，和对方在场球员负相关，而和不在场球员无关。多个回合经过模型学习后，每个球员都有了自己的一个权重，越大表示这个球员对胜利的贡献越大，同时由于每个回合都考虑我方在场和对方在场的球员，也把其他球员的影响自动考虑进去。

上图图是 赛季头部和尾部的球员，看起来非常靠谱，和大部分球迷的认知还是比较一致的。
      预测比赛胜负：基于的
简单来说基于的思想，将球队之间的比赛建模成图，结点是球队，边是球队之间的战绩得失分。然后在图上运行，就可以得到每个球队的实力评估分数，值越大，球队实力越强，胜率越高。下图是基于联赛构建出来的图，结点越大，球队越强。边越粗，说明球队交手时差距越大。
 
预测比赛胜负时，可以简单根据之前的交手记录构建图，然后计算出每个球队的目前实力。当两个球队交手时，实力更强的球队预测为胜。就是这样一个简单的策略，就能取得很好的效果，按作者的原话是达到了的水平。

上图是联赛预测的结果和真实的结果的比较，可以看出确实不简单。
      战术有效性：挡拆识别及评估
挡拆防守是最常见的战术，也是得分最有效的手段。有研究者建立并实验了一套自动识别常见挡拆防守套路的系统。利用球员追踪数据和监督式机器学习方法，建立了一套学习分类器，用于分辨防守挡拆的四种方式：“挤过”、“绕过”、“包夹”、“换防”。具体含义如下：
挤过：持球防守者在持球人和掩护者之间，即从掩护上方挤过；
绕过：持球防守者不在持球人和掩护者之间，即从掩护下方绕过；
换防：持球防守者和掩护防守者交换防守对象；
包夹：持球防守者和掩护防守者夹击持球人。
然后作者手动标记了四种类型的若干样本，并进一步训练构建了分类器来发现更多的挡拆。最终识别结果如下：全部个挡拆，“挤过”个，“绕过”个，“换防”个，“包夹”个。对这些进一步分析可以得到以下一些有趣的结论：
     各赛季四类挡拆分布基本一致，但可以注意到“包夹”的比例略有提高，说明随着个人得分能力更强后，包夹会越来越多？

    哪些组合不来电？
下图比较了不同防守组合面对挡拆的每回合失分以及他们各自与所有球员搭档的平均每回合失分。克里斯保罗和布雷克格里芬是使用挤过的效果是最差的之一，平均失去分。另外伊巴卡和雷吉杰克逊组合的换防很差，但各自挡拆防守效率很接近。【题外话，如今这两对组合已经都被拆散了，是不是经理看到了这个研究？】

结语：在体育产业的应用才刚刚开始，还有很多的应用正在展开或者即将展开。感兴趣的同学可以自行搜索相关资料进行学习研究。地址：引言
腾讯云作为国内一流的云服务提供商，云服务器的使用可谓是“一键成站”，十分方便。今天我们就来介绍一下几种在腾讯云建立的方法。 这里，我们仅介绍下安装等内容托管开源程序的示例，对于在下的环境配置与开源程序安装大同小异，只不过下图形界面多一些使得让人看上去没那么难而已。
 使用此教程前先修知识：

简单命令
编辑器的使用

【常规安装——或安装】
前奏：环境检查

操作系统：本例使用的大部分在  与   位上可行
服务架构：或

注：此处为，为


软体版本： 、、


在上的配置

这一节是按照已有域名来写的，如果暂时没有域名或者只是想配置单网站，可以先看下一节“在上的配置”

  简称是软件基金会的一个开放源码的网页服务器，是最流行的服务器端软件之一。 版本是一重大升级版本，新版改进了缓存、代理模块，会话控制，改进异步读写、增加_各方面支持等，有大幅度提升并发性能。
下面，我们就介绍一下在配置多域名或已有域名模式的，以供参考。
更新系统
  
安装并配置  网络服务器
  中默认的是   版本， 官网有份很好的  配置实例。
安装
    
备份配置文件建议对于所有的配置文件，做任何更改前都先备份一份，以便应对未知错误
  
    
其中 ～ 表示当前登录用户的用户文件夹； 参数表示递归到所有子目录
配置虚拟主机 
  
文件内需要填写的内容：

 主机 
 

 
     
     
     
     注意下面这行末尾不要带 
     

 
     
     下一行这样设置就可以在网站文件的目录中使用 
     
     下一行是替代    的新机制
      


     
      
     



 主机 
 
 这是另一个位于同一服务器的网站，如果不需要则删除此段配置

 
     
     
     
     

 
     
     
      


     
      
     



 主机 
 为了以后给访问  的时候用，也可以是别的端口，如 
 

 ，访问地址：

 
     
     
 
     
     
      

     
      
     

虽然配置文件写好了，但是还不能启动  进程，因为上面设置的各个文件夹网站目录还没有创建。
创建各个虚拟主机的文件夹根据需要增加或删除，
 主机  的
   
  

 主机  的
   
  

 主机  的
   
  
为了能够在系统启动时自动运行  服务器，需要运行下面的指令：
   
输出类似于，
      
然后启动  服务，
   
如果上述指令提示说本来已经启动了 ，则重新加载它，
   
现在需要将  服务加入防火墙以允许外部访问。先启用防火墙服务，如果防火墙默认没有启动，则下述指令会提示错误，“   ”。
       
其中  表示两条指令依次执行。
启动后再重新执行下面的指令：
将  默认使用的端口  加入到防火墙允许列表里
  = 
其中，– 参数表示这是一条永久防火墙规则，如果不加这个参数则重启系统后就没有这条规则了。
而对于自定义的用于  的  端口，也需要添加相应的防火墙规则。因为是非标准端口，直接用数字表示即可，
  = = 
重启  使该规则生效，
   
如果要查看加入后的防火墙规则，使用指令，
  
显示结果类似于，
 
  
  
     
   
   
  
  
   
如果已经做好了  域名解析，现在用浏览器打开域名应该能够看到  的测试页面了。

安装和配置  数据库服务
 是在  基础上重建的一个数据库软件，各  发行版都陆陆续续从  切换到了 。 从  开始默认使用 。
安装
     
加入随系统启动
   
输出结果类似于，
     
启动  守护进程
   
其默认用户名还是 ，
   
可以查看内存占用情况。
安全配置 
使用  内建的安全配置脚本进行配置
 __
这里需要配置  根用户和密码、清除其他用户、清除不需要的数据库等。输出类似于下面的执行过程，其中需要我们从键盘输入的内容用注释出来了：
           
               

            
           
           
      

       
     

           
     

     此处输入
 这里输入你的密码并不会显示
  再次输入
  
  
  


          
            
            
            
 

     此处输入
  

           
           

      此处输入
  

           
            
     

         此处输入
    
  
      
  

           
   

      此处输入
  

 

            
    

   
然后使用  的  帐户不同于  的  帐户，刚才设置密码了登录进去
    
输入密码后回车，下面是输出示例，可以看到命令提示符变为  
           \
     
    

         

   \    \      

 
建一个新数据库给  用这里取名为 ，也可以用别的名字
    
创建一个新用户，并将该数据库的权限赋给他这里只是举例，用户名为 _，密码为 
       _   
更新权限
   
退出数据库
  
执行大体输出如下：
    
      

       _   
      

   
      

  

备份配置文件，
   
其它的先不做了，回头用图形界面的  来做。
安装和配置 
安装 
    
备份配置文件 ，还有  以及 ，
   
   
   
并确保  中有下面的语句不同的就修改，没有的就添加，某些数值可以后再调整，这是针对一个简单的运行  的服务器的配置：
_ = __|__|_|__
_ = 
_ = 
__ = 
_ = 
安装 
为了在  中使用 ，还需要安装这个  包：
    
安装和配置  选作
 安装源上有最新的 、 以及  的  安装包，可以方便安装、更新。但是正在使用的  发行版   上的软件包可能版本上要求不一样，所以使用  安装源优先级插件来进行控制。
安装使用  选择合适的源地址来安装，参考方法：安装使用  安装源。
到  主页：
______
找到     ‘’  ，点击打开新页面，复制  的链接数字可能有变化，当前版本是 。采用下面的方法直接安装：
    
安装
    
配置
 的默认安装目录是 ，同时会在  的配置文件目录中自动创建虚拟主机配置文件  区分大小写。
同样的，先备份配置文件以防修改出现错误，
   
然后修改配置文件 中有设置：
  
  
也就是说，我们可以通过绑定到  服务器上的任何域名访问 。比如这里可以通过  或者  访问。但是这样一来， 的内容就与网站内容混到一起了，感觉  成了网站的一个目录。但实际上我们并不希望别人也去访问这个页面。所以我们使用习惯的地址加端口 而不是默认的  端口，换成自己喜欢的端口就行，再比如 的方式，即  的链接形式访问 ，加  注释掉上面的   规则
  
  
并将
 


里面的
  
  
改成
  
保存退出，使之可以从任何地方都可以访问。如果本地电脑是固定  的，为了安全，也可以将上面的    改成   。咱的  就享受不到这样的待遇了。
因为在前面创建虚拟主机配置文件  的时候已经为  配置了一个端口为  的虚拟主机，只能通过该虚拟主机端口访问 。因为 _ 配置为  的虚拟主机目录，为该目录创建符号连接到  安装目录：
    
备份然后修改  的配置文件，
   
编辑文件：
  
找到其中的如下代码段：
_ = 这里随便填上一串乱七八糟的字符即可，字母、数字等，长度最好大于  个
按照上面的提示填写 _ 字符串。其他的不用修改，保存并退出。
重起  使配置生效
   
现在就可以通过  将  换为你腾讯云服务器的 ，端口为前面设置的  的虚拟主机端口，注意大小写访问  了。
使用前面创建的用户名和密码 中  语句中包含的用户名和密码登录 。
安装
域名配置
首先配置域名，这里以为示例演示，截图中也有对相关记录的解释，接下来的其他方法也可通过此教程来配置域名解析。
增加解析如图：

解析详解如图：

安装
转移目录到相关目录
  
下载
  _
解压文件
   _
移动文件
   
访问网址，进行最后一步的安装。
出现如下图所示页面，单击继续：

输入已经创建的数据库信息：

这一步出错的原因是，网站本身对文件夹没有读写权限，具体解决方案可以查看本节参考资料链接中关于网站用户权限的讲解。此处我们可以按照提示，通过，输入 来创建，并复制已经提供的内容，保存继续即可

到这里说明已经连接了数据库，提供网站管理信息就可以继续安装咯。

哇咔咔，这个页面不用解释了吧

仪表盘控制后台界面：

首页截图：

在上的配置
是一款轻量级的 服务器，并在一个 协议下发行。由俄罗斯的程序设计师 所开发，供俄国大型的入口网站及搜索引擎使用。其特点是占有内存少，并发能力强。
下面，我们就介绍一下在配置单网站模式的，以供参考。
安装服务程序
安装：
    
使能够开机自启：
   
输出结果类似于，
     
重新启动：
   
安装完成后，访问地址，出现如下图页面的欢迎界面，即说明已经完成安装了。

在这个页面我们看到

                                        

这两句话，这里告诉我们默认的配置文件在哪里，以及访问路径在哪里，也就是我们需要放置的路径在哪里。先记下来，等会有用

这里的是最简单的安装方法，其实最合适的安装方法还是在本地环境交叉编译完成后进行的安装，也不算特别麻烦，教程详见：服务器安装及配置文件详解

安装  服务程序和  数据库服务程序

此步与上节相同，请参照上节相关子节的步骤进行即可。

不过按照上节步骤安装完之后，需要安装一个插件才行
    
创建守护进程，并设置自启并启动：
   
   
输出如下的类似内容：
     
配置完成并启动后，我们通过如下命令可以看到进程的监听状态：
  |  
  | 
输出如下的类似内容：
   | 
                 = 
   | 
                                        
安装
首先配置，通过如下命令进入编辑器：
  
在
          {
             
        }
中添加
  
并在}后另起一行，添加如下内容：
           \ {
                       
            _   
            _  
            _  _  ___
                    _
        }
添加完成后，代码区段的代码情况如下：
          {
             
        }

           \ {
                       
            _   
            _  
            _  _  ___
                    _
        }
然后，进入刚才所列的路径：
  
下载
  _

这里可能受服务器影响，北京机房下载速度不错，上海可能慢点。

解压文件
   _
更改与备份文件夹现有文件：
   
移动文件
   
访问你服务器的地址，进行最后一步的安装。

安装情况同上节相关子节，请参见上一节的相关子节

小结
这是最传统的安装方法，学习这样的安装方法主要还是为了熟悉环境的命令操作与文本编辑。可以有效学习各种组件的调用执行原理。建议人人都会。

相关推荐 【腾讯云的种玩法】几种在腾讯云建立的方法二如何在腾讯云快速构建一个个人站点 免费体验腾讯云服务器，快速上云随着国内服务共享化的热潮普及，共享单车，共享雨伞，共享充电宝等各种服务如雨后春笋，随之而来的服务定位问题成为了后端服务的一个挑战。对查询的支持较为友好，也是各大服务商的首选数据库。腾讯云团队在运营中发现，原生在服务场景下有较大的性能瓶颈，经腾讯云团队专业的定位分析与优化后，云在服务的综合性能上，有倍以上的提升。腾讯云提供的优异综合性能，为国内各大服务商，例如摩拜单车等，提供了强有力的保障。
业务特点
以共享单车服务为例，业务具有个特点，分别是时间周期性和坐标分布不均匀。
一．时间周期性
高峰期与低谷期的量相差明显，并且高峰期和低峰期的时间点相对固定。
二坐标分布不均匀
坐地铁的上班族，如果留意可能会发现，在上班早高峰时，地铁周围摆满了共享单车，而下班 时段，地铁周围的共享单车数量非常少。如下图，经纬度，附近集中了以上 的坐标。此外，一些特殊事件也会造成点的分布不均匀，例如深圳湾公园在特殊家假日涌入大量的客户，同时这个地域也会投放大量的单车。部分地域单车量非常集中，而其他地域就非常稀疏。

的服务原理
中使用_ 或__来创建地理位置索引两者差别不大，下面我们以_为例来介绍。
一．索引的创建与使用
{} {}
通过上述命令来创建一个索引，索引的精度通过来指定，越大，索引的精度就越高。更大的带来的插入的可以忽略不计
{
 
 
 
 
    
 |}
通过上述命令来查询一个索引，其中：| 表示应该如何理解创建的索引，表示将索引理解为平面索引，表示将索引理解为球面经纬度索引。这一点比较有意思，一个索引可以表达两种含义，而不同的含义是在查询时被理解的，而不是在索引创建时。
二．索引的理论 使用的技术来构建索引见   文字链  。使用平面四叉树划分的方式来生成，每条记录有一个，通过的索引映射方式存储在中很显然的，一个的精度能把平面分为个，一个的精度能把平面分为个。索引的默认精度是长宽各为，索引把地球分为块，每一块的边长估算为 =  米的官网上说的的精度就是这么估算出来的                               
三索引在中的存储
上面我们讲到使用平面四叉树的方式计算。事实上，平面四叉树仅存在于运算的过程中，在实际存储中并不会被使用到。
插入对于一个经纬度坐标，计算出该坐标在平面内的编号，该编号为是一个的类型，该类型被用作的，因此实际数据是按照 {}的方式被插入到中的。
查询对于索引的查询，常用的有和两种。查找距离某个点最近的个点的坐标并返回，该需求可以说是构成了服务的基础陌陌，滴滴，摩拜，是查询一个多边形内的所有点并返回。我们着重介绍使用最广泛的查询。
的查询过程查询语句如下

{
   
        
         
 {   }  
       
}
可以理解为一个从起始点开始的不断向外扩散的环形搜索过程。如下图所示：由于圆自身的性质，外环的任意点到圆心的距离一定大于内环任意点到圆心的距离，所以以圆环进行扩张迭代的好处是：减少需要排序比较的点的个数能够尽早发现满足条件的点从而返回，避免不必要的搜索在实现的细节中，如果内环搜索到的点数过少，圆环每次扩张的步长会倍增
 服务遇到的问题
部分大客户在使用的功能查找附近的对象时，经常会发生慢查询较多的问题，早高峰压力是低谷时段的倍，坐标不均匀的情况慢查询严重，濒临雪崩。初步分析发现，这些查询扫描了过多的点集。如下图，查找米范围内，距离最近的条记录，花费了，扫描了的记录。类似的慢查询占据了高峰期左右的查询量

测试环境复现与定位排查数据库的性能问题，主要从锁等待等待消耗三封面分析。上面的截图扫描了过多的记录，直觉上是或者消耗性的瓶颈。为了严谨起见，我们在测试环境复现后，发现慢日志中无明显的项排除了执行层面的锁竞争问题，并选用较大内存的机器使得数据常驻内存，发现上述用例依旧需要以上的执行时间。核的资源针对截图中的，只能支持。为何扫描集如此大上面我们说过，搜索距离最近的点的过程是一个环形扩张的过程，如果内环满足条件的点不够多，每次的扩张半径都会倍增。因此在遇到内环点稀少，外环有密集点的场景时，容易陷入。如下图，我们希望找到离中心点距离最近的三个点。由于圆环扩张太快，外环做了很多的无用扫描与排序。这样的用例很符合实际场景，早高峰车辆聚集在地铁周围，你从家出发一路向地铁，边走边找，共享单车软件上动态搜索距你最近的辆车，附近只有三两辆，于是扩大搜索半径到地铁周围，将地铁周围的所有几千辆车都扫描计算一遍，返回距离你最近的其余的七八辆
问题的解决
问题我们已经知道了，我们对此的优化方式是控制每一圈的搜索量，为此我们为命令增加了两个参数，将其传入中。可以控制结果品质的下限，返回的前个一定是最靠近中心点的个点。用以控制扫描集的大小的上限。

 已经扫描的点集大小大于后，做模糊处理。已经返回的结果数大于后，做模糊处理。

该优化本质上是通过牺牲品质来尽快返回结果。对于国内大部分服务来说，完全的严格最近并不是必要的。且可以通过控制参数获得严格最近的效果。在搜索过程中，密集的点落到一个环内，本身距离相差也不会不大。该优化在上线后，将部分大客户的性能上限从单机提升了倍到以上。


和的对比
也加入了地理位置查询的功能，我们也将开源和云数据库进行对比。使用方式：        。在密集数据集场景下，使用腾讯云和开源的进行了性能对比。下图是在密集数据集上，在核机器上，单实例与单实例的测试对比。需要注意的是本身是单线程的内存缓存数据库。是多线程的高可用持久化的数据库，两者的使用场景有较大不同。
总结
原生的接口是国内各大应用的主流选择。原生在点集稠密的情况下，接口效率会急剧下降，单机甚至不到。腾讯云团队对此进行了持续的优化，在不影响效果的前提下，的效率有倍以上的提升，为我们的客户如摩拜提供了强力的支持，同时相比也有较大的性能优势。作者：晋中望 

接上篇   从源码简要分析基本调用流程我们从订阅过程、“变换过程”进行分析，下篇文章我们继续分析线程切换过程
线程切换过程
从上文中我们知道了能够帮助我们对数据流进行灵活的变换，以达到链式结构操作的目的，然而它的强大不止于此。下面我们就来看看它的又一利器，调度器：就像我们所知道的，是给数据流添加多线程功能所准备的，一般我们会通过使用、方法传入对应的去指定数据流的每部分操作应该以何种方式运行在何种线程。对于我们而言，最常见的莫过于在非主线程获取并处理数据之后在主线程更新这样的场景了：这是我们十分常见的调用方法，一气呵成就把不同线程之间的处理都搞定了，因为是链式所以结构也很清晰，我们现在来看看这其中的线程切换流程。

当我们调用的时候：可以看到这里也是调用了去生成一个，而 则是实现了接口，同时将原始的和我们需要的传入：可以看出来，这里对的处理与前文中中对的处理很相似。在这里我们同样会根据传入的构造出新的，不过这一系列的过程大部分都是由通过去执行的，从后面中对于线程的判断，再结合方法的目的我们能大概推测出，这个在一定程度上就相当于一个新线程的代理执行者，所实现的与类中应该十分类似。我们现在来看看这个的执行过程。首先从进入：这个通过拿到的过程我们先不管，直接进，看它的方法：这里的是一个原子变量引用，所持有的则是，因而这个顾名思义就是用来保存的缓存池啦，我们从缓存池里拿到需要的并作了一层封装成为：在这里我们终于发现目标，它继承自，之前的方法最终都会到这个方法里：这里我们看到了线程池，我们用最终实现的线程切换的本质就在这里了。现在再结合之前的过程我们从头梳理一下：在时，我们会新生成一个，它的成员会在目标订阅时使用传入的的作为线程调度执行者，在对应的线程中通知原始发送消息给这个过程中临时生成的，这个又会通知到目标，这样就完成了的过程。

下面我们接着来看看：我们直接看最终调用的部分，可以看到这里又是一个，在这里传入了，它与不同，是一个的功能我们上文中已经讲过就不赘述了，它构造出了新的观察者并实现了接口：可以看出来，这里所有的发送给目标 的消息都被切换到了的线程作处理，也就达到了将线程切回的目的。


总结整体流程如下：对比和这两个过程，我们不难发现两者的区别：将初始的订阅事件整体都切换到了另一个线程；而则是将初始发送的消息切换到另一个线程通知到目标。前者把 “订阅  发送” 的切换了一个线程，后者把 “发送” 切换了一个线程。所以，我们的代码中所实现的功能其实是：这样就能很容易实现耗时任务在子线程操作，在主线程作更新操作等这些常见场景的功能啦。
其他角色
在系列是一个比较特殊的角色，它继承了的同时也实现了接口，也就是说它既可作为观察者，也可作为被观察者，他一般被用来作为连接多个不同、之间的纽带。可能你会奇怪，我们不是已经有了像、这类的操作符去变化 数据流了吗，为什么还要引入这个东西呢？这是因为所承担的工作并非是针对数据流内容的转换连接，而是数据流本身在、之间的调度。光这么说可能还是很模糊，我们举个《 》中的例子：
我们通过创建了一个，观察者成功订阅了这个，然而这个却没有任何数据要发送，我们只是知道他未来会发送的会是值而已。之后，当我们调用时，消息才被发送，的被触发调用，输出了 。
这里我们注意到，当订阅事件发生时，我们的是没有产生数据流的，直到它发射了 ，数据流才开始运转，试想我们如果将订阅过程和调换一下位置，那么就一定不会接受到 了这不是废话吗 |||，因而这也在根本上反映了的冷热区别。
一般而言，我们的都属于 ，就像看视频，每次点开新视频我们都要从头开始播放；而则默认属于 ，就像看直播，视频数据永远都是新的。基于这种属性，自然拥有了对接收到的数据流进行选择调度等的能力了，因此，我们对于的使用也就通常基于如下的思路：
在前面的例子里我们用到的是，它只会把在订阅发生的时间点之后来自原始的数据发射给观察者。等一下，这功能听起来是不是有些似曾相识呢？
没错，就是和。的出现慢慢让退出了舞台，现在的已经是状态了，而依旧坚挺基于的观察订阅取消的能力和的功能，我们十分容易就能写出实现了最基本功能的简易事件总线框架：
当然还有其他如、、等类型，大家可以去看官方文档，写得十分详细，这里就不介绍了。
三后记
前面相信最近这段日子里，提到，大家就会想到最近刚刚开源的。作为专门为打造的 框架，难免会被拿来与做对比。本文前面的主体流程分析已近尾声，现在我们再来看看这东东又是怎么一回事。
首先先上结论：
最初是为了  而开发的一个内部框架，现在开源出来了，它虽然是在之后才出现，但是完全独立于，与它没有任何关系只不过开源的时间十分微妙罢了。 与比起来，更加专注于的生命周期，而则更加纯粹地面向平台而非。
也许你可能会问：“那么呢，不是还有它吗？”事实上，早在版本的时候就进行了很大的重构，很多模块被拆分到其他的项目中去了，同时也删除了部分代码，仅存下来的部分多是和线程相关的部分，比如、等。鉴于这种情况，我们暂且不去关注，先把目光放在上。
同样也是基于观察者模式，和的角色分类大致相似，在中，主要角色有两个：被观察者、观察者。
是的，相较于中的，中的只是一个简单的接口，也没有范性的存在，亦是如此，这样我们要如何做到消息的传递呢？这就需要另外一个接口了：
终于看到了泛型，我们的消息的传递能力就是依赖于此接口了。所以我们将这个接口和基础的结合一下：
这里的在一定程度上就是我们想要的中的啦。类似地，也有两种类型的实现：

  所包含的数据总是可用的或者是可被同步计算出来的；一个的总是处于活跃状态下

  所包含的数据是异步计算或拉去所得；一个的直到有被添加进来之前都会是非活跃状态下是不是感到似曾相识呢？没错，也是有冷热区分的，不过我们现在暂且不去关注这一点。回到上面接着看，既然现在发数据的角色有了，那么我们要如何接收数据呢？答案就是：


相信看到这里，大家应该也隐约感觉到了：在的世界里，数据的传输与事件的传递是相互隔离开的，这是目前与系列的最大本质区别。所使用的是一种   的模型，这意味着并不会携带任何，在需要更新时，它自己会承担起从数据源拉取数据的任务。这样，提供数据的责任就从中拆分了出来交给了，让其自身能够专注于发送一些简单的事件如按钮点击、一次下拉刷新的触发等等。
那么，这样的实现有什么好处呢？
当这两种处理分发逻辑分离开时，就不必观察到来自的完整数据变化的历史，毕竟在大多数场景下，尤其是更新的场景下，最新的数据往往才是有用的数据。
但是我就是需要看到变化的历史数据，怎么办？
不用担心，这里我们再请出一个角色：顾名思义，就是我们用来存储变化中的数据的地方，它继承了、，也就相当于同时具有了接收数据，发送数据的能力。通过查看其具体实现我们可以知道它的本质操作都是使用内部的实现的：通过接收到数据后入列，通过拿到数据后出列。若一个观察了此，其队列中发生调度变化后即将出列的下一个数据如果是可用的非空，就会通知该，进一步拉取这个数据发送给。
现在，我们已经大概了解了这几个角色的功能属性了，接下来我们来看一段官方示例代码：
是不是有些云里雾里的感觉呢？多亏有注释，我们大概能够猜出到底上面都做了什么：使用需要的图片规格作为参数拼接到中，拉取对应的图片并用显示出来。我们结合来看看整个过程：

创建一个可运行抑或说执行的。初始化传入值是，它用来概括一些诸如、的操作的结果的不可变对象，并且存在两种状态、。返回

用于添加新的作为更新我们的图片的 ，本例中不需要。返回

在每一个  中若有来自多个 的处理时，只需开启一个数据处理流。返回

 …忽略输入值，使用来自给定的新获取的数据作为输出值。返回

切换到给定的继续数据处理流。

使用给定的变换输入值，若变换失败，则终止数据流；若成功，则取新的变换后的值作为当前流指令的输出。返回

若前面的操作检查为失败，就跳过剩下的数据处理流，并且不会通知所有已添加的。

与相似，区别在于当必要时会发出通知。返回

_用于明确不再时的行为。返回

执行这个。返回


整体流程乍看起来并没有什么特别的地方，但是真正的玄机其实藏在执行每一步的返回值里：初始的 代表着事件源的开端，它从传入值接收了 ，这里的中，第一个是当前的数据的类型，第二个则是数据处理流开端的时候的数据的类型。
之后，当调用后，我们传入事件源给，相当于设定好了需要的事件源和对应的开端，这里返回的是 ，它继承自，为其添加了事件源的发送频率的属性。
之后，我们来到了，这里明确了所开启的数据流的个数也就是前面所讲的频率后，返回了，这里也就意味着我们的数据流正式生成了。同时，这里也是流式调用的起点。
拿到我们的之后，我们就可以为其提供数据源了，也就是前面说的，于是调用，这样我们的数据流也就真正意义拥有了数据“干货”。
有了数据之后我们就可以按具体需要进行数据转换了，这里我们可以直接使用，返回，以便进一步进行流式调用；也可以调用来对可能出现的异常进行处理，比如、之后继续进行流式调用。
经过一系列的流式调用之后，我们终于对数据处理完成啦，现在我们可以选择先对成型的数据在做一次最后的包装，或是与另一个合并等。这些处理之后，我们的返回值也就转为了，进入了最终配置和声明结束的状态。在最终的这个配置过程中，我们调用了，为这个明确了最终进入非活跃状态时的行为，如果不需要其他多余的配置的话，我们就可以进入最终的方法了。当我们调用时，就会按照前面所走过的所有流程与配置去执行并生成这个。到此，我们的才真正被创建了出来。
以上就是从无到有的全过程。当诞生后，我们也就可以传输需要的数据啦。再回到上面的示例代码：
我们在、这两个生命周期下分别添加、移除了。相较于中通过去取消订阅的做法，的这种写法显然更为清晰也更为整洁。我们的实现了和接口，直接看其实现方法：

可以看到这里将数据发送给了，也就是自己，在对应的方法中接收到我们想要的后，这张图片也就显示出来了，示例代码中的完整流程也就结束了。
总结一下上述过程：

首先生成原点。

配置完之后进入状态，接着配置数据流的流数。

前面配置完成后，数据流生成，之后通过、、等方法可进一步进行流式调用；也可以使用方法代替原方法，后面接着调用、进行 处理。当使用方法时，数据流状态会变为，它代表此时的状态已具有终结数据流的能力，是否终结数据流要根据 触发，结合后面跟着调用的、，我们的数据流会从再次切换为，以便进行后面的流式调用。

经过前面一系列的流式处理，我们需要结束数据流时，可以选择调用方法，对数据流进行最终的处理，处理之后，数据流状态会变为 ；也可以为此行为添加 处理，选择方法，后面同样接上、即可，最终数据流也会转为状态。

此时，我们可以在结束前按需要选择对数据流进行最后的配置，例如：调用配置从“订阅”到“取消订阅”的过程是否需要继续执行数据流等等。

一切都部署完毕后，我们这个，得到最终的成型的，它具有添加、发送数据通知的能力。

我们根据需要添加，在数据流处理完成后会通过发送通知。

收到通知后则会拉取的成果数据，并将数据通过发送给。完成  ，   的流程。


以上就是一次的流式调用的内部基本流程。可以看到，除了  ，   这一特点、的加载模式本文未介绍等，依托于较为精简的方法，的流式调用过程同样也能够做到过程清晰，并且上手难度相较于也要简单一些，开源作者是的团队也让一些粉对其好感度提升不少。不过在本文撰写时则是 ，未来的版本还有很多不确定因素，相比之下系列发展了这么久，框架已经相对成熟。究竟用还是，大家按自己的喜好选择吧。
新人处女作，文章中难免会有错误遗漏以及表述不清晰的地方，希望大家多多批评指正，谢谢！

参考拓展：  给  开发者的  详解                     –   

文章来源公众号：空间终端开发团队

相关推荐
上一篇：   从源码简要分析基本调用流程之前写过几篇大数据的文章《遇见大数据可视化 ：基础研究》，《遇见大数据可视化 ： 来做一个数据可视化报表》，《遇见大数据可视化 ： 图表的视觉系统感知》。得到了身边不少小伙伴的认可，都觉得数据可视化是一件挺有意思的事情，纷纷投入到数据可视化上来。
但是很快一腔热血就被浇灭了，很多小伙伴都反映来说做数据可视化的学习成本太高了。从最开始数据的挖掘学习：，，语言等等，再到可视化图表的设计学习：，，，等等，还要看各种书籍。其实小伙伴的目标只是想简单的做一些不是很复杂的数据可视化，但陡峭的学习成本，让很多小伙伴望而却步，看到各种复杂的教程，简直是从入门到放弃。
那么有没有什么好的办法，可以不用学习这么多的知识点，而能做一些不太复杂的数据可视化图表出来呢？答案肯定是有的，那下面就手把手的带领大家，零代码来做数据可视化图表。
【生产力有两项，一项是人，一项是工具。工具是由人创造的。  毛主席】
想要零代码来完成数据可视化图表来，很简单，只要选好工具来就可以了。网上有很多介绍各种工具的文章，这里就不一一的去粗浅的介绍各种工具，而是深入的用案列的方式带大家了解我觉得还不错的可视化工具数据挖掘和可视化图表，目标的就是让大家可以零代码的做一些简单的可视化分析报表出来。
既然是按照案列的方式，那首先需要确定我们做什么主题。作为一个四川人，每次做自我介绍的时候，都会说到四川的美食，川菜作为中国八大菜系之一，还是深受广大人民的喜爱的。那么我们就用数据，来看看川菜和中国其他菜系鲁菜、川菜、粤菜、苏菜，浙菜、闽菜、湘菜、徽菜到底有什么不同，来做一个【中国八大菜系菜谱数据可视化图表分析】出来。
主题确定了，下一步就是数据的挖掘。 一般来说，基础数据的来源分为这几类。
自家数据 – 自家应用收集的数据。不对外输出，最好的数据来源，纯洁数据拿来就可以用。
行业报告 – 上市公司的年报、半年报、工商系统、股转系统。定期对外输出，有干扰项。
政府官方数据 – 国家统计局，中国环境监测总站，世界银行等。定期对外输出，或有接口，干扰项较少。
全网公开数据 – 拉勾、知乎、链家、雪球等公开网站的数据。需自己抓取数据，干扰项较多，一般都需要做二次数据清理。
那这次我们要做菜谱的分析，自家数据是没有的。行业报告和政府官方数据也没有这方面的数据。所以我们只能去网上自己爬取相关数据了。简单找了一番，就发现了很多的菜谱网站，比如【下厨房】、【美食天下】、【豆果美食】、【好豆网】等等，这些网站上面都有大量用户上传的各种菜谱。这里我选择【美食天下】来爬菜谱数据，因为【美食天下】刚好有按照菜系进行分类，这样我们在做二次数据清理的时候，就可以减少一个步骤了。
 
上图就是我们需要爬取的一条内容。有了爬取网站，确定了爬取内容。接下来就开始对数据开始爬取。怎么爬取呢？代码大神通常会推选用来做数据的爬取。
说好的零代码呢。这时候就要给大家推荐第一款数据挖掘的工具了  【造数】 对于简单的数据爬取足够用的工具，简单的了解，分钟就能上手。
下面我们就开始进行数据的爬取。
第一步：输入需要爬取的网站地址，然后点击【开始爬取】。

第二步：设置爬取规则。点击【开发爬取】后，会进入这个界面，在这个页面进行爬取规则的制定就是选择出我们需要获取的内容，只需点击我们想要的内容即可，下图绿色区域就是我们需要的内容，然后点击【完成创建】。

第三步：执行下载数据。这步就可以下载数据了，只需三步造数就能得到想要的数据，而不需要各种配置。

下图就是下载下来的原始数据，大致是这样的，全部汇总在一个表中。在这里有菜谱名称，网站地址，和所需原料。当然不是所有内容都是我们需要用的，这时候就需要对原始数据进行清理，删除，汇总等处理。
因为数据量不大，对于原始数据的处理，我们直接选用来做了。

单个菜谱的原料是全部汇总在一个单元格中的，所以首先我们需要把原料分解到单个单元中去。原料是按照【、】来间隔的，那我们直接用【文本分列】直接处理就可以了。通过【文本分列】我们把原料分解到单个单元中，如下图所示。

文本分列后，把它聚合到一起，然后用【数据透视】即可统计出来每个原料的个数出来。再通过简单的降序排序，我们就能得到最终我们需要的数据了。

小结
在这一步我们完成了【中国八大菜系菜谱数据可视化图表分析】的一半的流程，及数据挖掘和清理汇总。在这里我们用到了两个工具，一个是【造数】用做数据的爬取，一个是【表格】用做数据的清理汇总。类似【造数】这类的爬虫软件其实挺多的，比如国内的集收客，八爪鱼。国外的，。但是我们的目标是能快速的上手做一些简单数据挖掘，所以这里给大家推荐的是造数，它规则提取足够简单，能通过可视化的简洁的方式来设置提取规则，同时爬取路线很清晰，很容易就能理解它是怎么运行的，从而快速上手。而【表格】也是我们办公常用的软件，对于数级不大数据源，我们完全可以用手动的来做数据清理汇总。
可视化图表
数据处理好后，我们就可以开始进入可视化图表制作这一步了。关于图表的制作，其实用就能完成的。不过图表的默认样式，和图表的对应数据的关系都做的十分不友好的，你很难能对应出数据和图表横纵坐标的关系。毕竟主要是做表格的，而非做图表的工具。这里就是给大家推荐第二款图表制作工具  【】 。把数据拆分出来，把图表的维度和数值列出来，通过拖拽的方式进行数据分析，完爆。
的具体使用过程就不在这里给大家贴出来了，感兴趣的去试试，很快就能上手开始做图表的了。下面我们就来看下，用做出的图表，来看看中国八大菜系鲁菜、川菜、粤菜、苏菜，浙菜、闽菜、湘菜、徽菜有什么不同。
我们在【美食天下】的网站中，一共爬取了篇菜谱，其中川菜就有篇，就占了总量的三分之一的量，全国人民还是都比较喜欢吃川菜的，真可为八大菜系之首的。而紧跟其后的就是粤菜，也有篇之多的。

我们把川菜和粤菜的的原料拿出来继续来看。
川菜前项分布是：盐、料酒、生抽、花椒、姜、葱、鸡精、白糖、蒜、干辣椒、八角、淀粉、郫县豆瓣酱和酱油。
粤菜的是：盐、白糖、酱油、生抽、姜、葱、鸡蛋、耗油、胡椒粉、酱油、老抽、香油、花生油、水和淀粉。
除去相同的东西，川菜出现最多就是各种重口味的花椒、辣椒、八角、豆瓣酱之类的。而粤菜是各种油油水水的东西。作为一个四川人，还是不能理解为什么需要放耗油来做菜，耗油不只是用在吃火锅的时候做蘸碟吗？还有居然没有豆瓣酱，豆瓣酱才是做菜的王道呀，炒菜放点豆瓣酱味道一下就来了。

再看下，把多个菜谱所有的原料进行统计下。盐是所有原料中使用最多的，以上的菜品都用到了盐。不过让我没想到的是排第二的是白糖：具大厨了解，加白糖多是为了上色，而非让味道变甜，而豆瓣酱在中已经没见了，果然豆瓣酱只有在四川才流行的。

我们再把调味品提出去，只看下主材的情况。在主材中鸡蛋出现了次，也就是说菜品用到了鸡蛋，上榜率相当高的。紧接着就是猪肉，这个也是意料之中的。如果把排骨等也归为猪肉的话，猪肉就是最多的了。但没想到的是有这么多菜品用到了香菜，而土豆这种我觉得应该用的很多的主材，却这么少。

，这边我们就只做简单的分析即可，如果有同学有兴趣，可以在分析下去，我这边就不继续展开去说了。
总结
在上述【中国八大菜系菜谱数据可视化图表分析】的案例中。我们通过【造数】、【表格】和【】这些工具的使用， 就能做到零代码的完成包括数据挖掘和图表制作的过程。所以想做数据的可视化展示并不难，只要我们开始动手去做，人人都可数据可视化图表来，这就是工具的价值。
所以我们设计中心也在思考，有没有可能在图表之上，提供更好的数据可视化工具，而不单只是做一个个单一的图表。集合图表、地图、大数据的整体可视化工具，我们在这个方向前进，推出一款更好打大数据可视化工具。业务背景介绍：腾讯云数据库产品中心  大数据及人工智能产品中心 前端从年初开始尝试    全家桶，期间经历了很多波折，到目前为止总共个项目，其中有个项目使用了该方案

一、开发噩梦
 在我看来除了提供统一的状态管理，最大好处就是实现 视图、业务逻辑 与 数据处理的分离，这样可以最大程度地去复用三个模块。

图： 对项目的模块拆分
从这种意义上来说，它是成功的，但是实际的开发过程中，却遇到很多问题，导致开发体验非常不友好。
、丑陋的 
做过  开发的一定对  不陌生，里面主要靠   来处理 。对于一个状态复杂的应用，一般使用 来进行模块拆分，进而减少 的长度，使得模块化的  可维护。实际应用中，往往比较考验开发者的模块划分能力，一些比较复杂的模块，不进行很好的拆分和重构，伴随着业务的变化   任然会增长很长。但如果你拆分得过细，与应用的状态树就会变得复杂。
下面是一个典型的表格 ：
  = {
    
     
     
     
      
     
}

    =   {
      {
         _
             {
                
                 
            }
         __重新加载
             {
                
                 
                  
            }
         __加载完成
             {
                
                 
                      || 
                 
            }
         ____全选
        {
             {} = 
                {} = 
              =  
              {
                =
            }
             { }
        }
         ____选中一项
        {
             { } = 
             { } = 
              {
                
            }  {
                
            }
             { }
        }
         __
        {
            {
                  = 
                  = 
                  {
                      {
                         == {
                             = 
                        }
                    }
                }
                 {  }
            }{
                 
            }
        }
        
             
    }
}
、令人头晕的开发体验
 要实现 视图、业务逻辑 与 数据处理的分离，其实默认要求开发者开发过程是纵向的，但实际的开发过程中，大多数人的开发过程是横向的，如下图：

图：开发过程
这就导致一个问题，开发者会在 、、 三者来回切换开发，在阅读一个项目源码的时候，也需要来回切换查阅，才能清晰地知道某个模块的逻辑。当模块的  足够多，足够复杂，并且你显示器又不够大的时候，上面的过程往往就会把你绕晕了。
二、如何更优雅地使用
经历了很多项目，我观察到  的一个代码特点，大量的   下都是简单的数据加工合成新的状态子树，这里可以通过统一的扩展覆盖方式来实现这个目标。
首先，我将  的方法设计为：
{
     ___
    {
         
         
               
    }
}
这样，依靠关键字  可以用来做  匹配，对应 里面的内容可以直接在原有状态子树的基础上扩展覆盖生成新的状态子树。
对应 的  设计如下：
 
     = {
         
        {}
        {}
    }
     {
      = { }
     
}
按照上述的方法，我们就解决了 的问题，在这里的作用就只有   的回溯才会用到。
还可以近一步地优化，可以写一个方法来返回  方法，这样就不用再重复写相同  的扩展逻辑，如下：
   {
      =   = {
          = 

        没有更新的状态，不进行处理
          == {
             
        }

        只更新原始状态子树有的属性
          = { }
          = {}
           {
            {
                 = 
            } {
                 = 
            }
        }


         
    }
}

生成 
  = {
     
    {}
    {}
} 

  = {
     
     
     
} 

组合 
  = {
     
     
}
最后还可以近一步创建一个函数分析状态对象，自动生成 ，使得接口调用更简单，对整个  状态树更直观，如下：
 {
      = {}
       {
          = 
         =  
    }
     
}

{
    {
         
        {}
        {}
    }
    {
         
         
         
    }
}
三、最后
回到第一张图  的本意应该是数据与业务分离，数据处理的代码被分割到  里，而业务逻辑放到  里，而上述的优雅方案从某种程度上来会打破这种设定。但我想说的是这是一种折中，将  代码压缩掉，剩余的数据处理代码不可避免的分散到 里，经过实际项目经历，其他同事均反馈开发效率与代码阅读体验得到很大提升。
当然最后的这个工具也保留了对原生  的兼容方法。今天云头条发了篇文章《哎！无奈，遇到到底应该怎么办？阿里云将你扔进黑洞；腾讯云清退你！》，提到了一些网站在各家公有云厂商上遭遇分布式拒绝服务攻击后被公有云限制服务的无奈现状。我虽然从来没有正儿八经的做过安全，但是在互联网圈子混迹这么多年，也耳濡目染的知道一些基本的安全常识，而且由于协助一些公益网站做优化的关系，跟一些小黑客也有过几次小对抗，我来讲讲作为安全门外汉对这个问题的粗浅认识。
、误解
先讲一个普遍的误解。近年来攻击越来越频繁，攻击流量越来越大，有很多人误以为是因为黑客掌握了越来越多的带宽资源可以发动越来越猛烈的攻击。实际上黑客掌握的攻击流量未必上升了，更可能的是越来越多的黑客掌握了反射式攻击的能力。
反射式的攻击形式可以这么理解：

有黑客伪装成你的样子，朝黑猩猩扔了一块石头，黑猩猩扭头一看，好哇你敢扔我石头，我砸死你，从地上检了十几块砖头都吵你丢过来。

丢一块石头给黑猩猩它会丢回来多少块石头呢？这里有个表。

图片来自此文，也推荐感兴趣的读者阅读
比如年月号，卖桃君还在锤子的时候，锤子有一次发布会遭遇了攻击，攻击形式其实就是表中放大倍数最大的反射式攻击。
但是根据年黑帽大会展示的新研究，攻击者正在改变 放大攻击战略 ，放弃而采用其他形式，尤其是，原因可能是大量被利用的服务器都做了修复，难以被利用了。
也就是说，看起来你遭遇了几十上百的攻击流量，十有八九攻击你的黑客其实只使用了几个的流量。
、反射式攻击的局限性
从上面的介绍中我们可以看到，黑客如果要对你发起非常大流量的攻击，就不得不依赖哪些能够实施反射式攻击的协议。好消息是，这些协议中并不包含我们最常用的这样的网络服务协议。
因为采用了这些协议，黑客也就无法对一个“域名”去发起大流量的反射式攻击，而只能对一个具体的地址去发起攻击。
、对抗
对抗这样的攻击形式，最重要的一点就是：
服务器的真实不要暴露出去，甚至于负载均衡的也不要暴露出去。
没事不要留一个靶子在外面给黑客没事打着玩。
那怎么把自己的服务器甚至于负载均衡的藏起来不让黑客知道，又能够继续提供服务呢？以前有很多公益网站也经常遭遇到黑客攻击，腾讯云的志愿者为他们提供技术对抗的基本套路就是：
使用内容分发服务。
不熟悉服务的同学可以移步搜狗百科 了解一下。本来想贴维基百科上的词条的，发现搜狗百科的词条解释更接地气。
基本上我们使用会有两种做法：
 回源到云服务器或者回源到负载均衡。
这对于提供动态服务的网站比较适用，可以配置的回源规则，让动态的请求被缓存秒，静态的请求  被长时间缓存，从而在隐藏服务器的同时还能实现动静分离。
：回源到云对象存储的，的再回源到云服务器或者云服务器主动把生成的静态资源推送给。
这只适用于全静态的网站服务。这样做真实服务器被做了双重隔离，安全性更高，服务器负载更低。
、代价
通过来做网站节接入如果这么好，那为什么大家没有都这么做呢？
首先，是被设计来分发静态的数据的。当然腾讯云也有设计来分发动态数据的，但是目前仍在内测。因此如果你的网站主要是提供动态数据的服务的，这样的数据二次分发有可能会降低分发效率。
更重要的是，用户的访问流量会被二次计费。
比如中的做法，所有已经被缓存的静态请求，你只需要为流量支付流量费用。但是所有的动态请求和第一次被访问，边缘节点和中间源还没有缓存的静态资源，你不但要为流量买单，在回源到你的服务器上获取最新数据的时候，你还要支付虚拟机的出带宽费用。
假如是中的做法，从回源到的流量通常已经少到可以忽略了，但是从回源到的回源流量也是需要支付费用的。
这对于小网站其实不是个问题，因为腾讯云为用户每个月都赠送的流量包，很多小网站都用不完，因此只要是采用流量结算模式也就没有额外费用。
对于规模比较大的网站，如果静态化程度高，并且采用足够好的动静分离方案，总体流量费用有时也是可以相比原来更低的，但是业务场景偏动态，就有可能需要多支付一些流量成本。
而且有一些网站，由于接入了以后分发能力大幅度提升，后台服务器压力大幅度降低，用户访问起来更流畅，也可能带来更多的访问量从而推高了流量费用。
总的来说，服务体量越大，越建议进行充分的动静分离。对于大客户，建议静态的资源尽量采用分发，动态的流量还是应该采购大禹这样的专业防护产品。
、局限性
通过透传的方式隐藏了服务器真实，能够使针对的攻击手段失去了攻击的靶子，不但包括了上面提到的反射式攻击手段，也包括更多传统的针对的攻击手段。但是对于针对域名访问的不一定有效，比如基于的假如黑客真的掌握了庞大的攻击流量而无需通过反射式放大流量或者攻击。
好消息是，传统的攻击手段很多也有更加传统的对对抗手段。比如在腾讯云管理界面中的“域名管理——访问控制”界面下就提供了防盗链、黑白名单、访问限频等配置项目。很多流行的系统也会有对抗  攻击的配置项可以打开，比如我以前帮助一个公益机构的论坛进行过一次对抗 就只是开启了配置项目。
、安全的本质
很多人认为安全就是“无懈可击”，总是试图追求最高级别的安全。如果是非常大的机构，极其注重安全的产品，按照这个思路去做安全并不是不可以，比如直接采购专业的安全产品。
但是在我看来，这是一个“保卫者视角”看待问题的方式。没有尝试从攻击者的视角去完整的看待攻防的双方。攻击者的很多信息其实我们现在是有所了解的，他们的很多软肋我们也知道，所以无条件的死守有时不一定是最高效的。
在我看来，安全的实质就是降低保护者的成本，提升攻击者的成本，让攻击变得更加困难、更贵，让攻击获益更低，直到跨越某一个平衡点，攻击的成本高于攻击能获得收益。比如说，我们把原本非常便宜的反射式攻击、同步洪水攻击的门槛抬高到贵了几十倍的非反射式的攻击、攻击。如果你只是一个小网站，黑客花那么高的成本来攻击你真的值得吗？
毕竟，杀头的生意有人做，赔本的生意没人做。一、引言
在和服务器传输文本的时候，可能会因为某一个字符的编码格式不同、少了一个字节、多了一个字节等原因导致整段文本都无法解码。而实际上如果可以找到这个字符，然后替换成其他字符的话，那整段文本其他字符都是可以解码的，用户在上也许能猜测出正确的字符是什么，这种体验是好于用户看到一片空白。

代码的思路是对于无法用方法解析的数据，则逐个字节的进行解析。源码的一个分支如下：

检索未超过文件长度
{
    字节长的编码
    {正确编码，继续循环}
      字节长的编码
    {
          =  { }   
         
        {正确编码，继续循环}
        
        {替换字符}
    }
     个字节长的解码
}
发现无法解析的字符后进行替换。这个方法的弊端在于方法分配的字符串是堆空间，如果数据过长，则很容易产生内存碎片。
解决这个问题有两种思路：一是在栈空间分配内存，二是分配一个可以重复利用的堆空间。
二、的研究
从提供的参数看，调用者可以指定内存分配器。查阅官方文档对第一个参数 给出的释义：                    。接下来研究下这个内存分配器的数据结构以及系统提供的六个分配器的区别。
先看下的数据结构：
   __ __  
 __ {
     _
     _
     _
}
只考虑平台的话，__只有三个成员。其中 _是分配器的核心，其作用是可以自定义分配和释放的回调函数：
               
            
  {
    
            
        
    
} 
当系统使用这个分配器进行分配，释放，重分配等操作的时候会调用相应的回调函数来执行上面代码省略了部分回调函数，有兴趣深入了解的同学可查看的源码。
接下来看系统为提供的一系列分配器的源码只考虑平台。

：系统的分配和释放本质就是。

   __     
{     }
  __   
{}

看源码这个分配器在上和是一样的，但在的操作系统上是有区别的和__。

其实什么都不会做，直接返回。看文档说明主要是用于在释放的时候内存实际上不应该被释放。
  __     
{  }

是一个固定的地址，它只用于创建分配器的时候。表示创建分配器时使用自身的方法来分配内存。因为分配器也是一个对象。
   = 

这个是取系统当前的默认分配器，这个需要结合另外两个来理。解：和方法。源码中方法有一段有意思的注释：系统了两次，目的是为了在设置默认分配器的时候，之前的默认分配器不会释放。那这里不是会造成内存泄漏了吗？觉得要慎用。

这个才是系统级别的默认分配器，如果不调用，则用取出的分配器就是这个。从源码来看，目前和没区别也许很久之前因为__不是用实现的。后来兼容了，这里的故事有知道的欢迎告知


三、自定义分配器
看完系统提供的分配器后发现都是在堆空间分配内存，没有合适的。后发现系统提供了另外一个：。这时可以考虑自定义一个分配器，分配器在分配内存的时候，返回一块固定大小的内存重复使用。
      
{
     
}

        
{
    警告发生了内存重新分配
     不写这个回调系统也是返回的。这里简单的打句。
}

    
{
    因为的地址是外部传来的，所以应该由外部来管理，这里不要释放
}

  
{
      = 
      == 
    {
          = {        }
         = 
         =  
    }
     
}

 
{
      = {}
      = 

      =     
     
    {
         这里不要释放，这里分配的内存是的栈空间，由系统自己自己回收就好
    }
      
}
这里用了一个技巧是重复使用的内存首地址利用的来传递。的大小为什么是个字节呢？这个大小只要取需要的最大长度就可以了。如果自己项目需要引用这个方法，需要考虑这个需要设置多大。取决于的参数值，这里会有字节对齐的知识。
创建的也是在堆空间上，它也需要被释放。系统同样提供了释放：。这里需要注意的需要和时是同一个。否则无法释放，造成内存泄漏。
四、结语
自定义分配器让我们对内存的分配拥有了一定的可操作性，文中的应用场景是在创建对象时返回一块固定的内存区域重复使用，避免了重复创建和释放导致的内存碎片问题。这种可操作性相信以后在解决内存方面问题时会为你多提供一种解决方案。
的源码最近一次更新是日。这份源码最新也是基于的。在写这种底层代码的时候需要格外小心，作者在写的时候因为和的参数传的不同，导致内存泄漏，需要多多测试。发布到外网的时候需要加上灰度策略以及开关控制。
最后分享一个额外小知识，线程的默认栈空间大小是这个在苹果出了新系统和新机器后可能会变大，所以使用的时候尽量多测试。这里踩过坑，程序源码中一开始是临时变量，分配在栈上，但是由于字符串太长，导致栈溢出，所以后面分配在堆上了。
参考链接



_机器学习概念总结笔记一机器学习概念总结笔记三机器学习概念总结笔记四
逻辑回归
回归又称回归分析，是一种广义的线性回归分析模型，常用于数据挖掘，疾病自动诊断，经济预测等领域。例如，探讨引发疾病的危险因素，并根据危险因素预测疾病发生的概率等。以胃癌病情分析为例，选择两组人群，一组是胃癌组，一组是非胃癌组，两组人群必定具有不同的体征与生活方式等。因此因变量就为是否胃癌，值为“是”或“否”，自变量就可以包括很多了，如年龄、性别、饮食习惯、幽门螺杆菌感染等。自变量既可以是连续的，也可以是分类的。然后通过回归分析，可以得到自变量的权重，从而可以大致了解到底哪些因素是胃癌的危险因素。同时根据该权值可以根据危险因素预测一个人患癌症的可能性。
考虑具有个独立变量的向量设条件概率为根据观测量相对于某事件发生的概率。逻辑回归模型可表示为：
上式右侧形式的函数称为逻辑函数。下图给出其函数图象形式。

其中。如果含有名义变量，则将其变为变量。一个具有个取值的名义变量，将变为个变量。这样，有

定义不发生事件的条件概率为

那么，事件发生与事件不发生的概率之比为

这个比值称为事件的发生比     简称为。因为故。对取对数，即得到线性函数

假设有个观测样本，观测值分别为。设为给定条件下得到=原文的概率。在同样条件下得到=的条件概率为。于是，得到一个观测值的概率为

 因为各项观测独立，所以它们的联合分布可以表示为各边际分布的乘积。

上式称为个观测的似然函数。我们的目标是能够求出使这一似然函数的值最大的参数估计。于是，最大似然估计的关键就是求出参数，使上式取得最大值。对上述函数求对数

上式称为对数似然函数。为了估计能使取得最大的参数的值。
对此函数求导，得到个似然方程。

 上式称为似然方程。为了解上述非线性方程，应用牛顿－拉斐森方法进行迭代求解。
贝叶斯分类
贝叶斯分类器的分类原理是通过某对象的先验概率，利用贝叶斯公式计算出其后验概率，即该对象属于某一类的概率，选择具有最大后验概率的类作为该对象所属的类。先验概率 是指根据以往经验和分析得到的概率，如全概率公式，它往往作为由因求果问题中的因出现的概率·。后验概率是指在得到“结果”的信息后重新修正的概率，如贝叶斯公式中的。是“执果寻因”问题中的果。先验概率与后验概率有不可分割的联系，后验概率的计算要以先验概率为基础。后验概率实际上就是条件概率。目前研究较多的贝叶斯分类器主要有四种，分别是：、、和。
朴素贝叶斯分类器  或 发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。同时，模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给模型的正确分类带来了一定影响。左图是朴素贝叶斯网络，之间独立，右图表示一般贝叶斯网络，之间存在关联关系。贝叶斯网络不可成环。

     增强树贝叶斯分类器，算法通过发现属性对之间的依赖关系来降低中任意属性之间独立的假设。它是在网络结构的基础上增加属性对之间的关联边来实现的。实现方法是：用结点表示属性，用有向边表示属性之间的依赖关系，把类别属性作为根结点，其余所有属性都作为它的子节点。通常，用虚线代表所需的边，用实线代表新增的边。属性与之间的边意味着属性对类别变量的影响还取决于属性的取值。这些增加的边需满足下列条件：类别变量没有双亲结点，每个属性有一个类别变量双亲结点和最多另外一个属性作为其双亲结点。找到这组关联边之后，就可以计算一组随机变量的联合概率分布如下：其中Π代表的是的双亲结点。由于在算法中考虑了个属性中个两两属性之间的关联性，该算法对属性之间独立性的假设有了一定程度的降低，但是属性之间可能存在更多其它的关联性仍没有考虑，因此其适用范围仍然受到限制。
    分类器进一步扩展ＴＡＮ分类器，允许各特征结点之间的关系构成一个图，而不只是树。
 分类器作为分类器对应一组贝叶斯网，类结点的每个可能取值均对应一个贝叶斯网。ＢＭＮ可看作是ＢＡＮ的推广，ＢＡＮ认为对各个不同的类各特征之间的关系是不变的，而ＢＭＮ则认为对类变量的不同取值，各特征之间的关系可能是不一样的。
   广义贝叶斯网络是一种无约束的贝叶斯网分类器，和其他贝叶斯网分类器有较大区别的是，在其他分类器中均将类变量作为一特殊的结点，是各特征结点的父结点，而ＧＢＮ中将特征结点作为一普通结点。ＧＢＮ假设对整个数据集有一单一联合概率分布，而ＢＭＮ则认为对不同的分类有不同的联合概率分布。因而对那些数据集有单一内在概率模型的应用使用ＧＢＮ更合适，而对那些不同类的数据集其特征之间的依赖关系差异较大的应用场合，则使用ＢＭＮ更合适。
     懒惰贝叶斯规则分类器
  隐朴素贝叶斯
   基于多重判别分析的朴素贝叶斯
支持向量分类
支持向量机   名字听起来很炫，功能也很炫，但公式理解起来常有眩晕感。所以本文尝试不用一个公式来说明的原理，以保证不吓跑一个读者。理解有四个关键名词： 分离超平面、最大边缘超平面、软边缘、核函数 。
分离超平面     ：处理分类问题的时候需要一个决策边界，好象楚河汉界一样，在界这边我们判别，在界那边我们判别。这种决策边界将两类事物相分离，而线性的决策边界就是分离超平面。
最大边缘超平面   ：分离超平面可以有很多个，怎么找最好的那个呢，的作法是找一个“最中间”的。换句话说，就是这个平面要尽量和两边保持距离，以留足余量，减小泛化误差，保证稳健性。或者用中国人的话讲叫做“执中”。以江河为国界的时候，就是以航道中心线为界，这个就是最大边缘超平面的体现。在数学上找到这个最大边缘超平面的方法是一个二次规划问题。
软边缘  ：但世界上没这么美的事，很多情况下都是“你中有我，我中有你”的混杂状态。不大可能用一个平面完美的分离两个类别。在线性不可分情况下就要考虑软边缘了。软边缘可以破例允许个别样本跑到其它类别的地盘上去。但要使用参数来权衡两端，一个是要保持最大边缘的分离，另一个要使这种破例不能太离谱。这种参数就是对错误分类的惩罚程度。
核函数 ， 为了解决完美分离的问题，还提出一种思路，就是将原始数据映射到高维空间中去，直觉上可以感觉高维空间中的数据变的稀疏，有利于“分清敌我”。那么映射的方法就是使用“核函数”。如果这种“核技术”选择得当，高维空间中的数据就变得容易线性分离了。而且可以证明，总是存在一种核函数能将数据集映射成可分离的高维数据。看到这里各位不要过于兴奋，映射到高维空间中并非是有百利而无一害的。维数过高的害处就是会出现过度拟合。
所以 选择合适的核函数以及软边缘参数就是训练的重要因素 。一般来讲，核函数越复杂，模型越偏向于拟合过度。在参数方面，它可以看作是 算法中的的倒数，越大模型越偏向于拟合过度，反之则拟合不足。实际问题中怎么选呢？用人类最古老的办法，试错。
常用的核函数有如下类：：使用它的话就成为线性向量机，效果基本等价于回归。但它可以处理变量极多的情况，例如文本挖掘。：多项式核函数，适用于图像处理问题。 ，高斯核函数，最流行易用的选择。参数包括了，其值若设置过小，会有过度拟合出现。：反曲核函数，多用于神经网络的激活函数。
分类决策树
算法是一种贪心算法，用来构造决策树。算法起源于概念学习系统，以信息熵的下降速度为选取测试属性的标准，即在每个节点选取还尚未被用来划分的具有最高信息增益的属性作为划分标准，然后继续这个过程，直到生成的决策树能完美分类训练样例。
算法最早是由罗斯昆  于年在悉尼大学提出的一种分类预测算法，算法的核心是“信息熵”。算法通过计算每个属性的信息增益，认为信息增益高的是好属性，每次划分选取信息增益最高的属性为划分标准，重复这个过程，直至生成一个能完美分类训练样例的决策树。
决策树是对数据进行分类，以此达到预测的目的。该决策树方法先根据训练集数据形成决策树，如果该树不能对所有对象给出正确的分类，那么选择一些例外加入到训练集数据中，重复该过程一直到形成正确的决策集。决策树代表着决策集的树形结构。决策树由决策结点、分支和叶子组成。决策树中最上面的结点为根结点，每个分支是一个新的决策结点，或者是树的叶子。每个决策结点代表一个问题或决策，通常对应于待分类对象的属性。每一个叶子结点代表一种可能的分类结果。沿决策树从上到下遍历的过程中，在每个结点都会遇到一个测试，对每个结点上问题的不同的测试输出导致不同的分支，最后会到达一个叶子结点，这个过程就是利用决策树进行分类的过程，利用若干个变量来判断所属的类别。
以下是一些信息论的基本概念：
定义：若存在个相同概率的消息，则每个消息的概率是，一个消息传递的信息量为
定义：若有个消息，其给定概率分布为=…，则由该分布传递的信息量称为的熵，记为。
定义：若一个记录集合根据类别属性的值被分成互相独立的类，则识别的一个元素所属哪个类所需要的信息量为=，其中为…的概率分布，即=||||…||||
定义：若我们先根据非类别属性的值将分成集合…，则确定中一个元素类的信息量可通过确定的加权平均值来得到，即的加权平均值为：
 ==   求和||||
定义：信息增益度是两个信息量之间的差值，其中一个信息量是需确定的一个元素的信息量，另一个信息量是在已得到的属性的值后需确定的一个元素的信息量，信息增益度公式为：
 = 
衍生出来了和决策树算法。
信息增益实际上是算法中用来进行属性选择度量的。它选择具有最高信息增益的属性来作为节点的分裂属性。该属性使结果划分中的元组分类所需信息量最小。对中的元组分类所需的期望信息为下式：

又称为熵。
现在假定按照属性划分中的元组，且属性将划分成个不同的类。在该划分之后，为了得到准确的分类还需要的信息由下面的式子度量：

信息增益定义为原来的信息需求即仅基于类比例与新需求即对划分之后得到的之间的差，即
一般说来，对于一个具有多个属性的元组，用一个属性就将它们完全分开几乎不可能，否则的话，决策树的深度就只能是了。从这里可以看出，一旦我们选择一个属性，假设将元组分成了两个部分和，由于和还可以用其它属性接着再分，所以又引出一个新的问题：接下来我们要选择哪个属性来分类？对中元组分类所需的期望信息是 那么同理，当我们通过将划分成个子集=…之后，我们要对的元组进行分类，需要的期望信息就是而一共有个类，所以对个集合再分类，需要的信息就是公式了。由此可知，如果公式越小，是不是意味着我们接下来对分出来的几个集合再进行分类所需要的信息就越小？而对于给定的训练集，实际上已经固定了，所以选择信息增益最大的属性作为分裂点。
但是，使用信息增益的话其实是有一个缺点，那就是它偏向于具有大量值的属性。什么意思呢？就是说在训练集中，某个属性所取的不同值的个数越多，那么越有可能拿它来作为分裂属性。例如一个训练集中有个元组，对于某一个属相，它分别取这十个数，如果对进行分裂将会分成个类，那么对于每一个类=，从而式为，该属性划分所得到的信息增益最大，但是很显然，这种划分没有意义。
更多详见：机器学习概念总结笔记一机器学习概念总结笔记三机器学习概念总结笔记四微软的都已经推出到了，由于项目的需要不得不在 的服务器上继续沿用其原来购买的。那问题就来了，因为在。上对并不友好在安装过程中会报错在几经努力下，终于找到一个好的解决方法。方法如下
按正常流程安装任一版本的  。
在安装到服务的时候会弹出启动服务失败的提示这个时候什么都不要按先备份个重要的文件 和目录在 \ 。 \\\也有可能在下面
备份后可以用 版本中的和替换当然也可以下载相关的文件。
下载地址
替换后就可以点击重试然后就顺利安装成功。
安装成功后要先把 服务停止，把原来备份的文件还原回去因为不还原是没办法打的补丁的。
再安装  就完美执行了。
这样 就可以在  上运行了。在上一篇文章中，我们已经学会了在腾讯云服务器上搭建环境了，假设你已经在腾讯云服务器上搭建好了环境，我们将进入下一步：搭建爬虫环境。
一直在终端编写爬虫是不现实的，除非你在学习阶段，当我们要正式开始编写爬虫的时候我们理所应当的需要一个爬虫环境了。
第一部分：搭建爬虫环境
考虑到学习、使用便捷，我们将使用 开发爬虫： ，进入 官网，按照你的系统下载相应的版本，我这里下载的是 位的。

下载好之后，安装


选择安装目录，点击

勾选上    ，点击，最后点击，安装完成。安装完成之后到你之前配置的安装目录打开 ，你也可以复制一个快捷方式到桌面方便以后使用。
现在你就可以使用 来编写了，如若有什么不懂的地方可以访问 的官网查看文档。编写完代码之后，运行脚本，第一次运行的时候会出现以下界面，选择的一个行的即可。

第二部分：学会安装库
适合做爬虫是因为：有无数的开源作者无私的在开源社区做贡献，强大的库为我们提供了很多便捷的操作。有三种方法安装库，具体方法可以访问：_ 
中绝大部分的库都可以使用进行安装，也是最简单的安装方法，使用安装第三方库只需要使用命令：   库名，比如我需要安装一个叫的库，我只需要在终端执行  
出现：  则表示安装成功。
第三部分：你不得不知的库
在编写爬虫的时候我们可能需要以下一些比较常用的库，这里我们做一个简单的介绍，方便后续的使用。
、
 是用语言编写，基于 ，采用   开源协议的  库。它比  更加方便，可以节约我们大量的工作，完全满足  测试需求。 的哲学是以   的习语为中心开发的，所以它比  更加 
安装命令：  
、
 提供一些简单的、式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序
安装命令：  
、
 包用于解析和文件，可以使用和定位元素
安装方法：  
第四部分：寻找你需要的库
当以上库不能满足你需求的时候，你就需要学会自己寻找库了。首先访问一个项目：
在这个项目中，作者把所有的资源包括库资源等分成了几十个大类：数据挖掘、数据可视化、日期和时间处理、数据库相关……等等，在每个大类中归类了该类下的所有资源，并且该资源的首页有各个大类的索引。 
在这个大背景之下，假设我现在想找一个操作的库，我们就首先点击最上面的索引： 直接跳转到数据库相关库的地方。

跳转之后，如下界面，我们就可以直接寻找到我们需要的库了。

当然，因为所有的资源都在同一个页面，所以我们同时可以使用浏览器自带的搜索功能，在下是，在该页面直接搜我们需要的某个功能关键词，比如：，

当然，这样搜索出来的结果可能不仅仅是一条，就需要你自己排查以下哪一个才是你真正那个需要的库资源了。

相关推荐
【腾讯云的种玩法】云服务器搭建环境
操作  云爬虫初探
腾讯云主机环境安装爬虫框架过程导语
随着直播平台爆发式增长，直播平台从  端转战移动端，紧跟着直播的潮流，自己学习实现了一套简单的  视频推流的解决方案，下面就给小伙伴们分享一下自己学习过程中的经验。
环境部署
、 配置、安装 ；
  = = __ = = =
 
  
     启动
   |  
 、扩展 
  = =
 
  
  
 
  
 {
     {
         

          {
             

             
            _ 
            __ 
            _ 
            _ 

            _ 
            _ 
            __ _
        }

              {
             
             
            _ 
            _      每个视频切片的时长。
            __   总共可以回看的事件，这里设置的是分钟。
            _  连续模式。
            _     对多余的切片进行删除。
            _      嵌套模式。
        }
    }
}

 {
     {
              

          {
            _ 
            __ 
        }

          {
             
        }

          {
            _ 
        }

          {
             
        }

              {
              
            {
                 
                 
            }
             
             
             
        }

          {
             
        }
    }
}
   
    查看端口的监听情况
、 安装        
  =
 
  
至于  是啥？详细介绍可以参考：《【经验分享】音频、视频利器——》
模拟推流

先来看一个简单的直播推流流程图 ：



用  视频文件模拟  视频流： 

            
注：   ，实时消息传输协议，用于视频直播协议，和  一样都可以应用于视频直播；  

用  视频文件模拟  视频流：

        
注：  ，  的动态码率自适应技术，主要用于  和  终端的音视频服务；

 的请求流程：


 如何在页面上播放视频
        
         = =       
         =         
    
总结
根据以上的流程，简单的实现了一个视频直播的流服务器来推送直播流，并且可以在  页面上播放视频流。有兴趣的小伙伴们也可以尝试一下游戏社交化是近年来游戏行业发展的重要趋势，实时互动的实现和社交平台的能力是游戏社交化的两大关键。游戏中玩家的沟通协作从最初的文字交流，逐渐发展为音、视频结合的多场景下的实时互动，是游戏中社交关系建立和维持的关键因素。另外，游戏社交需依托于平台，如何构建玩家间的社交网是各大游戏厂商的重要考虑点，这对平台的能力提出了很高的要求。
本期腾讯云沙龙，与您一一探讨！
演讲主题：腾讯游戏云生态产品规划及最新进展嘉宾简介：

王永和 腾讯游戏云产品总监负责腾讯游戏云产品规划及发展。关注游戏行业生态，致力于腾讯内部游戏生态和技术能力开放，以及周边游戏生态资源整合。
演讲概要：腾讯云游戏业务中心除了为游戏提供灵活而稳定的部署解决方案外，同时也秉承腾讯公司”开放“的战略理念，将腾讯内部领先的游戏开发技术和丰富的游戏服务资源，向外部游戏开放，并共享大平台优质渠道资源、以及提供丰厚的专项扶持金，助力您的游戏业务腾飞。
下载：
关于：系列沙龙由腾讯云主办，旨在为游戏开发者提供一个自由的交流分享平台。沙龙将围绕游戏行业趋势、研发技术、运维和推广等热点进行探讨。每期沙龙将邀请国内外游戏领域专家，分享游戏开发及运营过程中的思考和实践。
访问沙龙官网 ，了解最新沙龙资讯和更多往期回顾。作者：

概述
                           
 是一个无界面的内核浏览器，你可以把它当作一个没有界面的 。
安装
目前  的最新版本的，官方文档中有提到说：如果在使用老版本时碰到一些难解的  ，可以升级到最新版试试。

直接下载  ，并解压，将  文件夹中的可执行文件的路径添加到环境变量后可能需要重启机器才能生效，就可以在命令行环境 或  中使用   命令执行  文件了。

安装二进制文件包
可以在  下载已经编译好的二进制文件安装包，不过目前  提供到  的安装包，最新的  还没有发布。安装方式：

下载_

进入安装目录，解压二进制文件

  
   _


创建软链接指向解压出来的文件夹，或将解压出来的文件夹重命名为

   _ 

编译源码的方式
由于  模块中有数千个文件，因此由源码编译  会花费很长的时间，文档上说，开四个并行的进程进行编译工作，需要超过分钟的时间，因此官方文档推荐直接下载和安装二进制文件。
具体的安装方法，这里就不再赘述，大家可以到官方文档上查看。
是否安装成功
我们可以使用下面的命令来查看  是否安装成功：
  

命令运行  即可执行一个  程序。
 模块
 是  的核心模块，你可以通过以下方式，获得一个  模块的实例：
  = 
     = 


打开一个  链接，并加载对应的页面，一旦页面加载完成，就会触发回调，你也可以使用方法来监听页面是否加载完成。下面，我们来用  方法打开腾讯课堂：
  = 

  {
     ==  {
         
    }
    
}

上面的代码中， 方法接受了两个参数。第一个参数是要打开网页的 要记得加协议头哦！，默认使用  方法打开，第二个参数是回调参数，网页加载完成后该函数将会执行，它的参数表示网页是否打开成功，打开成功就是，否则就是。要注意的是，只要收到服务器返回的结果，参数就是，即使服务器返回的是或错误。
我们也可以使用其他的方法打开页面。
  = 
  = 
  = ==

    {
     
      
}

上面的代码是官方文档的事例，使用方法向服务器发送数据。方法的第二个参数用来指定方法，第三个参数用来指定该方法所要使用的数据。
从 开始，我们还可以使用对象来对请求进行更详细的配置。
  = 
  = 
  = {
   
   
   {
     
  }
   {
     
      
  }
}

   {
     
      
}


在打开一个网页后，我们往往有对其进行操作的需求，例如模拟点击登陆按钮、获取某个元素等等，也就是需要在页面中执行代码，这时候我们就需要使用到方法。
 获取打开页面的
  = 

  {
    =  {
     
  }
       
  
}

由于因为方法相当于一个沙盒，在其中是无法访问之外的变量的。那如何将我想要获取的元素的传进呢？
从 开始，我们可以将外部变量以如下的方式传给内部，需要注意的是，能传入方法内部的参数只能是简单的基本类型，例如数值、字符串、对象等能被序列化的类型，而无法接受更复杂的对象，它的返回值也同样如此。
=  {
    = _
    =  {
     
  } 

  
  

}

由于方法打开的网页内部的  语句，和  方法中的  语句都不会执行，给我们开发调试带来了不便。这时可以采用  回调函数，来打印出上面两种情况中的  语句中的信息：
  = 
  = 

 =    {
                    
}

其中  是需要打印的信息， 和  是  在文件中的行号以及这个文件对应的标识 。

可以使用 方法加载外部脚本，例如 。
  = 
  = 

  {
     ==  {
         
    }
      {
       {
                   
            = 
          =
          =
          
      }
      
    }
}

注意，由于是异步加载脚本，所以需要放在的回调函数中，否则进程会过早退出。

 可以将打开的网页截图并保存成本地图片，可以将指定的图片文件名作为参数传入， 方法可以根据文件名的后缀将图片保存成对应的格式。目前支持、、、四种图片格式。
  = 
  = 

 = {     }
   {
  _ {   }
  
}

该方法的第一个参数是保存的文件名，第二个可选参数是一个  对象， 指定图片格式，  指定区间内的图片质量，必须是整数。

当页面去请求一个资源时，会触发  方法的回调函数。回调函数接受两个参数，第一个参数是这个请求的元数据对象，包括以下属性：

 所请求资源的号，这个应该是给标识的。

 所使用的方法等。

 所请求资源的

 包含请求该资源时间的一个对象。

 该请求的请求头中的信息数组。


第二个参数包含以下方法：

 终止当前的网络请求，这会导致调用回调函数。
：改变当前网络请求的。
 ：设置头信息。

  = 
  = 

 =   {
          
}

  {
     {
        
    }
    
}


属性用于指定一个回调函数，当网页收到所请求的资源时，就会执行该回调函数。回调函数只有一个参数，就是所请求资源的服务器发来的 的元数据对象，包括以下字段。

：所请求的资源编号，此编号标识。

：所请求的资源的 

：包含回应时间的对象

：响应的头信息数组

：解压缩后的收到的内容大小

：接到的内容种类

：重定向如果有的话

：对于多数据块的回应，头一个数据块为，最后一个数据块为。

：状态码，成功时为。

：状态信息，比如。


需要注意的是，该方法收到的对象是没有的具体内容的。
可以利用正则表达式，来筛选出我们想要操作的一些响应资源。比如我想从淘宝教育的课程详情页跳转到购买页在淘宝网中，可以从淘宝同学请求的资源中筛选出带淘宝网商品详情页的商品，然后用这个淘宝网商品拼接成一个淘宝网的商品详情页，再次使用方法打开这个，就可以跳转到该课程的购买页中。
  = 
     = =
     = =
     = 
     = 
     = 
 =  {
      
}
 =  {
     = \\\|=\ {
         = 
        
        
    }
     获取课程对应的淘宝网商品
     = =\ {
         = 
    }
}
  {
     ==  {
         
        
    }
    ；
     打开课程对应的淘宝商品详情页。
        {
         ==  {
             
            
        }
         由于页面中的资源是动态加载的，需要  等待资源加载完，再操作页面。
         {
              =  {
                 获取课程交易量
                 _
                 
            }
              
              
            
        } 

    }

}

小栗子
动态获取淘宝商品详情页的商品交易量
相信大家都知道爬虫的基本方式无非是抓取页面中的 ，然后分析；但是页面中的  也些是静态的，有些事通过动态生成的，故爬虫也分抓静及抓动之分。
因为淘宝商品详情页的交易量是异步拉取的，在异步数据还没有返回时，页面上交易量那一栏只是一个无意义的“”，如图：

当异步数据返回后，才会显示出真正的交易量：

因此，
  = 
  = 
  = 
  = =


 =            

  {

     由于是拉取异步数据，我们打开页面后，等待再去操作，获取交易量
     {
          =  {
             _
        }
        
        生成当前页面截图
        
        
    } 
}

上执行命令：
  = 


上得到了交易量由于是打开协议头的网页，所以执行文件时，需要添加=参数
不能做什么

是一个阉割版的，不支持、、、 ，不想背负操作系统强相关的特性，跨平台比较困难。
如果使用模块的方法监听页面收到的请求资源，是无法得到该资源的的，这也是目前最受开发者吐槽的点之一。


原文链接：


相关推荐包学会之浅入浅出：开学篇关于错误捕获如何从到搭建个人站点在复制环境中，我们通常只根据 __ 的值来判断的延迟。这么做大部分情况下尚可接受，但并不够准确，而应该考虑更多因素。
首先，我们先看下  的状态：
    \
   
__      

__ 
___ 
__ 
__ 
___ 
__ 
__ 

_ 
___ 
__ 

__ 

可以看到 __ 的值是 ，也就是  至少延迟了  秒。
我们再来看下  上的  个  进程状态：
    \
   
 
  

 
 
 
      
 
   
 
  

 
 
 
 
      
可以看到  线程一直在执行  操作，注意到  的值是 ，看起来像是这个  操作执行了  秒，一个普通的  而已，肯定不至于需要这么久。
实际上，在  进程中， 这列的值可能有几种情况：
、 线程当前执行的 实际上是  中的  和  线程最新的  的差值，这就是通常大家认为的 __ 值，并不是某个  的实际执行耗时；
、 线程当前如果没有活跃  在执行的话， 值就是  线程的  ；
而  线程的  值则是该线程自从启动以来的总时长多少秒，如果系统时间在  线程启动后发生修改的话，可能会导致该  值异常，比如变成负数，或者非常大。
来看下面几个状态：
设置 ，只查看关注的几个  值
    |    |___|__|___

这是没有活跃  的情况， 值是  ，并且 __ 为 
      \
|  |   | |  |  |  |       |  |
|  |   | |  |  |  |     
___ 
___ 
__ 

和上面一样
      \
|  |   | |  |  |  |       |  |
|  |   | |  |  |  |     
___ 
___ 
__ 

这时有活跃  了， 值是和 __ 一样，即  线程比  线程“慢”了  秒
      \
|  |   | |  |  |  |       |  |
|  |   | |  |  |  |  |  
___ 
___ 
__ 

和上面一样
      \
|  |   | |  |  |  |       |  |
|  |   | |  |  |  |  |  
___ 
___ 
__ 
好了，最后我们说下如何正确判断  的延迟情况：
、首先看 ___ 和 __ 是否有差异；
、如果 ___ 和 __ 是一样的话，再来看 ___ 和 ___ 的差异，对比  线程比  线程慢了多少个  事件；
、如果 ___ 和 __ 不一样，那说明延迟可能较大，需要从  上取得  ，判断当前的  和  上的差距；
因此，相对更加严谨的做法是：
在第三方监控节点上，对  和  同时发起    和   \ 的请求，最后判断二者  的差异，以及 ___ 和 ___ 的差异。
例如：
在  上执行    的结果是：

| _ | _ |

|  |  |
|  |  |

而在  上执行   \ 的结果是：
__ 
 ___ 
___ 
__ 
__ 

___ 


__ 

这时候， 实际的延迟应该是：
 这个  中的    和  上读取到的   之间的差异延迟，即：
   =  个  
并且还要加上  这个  已经产生的个  ，共
   =  个  
后记更新：
、可以在  上维护一个监控表，它只有一个字段，存储这最新最新时间戳高版本可以采用 _ 来更新，低版本可以用  结合自动循环脚本来更新，在  上读取该字段的时间，只要  和  的系统时间一致，即可快速知道  和  延迟差了多少。不过，在高并发的系统下，这个时间戳可以细化到毫秒，否则哪怕时间一致，也是有可能会延迟数千个   的。
、网友李大玉，：细心支出上面的计算延迟有误，应该是  的最大事件数减去已经被执行完的事件数，即  – =  个  ，再加上  这个  已经产生的  个  ，共  个  。目前移动端越多越多的网页开始化，一方面可以减少安装包体积，另一方面也方便运营。但是相对于原生界面而言，的慢速问题一定被大家所诟病，针对这个问题，目前手存在几种方案，最常见的便是离线包方案，但离线包存在几个问题：

滞后性，内容显示不及时；
覆盖率，很难达到；
校验耗时，由于离线包的素材较多，加载时安全性校验非常多；

除了上面的缺陷外，对于一些架构的业务，离线包的支持也不是特别好。针对这些问题，业界存在一种基于长连接的新方案，专注于提高首屏的加载速度。的思路来源主要是由于端在初始化和拉取资源串行执行时都很耗时，如下图：
基于这一前提，把串行变并行，并利用长连接替换掉，另外一个突破是针对内容的动态性，增加了模板和数据分离，变化频率较多的数据定义为，变化频率较少的定义为，基本实现流程如下图：手机针对个别页面最开始采用的也是这种方案，不过在灰度过程中发现数据不理想，尤其是首次加载及模板变更时数据非常糟糕，仔细分析发现主要的原因包括下面几点：

长连接信令拉取资源时要经历跨进程、服务器中转、信令排队、加解密，导致时间过长；
长连接信令需要下载完整个才能塞给内核渲染，不能利用内核的边下载变渲染；
数据、模板变更时会引起整个页面重刷，导致体验很差。
异常时不会智能切换

针对这几点问题，为了让用户的体验达到更好，增值产品部提出了方案，第二部分我们来介绍一下具体的实现细节。
一实现细节
我们从两个场景来介绍具体实现。
第一种场景是用户首次或者缓存失效时加载页面，与一样，在初始化的同时也会并行发起连接，在初始化好之后会在内核与流之间建立桥接，桥接流在不同机型不同网速情况下可能有三种不同状态：全内存流、内存流网络流、网络流。在桥接流关闭时，我们会在终端根据模板数据拆分规则对进行内容分割，并记录模板和数据的信息，利用这些信息，可以在下次与服务器通信时进行数据校验和更新。具体实现思路如下：
第二种场景是用户二次进入页面，通过手灰度测试的观察这种场景的占比较高，普遍情况下会在七成以上。这种场景我们会优先加载缓存，并且根据返回码的同步状态，进行不同的处理。首先会根据做不同的智能开关处理；然后根据本地的缓存状态做不同的状态转换：如果完全命中缓存，则不作任何处理；如果发生模板变更，处理逻辑会有点复杂，会根据不同机型和网络环境做智能切换处理，速度较快时会拉取完流交给内核渲染，速度不快时仍然会建立桥接流，并且会对内容进行拆分；如果发生数据变更，会对数据进行处理，和页面通过进行通信进行刷新，这样做的好处一方面可以不影响用户的体验，另一方面速度也更快。具体实现思路如下：为了达到更好的效果，后续我们可能还会加入的优化，这样做的好处是减少域名劫持，不过目前的方案已经能达到非常不错的效果了。
二数据对比
 下面我们分别针对中心首页在四个场景的实验数据来进行对比端外网灰度数据基本一致，速度很快暂时没有采用此方案，图中每行的意义如下：

：点击到的首行时间；
：点击到的时间；
：点击到页面首行的执行时间；
：点击到准备好的时间；
：点击到页面交互的时间。

其中一般用来衡量页面加载时的总时间。
第一种场景是首次启动进程、无缓存时的数据，可以发现首次启动比加载耗时减少：
第二种场景是非首次启动进程、模板更新时的数据，可以发现比减少：第三种场景是非首次启动进程、模板不变数据更新的数据，比减少：第四种场景是非首次启动进程、完全命中缓存的数据，和的数据差不太多：从实验和手灰度的情况看，整体而言，在绝大部分场景下已经能够达到非常好的体验，后续我们也会继续进行进一步的优化，争取达到更好的体验效果。

相关推荐
页面性能监测  优化，让你的快如闪电！今天继续看   ：_
完整版教程可以看中文版：_
这一节讲了使用  数据集训练并评估一个简易前馈神经网络  
， 和前两节是一样的：即划分数据集并预测图片的 
_    个图像和标签，作为主要训练集。
_    个图像和标签，用于迭代验证训练准确度。
_    个图像和标签，用于最终测试训练准确度 。
主要有两个代码：

构建一个全连接网络，由  个隐藏层， 个 _输出构成定义损失函数，用 定义训练时的优化器，用 定义评价函数，用__
__ __

向 _ 传入  ，得到  和  的两个
定义生成 _的函数， 是 ， 是 
定义 _ 函数，每隔  个训练步骤，就对模型进行以下评估，分别作用于训练集、验证集和测试集
训练时：
导入数据
得到  和  两个 
传入  定义的  得到 
将  传给  计算 
 传给 进行优化训练
再用  评价预测值和实际值代码中涉及到下面几个函数：



 _即所有已经构建的操作都要与默认的  全局实例关联起来， 实例是一系列可以作为整体执行的操作
 = _：为了释放  所使用的  ，所有的即时数据都要在图表构建时合并至一个操作  中，每次运行  时，都会向   中写入最新的即时数据
_ = _ ：用于写入包含了图表本身和即时数据具体值的  。
 = ：就是向训练文件夹中写入包含了当前所有可训练变量值  
 _主要用于管理一个图里面的各种 ，返回的是一个以 _命名的  ，一个  会维护一个 _的堆，实现一种层次化的管理，避免各个  之间命名冲突。例如，如果额外使用 _ 定义的变量是不会被_ 当中的名字所影响的
__  ：意思是在  个最有可能的预测中如果可以发现 ，就将输出标记为 。本文  为 ，也就是只有在预测是  时，才判定它是 。今天，第五届腾讯大会在京举行，“超级网红”，“黑洞”理论提出者，剑桥大学教授史蒂夫霍金霍金，突破摄星执行董事、前艾姆斯研究中心主任 ，量子计算专家、图灵奖获得者姚期智院士，未来学家 、科幻作家、“雨果奖”奖得主郝景芳等大咖发表演讲。其中，霍金、 、姚期智这三位大咖都谈到了人类在地球之外建立家园的可能性，霍金更是带来了“摄星计划”的最新进展。科技大本营特别对这三位大咖的演讲进行编辑整理，希望对你有所帮助。
超级网红霍金：大胆前行，涉足无前人所及之处！
霍金详细阐述了他在去年四月提出的，可以拯救损耗过多的地球的“突破摄星”的计划，以及这一年间，这项震撼人心的计划取得的进展。

“网红中的战斗机 史蒂夫 霍金  
以下为霍金演讲实录：
你好，北京！我是史蒂芬•霍金。
我今天的演讲，是关于在宇宙这一背景下，地球和人类所扮演的角色。为了更好地阐述，我需要从两个维度出发，一是思考人类的未来，二是研究我们探索太空、寻求其他潜在宜居星球的选择。

今天，我想问大家两个问题。首先，我们需要怎么做，才能够确保人类的未来，能在力所能及的范围内，达到完美？其次，我们为什么要考虑探索其他宜居星球？
一个原因是，由于人口的增长，地球变得太小了。在过去二百年间，人口增长是指数级的，即每年人口以相同比例增长。目前这一数值约为。 这听起来可能不是很多，但它意味着，每四十年世界人口就会翻一番。 年，我将庆祝自己岁的生日。和我出生时相比，世界人口已经膨胀了四倍。
我认为，这样的指数增长不能持续到下个千年了。 到年，世界将拥挤得 “摩肩接踵”，电力的消耗将让地球变成“炽热”的火球。这是岌岌可危的。然而作为一个乐观主义者，我相信我们可以避免这样的世界末日。而避免末日最好的方法就是：移民到太空，探索人类在其他星球上生活的可能。
这是因为，在某种程度上，今天的情况就如同年前的欧洲。当时的人们都觉得，哥伦布的探险注定是徒劳无功的。 然而，新世界的发现，对旧世界带来了深远的影响。对于那些被剥夺权利地位、走投无路的人来说，新世界成为了他们的乌托邦。
而人类向太空的拓展，将彻底改变人类的未来，甚至会决定我们是否还有未来。它虽然不会解决地球上任何迫在眉睫的问题，但它将提供解决这些问题的全新视角，让我们着眼于更广的空间，而不是拘泥眼下。我希望，人类的视野能够望向太空，让我们团结起来，面对共同的挑战。

那当我们进入太空时，会有怎样的发现呢？会找到外星生命，还是发现我们终将在宇宙中踽踽独行？生命在地球上是自然而生的，是在漫长的进化后，实现了与地球资源的高度契合。因此，我们相信，在其他条件适宜的星球上，生命的存在也必定有可能，即使这种可能性极小。由于宇宙是无限的，我们还是可以假设，生命会在某处出现。不过，如果有生命的星球非常少，那么出现生命的两个星球间的距离，可能将异常遥远。
在太阳系中，月球和火星是太空移民最显而易见的选择。水星和金星太热，而木星和土星是巨大的气体星球，没有坚实的表面。火星的卫星非常小，并不比火星本身更优。木星和土星的一些卫星也存在可能。比如木星的卫星之一欧罗巴，它的表面是冰层，但其下可能会有液态水，也就可能会孕育生命。
那么我们如何确定这种可能？是否必须登陆欧罗巴，然后钻一个洞？
星际航行必然可行，但它是一个长期的目标。我所说的长期，是指未来二百到五百年。
还有另一种选择。去年，我与企业家尤里•米尔纳 一起，推出了长期研发计划——“突破摄星”，目标是让星际旅行变成现实。如果成功，在座各位有些人在有生之年内，我们将向太阳系最近的星系——半人马座阿尔法星系发送一个探测器。
“突破摄星”计划是人类初步迈向外太空的真正机会，可以探索和考量移居太空的可能性。这项涉及三个概念：迷你太空飞行器、 光动力推进和锁相激光器。“星芯片”是尺寸被缩小到仅几厘米、但功能完备的太空探测器，它将附着于“光帆”上。“光帆”由超材料制成，重量仅有几克。我们设想，一千个由 “星芯片”和 “光帆”组成的纳米飞行器将被送入轨道。 同时在地面上，激光器阵列将共同形成一道超强光束，光束穿过大气，以数十吉瓦的功率射向太空中的“光帆”。 

这项创新背后的想法，是以光束来驱动纳米飞行器的前进。这样产生的速度虽然不及光速，但也能达到其五分之一，约合每小时亿英里。这样的系统可以在一小时内抵达火星，几天内到达冥王星，一周内就可以追上并超过旅行者号探测器，并在仅二十年后到达半人马座阿尔法星系。重要的是，“星芯片”的轨迹可能包括“比邻星”，这颗位于半人马座阿尔法星宜居带的行星，与地球的大小类似。就在今年，“突破摄星”启动与欧洲南方天文台的合作，更进一步探寻在半人马座阿尔法星系中的宜居行星。
目前看来，这些都可能成为现实。同时，我们也面临着巨大的挑战。吉瓦功率的激光器仅能提供几牛顿的推力，不过纳米飞行器因为只有几克重量，恰恰可以克服这个问题。在工程方面，纳米飞行器必须经受极限加速、极寒、真空，质子，以及太空粉尘等垃圾的碰撞。另外，由于大气湍流，将一套总量吉瓦功率的激光组瞄准太阳帆，也是困难重重。
还有一些严峻的问题有待人类解决。如何让数百道激光穿过大气波动时最终聚合？如何推动纳米飞行器又不烧毁它们？如何让它们瞄准正确的方向？此外，我们还需要让纳米飞行器在冰冷的真空环境中工作二十年，这样它们才能将信号传回到四光年外的地球。
以上这些都是工程设计要解决的问题。随着技术进步日趋成熟，这些工程问题都能被解决，我们可以展望更多令人兴奋的使命。如果“突破摄星”计划能传回毗邻星系中宜居星球的图像，这对人类的未来必将产生深远影响。

希望我已经解答了我演讲一开始所提出的问题。人类作为独立的物种，已经存在了大约二百万年。我们的文明始于约一万年前，其发展一直在稳步加速。如果人类想要延续下一个一百万年，我们就必须大胆前行，涉足无前人所及之处！
 ：外太空到底有没有生命？
 
突破摄星执行董事、前艾姆斯研究中心主任   
以下为 演讲实录
各位下午好！我非常荣幸今天有机会能够来到这里，同时我也深感谦卑，因为我们看到在这里有很多知名的演讲者，比如霍金教授。
今天来到这里，就是希望能够给大家简单地介绍一下突破摄星的这个项目。刚才霍金教授已经很简单地起了个头，讲了突破摄星到底是什么样的项目。
首先我介绍一下背景。这是最开始知名的俄罗斯的企业家尤里·米尔纳先生所启动的，一开始包括万美元，是激励基础科学方面的研究，现在已经拓展到了生命科学、应用数学。除此之外，我们还有很多万元级的一些奖金，是针对其他的一些项目。另外我们也给高中生做了一个青年人的奖项。
今天我想给大家介绍一下，我们怎么开始突破摄星项目。当时我们是希望能够通过这样的一个突破项目，能够让我们知道是不是太空当中还有其他的生命以及文明存在，我们是否能够找到他们。
今年在智利、圣地亚哥开启了一个观察的项目，了解太阳系以外是不是还有生命的存在。目前，我们认为在太阳系当中唯一有可能有生命的是火星，但是火星上面还没有找到任何的生命迹象。至少在数十亿年前，有很多可以让生命支持的因素。当然，如果说在它的表面下有水存在的话，有生命的可能性就会提高。
另外还有一个土卫。在土卫当中更有可能存在生命，我们在两个月前就看到，在土卫的南半球的部分，事实上有一些涌出的泉水，这就说明了在结冻的表面之下，是有水存在的。同时我们在卡西尼任务当中，找到里面有一些碳元素，还有一些金元素。更有意思的是我们还找到一些非常简单的、有机碳分子的存在。这也就意味着它更有可能是存在生命的。
我们接下来要解决的问题就是：会不会在那里找到生命？我们要通过后续的任务去解答这样的问题。同时我们也必须要在我们临近的星系当中寻找生命的存在。在我们南半球可以看到的最亮的一个临近行星，半人马，在这个星座当中其实有三个行星。它就像我们的太阳一样，一个比较大，这个星小一点。还有一个非常小的是红矮星，这个红矮星可能只有太阳的—，它的亮度也比较低。
非常有意思的是年欧洲的南方天文台，他们就正式宣布他们找到了一些证据，找到针对第三个红矮星所绕行的一个卫星，这个绕行的行星它其实是移居的，差不多跟地球的大小，这可能是临近地球最可能有生命的一个星球，其他的信息我们目前掌握的还不足够，现在我们也还没有充分的理由可以支持我们可以移居到那里，但是这是至少离地球最近，可能居住，可能移居的地方。
另外我们也希望能够更好地仔细观察这些移居的星球，所以去年开始，我们就使用了欧洲南方天文台在智利的一个强大的天文台望远镜，帮我们进一步地观察刚才说的半人马星和两个星座，也许—年以后我们会看到不仅仅是有可能移居，同时我们可以真正看到它上面的一些现象。
但是更有意思的是我们刚才提到的是年月日所开启的突破项目。我们选择这个时间就是希望能够看看我们是不是有一天，能够真正的把人送往移居的星球。很多年以前我们一直试图探究到底有没有其他的太阳系存在、是不是有其他的行星存在？
当我读研究生的时候上世纪的事情，我们当时觉得可能只有千分之一的机会有生命，但是事实上年开普勒任务的时候，当时美国宇航局开启的这个项目。我们看到像是太阳这样的，其实有上千个，我们希望能够观察他们的亮度，近距离观察以后，通过开普勒观察站我们就可以更好地了解上面的一些细节，我们就会发现，在银河系当中是否有可能有我们这样的太阳系，其中也有一些像地球一样有水，并且有一个太阳能够公转这样的星系存在。
刚才我说到的临近半人马星座里面的红矮星，的银河系当中的行星都是这些小小的红矮星。我们可以看到他们有个，其实都跟我们地球非常接近，而且其中有个是可以移居的。
所以我们相信，如果我们持续的寻找，我们可以找到更多这些宜居的星球，问题就在于即便它们宜居了，我们是否真正能够移居过去，我们是不是能够旅行过去。我们如何能够旅行到银河系，我们从多年前就试着做这样的尝试，因为这些银河系它的距离比我们现在离太阳的距离还要远得多。
很多时候我们的发射，如果没有办法快速地到达那里，即便我们今天发射可能也要万年才能到达我们想要到达的目的地。所以下一个问题是我们能不能把太空旅行走的更快一点，如果我们能提速到现在的一万倍，我们才能在年之内走到我们要到的星球。
我们知道上世纪的时候我们看到提速，的确在一百年之内提速了一千倍，但是下一次让我们的飞行器提速一千倍需要花多少年的时间，是我们必须要回答的问题。很多时候我们必须要问，我们在电子行业出现的摩尔定律，是不是也能够适用在我们在太空飞行器的提速上面。
很多时候我们希望至少能够达到光速的，我们才有希望到达这些宜居的星球。
另外一个问题像我们传统的这些飞行器，如果设计的这么大或者是火箭这么大，我们需要很多的燃料，它也不可行。如果说火箭仍然是原来那样的重量的话，那么我们需要更多的一些燃料。事实上有可能我们要考虑使用核燃料，哈佛的一位教授就提过，也许我们使用核燃料，虽然可行，但是目前找到可用的核燃料，必须要等到几十年，甚至一百年以后才能满足我们的需求。那么我们就要考虑到用其他的一些推动能力。
接下来的问题就是我们有没有可能在太空当中航行，这是很有意思的一个问题。年的时候，我们看到开普勒曾经写信给伽利略，信里面就提到我们是否能够有神助之风，来保证我们在太空当中航行。概念虽然很早，但是很有意思的是我们现在回过头想，用风帆的方式在太空中航行，可能是可行的。
很多年以前就提到用光的方式，比如说年代，就有教授提到用这种光的方式作为推力。但问题是最近日本人有一个项目，就是利用光作为推进力的方式来进行研究。如果是太阳能的话，它的推进力仍然是不够的。我们必须要考虑有没有其他的一些方式，能够让光作为推进力，成为可能。
有两种途径，一是我们可以把我们的太空船做的更小一点，二是我们可以用激光的方式，让光能够更好地聚焦在一起，形成我们所需要的推力。
我们这里所想到的概念就是能够形成一个激光的阵列，我们能够让他们聚集起来，能够在几分钟形成、这种推进力。事实上在很多的一些沟通和通讯的应用当中也用到了这个概念。我们用来通讯的一个太空船，它的重量是上千公斤，接下来我们可以做出更小的立方体的卫星，问题在于我们是否有可能在这种基础之上，把它从这么小的立方体的迷你卫星的基础上进一步的缩小？
我知道大家都使用苹果手机，它起到了很多的作用，里面的芯片可以帮助我们进行很多的运算、计算甚至定位。我们要考虑的问题是，我们是不是能够用苹果手表这样的概念来做，所以我们就做了一个星芯片。我戴在手上大家可以看到，它只有差不多一厘米的边上，我们可以看到这就是我们接下来在星星飞船上面所要使用的一种芯片。
事实上几个月以前，我们推出了星芯片比较早的版本，把它放在了一个拉脱维亚的卫星，上面使用的是印度的推进器，几个月之前比较大的版本显然已经发挥了作用，现在我们进一步地把它缩小，我们希望在未来发射上去的时候它能发挥它的作用。
同时我们也看到，如果加上我们所说的光之风帆的话，我们就可以保证它能够用光速的的速度持续年的航行，持续的给我们传回相关的一些信息，也许年左右的时候，我们就可以收到在整个银河系当中可能有生命的其他的星球上面的一些生命迹象的图片。
在突破项目当中，我们还有一个项目叫做突破聆听项目，我们在年月份开启的一个项目，目的就是希望能够寻找外星人可能发给我们，或者说，他们自己发出的一些信号。我们把世界上最大的一些射电望远镜结集起来。首先，我们在西弗吉尼亚州 绿岸射电望远镜。另外，我们也使用帕克斯望远镜，这个是来自澳大利亚。我们使用自动的行星寻找器，这个是在美国的技术去寻找可能的行星存在。
一年以前，我们与中科院的国家天文局合作，来使用中国望远镜，这是全世界最大的望远镜。通过这个望远镜，我们希望能够找到更多的突破。另外，我们也与英国、南非合作，等到我们这几项合作的联网完成之后，我们就可以看到更多信息采集，以及信号分析的结果。
我们从射电望远镜上所获得的信号，也许这些信号一些快速射电爆发的现象，说明了外星人他们可能把他们自己的太空船，射向太空的时候所发出来的信号，我们希望更好的观察这样的信号。如果这个信号真的如他所说的，那就意味着外星人也在试着来到其他的星球去进行移居或者定居。
后来经过证明，这其实并不是，不管怎么样，如果我们继续通过这种方式，我们就可以找到更多临近星球，然后去收集更多我们刚才找到的信号。像刚才所说的，我们没有任何的迹象完全证明有生命，但是我们持续努力，现在也有一些成绩，我相信可以继续尝试回答我们想要回答的问题：到底在外太空有没有生命存在。
接《霍金没有提威胁论，他的新目标是带领人类移民外星球 下篇》

本来来源于 科技大本营 微信公众号导语：   以 即时相机翻译黑科技与 基于云计算架构的“统计机器翻译”的强大服务后台，引爆大众关注。“交互移动终端云计算” 这一跨界结合展示了极大的潜力。

视频演示
二话不说先来应用场景展示。第一个是手机通过浏览器访问外网的页面，调用手机摄像头传输当前图像到云计算后台服务，得到头部姿态识别结果，在当前页面画出识别结果。
视频 ： 的使用展示
视屏 ， 客户端的展示
来源
？


为了说明项目技术尝试的概念，先看几个有关联的的技术方案及产品。上述图是结合云计算在移动终端上的应用案例，以  为例进行介绍。
 的核心技术在于“统计机器翻译”，基本思想是通过对大量平行语料进行统计分析，构建统计翻译模型进而使用此模型进行翻译。简单的说， 在生成译文时，会在大量人工翻译的文档中查找各种模型，进行合理的推测，从而得到恰当的翻译。之所以使用云计算架构，是由于机器翻译需要海量的数据存储空间以及高效的运算能力。
提供了语音识别，触摸手写，即时相机翻译真黑科技。真正引爆大众关注的是其名为 即时相机翻译新技术与其强大处理后台结合提供的便利性。
交互  移动终端 云计算是一种极富有潜能的跨界产物。
？

基于的交互

更自然、方便的体验


移动终端  云计算

网络带宽渐渐不是问题
在线更新算法，更快的迭代
本地数据有限，云端数据可扩展，模型灵活


应用服务分离

轻客户端
一种服务后台——多种端末应用
更方便的用户数据收集、管理


目的

探讨基于的游戏交互的新体验
可验证、可持续发展“服务应用”框架



系统构成

不同的客户端  或者将图像信息通过网络发给云服务器，云服务器进行算法处理，将结果返回格式客户端。
云服务器由代理代理服务器、后台应用程序、算法库和日志评估组成。
代理服务器，代理路由来自不同客户端类型、个体的请求，发送到合适的后台应用服务进程；
后台应用服务程序根据请求的多线程启用算法模块库进行处理。
数据流图

具体的数据流图、涉及到相关技术红色是规划而未实现如上图所示。需要特别说明的是，系统方案设计的客户端上传的是图像信息，可以是具体编码压缩后的图像信息，也可以是经过机器学习预处理后高度降维的图像特征信息。只不过这一方面还没有开始着手进行。
算法服务

 如上图所示，算法服务程序由任务框架、算法模块库、日志和评估子系统构成，部分相关依赖开源库如图所示。
任务框架支持多任务扩展、支持多线程、支持多算法模块组合；算法框架面向对象设计、扩展方便。
前端应用

前端应用基于接口实现接口统一，不同的客户端平台具有差异的平台适配。
统一的接口

统一入口地址

方式
      


统一数据包

典型的发送数据包
结果返回包


统一交互模式


差异的平台适配

不同平台上设备接口获取
不同框架系统的处理逻辑加载
不同应用的不同数据使用

这部分考虑后面系列再来说明。
相关推荐：《基于云计算的  移动交互应用研究：头部姿态估计综述》导语
推荐系统在电子商务领域有着很重要的作用。电子商务公司通过向用户推荐符合他们口味的商品而获取巨大利润。最为通常的推荐方法是基于内容的协同过滤对每个用户产生一个推荐列表，但是这些方法并没有很好的考虑用户的评论内容，同时这些评论内容直接体现用户的偏好。在这篇文章里，作者基于用户的评论内容，评估了十多种不同的  框架。这些  框架包括多层双向  和 ，同时有   框架。这种基于注意力的  框架不仅在众多模型中表现尚佳，同时它会对每一个评论单词赋予一个权重。因为获得了每一个单词的权重，我们能够在后续预测过程中增加一些额外的视角。作者在做相关的调研时采用的是类似国内的大众点评的数据集。
简介
随着像和 这样的点评网站的数据量级迅速增长，它们拥有关于用户个性化和偏好的充足数据。大量的评论信息对于推荐的准确率提升是一种新的助力，因为用户的偏好深根于用户的评论之中，这些评论对于神经网络来说能够产生很多有用的特征。在这篇文章里，作者调研并对比了十多种不同推荐系统模型。
在调研过程中，我们首先面临一个很重要的问题：基于用户的个人数据对单个用户进行预测会有特征稀疏性的问题，也就是说单个个体的自解释特征覆盖的样本太少，容易造成过拟合。因此需要更加泛化的特征覆盖更多的人和样本。当前已经有许多成熟的方案来解决数据稀疏性问题。由于我们的目标是为模型以获取用户偏好的充足数据，因此我们基于用户的偏好寻找其最邻近的用户，并且使用最邻近用户形成的簇所包含的评论来训练模型。
模型的输入：将评论中每一个单词转换为单词向量 ，每一个  作为模型的隐层输入。
模型的输出：用户对特定饭店的喜好的概率。每一个簇的用户都有其自己的模型。

我们采用自底向上的方式来生成不同的结构。首先是实验两个典型的模型效果：和，这两个模型能够解决梯度消失的问题。为了能够使模型结合评论的上下文信息，增强模型预测能力，引入了双向的结构。另外，从网络深度的维度，我们在和的基础上，引入了多个隐含层的模型。最后， 的 模型也被引入进来，因为注意力模型能够对训练评论每一个单词给出一个权重，用来表明评论中哪些单词对表达中心主题更重要。
相关工作
我们知道，是一个极具表达能力的模型，能够学习出序列数据中高度复杂的关系。它维护着序列数据中每一个时间步长的一系列激活单元，这使得结构深度天然就会很长。而这样的结构会导致两个问题：梯度爆炸，梯度消失。


梯度爆炸的问题可以通过增加一个梯度上限来解决；梯度消失的问题可以通过和的结构很好地解决。 和  都是通过重新参数化的模型来解决梯度消失的问题；单元的输入是由输入门的激活来控制，更早之前的数据是由遗忘门来控制，网络结构只会通过  结构中门的控制来相互影响。 是在的基础上，把遗忘门和输入门结合成一个更新门，并将隐含状态结合了的状态，并且它的效果在某些任务被证明是超过。
另一个关键问题是：单向的结构每一层的输出是完全依赖上文环境。对于一个自然语句的理解应该依赖于上下文环境。如果不仅仅依赖上文或者下文，会导致预测的准确性降低。对于这个问题，一个看上去优雅的解决方案是通过双向的模型来解决这个问题。每一个训练序列会被表达成前向和后向两种单独的循环网络，它们都被连接到同一个输出层。

多层的模型已经被证明在领域有很显著的效果。单层被排列在一起，每一个隐含状态的输出信号作为上层隐含状态的输入。多层的结构能够在不同时间维度发挥作用，低层能够获取短时的相互影响，然而聚合的影响能够被深层的模型所捕获。

最后一个关键的技术点是，引入注意力模型到中，能够使模型更加关注一条评论某局部关键信息，并且模型会认为这个局部的信息是对整个评论的理解起到了关键作用。
举个例子，“我的段位达到了最强王者，哈哈哈哈哈”。显然，我们会觉得“我，段位，最强王者”是非常关键的信息，然而“哈哈哈哈哈”是无关痛痒的东西。引入注意力模型，就是希望模型知道对于输入的评论，每一个单词对语义理解的贡献都是有一定权重的。

数据集
数据集采用的是   。它提供的是种结构的对象，包含饭店、用户、评论、登记、建议信息，我们只使用了饭店，用户和评论信息。
饭店信息包含饭店类型、位置、类别、评分、名字等。
评论信息包含评星和评论内容。
 数据集包含 条评论， 个饭店，个用户。我们把数据集减少到 关于个饭店的个评论。
为了克服单个用户数据的稀疏性，我们把具有相似偏好的的用户聚集在一个簇里面，并用这个簇所包含的用户评论来作为训练集。我们将评论数据集分为训练集评论，有效集条评论，测试集条评论。评论中每一个单词被转化为维的向量，使用的方法是，这个类似于，但是比好用。
为了简化模型的输入，我们统一每条评论的单词个数为个。主要的操作方法是：评论单词数大于个，会砍掉之后的单词；评论单词数小于个，会重复评论最后的句子追加到评论里面直至个。为啥是个呢，当然不是拍脑袋想的，是统计出来的。
这样的话，的输入实际上是固定两个单词，每一单词维的向量表示。
实验方法和模型
通常方法
我们需要实验种不同的模型，每一个模型都会将指定饭店的评论作为输入，输出是用户对饭店喜欢还是不喜欢。
我们将饭店的评论分为两个类别：

喜欢：评论星级是或者

不喜欢：评论星级是或者


每个单词的词向量都会喂给的隐层，最后的输出会通过的激活函数返回每一个类别的概率。我们使用交叉熵作为代价函数来训练模型，样本的被表示成形式。

在这个实验中，我们只关注选择的数据来测试不同的模型效果。结果显示，模型效果好于。然后，我们以作为单元，
模型选择
我们首先测试比较和的效果。然后以的作为单元基础，构造单层、双层、三层、四层的双向模型，来进行实验效果测试。以同样的方式，基于的，构造多层的基于注意的模型。

模型和模型描述


 和  都是在基本的结构上改造隐含单元的结构。这些结构看起来很复杂，但其实这些不关键。只要记住这些结构能起到很好地保存短期和长期的记忆，并有效地解决梯度消失的问题就了，具体推导在这里不展开。
双向模型描述
 包含前向和后向的结构 。在前向中，输入的顺序是从第一个单词导最后一个单词，模型会计算前向序列的隐含状态。后向是把输入序列倒过来，产生一个倒序的隐含状态。我们取双向输出的平均值，并进行线性转换，输入到的激活函数，然后获得输出。
多层 是由多个单词构成的模型。每上一层的隐含状态是作为下一层隐含状态的输入。直观来看，每一层都会用上一层的记忆序列作为输入序列，并计算出自己的记忆表达。我们也是通过计算最后一层双向的输出的平均值，输入到激活函数来计算最后预测值。

基于注意力的模型描述
一个标准的模型会通过长距离的方式来传播依赖关系来获得最后的预测结果。网络必须获取之前状态的所有信息来作预测。对于神经网络来说，处理长文本的内容将是很困难的。例如有个单词，通过一千次传递到最后的输出。最后输出必须包含一开始的输入，这个信息折损是相当大的，不能很好表达第一个单词的意思。在本文实验中，我们的输入长度是个单词，训练过程中是很容易造成信息损失的。
我们引入了基于注意力的模型思想来助力模型。简单理解就是我们希望对输出的影响，不仅是传递到最后一个单词的输出来影响预测，而是每一个序列的输出都会影响预测。这样对于预测的结果来说，就知道哪些词是关键的，哪些是不关键的。

实验结果
和有相似效果，它们的效果都要好于基线的效果。

同时，要好于 效果，多层的的效果要好于单层的效果。同时我们也发现准确率不是是层数越多越好，而是在达到第三层的时候，效果是最好的。同时，我们也看到当引入了注意力模型时，其效果并没有预计的那么好，这个可能跟训练的数据有大关系。

引入注意力模型的效果，我们也可以看到这样的例子。

上面是两个测试样本。标粗的单词是在    模型中，输出权重的单词。从这两个样本，我们可以再深刻体会下注意力模型的作用。前者是一个 ，标粗的单词能够概括整个评论的主题思想，后面的例子就呵呵了
总结和未来工作
 证明了在预测用户偏好时，评论内容是用得上的。
 多层双向，基于注意力的模型比起单层单向的模型预测得还是要准一些。
 并不是神经网络的层数越多越好使，还是要试试，看命。
 理论上基于注意力的模型效果更好，但是实际效果差了些，这个跟数据集不够充足有关。
存在的问题：
  评论的长度限制太死了，后面其实可以让模型处理自定义长度。
  数据集可以用得更多。
  目前的输出只有个类别，其实可以设置更多的类别，并且做到并不针对某一个饭店预测输入引入除评论的外的，饭店特征维度。
参考文献
                                                                                                                                                                                             –                             –                           –                                 –                      –                                                                      –                                 “          ”                               –                                                                                           作者：虫虫爸
团队：腾讯移动品质中心

导读
最近两年，品质中心极力推动测试工作左移，以期能提前发现产品的问题，降低成本。笔者自认代码基础能力还不错，就想通过代码来提前发现一些。
多数项目中，代码评审工作是由开发同事相互执行的。但往往开发同事为了赶进度，并没有时间进行代码评审，导致很多明显的被遗留到了测试阶段。那代码评审是否可以由测试人员来做呢？显然是可以的。诚然多数测试人员的代码能力没有开发人员的水平，代码的深度不如开发同事，但通过实践证明，测试人员也能胜任大部分代码评审的工作。
做的方法
笔者在刚开始做代码时也是毫无头绪，不知道哪些代码可能有问题。那时我才意识到了解出现的根因对代码有至关重要的作用。
通过对及开发对应修改的代码进行分析，并与开发同事交流，我了解到一些出现的原因，以及出错代码的一些特征。当这些代码特征被总结出来后，我将这种特征用于其他的代码，此时能慢慢地能发现一些了，但效率比较低。
后来用 自带的工具扫描代码可以扫描出大量疑似缺陷的点，再通过人工分析可以发现不少空指针和逻辑上的问题，代码的效率得到了极大的提升。
但还有一些更深层次的需求，比如像一些多条件组合的代码就不能通过扫出来了。因此我把这些特殊的代码特征进行汇总，请一个同事帮忙写了一个定制化的代码扫描工具，利用这个工具扫描出代码位置，然后针对性的。

总结我的实践过程，建议刚开始做代码的朋友，先使用一些业界常用的工具快速入手。当积累一些经验后，尝试自己分析问题并总结经验，好的经验积累起来形成自己的知识库和工具库，提升效率。
知识点汇总
以下是笔者在平时工作中总结出一些经常可以发现问题的点，希望对同仁们有所帮助。
、空指针
如果项目有异常上报统计，就会发现最常见的异常是空指针异常代码中如果使用了未初始化的对象都会导致这个异常。一般开发都会在程序入口处进行参数的判空，不过这样还不够。严格意义上，任何一个对象在使用前都应该进行判空处理。
如下代码片断所示，一些开发同事习惯当传入参数为空时，直接返回一个空的对象。单从本方法的角度来看是不会有问题的，但是在调用本方法的地方，如果忘记做判空处理就会出现空指针的错误。

以上示例中较好的代码实践是返回一个没有元素的列表，或者是当参数为空时直接显式的抛出一个异常，让调用者必须处理该异常。
针对空指针的情况，一般以下几点：
方法参数如果不能为空时，是否做了判空处理，或者在方法调用者传入参数时是否确保了不为空；
方法是否有返回的情况，如果有是否可以改为返回一个空白对象如没有元素的列表等；
当被调用的方法如系统方法返回为时，调用者是否有进行判空处理；
使用的对象是否在使用时已经被初始化。较常见出现问题的情况是类的成员，如果在构造函数中没有进行初始化，而在其他地方进行初始化时，初始化时机是未知的，那么此时对象使用前一定要进行判空。
、逻辑判断
边界判断
数组越界在异常统计上报中也是比较常见的问题这是最常见的一种边界条件不正确引起的问题。
数组或者列表边界一般的点有以下几个：
 数组或列表的循环中，合法下标范围是=；
通过下标从数组或列表取数据时，下标不合法的判断方法是    ||  = ；
当在下标存在加减时需要判断当加上或减去某值后是否可能存在越界的情况；
如果是分隔字符串产生的数组，取数组的值前一定要判断下标是在数组长度范围内的；
取数组或列表的项时，需要首先判断数组或列表的长度不为。
逻辑判断
任何一个语句都有两个分支。当仅有一个时，开发一般不会漏掉两个分支。
但如下面的示例代码，本身可能不存在问题。但可以看出组合起来的条件分支会有很多，当组合嵌套时，开发同事会重点关注满足需要条件的情况，却往往容易忽略应该做的处理。像以下的示例代码，也要思考是否能将判断条件组合来用，减少嵌套。

另外多条件组合的判断逻辑，特别是判断条件超过两个时，或者是“”与“||”组合使用时也非常容易出错。
如下的示例代码，首先这段代码不容易理解，看到这段代码时需要想想“”与“||”哪个的优先级高，如果用括号包起来就会更容易理解；其次经过详细分析后发现最终结果与的值无关。

又如下面的示例代码，的方法接受的参数不为空，然而当的值为空时会中断后续判断逻辑即使为空也会传入到方法中，导致不能正常运行。

因此，对于以上类似的判断逻辑代码，可以做的评审有三点
是否能优化判断逻辑，使代码更加简洁易懂；
是否所有的分支都得到了合理的处理，如代码中没有写出来的分支，或者的分支；
是否存在条件判断的中断情况，对后续一些判断或者逻辑造成影响。
、函数中途返回
函数中途返回指在运行过程中 达到了某种条件 使程序中途的情况。
如下面的代码所示，当为空时直接返回了，乍一看似乎没有任何问题；但如果认真地思考后，会发现对象还在等待一个回调，时需要去检查没有执行这个回调方法是否会存在问题。

因此针对类似的在中途返回的情况，时需要看看是否存在导致某些逻辑不能正确执行到的情况。
、内存泄漏
当程序偶尔出现莫名其妙的卡顿或异常，又或者上报出现异常时，那作为测试人员就该意识到程序有内存泄漏了。
内存泄漏除了通过专门的测试方法来测试外，也可以通过代码来发现。
对浏览器的内存泄漏测试发现的原因分析，发现导致内存泄漏最频繁的原因不是图片资源或者流未释放，而是注册了事件未取消注册引起的内存泄漏。
如下面的示例代码所示，将自己注册到了，便于在数据发生变化时自己能收到通知。

如下面的代码所示，一般都会用一个列表来存储注册的监听者，如果需要运行很长时间甚至整个生命周期，或者本身是一个静态对象的话，那么会长期存在于内存中，这意味着中存放的对象也会被长期持有，最终导致内存泄漏。

前面示例中的并未将自己反注册，一直持有该对象造成内存泄漏。
以上问题看起来似乎很简单，但是在浏览器项目中，即使高级的开发工程师也会犯类似的错误。当然内存泄漏的原因还有很多，这里就不全部列举了，大家可以网上搜索进行了解。
针对内存泄漏的情况，我一般会以下几种常见情况：
对象如果注册了事件回调，是否在合理的地方进行了反注册；
线程对象使用完毕是否正常的结束；
各种数据库、网络连接和文件被打开后，是否正确关闭；
图片资源正确释放；
缓存对象要有一定的大小控制，且有明确的释放策略。
、异常处理
关于异常处理的评审，笔者一般会关注当异常被捕获后，是否正确的处理，以及当有异常处理后，后续的流程是否正常执行。
如下面的代码所示，当到异常时，此时是为空的，到后续的初始化传入空的程序会出错。

效果
代码评审在浏览器漫画模块最近了三个版本进行了实践，共发现个，如下面的截图所示。由于代码在开发阶段就进行，发现的时间提前了至少一周。

总结
以上是我的一点经验总结，还需要持续积累。
万事开头难，个人以为做代码在刚开始的时候会稍微难一些，但只要做到以下几点一定能做好代码。
第一，学会使用一些业界比较常用的代码扫描工具，可以快速入手；
第二，坚持学习提升自己的代码能力，并掌握快速阅读和理解代码的方法；
第三，加深对自己产品的业务和代码结构的理解，更容易发现深层问题。
最后，学会通过根因分析，总结经验并应用于平时的工作中。
以上内容分享给大家，与大家共勉，希望我们一起进步！
获取更多测试干货分享请搜索微信公众号：腾讯移动品质中心！作者：黎斌摘要得益于家庭带宽和移动网络的快速升级，突发带宽越来越大，经常达到级，甚至 。如何快速、低成本地保障业务突发，本文从目前问题出发，论述了问题对应的解决方案，并对其效果做出总结。

背景
使用的业务中，经常有带宽突发的场景，比如新闻爆点视频、大型直播活动、热门影视剧上线、游戏等应用发布。得益于家庭带宽和移动网络的快速升级，突发带宽越来越大，经常达到级，甚至 。如何快速、低成本地保障业务突发，是的一大挑战。
年，腾讯接入第一个业务腾讯网。带宽从最早的，发展到现在的数。单业务的带宽也越来越大，大部分业务常量带宽在几百，部分突发业务达到了。网络的快速升级，移动用户爆发式增长，以及视频类业务包括点播和直播的兴起，使得业务突发越来越频繁，突发带宽越来越高，对的要求也越来越高。
腾讯得益于公司业务的蓬勃发展，先后支持了游戏下载、流媒体视频加速、春节红包等公司内部业务；年腾讯开始接入第三方客户，比如快手点播、斗鱼直播等。以上各种业务都有突发场景，腾讯在这些年的发展过程中，关于如何保障业务突发，积累了丰富的经验。接下来就挑战和问题、解决方案、效果三个方面来解析。
一、挑战和问题
下面将从业务特点开始，分析目前存在的挑战和问题。
、 业务特点和挑战
多样化的场景，注定了突发业务充满挑战。突发业务具有体量大、场景多样化、 无规律等特点。
  体量大：突发业务带宽大部分都超过，部分甚至达到了 ；
  场景多样化：点播中的热剧和新闻爆点；直播中的／／等游戏直播，／世界杯等体育直播，演唱会等综艺直播；应用下载中的王者荣耀等游戏下载；静态网页加速中的红包活动、电商促销等；
  无规律：部分突发活动无法预知，活动快要开始或已经开始了才知道，比如新闻爆点。
体量大，需要准备更多的资源；场景多样化，需要满足不同的资源需求；无规律性则对我们的扩容效率提了很高的要求。
、 目前存在的问题
仅仅为了满足业务突发需求而储备大量的资源，成本太高，会造成资源极大的浪费。所以一般会通过复用资源来应对业务突发。但是直接复用资源，存在两个问题：
  只能复用部分资源：业务，一般按业务类型来区分平台和资源使用，主要原因是不同业务类型对资源需求不同，比如点播类需要更多的存储；有较多请求的静态页面类，则需要更多资源。这种限制使得资源无法充分利用，加大了资源准备的难度。比如视频突发主要使用视频，而下载类和网页类无法直接使用，这限制了的大小。即使复用同类型资源，因为涉及多个业务资源的协调，准备时间一般会超过两天，无法应对临时突发；
  无法降低成本：另外针对部分突发业务，比如游戏应用下载，带宽高峰期在上午和中午，如果只使用本平台资源，会导致结算带宽明显上涨，从而增加成本。无法利用同其他业务错峰的特点来降低结算带宽。
二、解决方案
通过虚拟化复用现有资源，搭建全业务通用的突发池，所有平台共享。 突发池中的设备为虚拟机，虚拟机有不同的规格，只要业务有需求，都可以按需使用。突发池中的带宽储备达到了，基本能满足所有业务突发需求 。任何业务有突发需求，配合自动化上架接口，可在分钟完成突发池的扩容。
、 突发池系统架构
突发池系统架构见图图 突发池系统架构
  突发池：在各平台物理机的上层，由虚拟机组成的资源池，对内存磁盘等使用进行了限制，防止对物理机造成影响。原有业务依然部署在物理机上，不用调整。
  自动化部署和监控系统： 能根据业务实际需求，自动预测需求并扩容 。所有的突发需求，都能在分钟内扩容完成。针对点播下载业务，自动分发热点文件，降低回源带宽。
  调度系统：突发业务的突发性和体量大两个特点，使得相比域名调度系统，直通车更占优势。直通车调度更灵活，生效时间快，能达到分钟级。
虚拟机和物理机部署了上报，业务信息和服务器负载每分钟都会上报到监控系统。监控系统会根据历史带宽预测一个值，并与当前带宽比较，如果当前带宽超过预测值的，则认为有突发。根据带宽上涨的比例，系统会自动从突发池中扩容相应数据的设备。针对提前准备的突发活动，运维可以指定带宽需求量，之后系统便会自动计算设备需求并扩容。
分钟粒度上报的服务器负载信息则为监控系统做调度决策提供了依据。系统会依据机房剩余带宽、服务器带宽、、等综合信息决定虚拟机是否需要从直通车中启用或者禁用。用户访问时先请求直通车调度系统，直通车会根据调度策略返回一个地址，地址中为实际资源地址。用户跳转到地址，并获取实际内容。
、技术优化
使用虚拟化技术复用资源的重要前提是，不影响现有业务。这就要求对资源有充分的隔离，比如／磁盘，以及对带宽的使用。下面是实现过程中存在的几个问题及解决方案：
● 精准控制单机负载：负载过高会影响业务质量，需要对单机负载进行精准的控制。解决方案： 配额系统：直通车中有配额系统，对每个虚拟机可使用的资源做了限制，包括／和带宽。监控系统中上报的信息，结合配额系统，可以确保服务器负载被限定在制定的范围内，粒度为分钟级。 部分请求返回：对／带宽／等做了限制后，应用程序能根据母机当前负载，实时判断是否处理一个请求。如果负载在限制范围内，直接处理；如果负载超出限制，则返回，使用户跳转到直通车的调度地址，这样能在尽量不影响业务质量的情况对负载做精准控制。程序层面对负载的实时控制，是配额系统的有效补充。 网卡流量控制：在极端情况下，业务带宽超过设定阈值，这时虚拟网卡会主动丢包，避免对母机造成影响。
● 限制磁盘大小：在文件系统中无法对文件／目录级别进行磁盘大小限制。解决方案：由于腾讯业务基本都是使用文件系统，这种情况下只能对根据用户或用户组对磁盘进行限制，但现网业务都是直接在环境下使用。这里我们使用 来解决磁盘大小限制问题。虚拟机中突发业务使用挂载在 上的目录，这样就可以间接限制磁盘大小，防止使用太多磁盘影响其他业务。
● 绑定：默认是绑定所有，部分单负载高会影响母机业务。解决方案：通过脚本每分钟采集一次系统所有单负载，为避免频繁调整和受毛刺数据影响，取分钟的均值。最后选取负载较低的部分核，并通过配置文件来动态绑定，将虚拟机对母机业务影响降低到最小，并且能充分利用资源。
效果
突发池上线后，支持了王者荣耀下载、直播、游戏直播等多次大型突发活动，节约成本万。通过共享，搭建突发池能显著提高突发能力和降低成本。

总结
腾讯通过技术复用资源，搭建级别突发池，能支持直播、点播、静态等各种业务突发，能自动检测到业务突发需求并在分钟内完成资源扩容，具有发布快，成本低等特点。资源复用能提高资源利用率，为业务提供极大的突发池，但要注意复用业务之间不能相互影响，这需要对服务器进行实时的监控和及时的调度。另外还有一些待改进的地方，比如内核参数基于容器隔离，方便不同业务调优；部分业务客户端不支持跳转，调度系统需要支持域名调度方式。

本文来自：腾讯架构师 公众号导语
随着虚拟现实技术的发展，视频板块也越来越多的涌现在各大视频网站，比如爱奇艺，，优酷，腾讯视频等。随着专区版块的建立，用户自主上传的视频内容也越来越多，目前都是编辑工作人员审核进行视频和普通视频分类，如何设计算法实现自动分类视频和普通视频，提高片源审核效率显得尤为重要。
视频及播放原理
对于视频，大部分用户的概念更多的是在眼镜上，通过手机上特定的 眼镜播放模式来播放视频，然后将手机插入眼镜进行实际交互观看体验，如下图所示：

图：用户通过眼镜观看视频
对于后台视频数据存储库来说，实际上视频的视频数据保存格式和普通视频无差异，都是等其他常见的格式。视频现在主要有种类型比较广泛使用，分别是 度， 度， 度。如下图所示：

图： 度视频普通播放模式播放

图： 度视频普通播放模式播放

图： 度视频普通播放模式播放
与普通视频的区别在于视频需要专门的播放器插件将视频画面渲染到球面上，然后将用户观看视角置于球体中央，用户正面所对球体的局部画面即为用户当前所看到的全景的局部画面，当用户转动视角时就可以度浏览当前场景的所有画面。全景度交互浏览及眼镜上的播放模式也就是此原理。

图：视频播放原理
视频片源识别算法
由于视频和普通视频格式一样，网站或者应用里面的后台会字段标记为视频。不过对于用户在板块上传的视频，我们后台数据库服务器要鉴定审核其是否为视频，提高效率，只能基于视频本身的画面内容识别。
相关基础知识
要想从视频本身画面内容角度识别出视频，就必须先了解视频是如何产生的，及其数据的保存方式。这里给出腾讯视频对于直播这块的整体流程，从数据采集、全景拼接到视频处理到编码推流的全套流程，如下图所示：

其中，全景视频是通过全景拼接技术生成，如下图所示：

全景视频的数据保存形式为投影方式，如果你带上一副眼镜进行观看，就可以在一定程度上体验到被世界环抱的感觉。这种投影方式的特点是水平视角的图像尺寸可以得到很好的保持，而垂直视角上，尤其是接近两极的时候会发生无限的尺寸拉伸。可以理解为水平方向经度°和垂直方向纬度°的数据都可以通过投影方式保存下来。

图：投影方式保存全景数据
越是靠近顶端和底部图片的扭曲就越严重，头盔和应用软件的意义也就在于将这些明显变形的画面还原为全视角的内容，进而让使用者有一种身临其境的包围感。
视频片源识别算法
通过基础知识我们知道，与普通视频的差别在于，视频画面是投影方式保存的球体模型数据。我们算法核心思想就是将一帧视频画面反投影到球体上，变换得到局部特定角度对应全景视频的边界，如图红框所示的正常画面，对画面内容进行相似度计算，得到一个表征相似度的二维向量，最后用模型进行分类。
整体算法流程如下：

具体过程如下：
原始视频的一帧全景画面

全景画面投射到球面上，变换得到固定的个视角画面，分别如下：



对每个视角画面进行相似度计算，得到表征相似度的二维向量

构建分类器
 得到个普通视角的相似度二维向量取均值，构成最终的表征特性的二维向量。为了构建分类器，我们取张视频画面，张普通视频画面，分别求取对应的特性的二维向量作为训练数据进行模型分类训练，得到最终的分类模型。
加载分类模型进行片源识别
对于一帧视频画面，求取其对应的特性的二维向量，然后送入分类器进行分类，判断其是否是视频对应的画面。为了更准确的判断一个视频是否是片源，我们这里采用等间隔选取视频中的个关键帧画面，进行上述分类操作，若其中有画面类别判断为视频画面，则判定该视频为片源。
注意：本文提出的算法是针对度视频片源的识别，对于度的识别算法并不适用。对于测试数据算法的准确率，有待后续上线应用测试。作者：刘科

 漏洞简介
 是  里面由于 整数截断 引起的一个堆溢出漏洞将   赋值给，简单记录一下。
漏洞原理：

 使用  的  接口解压数据；
在  中，解压后的数据的大小使用  类型的变量 _ 来存储；
 使用  类型的变量来接收 _ 的值；
在  位环境中，当解压后的数据大小超过  时即超过的范围会产生截断；
后续  使用截断后的值分配堆块并拷贝解压后的数据，导致了堆溢出； 漏洞分析


 崩溃信息
在  位  上开启  编译 ，使用编译出来的 _测试原贴提供的  文件，可以看到如下崩溃信息已简化：
====     
           
       
       ___ 
         
        __
       _ 
       _ 
       _
       _
       _
       _
       _
       _
       
       
       
     

         
      
    
       
       _
        
        __
       _
       _
       _
       _
可以看出这里出发了堆溢出行为，目标堆块的大小只有  字节，而程序尝试通过 往堆块上写入大量数据。总结如下：

调用位于  函数 __的第  行；
堆块的分配操作同样位于 函数__ 的第  行；  分析


原贴提供的  文件十分简单： 号  包含  字节数据， 的值为 ，即数据使用了  算法进行压缩，需要使用 算法进行解压缩。
  分析
先来看一下  在解压数据时需要用到的关键结构_注意这里 _ 的类型为 ：
  __ {
    _  _  存储待解压数据的位置 
         _       还有多少字节的数据需要解压 
        _       已经处理的数据大小原始压缩数据 

        _      存储已解压数据的位置 
         _      还可以存储多少字节的已解压数据 
        _      已经处理的数据大小已解压数据 

    _  
     _  

    _ 
    _   
         

         _
       
       
} _
在调用  的 解压数据时，_ 的成员都会进行相应的更新，这里着重观察 _ 成员。
  _   
{
     
     = _        处理了多少压缩数据
     = _      数据解压缩后的大小
    _ =         记录
    _ =       记录
     
}
  分析
为了提高代码的可读性，这里删除了 中无关紧要的一些代码。
下面的代码展示了数据的解压过程，可以看出数据是分块进行解压的，且解压的结果存储在 __ 中。
  初始化
    = ___ __

   设置输入数据 待解压数据
  _ _ _

   对输入数据分块进行解压
  _ __
  _ _ = _
    {
     调用  解压一块数据
    _  = _ _ _
     _ 的剩余存储空间
    _ __ = _

     解压出错
      = _ {
      __ = _  __
      ____
      
    }

     _ 还有剩余空间 说明解压完毕
     __ =  {
      __ = _  __
      ____
      
    }

     存储当前解压结果 并为下一次解压做准备
    ____
    _ = __ _  
    __ = \
  }
因为数据是分块进行解压的，所以解压完之后需要进行拼接操作。然而 _返回类型为，且_ 的类型为，所以会发生截断，后面 __ _分配的堆块也无法存储全部解压数据。
   解压后总的数据大小
  _ = _

   __ ==  {
     仅有一块数据
    _ = __
  }  {
     存在多块数据
     根据 _ 分块堆块
    _ _ = __ _
    _ _ = 
     拷贝数据
     _  =    __  {
      _ _ = __
      _ __ = _
        == __   {
        __ = __
      }
       
      __  _ _ __
      _ = __
      ___
    }
    _ = _
  }
  调试
对下断点，可以看到待解压的数据以及大小前面提到过大小为 ：
   
  

    
    _= \\\\    压缩数据
    _=                        数据大小
    _= 
    _=  
    _=  
    = 
     __

   _
 = 

   _
                                
                                
                                
                                
                                
在调用_ 函数所在的行第  行下断点，可以看到 _ 的值为 ，当赋值给  时会截断为 。
  
    
     __  

 

    

   
 = 

   
     
   
                
                
                     _
                
                

 
_ =  
    __
       __

   __
 = 
 补丁分析
 对相关的代码进行了  以防止出现   ，但是新的代码仍然无法处理  以上的数据，如下所示：
   
     }  {
       _ _ = __ _
       _ _ = 
      _  = _
        _  =    __  {
         _ _ = __
         _ __ = _
           == __   {
           __ = __
         }
        __  _ _ __
        _ = __
        _ _ = __ 
        __  _ _ _
        _ = _
         = _
         ___
       }
后续相关的  对这一段代码进行了清理，如  和  。腾讯云搭建  论坛这里的方法是从服务市场选择  镜像，简化了环境安装配置。

从腾讯云官网购买一台云服务器，在购买向导服务市场选择镜像： 多版本可切换 位并设置机器账号，密码。



从说明文档中查看获取账号密码方法：
密码获取方式：使用用户登录终端，执行： 

服务启动与停止  启动，停止，重启          
  启动，停止，重启：  ，  ，  
  启动 

版本切换，执行脚本：__，如：
   __  使⽤用 版本
   __  使⽤用 版本

下载最新版本  包
简体 安装包下载地址：___
解压安装包
打包  目录为 

利用  客户端工具如 连接  服务
上传  默认上传到  默认   路径

复制 文件到 目录
解压 ： 
复制或剪切到默认站点目录：  
修改文件及目录所有者，属组：   
修改文件及目录权限：   

修改   密码
      
   【输入原来的密码】。

可以通过  测试修改后的  账号密码、



使用修改后的密码，可以正常登录。

安装 
浏览器访问安装地址：


点击我同意按钮

确保所需状态与当前状态一致没有红

选择全新安装点击下一步

输入数据库用户名，密码，以及后台管理员账号密码等信息，点击下一步

如上图显示正在安装信息

如上图，完成安装
安装完成后，访问论坛地址：

安装完成的论坛
后台管理端入口：
管理员账号，密码为安装输入的账号密码

后台管理入口
利用登录数据库可以看到安装创建的数据库

至此，论坛安装完成。

相关推荐【腾讯云的种玩法】利用腾讯云搭建实用小工具【腾讯云的种玩法】利用腾讯云搭建个人博客【就是快】分钟搭建一台服务器！导语：海量服务之道其一，有损服务； 特性其一，容错；   

上一节简单提到了客户端在选取节点时，会对列表执行死活检查，屏蔽掉一定时间内异常的节点，从而达到容灾的目的。下面对容错机制做具体探讨。
一、容错性
从概率学的角度，随着分布式系统规模不断扩大，即使是小概率的系统错误依然不可忽略不计，容错设计必不可少。
在分布式计算领域有一个公理即：理论，分布式系统必然需要满足“” 项，在遇到某个节点或网络分区故障时，仍然能对外提供满足一致性和可用性的服务，而一致性和可用性须有一方取舍，通常我们会选择系统高可用。在这次实习做的项目中也有所体会，为保证系统高可用我容忍了一定判重状态的不一致，实际上很多业界优秀的方案也是这么做的。
说得再直白一点？ 一句话： 任何一台服务节点掉，都不影响业务的访问；
怎么保护？ 简单点： 先屏蔽掉该异常节点，请求先发送到别的节点去，隔一段时间再试试异常的。
注意这里所说的容错性是站在系统层面上的，而业务上的容错是交给业务方自行根据需要做定制和实现的，如：根据服务端错误返回、捕获调用异常信息或是在错误回调中做相应重试处理。
二、容错保护
系统要做到容错，首先需要思考：系统会有哪些错误？ 系统如何能发现这些错误？
而所谓的容错保护就是在发现这些错误节点后采取特定的容错策略来保证系统的可用性，最简单的方式就是将这些错误节点移除屏蔽掉，然后定期重试，若发现错误节点恢复正常则取消屏蔽。
 错误类型
根据前面对客户端向服务端发起请求过程的分析，为保证系统的高可用性，若出现建立连接失败，或是处理请求时出现大量超时参考：过载保护，我们应将该节点判定为异常节点。
具体分析连接失败或处理超时的原因是比较复杂的，可能是网络线路中断引起，亦有可能是节点系统异常，或是服务节点宕机等等。既然异常情况可能性较多，我们则不去具体细化探讨到各种情况的异同，而是概括性地抽象出系统错误出现的表征，以此作为依据发现错误却是比较容易实现的。
 如何发现
针对这个问题，必然要从两个角度出发考虑：

在服务端做监控
客户端主动发现

对于节点连接失败，一方面可以让服务端保持心跳上报，告知当前服务正常运行；另一方面可以使客户端建立连接失败时返回错误信息，以此判定；
对于节点过载，一方面可以监控服务端的服务队列处理情况； 另一方面可以在客户端统计请求的超时响应情况，以此判定。
三、实现
分析清楚问题，再考虑如何实现就比较简单了，的实现同样是从以上两个角度做考虑的。回想前面在整体架构介绍中提到的，服务会定期上报心跳到服务，由服务统一将心跳上报，以此我们可以在端设计名字服务排除策略，移除故障节点；而对于节点过载情况，考虑到在上直接统计更为精确，直接更新可用节点列表更为及时，同时没有服务端 复用问题，因此我们可以设计客户端主动屏蔽策略。
 名字服务排除策略：
业务服务  主动上报心跳给名字服务，使名字服务知道服务部署的节点存活情况，当服务的某节点故障时，名字服务不再返回故障节点的地址给，达到排除故障节点的目标。名字服务排除故障需要通过服务心跳和地址列表拉取两个过程，默认故障排除时间在分钟。
 主动屏蔽策略：
为了更及时的屏蔽故障节点，根据调用被调服务的异常情况来判断是否有故障来更快进行故障屏蔽。具体策略是，当调用某个出现调用连续超时，或者调用的超时比率超过一定百分比，会对此进行屏蔽，让流量分发到正常的节点上去。对屏蔽的节点，每隔一定时间默认秒进行重连，如果正常，则进行正常的流量分发。
代码实现放在工具类中，每个服务会对应一个死活统计状态，每次执行请求结束后会检查更新该活性，
代码逻辑很简单，以下情况则屏蔽该服务节点：

周期内超时次数超过，且超时比率大于总数的
连续调用超时次数超过秒内
连接失败错误

如下：
       {
      == __ {
         = 
        _ = 
        
         = 
        
    }    == __ {
          {
            
        }  {
            
             = 
            _ = 
        }
         = 
        
    }    == __ {
          {
            
        }  {
            
             = 
            _ = 
        }
         = 
        
    }    == __ {
         = 
    }
    周期重置
     _     {
         = 
         = 
         = 
        _ = 
    }

      {
         周期内超时次数超过，且超时比率大于总数的
          =     
          =  {
              =   
                {
                 = 
                  |=|=    |  
            }
        }

          {
             秒内连续失败次
              =   _     {
                 = 
                  |=|=    |  
            }
        }
          {
            连接失败
              {
                 = 
                  |=|  |  
            }
        }
    }  {
          == __ {
             = 
        }
    }
}
感谢阅读，有错误之处还请不吝赐教。本文转载于

智能交通云在刚刚举办的腾讯“云未来”峰会上，成为瞩目焦点。交通与物流智能化的领军人物就腾讯云新发布的“人工智能即服务”战略展开了讨论与分享。腾讯云也由此率先在交通物流行业落地商业实战能力。

腾讯“云未来”峰会于月日在深圳举办。在峰会上，顺丰集团、顺丰科技田民，蔚来汽车创始人、董事长李斌，驭势科技联合创始人、吴甘沙分享了各自对于智能物流、未来交通形态等方面的探索与实践；并与腾讯副总裁、腾讯云总裁邱跃鹏，腾讯云副总裁曾佳欣在圆桌讨论中进行了观点的深度碰撞。腾讯云在会上提出智慧交通云的概念，参会者一致认为云计算将是交通物流行业向智能化自动化演进的重要基础。
邱跃鹏将云比喻为未来无人驾驶的信息高速公路，并指出，信息高速公路与地面公路的结合，才能真正形成智慧交通的有效解决方案。
腾讯云在为交通物流业修筑“信息高速公路”方面已经有了最前沿的商用实战方案。通过支持和服务滴滴出行、摩拜单车、顺丰等明星企业，腾讯云积累了大量智能交通数据与解决方案经验。邱跃鹏认为，腾讯云将以一个辅助者的角色，将自身的人工智能能力和内容开放性与交通物流企业的实际需求深入结合，在交通物流领域率先普及“人工智能即服务”。
对于腾讯云搭建的这条信息高速公路，顺丰、蔚来汽车，驭势科技这样的交通物流行业的领导者都毫不犹豫地表示举双手支持：“交通物流行业的进化迫切的需要云人工智能的赋能”。
新型的智能汽车行业已经是云计算、人工智能等技术被深度应用的明星领域。作为国产电动汽车的领军人物，李斌认为云计算为基础的无人驾驶加上电动汽车，这几个因素组合到一起会开创汽车的新未来。在被问到是否会和腾讯云有大量的合作时，他表示腾讯是全世界最大智慧交通支持平台，这方面非常可靠。在连接用户这件事情上，没有人比腾讯做得更好，希望蔚来能成为腾讯云在汽车领域的标杆应用。
在对未来的智能交通的展望中，吴甘沙认为未来的城市一定会脱胎换骨。这时需要一个城市级别的交通管理云，了解、预测和实时更新每一个个人的出行，对他们的行程进行共享，这就是云计算在起作用的地方。
作为腾讯云的亲密合作伙伴，在谈到顺丰为什么选择与腾讯云合作时，田民表示，这不仅是兄弟情谊，也是因为腾讯云的技术能力强大可靠。他认为在人工智能时代，需要利用云和大数据帮助顺丰处理底层运算、图像识别、智能调配等工作，而让精力更聚焦在核心的物流部分。
腾讯云能助力交通物流行业智能化、自动化，与该领域创新企业开放合作、进取探索的姿态是密不可分的。与此同时，腾讯云也得益于智能交通领域对大数据应用与人工智能能力的需求暴涨。
腾讯云在此次峰会上发布的“人工智能即服务”战略，率先在智能交通物流行业被关注，显示了传统行业与实业对智能未来的期待，也印证了腾讯董事局主席兼首席执行官马化腾在峰会上提出的：云是产业革新的源动力、新型社会管理的主平台、人工智能的强载体。主要是由  语言开发，为了方便和其他系统集成而不引入  相关依赖，部分实现使用  语言开发，例如    等。总体来说， 是由  语言实现，会运行在  中。然而， 除了提供  开发接口外，还提供了 、 等语言的开发接口，为了保证  核心实现的独立性， 仅在外围做包装，实现对不同语言的开发支持，本文主要介绍   的实现原理，剖析  应用程序是如何运行起来的。
 运行时架构
首先我们先回顾下  的基本运行时架构，如下图所示，其中橙色部分表示为 ， 应用程序运行时主要分为  和 ， 负载总体调度及  展示， 负责  运行， 可以部署在多种资源管理系统中，例如 、 等，同时  自身也实现了一种简单的 独立部署 资源管理系统，可以不用借助其他资源管理系统即可运行。更多细节请参考   内部原理剖析。

用户的  应用程序运行在  上某种程度上说，用户的程序就是   程序，经过  调度封装成一个个 ，再将这些  信息发给  执行， 信息包括代码逻辑以及数据信息， 不直接运行用户的代码。
 运行时架构
为了不破坏  已有的运行时架构， 在外围包装一层  ，借助  实现  和  的交互，进而实现通过  编写  应用程序，其运行时架构如下图所示。

其中白色部分是新增的  进程，在  端，通过  实现在  中调用  的方法，即将用户写的  程序映射到  中，例如，用户在  中实例化一个  的  对象，最终会在  中实例化  的  对象；在  端，则不需要借助 ，因为  端运行的  逻辑是由  发过来的，那是序列化后的字节码，虽然里面可能包含有用户定义的  函数或  表达式， 并不能实现在  里调用  的方法，为了能在  端运行用户定义的  函数或  表达式，则需要为每个  单独启一个  进程，通过  通信方式将  函数或  表达式发给  进程执行。语言层面的交互总体流程如下图所示，实线表示方法调用，虚线表示结果返回。

下面分别详细剖析  的  是如何运行起来的以及  是如何运行  的。
 端运行原理
当我们通过  提交  程序，首先会上传  脚本及依赖，并申请  资源，当申请到  资源后，会通过 其中有  方法 拉起 ，如下图所示。

 入口  函数里主要做两件事：

开启  
通过   方式运行用户上传的  脚本

用户  脚本起来后，首先会实例化  版的  对象，在实例化过程中会做两件事：

实例化  ，连接  中的  ，后续在  中调用  的方法都是借助这个  
通过   在  中实例化  对象

经过上面两步后， 对象初始化完毕， 已经起来了，开始申请  资源，同时开始调度任务。用户  脚本中定义的一系列处理逻辑最终遇到  方法后会触发  的提交，提交  时是直接通过  调用  的  方法完成，映射到  中，会转给  方法， 运行完成后， 中会开启一个本地  等待  进程拉取，对应地， 进程在调用  后就会通过  去拉取结果。
把前面运行时架构图中  部分单独拉出来，如下图所示，通过  入口  函数拉起  和  进程， 进程对应下图橙色部分， 进程对应下图白色部分。 进程通过  调用  方法提交 ， 运行结果通过本地  被拉取到  进程。还有一点是，对于大数据量，例如广播变量等， 进程和  进程是通过本地文件系统来交互，以减少进程间的数据传输。

 端运行原理
为了方便阐述，以    为例，当  申请到  资源时，会通过 其中有  方法 拉起 ，启动一些必要的服务后等待  的  下发，在还没有  下发过来时， 端是没有  进程的。当收到  下发过来的  后， 的内部运行过程如下图所示。

 端收到  后，会通过  运行 ，最后会调用到  的  方法，来处理一个分区的数据， 的  方法的计算流程大致分三步走：

如果不存在  后台  进程，那么通过   的方式启动  后台进程，注意每个  上只会有一个  后台进程，否则，直接通过  连接 ，请求开启一个  进程运行用户定义的  函数或  表达式。 是一个典型的多进程服务器，来一个  请求， 一个  进程处理，一个  上同时运行多少个 ，就会有多少个对应的  进程。

紧接着会单独开一个线程，给  进程喂数据， 则会调用用户定义的  函数或  表达式处理计算。

在一边喂数据的过程中，另一边则通过  去拉取  的计算结果。


把前面运行时架构图中  部分单独拉出来，如下图所示，橙色部分为  进程，白色部分为  进程，每个  上有一个公共的  进程，负责接收  请求，并   进程单独处理每个 ，实际数据处理过程中， 进程和   会较频繁地进行本地  数据通信。

总结
总体上来说， 是借助  实现  调用 ，来驱动  应用程序，本质上主要还是  ， 到  的结果返回是通过本地  完成。虽然这种架构保证了  核心代码的独立性，但是在大数据场景下， 和  进程间频繁的数据通信导致其性能损耗较多，恶劣时还可能会直接卡死，所以建议对于大规模机器学习或者  应用场景还是慎用 ，尽量使用原生的  编写应用程序，对于中小规模数据量下的简单离线任务，可以使用  快速部署提交。直播礼物系统的特点

数据一致性要求高。用户购买的礼物，主播收到的礼物。这些都涉及真金白银结算，自然是不能错。
实时性要求高。腾讯公司做过一次问卷调查，用户送礼时，最关注的是主播的反馈。送出礼物后，希望能较快听到主播感谢自己，念自己名字。主播会更关心礼物排行榜的变化，以便及时和粉丝互动。这样要求送礼后，礼物账户及各种排行榜准实时的更新。
关联模块多。一次送礼，需要更新各种各样排行榜，还要增加用户等级，发送礼物消息等。
安全性要求高。用户礼物账户好比银行账户。
消息的重要性高。热门主播直播时，大量的粉丝进行送礼，粉丝及主播是根据看到的送礼消息来确定礼物是否送出和收到什么礼物。消息不能丢也不能多，同时还要求能较快显示。

礼物系统架构选择

模块交互模式

送礼功能关联的模块多，操作流水需要同步到其它模块，可选的方式有模式和消息队列模式。两者特点如下

根据实际工作的碰到的各种问题，建议采用生产者消费者模型，用消息队列来进行模块间通讯。送礼是直播业务里的核心功能，随着业务的发展，围绕着送礼功能会衍生各种周边功能，如增加几种排行榜，建立一种荣誉体系等。这样，送礼流水需要同步的模块会越来越多，如采用模式，链条会越来越长，主流程需要经常修改，模块间容易互相受影响。如采用消息队列模式，一次生产，多次消费，当新增一种功能需要送礼流水时，自行接入消息队列拉取流水进行计算，不用修改现有的模块而影响到其它接入模块。另外，在模式里没有考虑到被通知端的实际处理能力。在生产者消费者模式，消费者可以根据自己的实际计算能力来调节拉取速度，架构的可扩展性强，更具备弹性。

 计算模式排行榜是送礼服务里必不可少的功能。直播送礼是读多写少的服务，基本上还是大部分观众围观土豪送礼的模型。建议排行榜采用写扩散模式，异步计算好排行榜，读取时直接进行拉取。在实现上把读写进程分开，两者各司其职，互不影响。

存储模式根据礼物系统的特点，其在不同方面有不一样的要求。




存储：排行榜等核心基础数据最终落地在存储，以加快计算读写速度。
：定时缓存的数据。减少网络请求，加快读取速度。
：存储送礼流水。用于进行对账和各类实时性要求不高的统计计算。
 存储送礼流水。用于异常情况下的数据丢失重建，定位问题，日志回溯等。礼物业务的流水数据重要，建议分级和分多份存储以便数据对账和数据重建。当然成本也是考虑因素之一。

数据一致性

理论已经广为人知。这里结合实际工作中遇到的问题，谈点个人的认知和方法。在服务海量用户时代，传统的存储并不适合高并发，实时性要求高的场景，大量存储应用在我们的业务中，追求高性能高并发的的存储大部分并不支持事务功能，这样带来了数据一致性问题。总体来看，影响数据一致性主要有两个方面。一：数据损坏。这个可通过备份数据进行重建和对账来恢复。二：超时。在分布式架构下，超时简直是噩梦，其带来了状态的不确定性。
歌礼物业务解决数据一致性基本方法：每次送礼时会生成唯一送礼号，唯一号会贯穿整个送礼流程，最终的存储也会记录有号信息。当送礼流程中有超时的会记录日志，由程序来进行重试处理，程序会先判断送礼号是否已经处理以防止多算一次。

安全

送礼协议端到端加密防破解。
防抓包重放攻击。具体实现方法为送礼分两步走，分下单和消费两个步骤，联合送礼步骤的状态机进行判断。下面为实现流程图


举例：如果下单数据包被截获重放，只会新生成不同的订单号，如果消费包被截获，流程里会判断状态机这个订单是否是合法及是否已经消费了。
内部安全。堡垒最容易在内部被攻破，加强内部控制，严格流程规范。分离，定时对账。基本环境准备
使用    位系统  使用 _版本，去官方下载_ 版本



机器名
操作系统





















三节点集群设置为 
一般我们建议关闭

   — 
   
并且关闭 
   

并且将配置文件  中的下面这行
=

更改为

=
下载
   
   
    \_
部署约定
二进制文件放置到  下面对应的目录。数据文件全部放置到  下面对应的目录。原始二进制文件下载到  目录下。
基本安装
以下安装步骤需要在  上分别执行。

   
   
    _
    _ 
   {} 
   
          
     
     
   
   —= —
    | 
   —= 
   “ =” 
   

      

        ‘’’’   ‘’
       ‘’’’   ‘’
  
每个节点按上面进行，遇到初始化和启动故障请认真阅读   日志文件。
搭建主从结构
上设置
    _=’’
_= _=’’ 
_=’’ __= 
  ‘____’

    _=’’
_= _=’’ 
_=’’ __= 
  ‘____’

确认同步
   
   \
上设置
    _=’’
_= _=’’ 
_=’’ __= 
  ‘____’

    _=’’
_=_=’’ 
_=’’__= 
  ‘____’

确认同步
   
   \
上设置
    _=’’
_= _=’’ 
_=’’ __= 
  ‘____’

    _=’’
_= _=’’ 
_=’’__= 
  ‘____’

确认同步
  
   \
安装
， ，  上分别安装。
  
安装依赖模块。
  _   
配置 配置文件放置在 ，内容如下
_ __ {

         

     

}

_ _ {

     

    

     

    __ 

     

    _ 

     {

        _ 

        _ 

    }

    _ {

        __

    }

     

    _ {

        

    }

}
在  分别执行下面命令，启动。
 
观察每个系统上的 中是否有报错等内容。
在端机器上测试验证当前连接到哪个实例上。
        “ ”
可以尝试关闭实例，自行触发高可用切换，完成一次高可用自动切换。现在的时间是：，拖着疲惫的身躯，还是决定记录一下今天遇到的一个关于的”诡异”问题。其实决定记录的原因：一是好久没有在上刷存在感了；二是星期五晚上的大好时光，竟然一晃又过去了，心中愤愤不平
圆规正传，下面就详细的从问题的起因、发现、探索和解决，分享一下自己的心路历程。
一、  问题是这样来的
内部要进行数据库的容灾演习，需要模拟线上实际的环境进行测试，这就需要一份线上的数据库到测试库中，其实也就是重建一个线上数据库。要完成这个任务其实有种不同的做法，但是我当时一想：“好久没有测试一下数据备份是否正常了。”就决定利用备份数据进行重建测试库，于是乎就导出了一份文件，直接往测试库里面导入，由于线上库的实际数据量还不小，所以当我按完“”后就决定下班回家，估计等我到家了就差不多完成了。
结果竟然出问题了，屏幕上出现：
             
二、  苦逼的探索
对于报错信息“             ”，其实意思就是“索引字段长度太长，超过了”。
的主键只支持不超过个字节或者=个双字节 或者=个三字节的字段 而是双字节的，是三字节的。
那么问题来了，为什么线上业务库中正常的数据直接移植到另一个库，竟然会报设置表中字段不合法的错！
字符集设置不同？
第一个想法是查看两个库的字符集设置是不是不一样，果然线上库的字符集__=，而测试库的字符集__= 。这时候，我很天真的以为可能是因为建表的时候没有指定字符集，所以在导入测试库的时候默认使用字符集，导致    。所以就更改了测试库中默认的字符集，但是导入数据的时候依然还是报同样的错误。而且我在建表的语句中发现了，其实原来就已经指定了字符集，都是=，所以字符集设置不同并不是问题的症结所在。
更改索引字段长度？
定位到出错的建表语句，果然是使用字符集，而且长度是如下图所示。

  为了验证索引字段的字符集设置为时，确实是超长了，做了如下的测试：

那么问题简单了，更改为，然后再进行导入数据，竟然成功了。但是依然后两个困惑在我脑海里，
① 为什么线上库可以设置？
② 要是字段刚好有个字节的数据，那么转存的时候，数据不就丢失了？
存储引擎惹的祸？
 当我去检查刚刚那张被我手动修改过的表的状态时，意想不到的发现了一个问题，为什么建表的语句明明写的是“=”，但是导入后的表变成了“=”。如下图所示

再仔细一回想，刚刚竟然只记得索引字段长度不能超过，但是忘了和的区别了。
① 存储引擎，多列索引的长度限制如下：
 每个列的长度不能大于 ；所有组成索引列的长度和不能大于 
② 存储引擎，多列索引长度限制如下：
 每个列的长度不能大于 ，所有组成索引列的长度和不能大于 
原来是两张表的存储引擎不同，这样就解释了刚刚的两个疑问，但是又一个疑问就出现了，为什么建表语句中明明写的是表，怎么导入之后就变成了。经过对比，发现所有的表都被转换成了表
这个问题暂且先搁置，紧急的是要怎么规避。先分别查了下两个数据库的默认存储引擎，果然发现在线上库中__和_都是，而测试库却均是。如下图所示
通过修改默认的存储引擎


在中的  下加入= ，保存需重启。
  __=
通过这种方法终于保证了不修改源数据文件的情况下，能正确的重建线上数据至测试库，并且核对了数据和存储引擎，均与线上库一致。
存储优化选项？
问题虽然是解决了，但是难道中单个索引字段的长度真的只能小于？
又经过一番探索，发现在中，可以启用启用__参数，来使得单个索引字段的长度突破。
注意：
①启用__参数能够取消对于索引中每列长度的限制但是无法取消对于索引总长度的限制 
②启用__必须同时指定__=，___=，并且建表的时候指定表的_为或者 中_默认值为
具体的操作如下：
① 查看__，__参数 
    __ 
 
| _   |              | 
 
| __ |          | 
 
② 查看    __ 
 
| _       |          | 
 
| __ |   | 
 
③  建索引测试____都为默认值的情况下 
 
         

           
索引列大于 时报错，组成索引列总长度大于 时报错 
④ 修改____参数 
   __= 
   __= 
⑤ 对_为格式表创建索引测试 
     _= 
         _=  

  __=并且__=时，对于_为的表可以指定索引列长度大于 。但是索引列总长度的不能大于 的限制仍然存在。
三、  有待深思的细节
 相信大家一定还记得上面我们跳过的一个问题：为什么建表语句中明明写的是表，怎么导入之后就变成了。于是乎我做个组简单的测试：
① 设置数据库__=，将含有和的库导入。
② 设置数据库__=”，将含有和的库导入。
实验结果是，__设置成时，不论建表语句指定的是或，最终生成的表均为；设置成时，最终生成的表与其建表语句中设置的一致。
这个问题暂且就当做经验来记吧，至于其中的原因估计对于我这样经验和学识不够老道的来说，确实要慢慢研究和探索了。看了一看时间，今天就分享到这里吧，各位晚安。最近做了关于 性能测试，开始是拿中 来作为测试基准，分别测试各种下应用程序的运行速度，最后使用  来验证。在做测试时，发现有很多有趣的调优点，想到这些调优点可能对用户来说是普遍有效的，现把它整理出来一一分析，以供大家参考。
中的 采用的是开源代码里的样例代码，原理及代码实现都比较简单，下面我简单地介绍下。
基本原理介绍
的作用是评价网页的重要性，除了应用于搜索结果的排序之外，在其他领域也有广泛的应用，例如图算法中的节点重要度等。假设一个由个页面组成的网络如下图所示，链接到、，链接到，链接到所有页面。

那么的值分别来自、、的贡献之和，由于除了链接到还链接到，除了链接到还链接、，所以它们对的贡献需要平摊，计算公式为

简单来说，就是根据链出总数平分一个页面的值

对于上图中的页面来说，它没有外链，这样计算迭代下去，值会全部收敛到上去，所以实际上需要对这类没有外链的页面加上系数

  
 中给出了一个简易的实现，后续讨论的相关优化都是基于该简易实现，所以并不一定可以用来解决实际问题，这里仅用于引出关于调优的思考。下面是原始版本的实现代码，由于对代码排版极其丑陋，可能影响读者心情，这里以截图方式展现，完整的代码见中的。

上面的代码应该不难理解，它首先通过得到每个链接的列表，初始化每个的初始为，然后通过将每个的均摊到其链接的上，最后通过规约来自每个贡献的，经过若干次迭代后得到最终的，为了方便测试，上面代码行我改成了一个空操作的，用于触发计算。
优化一
从原始版本的代码来看，有些童鞋可能会觉得有必要对做，避免每次迭代重计算，我们不妨先运行下原始代码，看看是否真的有必要，下图是指定迭代次数为时的 图，其中蓝色的点表示被过。

从上图可以看到，次迭代计算是在一个里一气呵成的，所以没必要对做，因为从整个代码来看，在迭代循环里没有出现方法，所以迭代循环中不会触发，仅仅是组织之间的依赖关系。
但是，一般来说迭代次数都比较大，如果迭代甚至次，上述依赖关系将变得非常长。一方面会增加的维护压力，很可能导致 ；另一方面可能导致失败重算，单个失败后，会根据的依赖链从头开始计算。所以从容错以及可用性来说，上述代码实现是不可取的。所幸，提供了机制，来实现断链及中间结果持久化。
使用，我们来改造上述迭代循环，在每迭代若干次后做一次，保存中间结果状态，并切断依赖关系链，迭代循环代码改造如下：

上述代码中每隔次迭代，做一次，并强制触发计算。一定要注意，在做前，一定要对要的做，否则会重计算。这里简单描述下的计算流程 调用仅仅是标记该需要做，并不会触发计算，只有在遇到方法后，才会触发计算，在执行完毕后，会启动计算，如果依赖链中有被标记为，则会对这个再次触发一个执行计算。所以在前，对做，可以避免计算过程中重新根据依赖链计算。在上述代码中变量记录上一次的结果，在一次迭代完毕后，删除上一次的结果，并更新变量。
为了方便测试，我每隔次迭代做一次，总共迭代次，运行上述代码，整个计算过程中会有一次，根据前面的计算描述可知，在代码行处会有两个，一个是常规计算，一个是计算，计算是直接从缓存中拿数据写到，所以计算开销是很小的。加上最终的一个，整个计算过程中总共有个，下面是测试过程中的截图，注意图中对应的行号跟上面贴的代码没有对应关系哦。

第一个执行次迭代计算，并将结果缓存起来，下面是第一个的。

第二个做，由于需要的已经缓存了，所以不会重新计算，它会跳过依赖链中前面的，直接从缓存中读取数据写到，所以前面的依赖链显示是灰色的。

第三个执行剩下的次迭代计算，由于前次迭代的结果已经做过，所以这里的依赖链中不包含前次迭代计算的依赖链，也就是说起到了断链作用，这样维护的依赖链就不会越变越长了。

到这里，我们有一个稍微比较稳定的版本了，完整的代码见中的。但是，一般实际场景中，可能会特别大，例如好友关系，就有近亿的，每个对应的平均应该也有，不一定能全部缓存到内存，从之前文章 性能测试的结论可知，我们可以选择带压缩的__或_的缓存方式来减少内存的使用，由于在集群环境中磁盘资源是没有被隔离的，也就是说一台机器上的磁盘资源是多任务共享的，所以使用_存在磁盘溢出或被其他任务影响的风险，还是建议使用带压缩的__，这样可以大大降低内存的使用，同时性能不至于损失太多。在上面加了的代码基础上，把所有使用的地方全部改成如下形式。

相同资源和参数下分别使用默认的_和带压缩的__测试次迭代的性能，下图是使用默认的_方式缓存时，在内存中的大小，可以看到缓存后占用了内存。

改用带压缩的__的缓存方式后，缓存后只占用了内存，仅为之前的。

通过在日志中打印运行时间，得到使用_时运行时间为，使用__时运行时间为，性能牺牲了左右，所以使用__是以牺牲代价来换取内存的一种较为稳妥的方案，在实际使用过程中需要权衡性能以及内存资源情况，其实对于长时间运行的离线任务来说，他们之间的性能差别不是特别明显。
优化二数据结构
在上述代码实现中，中的记录为  ，类型为，通常情况下，占用的内存比、 等原生类型要多，在上述代码实现中，完全可以被编码成一个型，因为在整个计算过程中根本没有用到中的内容，这样就可以一定程度上减少缓存时的内存占用。由于在我的测试数据中，本身是由数字来表示的，所以在前面代码的基础上再将的定义改为如下代码：

完整的代码见中的。经过测试发现，改成型后，使用_缓存方式时，如下图所示，仅占用，相比为类型时的，缩小了一半多。此外，改成型后，运行次迭代的时间为，相比为类型时的，性能提升了左右。

使用带压缩的__缓存方式时，如下图所示，仅占用，相比为类型时的，也缩小了近一半。此外，改成型后，运行次迭代的时间为，相比为类型时的，性能提升了左右。

优化三数据倾斜
经过前面两个优化后，基本可以应用到线上跑了，但是，可能还不够，如果我们的数据集中有少数链接的特别多，那么在使用初始化时，少数记录的可能会有溢出风险，由于底层是用一个保存，如果一个节点链接了数十万个节点，那么要开一个超大的数组，即使不溢出，很可能因为没有足够大的连续内存，导致频繁，进而引发等致命性错误，通常我们把这类问题称之为数据倾斜问题。此外，在后续迭代循环中和的也可能因为数据倾斜导致部分非常慢甚至引发，下图是和的示意图，左边是后得到每个链接的，底层用数组保存，在时，阶段会将来自两个相同的记录通过网络拉到一个中，右边显示对的 ，如果对应的特别多，过程将会非常慢。

对进行分桶
首先我们应该考虑避免使用，这是导致后续数据倾斜的源头。既然可能存在单个对应的特别多，那么可以将做一个随机化处理，例如将具有相同的记录随机分配到个桶中，这样就相当于把数据倾斜的记录给打散了，其大概原理如下图所示。

基于上面的理论基础，我们先得到不用的

再分析前面代码里的迭代循环，发现我们之前使用很大一部分原因是想要得到每个对应的 ，我们可以单独通过来得到，会做本地，这个操作开销很小的

现在我们就可以使用将、以及三者起来了，很快我们会想到使用如下代码

但是！但是！但是！这样做还是会跟之前一样出现数据倾斜，因为执行过程中，在阶段还是会把中相同的记录分到同一个，也就说上面代码_也可能非常大，这个底层也是，面临的问题基本没解决。
所以我们就要考虑使用前面介绍的分桶方法了，对中的每条记录都随机打散到个桶中，那么相同的记录就会被随机分到不同桶中了

然而，是按照进行的，就是说它把来自多个具有相同的记录汇聚到一起计算，既然的已经被我们改变了，那么和也要变成跟相同的形式，才能到一起去计算

有了这个基础后，我们就可以将前面的逻辑修改一下，让他们能够顺利到一块儿去

完整的代码见中的。将上述逻辑整理成如下图，可以看到，其实我们对和做了膨胀处理，才能保证阶段对于中的每条记录，都能找到与之对应的和记录。

其实这种做法会极大地损失性能，虽然这样做可能把之前的问题搞定，能够不出错的跑完，但是由于数据膨胀，实际跑起来是非常慢的，不建议采用这种方法处理数据倾斜问题，这里仅仅引出一些问题让我们更多地去思考。
拆分发生倾斜的
有了前面的分析基础，我们知道对分桶的方法，是不加区分地对所有都一股脑地处理了，把不倾斜的也当做倾斜来处理了，其实大部分实际情况下，只有少数有倾斜，如果大部分都倾斜那就不叫数据倾斜，那叫数据量特别大。所以我们可以考虑对倾斜的和不倾斜的分别用不同的处理逻辑，对不倾斜的，还是用原来和方式来处理，对倾斜的可以考虑使用来实现 ，因为倾斜的一般来说是可数的，其对应的和信息在我们场景里也不会很大，所以可以使用广播。
首先我们把链接的个数超过的定义为倾斜，使用下面代码将切分为两部分

首先统计出链接数超过的，广播到每个计算节点，然后过滤，如果在广播变量中则为倾斜的数据，否则为非倾斜的数据，过滤完毕后原始被销毁。下面就可以在迭代循环中分别处理倾斜的数据和非倾斜的数据了。
对使用原来的方法

对使用方式实现 ，类似地，要把倾斜的对应的收集起来广播，之前的中的和在这里就都被广播了，所以可以直接在操作里完成对中的数据处理

最后将两部分的处理结果一下

后面的逻辑就跟前面一样了，完整的代码见中的。分别测试和版本，迭代次，在没有数据倾斜的情况下，相同数据、资源和参数下运行时间，运行时间，但是在有数据倾斜的情况下，相同数据、资源和参数下运行时间并伴有严重的，运行时间。可以发现版本在不牺牲性能的情况可以解决数据倾斜问题，同时还能以相同的性能处理不倾斜的数据集，所以说版本鲁棒性和可用性更强。
优化四资源利用最大化
通过前面几个优化操作后，中的版本基本可以用于线上例行化跑作业了，但是部署到线上集群，我们应当思考如何让资源利用最大化。为了测试方便，测试数据集中没有数据倾斜，下面就拿来测试并监控资源利用情况。
原始测试数据使用带压缩的__缓存方式情况如下表



磁盘中大小
缓存大小
分区数










运行次迭代，一开始大概估计使用如下资源，使用个，每个配个，一次并行运行个，个 轮就可以跑完



_
_
_
_











在提交参数中加上如下额外参数，表示分别对和在运行期间开启  

运行完毕后，统计运行时间为，将和拿到开发机上来，打开分析工具位于安装目录下面，首先我们看的监控信息，主页如下图所示，可以看到的占用是很小的，不存在瓶颈。

切到内存，把物理内存的两个勾选去掉，可以看到的内存使用曲线，我们给了，但是实际上最大也就用了差不多，看下图中的统计信息，没有什么瓶颈。

所以给分配是浪费的，我们把它调到，虽然实际上只用了大概，这里多给留点余地，其他配置不变，重新提交程序，统计运行时间为，跟时运行时间差不多。
再来看的监控信息，主页如下图所示，可以看到的利用明显比多，因为要做序列化、压缩、排序等操作。

再切到内存，如下图所示，可以看到的内存使用波动较大，最大内存使用差不多，我们给了，还是相当合适的。但是看下面的统计信息，发现最长暂停多，而且垃圾回收次数也较多。

为此，我们切到时间，可以看到，还是比较频繁的，还有一次暂停多的，看右边类型，对最长暂停时间从大到小排序，居然有几个类型的，其他一部分是类型，一部分是类型的，没有出现 ，下面先分析内存占用情况，回过头来再分析这里出现的诡异。

我们再看下堆内存大对象占用情况，大对象主要是在和中，用于存放 的数据，用于存放 的数据，目的是对记录排序，这两个数据结构底层使用表现为大对象存储记录。

切换到，再细化到小对象，可以看到大部分是型，展开堆栈跟踪，大部分是用在阶段，因为在时，一方面会读取后的，用于做 ，一方面在 阶段，将相同的和拉到一起做计算。

所以总体来说，内存情况是符合业务逻辑的，没有出现莫名其妙的内存占用。让人有点摸不清头脑的是，信息中有这玩意儿，我明明用了垃圾回收方式，经过一番查阅资料，说  可能导致 的出现，原因是当 正进行时，此时有新的对象要进入老年代，但是老年代空间不足。仔细分析，个人觉得可能是因为 后存在较多的内存碎片，而我们的程序在阶段底层使用，需要连续内存，导致 过程中出现了  ，才退化到 ， 是采用标记整理回收算法，回收过程中会整理内存碎片。这样看来，应该是 过程中，老年代空间不足导致的，从两个方面考虑优化下，一是增加老年代内存占比，二是减小参数，降低触发 的阈值，让 及早回收老年代。
首先我们增加老年代内存占比，也就是降低新生代内存占比，默认=，我们把它改成=，将老年代内存占比由提升到，重新提交程序，得到，打开监控信息，发现有很大的改善，不在出现 类型的了，最长暂停时间从原来的降低到左右，整体运行时间从降低到。

把上述=去掉，设置参数=前面是设置了，重新提交程序，得到 的监控信息，发现最大暂停时间也降下来了，但是由于老年代的频率加大了，整体运行时间为，比原来的还要长。

综合考虑以上信息，增加的启动参数=，能把状态调整到一个较优的状态。
值得一提的是，目前我们平台还没开放给用户配置参数的功能，以上监控信息暂时只能内部开发人员才能拿的到，这里拿出来仅作为相关调优思考，考虑平台的通用性，我们已经配置好了较为平衡的参数，后续探索如何向用户提供这些监控信息作为参考。
总结
给我们提供了一种简单灵活的大数据编程框架，但是对于很多实际问题的处理，还应该多思考下如何让我们写出来的应用程序更高效更节约。除了最后关于性能监控外，以上其他几个调优点是可以推广到其他应用的，在我们编写应用程序时，通过这种思考也可以加深我们对的理解。作者：张硕



相关推荐
【腾讯云的种玩法】如何利用腾讯云搭建个人网盘云服务器近日，腾讯游戏云游戏更新解决方案于官网正式上线。作为率先推出游戏更新解决方案的综合云服务商，腾讯游戏云整合平台的技术优势和海量自研游戏的开发运营经验，旨在帮助手游和应用开发者提供专业、稳定的应用程序和游戏资源更新服务，根据玩家本地资源动态计算差异，一次解决跨版本更新，轻松实现多渠道多版本运营，直指游戏开发者四大痛点。
痛点一：程序版本更新过程冗长，造成用户流失痛点指数：毋庸置疑，手游是一个通过快速版本迭代来保持生命力的行业，然而受、 的审核规则约束，开发者提交一次版本更新的审核周期在天不等。审核周期尚未完成，新的更新却已到来。因此无需提交审核的资源更新几乎成为了大部分游戏开发者最期待的功能。
对策：资源更新功能腾讯游戏更新解决方案提供的资源更新功能，不仅支持游戏配置文件、美术图片、脚本等资源更新，还支持、 等环境和代码相互调用，极大的提高游戏可运营性，同时提升开发效率。基于腾讯游戏云强大的基础设施布局，在全球范围内拥有个可用区、加速节点，一次接入即覆盖全球，高速下载速度达，无论玩家身在何处，都能获得畅快的更新体验。更值得一提的是，腾讯游戏云资源更新未采用热更新代码，可免于受苹果政策封锁的影响，实现非全量更新下的资源最大化更新。
《寻仙》手游使用资源更新功能 使得新版本快速触达用户
【痛点二】客户端臃肿，游戏拉新受阻痛点指数：随着手机性能的不断攀升，手游行业也迎来了施展拳脚的宽阔空间。更多剧情动画，更高质量的画面也带来“体重超标”的游戏安装包。体量巨大客户端一方面成为用户手机的存储空间杀手，另一方面耗费用户大量时间精力，使用门槛高，拉新受阻。
对策：客户端瘦身功能腾讯游戏云游戏更新方案通过微端分包技术最大可将安装包缩减为原大小的，实现客户端瘦身。此外，该功能还提供游戏过程无感知静默下载功能，用户在游戏过程中便能完成更新，大大提升重度游戏的更新迭代效率。
客户端瘦身功能助力《穿越火线》手游安装包缩减到原大小的
以《穿越火线》手游为例，在经历持续一年的运营后，安装包持续膨胀的问题亟待解决。从年底至今，《穿越火线》使用客户端瘦身功能将枪械声音、音频资源、地图场景、角色资源云端存放、按需下载，安装包成功缩减，随着后续资源优化和分包的进行，预计可缩减到原大小的。
痛点三：全版本更新流量消耗大，更新时间长，用户流失严重痛点指数：对于手游运营开发者来说，全量强制更新是解决版本兼容、实现游戏资源大量更新不得不面临的选择，但每一个版本的强制全量升级不仅会消耗开发商大量流量，还会导致近的用户流失，部分休闲类游戏的流失率甚至高达。如何在必须面对的全量更新过程中减小用户损失，成为又一横亘在开发者面前的难题。
对策：差异更新功能，省流量更新针对此难题，腾讯游戏云游戏更新解决方案提供了省流量更新功能。该功能可根据玩家本地资源，动态计算生成更新差异包，做到精准更新，最多能节省用户的更新流量使用。帮助游戏运营开发者在全量强制更新状态下，将损失降低至最小。
《火影忍者》手游借助省流量更新功能 大版本可为用户节约流量
痛点四：渠道多样化难管理痛点指数：据不完全统计，国内手游渠道总数已经超过家，头部渠道超过家，尤其是对安卓游戏而言，渠道碎片性已成为很多游戏开发运营团队的梦魇。
对策：多渠道多版本管理功能，保障用户体验该解决方案包含的多版本管理功能，将支持开发者自定义渠道、进行服务器管理，灵活支持多渠道、多版本更新。此外，还提供灰度发布功能，不仅支持区服级别的灰度，还支持白名单的精准灰度，同时还可根据不同渠道不同版本线灵活配置灰度策略，进而保障整体用户的游戏体验。《御龙在天》手游借助灰度发布功能 保障整体用户体验
百款游戏的选择  轻松开启游戏精品化运营之旅作为首推云端游戏更新解决方案的综合云服务商，腾讯游戏云整合平台的技术优势和腾讯游戏海量开发和运营经验，旨在帮助游戏开发者降低游戏更新门槛，轻松开启游戏精品化运营之旅。目前，该解决方案为包括《王者荣耀》、《穿越火线》、《火影忍者》等千万级自研大作提供稳定的更新服务，更新成功率高达。随着腾讯游戏云游戏更新解决方案的正式上线，国内游戏开发者将直接享受到腾讯游戏级别的通道技术支持，为国内手游产品精细化运营再添新动力。

点击原文了解详情，专享每月免费体验流量： 背景
 年中，微信支持包括 、、 等三个平台。但在各个平台上，微信客户端没有任何统一的基础模块。 年的微信正处于高速发展时期，各平台的迭代速度不一、使用的编程语言各异，后台架构也处在不断探索的过程中。多种因素使得各个平台基础模块的实现出现了差异，导致出现多次需要服务器做兼容的善后工作。网络作为微信的基础，重要性不言而喻。任何网络实现的  都可能导致重大事故。例如微信的容灾实现，如果因为版本的实现差异，导致某些版本上无法进行容灾恢复，将会严重的影响用户体验，甚至造成用户的流失。我们急需一套统一的网络基础库，为微信的高速发展保驾护航。
恰好，这个时候塞班渐入日暮，微信对塞班的支持也逐渐减弱。老大从塞班组抽调人力，组成一个三人小  的初始团队，开始着手做通用的基础组件。这个基础组件最初就定位为：跨平台、跨业务的基础组件。现在看，这个组件除了解决了已有问题，还给微信的高速发展带来了很多优势，例如：

基础组件方便了开展专项的网络基础研究与优化。
基础组件为多平台的快速实现提供了有力的支持。

经过四年多的发展，跨平台的基础组件已经包含了网络组件、日志组件在内的多个组件。回头看，这是一条开荒路。
设计原则
在基础模块的开发中，设计尤为重要。在设计上，微信基础组件以跨平台、跨业务为前提，遵从高可用，高性能，负载均衡的设计原则。
可用是一个即时通讯类  的立身之本。高可用又体现在多个层面上：网络的可用性、  的可用性、系统的可用性等。

网络的可用性

移动互联网有着丢包率高、带宽受限、延迟波动、第三方影响等特点，使得网络的可用性，尤其是弱网络下的可用性变得尤为关键。 的  组件作为基于  层的网络解决方案，在很多细节设计上会充分考虑弱网络下的可用性。

 的可用性

 的可用性包含稳定性、运行性能等多个方面。文章 高性能日志模块 描述了  在不影响  运行性能的前提下进行的大量设计思考。

系统的可用性

除了考虑正常的使用场景，的设计还需要从整个系统的角度进行设计思考。例如在容灾设计上， 不仅使用了服务器容灾方案，也设计了客户端的本地容灾。当部分服务器出灾时，目前微信可以做到， 内把以上的用户转移到可用服务器上。
保障高可用并不代表可以牺牲性能，对于一个用户使用最频繁的应用，反而更要对使用的资源精打细算。例如在  信令传输超时设计中，多级超时的设计充分的考虑了可用性与高性能之间的平衡取舍。
如果说高可用高性能只是客户端本身的考虑的话，负载均衡就需要结合服务器端来考虑了，做一个客户端网络永远不能只把眼光放在客户端上。任何有关网络访问的决策都要考虑给服务器所带来的额外压力是多大。为了选用质量较好的 ，曾经写了完整的客户端测速代码，后来删掉，其中一个原因是因为不想给服务器带来额外的负担。 的代码中，选择  时用了大量的随机函数也是为了规避大量的用户同时访问同一台服务器而做的。
在这四年，我学到最多的就是简单和平衡。 把方案做的尽可能简单，这样才不容易出错。设计方案时大多数时候都不可能满足所有想达到的条件，这个时候就需要去平衡各个因素。在组件中一个很好的例子就是长连接的连接频率具体实现见__，这个连接频率就是综合耗电量，流量，网络高可用，用户行为等因素进行综合考虑的。
 的发展历程
阶段一：让微信跑起来
跨平台基础组件的需求起源于微信，首要目标当然是先承载起微信业务。为了不局限于微信，满足跨平台、跨业务的设计目标，在设计上，网络组件定位为客户端与服务端之间的无状态网络信令通道，即交互方式主要包含一来一回、主动两种方式。这使得基础组件无需考虑请求间的关联性、时序性，核心接口得到了极大的简化。同时，简洁的交互也使得业务逻辑的耦合极少。目前基础组件与业务的交互只包括：编解码、状态查询两部分。核心接口如下：具体见_。
 
 
 
 
 
 
在线程模型的选择上，最早使用的是多线程模型。当需要异步做一个工作，就起一个线程。多线程势必少不了锁。但当灰度几次之后发现，想要规避死锁的四个必要条件并没有想象中的那么容易。用户使用场景复杂，客户端的时序、状态的影响因素多，例如网络切换事件、前后台事件、定时器事件、网络事件、任务事件等，导致了不少的死锁现象和对象析构时序错乱导致的内存非法访问问题。
这时，我们开始思考，多线程确实有它的优点：可以并发甚至并行提高运行速度。但是对于网络模块来说，性能瓶颈主要是在网络耗时上，并不在于本地程序执行速度上。那为何不把大部分程序执行改成串行的，这样就不会存在多线程临界区的问题，无锁自然就不会死锁。
因此，我们目前使用了消息队列的方案具体实现见  目录，把绝大多数非阻塞操作放到消息队列里执行。并且规定，基础组件与调用方之间的交互必须 尽快完成，不进行任何阻塞操作； 单向调用，避免形成环状的复杂时序。消息队列的引入很好的改善了死锁问题，但消息队列的线程模型中，我们还是不能避免存在需要阻塞的调用，例如网络操作。在未来的尝试中，我们计划引入协程的方式，将线程模型尽可能的简化。
在其它技术选型上，有时甚至需要细节到 的使用，比如考虑平台兼容性问题，舍弃了一些函数的线程安全版本，使用了 、、 等非线程安全的版本。
阶段二：修炼内功
在多次的灰度验证、数据比对下，微信各平台的网络逻辑顺利的过渡到了统一基础组件。为了有效的验证组件的效果，我们开发了  的统计监控组件，开始关注网络的各项指标，进行网络基础研究与优化，尤其是关注移动网络的特征。

基础网络优化。

常规的网络能力，例如  防劫持、动态  下发、就近接入、容灾恢复等，在这一阶段得到逐步的建设与完善。除此之外， 的网络模块是基于  层的网络解决方案，在缺失大而全的  能力的同时，却可以将优化做到更细致，细致到连接策略、连接超时、多级读写超时、收发策略等每个网络过程中。例如，当遇到弱网络下连通率较低，或者某些连通率不好的的服务器影响使用时，我们使用了复合连接代码见和  排序代码见__的方案很好的应对这两个问题。

平台特性优化。

虽然  是跨平台的基础组件，但在很多设计上是需要结合各平台的特性的。例如为了尽量减少频繁的唤醒手机，引入了智能心跳，并且在智能心跳中考虑了  的  对齐特性具体实现见_。再如在网络切换时，为了平滑切换的过程，使用了  中网络的特性，在  中做了延迟处理等。

移动特性优化。

微信的使用场景大部分是在手机端进行使用，在组件的设计过程中，我们也会研究移动设备的特性，并进行结合优化。例如，结合移动设备的无线电资源控制器的状态切换，对一些性能要求特别特别敏感的请求，进行提前激活的优化处理等。
阶段三：“抓妖记”
基础组件全量上线微信后，以微信的用户量，当然也会遇到各种各样的“妖”。例如，写网络程序躲不开运营商。印象比较深刻的某地的用户反馈连接  时，微信不可用，后来  发现，当包的大小超过一定大小后就发不出去。解决方案：在  网络下强制把  改为代码见 _。
做移动客户端更避不开手机厂商。一次遇到了一个百思不得其解的 ，堆栈如下：
      
      
      __
      
看堆栈结合程序  分析，非阻塞  卡在了  函数里超过了  被我们自带的  检测代码见发现然后自杀。最后实在束手无策，联系厂商一起排查，最终查明原因：为了省电，当手机锁屏时连的不是  且又没有下行网络数据时，芯片  会关闭， 住所有网络请求，直到有下行数据或者超过  才会放开。当手机有网络即使是手机网络的情况下，很难没有下行数据，所以基本不会触发组件自带的  检测，但当手机没连接任何网络时，就很容易触发。解决方案：厂商修改代码逻辑，当没有任何网络时不  网络请求。
运营商和手机厂商对我们来说已经是一个黑盒，但其实也遇到过更黑的黑盒。当手机长时间不重启，有极小概率不能继续使用微信，重启手机会恢复。但因为一直找不到一个愿意配合我们又满足条件的用户，导致这个问题很长一段时间内都没有任何进展，最终偶然一个机会，在一台测试机器上重现了该问题， 发现在三步握手阶段，服务器带回的客户端带过去的  字段被篡改，导致三步握手直接失败，而且这个篡改发生在离开服务器之后到达客户端之前。

这个问题是微信网络模块中排查时间最长也是花费精力最多的一个问题，不仅因为很长一段时间内无案例可分析，也因为在重现后，联系了大量的同事和外部有关人的帮忙，想排查出罪魁祸首。但因为中间涉及的环节和运营商相关部门过多，无法继续排查下去，最终也没找到根本原因。 解决办法：服务器更改 _ = 。
这段时间是痛并快乐着，见识到了各种极差的网络，才切肤感受到移动网络环境的恶劣程度，但看着我们的网络性能数据在稳步提升又有种满足感。截止到今天，已经很少有真正的网络问题需要跟进了。这也是我们能有时间开始把这些代码开源出去的很大的一个原因。
 介绍
讲述了一大堆  的发展历程，终于来到主角的介绍了。大概一年前，我们开始有想法把基础组件开源出去，当时大家都在纠结叫什么名字好呢？此时恰逢《火星救援》正在热映，一位同事说干脆叫  吧，于是就定下来叫了 。看了看代码，发现想要开源出去可能还是需要做一些其他工作的。
代码重构
首先，代码风格方面，因为最初我们使用文件名、函数名、变量名的规则是内部定义的规则，为了能让其他人读起来更舒心，我们决定把代码风格改为谷歌风格，比如：变量名一律小写 单词之间用下划线连接；左大括号不换行等等。但是为了更好的区分访问空间，我们又在谷歌代码风格进行了一些变通，比如：私有函数全部是”_”开头；函数参数全部以”“开头 等等。
其次，虽然最初的设计一直是秉承着业务性无关的设计，但在实际开发过程中仍然难免带上了微信的业务性相关代码，比较典型的就是  。为了  以后的维护以及保证开源出去代码的同源，在开源出去之前必须把这些业务性有关的代码抽离出来，抽离后的结构如下：

 也就是要开源出去的代码，独立  。
 是可能开源出去的代码，依赖 。
 是微信业务性相关的代码，依赖  和 。

最后，为了接口更易用，对调用接口以及回调接口的参数也进行了反复思考与修改。
编译优化
在 之前，是直接给  提供动态库，因为代码逻辑都已经固定，不需要有可定制的部分。给  系平台提供静态库，因为对外暴露的函数几乎不会改变，直接把相应的头文件放到相应的项目里就行。但对外开源就完全不一样了：日志的加密算法可能别人需要自己实现；长连或者短连的包头有人需要自己定制；对外接口的头文件我们可能会修改……
为了让使用者可定制代码，对于编译  平台我们提供了两种选择： 动态库。有些可能需要定制的代码都提供了默认实现。 先编译静态库，再编译动态库。编译出来静态库后，实现自己需要定制的代码后，执行  后即可编译出来动态库。 对于  系平台，把头文件全部收拢为  维护，直接编译出 。
为了能让开发者快速的入门，我们提供了 、、  平台的 ，其他平台的编译和  会在不久就加上支持。
成型的  结构图如下：

业界对比
我们做的一直都不是满足所有需求的组件，只是做了一个更适合我们使用的组件，这里也列了下和同类型的开源代码的对比。












跨平台






实现语言






具体实现
基于
基于 
基于 
基于 


支持完整的 






支持长连







扩展






结合移动
做设计







可以看出：
、 中包括一个完整的高性能的日志组件 ；、 中  是一个跨平台的  层解决方案，并不支持完整的  协议；、 中  模块是更加贴合“移动互联网”、“移动平台”特性的网络解决方案，尤其针对弱网络、平台特性等有很多的相关优化策略。
总的来说， 是一个结合移动  所设计的基于  层的解决方案，在网络调优方面有更好的可控性，对于  完整协议的支持，已经考虑后续版本会加入。
总结
经常有朋友和我说：发现网络信号差的时候或者其他应用不能用的时候，微信仍然能发出去消息。不知不觉我们好像什么都没做，回头看，原来我们已经做了这么多。我想，并不是任何一行代码都可以经历日活跃亿用户的考验，感谢微信给我们提供了这么一个平台。现在我们想把这些代码和你们分享，运营方式上  所开源出去的代码会和微信所用的代码保持同源，所有开源出去的代码也首先会在微信上验证通过后再公开。开源并不是结束，只是开始。我们后续仍然会继续探索在移动互联网下的网络优化。      

关注   来  给我们  吧一简介
华尔街见闻的运营方上海阿牛信息科技有限公司是全球金融信息服务提供商，每天全平台为近万用户提供资讯、数据、研究等服务。旗舰产品华尔街见闻  长期位居各应用市场财经资讯类客户端第位。由于将重大事件、市场的基本面变化和多种全球资产价格紧密关联，在金融领域具有极高渗透率。首创的快讯模式已经成为在中文世界理解全球市场的最快来源。也因此，该产品有技术架构复杂，需要高并发承载能力等特性。
二背景

老系统日益臃肿  
原先的系统是 架构，功能按模块划分，日积月累，最后模块达到个，新人接手项目会拿到一整个系统的代码，以及需要整个系统的配置，而他可能只需要专注开发不到的业务。

伸缩性  
我们的主要业务是即时资讯，资讯具有时效性，网站的访问量会呈现锯齿形分布。当遇到特大新闻如英国退欧、美国大选、法国大选等，我们要能弹性地通过增加服务资源，提高服务的容量。

容错性  
我们希望一个低优先级服务出现问题之后，不影响主要服务；一个主要服务能保证更高的可用性，就算出现问题，也要保证优雅降级。
比如在重大事件发生的时候，我们希望文章  保证不会受到影响。

单体应用  
单体应用在生产环境服务的时候，所有业务都跑在一个程序里，增加了系统的脆弱性，一个隐藏的性能问题，能在服务量激增的时候成为压垮骆驼的一根稻草。  

云服务商成本  
由于架构落后于需要，我们不得不用硬件弥补性能上的问题，导致云服务器成本不断增加。

线上运维  
由于没有方便的监控和运维工具，导致排查问题的效率低，使得在系统遇到问题的时候排查困难，耗时过长。

开发新功能  
开发新任务的同时，我们需要修复原有系统的性能问题。   架构图



每台服务器部署相同的服务端代码，由解释执行，通过进行反向代理。
三华尔街见闻微服务架构设计
因此，在年月至年月，我们采用微服务架构启动重构，尝试解决一部分上述问题，在伸缩性上能以服务为单位进行拓容，同时，这一设计会在某些方面增大我们的开发成本和运维成本。

错误排查复杂  
很显然，以前在单体应用中能直接登录服务器，查看出错日志，现在错误散落在不同的服务中，为我们的错误排查带来了困难。

日志源增加  
如何把服务的日志收集并分析。

基础设施增加  
每个服务有互相独立的  、 ，公共服务方面需要高可用的服务发现，调用链路分析，日志收集储存设施等。


技术选型
微服务架构图
每台服务器上均衡地部署服务， 接受用户的请求，将请求转发到 ， 向服务发现查询具体服务的和端口，服务执行完业务逻辑后向上返回数据。
服务框架
我们选择作为我们的后端开发语言。

在性能和开发效率上有很好的平衡，语法上很简单，并发编程简单高效，基础库健全。

调试工具强大  
自带一些包可以  当前程序的  消耗、内存占用、锁状态、阻塞等，非常便利我们定位问题。

有一些优秀的微服务框架  
我们选用作为开发框架，里面包含几乎所有微服务组件，并且支持非常好的拓展性，通过接口的设计方式，让我们可以拓展一些自己的组件，如服务发现、传输协议等。

在华尔街见闻已经有过比较多的应用，工程师使用开发几乎学习成本。


服务拆分
拆分的原则是通过服务功能划分，尽量避免双向依赖。经过拆分我们目前有个服务，包括用户、内容、实时新闻、评论、搜索、商城、支付、三方代理等服务。
服务间通信
服务间使用协议对数据进行编码，使用作为传输协议。
服务发现
 搭建多节点高可用的服务发现。
服务保护
我们选择作为服务保护以及服务降级的方案。  
每个服务开发者，需要定义自己服务接口的并发量、超时时间以及  方法。
部署方案
我们选择了。

  
这是我们最先选择的方案，因为 之后已经将功能集成到 ，能以最少的配置启动集群。经过简化和设计的控制台，方便地管理集群、调整服务如控制服务的数量、、内存限制等。往集群内加入机器非常简单，只需要运行一条命令即可。使用架构，作为调度节点，支持高可用。
但遇到了非常致命的问题，比如频繁更新服务的时候会出现服务访问不到，某服务的负载均衡后挂载的服务是其它服务的，服务之间的通信有几率出现超时问题，归根结底，还是社区正在不断完善 ，有很多不稳定的地方，网络方面没有进行优化。  

 
这是谷歌主导的服务编排工具，它支持，相比 来说，它的概念更多，分层更细。功能方面多于 ，支持一些高级功能如秘钥管理、配置管理、自动拓容等。在生产环境的应用比较广泛，稳定性更高。

裸机部署  
裸机部署是我们的一个备案，考虑到以上两个方案在当时没有具体线上实施的经验，所以如果 和都没有成功，我们直接裸机部署。  


裸机部署的需要解决单机端口冲突，如果一个服务在一个服务器上最多只部署一个，那么可以通过写脚本，并划分服务器角色的方式进行部署，利用可以定义服务集群、服务集群、服务集群等，通过分发二进制文件的方式让服务启动，这样的方案要考虑到服务更新、服务重启、服务删除等逻辑，同一时间只有部分节点更新，在服务未更新成功的时候流量暂时不能打到正在更新的节点。  
四准备工作
代码托管
由于之前使用开发人员的代码提交在有翻墙工具的帮助下速度依然不是很理想，我们自建了仓库，自此开发过上了幸福的生活。
容器化
和是基于快速创建删除服务，通过增加容器为服务拓容，缩减容器为服务缩小规模，所以所有项目必须要构建镜像。按项目类型划分，我们遇到种镜像打包情况。

后端项目  

后端服务是项目，针对的镜像，我们采取将项目编译成可执行文件，基于最小的镜像打包入，这里遇到过一个问题，就是里缺少的证书，无法支持，我们自定义了新的基础镜像，不仅将证书文件打入镜像，同时为了线上调试方便，增加了、、等工具，在初期调试容器间通信问题时发挥重要的作用。

前端静态文件

见闻的后台以及站基于，编译后生成的静态文件打入镜像，通过访问。
为了支持，我们打入镜像缺少的证书。

服务端渲染  

主站站基于、实现服务端渲染，所以不仅需要依赖，而且需要利用进行生命周期的管理。为了加速线上镜像构建的速度，我们利用源进行加速 并且将一些常见的依赖打入了基础镜像，避免每次都需要重新下载，镜像打包从开始的分钟缩减到分钟。
三类镜像结构
持续集成
我们利用 配置了测试、镜像构建、镜像发布、自动部署等流程，后端服务从提交代码到测试分支到测试环境自动部署完成花费分钟，前端服务平均为分钟。
任务中的流程
五云平台的选择
最终我们选择了腾讯云的容器服务，主要基于以下几点考虑：

腾讯云的容器服务是在腾讯云的上为每个用户构建容器集群，他们提供的微服务架构和持续集成与交付的应用场景基本满足了我们的述求。

腾讯云的容器服务是基于实现的，支持完全的能力。

腾讯云在上实现了他们的存储、负载均衡等产品的插件、复用了他们平台的监控、日志等能力。减少了我们接入和开发的成本。


六服务在腾讯云的应用
我们将我们的应用重构成微服务的架构，每个微服务部署成腾讯云容器服务上的一个服务，前端接入通过一个负载均衡。后端服务间可互相访问。
通过进行网络隔离，将网络划分为生产环境、测试环境，在生产环境中又划分子网和子网，设定子网之间的访问规则，增加服务端的安全性。
七性能对比
利用模拟线上请求的比例，利用台核的压测机在内网对台的机器上的服务进行压测，达到 以上，并且服务的负载并没达到极限，这已经是之前生产环境台服务器能达到的。
八线上调用追踪
通过追踪调用链的流向与耗时，我们可以找出性能的瓶颈。我们通过实际优化了几种情况

服务调用冗余  
当拉取文章列表的时候，我们需要拉取文章对应的作者信息，开始的时候我们使用拉取单个作者信息的方式，后来性能调优阶段，我们将其改为批量拉取作者列表，减少的冗余。  

服务耗时长  
对于有些本身就比较耗时并且对即时性不是那么苛刻的计算服务，我们为了保证服务的响应时间，会适量地加上缓存。


九监控与报警
由从外部系统表征到内部日志，我们将监控分为健康，程序错误报警，以及服务器容器负载。
排查问题的流程一般有两种情况，一种是用户发现问题，申报问题，开发人员跟进问题；一种是我们的监控优先发现问题，开发人员在用户反馈前跟进并修复。在报警方面，我们通过为监控系统谨慎设置报警阈值，当触发报警时，开发人员会收到邮件。
这里我们在报警的定义上有过思考，即什么样的报警算是有意义的？我们遇到过每天几条重复的报警，通常开发人员开始时会对报警非常重视，当重复的报警一再出现，渐渐失去了对报警的关注。所以我们有解除一些不必要的报警，并且对剩余一些报警进行调查，甚至有些警报是因为监控工具本身的不准确引起的。
健康
我们设置默认的时间区间是分钟

统计五分钟内平均   
 以内的延迟分布  
 最高的前的  
 的返回码的分布  

程序错误报警
后端程序内接入日志报警系统，程序捕获日志以及日志，并发送报警邮件。
服务器容器负载
通过在服务器上运行 进程，收集服务器并发送给，使用作为前端面板，对服务器负载以及容器的平均  、内存占用率进行监控。
十结束语
本文介绍了华尔街见闻微服务的实践情况。经过几个月的开发测试，已经完成了线上服务从到的转型。
在服务的稳定性上经历了考验，支撑了几次重大新闻的高流量。
在开发流程上，搭建了完善的自动化工具，减少了人工操作的重复性和误操作概率。
在运维方面，由于监控系统对系统完整的监控，与健全的上线、下线、回滚、拓容功能配合，能以极快的速度处理线上问题。作者：， 腾讯压测大师团队产品经理 
商业转载请联系腾讯获得授权，非商业转载请注明出处。 
原文链接：
 导读
天天图”军装照”活动交出了一份亿浏览量的答卷，一时间刷屏朋友圈，看到这幕，是不是特别想复制一个如此成功的？不过本文不教你如何做一个爆款，而是介绍天天图在“军装照”活动过程中，如何面对亿流量时的后台承载。

一、亿浏览量，“军装照”火了
这两天，相信 “军装照”活动已经刷爆了朋友圈，这个活动是由人民日报客户端策划出品并主导开发，腾讯天天图提供图像处理支持的一款产品。
天天图智能换脸
这款于月日晚一经推出，浏览量就迅猛攀升。月日时，浏览次数突破万，在月日：时，迎来了这次活动的最高峰值，图片生成请求达到每分钟万次，月日时突破亿。截至月日时，“军装照”的浏览次数累计亿，独立访客累计亿，一分钟访问人数峰值高达万。
后台数据截图
一般来说，一个产品浏览次数能超过万就很不错了，超过亿的十分罕见。如果以亿为标准，这款产品能够申请次世界纪录。
创纪录的浏览量背后，自然需要坚强的后盾，腾讯云与腾讯帮助天天图对图片上传下载，存储，智能分析、融合处理以及压力测试等服务提供技术支持，让“军装照”活动可以顺利延续影响力，保证用户的良好体验。
二、一个刷屏级的有多难？
在见证了一个个精妙的活动后，我们渐渐意识到，制作一个刷屏级的越来越难了。
面对，用户越来越“丧失耐心”
腾讯大数据年的《移动页面用户行为报告》中表示如果页面加载超过秒就会有的用户离开页面。
页面加载超过就会有的用户离开页面
图片来源：腾讯大数据《移动页面用户行为报告》
这样的数据是符合交易响应时间的“原则”的，也就是：
、 当用户能够在秒以内得到响应时，会感觉系统的响应很快；
、 当用户在秒之间得到响应时，会感觉系统的响应速度还可以；
、 当用户在秒以内得到响应时，会感觉系统的响应速度很慢，但是还可以接受；
、 当用户在超过秒后仍然无法得到响应时，会感觉系统糟透了，或者认为系统已经失去响应，而选择离开这个站点，或者发起第二次请求。
从腾讯大数据的数据来看，用户对于的容忍程度显然更低，在秒的时候，已经开始无法忍受了，因此根据这样的现实情况，对于移动页面，我们更应该关注一个全新的“原则“：
、 当用户能够在秒内打开页面，看到信息的展示，或者能够开始进行下一步的操作，用户会感觉速度还好，可以接受；
、 页面如果在秒后才进入可用的状态，用户的耐心会逐渐丧失；
、 如果一个界面超过秒甚至更久才能显示出来，这对用户来说基本是无法忍受的，也许有一部分用户会退出重新进入，但更多的用户会直接放弃使用。
举个例子：
年月日晚上九点半，一个名为《薛之谦个月没写段子，结果憋了个大招》的腾讯动漫的引爆了朋友圈，仅仅三个小时就已经突破的，而第二天早上的大概是左右。
该采用长图文视频的形式，在屏幕划到某一个位置，自动播放准备好的文件，起初，这个时长分秒的视频大小是，，如果在网络环境较好的情况，用户可以很流畅的观看，没有卡顿和延迟，但是为了提升用户的体验感受，进行了全面的优化，整体大小被下降到了。腾讯动漫的整体大小从左右优化到了
图片来源：《深度解析！薛之谦的二次元为什么又翻天了！》
对于一个的产品，功能无疑很重要，但是性能同样是用户体验中不可或缺的一环。原本的渲染性能就不及的，所以，的性能是一个绕不开的话题。
三、腾讯云 “军装照”攻克最后技术难关
为了保证“军装照”能够被用户顺利的访问，，天天图与腾讯压测大师合作，对的主要接口进行了多次压力测试。
、制定测试目标
根据之前多次活动经验，天天图对活动流量通常都有一个稳定的预期。天天图的技术团队将的压测目标制定如下：
事务成功率： 
响应时间： 
 
网络流量 

压测人数配置示例
、确认压测场景
对于“军装照”活动，最为重要的一个接口就是用户上传图片到天天图“人脸融合”后台的接口，通过完成接口地址的配置，天天图技术团队完成了压测的配置。
接口地址配置示例
天天图团队不断的通过压测大师测试接口，获取实时的承载数据，对服务器进行持续优化，从而实现一个最为稳定的状态。

压测数据结果数据
在完成了服务器架构的最佳优化之后，天天图在“军装照”活动爆红之后，依赖腾讯云海量处理能力和灵活扩展性，天天图团队紧急在腾讯云调动服务器，进行弹性扩容，从一开始的台，再到台，最终在最高峰动态部署了台腾讯云服务器。此外腾讯云还采用了智能分流、柔性策略等办法，确保稳定应对海量用户的请求。这样的弹性扩展因而支撑了“军装”亿次的浏览。
技术的兴起，注定着这款重要的网络语言将要承载越来越多的内容，为了满足用户越来越“不耐心”的响应时间要求，未来的以及页面针对性能势必进行更多的测试以及优化，保证用户在越来越多的场景下可以体验到最好的效果。

腾讯压测大师运用了沉淀十多年的内部实践经验总结，服务了包括王者荣耀、龙之谷手游、轩辕传奇手游、火影忍者等多款高星级手游，也包括天天图、直播等明星产品，通过基于真实业务场景和用户行为进行压力测试，帮助开发者发现服务器端的性能瓶颈，进行针对性的性能调优，降低服务器采购和维护成本。
为了让外部更多产品能够享受到简单易用的压测产品，腾讯决定将这份服务器测试能力产品化，以产品”压测大师“的形式，正式对外开放。目前更有元的压测优惠，欢迎大家的使用！
体验地址：
如果对使用当中有任何疑问，欢迎联系腾讯企业：作者：朱建平 腾讯云技术总监，腾讯  架构平台部专家工程师

关于人工智能的若干个错误认知
工智能是  工程师的事情，跟我没有什么关系
大数据和机器学习   是解决问题的一种途径和手段，具有通用性，是一个基础的技能。当前我们工作中还有很多决策，是基于经验和预定的规则，未来这部分决策可以通过  让我们做得更合理更好一些。
工智能太厉害了，未来会取代人类
随着人工智能的发展，特别去年谷歌的  围棋战胜代表人类的顶级棋手李世石，更是引爆了整个互联网。于是，网上不少人开始了很多担忧：机器人取代人类，有些人甚至在孩子高考填志愿时要求孩子填报艺术创作类似的方向，以避开未来与机器人或人工智能的竞争。
实际上，虽然目前人工智能在语音识别，图片识别近年来取得了突破，但人工智能还远未完善 数学理论尚不完备，“智能”的取得建立在大量的人工前期工作基础上，缺乏无监督学习。
 传统开发 转行  工程师的障碍
  急于求成的心态
    决策树，                智能驾驶，   个性化推荐 智能语音，     
晕了没？ 没晕再来一波

这里面的水很深，不要太急躁很快能搞懂，事实上由于数学理论不完备，有些东西还真解释不清楚，比如在图像识别上 比  识别率更高， 是怎么推导出来的？
梳理好这些概念，结合实际应用，化整为零逐步理解和吸收，有的放矢，不可操之过急。
　　
  自底往上的学习方法，想要从基本概念学习
建议结合应用场景先动手实践，再逐步细化。
推荐《机器学习》 周志华 清华大学出版社。

 工程师的知识结构 机器学习的基础知识
 人工智能、 机器学习、 深度学习的关系
这是现在大家经常混淆的概念，什么叫做人工智能？什么叫做机器学习？什么叫做深度学习？人工智能是最大的范畴，只要你用计算机做了一点智能的事情都可以称为做了人工智能的工作。真正的人工智能应该是让机器拥有人的智能，让机器跟人一样能看、能听、能说，能用自然语言跟人进行交流。这个涉及到计算机视觉、语音识别、自然语言处理、人机交互、语音合成等等，是常规的我们研究讨论的人工智能的主要发力点，在互联网公司有着广阔应用场景的。
机器学习可能是人工智能目前最火的领域，深度学习可能又是机器学习最火的子领域。什么时候需要用人工智能？直觉上来讲数据越复杂，深度学习越可能起作用；数据很简单很明确，深度学习可能就不怎么起作用了。比如搜索领域，目前只有  宣称他们用深度学习  了用户点击率，是指他们将深度学习运用在用户浏览过、搜索过的信息上，那是非常庞大非常复杂的数据。
　　
 机器学习解决问题的基本步骤
一般应用机器学习解决实际问题分为个步骤：

定义目标问题 
目前还没看到有一个机器学习模型适用于解决所有问题，不同问题有各自适用的模型，如图像相关问题有深度学习、推荐相关问题有专门的推荐算法、安全相关问题有异常检测模型等。脱离具体问题去讨论模型是没有意义的。　　  收集数据和特征工程
机器学习是面向数据编程，数据是机器学习的基础。训练模型时，一般会把样本数据拆成两部分，其中大部分约成数据用于训练模型，称其为训练集；另外少部分数据用于测试“模型的好坏”也称“泛化能力”，称其为测试集。
同一个机器学习算法，好的数据能让其表现更好，差的数据会让模型毫无用处。什么是“好的数据”？并没有统一定义，从结果看，能让模型表现良好的数据就是“好的数据”。一个可行的办法是想象“人”在解决该问题时，会依据哪些数据和特征做决策，然后挑选这些数据和特征作为机器学习模型的输入数据，这个过程就是特征工程。在应用机器学习时，可能需要反复做多次特征工程，特征工程是个试错的过程。　　  训练模型和评估模型效果　
利用标注数据，训练模型数据，而一般的步骤是：
 从底层存储读取数据
 对训练数据进行前向计算
 计算训练误差
 反向计算梯度，更新网络参数
 重复   步，直到模型收敛
测试模型效果，一般测试数据集远小于训练集，这里主要是快速前向计算，一般合并在第一步中。　　  线上应用和持续优化
模型在训练集上性能达标，但在线上环境性能不达标，这一现象被称为“过拟合”。通常的原因是用于训练模型的数据中特征的分布与线上数据偏差太大，此时需提取更具代表性的数据重新训练模型。 
模型在线上应用后，需持续跟踪模型的性能表现，机器学习是面向数据编程，如果线上系统上的数据出现了不包含在训练集中的新特征，需要补充新样本，重新训练迭代模型以保证预测效果。　　 机器学习的相关概念

模型用途：分类、回归、聚类
主要区分在于  的描述是什么性质分类是指  是整数即多个类别标签；回归是指  是一个实数，例如预测股票的走势， 是时间， 就是股票价格；聚类一般都是应用于非监督的状态下，对  完全不知道，只能对  数据本身进行统计分析，比如用户画像，通过数据之间的关系如关联程度将数据分成好几簇。
　　
训练过程 监督、半监督和非监督
机器学习是一个用数据训练的过程；监督是指  的每个数据样本，我们明确知道它的  如类别标签是什么；半监督是指我们只知道  数据样本中一小部分的  ，另外大部分不知道；非监督是指所有  的数据样本，我们完全不知道它们的  是什么。
　　
学习模型：决策树传统的分类和聚类深度神经网络卷积神经网络
常用模型：     
浅层和深层，以前的机器学习方法大都是浅层，浅层学习模型是从六十年代发展到现在；深层学习模型过去不怎么，自年迄今有了非常大的突破，深层模型在大量至少百万级别的有标签的数据驱动下将端到端之间的映射做的更深更完善。
　　
开源框架平台：      
为什么有这么多深度学习框架，参考《      》
入门成为  工程师的可行路径
虽然从垂直领域讲有语音识别，图像视觉，个性化推荐等业务领域的工程师，但从其所从事的研发内容来看，从事研发的工程师主要分为类：
   算法研究
这类人大都有博士学历，在学校中积累了较好的理论和数学基础积累，对最新的学术成果能较快理解和吸收。这里的理论是指比如语音处理，计算机视觉等专业知识。
算法研究的人主要研究内容有 样本特征，模型设计和优化，模型训练。样本特征是指如何从给定的数据中构建样本，定义样本的特征，这在个性化推荐领域中就非常重要。模型设计和优化是设计新的网络模型，或基于已有的模型机型迭代优化，比如网络模型中       等新模型的不断出现，另外就是比如模型剪枝，在损失计算精度情况下，减少计算量，以实现移动终端的边缘计算等等。模型训练是指训练网络，如何防止过拟合以及快速收敛。
 工程实现
这类人主要提供将计算逻辑，硬件封装打包起来，方便模型的训练和预测。比如：

精通等训练框架源码，能熟练使用并做针对性优化；

构建机器学习平台，降低使用门槛，通过页面操作提供样本和模型就能启动训练；

通过实行硬件加速，实现更低延时和成本的模型预测；

在新模型验证完成后，实现在线平滑的模型切换。
　　
 应用


侧重验证好的模型在业务上的应用，常见语音识别，图像视觉，个性化推荐。当然这也包括更多结合业务场景的应用，比如终端网络传输带宽的预测，图片转码中参数的预测等等。
 和  网络
  原理
深度神经网络是模拟人脑的神经元工作机制构建的计算处理模型。

激活函数常用的有：，等比如 典型的函数

多个神经元分层组织起来构成了一个网络，早期神经元网络仅能做到浅层，在训练方法和计算能力获得突破后，深层神经网络得到了更广泛研究和应用。
　　
  原理
简化的计算过程：

上图展示了一次卷积计算 一个×的图片 使用卷积核  进行卷积，得到输出图片  。输入图片中在  范围内的元素和卷积核中对应的元素相乘，最后乘积结果相加。
真实的计算过程：

上图是三维卷积的展示，对于第一层来说卷积核是，在输入立方体上进行滑动，对应图表 中的=，=，=卷积算法就是卷积核和立方体的重叠的每个值做乘运算，再把乘的结果做累加，最后得到一个值，数学公式为  =  ×   × … × ，因为卷积核共有个值，所以我们可以看成一个的矩阵乘以矩阵。
　　
 开发的典型场景

训练采用  单机框架，单机卡 ，为充分发挥 ，采用了数据并行，一次一个  张图片输入， 网络分为前层卷积层，后层为全连接层，主要的计算在卷积计算，我们将其用  实现，全连接层采用 实现。
海量准确的样本也是个细致活，需要不断运营。

腾讯云云客户案例

香港理工项目
该实验项目是基于美国气象局提供的年的气象数据，包括温度，湿度，风向，风速，降雨量，云层厚度，云图，空气浑浊度，日照等数据，对未来一段时间的天气进行预测。在该项目中，我们使用  进行基于神经网络深度学习的  框架，用  进行开发，并且在  上对深度神经网络进行训练。
、、 区别

大多数人可能有个大致的认识 训练用  预测用  或者  
 开发门槛低，未来主要承载 高性能网络，计算分拆出来的逻辑复杂，不适合并行计算的部分。
 最新的系列，采用工艺，因其  开发环境比较成熟，学习成本低，灵活性高，将继续在的模型训练阶段发挥关键作用。
 最新的 ，之前强调节能，单  在数据中心的部署也是一个全新的课题，未来可能会加强  片上  内存容量和带宽的增长。未来在在线模型预测方面发挥重要作用，但  不足，开发周期长是一个瓶颈。   卡，驱动开发， 实现导致使用门槛较高，未来会在  云上消除这些应用障碍。 
 腾讯云的  云、 云进展
 腾讯云  
年月，腾讯云宣布在国内率先使用英特尔下一代至强®处理器代号 ，推出国内最新一代云服务器。新一代云服务器在计算性能、内存带宽、网络时延等方面拥有显著优势，最高可提供 ，可满足企业对云服务器高规格高配置的广泛需求，尤其在人工智能等高性能计算领域将发挥更大价值。据介绍，目前腾讯云官网已开放新一代云服务器的试用申请，客户将花费更低的购买价格，享受到更高性能计算服务。
与过往采用至强系列处理器的云服务器相比，内置  至强®处理器的新一代云服务器具有更高计算性能、更大内存带宽、更强存储  性能、更低网络时延等优势，能满足游戏行业、视频行业、金融行业等领域的更高计算需求。具体而言， 至强®处理器具备的更优特性主要包括： 
 至强®处理器支持  指令 可支持更大数据宽度处理，能加速多媒体编解码、加解密数值运算，在机器学习、科学计算和金融分析等需要顶尖的浮点运算功能的场景提供更优质的处理性能。
至强®处理器支持  互联架构，有助于提供更快的数据访问效率、更低的延时服务。
  腾讯云 
腾讯云推出基于  最新企业级产品和的云产品  云服务器和  黑石服务器，其中，基于的  云服务器已于年底正式上线。今年上半年，腾讯云还将推出机卡的  云服务器，单机多卡整机性能更高，可以满足超大数据量超大规模机器学习算法需求，最大化提升计算效率。
 实例最多可提供  个   、 个  和  主机内存，以及双卡  的 显存。云服务器拥有高达个加速核心、单机峰值计算能力突破 单精度浮点运算，  双精度浮点运算。　　在视频渲染、虚拟化桌面、深度学习等对计算能力要求极高的场景中，腾讯云  云服务器以及  黑石服务器都有广泛的应用前景，同时还能满足图形数据库、高性能数据库、计算流体动力学、计算金融、地震分析、分子建模、基因组学、渲染等领域对基础设施的高要求，且极具性价比。
目前腾讯云服务器已开放官网申请。
 腾讯云 
腾讯云在年前宣布推出国内首款高性能异构计算基础设施“  云服务器”。已于年月内测上线，以云服务方式将大型公司才能长期支付使用的推广到更多企业。 腾讯云和业界厂商有良好的关系，提供了基于  和  两家的硬件平台和软件开发工具，方便开发者选择自己熟悉的开发模式，避免切换平台。
硬件平台
腾讯云即将发布基于  和  的单机卡  云服务器，推出多种规格的  实例供您选择。单机多卡整机性能更高，可以满足超大数据量超大规模机器学习算法需求。也可选择单卡可节省计算效率，轻资产开发，降低项目研发期间的投入成本。
 腾讯云官方  
 网络模型预测加速已上线— 用于图片鉴黄的粗筛
 网络模型预测加速今年上半年— 用于图片鉴黄的精选
同步开放的还有内部使用的图片压缩。
　　
 生态建设
我们通过市场，以开放合作的心态引入更多第三方成熟的  进来，为  生态的发展注入新的生机。
：机器学习对于模仿人的思考是怎么做到的？
现在机器学习模仿人的思考做的比较原始。目前主要还是提取人做某项决策时考虑的主要因素，在机器学习中我们叫样本特征来告诉模型，当遇到类似特征时应该输出什么。昨天月日，腾讯云技术社区推出的《云端架构师养成系列分享》迎来了第三期，主角是腾讯云的消息服务。本期邀请到的嘉宾是腾讯云资深产品经理张浩和后台开发工程师张晓宇。张浩同时也是第一期「高性能云硬盘入门与实战」的分享嘉宾。

腾讯云消息服务  是分布式消息队列服务，能够为分布式部署的不同应用之间或者一个应用的不同组件之间，提供基于消息的可靠的异步通信机制，消息被存储在高可靠、高可用的队列中，多进程可以同时读写，互不干扰。
官网的案例介绍中写道，微信架构组在红包系统引入了 ，避免分布式事务增加对系统的开销。这在一定程度上，也可以说是微信红包达到海量性能背后的一个原因了。

直播回看

本期分享 及演示代码：
详见本文附件。
下期预告
下一期的《云端架构师养成系列分享》将在月日晚点半进行，主题是「云服务器：弹性、安全、稳定的云计算服务」。
报名链接：=
往期回顾
云端架构师养成之一：高性能云硬盘入门与实战云端架构师养成之二：云端负载均衡上手与实践概念在国内已经有一些文章谈过，但是都处于理论范畴。而本文则是一篇实践的文章。
有必要说明我对的理解，表面上就是在一个聊天窗口中，发送一个命令给运维机器人，然后根据我们预定义的操作进行执行，并返回执行结果。至于更深层次的作用，就是将重复性的手工的运维工作自动化了，开发人员、运维人员可以按需执行一些运维操作。
另外，我做到了自动化搭建这一套东西感谢上那么多开源项目，让我少写很多脚本。为什么要自动化搭建呢？因为我懒，我不想每次通过一条条手工搭建。
本文主题
在的聊天窗口中命令执行一次构建任务。
工具介绍
有必要简单说明一下我们此次实现的这几个工具。

可以把想像成一个具有更多功能的或者微信。它依赖于，所以，我们还将自动化安装。
如果你了解过的话，它可以作为的开源替代表。

是出品的一个运维机器人。本质上就是一个接收命令消息，执行预定义操作的一个程序。而接收命令消息的这个组件在中被称为。比如我们希望接收来自聊天窗口里的消息，我们就必须为安装一个的。市面上，已经有很多了，我们很少需要自己实现自定义。
那么，接收到命令消息后，怎么知道执行哪些操作呢？这部分是需要我们实现了。本质上就是通过正则表达式匹配命令消息，然后操作。实际上通过写脚本实现。比如：
      
     = 
        
              
    
        {} 


就这个就不用多介绍了。值得一提是已经有不少自动化搭建的脚本了完全不需要人工干预，本文使用的是的。

能让开发人员快速上手的自动化运维工具。我们使用实现自动化。想简单了解，可以看看简单易懂系列 —— 解决了什么。
准备环境
需要准备几台机器：





安装






 




 




  ，



因为我是在本地做实验的，所以需要在本机虚拟化台机器。我使用  的方式来实现。具体如何使用，不在本文讨论范围。你也可以手工在或上创建相应的虚拟机。只不过是自动化了这个过程。会基于一个称为的文件来创建机器。
部分内容如下想看全文件点这：
  ||

  ___ = 
  __ = 
  _ = _
        ||
        = _
        _  
          ||
            = 
            = 
            = 
       
      
   此处省略其它机器的配置

因为我本地已经存在相应的 了，所以，直接使用命令就可以启动这几台机器：
  
  
  
搭建环境

 项目     
    

执行自动化部署所有的应用及配置   
 是一个类文件，用于描述机器，其实就是对机器进行分组。 是一个文件，用于描述如何部署我们的应用及配置。

就这样，我们的，，就已经搭建完成了。没错，就只需要扫行一条命令。是不是很爽
 客户端：，初次登录时，需要先注册一个超级管理员。 ，默认账号密码：
至于是如何搭建的，感兴趣的同学可以看代码。
以下是集成方法及需要注意的地方：
与集成

设置运维机器人现在需要在中添加一个作为运维机器人，我们选择默认用户作为运维机器人，这里需要注意的是

必须具有的角色：、
必须设置密码，我设置了为
邮箱必须，设置时只要勾选上就可以了


安装 

启动时需要指定这几个环境变量以便能登录上：
  _=
  _=
  ___=
  _=
  _=
  _=

验证  因为我们安装了脚本，一下，它有回应，就说明我们成功集成了和。
 


与集成

安装脚本：
配置连接的环境变量：  __=
  __=

在中，操作的 比如列出当前的列表：
 
 再比如执行这个 


与集成
与集成主要用于当的发生变化时主动推送消息到中。

在中安装插件

在系统设置中，设置参数： 

在构建中设置    如果你使用的是 ，也支持          

验证在上手工点击构建按钮，的 应该会有消息提醒：

小结
至此，我们简单的框架算是搭好了。剩下的就是根据你们自己业务进行改造了。另外多说一句：思维模式不应该被职位所局限。本文不明之处，欢迎来邮讨论咨询：  简介
 是一个使用  语言编写的   调度和监控工作流的平台。 被  内部用来创建、监控和调整数据管道。任何工作流都可以在这个使用  来编写的平台上运行。 
  是一种允许工作流开发人员轻松创建、维护和周期性地调度运行工作流即有向无环图或成为  的工具。在  中，这些工作流包括了如数据存储、增长分析、 发送、 测试等等这些跨越多部门的用例。
这个平台拥有和 、、、、 和  交互的能力，并且提供了钩子使得系统拥有很好地扩展性。除了一个命令行界面，该工具还提供了一个基于  的用户界面让您可以可视化管道的依赖关系、监控进度、触发任务等。 
传统  通常使用     来定义  然后  解析这些  文件形成具体的  执行；  没这么干，它直接用  写  一下子突破了文本文件表达能力的局限，定义  变得简单。
 的架构
在一个可扩展的生产环境中， 含有以下组件：

一个元数据库 或 

一组  工作节点

一个调节器 或 

一个   服务器


所有这些组件可以在一个机器上随意扩展运行。如果使用  来适度的安装则可以获得相当多的额外性能。
 

优点

 脚本实现  ，非常容易扩展

工作流依赖可视化

 

可测试

可作为  的替代

可实现复杂的依赖规则



 和  


功能简介

常见命令

，初始化元数据 ，元数据包括了  本身的信息、运行信息等；

，清空元数据 ；

_，列出所有 ；

_，列出某  的所有  ；

，测试某  的运行状况；

，测试某  在设定的日期区间的运行状况；

，开启  服务；

，用于监控与触发  。



，是英文  的缩写，用来描述将数据从来源端经过抽取、转换、加载至目的端的过程。一词较常用在数据仓库，但其对象并不限于数据仓库。
 设计时，只是为了很好的处理  任务而已，但是其精良的设计，正好可以用来解决任务的各种依赖问题。
任务依赖
通常，在一个运维系统，数据分析系统，或测试系统等大型系统中，我们会有各种各样的依赖需求。比如：

时间依赖：任务需要等待某一个时间点触发。

外部系统依赖：任务依赖  中的数据， 中的数据等等，这些不同的外部系统需要调用接口去访问。

机器依赖：任务的执行只能在特定的某一台机器的环境中，可能这台机器内存比较大，也可能只有那台机器上有特殊的库文件。

任务间依赖：任务  需要在任务  完成后启动，两个任务互相间会产生影响。

资源依赖：任务消耗资源非常多，使用同一个资源的任务需要被限制，比如跑个数据转换任务要个 ，机器一共就个 ，最多只能跑两个，我希望类似的任务排个队。

权限依赖：某种任务只能由某个权限的用户启动。


也许大家会觉得这些是在任务程序中的逻辑需要处理的部分，但是我认为，这些逻辑可以抽象为任务控制逻辑的部分，和实际任务执行逻辑解耦合。
如何理解 
现在让我们来看下最常用的依赖管理系统，。
在各种系统中，总有些定时任务需要处理，每当在这个时候，我们第一个想到的总是。
确实， 可以很好的处理定时执行任务的需求，但是对于  来说，执行任务，只是调用一个程序如此简单，而程序中的各种逻辑都不属于  的管辖范围很好的遵循了  。
所以我们可以抽象的认为：
 是一种依赖管理系统，而且只管理时间上的依赖。
的处理依赖的方式
 的核心概念，是  有向无环图， 由一个或多个  组成，而这个  正是解决了上文所说的任务间依赖。  执行完成后才能执行  ，多个之间的依赖关系可以很好的用表示完善。
 完整的支持  表达式，也支持直接使用  的  表述时间，还可以用  的  表述时间差。这样可以解决任务的时间依赖问题。
 在  下可以使用不同的用户启动  ，不同的  监听不同的  ，这样可以解决用户权限依赖问题。 也可以启动在多个不同的机器上，解决机器依赖的问题。
 可以为任意一个  指定一个抽象的 ，每个  可以指定一个  数。每当一个  启动时，就占用一个  ，当  数占满时，其余的任务就处于等待状态。这样就解决了资源依赖问题。
 中有  机制其实我觉得不应该叫  ，作用时建立一个与外部数据系统之间的连接，比如 ，，本地文件系统文件系统也被认为是外部系统等，通过拓展  能够接入任意的外部系统的接口进行连接，这样就解决的外部系统依赖问题。
参考
=_=的核心概念是，而的关键特性之一是其不可变性，来规避分布式环境下复杂的各种并行问题。这个抽象，在数据分析的领域是没有问题的，它能最大化的解决分布式问题，简化各种算子的复杂度，并提供高性能的分布式数据处理运算能力。
然而在机器学习领域，的弱点很快也暴露了。机器学习的核心是迭代和参数更新。凭借着逻辑上不落地的内存计算特性，可以很好的解决迭代的问题，然而的不可变性，却非常不适合参数反复多次更新的需求。这本质上的不匹配性，导致了的库，发展一直非常缓慢，从年开始就没有实质性的创新，性能也不好。
为此，在设计生态圈的时候，优先考虑了。在推出的时候，就已经具备了  的功能，基于为加上了功能，在不变中加入了变化的因素，可谓如虎添翼。
我们将以为例，来分析在机器学习算法的实现上的问题，以及  是如何解决在机器学习任务中的遇到的瓶颈，让的机器学习更加强大。
 算法说明
模型参数更新过程如下：
 ←  λ· 
其中， 是模型参数，  =    是搜索方向， λ 是通过线性搜索得到的步长。
计算 =    伪代码如下所示，这是人们常说的 算法，是算法的核心部分。返回值  是我们说要的。

其中，   是单位阵，=  =  ，算法将最近  轮生成的  和  序列，记做 {} 和 {}。基于计算 {} 和 {} 计算  。
的实现
 实现框架
中的负责协调整个任务执行的同时，需要保存最近  轮的 {} 和 {} 序列，并在上执行 算法。而负责分布式地计算梯度向量。

迭代过程：每轮迭代，将每个计算的梯度到 和  保存在上，在端执行 算法上更新模型 ，并将  广播到每个
 性能分析
基于的实现的算法优点比较明显：

 可以快速读写上的训练数据；    
细粒度的负载均衡并行计算梯度时，具有强大的并行调度机制，保证快速执行；    
容错机制当计算节点挂掉、任务失败，会根据的关系链实现数据的重计算。但是对于迭代式算法，每轮迭代要用的操作，打断的，避免因为重计算引起逻辑的错乱；    
基于内存的计算基于内存的计算过程，可以加速机器学习算法中计算梯度过程的耗时。

该实现的缺点：

引起的网络瓶颈用聚合梯度时，如果模型维度达到亿级，每个梯度向量都可能达到几百兆；此时的的效率非常低；    
单点  
保存{}和{}序列需要较大的内存空间；  
 算法是由单点执行，该过程是多个高维度的向量的运算；
每轮迭代，都需要和完成高维度向量的和。



的  实现
 实现框架
  借助 的功能为引入的角色，减轻整个算法流程对的依赖。 算法的运算交给，而只负责任务的调度，大大减轻的对性能的依赖。
 由一组分布式节点组成，每个、被切分成多个保存到不同的节点上，同时支持和之间的运算；
{} 和 {} 序列分布式地保存到 上， 算法中高维度的向量计算也是在上完成。 每轮迭代过程会从上  到本地，并将计算的梯度向量到。

迭代过程：每轮迭代， 将上的模型   到本地，计算梯度，然后梯度向量给 和  保存在上，在端执行 算法上更新模型 
 性能分析
整个算法过程，只负责任务调度，而复杂的 运算在上运行，梯度的和模型的同步是和之间进行，所有运算都变成分布式。在网络传输中，高维度的会被切成小的数据块再发送到目标节点，这种节点之间多对多的传输大大提高了梯度聚合和模型同步的速度。
这样  完全避开了中单点的瓶颈，以及网络传输高维度向量的问题。
“轻易强快”的  
  是为解决在机器学习模型训练中的缺陷而设计的“插件”，没有对做侵入式的修改，是一个独立的框架。可以用 “轻”、“易”、“强”、“快” 来概括  的特点。
 轻  插件式的框架
  是为解决在机器学习模型训练中的缺陷而设计的“插件”。  没有对中的做侵入式的修改，  是依赖于和的框架，同时其逻辑又独立于和。
因此，用户使用  非常简单，只需在的提交脚本里做三处改动即可，详情可见的     文档
可以看到提交的  任务，其本质上依然是一个任务，整个任务的执行过程与一样的。
 {_}
_ \
      \
     =__ \
     = \
     = \
     = \
     __ \
    

  能够成为如此轻量级的框架，得益于对的封装，使的和可以通过、与 做数据交互。

 强  功能强大，支持库
库是实现的面向机器学习的数值运算库。 的大部分数值优化算法都是通过调用来完成的。如下所示，和  两种实现都是通过调用实现的。的实现是传入的类型是库的，而  的实现是传入。
是指 上的，该实现了 下的方法，如常用的 ，，，等运算，因此在  算法中的高维度向量运算是之间的运算，而之间全部在 上分布式完成。

的实现

 
    =    
    =  

  的实现

接口调用里的泛型从  变成 
   
    =    
    =  

 易  编程接口简单
能够在大数据领域这么流行的另外一个原因是：其编程方式简单、容易理解，  同样继承了这个特性。
  本质是一个任务，整个代码实现逻辑跟是一致的；当需要与做运算时，调用相应的接口即可。
如下代码所示，在和  上的实现，二者代码的整体思路是一样的，主要的区别是梯度向量的和模型  的。因此，如果将的算法改造成  的任务，只需要修改少量的代码即可。
需要用户实现，的接口输入参数是  ，遍历训练数据并返回  和 。
其完整代码，请前往 

的实现

        {
         = {
       广播 
        = 

       通过的方式计算和
         = 
            

        =  _  
         
    }
  }

  的实现

接口输入参数是  ，遍历训练数据并返回  和 。其中  和 都是；计算梯度时，需要将   到本地，本地的值，需要通过的方式到远程上的向量。
        {

          = {
       初始化向量：
        = 

       计算梯度和
        =  {  =
         模型  到  本地
          = 
           =  
         本地的到的
        
        
      }

       =   
         
    }
  }

 快  性能强劲
我们分别实现了、、三种优化方法的，并在和  上做了实验对比。该实验代码请前往   

数据集：腾讯内部某业务的一份数据集，亿样本，千万维度
实验设置：说明：三组对比实验的资源配置如下，我们尽可能保证所有任务在资源充足的情况下执行，因此配置的资源比实际需要的偏多；说明：执行任务时，需要加大参数；而  就不用配置此参数。


如上数据所示，  相较于在训练模型时有以上的加速；对于越复杂的模型，其加速的比例越大。
结语
  的出现可以高效、低成本地克服在机器学习领域遇到的瓶颈；我们将继续优化  ，并提高其性能。也欢迎大家在上一起参与我们的改进。项目：，喜欢的话到上给我们。前言

，  将 数据库进行开源啦。是使用图形处理单元以毫秒为单位分析数十亿行数据的先驱，比传统的基于的数据库快几个数量级。 数据库及其可视化库开源让每个人都可以使用这个世界上最快的分析平台。
今天，笔者就要教大家如何在腾讯云上安装这个“新玩意”。
本文安装目录就直接选择了。
这里创建了一个用户。
准备工具

腾讯云服务器 系统为   位
登陆工具

系统准备
下面全部在用户下执行，需要切换用户的地方会指明
一、安装
这个网上教程一大堆，在这我就快速安装了。
执行以下代码：
  

然后
 
在该文件里面输入
 __=__

二、安装 存储库额外的包
  

三、更新并重启
 


时间太长，看会皮卡丘再回来。：
四、创建用户并更新密码
  
 

五、安装驱动
    __
  _
  
  

上面第一条命令的版本可以修改 “_” 就是这一部分可以改成你想要的版本，现在最新版本为 要想安装其它版本或者是的可以点击这里下载相应的驱动。
安装完成后在  下检查是否存在这个东西，如果不存在的话，请重新执行第五步操作
安装中途提示输入密码，记下此密码，后面要用。
六、设置防火墙
  = = 
  

开始安装系统
一、先去的官网下载安装包
这是他们官网地址。
点击按钮，然后点击按图所示的按钮。

然后把弹出的窗口的信息填好，邮箱一定要真，之后你的邮箱会收到一封邮件。

点击如图所示的会自动下载，可以复制下载链接到中，然后用命令下载：
 
下载下来的文件名为，通过命令把其改为并移动到  用户的目录下，然后解压安装
  
 
  
然后将解压出来的文件夹改名为 ，为了方便：
 _ 

安装目录可以自选，在这笔者为了方便就安装在里了
二、配置
输入下面命令，修改环境变量：
 
环境变量里面添加如下内容：
 _=
 _=
 _=
 _=
 __=
然后
 
使得环境变量生效
创建数据目录并修改目录权限
   _
   _ _
初始化数据库
_ _
安装
 _
__

三、 启动
启动 
   _
   __
设置 随系统启动
   _
   __
四、验证
验证系统是否启动成功，加载一些数据，然后执行查询。
首先进入的安装目录：
 _
___
然后你会看到下面的提示：

：里面有亿行数据：里面有万行数据
这里笔者选择的。
然后执行：
_
默认的密码为 下面输入的密码为。
至于如何更改密码可参照的官网文档，在这里笔者就不说了

然后输入查询语句开始查询：
 _   _    
   __       _
_
如果看到以下内容说明成功：

这个数据库还有一个好处，就是提供了一个可视化的平台。在浏览器中输入你服务器的公网 ，如图所示：

然后创建一个新的仪表盘和点图，验证是否正常工作。
在这里笔者就随便创建了，然后得到下面的图，说明成功了。

别说，这图很好看
如果安装中途出现问题，或者是最终安装出来没有此效果，请小伙伴们重新安装一篇，仔细仔细再仔细，实在不行在评论区联系我。月日下午，宝贝回家论坛一台服务器开始出现异常的高负载情况。首先是自动触发了自动扩容机制，增加了新服务器进来分担压力，保障了服务的持续可用，给问题解决争取了时间窗口。

随后手机收到告警短信，登录腾讯云控制台，首先排除了，因为外网入带宽和出带宽都正常。异常的是内网出带宽和入带宽。难道有内网的服务器发起攻击？登录到服务器上来看，没有看出什么异常，没有特别高的进程，进程确实多了一些，每个进程的时间也确实长了一些，但是也不说明什么问题。看_也没有看到聚集的请求。
怀疑服务器本身有异常，把服务器重启了一下，问题没解决。

把出现问题的服务器从负载均衡中踢出，问题立刻消失。加回到负载均衡集群中，问题没有再出现了。

随后发现，另一台原来没有问题的服务器现在变成高负载了。一样从负载均衡中踢出来再加回去，这下两台都高负载了。
没有什么头绪，只好继续分析_。这次看出来问题了。

有一批来自世界各地的肉鸡也可能是伪造的在根据用户一个一个的访问用户资料。这些都来自哪里的呢？

所以问题很清晰了，这是一个攻击，并且攻击是分散的，不能通过封来化解。

攻击者借助代理服务器生成指向受害主机的合法请求，实现和伪装就叫：。

对于攻击，是有对应的设计的，可以在_中配置，不过对抗手段都会或多或少的影响到正常访问。针对这次攻击我启用了 _=
也就是要求每个用户第一次访问的时候都要看一个秒的等候页面，然后自动进入原来的访问地址，这是目前对于用户访问体验伤害最小的方式用户什么都不用做，只要第一次等秒就一切正常了。如果攻击没有继续升级对抗这个策略的话，这次攻击应该就到此为止了。


相关推荐
新时代运维监控能力的进化——天网云用户体验监控平台实践 【黑客解析】黑客是如何实现数据库勒索的本文作者：  


此前，如果我们需要实现函数的返回值域给函数调用最简单的方式是

 
面向对象的话可以
  = {
      
       {
           = 
           
    }
     {
         = 
         
    }
     {
         =
         
    }
}


  
  
  
如果在端我们还可以使用



基本使用
而在中，也为我们提供了管道运算符，它的基本用法是，将上一个函数执行，且将返回值作为入参，传递给下个函数的形参。并执行下一个函数，直到全部函数执行完成，返回最后一个函数返回的结果。例如如下三个函数
   {
        
}
   {
     
}
   {
     
}
 原来的方式
  = 

  
 使用管道函数重构
  = 
  | 
  | 
  | 

  
同时，我们可以借助箭头函数在流的中间截获中间值例如另外一个自定义一个函数
   =   {
       
}
然后我们改写一下我们的函数
  = 
    | 
    |  = 
    | 

   
柯里化
我们还可以通过实现函数柯里化首先我们来复习一下柯里化
  {
    =  
     {
      =  
      
    }
}


  =   {
   
}


 接下来我们可以使用重写上述逻辑
  {
     {
      = 
           =      || 
  }
}

  = 
  |  

  
也是比较优雅的
继承
我们也可以在对象继承方面做一些文章
 基础对象
    {
   {   }
}

 功能函数
   {
   =   {
       
  }
   
}

   {
   =   {
       
  }
   
}

   {
   =   {
       
  }
   
}

   {
  =   {
       
  }
    
}

 具体对象
    {
     |  |  |  | 
}

    {
     |  |  | 
}
这样我们就能很轻松的搭配我们所需的功能函数，拼装为具体能实现的实例
数据检测
同时，关于数据检验，我们现在可以这样玩
     {
     {
         ||        
     
  }
}

    {
     {
           
     
  }
}

  {
     伪代码
}

   {
  
    |   
    |  
    | 
    | 
}

 {
  {   ____}
}  {
       
}

在此之前，如果要绑定函数的作用域，我们一般用的是   如今， 为我们提供了一个语法糖 栗子如下：
  = {
     
     {
         
    }
}

  = {
     
}


    
 等效于 
如果不指定左值，则绑定默认的上下文

 
我们可以发现，对于函数，如果 有执行符  则被编译为，如果没有则会编译为如果我们传递了多个参数，则会被编译为

  
 为我们带来了很多便利，首先就是 中需要绑定域的场景
 = 我们完全可以使用 进行改写 = 同时对于一些类数组，我们的操作也可以变得更加优雅
  = 

 = {
       
}

 等价于

  = {
       
}
当我们对数据需要进行一系列处理的时候，我们还可以这么玩
  {
     {
     
  }

     {
     
  }


   
      
      
      
      
}
等价于
  = 
        
        

      = 
      = 

      
 和 
在此之前我们就能通过  将对象的转为数组，如今，为我们扩展了这类的方法
  = {
     
     
     
}
  = 
    
如上，我们可以使用输入一个对象内的所有我们还可以使用  输出每一个键值对
  = {
     
     
     
}
  = 
       
 
 扩展了两个方法
 
                 
    
  
       
           
 
                  
     
   
            
未来我们可以更好的处理字符串了
   {
    =  大爷，您可来了，小的这就给您斟茶倒水，招呼菊仙姑娘
      
}


逗号不会抛错
有些时候复制多个对象可能后面不小心会留下一个小逗号
  = {
  
  
}
又或者 写函数入参的时候
  {
  `{} {}`
}

 
还有可能是数组


当代码复杂且代码被混淆|压缩|编译|转义的时候，可能一个逗号的也要查半天，断点调 在的规范中，能够忽视这种错误，让程序正常的跑起来当然，虽然规范给了我们这样的便利，还是最好不要犯这种低级的错误比较好。
共享内存
现在共享经济日渐火爆，有共享单车、共享充电宝、共享女友 当然也少不了共享内存了？！    我们可以通过  来开辟一个子进程

  =  
如果主线程和子线程需要通讯的话，主要使用  和 主线程

 =   {
  
}
子线程
  {
  
  
}
而现在我们可以开辟一定大小的存储空间，进行线程间数据共享  =      的共享内存    通过 将指针发送给子线程子线程直接从全局获取到指针，并写入数据，完成内存共享
 
 =   {
    = 
}
下面是一个素数生成器的例子
  =  __     个素数
  =      == 
  =    伪代码，素数生成器网上有对应实现
   =       
    = 

 
 =   {
   =           == 
    第位素数 
}
值得注意的是，在共享内存内两个线程都能够修改数据
   
 =   最后为 
所以，应该有合理的机制来保证共享内存的合理使用

未来还会提供一个类似  方法一样的全局对象  下存在多个静态方法用来操作  共享内存对象具体可以看 _关于  的介绍
求幂运算符
以前在写动画的时候，经常这么操作
  = 
 {   } = 
现在 新规范为我们推出了  求幂运算。我们可以直接这样
     

 等同于  

  = 
 = 

   

原文出处：社区本文内容是我学习时做的一个练手项目，描述应用机器学习的一般步骤。该项目的目标是从点击流数据中找出恶意用户的请求。点击流数据长下图这样子，包括请求时间、、平台等特征：

该项目从开始做到阶段性完成，大致可分为两个阶段：算法选择和工程优化。算法选择阶段挑选合适的模型，尝试了神经网络、高斯分布、 等三个模型。由于点击流数据本身的特性，导致神经网络和高斯分布并不适用于该场景，最终选择了 。工程优化阶段，最初使用单机训练模型和预测结果，但随着数据量的增加，最初的单机系统出现了性能瓶颈；然后开始优化性能，尝试了分布化训练，最终通过单机异步化达到了性能要求。 
 算法选择
 神经网络
刚开始没经验，受热潮影响，先尝试了神经网络。选用的神经网络是 ，多层感知器，一种全连接的多层网络。是有监督学习，需要带标签的样本，这里“带标签”的意思是样本数据标注了哪些用户请求是恶意的、哪些是正常的。但后台并没有现成带标签的恶意用户样本数据。后来通过安全侧的一些数据“间接”给用户请求打上了标签，然后选择、平台、版本号、操作码等数据作为的输入数据。结果当然是失败，想了下原因有两个：
，  样本的标签质量非常差，用这些样本训练出来的模型性能当然也很差；
，  输入的特征不足以刻画恶意用户。
数据的质量问题目前很难解决，所以只能弃用。 
 高斯分布
然后尝试其他模型。通过搜索发现，有一类模型专门用于异常检测，找到了 介绍的基于高斯分布的异常检测算法： 。高斯分布如下图所示：

这个算法的思想比较简单：与大部分样本不一致的样本就是异常；通过概率密度量化“不一致”。具体做法是：选择符合高斯分布或能转换为高斯分布的特征，利用收集到的数据对高斯分布做参数估计，把概率密度函数值小于某个阈值的点判定为异常。 
所谓的参数估计是指，给定分布数据，求分布的参数。对高斯分布来说，就是求μ和σ。用极大似然估计可以得到高斯分布参数的解析解：

得到高斯分布参数后，用下式计算概率密度：

表示一个特征输入。若有多个特征、、…、，一种简单的处理方法是将其结果连乘起来即可： = …。 
然后选定一个阈值ε，把  ε的样本判定为异常。ε值需根据实际情况动态调整，默认可设定ε = μ σ。 
把这个模型初步应用于点击流异常检测时，效果还不错，但在进一步实施过程中碰到一个棘手问题：样本中最重要的一个特征是操作码，当前操作码在微信后台的取值范围是 ，每个操作码的请求次数是模型的基础输入，对个特征计算概率密度再相乘，非常容易导致结果下溢出，以致无法计算出精度合适的概率密度值。这个现象被称为维度灾难 。 
解决维度灾难的一个常见做法是降维，降维的手段有多种，这里不展开讨论了。在点击流分析的实践中，降维的效果并不好，主要原因有两个：
，  正常用户和恶意用户的访问模式并不固定，导致很难分解出有效的特征矩阵或特征向量；
，  降维的本质是有损压缩，有损压缩必定导致信息丢失。但在本例中每一维的信息都是关键信息，有损压缩会极大破坏样本的有效性。 
高斯分布模型的维度灾难在本例中较难解决，只能再尝试其他模型了。 
  
 ，可翻译为孤异森林，该算法的基本思想是：随机选择样本的一个特征，再随机选择该特征取值范围中的一个值，对样本集做拆分，迭代该过程，生成一颗 ；树上叶子节点离根节点越近，其异常值越高。迭代生成多颗 ，生成 ，预测时，融合多颗树的结果形成最终预测结果。 的基础结构有点类似经典的随机森林 。算法的细节见这里：。 
这个异常检测模型有效利用了异常样本“量少”和“与正常样本表现不一样”的两个特点，不依赖概率密度因此不会导致高维输入的下溢出问题。提取少量点击流样本测试，它在维输入的情况下也表现良好，最终选择它作为系统的模型。 
 工程优化
工程实现经历了单机训练、分布式训练、单机异步化训练个方案，下面内容介绍实现过程中碰到的问题和解决方法。 
 单机训练
整个系统主要包括收集数据、训练模型、预测异常、上报结果四个部分。 
 收集数据
刚开始尝试该模型时，是通过手工方式从获取样本的：
，通过 ，得到手工登录成功用户的和登录时间；
，利用提供的接口，得到用户登录后分钟的点击流； 
但这样做有两个缺点：
，上述步骤是离线手工操作的，需要做成自动化；
，的接口性能较差，只能提供万的查询性能，上海登录的峰值有万。 
改进办法是复用点击流上报模块，增加一个旁路数据的逻辑：
，手工登录时在中记录手工登录时间，基于该时间旁路一份数据给。由于每次只能提供单挑点击流数据，所以需要在中缓存；
，做完数据清洗和特征提取，然后把样本数据落地，最后利用定期将该数据同步到集群中。 
最终的数据收集模块结构图如下所示：

 点击流数据提供了、平台、版本号、操作码等特征，经过多次试验，选定用户手工登录后一段时间内操作码的访问次数作为模型的输入。 
上面我们提到过点击流的操作码有个有效取值，所以一个显然的处理方法是，在中把用户的点击流数据转化为一个维的向量，是 ，是对应的访问次数。该向量刻画了用户的行为，可称为行为特征向量。 
 训练模型
初起为了控制不确定性，只输入万分钟的样本给模型训练和预测。系统的工作流程是先从加载上一分钟的样本数据，然后用数据训练 模型，最后用训练好的模型做异常检测，并将检测结果同步到。 
在万分钟输入下取得较好的检测结果后，开始导入全量数据，全量数据数据的峰值为万分钟左右。出现的第一个问题是，一分钟内无法完成加载数据、训练模型、预测结果，单加载数据就耗时分钟左右。这里先解释下为什么有“一分钟”的时间周期限制，主要原因有两个：
，  想尽快获取检测结果；
，  由于点击流异常检测场景的特殊性，模型性能有时效性，需要经常用最新数据训练新的模型。 
解决性能问题的第一步是要知道性能瓶颈在哪里，抽样发现主要是加载数据和训练模型耗时较多，预测异常和上报结果的耗时并没有随数据量的增加而快速上涨。 
加载数据的耗时主要消耗在网络通信上：样本文件太大了，导致系统从同步样本数据时碰到网络带宽瓶颈。但由于样本是文本类数据，对数据先压缩再传输可极大减少通信量，这里的耗时比较容易优化。 
训练模型的耗时增加源于输入数据量的增加。下图是万样本的输入下，系统个阶段的耗时：

其中：加载程序： 加载数据： 训练模型：分类异常： 保存结果： 单轮总耗时：需处理全量数据时，按线性关系换算，“训练模型”耗时为：   = ，约为分钟，单机下无法在分钟内完成计算。最先想到的优化训练模型耗时的办法是分布式训练。 
 分布式训练
由于只提供单机版的 实现，所以只能自己实现它的分布式版本。了解了下目前最常用的分布式训练方法是参数服务器 ，模式，其想法比较简单：训练模型并行跑在多机上，训练结果在合并。示意图如下所示：

分布式训练对算法有一定要求，而 正好适用于分布式训练。 
然后尝试在上实现 的分布式训练版本。选择的原因有主要两个：
，  已经实现了一个分布式训练框架；
，  的包已经实现的 可作参考 在结构上与 类似，只需对 定制一个即可的细节看这里：___。 
写完代码测试时，发现了个巨坑的问题：内部的序列化操作非常频繁、性能十分差。构造了个测试样本，耗时只有秒，万次函数调用；而耗时达秒，有亿次函数调用。 
性能抽样：
 
性能抽样：

从的性能抽样数据可以看到，耗时排前排的函数都不是实现 算法的函数，其原因应该与基于、的实现方式有关。感觉这里坑比较深，遂放弃填坑。 
也了解了下基于的，该项目暂时还未支持 ，也因为坑太深，一时半会搞不定而放弃了。 
 单机异步化训练
没搞定分布式训练，只能回到单机场景再想办法。单机优化有两个着力点：优化算法实现和优化系统结构。 
首先看了下中 的实现，底层专门用优化了，再加上库的多并行，算法实现上的优化空间已经很小了，只能从系统结构上想办法。 
系统结构上的优化有两个利器：并行化和异步化。之前的单机模型，加载数据、训练模型、预测异常、上报结果在单进程中串行执行，由此想到的办法是启动个工作进程分别处理相应的四个任务：异步训练模型、预测异常和上报结果，并行加载数据。工作进程之间用队列通信，队列的一个优势是容易实现流量控制。
 写完代码测试，却发现环境中的 库在多进程并发下直接抛异常。尝试多个方法发现这个问题较难解决，暂时只能想办法规避。经测试发现，直接从同步所有压缩过的样本数据只需秒左右，由此想到规避方法是：先单进程同步所有样本数据，再多进程并发解压、加载和预测。 
按上述想法修改代码测试，效果较好，处理所有样本只需秒左右，达到了分钟处理完所有样本的要求。然后提交作业线上跑，处理所有样本耗时却达到～秒：

咨询侧同学，得知对提交的离线作业有配额的硬限制，分时段配额如下表：
    
晚高峰时段的配额只有。 
与侧同学沟通，他们答应后续会支持库的在线服务。目前通过手工方式在一台有的机器上运行在线服务，晚高峰时段处理全量数据耗时为秒左右。 
最终的系统结构图如下图所示：

模型训练进程定期训练最新的模型，并把模型通过队列传给预测进程。预测进程每分钟运行一次，检查模型队列上是否有新模型可使用，然后加载数据、检测异常，将检测结果通过上报队列传给上报进程。上报进程在上报队列上，一旦发现有新数据，就根据数据类型执行上报监控、上报等操作。 
 评估性能
安全侧将异常用户分为以下几类：盗号、加好友、养号、欺诈、外挂多开等。由于这些分类的异常打击是由不同同学负责，不便于对 的分类结果做评估，因此需要在 的基础上，再加一个分类器，标记“异常样本”的小类。利用操作码实现了该分类器。 
接入全量数据后，每天准实时分析亿量级的样本，检测出万左右的异常，精确分类出万左右的恶意请求。恶意请求的、类型、发生时间通过中转给安全侧。安全侧通过线下人工分析和线上打击，从结果看检测效果较好。 
 持续优化
再回过头观察点击流数据，我们使用的 模型只利用了操作码的统计数据。可以明显看到，点击流是一个具备时间序列信息的时序数据。而自然语言处理  ，领域已经积累了非常多的处理时序数据的理论和实战经验，如、等模型。后续期望能引入的相关工具挖掘出更多恶意用户。作者：腾讯研究院高级研究员  徐思彦

导读

放眼全球的人工智能领域，美中英是在此领域表现最为突出的三个国家。英国一直是人工智能的研究学术重阵。牛津大学、剑桥大学、帝国理工学院及伦敦大学学院等高校、研究机构都在人工智能和机器学习领域有深厚的积累。从论文引用率来看，英国研究质量超过中国，略逊于美国。
浓厚的学术环境催生了大量人工智能初创企业，其中包括掀起人机对战浪潮的。在人工智能的发展历史上，也有独特的地位。英国是“人工智能之父” 的故乡，未来英国人工智能的发展也将和 有更加密不可分的关系。
此外，英国政府也是产业发展的给力靠山。去年月，英国政府曾发布人工智能报告，希望借助人工智能的创新优势提升整体国力。今年月日，英国政府再次发布了名为《在英国发展人工智能》的报告，对当前人工智能的研究、市场和政策支持进行了分析。作为英国数字战略的一部分，该报告也会被纳入英国政府行业战略中，发表于年底出版的《政府行业策略指导》白皮书中。
本报告从四方面提出了促进英国产业发展的重要行动建议：数据获取、人才培养、研究转化和行业发展。腾讯研究院将为您解读英国政府如何从政府层面思考人工智能为经济社会带来的变革及发展战略。

“长久以来，都只是概念。最近的科技突破可以让自动化更深入地渗透生活的方方面面，现在是时候让所有的科学家、研究者、企业家和政府携手一起研究奖如何影响我们的社会来确保我们的革命性科技创新能够释放其许诺的潜力。”
——报告作者  教授

一、愿景
不同研究者对人工智能的定义各不相同。对人工智能内涵理解也将直接影响到研究内容和应用领域。在本报告中，英国政府将“人工智能”理解为够让机器高效地处理复杂问题的一系列数字技术，包括了从统计学、计算机科学和认知心理学中发展出来多种技术。英国工程物理科学研究委员会使用了这样的描述，“技术的目标是复制或者超越计算机系统中需要人类智能的部分，具体包含了学习与适应、感知理解和交互、推理和计划、过程与参数优化、自动化、创造力以及根据多元复杂的大数据提炼知识与预测。”通过人工智能可以更好地使用信息来制定或提出更准确的决策，将其集成到现有流程中，改进它们，扩展它们并降低成本。
站在英国政府的立场上，本报告为研究提供了一个切实的目标。英国政府认为，的技术发展当前已经到了行业广泛应用的时间点。通过提高生产力以及创造全新的产品和服务，这是英国经济迫切的需求。现在应用型以及渗透到了各行各业，改变了不同领域的商业实践：包括金融、法律、医疗、会计、审计、建筑、咨询服务、服务业、制造和交通业等。英国政府的愿景是让英国成为世界上商业发展和部署最好的地方，从起步、发展到繁荣，逐步收获技术红利。

二 、英国人工智能的应用现状
人工智能是数字革命的下一站。人工智能并不是单一的技术或者赛道，它将融入现有的数字技术中，在垂直领域加深数字化的影响，影响到所有和数据相关的领域。
■ 数据经济：收集数据为了发展，发展为了管理数据
据估算，年，数据产业将为英国经济带来亿英镑的增长。数据产业的快速发展带来的复杂性和海量数据导致只有用才能处理、分析、管理数据。
■ 英国产业：
英国培育一批非常具有创新力的公司，新公司的诞生频率也非常快。根据年的 报告，“过去个月，英国几乎每星期就有一家新的创业公司成立”。年月，一项研究估计，英国有家独立的早期公司。这些公司中，产生了一批被美国巨头收购的独角兽公司，包括年收购的，年收购的，年苹果收购的以及年收购的 。
■ 七大领域公司：

报告中还特别强调了人工智能面向政府的潜在应用，英国的公共服务部门已经开始应用，提高公共服务的效率。英国的政府数字化服务利用机器学习来生产上的用户评价来预测公众最关心的内容。公共部门是否能成功应用与企业相似，领导者需要进一步理解人工智能使用的场景以及数据相关问题，落地能力。
■ 评价未来对英国经济的影响：
据的估算，到年，可以为英国经济增加额外亿美元约合亿英镑收入，将年增长率从增加到％。

三、国际比较
在投资和活动规模方面，英国和其他国家通常被认为是落后于美国和中国的。在全球交易份额方面，英国仍然远远落后于美国，年的投资交易预计将流向美国的初创公司，只有的投资会流向英国的创业公司。年至年，公司的全球风投基金中，只有的投资流向了英国企业见下表。更多的英国投资似乎在早期阶段，英国公司中有四分之三的公司在寻求种子或天使投资，而美国公司中寻求种子或天使投资的占二分之一。英国家公司中只有家寻求成长资本，相比之下，美国的这一数字是五分之一。

数据来源： 
不过，英国一直以来都有强大的人工智能科研实力。牛津大学、剑桥大学、帝国理工学院及伦敦大学学院等高校、研究机构都在人工智能和机器学习领域有深厚的积累。英国在年至年间，发表的学术论文数量排在全球第，前三名依次是中国、美国和日本。其中，中国在同期发表论文篇。但从论文引用率来看，英国研究质量超过中国，略逊于美国，排名第二。

四 、四大领域政策建议
为了确保人工智能的革命性科技创新能够释放其许诺的潜力，本报告从四方面提出了促进英国产业发展可操作、可交付的重要行动建议，包括数据获取、培养人才、支持研究与应用发展。通过这些政策建议，学术界、产业界和政府可以携手并进加强英国在全球人工智能竞争中的实力。
一提高数据获取性的建议
数据是人工智能产业发展的核心，人工智能的发展也为开发者和政府对于数据的获取和治理提出了新的问题。本部分建议强调让数据更加开放，提高机器可读性以及平衡数据的隐私和开放，从而增强人工智能领域的信任。

推动拥有数据的机构和寻找数据来发展的机构之间的合作和共享。政府和行业应该成立相关项目，来发展数据信任。

为了提升开发人工智能系统的数据可用性，政府应确保由公共资资助的研究应该以机器可读的格式发布基础数据，并提供明确的权利信息，并尽可能开放。

为了支持文本和数据挖掘作为研究的标准和必要工具，英国应该规定一种默认规则：对于已发表的研究，阅读权也是挖掘数据的权利，在那里不会产生替代原创作品的替代品。在评估如何支持文本和数据挖掘时，政府应该提到的潜在数据用途。


二关于提高技能的建议
培养人工智能的人才是人工智能产业发展的核心问题，其中既包含人工智能领域的专业学术、研发人才，也包含未来人工智能行业中大量的低技能劳动力。政府应当为其创造多元的技能培训计划，并且提高全民的科技素养。

政府、产业界和学术界必须充分利用的价值和多元化的重要性，并应该共同努力打破成见，扩大参与。

工业界应该赞助主要的学生项目，帮助学生在领域攻读硕士课程，第一批学生人数为人。

大学应该与雇主和学生一起探讨硕士学位毕业生的潜在需求。

政府和大学应该至少在领先的大学设立个专门的博士学位名额。随着英国教育和吸引更多的学术人才，这个数字应该会持续增长。

大学应该鼓励发展 和在线持续专业发展课程，为那些有资格的人提供更多专业知识。

英国人工智能协会的国际奖学金项目应该与艾伦·图灵研究所合作：图灵人工智能奖学金。这应该由一个专门的基金支持，以确定和吸引最优秀的人才，并确保英国对来自世界各地的所有合格的专家开放。


三加强研究与商品化
英国已经有顶级的人工智能研究土壤，为了研究的应用及产业化，政府应当为研究及其技术转移铺平道路，加速的商品化和产业化。

艾伦图灵研究所应该成为国家人工智能和数据科学研究所，真正成为国家级的，并扩展到目前的五所大学，其中一个关键的目标是把它的中心任务集中在人工智能。

大学应该使用清晰的、可访问的以及可能的公共政策和实践来授权知识产权和创建公司。

艾伦图灵研究所、工程与物理科学研究委员会、科学技术设施理事会和联合信息系统委员会应共同努力，协调对研究的计算能力的需求，并为英国研究团体进行协商。


四关于支持产业发展的建议
为了释放带来的经济潜力，政府需要帮助行业降低合作壁垒，打通学术界与企业界，推进行业的发展与应用。

政府应该与行业和专家合作，建立一个英国人工智能委员会  ，帮助协调和发展英国的应用。

信息专员办公室和艾伦图灵研究所应该制定一个框架来解释提供的程序、服务和决策，以提高透明度和问责制。

国际贸易部门应扩大其目前对业务的支持计划。

应该与英国皇家工程学院、 和工业领域的关键参与者合作，为在英国经济中成功利用的机遇和挑战提供实用的指导。

政府，利用政府数字服务的专业知识、数据科学伙伴关系以及其他部门的数据工作专家，应该制定一项行动计划，为公共部门做好准备，并推广应用改善公民运作和服务的最佳实践。

政府应确保产业战略挑战基金和小型企业研究计划面临的挑战，旨在吸引和支持在整个有挑战性的领域的应用。


感谢新智元对相关内容的整理及翻译