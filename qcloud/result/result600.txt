存储
在本节我们介绍一下的操作，在本节开始之前请确保你已经安装好了及 库。
和
库提供两个类和用于实现的命令操作。
实现了绝大部分官方的命令，参数也一一对应，比如方法就对应命令的方法。而是的子类，它的主要功能是用于向后兼容旧版本类里面有几个方法为了做兼容，将方法改写，比如方法就将和的位置互换，和命令行的命令参数不一致。 
官方推荐使用，所以本节我们也用类的相关方法作演示。
连接
当前在本地我已经安装了并运行在端口，密码设置为。
那么可以用如下示例连接并测试：
   

 = = = = =
 


在这里我们传入了的地址，运行端口，使用的数据库，密码信息。在默认不传的情况下，这四个参数分别为、、、。现在我们声明了一个对象，然后接下来调用了方法，设置一个键值对，然后在将其获取打印。
运行结果：

这样就说明我们连接成功，并可以执行、操作了。
当然我们还可以使用来连接，示例如下：
    

 = = = = =
 = _=

这样的连接效果是一样的，观察源码可以发现内其实就是用、等参数又构造了一个，所以我们直接将当参数传给也是一样的。
另外还支持通过来构建，的格式支持如下三种：


=

这三种分别表示创建 连接、 连接、  连接，我们只需要构造上面任意一种连接即可，其中部分如果有则可以写，没有可以省略，下面我们再用连接演示一下：
 = 
 = _
 = _=

我们首先声明了一个连接字符串，然后调用_方法创建一个，然后将其传给即可完成连接，所以使用的连接方式还是比较方便的。
操作
在这里主要将的一些判断和操作方法做下总结：



方法
作用
参数说明
示例
示例说明
示例结果





判断一个是否存在
 名

是否存在这个




删除一个
 名

删除这个




判断类型
 名

判断这个类型




获取所有符合规则的
 匹配规则

获取所有以开头的




获取随机的一个


获取随机的一个



 
将重命名
 原名  新名
 
将重命名为




获取当前数据库中的数目


获取当前数据库中的数目



 
设定的过期时间，单位秒
 名  秒数
 
将这的过期时间设置秒




获取的过期时间，单位秒，为永久不过期
 名

获取这的过期时间



 
将移动到其他数据库
 名  数据库代号
 
将移动到号数据库




删除当前选择数据库中的所有


删除当前选择数据库中的所有




删除所有数据库中的所有


删除所有数据库中的所有




操作



方法
作用
参数说明
示例
示例说明
示例结果




 
给数据库中为的赋予值
 名  值
 
给这个的赋值为




返回数据库中为的的
 名

返回这个的



 
给数据库中为的赋予值并返回上次的
 名  新值
 
赋值为并得到上次的



 
返回多个对应的
 的列表
 
返回和的
 


 
如果不存在才设置
 名
 
如果这不存在则设置值为
第一次运行，第二次


  
设置可以对应的值为类型的，并指定此键值对应的有效期
 名  有效期  值
  
将这的值设为，有效期秒



  
设置指定的值的子字符串
 名  偏移量  值
    
设置为字符串，并在为的位置补
，修改后的字符串长度



批量赋值
 字典
{   }
将设为，设为




均不存在时才批量赋值
 字典
{   }
在和均不存在的情况下才设置二者值



 =
为的增值操作，默认，不存在则被创建并设为
 名 增长的值
 
对应的值增，若不存在则会创建并设置为
，即修改后的值


 =
为的减值操作，默认，不存在则被创建并设置为
 名 减少的值
 
对应的值减，若不存在则会创建并设置为
，即修改后的值


 
为的的值附加
 名
 
向为的值后追加
，即修改后的字符串长度


  =
返回为的的的子串
 名  起始索引  终止索引，默认截取到末尾
  
返回为的值的字符串，截取索引为的字符



  
获取的值从到的子字符串
 名  起始索引  终止索引
  
返回为的值的字符串，截取索引为的字符




操作



方法
作用
参数说明
示例
示例说明
示例结果




 
在为的尾添加值为的元素，可以传多个
 名  值
   
给这个的尾添加、、
，大小


 
在为的头添加值为的元素，可以传多个
 名  值
 
给这个的头添加
，大小



返回为的的长度
 名

返回为的列表的长度



  
返回为的中至之间的元素
 名  起始索引  终止索引
  
返回起始为终止为的索引范围对应的
  


  
截取为的，保留索引为到的内容
名  起始索引  终止索引
  
保留为的索引为到的元素



 
返回为的中位置的元素
 名  索引
 
返回为的列表为的元素



  
给为的中位置的元素赋值，越界则报错
 名  索引位置  值
  
将为的索引位置赋值为



  
删除个的中值为的元素
 名  删除个数  值
  
将为的列表删除个
，即删除的个数



返回并删除为的中的首元素
 名

返回并删除名为的第一个元素




返回并删除为的中的尾元素
 名

返回并删除名为的最后一个元素



 =
返回并删除名称为在中的中的首元素，如果为空，则会一直阻塞等待
 列表  超时等待时间，为一直等待

返回并删除名为的的第一个元素



 =
返回并删除为的中的尾元素，如果为空，则会一直阻塞等待
 列表  超时等待时间，为一直等待

返回并删除名为的的最后一个元素



 
返回并删除名称为的的尾元素，并将该元素添加到名称为的的头部
 源的  目标的
 
将为的尾元素删除并返回并将其添加到为的头部




操作



方法
作用
参数说明
示例
示例说明
示例结果




 
向为的中添加元素
 名  值，可为多个
   
向为的中添加、、三个内容
，即插入的数据个数


 
从为的中删除元素
 名  值，可为多个
 
从为的中删除
，即删除的数据个数



随机返回并删除为的中一个元素
 名

从为的中随机删除并返回该元素



  
从对应的中移除元素并添加到对应的中
 源  目标  元素值
  
从为的中删除元素并添加到为的




返回为的的元素个数
 名

获取为的中元素个数



 
测试是否是为的的元素
值
 
判断是否为为的元素



 
返回所有给定的的交集
 列表
 
返回为的和为的的交集
{}


  
求交集并将交集保存到的集合
结果集合 列表
  
求为的和为的的交集并保存为



 
返回所有给定的的并集
 列表
 
返回为的和为的的并集
{  }


  
求并集并将并集保存到的集合
结果集合 列表
  
求为的和为的的并集并保存为



 
返回所有给定的的差集
 列表
 
返回为的和为的的差集
{ }


  
求差集并将差集保存到的集合
结果集合 列表
  
求为的和为的的差集并保存为




返回为的的所有元素
 名

返回为的的所有元素
{  }



随机返回为的的一个元素，但不删除元素
 值

随机返回为的的一个元素



 操作



方法
作用
参数说明
示例
示例说明
示例结果




  
向为的中添加元素，用于排序。如果该元素存在，则更新其顺序
 名  可变参数
    
向为的中添加，为，添加，为
，即添加的元素个数


 
删除为的中的元素
 名  元素
 
从为的中删除
，即删除的元素个数


  =
如果在为的中已经存在元素，则该元素的增加，否则向该集合中添加该元素，其的值为
 名  元素  增长的值
  
为的中的减
，即修改后的值


 
返回为的中元素的排名按从小到大排序即下标
 名  元素值
 
得到为的中的排名



 
返回为的中元素的倒数排名按从大到小排序即下标
 名  元素值
 
得到为的中的倒数排名



   =
返回为的按从大到小排序中的从到的所有元素
 值  开始索引  结束索引  是否带
  
返回为的前四名元素
   


   = = =
返回为的中在给定区间的元素
名  最低 最高  起始索引  个数  是否带
  
返回为的中在和之间的元素


  
返回为的中在给定区间的数量
名  最低  最高
  
返回为的中在到的元素个数




返回为的的元素个数
 名

获取为的中元素个数



  
删除为的中排名在给定区间的元素
名  最低位次  最高位次
  
删除为的中排名第一的元素
，即删除的元素个数


  
删除为的中在给定区间的元素
名  最低 最高
  
删除在到之间的元素
，即删除的元素个数



操作



方法
作用
参数说明
示例
示例说明
示例结果




  
向为的中添加映射
 名  映射键名  映射键值
  
向为的中添加映射关系，的值为
，即添加的映射个数


  
向为的中添加映射，如果映射键名不存在
 名  映射键名  映射键值
  
向为的中添加映射关系，的值为
，即添加的映射个数


 
返回为的中对应的
 名  映射键名
 
获取为的中键名为的



  
返回为的中各个键对应的
 名  映射键名列表
  
获取为的中和的值
 


 
向为的中批量添加映射
 名  映射字典
 {   }
向为的中批量添加映射



  =
将为的中映射的增加
 名  映射键名  增长量
  
为的中的值增加
，修改后的值


 
为中是否存在键名为的映射
 名  映射键名
 
为的中的值是否存在



 
为中删除键名为的映射
 名  映射键名
 
从为的中删除键名为的映射




从为的中获取映射个数
 名

从为的中获取映射个数




从为的中获取所有映射键名
 名

从为的中获取所有映射键名
   



从为的中获取所有映射键值
 名

从为的中获取所有映射键值
   



从为的中获取所有映射键值对
 名

从为的中获取所有映射键值对
{       }引言
在几乎所有的应用开发中，都会涉及到配置文件的变更，比如说在的程序中，需要连接数据库，缓存甚至是队列等等。应用开发上线过程需要分别部署到开发环境、测试环境、预发布环境等多个环境。而每一个环境都要定义其独立的各种配置。如何对配置文件进行管理，是应用程序管理的重要内容。
中通过资源管理应用程序的配置信息。本质上是一个基于键值方式存储的一段文本。支持三种使用方式：

设置成容器的环境变量。
在容器的启动参数中使用。
将中的内容，作为文件挂载到容器某个目录下。

腾讯云容器服务根据用户使用的场景。基于的实现了通过配置文件设置容器的环境变量和将中的内容挂载到容器的某个目录。
中将配置文件内容设置成容器的环境变量
在示例中我们创建一个如下所示的配置文件。
 

   |
    
     = 
    
    =
  _ 
   
   
 

   
   

然后将对应的设置成容器的环境变量。
 
 

   

  
      
       
           
      
          
          
            
               
               
          
          
            
               
               
          _
          
            
               
               _
   

当结束后会输出
=
_=
=
腾讯云容器服务如何使用配置文件设置容器的环境变量
腾讯云容器服务基于的实现了将配置文件导入成容器的环境变量。并且在此基础上，提供管理配置文件版本的功能。配置文件的修改都是基于版本进行保存，配置文件保存后不能修改只能新增版本，这样保证了配置文件同一个版本的内容不变，方便回滚和追溯。
在腾讯云容器服务中将配置文件，设置成容器的环境变量操作步骤如下：
 在配置页面创建对应的配置项

 在服务创建更新时选择从配置文件导入环境变量

 选择需要导入的环境变量

 查看导入的环境变量

这样在服务创建更新时配置文件对应的内容就会被设置成容器对应的环境变量。
将配置文件内容挂载到指定目录
 
 

   

  
      
       
          
      
        
         
        
         
  
      
      
         
        
          
           
          
           
      
      
         
        
          
           
   
使用    命令进入容器后，查看挂载文件的信息。
   
  
   

 = 

=
   

   

腾讯云容器服务如何使用配置文件中的内容挂载到指定目录
在某些情况下，程序已经定义了配置文件的读取形式为：从某个路径下的文件读取。这样简单的通过环境变量的方式就不能满足需求。
腾讯云容器服务考虑到具体的需求场景，同样也支持将配置文件中的内容，通过文件的形式挂载到指定目录。
具体的步骤如下：
 创建对应的配置文件

 从配置文件导入挂载项

 选择对应的挂载项

 查看创建的挂载项

 在容器中设置对应的挂载点

这样在就可以将配置文件中对应的内容，通过文件的方式挂载到容器指定的目录了。同样的，我们登录容器后查看挂载文件的信息。

可以看到分别将和中的内容挂载到了和两个目录。腾讯云容器服务支持远程在界面远程直接登录容器，具体操作方法可以参考
总结
中对于程序的配置文件通过进行管理。在使用上支持配置文件设置成容器的环境变量以及将配置文件的内容作为文件挂载到指定目录。
腾讯云容器服务基于中的功能，支持配置文件设置成容器的环境变量和支持挂载到制定目录。在界面直接进行操作，更加方便。同时支持配置文件的版本管理，便于回滚和追溯。送出一个是的 数据包到目的地，当路径上的第一个路由器收到这个数据包时，它将减。此时，变为，所以该路由器会将此数据包丢掉，并送回一个「  」消息包括发包的源地址，包的所有内容及路由器的地址，收到这个消息后，便知道这个路由器存在于这个路径上，接着再送出另一个是 的数据包，发现第 个路由器 
每次将送出的数据包的 加来发现另一个路由器，这个重复的动作一直持续到某个数据包 抵达目的地。当数据包到达目的地后，该主机则不会送回  消息，一旦到达目的地，由于通过数据包向不常见端口以上发送数据包，因此会收到「  」消息，故可判断到达目的地。
一、原理及问题


使用模拟器抓包分析，实验拓扑：

在路由器上 

通过抓包分析：

看第个数据包使用协议请求大于不存在的端口，当收到  包时停止。

第个包回  包

问题：为什么不是显示 ？

解答：你无法从中得知包返回的路径以及路由器使用的  和 的 值得一提的是在     中提到，包的源地址必须是传包出去的物理接口绑定的其中一个                                    。 
经过实验证实了这个问题。一个探测包确实会有可能从路由器的一个接口进，  包从另外一个接口出，并且源是进的接口，按照个人理解其原因是路由器会把进的接口产生的超时包当作外来的包并遵循路由表进行路 由转发，转发过程不会改变包的源目。因此在外部看来这个包并不符合文档的定义。
延时计算
在探测包发出时打上时间戳；
当收到响应时打上时间戳；
根据两个时间戳计算往返时间；
路由器不对包的时间做任何处理，只是单纯的转发数据； 延时计算的是包的往返时间，但显示的是去的路径上所经过的路由。
二、中的反向解析
提供了比较多的信息，可以通过这些信息进行问题排查


从东京到美国绕欧洲过去，那就不太理想了。 从印度到美国要，但从日本到美国并不需要。
中包含的接口信息：


很多网络都会尝试将接口信息放在，需要注意的是： 接口信息通常是帮助他们排查自己网络的问题； 接口信息有可能不是最新的。虽然很多大型网络会自动产生，但其余的不会； 可以帮助你识别接口的类型，通过接口类型甚由器的型号。
例如：是 端口，该设备至少有个板卡槽；至少一台板卡槽的路由器，因为它有一块板卡在板卡槽。


边界的变化：      
路由的变化：        
问题：想知道路由是否同时属于两个，使用掩码方法 两个路由器之间一般是点到点，为了省配置。
 
三、延时

串行延时产生原因：一个数据包被移动到网络上的时候是一个不可分的单元；在一个数据包传输完毕之前另外一个数据包无法发送。
队列延时
在高速网络中该延时非常小：
       =        =        =        =  
利用率
的接口跑到我们会说利用率是，但实际上，一个接口只能进行转发数据利用或者不能转发数据利用，故所谓的利用率实际上是指内有用来了传输数据。 
排队
当一个接口在被使用，下一个包必须排队等待被发送。通常来说，一个接口使用率等于将要转发的包都在排队。当一个接口达到饱和时，排队时间将迅速增加，当一个接口过饱和时，一个包排队可能要耗费几百甚至几千毫秒，排队延时通常与拥塞程度相关联。

在美国本土传播耗时，延时不正常。
四、路由跟踪
每一跳延时计算：

探测包到达一个特定路由器的时间

路由器生成  的时间


  返回到的时间
第一个和第三个时间都是受实际网络情况影响的，而第二个时间不是。能够对网络问题的判断起到帮助作用的仅仅只有第一个和第三个时间，第二个时间生成涉及到路由器的，第二个时间往往起到误导的作用。 其中经过的路由器是不会对时间戳做任何处理。

如何排查假延时？

最重要的一个规则：如果在某一跳中发生问题，那么所有后续跳的延时将会持续或增长。
影响耗时的因素 
通常是路由器的限速与优先级问题；
最坏情况是路由器回包过程中走的路径不同导致的非对称转发路径

第一跳紫色：折回点为 
第二跳红色：折回点为 
第三跳绿色：折回点为  
可以看到第三跳不是原路返回的，如果 返回的路径上出现拥塞，那么第三跳上将不会出现拥塞情况，故在时可能会看到第二跳延时高于第三跳。
如何排查？

等价等长路由

等价不等长路由

产生原因：路由器错误传递，将=的包传到下一跳 路由器，会将源地址重写，导致后面的跳数看上去都是那个。
如何避免？

利用强大的参数设置，固定目标端口不变，就能够出同一条路径了 版本，可固定目标端口不变，指定目标端口。但是需要注意出来的路径不一定是实际数据包走的路径。可以通过目标 加或减进行多次来完成多路径的。网络中区分数据流的策略很多，三层网络通常是根据源、目标来区 分一个数据流，因此固定目标端口，更改目标能够让探测包走不同的路径，从而让更加准确。
 隧道 ：很多大型网络都有运用，有些路由器只根据的标签进行转发而没有路由表，当包产生时问题就出现了，这些路由器要怎么去转发这些包？其中一种解决方案是 隧道。 当一个包产生并打上标签时，路由器会根据标签交换路径转发表将包转发至下一跳，这会导致的结果看起来非常奇怪，你会看到中间很多跳的延时会跟某一跳的延时是一样的

根据原理  包应该是由每一跳的路由直接返回给。 但是，在 隧道中，包会一直走到的出口才会返回给，这就造成在上的所有跳的延时都是几乎一样的。 其实这里还会引申出一个问题，那就是跳数缺漏。

相关推荐
谈谈后台服务的和路由管理在之前一直使用引擎作为默认存储引擎，本篇从源码角度对引擎作分析，业界一直以来对用实现存储引擎褒贬不一，本文对此不作探讨。
存储按照来分目录， 每个目录下有 文件 {} {} 等文件。 目录下存放的是   用于故障恢复。 目录结构如下：

|
           |_
           |_
           |
|
           |
           |
           |
|
           |
           |
           |
这三类文件构成了引擎的持久化单元。本文主要从代码层次分析每类文件的结构。
元数据管理
文件映射
引擎加载某个时，首先初始化，相当于的元数据入口。__
      _{}      
     _ _               
       =  
    _
     = _
    _    
如上，创建对文件的，将内存的直接映射到上不不进行任何解析。因此文件是一个的内存镜像。
的关系_，采用的是开放寻址。
  _      {        
       {        
          _ {        
                
                  =         
         }       
        
          _ ==   _ ==  {        
               =  
                       _               
              =  
                      
         }        
                 
          =      
           ==  {        
                   _                 
              
         }       
           =  {        
               =         
                  
                   _         
              
         }       
     }       
 }
上述过程是开放式寻址的经典的查找过程，如果有冲突，向后跳一格，如果跳到查找的起点依然没有找到可用的空槽，则说明满了。
元数据内容窥探
一个对象对应该下的某张表的元数据_，大小为，默认为文件分配的空间，且文件唯一且不可动态伸缩空间，可以推断出一个实例至多可建表大概个。该类有个字段，重要字段有如下个。
  {
 对应于一个内存连续块，由于，也是文件连续区域。一张表有多个。
 以双向链表的形式组织，和分别对应的首尾指针
   
 
 有若干种种按照最小尺寸划分的，
 表中删除掉的行对应的数据块放到中，按照数据块的尺寸划分为若干规则的。
 
 兼容旧版本引擎的废弃字段
 
 该表是否是，是类型的，中用来存放
 
 和字段一样，都是的一部分，只是大小不同
 
}
为了便于下文阐述，结合上述对构建过程的描述与对元数据的注解，笔者先勾勒出如下的元数据结构。
单表结构
上文我们讨论了单表元数据中重要字段的含义，接下来进行深入探讨。
的组织形式
每张表由若干组成，每个为一块连续的内存区域也即连续的硬盘区域，由 和  记录首尾位置，每个的结构为
               
  {
     
      双向链表中前节点指针
      双向链表中后节点指针
     
     
     一个对应表中的一行，每个在物理上由若干地址连续的
     组成，但是这些在逻辑上的前后关系并不等价于物理上
     的前后关系， 维护了逻辑上的先后关系，在维护游
     表迭代时使用
     
     
     _
}
上述描述的组织结构如下图所示：

 的分配与回收由管理， 首先尝试从已有文件中分配一个满足条件的连续块，如果没有找到，则生成一个新的{} 的文件。
                                                          
                                                                                
                                                                                       
                       {                                                       
       = _                                                                   
                                                                                                   
         {                                                                     
               {                                                               
              =                                                                            
         }  {                                                                                 
              =                                                                      
                                                                                            
         }                                                                                         
     }                                                                                             
                                                                                                   
         {                                                                       
          =                                                                          
     }                                                                                             
                                                                                                   
      =      || 
文件的大小 {}的大小默认为。 之后每次新建会扩大一倍，以默认为为上限。
一个被分为若干，每个对应表中的一行一个集合中的文档，每一张表被类封装，并对外提供出的接口。
分配
首先从已有的上文中提到的中分配，每张表按照内存块尺寸维护了不同规格的，每个是一个单向链表，当删除时，将放入对应大小的中。
如下按照从小到大的顺序遍历，如果遍历到有空闲且符合大小的空间，则分配：
           =      {
                            
                  
                = _
              
                 
                = 
               =  {
                  = 
                  = 
                 
             }
         }
上述代码分配出一块尺寸合适的内存块，但是该内存块依然可能比申请的尺寸大一些。引擎在这里的处理方式是：将多余的部分砍掉，并归还给。
        =   
       =  {
          = 
            =    
           = 
          =        
          = 
         
         
          
     }
上述分片内存的过程如下图所示：

如若从已有的中分配失败，则会尝试申请新的并将新的加到尺寸规则最大的中。并再次尝试从中分配内存。
     = {
  
             
                
      _                          
  }
 
上述过程为引擎对内存管理的概况，可见每个在分配时不是固定大小的，申请到的内存块要将多出的部分添加到中，释放后也是链接到对应大小的中，这样做时间久了之后会产生大量的内存碎片，引擎也有针对碎片的过程以提高内存的利用率。
碎片
以命令的形式，暴露给客户端，该命令以为维度，在实现中，以为最小粒度。
整体过程分为两步，如上图，第一步将从中断开，第二步将中已使用空间到新的拷贝过去保证内存的紧凑。从而达到的目的。

 过程

将 对应的 下的 置空，这样新创建的就不会分配到已有的。
          
                       
                       
                        
                     
                 
                
         _

对于每个，每个记录了首尾，遍历所有，并将插入到新的中新的在插入时由于空间不足而自动分配参考上面的过程，重新设置从最小开始增长。

               
     _ 

              
      _ 
        =   =   {
         
         _ == 
               
         _     
         _ = 
         
     }

在_的过程中，该的逐渐被插入到新的里，空间逐步释放，当全部都清理完后，该又变成崭新的，没有使用过的了。如下图


           {
             

              
               = 
               = 
              =  
                
               =  
             _  
              }
上述即是_函数中遍历该的，并插入到其他，并逐步释放空间的过程行。
数据回写
上面我们介绍文件结构时谈到文件是通过 映射到内存中的一个上，这个映射过程是通过 实现的。我们看下该模块是如何做持久化的。
在 引擎的 中
   {

     
这里调用 类的定时任务，在线程中定期落盘
        {
            ==  {
                           
              
              
          }
 
          
                    _

          _  = 
            = 
 
          
            = 
          
          }
      }
最终会调用每个的方法
    {                                                         
       ||  ==  ||                                                        
                                                                                            
                                                                                                   
       =                                          
                                                                                                   
         =     _ =  {               
                                                                        
                            
                                                                       
                                                                          
     }                                                                                             
 }
  
不管调用 还是落盘，我们的预期都是内核会高效的查找出数据中的脏页执行写回，但是根据 以及下面的代码注释中。
在有些操作系统上比如与 的某些版本， 并不能高效的寻找脏页，因此引擎在这里对操作系统区别对待了。
                  
                       
                      
                                                                               
                       
          

相关推荐复制集原理与集群均衡 的优势摘要
如果说云计算拼的就是运维的话，那么公有云的运维拼的就是容量管理。公有云上容量管理以下容量管理特指公有云上容量管理就是要保障有充足的资源可对外售卖，即“有货可卖”。当资源供应不足，用户无法购买需要的云计算资源时，就产生了所谓的“售罄”事件。售罄问题对公有云口碑影响很大，影响用户体验的同时甚至会造成用户的流失。本文主要对容量管理相关问题进行总结和分析，同时介绍云硬盘存储系统容量管理实践方案。
问题
云硬盘  ，作为腾讯云基础组件之一，在容量管理方面之前遇到了很多问题，总结起来有以下几点。
缺少统一、多维度资源规划
通常我们的资源主要有三部分组成：线上可对外售卖资源，线下储备设备以及报备在途设备。这三部分资源分别在三个不同的系统中维护，缺乏统一的视图，导致运维人员对资源整体储备情况无法准确预估。另外一方面，目前腾讯云有众多可用区，同时有多种云硬盘产品，不同产品使用不同的机型；如果只考虑整体资源，而不考虑不同可用区不同云盘产品的售卖情况的话，很容易出现资源不均衡的情况，即部分可用区云盘产品售罄的同时其他可用区云盘产品却资源过剩。因此，我们需要统一、多维度的资源规划，打通线上、线下资源系统，从全局进行不同地区不同产品类型的资源规划和调度。
字源交付效率低
一台物理设备的生命周期会经历采购、到货、初始化、上架、维修、下架。交付过程中的大量环节需要人工介入和操作，资源交付自动化程度较低会导致单交付时间可能超过几十分钟，并且交付并发度基本为串行。如此低的交付效率一方面会导致售罄频发交付赶不上售卖，另一方面会增加运维在交付方面的人力投入以上。
系统感知滞后，监控力度过粗
通过对售罄问题的分析，我们发现大部分售罄问题往往是因为短时间的突发购买击穿库存导致。现有的容量系统无法做到实时感知和预警短时间内的突发购买行为，等到触发资源不足告警再去追查和分析，使得后端运维响应非常被动。另外，现有的资源监控策略基于静态阈值，只能做到级别的资源总体情况预警，缺乏细粒度监控例如 用户购买情况、不同大小的盘资源情况等。
碎片化问题
 除了突发购买，碎片化问题也会导致售罄。很多时候线上整体可售卖的资源还有很多，但是这些资源都分布在很多个，就会导致无法提供大规格的整块资源。造成碎片化最直接的原因是前端售卖装箱策略不合理，但容量管理系统本身也需要具备定期整理碎片、均衡资源的能力。
实践方案

图 容量管理整体解决方案
如图所示，为了有效解决售罄问题，可以从线下、后端、前端、监控和数据分析等方面入手，总结起来有以下五点。
统一规划，全局调配
前面分析问题时指出各种资源数据分布在多个系统，缺少统一、多维度的规划。因此我们需要建立全局资源看板，来对资源进行统一规划和全局调配。具体来说，我们的全局资源看板包括以下内容：归一化地展示线上可售卖、线下储备和报备在途设备，这样一来就可以很清楚的知道现在有多少货可卖有多少，最近能够到货多少。
清晰地展示各个可用区、各种类型产品的资源情况包括可售卖、线下储备和报备在途，便于进行各可用区之间的资源调度和腾挪。
其他维度的资源展示，例如不同规格区间的资源情况等。

图 全局资源看板示例
自动交付，弹性伸缩

图 设备生命周期
设备一旦到货以及需要紧急扩容的情况下，我们需要具备快速自动交付能力，降低售罄风险的同时也能优化运维人力。一方面需要打通整个设备生命周期，实现全自动化交付。另一方面需要和监控以及数据分析联动起来，当收到资源不足预警时自动触发上架操作，及时扩容。
实时感知，精细运营

图 容量监控分析体系
容量监控分析体系如图所示，主要由三部分组成：
静态阈值监控。除了监控各个地区和各种类型云盘线上容量之外，我们还增加了两种预警，即上架预警和报备预警。上架预警和上面的自动化交付系统关联，当线上容量触发上架预警值之后会回调自动化上架接口进行扩容操作。报备预警会综合线上容量和线下当资源整体消耗较快无法保障未来一个月的售卖时，会及时告知运维人员发起报备。
动态异常分析。通过对用户的购买行为进行动态异常分析和监控，可以及时感知突发购买和刷单等异常情况，以便及时采取措施，防止库存被击穿。
精细化分析。除了关注大盘整体容量情况和短期的异常外，我们还对用户进行了定制化监控分析，重点关注的用户行为和使用情况，主动发现问题来提升服务专业度和口碑。
合理装箱，自动均衡
典型的部署模型提供的最小容量单位为，用户可购买的云盘的规格为，这是一个很典型的装箱问题。我们还在不断探索和优化装箱策略和算法，我们已经采取的主要优化措施包括：容量实时上报，指定售卖装箱。各将可售卖容量实时上报，控制系统综合全局容量情况指定售卖和装箱，避免随机装箱造成的碎片问题。
定期碎片整理和均衡。后端会定期对的装箱和使用情况进行分析，将大规格的云盘打散分布；同时会综合各个的底层存储使用率，自动发起盘迁移和均衡操作。
多管齐下，分级预案
容量管理问题没办法做到一招制胜，而是需要一套“组合拳”来应对不同情况。表为容量分级预案，不同的触发条件对应了不同的预案，每种预案的时效性也不尽相同。只有多管齐下，做好充足的预案和准备，才能够从容的应对各种突发情况。

表 容量问题分级预案引言
最近几年，随着云计算相关技术的发展，各种不同类型的云层出不穷，服务越来越多不同类型的企业业务，传统企业也渐渐开始探索上云的道路。在云上，作为业务最核心的数据库，相比之前的传统方案会有哪些变化呢？在正式聊云时代的数据库特点之前，我们需要了解一下目前云时代架构发生的变化。
畅想一下，未来的服务都跑在云端，任何的服务资源都可以像水电煤一样按需选购。从  层的容器虚拟机，到  层的数据库，缓存和计算单元，再到  层的不同类型的应用，我们只需要根据自身业务特点进行资源选配，再也不用担心应用服务支撑不住高速的业务增长，因为在云上一切都是弹性伸缩的。有了可靠的基础软件架构，我们就可以把更多精力放到新业务的探索，新模式的创新，就有可能产生更多不一样的新场景，从而催生更强大能力的云端服务，这是一件多么  的事情。
当然，理想要一步一步实现，未来的基础软件栈到底会怎样呢？社区在这方面正在进行积极地探索，其中最有代表性的就是基于容器以  为代表的虚拟化技术和微服务。
在云时代，一切都应该是可伸缩的，使用 在保证资源平衡的前提下，通过  部署我们依托于容器的微服务模块，我们不用关心服务到底跑在哪里，只需要关心我们需要多少服务资源。 提供了极大的便利性，一次构建，到处运行，我们可以很好地解决开发、测试和上线的环境一致性问题。如果不能很好地保证测试和实际上线环境的一致性，则很有可能需要花费远超过开发的时间去发现和修复问题。 更是在  构建的基础上增加了更多的云特性，包括  的升级，高可用和弹性伸缩等等。 关于  相关的讨论已经很多了，因为时间关系，关于具体的细节就不再展开。我们只需要了解，有了它，可以很轻松地解决服务的安装和部署。
下面再聊聊微服务，微服务将一个服务拆分成相对独立的更小的子服务单元，不同的子服务单元之间通过统一的接口 等进行数据交互。
相比于传统的解决方案，这种架构有很多的优点

更好的开发效率和可维护性。微服务将一个单独的服务进行更细力度的拆分，每一个子服务单元专注于更小的功能模块，可以更好地根据业务建立对应的数据模型，降低复杂度，使得开发变得更轻松，维护和部署变得更加友好。
更好的可扩展性。每个不同的子服务单元相互独立，彼此之间没有任何依赖，所以可以根据业务的具体需要，灵活地部署多个子服务单元进行水平扩展。
更强的容错性。当其中一个子服务出现故障的时候，可以通过辅助的负载均衡工具，自动路由到其他的子服务，不会影响整体服务的可用性。当然，微服务也不是一个银弹，相对来说，这种方案会使整体系统的设计更加复杂，同时也加大了网络的延迟，对整个系统测试的复杂度也会更高。

 提供的隔离型和可移植性，与微服务是一种天然的契合，微服务将整个软件进行拆分和解耦，而通过  可以很自然地做到独立的部署，高可用和容错性，似乎一切都可以完美地运转起来。但是真的是这样么？我们是不是忽略了什么？
是的，我们在讨论前面的问题的时候忽略了一个很重要的东西：状态。
从整个技术发展的角度来看，微服务是一个非常有意义的探索。每个人都期望着每个微服务的子服务都是无状态的，这样我可以自由地启停和伸缩，没有任何的心智负担，但是现实的业务情况是什么样的呢？比如一个电商网站，用户正在下单购买一件商品，此时平台是通过订单子服务的  应用来提供服务的，突然，因为机器故障，订单子服务的  应用不可用了，改由订单子服务的  应用提供服务，那么它是必须要知道刚才用户的订单信息的，否则正在访问自己订单页面的用户会发现自己的订单信息突然不见了。虽然我们尽量想把子服务设计成无状态的，但是很多时候状态都是不可避免的，我们不得不通过存储层保存状态，业界最主要的还是各种数据库，包括  和 ，比如使用 、、、 等，特别是有些场景还要考虑数据一致性问题的时候，更加重了对存储层的依赖。
由此可见，云计算时代系统的架构发生了巨大的变化，这一方面为用户提供了更优秀的特性，另一方面也对云计算的组件提出了更高的要求。数据库作为云计算最基础的组件之一，也需要适应这种架构的变化。这里我们主要关注  数据库，云时代的数据库以下简称云数据库。那么云数据库主要有一些什么样的特点呢？我认为主要有以下几点。
弹性伸缩
传统的数据库方案，常见的会选用 ，，。在云时代，数据量的规模有爆发性的增长，传统的数据库很容易遇到单机的存储瓶颈，不得不选用一些集群方案，常见的比如  、   等，而这些集群方案或多或少都有一些不令人满意的地方。
比如说，  通过共享存储的硬件方案解决集群问题，这种方式基本上只能通过停机换用更大的共享内存硬件来解决扩容问题， 节点过多会带来更多的并发问题，同样也会带来更高的成本。
以   为代表的数据分片方案，很多时候不得不提前对数据量进行规划，把扩容作为很重要的一个计划来做，从  到运维到测试到开发人员，很早之前就要做相关的准备工作，真正扩容的时候，为了保证数据安全，经常会选择停服务来保证没有新的数据写入，新的分片数据同步后还要做数据的一致性校验。当然业界大公司有足够雄厚的技术实力，可以采用更复杂的方案，将扩容停机时间尽量缩短但是很难缩减到 ，但是对于大部分中小互联网公司和传统企业，依然无法避免较长时间的停服务。
在云时代，理想中所有的资源都是根据用户业务需求按需分配的，服务器资源，应用容器资源，当然也包括数据库资源。添加或者减少新的数据库资源，完全就像日常吃饭那样稀疏平常，甚至用户基本感知不到。比如作为一个电商用户，在双  促销活动之前，可以通过增加数据库节点的方式，扩大更多的资源池，用来部署相应的容器服务，当活动结束之后，再将多余的资源移除去支持其他的服务，这样可以极大地提高资源的利用率，同样可以弹性地支撑各种峰值业务。
高可用
传统的  方案，数据复制的时候默认采用异步的方式，对于一个写入的请求，主库写入成功后就会返回成功信息给客户端，但是这个时候数据可能还没有同步给从库，一旦主库这个时候挂掉了，启动从库的时候就会有丢失数据的风险。当然，也有人会选择半同步的复制方式，这种方式在正常情况下是同步的，但是在遇到数据压力比较大的时候，依然会退化为异步的方式，所以本质上来说，同样有丢失数据的风险。其他也有一些多主的同步方案，比如在应用层做数据同步，但是这种方式一是需要应用层的配合，二是在对网络超时的处理非常复杂，增加心智负担。
在云时代，因为所有的数据库资源都是分布式存储的，每个数据库节点出现问题都是很正常的事情，所以就必须有一种可以实现数据一致性的数据复制方式来保证服务的高可用，业界给出的答案就是：关于  和  的实现细节我们不在这里展开。 在做的  就是选择了  协议， 协议看起来更像是一个多副本的自适应的主从复制协议，对于每次写请求， 都会保证大多数写成功才会返回客户端，即使  的 挂掉了，在一个有限的时间范围内，会很快地选出一个新的  出来，继续提供服务。同样，对于一个  副本的  ，只要  个写入成功，就可以保证成功，而大多数情况下，最先写入成功的往往是与  网络情况最好的那个副本，所以这种  写的方式，可以很自然地选择速度最快的副本进行数据同步复制。另外， 协议本身支持  ，增加一个新的节点，可以很容易地做副本数据分布的变更，而不需要停止任何服务。
同样，在云时代，数据库的  操作也会是一个非常有趣的事情。以一个常见的   操作为例，在表规模已经很大的情况下，在传统的实现方案中，比较有参考意义的是，通过一些工具，创建类似表级别的触发器，将原表的数据同步到一个新的临时表中，当数据追平的时候，再进行一个锁表操作，将临时表命名为原表，这样一个   操作就完成了。但是在云时代，分布式的数据存储方式决定了这种方案很难实现，因为每个数据库节点很难保证  状态变更的一致性，而且当数据规模增长到几十亿，几百亿甚至更多的时候，很短的阻塞时间都有可能会导致很大的负载压力变化，所以  操作必须是保证无阻塞的在线操作。值得欣慰的是， 的  给我们提供了很好的实现参考， 即是根据  的启发进行的研发，感兴趣的同学可以看下相关的内容。
易用透明
我们可以将云数据库想象成一个提供无限大容量的数据库，传统数据库遇到单机数据存储瓶颈的问题将不复存在。已有的程序基本上不怎么需要修改已有的代码，就可以很自然地接入到云数据库中来获得无限  的能力。增减数据库节点，或者节点的故障恢复，对于应用层来说完全透明。另外，云数据库的监控、运维、部署、备份等等操作都可以在云端通过高效的自动化工具来自动完成，极大地降低了运维成本。
多租户
云数据库本身应该是可以弹性伸缩的，所以很自然的，从资源利用率的角度来考虑，多个不同用户的数据库服务底层会跑在一个共享的云数据库中。因此多租户技术会成为云数据库的标配。但是这里面就有一个不得不面对的问题，如何做到不同用户的隔离性？用户数据隔离是相对比较容易的，比如还是以电商用户这里说的是电商企业，不是顾客客户为例，每个用户都有一个唯一的 ，这样在云数据库的底层存储中，可以保证每个用户数据都带有自己  前缀，用户登陆进来的时候可以根据这个前缀规则，获取他对应的数据，同时他看不到其他用户的数据。
在一个真实的多租户环境下面，纯粹的数据隔离往往是不够的，你还需要做到资源公平性的隔离。比如有的用户写一个 ，这个  没有做优化，主要做的事情是一个全表描扫，这个表的数据量特别特别大，这样他会吃掉很多的 、、 等资源，导致其他用户很轻量级的  操作都可能会变得很慢，影响到其他用户实际的体验。那么针对这种情况怎么做隔离？与此类似的还有，网络带宽怎么做隔离？大家都是跑在一个云数据库上面的，如果一个用户存放的数据特别大，他把带宽都吃掉了，别人就显得非常慢了。
还有一种情况，如果我本身作为一个租户，内部又怎么做隔离，大家知道  可以建很多 ，不同的  给不同的团队来用，那么他们之间内部隔离又怎么做，这个问题就进一步更加复杂了。
目前来讲没有特别好的方法，在一个分布式的环境下面去做很好的隔离，有两个方向可以考虑：
第一种是最简单也是有效的方法，制定一些规则，把某些用户特别大的数据库表迁移到独享的服务器节点上面，这样就不会影响其他用户的服务，但是这里面就涉及到定制化的事情了，本身理念其实与云数据库并不相符。
第二种就是依靠统计信息，做资源隔离和调度，但是这里面对技术的要求就比较高了。因为云数据库是分布式的，所以一般的统计都要横跨很多的机器，因为网络原因，不可能做到完全准确的统计，所有统计都是有延迟的。比如说对于某个用户，现在统计到的流量是  个 ，他可能突然就有一次峰值的网络访问，可能下一次统计消耗的流量是  个 这里面只是举例说明问题，如果你给他流量限制是  个 ，中间统计的间隔是多少比较合适，如果间隔比较小，那么这个对整个系统的压力就比较大，可能影响正常的用户  访问，另外本身这个流量限制的系统也是很复杂的系统。
调度算法一直是整个分布式系统领域很困难的一个问题，如何做到隔离性和公平调度也是未来云数据库非常有挑战的一个事情。
低成本
低成本应该是云时代基础设施最明显的特点。首先，云数据库的高可用和容错能力，使得我们不再需要昂贵的硬件设备，只需要普通的  服务器就可以提供服务。然后，受益于  的虚拟化技术，使得不同类型的应用容器可以跑在同一个物理机上，这样可以极大地提高资源的利用率。其次，多租户的支持，使得不同的用户可以共用一套底层的数据库存储系统，在数据库层面再一次提高了资源的利用效率。再次，云数据库的自动化运维工具，降低了整个核心数据库的运维成本。最后，云数据库资源是按需分配的，用户完全可以根据自身的业务特点，选购合适的服务资源。
高吞吐
云数据库虽然可以做到弹性扩容，但是本身是分布式存储的，虽然可以通过  、 和   等方式加快访问  请求的数据，但是相对传统单机的数据库来说，在数据访问链路上至少也要多走一次网络，所以大部分并发量不大的小数据量请求，都会比单机延迟要高一些。也就是说，当没有足够高的并发  访问的话，其实不能完全体现云数据库的性能优势，所以这也是我们在选用云数据库的时候需要认识到的问题，云数据库更多的是追求高吞吐，而不是低延迟。当并发大到一定规模，云数据库高吞吐特性就显现出来了，即使在很高的并发下，依然可以维持相当稳定的延迟，而不会像单机数据库那样，延迟线性增长。当然，延迟的问题，在合理的架构设计方案下，可以通过缓存的方式得到极大的缓解。
数据安全
云数据库的物理服务器分布在多个机房，这就为跨数据库中心的数据安全提供了最基础的硬件支持。谈到金融业务，大家耳熟能详的可能就是两地三中心，比如北京有两个机房，上海有一个。未来一切服务都跑在云上，金融类的业务当然也不例外。相比其他业务，金融类业务对数据安全要求就要高得多。当然，每个公司内部都有核心的业务，所以如果上云的话，也会有同样的强烈需要。这样，对云数据库来说，数据的一致性、分布式事务、跨数据中心的数据安全等更高端的需求有可能会日益强烈。常见的数据备份也有可能会被其他新的模式所取代或者弱化，比如基于  的多副本方案，本身就保证了会有多份备份。
自动负载平衡
对于云数据库来说，负载平衡是一个很重要的问题，它直接决定了整个云数据库系统性能的好坏，如果一个数据库节点的数据访问过热的话，就需要考虑把数据迁移到其他的数据库节点来分担负载，不然就很容易出现性能瓶颈。整个负载平衡是一个动态的过程，调度算法需要保证资源配比的最大平衡，还有保证数据迁移的过程对系统整体的负载影响最小。这在未来也是云数据库需要解决的一个核心问题。
小结
从目前已有的  数据库实现方案来看， 应该是最贴近于云数据库理念的实现。 本身具有 、 和  的能力，天然就具备了云数据库的一些特点。但是，从  到云数据库，依然有很多需要挑战的难题，比如多租户、性能等。
上面提到的一些云数据库的特点，也是  目前在着力实现的部分， 作为国内第一个  的开源项目，在与社区的共同努力下，我们在上月底刚刚发布了  版本，欢迎各位上  了解我们。
随着整个社区技术水平的发展和云时代新的业务需求的驱动，除了  的 ，相信会有更多的团队在这方面进行探索， 期待早日看到云数据库成熟的那一天。

问：由于客户数据环境复杂多样，在迁移到云端的时候怎么怎么做规划，以便后期统一运维管理？或者说，怎么把用户   或者  逐渐迁移到  之类的分布式数据库？崔秋：因为每个业务场景都不太相同，所以在选用云端服务的时候，首先要了解自身业务和云服务具体的优缺点。 如果你的业务本身比较简单，比如你之前用的 ，现在很多云服务厂商都会提供云端的  服务。这个时候你就要根据业务特点来做判断，如果  本身容量不大，远期的业务数据不会增长过快的话，这个时候其实你可以直接使用  的服务的。但是如果你本身的数据量比较大，或者数据增长比较快的话，就可能要考虑数据的扩容问题， 在这方面做的不是太好。 你可以考虑  数据库的集群方案。比如 ，它本身是支持弹性扩容，高并发高吞吐和跨数据库中心数据安全的，另外有一点明显的好处是  兼容  协议，所以如果你的应用程序是使用 ，就基本上可以无缝地迁移到 ，这方面是非常方便的。后续我们会提供常用的数据库迁移工具，帮用户把数据从   等平滑迁移到  上面。 还是那个原则，不要为了上云而上云，一定要了解清楚自己的业务特点，云数据库会帮助你提供很多特性，如果真的很适用你的业务的话，就可以考虑。
问：但从产品的角度来看，云厂商提供的  产品是  客户数据库的思路，或者说是为了支持不同的数据库而支持。请问这种局面以后会有什么改变吗？崔秋：现在确实蛮多云数据库服务其实就是在传统的  上面包了一层自动化的监控，运维和部署工具，就卖给用户提供服务了，但是实际上本身解决的仅仅是自动化管控的问题，云服务提供的数据库特性还是单机的 ，或者   的特性。如果本身底层的数据库满足不了你的需求的话，云服务也是满足不了的。 如果你需要不停服务的弹性扩容，单机的  服务肯定是搞不定的，  也很难帮助你做到，这就对底层的数据库有了更高的要求，当然这方面是  的强项了。 现在很多云上的  产品还远远没有达到理想中的云数据库的要求，不过随着社区的发展和业务需求的推动，我个人觉得，这方面最近几年会有更多的变化。如果对于这方面感兴趣的话，可以关注下 。
问：从  分流数据到 、 增量修改、 的记录，如何同步到 ？有没有工具推荐，比如类似 ？崔秋：目前  还没有相应的工具。如果真的需要在线从  这边分流的话，可以考虑使用  的触发器，将数据的变化记录下来，然后转化为 ，同步到 ，当然这需要一定开发的工作量。

作者简介：崔秋， 联合创始人，重度开源爱好者，曾任职于搜狗、豌豆荚，长期从事广告系统基础组件相关的研究，现主要从事开源  数据库  相关的设计和研发工作。

 源码地址：技术咨询：导语
年“云未来”峰会即将在深圳盛大举行，本次峰会   技术专场将在月日下午举行。  专场给各家提供了针对  应用以及背后填坑之路作深度探讨的机会。现在让我们一起回顾下去年各位嘉宾在在现场分享了哪些云上的心得体会以及 云原生架构上的亲身实践。
本文是加州理工学院博士，魔泊云创始人鲁为民在年腾讯“云未来”峰会   专场有关《开放融合的云平台构建企业云原生应用》分享的回顾。
鲁为民：《开放融合的云平台构建企业云原生应用》
云服务商也在做相应的调整，以适应这一新变化，魔泊云创始人鲁为民认为，未来云平台不仅仅提供基础设施，而应该关注应用的交付，未来、和之间的界限会越来越模糊，未来云平台融合是趋势，这一融合将会更好的支持 的云原生应用。
融合的云平台趋势和云原生需求
鲁为民首先介绍了融合云平台技术的需求。

企业  的演进趋势

需要支持用户业务需求多元化
从基础设施转变为应用投放
支持用户交互，更有效地驱动业务的增长


云服务的支持

不再仅仅是从工作负载的整合，而且更多的是应用的交付
 提供基础设施及其自动化交付
 管理工作负载并快捷投放市场，进而直接影响业务
 是颠覆性的云服务模式，是本质上不同的应用开发，部署，运行方式
作为“最后一英里”的云技术， 极大限度地实现云服务的红利




    相互渗透和融合的需求

灵活动态提供多元计算资源： 和容器化资源；基础资源和应用资源
简化应用生命周期管理，提供高效的应用和服务开发、部署和运维




接下来，重点介绍了  是一种横向扩展型应用交付平台，便于开发、测试和部署应用程序。它可供公有云和私有云使用，为多种编程语言提供了可扩展性、敏捷性和支持。总的来说能够让应用交付标准化、规范化和简单化。

那么，融合云平台与云原生应用又有什么样的关系？鲁为民针对这个问题发表了自己的看法。简单的说，云原生应用是在云环境下规模化运行，可以在云平台上进行开发；可以部署到不同的云环境以及提供各种软件堆栈，由此来实现这种快捷、安全以及可靠，费用成本的降低，这些方面实际上就是融合云平台的目标，所以融合云平台实现的目标与云原生架构实现的目标是一致的。

云原生应用的设计
首先，从云原生应用平台的设计来看，怎么满足云原生应用的需求。
云原生应用的需求

云原生应用在云计算环境下规模化运行

在云平台上进行开发
可以部署到不同的云环境
提供支撑性软件堆栈


云原生架构实现业务的用户驱动的创新

支持和用户更容易更紧密的交互，更有效地驱动业务的增长
云原生架构催生平台技术的融合满足多元需求
云原生造就一种不断变化的软件架构，让其支撑的业务能够维持市场竞争力


云原生应用程序遵循标准化的部署和运维

构建微服务离散的应用程序服务
基于容器，每个微服务在自己的容器中运行
容器间的服务协作 



另外，云原生应用可以通过微服务架构来设计和实现。微服务的架构实际上原则是按照业务领域来定义，具有业务领域、高可观测、隐藏细节等等的优势；其次，云原生实际上是由云平台支撑的，可以快捷动态提供资源、快速应用交付，提供监测和开发运维。其中还提到了微服务架构策略。

云原生应用的设计要求
最基本的要求是云原生应用“基础设施”和“数据”之间的分离，云应用可能有状态、必须持续地保存，很大程度上能够高可用。对于基础设施，因为软件提供相关的保护，你必须容忍节点的不可靠，必须支持状态不能维持等等。我们在云平台设计当中是怎么考虑这些，或者说我们要设计云原生应用当中要考虑哪些方面？

原生应用应用的云化设计原则
我们在云平台服务架构的设计中，以下四点是比较重要的。

数据持久化

需持久化的数据存放在 、、或其它共享存储
日志保存至远程
实例发生迁移时，里面的文件不保留


实例定位

 与  解耦，依赖域名或配置管理


状态管理

平台不提供状态保存管理，不依赖 会话保持功能
状态保存至第三方服务，以支持水平扩展性、负载动态均衡和故障转移


优化 

使实例的重启、重建，变得更快捷




接下来，鲁为民从以下几个简单的方面介绍云原生平台的底层的架构，从而说明前面所提到的为什么要满足云原生应用设计的要求以及原则。
资源管理：容器化管理和动态调配
必须考虑容器和基础设施的解耦，所以在应用云化设计当中，应用的实例必须和解耦，也就是说，你不能依靠或者端口来定位这个应用，定位这个容器。而是通过域名、应用层面的一些来对它们定位。当然更不能依靠物理环境。

资源管理：资源访问和负载均衡
我们实现资源访问的负载均衡时，为什么要实现应用的无状态或者用一种可靠的方式来维持这种状态？因为在负载均衡的情况下，同一个应用不同实例分布在不同容器中运行，但这些实例都是支持同一个用户访问的会话，其状态不能保存在单个的本地容器中，如果状态没有很好的管理，就不太可能实现稳定通畅的会话。

资源管理：多集群和高可用
另外我们如果要支持高可用，比如在部署区域层面的高可用，那么我们要在设计应用时确保应用不在当地自己管理状态，因为数据不保证在当地进行持久保存。

故障恢复：实例迁移和重启
此外，在故障恢复的时候，也必须考虑数据和状态的持久化，同时整个平台提供一个好的健康检测机制，这种健康检测是主动的，一旦应用出现问题故障，不是试图修复应用实例的这个故障，而是将它重启，因此，应用重启时间的设计优化变得非常重要，这使得整个重启的过程就变得非常主动，从而有效的实现故障恢复。

融合的云平台设计实例
接下来，鲁为民给我们介绍怎样设计融合的云平台来实现前面提到的云原生的架构。首先云平台是行业或是企业的需求，所以我们需要解决一系列的问题，来保证云平台高质量、高效率、低成本的运行。

其次，云平台具有融合的需求，所以融合企业云平台需要满足两点需求，一个是具备融合企业云平台架构特点，另一个是需要融合多元开放技术。

对于应用交付，满足用户的不同需求提供多种应用部署的方式。第一种方式是敏捷交付、第二种是灵活交付。

鲁为民还介绍了与腾讯云一起打造开放的云平台，使用腾讯云服务、网络、计算和存储与对接，并整合了腾讯云服务产品，如移动、数据、通讯、视频、安全等服务接入引擎。通过云平台，实现一个生态建设。

总结
最后，鲁为民对本次的分享做了总结，他强调重点更多地从基础设施转变为应用体现上，云平台需要提供不仅仅工作负载的整合，更多的是应用的交付，云平台的融合趋势包括、和的界限越来越模糊。云平台的融合将为应用的交付提供更好的快速敏捷、规模弹性和安全可靠，平台的融合可以更好的支持云原生应用。另外，云原生应用可以通过微服务架构来设计和实现。

相关推荐以   理念构建更健壮的在线教育平台一个应用的云化之路云时代程序员的社会责任和机会云存储  是腾讯云打造的兼容协议的缓存和存储服务，提供主从版和集群版。丰富的数据结构能帮助您完成不同类型的业务场景开发。支持主从热备，提供自动容灾切换、数据备份、故障迁移、实例监控、在线扩容、数据回档等全套的数据库服务。
购买请注意： 由于不同云产品之间的内网不互通，请一定购买与你之前的云服务器在相同地区的云存储，否则会无法访问。
当你使用写分布式爬虫的时候就需要使用了，今天这篇文章就让我们走进分布式爬虫的世界。第一步你可以先在  页面购买云存储，可以继续使用之前的实名认证的优惠券；如果你是学生你可以进行学生认证，会有更多优惠。
购买完成之后访问： 页面，在此页面需要自己配置初始化密码。如下图，第一条为刚购买未初始化密码的，只需要点击初始化密码并设计密码即可，第二条为已经初始化完成的。现在我们就可以通过，以及你刚刚设置的密码进行访问了。同时请记住你的实例的内网地址，这就是你下面连接此实例时候使用的，这里我的第二条已经初始化好的实例的地址端口是：
 
因为我们需要做爬虫，需要使用操作，需要我们自己去了解其中的原理吗？不需要，中有这样的一个库：，只需要在我们之前配置好的腾讯云服务器上执行命令：  

显示  则表示安装成功了，下面我们先做一些测试。说一个坑：腾讯云用连接云存储的时候密码不是你创建该实例的时候的密码，真实的密码格式为：实例：你自己设置的密码
 
 
 
   
={           }

 __
     = ===
       
         = 
         =  
        _ = =
         _
        
        __ = _
        __
         __  __
             = __
             
             == 
                 __
                __
        
     

 ___
     = ===
    
        
             = 
            
            
            
        
            请求求发送失败重试
            
            
     

 
    
         = = = 
         = 
         = 
        
        
       
        

 ____ == ____
     = __
    
    __开启则加任务队列
    ___开启则运行爬取任务
这段代码用来下载美图网上个页面的所有的图片，我们的思路是先把个页面上的所有的图片存储到上面。就上面的代码中__函数所实现的。
接着，我们用两台云服务器同时连接执行___函数，第二台服务器的配置请参照前面的两篇配置文章。
之后你将会在你的脚本的目录下的一个文件夹里面看到下载的美图。

相关推荐 云服务器搭建环境 云服务器搭建爬虫环境腾讯云主机环境安装爬虫框架过程及常见错误导语
 是官方推荐的开发，虽说提供了更多能提供效率的功能，但相信对部分一直习惯的开发者来说，刚切换过来难免会有“水土不服”的情况。本文借着手管切换之际，结合手管的工程结构及构建框架，介绍手管开发过程中 的一些基础功能。
记得之前体验  版本的时候，从到的第一感受就是严重的“水土不服”。由于手管要切换到，故又重新使用了，过程慢慢调整姿势，发现越用越爽。本文借着手管切换之际，结合手管的工程结构及构建框架，介绍手管开发过程中 的一些基础功能。
 的一些概念
  不使用工作区，因此各个项目在单独的   窗口中打开。   将代码组织到项目中，其中包含从应用源代码到构建配置和测试代码等定义  应用的所有信息。每个项目包含一个或多个模块，您可以将项目分成独立的功能单元。 模块可独立构建、测试和调试。例如：
  

在中为一个，在 中是个模块。

  

中一个包含多个，而在中一个包含多个模块。

可以简单粗暴的理解， 中的概念等同于中的。而 中的等同于中的。
项目结构
工程结构
  工程常用的两种视图模式分别是和。如下图所示：

左图为视图模式，以文件树的方式组织工程，包含了目录下的所有文件。

图为视图模式，显示当前处于构建的项目文件，按模块组织，方便快速访问项目源文件。 



当然，除了上面提到的两个视图，开发者还可以根据需要选择其它视图，如下图显示，切换到目录视图后，显示当前项目中有错误的源代码文件，可快速定位错误代码位置。

工程结构文件说明

 界面
  主窗口由下图标注的几个逻辑区域组成。

图示   主窗口

 工具栏：提供执行各种操作的工具，包括运行应用和启动  工具。

 导航栏：帮助您在项目中导航，以及打开文件进行编辑。此区域提供  窗口所示结构的精简视图。

编辑器窗口：创建和修改代码的区域。编辑器可能因当前文件类型的不同而有所差异。例如，在查看布局文件时，编辑器显示布局编辑器。

工具窗口栏：在  窗口外部运行，并且包含可用于展开或折叠各个工具窗口的按钮。


 工具窗口：提供对特定任务的访问，例如项目管理、搜索和版本控制等。您可以展开和折叠这些窗口。
 状态栏：显示项目和  本身的状态以及任何警告或消息
：构建过程的信息输出
： 集成命令行控制台，可命令行操作。
 ：日志输出，等同中的。
：该视图会列出代码中用标记的代码所在位置。
 ：用户在中操作的事件日志。例如用户更新了插件，触发了同步等。
 输出详细的构建任务信息流。
相关功能区介绍
 基于构建系统《构建初识》，手管的开发除了使用提供的插件外，还需要使用手管拓展定制的插件，集成在中使用。
 
构建变体，位于主窗口的左下角。构建系统可从一个项目构建同一应用的不同，例如，在以前的开发包中，有、、等三种大类型的包，每种类型的包，又有、、、的版本。变体由此而来，管家提供的变体共有   个可选择。如图示：选择打连测试服务器的。

选择了对应的 后，在菜单栏区中点击 ，便可编译和安装手管的包。
 
，位于主窗口右上角。显示当前工程有哪些构建的，每个归属在不同的里边，手管自定义的构建任务在名字为的中。根据列出的，双击可单独执行该。例如插件修改了需要重新生成常量引用，只需选择双击便生成最新的修改后的插件常量在插件中访问，而不需重新编译工程，如图示。

调试和分析工具
使用内联调试功能在调试程序视图中对引用、表达式和变量值进行内联验证，提高代码走查效率。内联调试信息包括：

内联变量值

引用某选定对象的引用对象

方法返回值

 和运算符表达式

工具提示值



要启用内联调试，请在  窗口中点击  ，然后选中    复选框。
快捷键
从切换过来，很多快捷键都还保留着的习惯，此时可在中打开进行编辑。如图示。

结语
本文主要参照官方文档介绍主要功能区的使用，没有介绍更多的个性化例如样式、模板、快捷键，更多的探索可参照的官网。探索  这是【 开源项目贡献指南】系列的第六章，原文【  ——   】

学会管理成长中的项目
你们的项目正在成长，也有人参与进来，你们承诺保持这样的状态。在这个阶段，你们可能想知道如何将常规项目贡献者纳入你们的工作流程，无论是否给他们提交权限或者解决社区辩论。如果你们有疑问，我们给出了答案。
在开源项目中使用正式角色的示例有哪些？
许多项目遵循类似的贡献者角色和认可结构。
这些角色实际上意味着什么，完全取决于你。这里有一些你可能认识的角色类型：

维护者

贡献者

提交者


对于一些项目来说，””是在项目中有提交权限的人。在其他项目中，他们是作为维护者被名字被列在中的人。
维护者不一定要是为项目编码的人。他可能是为你们项目的宣传做了很多工作的人，或者是为项目编写文档以方便其他人使用的人。无论他们每天做了什么，维护者是对项目的方向有责任感以及致力于改善项目的人。
一名“”可以是任何评论过或者 的人，给项目带来价值无论是对进行分类，编码，或者组织活动的人，或者任何合并过 的人可能是贡献者最狭隘的定义。

对于来说，项目社区中的每个人都参与评论或者提交代码。这意味着他们从用户过度到了贡献者。
—  “  ”

术语”提交者”可能是用于区分提交权限，它是一个有着明确责任的角色类型，来自其它形式的贡献。
虽然你们可以以任何你们想要的方式定义项目角色，但请考虑使用更广泛的定义来鼓励更多来自其他形式的贡献。你们可以利用管理者的身份认识为项目做出特别贡献的人，不论他们的技能是什么。

你们可能认为我是的“发明者”…但事实是当她诞生一年后我才参与这份工作。…人们怀疑我成功了，因为我的编程技能…但我最多只是个普通的程序员。
—  “  ” 

我如何正式化这些领导者角色？
正式化你们的领导者角色能够帮助人们有归属感并告诉社区中的其他成员他们可以向谁寻求帮助。
对于小项目来说，指派领导者可以和将他们的名字添加到你们的或者的文本文件中一样简单。
对与比较大的项目来说，如果你们有网站，可以创建一个团队网页或者将你们项目的领导者们排列在上面。例如有一个详细的团队页面并有每个贡献者的简单信息。
如果你们的项目有个非常活跃的社区，你们可能形成一个维护者的“核心团队”，甚至拥有来自不同领域例如：安全，分类或者社区准则的人组成的小组委员会。让大家自己组织并志愿选择他们喜欢的角色，而不是分配给他们。

我们补充了核心团队和几个“子团队”。每个子团队专注于一个特定领域如：语言设计或者库。整个项目的协作和强大，每个团队的愿景要与整个项目愿景保持一致，每个子团队由一名来自核心团队的成员领导。
— “  ”

领导者团队可能想要创建一个指定的通道像或者定期会面来讨论项目像或者 。你们甚至可以组织这样的公开会议以便其他人参与。例如，的每周办公时间。
一旦你们建立了领导者角色，请记得以文档的形式记录告诉大家如何联系他们！给大家如何成为你们项目的一名维护者或者仅仅是加入一个子委员会建立一个清晰的流程，并将之写进你们的中。
有些工具像可以帮助你公开跟踪谁给项目了贡献或者没有。记录这些信息可以避免社区认为维护者是一个团体，可以私下作出决定。
最后，如果你们的项目在上，请考虑将你们的项目从个人账号转移到一个组织并添加至少一个备份管理员。组织。
我什么时候应该给一些人提交权限？
一些人认为你们应该给所有参与贡献的人提交权限。这么做能够让更多的人对项目有归属感。
一方面，特别是对于比较大，很复杂的项目，你们可能只想把提交权给那些已经表示了忠心的人。这种事没什么对错，你们开心就好！
如果你们的项目在上，你们可以利用受保护的管理谁可以在什么情况下像某个特定的进行。

无论什么时候有人向你们发送一个 ，请给他们你们项目的提交权限。虽然这听上去非常愚蠢，但是使用这样的策略能够让你们充分利用的优势。。。。一旦大家有了提交权限，他们就不用再担心他们的补丁没有合并了…造成他们浪费了大量的时间。
—  “   ”

开源项目的一些常见治理结构有哪些？
这里有三个与开源项目有关的常见治理结构。

 表示”   仁慈的独裁者的生活”。在这个模式下，只有一个人通常是项目的作者对项目的主要决议有最终得决定权。就是一个经典的示例。小项目一般默认是，因为他们只有一两个维护者。如果是公司的项目可能也会使用这中策略。

精英  注意：这个术语”「精英」”对一些社区来说带有消极的意味，同时用有一个复杂的社会以及政治历史。在精英模式下，活跃的贡献者展示”价值”的人被赋予了一个正式的决策者角色。决议通常是通过纯投票的形式抉择。这个权威的概念是由 首创；所有的项目都是精英。贡献仅由他们个人提供，而不是公司。

 自由贡献在自由贡献模式下，做最多工作的人被认为是最有影响力的，但是是以现在的当前工作为基准而不是过去的贡献。项目的主要决议都是通过寻求共识的方式得到的，而不是以纯投票的形式，并努力考虑社区中更多的观点。使用自由贡献模式非常流行的示例包括：和。


你们应该选择哪种？这取决于你们！每种模式都有有点以及需要权衡之处。虽然咋一看他们有着很大的不同，但是他们的共同点要比看上去的多。如果你们有兴趣采用其中的一种模式，可以浏览这些模板：

  

  

’   


当我的项目启动时我需要编写管理文档吗？
虽然没有合适的时间写下你们项目的管理文档，但一旦你们看到你门的社区动态表现，它就容易定义了。开源管理的最好最难的部分是它是由社区塑造的！
一些早期文档不可避免的是用于你们项目的管理。所以，开始写下你们可以写的。例如，在你们项目启动的时候你们可以清晰地说明期待什么样的行为，或者你们的贡献者如何处理工作。
如果你们是参与公司开源项目启动的成员，在项目发布之前，你们有必要进行内部讨论，了解你们的公司如何保持并决定项目的进展。你们也可以公开解释贵公司将如何或不会参与该项目的任何事情。

我们分配小团队来管理上的项目，他们实际上在工作。例如，是由一位工程师管理。
—  “       ”

如果公司的员工开始提交贡献会发生什么？
成功大开源项目会被很多人和公司使用，以及甚至有些公司的收入会与这些项目有关。例如，公司可能使用开源项目中大代码作为他们商业服务的一部分。
随着项目被广泛地使用，会需要更多具有专业知识的人，你们可能就是他们中的一个！同时，有时大家在为项目工作时会得到报酬。
重要的是平常心对待商业活动，并且将之视作其他资源发展的动力。当然，不应该区别对待有报酬的开发者和其他无薪酬的；每个贡献都应该根据其技术特点进行评估。然而，大家应该开心地参加商业轰动；同时当争论对项目有利时，大方地陈述他们的用例。
“商业”和“开源”是兼容的。“商业”仅仅是意味着有金钱的参与，软件被用于商业，这有利于项目的发展和推广。虽然非开源产权中使用了开源软件，但整个产品依然是“专利”软件。开源可以用于商业或者非商业目的。
和任何人一样，具有商业动机的开发者也是通过他们贡献的质量和数量提高影响力的。很明显，得到报酬的开发者可能会比没有报酬的做的更多，但这是被允许的；金钱只是影响一些人做少事情的很多因素中的一个。让你们的项目讨论侧重于贡献，而不是关注使人们能够做出贡献的外部因素。
我需要一个法律顾问来支持我的项目吗？
你们不需要法律顾问来支持你们的开源项目，除非涉及到金钱。
例如，如果你们想创建商业业务，你们将要建立 或者如果你们位于美国。如果你们只是做与你们的开源项目相关的合同工作，你可以作为独资经营者接受金钱，或设立一个如果你在美国。
如果你们的开源项目想要接受捐赠，你们可以设置一个捐赠按钮例如使用或者还有中国的支付宝和微信支付，除非您是符合条件的非营利机构如果您在美国，否则这笔钱不会免税。
很多项目为了省去建立非盈利机构的麻烦而去找一家非营利机构赞助他们。非营利机构代替你们接受捐赠，但你们需要给他一定比例的捐款。自由软件保护 基金会 基金会 基金会和 都是为开源项目提供赞助的组织。

我们的目的是提供可被商业持续使用的基础设施，因此创造一个每个人包括贡献者，支持者，赞助者都能受益的环境。
—  “    ”

如果你们的项目与某种特定的语言或者生态系统联系紧密，那么你们可以和与之相关的基金会合作。例如，软件基金会帮助支持用于管理包的，基金会帮助支持一个基础框架项目。 背景
在计算广告系统中，一个可以携带广告请求的用户流量到达后台时，系统需要在较短时间一般要求不超过 内返回一个或多个排序好的广告列表；在广告系统中，一般最后一步的排序 =；其中  参数控制排序倾向，如果 ，则倾向于 ，否则倾向于 ；这里的核心因子  就是通常所说的点击率   。
在推荐系统中，也有类似的需求，当用户请求到达后台的时候，我们需要返回一个排序好的文章列表或者  列表。早期的推荐系统主要以协同过滤和基于内容的推荐为主，近年来推荐系统的主流形式也变成和广告类似的两步走模式：先召回一个候选队列，然后排序；在排序这一步有很多种不同的策略，比如  的一些分类算法之类，但更多还是类似 、 之类的计算一个分数，然后排序；这个分数里往往也少不了  的  这个关键因子。
综上，在计算广告、推荐系统等不同业务系统中都对预测物品的点击率有需求，所以这方面的研究也比较多，本文试着梳理一下相关的技术脉络。
  ：回归问题  分类问题
我们可以有很多种不同的方式来定义点击问题，本文会列举两种方式；第一
种是将其看做一个分类问题；这种看法比较自然是因为我们原始的日志是曝光和点击；通过简单的归约以后，我们把点击看做正样本，曝光看做负样本的话，基于一段时间的数据样本，我们可以训练一个分类器，形式化来说，假设用户 、物品 ，上下文 ，曝光和点击类别 ，每个样本可以看成一个|的元组；其中  的取值只有  两种，这时候对每一个用户、物品、上下文组合，，我们需要一个模型来对其分类，是点击还是不点击；
从分类角度出发，我们有很多算法可以用，比如贝叶斯分类器；、最大熵等等；我们也可以使用回归算法通过阈值来处理。
另一种看法假设每个我们可以预测一个  之间的值，这时候就变成了一个回归问题，可以使用 、、神经网络等模型。
在本文的结尾部分可能会有其他的一些问题定义的方法，大家也可以看到在实际业务中，不同的问题定义方式不仅决定了可以使用的模型的范围，甚至是决定了本质效果的差异。某个领域机器学习方法的进步，往往不只是模型的进步，有时候是先有问题定义的进步，然后才有模型和算法的进步；而问题定义的进步来源于我门对业务场景的理解，所以做算法的同学也一定要多花时间和精力在业务场景的分析和挖掘上。
逻辑回归介绍
将用户是否点击一个物品看成回归问题以后，使用最广泛的模型当属逻辑回归，是一篇很不错的关于逻辑回归的综述，这里不打算展开讲逻辑回归的细节，简单做个介绍并说明实际使用中的一些注意点。
首先逻辑回归使用  函数来建模，函数如下：

该函数对应的图像如下所示

  的优点很明确，首先  函数的取值范围是 ，刚好可以解释为点击概率，而输入的范围却可以很宽广。所以  是历史最悠久、使用最广泛的点击率、转化率模型。
这里重点说下使用  需要注意的几个事项，首先是训练算法；如果使用离线训练算法，有比较多的选择，比如 、、、 等等；其中  是一种非常通用的优化算法，但个人认为理论研究模型的时候可以用  快速理解，但实际业务中往往不是最佳选择，尤其是存在其他备选项的情况下；原因可以给一个直观的解释，从  函数图像可以看出来，在  大于  或者小于 以后，函数的取值已经接近于  或者  了，此时函数的梯度方向接近平行，说明梯度很小，那单个样本对模型参数的贡献也会接近于 ，所以  的收敛速度越来越慢。这种收敛速度是敏感的，如果你跑一个模型几个小时收敛不了，和另一个算法几分钟就收敛了，那时间的量变就会带来模型性能指标的质变的。
除了训练算法之外， 模型最需要注意的是特征的呈现方式，从  的解析式可以看到  其实是广义线性模型的一种，所以  既不能很好的处理连续型特征，也无法对特征进行组合。相反对于   反而处理的很好。因此，使用  模型的时候往往伴随着大量特征工程方面的工作，包括但不限于连续特征离散化、特征组合等
 特征离散化
对于  ，如年龄、薪水、阅读数、身高等特征，如果要添加到  模型中，则最好先进行离散处理，也叫  编码；离散化处理的方式有几种，等值分桶、等频分桶等；或者直接根据对业务的理解分桶。例如对于电商类，可能  岁以下的没有什么经济能力， 的经济能力差不多，这时候可以人工划分。
等值分桶是指每个区间同样大小，比如年龄每隔  岁为一个桶，则年龄特征变成一个  个区间假设上限是  岁的编码，如  岁对应、、、、、…。
等频分桶则是需要先对样本做一个分布统计，还是以年龄为例，首先我们要基于统计得到一个年龄分布直方图，通常这类特征都会大致符合一个正太分布，这时候对于中间阶段就需要多拆分几个桶，而对于两边的部分可以少一点；如  一个区间， 一个区间， 一个区间， 一个区间。目标是使得每个区间里的人数分布基本持平。
特征离散化的好处我理解是风险均摊，不把鸡蛋放在一个篮子里。举个例子，如果年龄特征对最终的预测结果很重要，则可能在  模型中获得一个比较大的权重 ，这时候如果有一个异常数据，某个人年龄些的是  岁，就会一下子将函数值推到接近  的区域。这明显不是我们想要的，相反如果通过离散化，年龄特征的权重会分散到各个桶对应的特征里，这时候单个特征的异常就不会造成很大的影响。
 特征组合
假设模型里有年龄、性别、身高三个特征；这时候就会出现一个特征组合的问题，比如年龄性别可以作为一个新的特征，可能某类物品对于这种组合特征有偏好，如  岁以下的小男孩对变形金刚很感兴趣我实在想不到什么例子。这种需求  是没有办法自动完成的，只能人工来添加。
类似还有三阶特征、四阶特征等等，在比较长一段时间，特征工程是算法那工程师的主要工作，后来特征多到人力无法去进行有效组合的时候，又想出来了其他一些办法，比如后面要介绍的  就是  提出的一种应对特征组合的处理方式。     
 特征设计
在这里也单开一个小节来介绍特征设计的内容，这块没有特别有效的现成方法，也没有相关的书籍总结，但又很重要。如果特征设计不好，很可能模型根本出不了效果，能给大家的建议就是多读读论文。从和自己业务需求相似的论文中去看别人设计特征的方式，然后结合自己的业务看看能否借鉴。
从我自己阅读的一些  里我总结了两个所谓的“套路”。一个是获取外部关联信息，比如对于新广告，我们要预测点击率的话，因为没有历史数据，我们可以从层次结构来获取一些信息，比如这个广告的  下面其他广告的点击情况，这个广告的落地页的  种的层次关系，比如  这类 ，我们是否可以对  做一个聚合，看看这类落地页对应的广告的数据情况，作为我们新广告的特征。还有一种技巧，将广告相关的文本，或者广告购买的关键词列表，丢到搜索引擎上去跑一下，取返回的  页面聚合以后做一个分类类别体系可以提前设计，然后根据关键词列表在不同类别上分布形成的信息熵作为一个 ，放到  里。在 中使用这种方法得到了一定的提升。
另一个套路是使用数据不同方面的信息，这个策略更加隐晦。举个例子，我们可以根据用户的资讯阅读历史计算一个兴趣画像，但是这个画像我们可以分成几个画像，比如拿一周的历史算一个，一个月的历史算一个，然后通过实践  算一个历史全量的。这样场中短期分开的画像可以作为独立的特征放到模型中去。另一个例子是  论文中一个很有意思的做法，在  的数据集里， 矩阵嵌入了一个隐藏信息是 打分  的对应关系，所以我们可以从  矩阵里提取一个二元取值的  关联矩阵，如果  对  打分了，则这个矩阵对应  的位置为 ，否则为 把这个矩阵作为一个   加入到  里，会有进一步的效果提升，这就是数据信息的不同 。
特征设计还有很多其他的技巧，这里就不一一列举了，还是需要去搜寻和自己业务场景相关的论文，阅读、总结，后面我会再写一篇协同过滤的综述，那里会介绍另外一些技巧。
 评价指标
这一小节是后补的，主要介绍几种常用的评价指标以及他们各自的优缺点，主要取材于 。这里选取 、、 三个来重点说下，其他的指标有需要的请参考原文。
 是  曲线下的面积，是一个 之间的值。他的优点是用一个值概括出模型的整体 ，不依赖于阈值的选取。因此  使用很广泛，既可以用来衡量不同模型，也可以用来调参。比如

这是用来调超参的一个例子，横坐标是的树的棵树，纵坐标是对应模型收敛后在集和集上的值，从图中可以看到在棵树附近就开始出现过拟合情况了，不过两个集合的都还在持续上升。除此之外，还可以作为一个在线监测的指标，来时刻监测在线模型的表现。
 指标的不足之处有两点，一是只反映了模型的整体性能，看不出在不同点击率区间上的误差情况；二是只反映了排序能力，没有反映预测精度；简单说，如果对一个模型的点击率统一乘以 ， 不会变化，但显然模型预测的值和真实值之间的  扩大了。
 比赛用的  指标可以衡量预测的精度，与之类似的指标有 、，以  为例，计算公式如下

公式里的  和  分别对应真是的  和预测的  值；前者用  表示曝光和点击；后者用 之间的实值即可。 指标不仅可以用来调参，也可以在参数选定以后来分区间看模型的拟合程度；熟悉  比赛相关  的同学可能知道缺点在哪，就是区分度的问题，很有可能  的很小的提升，对线上的效果，比如  值会有较大的变化，因此在业务优化的时候还可以参考其他更有区分度的指标。
如果我们要对比不同的算法的模型的精度怎么办呢？除了  有没有其他选择？这里提供一个 

这张图直接取子 ，表示有点问题，我先留给大家来发现吧，正确的表达式在本文另一篇参考文献里有，先留个悬念：
这里要强调的一点是  指标不仅和模型的质量有关，还和数据集的分布情况有关；因此千万注意不可以使用  来对比不同数据集上生成的模型，但可以用来对比相同数据集上不同模型的质量差异。这一点尤为注意
接《 点击率预测综述  下篇》作者：徐凯

这篇文章主要介绍了如何用三台虚拟机搭建一套分布式系统，步骤简洁但不失准确性。环境清理一小节可以解决绝大多数部署不成功的问题，最后一节介绍了常用的操作，希望能给刚搭建环境的同学一些帮助。
环境
三台装有 的主机，每台主机有三个磁盘虚拟机磁盘要大于详细信息如下：
   
     
   
                  
                         
├─                      
└─                    
 ├─             
 ├─              
  └─           
                          
                          
                          
                        
   

                                                                                                                                      
                                                                                                                                      
 
 集群配置如下：



主机

功能






、、




、 




 、



环境清理
如果之前部署失败了，不必删除客户端，或者重新搭建虚拟机，只需要在每个节点上执行如下指令即可将环境清理至刚安装完客户端时的状态！强烈建议在旧集群上搭建之前清理干净环境，否则会发生各种异常情况。
|  | { }|  
 | 
确保此时所有进程都已经关闭！！！如果没有关闭，多执行几次。
 
  
  
  
  
  
  
  
  
  
源及的安装
需要在每个主机上执行以下指令
 
  
   
   
   
   
   
增加的源
添加以下内容：

=
=_
=

=
=
=
安装客户端：

     
关闭
 == 
 
   
  
同步各个节点时间：
  
  
      
  
开始部署
在部署节点安装，下文的部署节点统一指：
    
   

   
   
在部署节点创建部署目录并开始部署：
 
   
   
      
如果之前没有到各个节点，则需要输入一下密码，过程如下：
_     
_        
_    
_                         
_                                
_                          
_   _                
_                            
_   _                       _   
_                          
_   _                   
_                                


_     
_        
        
    
         
         

  
      


_    
_     
_       
_      
_      
_      
_      
此时，目录内容如下：
 
    
根据自己的配置向中添加_，并稍微增大之间时差允许范围默认为，现改为：
  _=   
   ___ =    
    

 = 
__ =   
_ = 
__ = 
__ = 
__ = 

_=
___ = 
开始部署：
   

若干
  
               
    
查看集群状态：
  
     
      _
             
               
         {===}
                
            
            
               
                   
                  
开始部署：
           
          
我在部署的时候出了个小问题，有一个没成功待所有部署完毕后，再重新部署问题即可解决，如果不出意外的话，集群状态应该如下：
  
     
      _
                   
         {===}
                
            
            
               
                   
                  
去除这个，只需要增加池的就好：
      _ 
   _  
       _ 
   _  
   
     
      _
                    
             
              
         {===}
                
            
            
               
                   
                 
                  
                   
                   
   
     
      _
          {===}
                
            
            
               
                   
                 
至此，集群部署完毕。
推送
请不要使用直接修改某个节点的文件的方式，而是去部署节点此处为目录下修改。因为节点到几十个的时候，不可能一个个去修改的，采用推送的方式快捷安全！修改完毕后，执行如下指令，将文件推送至各个节点：       此时，需要重启各个节点的服务，见下一节。
启动方式
 
为各个所在节点的主机名。
  
  
  

  
为该节点的的，可以通过`  `查看
  

    
              
                                       
                                         
                               
                               
                               
                                         
                               
                               
                               
                                         
                               
                               
                              

原文来自： 公众号这次给大家分享的是的一些基本知识，希望对大家有帮助。　　现在比赛进入了白热化阶段，并且马上要切换决赛榜了，很多队伍都开始想着融合模型进行提高，大家讨论最多的一个就是框架，但是在群里看到好多好多同学还没有搞明白框架到底是什么结构？要怎么运行？有什么注意点？有没有变种？等等一些列问题。在哆啦的提醒下，今天写这篇文章就按我自己的理解普及下的一些知识如果有不对的地方欢迎大家指正。　　首先，在我看来严格来说不能称为一种算法，我理解的是一种非常精美而复杂的对模型的集成策略。大家都知道，在给定了数据集的情况下，数据内部的空间结构和数据之间的关系是非常复杂的。而不同的模型，其实很重要的一点就是在不同的角度去观测我们的数据集。我举个例子，可能更加关注样本点之间的距离关系包括欧几里得距离 、明可夫斯基距离 等等，当样本距离相对较近，就把他们分为一类；而决策树，可能更加关注分裂节点时候的不纯度变化，有点像我们自己找的规则，在满足某个条件且满足某个条件的情况下，决策树把样本分为一类等等。也就是说，不同的算法模型，其实是在不同的数据空间角度和数据结构角度来观测数据，然后再依据它自己的观测，结合自己的算法原理，来建立一个模型，在新的数据集上再进行预测。这样大家就会有个疑问了，俗话说：三人行必有我师。既然是不同的算法对数据有不同的观测，那么我们能不能相互取长补短，我看看你的观测角度，你看看我的观测角度，咱俩结合一下，是不是可以得到一个更加全面更加优秀的结果呢？答案是肯定的。在我当初学基础算法的时候就有这么一个疑问，但是不知道怎么结合，直到有一天看到了的框架，瞬间感觉找到了一片新天地。下面我从以下几个方面介绍：
一、的框架结构与运行过程
　　刚开始看好像是交叉检验的既视感，其实并不是这样。假设是五折的，我们有一个数据集和一个数据集，那么一个基本的框架会进行如下几个操作：

选择基模型。我们可以有，，，，，，等等你能想到的各种基本算法模型；
把训练集分为不交叉的五份。我们标记为到；
从开始作为预测集，使用到建模，然后预测，并保留结果；然后，以作为预测集，使用，到建模，预测，并保留结果；如此进行下去，直到把到各预测一遍；
在上述建立的五个模型过程中，每个模型分别对数据集进行预测，并最终保留这五列结果，然后对这五列取平均，作为第一个基模型对数据的一个转换；
把预测的结果按照到的位置对应填补上，得到对整个数据集在第一个基模型的一个转换；
选择第二个基模型，重复以上操作，再次得到整个数据集在第二个基模型的一个转换；
以此类推。有几个基模型，就会对整个数据集生成几列新的特征表达。同样，也会对有几列新的特征表达；
一般使用作为第二层的模型进行建模预测。大家看到这里可能有些不清楚，下面我画个图直观解释一下：


   　　　　　　　　　　　　　　　　　图  的框架及预测　　上面这个框架说明的是：对训练数据进行无重复的五次划分之后，分别对其中每一部分进行一次预测，而预测的模型就是由其余四部分训练的；并且在预测了预测集之后，还需要对我们的数据集也进行一次预测，这这样就会得到个行、列的对数据集的特征转换，和个行、列的对数据集的特征转换，由此进入下一个图。
    　　　　　　　　　　　　　　　　　图  的框架及预测　　这个图说明的是对五部分的分别预测之后再组成对的新的表达，由个行一列的预测组成一个行列预测结果，从而得到对的新表达；同时，对的结果也进行处理，由于是个模型对的预测，所以要取平均，使得五列平均为一列，从而得到对的新表达。　　至此，整个的框架和运作流程介绍完毕，希望大家通过上面这一部分，能对的整个框架和运作流程有个比较清晰的认识。
二、使用的一些注意事项：
　　经过上一部分的介绍，想必大家感觉到的威力可能很大，事实上也是这样的。但是仍然有一些需要注意的地方，简单介绍几点：

的框架设计比较复杂，对于一个基模型要训练次，如果你的一个模型要训练个小时，即使在进行的时候每折减少了五分之一的数据量，你的计算时间仍然是很可观的，加起来应该还是小时，所以耗费时间很长想像一下一个框架跑一个基模型要大半天，简直太可怕。所以建议大家在使用的时候要计算时间的耗费，或者可以改为折，折等等；
我们前面讲过了，框架是集成了不同的算法，充分利用不同算法从不同的数据空间角度和数据结构角度的对数据的不同观测，来取长补短，优化结果。所以，我们的基模型除了是不同参数的相同模型之外，比如不同参数的，或者不同值的等等；更重要的是要尽可能的多加一些不同种类的基模型进去，也就是说所谓的模型要“跨越空间”的概念。这样的话我们的集成结果会更加稳健，更加精确曾经见过一个比赛集成了上百个基模型的框架获奖，当然用在我们这次比赛中好像不大合适∩_∩哈哈

三、的一些基本变种改进
　　在变种改进方面，我们可以不仅对模型进行融合，还可以对特征级进行一些变化，比如选部分特征做；或者对的结果进行再次的，我们上面介绍的是两层的，可以有层，或者更多。但是时间复杂度很高，效果并不一定明显。　　好了，不知不觉洋洋洒洒写了两千多个字自己画的两个图有点丑不要介意，希望这篇文章能对大家理解和应用有所帮助，并且实实在在的提高比赛得分　　祝大家最后一周都能取得理想的成绩！作者介绍：韩伟，年大学实习期加入初创期的网易，成为第号员工，年间从程序员开始，历任项目经理、产品总监。年后创业年，开发过视频直播社区，及多款页游产品。年后就职于腾讯游戏研发部公共技术中心架构规划组，专注于通用游戏技术底层的研发。

我们常常会听说，某个互联网应用的服务器端系统多么牛逼，比如拉、微信拉、淘宝拉。那么，一个互联网应用的服务器端系统，到底牛逼在什么地方？为什么海量的用户访问，会让一个服务器端系统变得更复杂？本文就是想从最基本的地方开始，探寻服务器端系统技术的基础概念。
承载量是分布式系统存在的原因
当一个互联网业务获得大众欢迎的时候，最显著碰到的技术问题，就是服务器非常繁忙。当每天有万个用户访问你的网站时，无论你使用什么样的服务器硬件，都不可能只用一台机器就承载的了。因此，在互联网程序员解决服务器端问题的时候，必须要考虑如何使用多台服务器，为同一种互联网应用提供服务，这就是所谓“分布式系统”的来源。
然而，大量用户访问同一个互联网业务，所造成的问题并不简单。从表面上看，要能满足很多用户来自互联网的请求，最基本的需求就是所谓性能需求：用户反应网页打开很慢，或者网游中的动作很卡等等。而这些对于“服务速度”的要求，实际上包含的部分却是以下几个：高吞吐、高并发、低延迟和负载均衡。
高吞吐，意味着你的系统，可以同时承载大量的用户使用。这里关注的整个系统能同时服务的用户数。这个吞吐量肯定是不可能用单台服务器解决的，因此需要多台服务器协作，才能达到所需要的吞吐量。而在多台服务器的协作中，如何才能有效的利用这些服务器，不致于其中某一部分服务器成为瓶颈，从而影响整个系统的处理能力，这就是一个分布式系统，在架构上需要仔细权衡的问题。
高并发是高吞吐的一个延伸需求。当我们在承载海量用户的时候，我们当然希望每个服务器都能尽其所能的工作，而不要出现无谓的消耗和等待的情况。然而，软件系统并不是简单的设计，就能对同时处理多个任务，做到“尽量多”的处理。很多时候，我们的程序会因为要选择处理哪个任务，而导致额外的消耗。这也是分布式系统解决的问题。
低延迟对于人数稀少的服务来说不算什么问题。然而，如果我们需要在大量用户访问的时候，也能很快的返回计算结果，这就要困难的多。因为除了大量用户访问可能造成请求在排队外，还有可能因为排队的长度太长，导致内存耗尽、带宽占满等空间性的问题。如果因为排队失败而采取重试的策略，则整个延迟会变的更高。所以分布式系统会采用很多请求分拣和分发的做法，尽快的让更多的服务器来出来用户的请求。但是，由于一个数量庞大的分布式系统，必然需要把用户的请求经过多次的分发，整个延迟可能会因为这些分发和转交的操作，变得更高，所以分布式系统除了分发请求外，还要尽量想办法减少分发的层次数，以便让请求能尽快的得到处理

由于互联网业务的用户来自全世界，因此在物理空间上可能来自各种不同延迟的网络和线路，在时间上也可能来自不同的时区，所以要有效的应对这种用户来源的复杂性，就需要把多个服务器部署在不同的空间来提供服务。同时，我们也需要让同时发生的请求，有效的让多个不同服务器承载。所谓的负载均衡，就是分布式系统与生俱来需要完成的功课。
由于分布式系统，几乎是解决互联网业务承载量问题，的最基本方法，所以作为一个服务器端程序员，掌握分布式系统技术就变得异常重要了。然而，分布式系统的问题，并非是学会用几个框架和使用几个库，就能轻易解决的，因为当一个程序在一个电脑上运行，变成了又无数个电脑上同时协同运行，在开发、运维上都会带来很大的差别。
分布式系统提高承载量的基本手段
分层模型路由、代理
使用多态服务器来协同完成计算任务，最简单的思路就是，让每个服务器都能完成全部的请求，然后把请求随机的发给任何一个服务器处理。最早期的互联网应用中，轮询就是这样的做法：当用户输入一个域名试图访问某个网站，这个域名会被解释成多个地址中的一个，随后这个网站的访问请求，就被发往对应的服务器了，这样多个服务器多个地址就能一起解决处理大量的用户请求。
然而，单纯的请求随机转发，并不能解决一切问题。比如我们很多互联网业务，都是需要用户登录的。在登录某一个服务器后，用户会发起多个请求，如果我们把这些请求随机的转发到不同的服务器上，那么用户登录的状态就会丢失，造成一些请求处理失败。简单的依靠一层服务转发是不够的，所以我们会增加一批服务器，这些服务器会根据用户的，或者用户的登录凭据，来再次转发给后面具体处理业务的服务器。
除了登录的需求外，我们还发现，很多数据是需要数据库来处理的，而我们的这些数据往往都只能集中到一个数据库中，否则在查询的时候就会丢失其他服务器上存放的数据结果。所以往往我们还会把数据库单独出来成为一批专用的服务器。
至此，我们就会发现，一个典型的三层结构出现了：接入、逻辑、存储。然而，这种三层结果，并不就能包医百病。例如，当我们需要让用户在线互动网游就是典型 ，那么分割在不同逻辑服务器上的在线状态数据，是无法知道对方的，这样我们就需要专门做一个类似互动服务器的专门系统，让用户登录的时候，也同时记录一份数据到它那里，表明某个用户登录在某个服务器上，而所有的互动操作，要先经过这个互动服务器，才能正确的把消息转发到目标用户的服务器上。
又例如，当我们在使用网上论坛系统的时候，我们发的文章，不可能只写入一个数据库里，因为太多人的阅读请求会拖死这个数据库。我们常常会按论坛板块来写入不同的数据库，又或者是同时写入多个数据库。这样把文章数据分别存放到不同的服务器上，才能应对大量的操作请求。然而，用户在读取文章的时候，就需要有一个专门的程序，去查找具体文章在哪一个服务器上，这时候我们就要架设一个专门的代理层，把所有的文章请求先转交给它，由它按照我们预设的存储计划，去找对应的数据库获取数据。
根据上面的例子来看，分布式系统虽然具有三层典型的结构，但是实际上往往不止有三层，而是根据业务需求，会设计成多个层次的。为了把请求转交给正确的进程处理，我们而设计很多专门用于转发请求的进程和服务器。这些进程我们常常以或者来命名，一个多层结构常常会具备各种各样的进程。这些代理进程，很多时候都是通过来连接前后两端。然而，虽然简单，但是却会有故障后不容易恢复的问题。而且的网络编程，也是有点复杂的。——所以，人们设计出更好进程间通讯机制：消息队列。

尽管通过各种或者进程能组建出强大的分布式系统，但是其管理的复杂性也是非常高的。所以人们在分层模式的基础上，想出了更多的方法，来让这种分层模式的程序变得更简单高效的方法。
并发模型多线程、异步
当我们在编写服务器端程序是，我们会明确的知道，大部分的程序，都是会处理同时到达的多个请求的。因此我们不能好像那么简单的，从一个简单的输入计算出输出来。因为我们会同时获得很多个输入，需要返回很多个输出。在这些处理的过程中，往往我们还会碰到需要“等待”或“阻塞”的情况，比如我们的程序要等待数据库处理结果，等待向另外一个进程请求结果等等……如果我们把请求一个挨着一个的处理，那么这些空闲的等待时间将白白浪费，造成用户的响应延时增加，以及整体系统的吞吐量极度下降。
所以在如何同时处理多个请求的问题上，业界有个典型的方案。一种是多线程，一种是异步。在早期的系统中，多线程或多进程是最常用的技术。这种技术的代码编写起来比较简单，因为每个线程中的代码都肯定是按先后顺序执行的。但是由于同时运行着多个线程，所以你无法保障多个线程之间的代码的先后顺序。这对于需要处理同一个数据的逻辑来说，是一个非常严重的问题，最简单的例子就是显示某个新闻的阅读量。两个操作同时运行，有可能结果只加了，而不是。所以多线程下，我们常常要加很多数据的锁，而这些锁又反过来可能导致线程的死锁。
因此异步回调模型在随后比多线程更加流行，除了多线程的死锁问题外，异步还能解决多线程下，线程反复切换导致不必要的开销的问题：每个线程都需要一个独立的栈空间，在多线程并行运行的时候，这些栈的数据可能需要来回的拷贝，这额外消耗了。同时由于每个线程都需要占用栈空间，所以在大量线程存在的时候，内存的消耗也是巨大的。而异步回调模型则能很好的解决这些问题，不过异步回调更像是“手工版”的并行处理，需要开发者自己去实现如何“并行”的问题。
异步回调基于非阻塞的操作网络和文件，这样我们就不用在调用读写函数的时候“卡”在那一句函数调用，而是立刻返回“有无数据”的结果。而的技术，则利用底层内核的机制，让我们可以快速的“查找”到有数据可以读写的连接\文件。由于每个操作都是非阻塞的，所以我们的程序可以只用一个进程，就处理大量并发的请求。因为只有一个进程，所以所有的数据处理，其顺序都是固定的，不可能出现多线程中，两个函数的语句交错执行的情况，因此也不需要各种“锁”。从这个角度看，异步非阻塞的技术，是大大简化了开发的过程。由于只有一个线程，也不需要有线程切换之类的开销，所以异步非阻塞成为很多对吞吐量、并发有较高要求的系统首选。

 _ ；创建一个的句柄，用来告诉内核这个监听的数目一共有多大

 _       _ ；

 _   _      
缓冲技术
在互联网服务中，大部分的用户交互，都是需要立刻返回结果的，所以对于延迟有一定的要求。而类似网络游戏之类服务，延迟更是要求缩短到几十毫秒以内。所以为了降低延迟，缓冲是互联网服务中最常见的技术之一。
早期的系统中，如果每个请求的处理，都去数据库读写一次，那么数据库很快就会因为连接数占满而停止响应。因为一般的数据库，支持的连接数都只有几百，而的应用的并发请求，轻松能到几千。这也是很多设计不良的网站人一多就卡死的最直接原因。为了尽量减少对数据库的连接和访问，人们设计了很多缓冲系统——把从数据库中查询的结果存放到更快的设施上，如果没有相关联的修改，就直接从这里读。
最典型的应用缓冲系统是。由于本身的线程结构，是不带状态的。早期本身甚至连操作“堆”内存的方法都没有，所以那些持久的状态，就一定要存放到另外一个进程里。而就是一个简单可靠的存放临时状态的开源软件。很多应用现在的处理逻辑，都是先从数据库读取数据，然后写入；当下次请求来的时候，先尝试从里面读取数据，这样就有可能大大减少对数据库的访问。

然而本身是一个独立的服务器进程，这个进程自身并不带特别的集群功能。也就是说这些进程，并不能直接组建成一个统一的集群。如果一个不够用，我们就要手工用代码去分配，哪些数据应该去哪个进程。——这对于真正的大型分布式网站来说，管理一个这样的缓冲系统，是一个很繁琐的工作。
因此人们开始考虑设计一些更高效的缓冲系统：从性能上来说，的每笔请求，都要经过网络传输，才能去拉取内存中的数据。这无疑是有一点浪费的，因为请求者本身的内存，也是可以存放数据的。——这就是促成了很多利用请求方内存的缓冲算法和技术，其中最简单的就是使用算法，把数据放在一个哈希表结构的堆内存中。
而的不具备集群功能，也是一个用户的痛点。于是很多人开始设计，如何让数据缓存分不到不同的机器上。最简单的思路是所谓读写分离，也就是缓存每次写，都写到多个缓冲进程上记录，而读则可以随机读任何一个进程。在业务数据有明显的读写不平衡差距上，效果是非常好的。
然而，并不是所有的业务都能简单的用读写分离来解决问题，比如一些在线互动的互联网业务，比如社区、游戏。这些业务的数据读写频率并没很大的差异，而且也要求很高的延迟。因此人们又再想办法，把本地内存和远端进程的内存缓存结合起来使用，让数据具备两级缓存。同时，一个数据不在同时的复制存在所有的缓存进程上，而是按一定规律分布在多个进程上。——这种分布规律使用的算法，最流行的就是所谓“一致性哈希”。这种算法的好处是，当某一个进程失效挂掉，不需要把整个集群中所有的缓存数据，都重新修改一次位置。你可以想象一下，如果我们的数据缓存分布，是用简单的以数据的对进程数取模，那么一旦进程数变化，每个数据存放的进程位置都可能变化，这对于服务器的故障容忍是不利的。
公司旗下有一款叫的产品，是在缓存系统上设计比较好的。这个产品是一个商业产品，支持利用本地内存缓存和远程进程缓存协作。集群进程是完全自管理的，还支持在数据缓存所在进程，进行用户定义的计算处理器功能，这就不仅仅是缓存了，还是一个分布式的计算系统。

存储技术
相信理论大家已经耳熟能详，然而在互联发展的早期，大家都还在使用的时候，如何让数据库存放更多的数据，承载更多的连接，很多团队都是绞尽脑汁。甚至于有很多业务，主要的数据存储方式是文件，数据库反而变成是辅助的设施了。然而，当兴起，大家突然发现，其实很多互联网业务，其数据格式是如此的简单，很多时候根部不需要关系型数据库那种复杂的表格。对于索引的要求往往也只是根据主索引搜索。而更复杂的全文搜索，本身数据库也做不到。所以现在相当多的高并发的互联网业务，首选来做存储设施。最早的数据库有等，现在最流行的似乎就是了。甚至有些团队，把也当成缓冲系统的一部分，实际上也是认可的性能优势。
除了更快、承载量更大以外，更重要的特点是，这种数据存储方式，只能按照一条索引来检索和写入。这样的需求约束，带来了分布上的好处，我们可以按这条主索引，来定义数据存放的进程服务器。这样一个数据库的数据，就能很方便的存放在不同的服务器上。在分布式系统的必然趋势下，数据存储层终于也找到了分布的方法。
分布式系统在可管理性上造成的问题
分布式系统并不是简单的把一堆服务器一起运行起来就能满足需求的。对比单机或少量服务器的集群，有一些特别需要解决的问题等待着我们。
硬件故障率
所谓分布式系统，肯定就不是只有一台服务器。假设一台服务器的平均故障时间是，那么当你有台服务器的时候，那就几乎总有一台是在故障的。虽然这个比方不一定很准确，但是，当你的系统所涉及的硬件越来越多，硬件的故障也会从偶然事件变成一个必然事件。一般我们在写功能代码的时候，是不会考虑到硬件故障的时候应该怎么办的。而如果在编写分布式系统的时候，就一定需要面对这个问题了。否则，很可能只有一台服务器出故障，整个数百台服务器的集群都工作不正常了。
除了服务器自己的内存、硬盘等故障，服务器之间的网络线路故障更加常见。而且这种故障还有可能是偶发的，或者是会自动恢复的。面对这种问题，如果只是简单的把“出现故障”的机器剔除出去，那还是不够的。因为网络可能过一会儿就又恢复了，而你的集群可能因为这一下的临时故障，丢失了过半的处理能力。
如何让分布式系统，在各种可能随时出现故障的情况下，尽量的自动维护和维持对外服务，成为了编写程序就要考虑的问题。由于要考虑到这种故障的情况，所以我们在设计架构的时候，也要有意识的预设一些冗余、自我维护的功能。这些都不是产品上的业务需求，完全就是技术上的功能需求。能否在这方面提出对的需求，然后正确的实现，是服务器端程序员最重要的职责之一。
资源利用率优化
在分布式系统的集群，包含了很多个服务器，当这样一个集群的硬件承载能力到达极限的时候，最自然的想法就是增加更多的硬件。然而，一个软件系统不是那么容易就可以通过“增加”硬件来提高承载性能的。因为软件在多个服务器上的工作，是需要有复杂细致的协调工作。在对一个集群扩容的时候，我们往往会要停掉整个集群的服务，然后修改各种配置，最后才能重新启动一个加入了新的服务器的集群。
由于在每个服务器的内存里，都可能会有一些用户使用的数据，所以如果冒然在运行的时候，就试图修改集群中提供服务的配置，很可能会造成内存数据的丢失和错误。因此，运行时扩容在对无状态的服务上，是比较容易的，比如增加一些服务器。但如果是在有状态的服务上，比如网络游戏，几乎是不可能进行简单的运行时扩容的。
分布式集群除了扩容，还有缩容的需求。当用户人数下降，服务器硬件资源出现空闲的时候，我们往往需要这些空闲的资源能利用起来，放到另外一些新的服务集群里去。缩容和集群中有故障需要容灾有一定类似之处，区别是缩容的时间点和目标是可预期的。
由于分布式集群中的扩容、缩容，以及希望尽量能在线操作，这导致了非常复杂的技术问题需要处理，比如集群中互相关联的配置如何正确高效的修改、如何对有状态的进程进行操作、如何在扩容缩容的过程中保证集群中节点之间通信的正常。作为服务器端程序员，会需要花费大量的经历，来对多个进程的集群状态变化，造成的一系列问题进行专门的开发。
软件服务内容更新
现在都流行用敏捷开发模式中的“迭代”，来表示一个服务不断的更新程序，满足新的需求，修正。如果我们仅仅管理一台服务器，那么更新这一台服务器上的程序，是非常简单的：只要把软件包拷贝过去，然后修改下配置就好。但是如果你要对成百上千的服务器去做同样的操作，就不可能每台服务器登录上去处理。
服务器端的程序批量安装部署工具，是每个分布式系统开发者都需要的。然而，我们的安装工作除了拷贝二进制文件和配置文件外，还会有很多其他的操作。比如打开防火墙、建立共享内存文件、修改数据库表结构、改写一些数据文件等等……甚至有一些还要在服务器上安装新的软件。

如果我们在开发服务器端程序的时候，就考虑到软件更新、版本升级的问题，那么我们对于配置文件、命令行参数、系统变量的使用，就会预先做一定的规划，这能让安装部署的工具运行更快，可靠性更高。
除了安装部署的过程，还有一个重要的问题，就是不同版本间数据的问题。我们在升级版本的时候，旧版本程序生成的一些持久化数据，一般都是旧的数据格式的；而我们升级版本中如果涉及修改了数据格式，比如数据表结果，那么这些旧格式的数据，都要转换改写成新版本的数据格式才行。这导致了我们在设计数据结构的时候，就要考虑清楚这些表格的结构，是用最简单直接的表达方式，来让将来的修改更简单；还是一早就预计到修改的范围，专门预设一些字段，或者使用其他形式存放数据。
除了持久化数据以外，如果存在客户端程序如受击，这些客户端程序的升级往往不能和服务器同步，如果升级的内容包含了通信协议的修改，这就造成了我们必须为不同的版本部署不同的服务器端系统的问题。为了避免同时维护多套服务器，我们在软件开发的时候，往往倾向于所谓“版本兼容”的协议定义方式。而怎样设计的协议才能有很好的兼容性，又是服务器端程序需要仔细考虑的问题。
数据统计和决策
一般来说，分布式系统的日志数据，都是被集中到一起，然后统一进行统计的。然而，当集群的规模到一定程度的时候，这些日志的数据量会变得非常恐怖。很多时候，统计一天的日志量，要消耗计算机运行一天以上的时间。所以，日志统计这项工作，也变成一门非常专业的活动。
经典的分布式统计模型，有的 模型。这种模型既有灵活性，也能利用大量服务器进行统计工作。但是缺点是易用性往往不够好，因为这些数据的统计和我们常见的数据表统计有非常大的差异，所以我们最后还是常常把数据丢到里面去做更细层面的统计。
由于分布式系统日志数量的庞大，以及日志复杂程度的提高。我们变得必须要掌握类似 技术，才能真正的对分布式系统进行数据统计。而且我们还需要想办法提高统计工作的工作效率。
后续将从【解决分布式系统可管理性的基本手段】和【分布式系统在开发效率上造成的问题和解决思路】 进行分析，详见《浅析海量用户的分布式系统设计》

相关推荐
下一篇  浅析海量用户的分布式系统设计
【腾讯云的种玩法】如何利用腾讯云搭建分布式应用作者：熊训德

 语言本身内置了一套相对轻量级的测试框架，通过  库和   命令支持单元测试。本篇文档主要介绍使用  语言  包进行单元测试方法，以及一些在编写单元测试过程遇到的坑。
在  中使用单元测试时，在同需测试的源文件目录下增加_是源文件名文件即可。如用 还会帮你把包设置为_是源包名，这样可以防止测试依赖的包时的相互依赖，把这个称作扩展测试包  。
下面举一个栗子就很容易理解：
需要测试的函数是一个查询函数，它的功能是通过协议向异构的某个模块查询信息。因为对方这个模块的接口是可能变更的，所以使用在这个公共函数中使用单元测试不仅可以测试当前代码逻辑，也可帮助往后再开发时的效率。
被测源代码如下：
 
可以看到被测的公共函数就只有一个入参，两个出参，还算比较简单。
利用自带框架，最简单的单测代码即可如下：
 
然后在同目录下输入命令
   _
其中，选项可用于打印每个测试函数的名字和运行时间。
正常情况下，是会出现单测成功或者失败的信息。但这个例子有点不一样，终端会出现这样的错误：

错误里提及配置项并未设置，这是因为这个例子需要依赖外部配置文件，配置文件有设置。
这里，可以使用选项。在某些依赖配置文件的情况下很有用
 命令会先生成一个测试可执行文件，如果没会是一个临时目录，然后在这个临时目录下执行测试的可执行文件，如果使用选项：

可以看到可执行文件就会指定在生成可执行测试文件的地方执行也即是指定的目录下执行。
从这个示例中可以看到，包提供了和等方法来帮助提高测试效率，如果是方法的分支被执行了，则这组测试示例会失败，则是在标准输出上输出信息。
示例到这里，单测代码也写好了，单测执行也成功了，是否意味着单测就完成。其实不是，个人认为单测的目的主要在于在最小的模块内覆盖所有可能逻辑测试，使得更复杂的模块集成后降低的风险。要覆盖被测模块中更多的代码，则需要更多的参数组测试用例。实现这个最简单的方法就是多写几个，语言提供了表格驱动的测试方式，把所有测试数据合并到了一个测试中的表格中再集中测试。
语言中所谓的表格驱动，就是把输入和预期输出做成一个表格，很容易向表格添加新的测试数据，并且后面的测试逻辑也没有冗余，这样我们可以有更多的精力地完善错误信息，比如上例中单元测试是写成类似形式：

结构即是测试表格，这样即可以测试是否和预期的输入及输出一致。但是因为本示例中被测函数中的返回值复杂，为了简化单元测试返回的不易比对，最终的单元测试是使用来查看：
  {
     = 
        测试表格
      =  {
         
         
         
    }{
        {{}}
        {}
    }

     _ =  {
         = 
        
        
    }
}
自带的测试框架还提供了测试覆盖率和基准测试两个工具帮助查看编写代码和单测的质量和效率，详见。
如果使用惯了了、的单元测试，开始使用自带的测试框架，会觉得怪怪的，心里满是疑问，为哈单测连都没有断言，表示不服，但是开源社区的提供了。像简直新手拈来：
   {  }

  {}

 _ = {}

     {
      
         
      
}
这样让单测可以看起来简洁不少，更详细功能和用法可查看其官网 
一般来说使用语言自带的测试框架可以使用单测覆盖以上的代码。如果代码中并没有自带请求，那么测试的时候就需要自己编写代码去构造请求，。还有一种很常见的场景就是需要测试的代码中依赖了外部资源，而这些外部资源不像本例单测环境里不能提供或者提供特别繁琐，比如网络资源、资源等，就需要使用其他测试框架中常用的等技术，而这些自带测试框架并不提供。
下一篇将介绍以伪对象等核心技术为主的第三方测试框架来补充，以拟补语言自带的测试框架的不足。

相关推荐 单元测试进阶篇作者介绍：简怀兵，腾讯云数据库高级工程师，负责腾讯云内核及基础设施建设；先后供职于 和等公司，作者，曾获一项发明专利；从事内核开发工作年，具有丰富的优化经验；在分布式存储等领域有较丰富经验。

数据库适用场景广泛，相较于、性价比更高，网站、日志系统、数据仓库等场景都有用武之地，但是也存在对于事务性支持不太好 版本开始默认引擎才是事务型、存在多个分支、读写效率瓶颈等问题。
所以如何用好变得至关重要，一方面需要通过优化找出系统读写瓶颈，提高数据库性能；另一方面需要合理涉及数据结构、调整参数，以提高用户操作响应；同时还有尽可能节省系统资源，以便系统可以提供更大负荷的服务。本文将为大家介绍腾讯云团队是如何对进行内核级优化的思路和经验。
早期的主要基于开源的 分支，侧重于优化运维和运营的系统。在腾讯云，因为用户数的不断增加，对  提出越来越高的要求，腾讯云团队针对用户的需求和业界发展的技术趋势，对  分支进行深度的定制优化。优化重点围绕内核性能、内核功能和外围系统三个维度展开，具体的做法如下：
一内核性能的优化
由于腾讯云上的基本都需要跨园区灾备的特性，因此  的优化主要针对主从部署在跨园区网络拓扑的前提下，重点去解决真实部署环境下的性能难题。经过分析和调研，我们将优化的思路归纳为：“消除冗余、缩短路径和避免大锁竞争”。以下是内核性能的部分案例：
主备间的复制优化

问题分析
如上图所示，在原生的复制架构中，侧通过线程不断发送事件给的线程，的线程在接受到事件后，有两个主要的动作：

写入到 中，这个过程会和 线程争抢保护 的锁。
更新复制元数据包含的位置等信息。

优化方法
经过分析，我们的优化策略是：

 线程和 线程是典型的单写单读生产者消费者模型，是可以做到无锁设计的；因此实现思路就是 线程在每次写完数据后，原子更新 的长度信息， 线程读取 的时以长度信息为边界。这样就将原本竞争激烈的 锁化解为无锁；
由于事件中的  和事务是一一对应的关系，所以 中的数据本身已经包含了所需要的复制元数据，所以我们可以不写 文件，消除了冗余的文件；
于都是以事务为更新粒度的，因为在 文件上，我们通过合并离散小为事务粒度的大等手段，使磁盘得以大幅提升。

优化效果

如上图所示，经过优化：左图的锁竞争已经被完全消除；同压测压力下，的文件开销被优化到， 线程被优化为预期的密集型线程。
主库事务线程和线程间的优化

问题分析
如上图所示，在原生中多个事务提交线程和多个线程之间会同时竞争文件资源的保护锁，多个事务提交线程对执行写入，多个线程从文件读取数据并发送给。所有的线程之间是串行执行的！
优化方法
经过分析，我们的优化策略是：

将读写分离开来，多个写入的线程还是在锁保护下串行执行，每一个写入线程写入完成后更新当前的长度信息，多个线程以文件的长度信息为读取边界，多个线程之间并行执行。以这种方式来让复制拓扑中的线程发送得更快！

效果
优化后的示意图如下：

经过测试，优化后的内核，不仅提升了事务提交线程的性能，在线程较多的情况下，对主从复制性能有较大提升。
二主备库交互流程优化

问题分析
如上图所示，在原生中主备库之间的数据发送和回应是简单的串行执行，在上一个事件回应到达之前，不允许继续发送下一个事件；这个行为在跨园区 的情况性能非常差，而且也不能很好地利用带宽优势。
优化方法
经过分析，我们的优化策略是：

将发送和回应的接收独立到不同的线程中，由于发送和接收都是基于流的传输，所以时序性是有保障的；这样发送线程可以在未收之前继续发送，接受线程收到后唤醒等待的线程执行相应的任务。

效果
根据实际用例测试，优化后的提升为左右。
三内核功能的优化
 预留运维帐号连接数配额
在腾讯云上，不时遇到用户异常或者从而占满的最大连接限制，这是 帐号无法登录以进行紧急的运维操作。针对这个现状，我们在内核单独开辟了一个可配置的连接数配额，即便在上述场景下，运维帐号仍然可以连接到进行紧急的运维操作。极大地降低了异常情况下无政府状态的风险。该帐号仅有数据库运维管理权限，无法获取用户数据，也保证了用户数据的安全性。
 主备强同步
针对一些应用对数据的一致性要求非常高，在原生半同步的基础上进行了深度优化，确保一个事务在主库上提交之前一定已经复制到至少一个备库上。确保主库宕机时数据的一致性。
四外围系统的优化
除了以上提到的内核侧的部分优化，我们也在外围平台进行了多处优化。例如使用异步 协议实现大量实例的监控、通过分布式技术来加固原有系统的服务发现和自动扩容等功能、在数据安全故障切换和快速恢复方面也进行了多处优化。

相关推荐腾讯云数据库  产品相关文档数据库设计总结数据库的高可用性分析问题来源
本文首先观察出现问题的应用程序的逻辑，如图所示；通过协议与进行连接，选项设置为非阻塞，之后循环调用发送报文直至完成发送；但在应用程序实际使用过程中，经常出现调用失败的情况，函数在循环中被调用多次之后返回，设置为，导致程序进入错误处理分支，关闭以及记录日志见图。

 图  程序流程 

 图  关键代码 
本文试图从函数以及协议两个点进行问题的分析，并复现出错误场景，最后针对导致错误的原因来给出解决方案。
分析问题
本节通过两个视角来分析问题，一是系统中函数，二是协议栈的流量控制策略，综合这两点便能分析出本文‘问题来源’中所述函数失败的原因；
函数
头文件：
     
     
函数原型：
    _     _   

 图  数据收发过程 
如图，在程序中调用函数将以_为起始地址，长度为的内存数据从用户态拷贝到内核发送缓冲区中，拷贝成功后返回字节数，函数并不负责将数据从本机发送出去，将数据从一台主机经过网络发送到另一台主机是协议栈的任务。
可以被设置为阻塞和非阻塞两种属性；默认被设置为阻塞属性，调用时，若发送缓冲区中空闲空间的长度比请求发送的数据更长，则函数直接返回；否则，则会确保所有数据被拷贝到内核之后再返回。若被设置非阻塞属性，若缓冲区空间不足，则竟可能多的拷贝数据，函数返回实际拷贝的字节数目，若空闲空间为，则返回，并将设为。
由此可见，发送缓冲区是否拥有足够的空闲空间对网络应用的性能有着较大影响，而发送缓冲区的容量是有限的，不断调用拷贝数据势必将缓冲区填满，幸运的是，协议栈会将缓冲区中的数据发送到接收端，在收到对方的报文之后，将被确认接收的数据的空间返还到空闲空间中用于存放接下来调用拷贝进来的数据。
协议中的流量控制
众所周知，协议是一个流传输协议，为实现可靠连接，引入了连接管理、流量控制以及拥塞控制等概念；本文只讨论调用的情况，此时收发两端的状态机都已经处于状态，并且为了叙述上更直观，本文也不打算讨论协议中针对网络拥塞所采取的拥塞控制策略以及其他协议的最基础知识。
如图所示，发送缓冲区实际上是一个环形缓冲区，为了简单起见，我们假设第一个字节是以序列号发送的这通常不是这样因此缓冲区分为个部分本小节中图片均来源于  。   ：已发送到接收端并收到确认的数据 。
 ：已发送但未收到接收端确认的数据 。
 ：时刻准备发送的数据 。
 ：暂时不能发送的数据 。

 图  发送缓冲区图片来源：_    发送窗口的大小受到接收端返回的报文中参数以及实际网络环境的约束，为了简单起见，本文假设发送窗口大小与上一个报文中的参数相等。
当发送端将 中的数据发往接收端之后，紧接着收到接收端返回的对 数据的确认，此时，发送窗口向右滑动见图，此时 的数据随时可以被发送。

 图  滑动窗口的变化 
由上文可见，要不断将通过调用拷贝进来的数据发送出去，必须让滑动窗口向右滑动，并且若想又快又多的发送数据，滑动窗口需要尽可能的大，并且移动速度更快；而这又受制于接收端返回的报文中的参数以及确认的序列号大小，最终它受制于接收端对数据的处理速度。
接下来，通过图来说明接收端数据处理能力对发送端的影响；由图可知，和的发送缓冲区与接收缓冲区的大小都为，三次握手之后，得到了的接收窗口大小位，并将发送窗口同样设置为；图中，调用了次共发送数据，共返回了个报文，其中每个报文都携带了参数，他表示的接收缓冲区空闲空间大小，由于并未调用来处理缓冲区的数据，因此随着不断接收数据，空闲空间越来越小，向返回的参数变小，最终导致的发送窗口收缩为 长度。此时若不调用函数处理接收缓冲区中的数据，将导致发送窗口一直为。
在完成图中过程之后，接下来若继续调用发送数据，这些数据会被拷贝到发送缓冲区中去，但不会被通过网络发送出去，因为发送窗口为，无法发送，因此最终填满了发送缓冲区的 的空闲空间之后，再次调用发送数据时，若为阻塞的，会一直阻塞到发送缓冲区中有空闲空间；若为非阻塞，则会直接返回，并将设置为。

 图  动态过程图片来源：_  
验证方案
模拟图中情况，从返回调用函数休眠，而不数据，值得注意的是：不数据只表示不将数据从内核态下的接收缓冲区拷贝到用户态从而导致接收缓冲区被填满，实际上内核仍然根据协议接收了从发来的数据。此外客户端循环调用非阻塞发送参数中指定长度的数据直到返回或者发送完成。
方案中通过工具来捕获报文，通过来查看从接收端响应给发送端的报文中参数的大小变化。

 图  启动 

 图  启动服务端监听端口 

 图  启动发送端发送数据 

 图  通过查看的包 
从图中可知，客户端循环发送数据，但是当发送了之后调用返回，并提示资源临时不可用信息；通过查看捕获的数据包见图，发现发生错误时，接收端向发送端发送的报文中参数皆为，这与‘分析问题’小节中的结论一致，由于发送窗口缩小为，导致发送缓冲区被填充满之后，再次调用导致返回，并设置为。
结论
当发送端流量远远大于接收端流量时，虽然函数在初期会返回，但是随着接收端缓冲区被填满，发送端的发送窗口会缩小为，最终发送缓冲区也被填满，导致函数返回，被设置为。
为了不让此类情况发生，应当避免在对非阻塞调用失败之后立即关闭；一般采用下列几种方法来处理数据发送：   当为非阻塞模式下时，返回且被设置为，则调用函数或函数休眠一段时间后再进行重试，直到数据发送完毕或者错误次数超过阈值而放弃发送。
 当为阻塞模式下时，为设置_超时参数，当函数未在设置的时间内完成任务，则函数返回错误，这时可以采用和中相同的重试策略。
 将加入到多路复用代理中，如、或者，并设置超时参数，关注的可写事件，超时发生时采用如前两种方法中同样的重试策略。往期回顾：
第一部分：基于  的微服务生态系统与工程实践一
第二部分： 基于  的微服务生态系统与工程实践二
本文来自于   深圳站的演讲《基于  的微服务生态系统与工程实践》，时代公众号连续三篇文章详细解读与微服务的秘密。
作者简介：


王磊
华为 中央软件院首席软件工程技术专家
国内首批   认证讲师，《 》中文译者。
并著有国内首本微服务架构相关书籍《微服务架构与实践》一书。

前言
从年开始，当我接触微服务之后，我发现在微服务的演进过程中，开发和测试、运维需要相亲相爱，紧密合作，才能取得理想的效果。
本系列文章主要包括三部分内容：

第一部分：微服务与 ；
第二部分：微服务生态系统；
第三部分：微服务架构的工程实践；

本文着重介绍第三部分：微服务架构的工程实践。
四、微服务架构的工程实践
最后是微服务架构的工程实践。这是  从到年七年时间，把他的业务从数据中心迁到  之后的架构图。对于我们的系统而言，是不是意味着当我们把架构拆分成个、个之后，也能获取到这样收益呢？
这是很多组织和团队在做微服务的时候考虑的第一个问题。如果我们把架构拆成个，个，是否能获得同样的收益？答案是否定的。 首席云架构师说过，他们做了大量的关于流程工具和实践的演进。
 开发实践
我们在过去的微服务演进过程中所遵循的优秀实践，对于开发而言，这里我只提三个实践：
首先对于每个服务而言，最基本、最简单的需要给每个服务建一个独立的代码仓库，目的是让这个服务能够被隔离，而不是打开之后发现有很多相关的代码。

第二点——自解释文档。因为在过去的很多案例里面，我发现可能会用  来写文档，可能会用别的方式来写文档，但是这个文档会涉及很多设计的内容，在很多实践中并不太关心服务本身的流程跟设计，更关心的是我要知道这个服务是干什么，这个服务出问题了可以找谁协调。
作为新的开发人员，我能够花多长时间去运行起来这个服务，意味着这个服务的代码地址在哪里，在哪里，当我部署的时候，通过什么方式去完成类生产环境和测试环境的部署。

第三——易于本地运行。当我们做了服务拆分之后发现很多团队里面的服务，都不能独立在本地运行，怎么让开发人员快速交付，这里列了三个经常用的方法。
•第一个是用本地环境配置加  的方式，可以定义成自己的 ，把我们关注的服务在本地环境里迅速搭建起来。
•第二个是使用 
•也可以用共享的环境，可以在云上部署一些依赖环境。
这是过去一个真实的案例，我们定义了的服务，做的是把服务里面的数据同步给原有的系统，这种模式在微服务演进过程中非常常见，这个过程中对于数据传输而言，最重要的是油标，我要保证我的传输不会重复，同时数据不会丢失，所以我们把油标保存在亚马逊的  上面。
但是本地开发的时候，开发效率降低，原因是你从本地访问  会比较慢。为了解决这个问题，我们把做了一个 ，可以用任何  框架定义，这样本地运行的时候，就不用关心具体的操作，我只要关心钓到了就可以，因为它本身是第三方的业务，非常稳定。
 测试实践

对于测试而言，一定要清楚测试策略的三角形。当我们去思考测试的时候，不是只有一种系统性的测试，而是由单元、集成、组件和端到端的测试。每种测试给我们带来的价值不一样，越往底层走，单元测试效率最高，但是没有办法从真正的用户角度考虑业务价值问题。
越往上走，很容易描述，比如说我希望用户能够输入用户密码，能够成功登录，但是它所带来的测试如果只是从上面做的话，成本非常高。因为我们需要或者用人工、或者自动化方式打开网页，反馈周期也比较慢，可能你在页面上做了很多测试，后来发现最后一个错误是由于开发人员在某一行代码里面的错误变量。

所以在过去的测试例子里，我更多讨论的是“集成测试”，通常是“契约测试”，什么意思？我在提供者和消费者之间提供契约，里面记录的是在交付过程中，我的请求是什么样，我的响应是什么样，是不是有一些原数据来描述请求和响应的过程。
有了这个契约之后，当我们的结构发现破坏，我的提供者满足不了当前所定义的契约，我其实不需要真正到生产环境上去破坏消费者，就能在测试环境里验证出当前的提供者已经破坏了契约，如果让他上线是非常危险的事情。

基于契约测试在业界有一个框架，叫「消费者驱动契约测试实践」，是把  和  无的模式引到架构层面，对于两个服务而言，如果我存在消费者、提供者，我的价值点一定是在消费者这里，我希望从消费者逻辑本身去驱动我的契约，有了这步之后，拿这个契约验证我的提供者，这种方式就简化了很多。
通过这种方式还有最大的优势在于，它把我们的两个在线的集成测试，比如我们过去做集成测试，最简单能想到的就是把所有的服务全部署上去，用自动化或者人工的方式发请求，让请求跟过程发生交互或者提供结果，这对服务的稳定性要求都非常高。
所以在过去是通过这种方式之后，你会发现我可以把原本的集成测试变成两个独立的线下的单元测试。左边关心的是消费者能不能驱动出这个契约，右边关心的是契约能不能被提供者所验证。

这是我们使用最多的框架叫 ，为什么我们选择这个，是因为对多语言支持比较好，同时这里有一个非常重要的点，我们可以把生成的契约全部收集起来，因为契约里描述了请求和响应的过程，可以进行重绘，很容易就实现了调用图。

 部署实践
第三个是部署，当我的持续集成把包构建出来之后，把包存储到某个地方，这时候只需要关心我的部署流水线，从哪里获取包，部署到类生产和生产环境上。
最核心的挑战点在于部署流水线，提一个小的建议，对于部署流水线而言，现在的工具很多，但是最核心的是我们要很清楚的知道，我们的包是如何管理的，包的版本化、包的命名方式，比如过去做服务的时候，每个服务的命名方式都是很清楚的。
第二，对于部署而言，我们要尽最大程度，尤其是从事运维同事，一条命令里只需要三个参数：第一我的服务名字，第二我的版本号，第三是我的开发环境，这是在部署演进过程中所要考虑的核心问题，当然对于  之后采用什么工具和方式，是在团队内部可以协商的，现在开源的工具很多很多。
 运维实践
最后是运维，运维里面包括三点，监控，告警和日志聚合。我只提几个核心的关键点，系统监控关心的是  内存和磁盘；应用监控关心的是应用本身，可能会有响应时间、健康检查。
第三部分是延伸的部分，我们是不是要考虑对应用本身建构它的业务场景，比如通过一些收集的方式，监控在运行过程中业务是否运行正常，而不仅仅是对可用性的检查。告警里面要有很清晰的通知方式，还要有告警升级的策略，对于告警升级一般会有  工程师，工程师和服务 。
第一步你要评估带来的影响性；
第二是组内发邮件，先让有经验的工程师帮你做评估；
第三才是 ，你要花最快的时间把这个服务覆盖掉；
这个流程是对于线上服务去做运维的常见流程。

日志聚合。对于服务化之后，个，个，个，这种服务你的日志怎么获取，需要一种独立的日志聚合机制，能够帮助我们收集很多服务的调用链，对日志做分析告警，常用的有，可以很方便支持日志输出和收集。这三点是我认为在运维监控里可能是被大家平时忽略的点。
五、总结

最后推荐几本书，大部分是关于持续交付和  的书籍，不管我们如何清晰定义概念的划分，但是实践过程中三者是密不可分的。


文章来源：时代社区 月  日， 发布  版 。该版本对  兼容性、 优化器、系统稳定性、性能做了大量的工作。在此感谢社区小伙伴们长久以来的参与和贡献。


 查询优化器
调整代价模型
 下推
函数签名下推


优化内部数据格式，减小中间结果大小
提升  兼容性
支持 __ 语法，控制存储引擎对缓存的使用
重构   算子，降低内存使用
支持   算子



支持基于读流量的热点调度
支持设置  权重，以及基于权重的调度



 支持更多下推函数
支持取样操作下推
支持手动触发数据 ，用于快速回收空间
提升性能和稳定性
增加  ，方便调试

  

支持可配置框架
支持  和   脚本入口

源码地址：
在社区和  技术团队的共同努力下，如今，  版已发布，在此感谢社区的小伙伴们长久以来的参与和贡献。
感谢参与项目的企业和团队：





腾讯云
韩国三星研究院

感谢以下组织个人提供出色的开源软件服务：

 












 
 

感谢社区个人贡献者 ：
； ；；；； ； ；； ；； ； ；； ； ； ； ； ； ；；  ；；；；； ； ；；； ； ；；；；； ； ；； ； ；； ；；；；；； ； ； ü ； ； ；； ；； ； ； ； ；； ；；；；；； ； ； ； ；； ； ； ； ；； ； ；；；；； ； ；；； ； ； ； ；；；；；；；；；；； ；；；；； ；；； ；；；；； ；；；；；；；；； ；；； ；；； ； ；； ；； ；；；  ； ；；；；；；；； ； ；；；； ；；；；；；；；；；； ； ； ； ；；；； ； ； ；；； ； ； ； ；；； ； ； ； ；； ；；；； ； ； ； ；；； ；；；；；

作为世界级开源的分布式关系型数据库， 灵感来自于  ，具备『分布式强一致性事务、在线弹性水平扩展、故障自恢复的高可用、跨数据中心多活』等核心特性。 于  年  月在  创建，同年  月发布  版本，而后于  年  月发布  版， 月发布  版，  年  月发布  版， 月份发布  版， 月份发布  版， 月底发布  版。内容摘要

腾讯移动分析，将内部打磨多年的分析能力对外输出，在复杂的生态下，专注于构建完善的质量体系，助力研发者用一行代码拥有完整分析系统，为运行时的崩溃检测和恢复提供有力保障。

年月日日，“年全球移动技术大会”在北京举行。会议为期两天，面向移动开发、前端、技术人员，聚焦前沿技术及实践经验，打造技术人员的学习和交流平台。
大会上腾讯大数据移动开发高级工程师李国栋作为演讲嘉宾，围绕系统实时化演进与实践进行了精彩分享。
以下为演讲简介：腾讯移动分析将内部打磨多年的分析能力对外输出，在复杂的生态下，专注于构建完善的质量体系，助力研发者用一行代码拥有完整分析系统，为运行时的崩溃检测和恢复提供有力保障。
研究数据表明，以上的用户在使用移动时遭遇过；如果发生在首次启动，的用户会选择立即卸载；而如果发生在使用过程中，的用户会给应用差评。可以说问题对移动端应用的用户留存率、口碑、市场竞争力和收入都有非常大的影响，是移动应用开发过程中不容忽视的重要因素。
腾讯移动推送推出的分析整体方案，着重要解决的是终端堆栈、机型、日志等数据的完整采集，数据的实时高效处理，堆栈数据的精准还原，以及完善的告警运营体系。演讲内容干货满满，分享了分析开发工程中的很多技术难点攻克过程。虽然已经邻近大会结束时间，现场也是座无虚席。

演讲结束后，针对腾讯移动分析的能力，我们的讲师李国栋与的记者也进行了深入的沟通交流。
 腾讯 分析系统是什么时候创立，经历了哪些里程碑？
腾讯移动分析是在年创立的，系统是其一部分功能，也是已有多年的能力，主要面向内部用户开放，为了跟随公司开放的脚步，我们也在不断向外开放和输出我们的核心专业能力，为开发者提供更有价值的功能，为的质量保驾护航。
近期，我们对系统做了全面的优化升级，不仅支持捕获全平台异常堆栈，还支持实时还原与报表查看，告警监控等一系列功能优化，整个过程来说，至少有三个里程碑：
首先第一个就是基础领域的解决方案。
这一块对开发者来说是一个强刚需的产品，即对和原生的异常处理，其中核心的一个突破在于面向的和、的和两大平台四种语言，我们做到了的全平台覆盖捕获、实时化处理、还原告警与前台报表升级。运营报表的体系这一块的话，我们搭建得很快速，在原有的功能基础上，我们有前期积累的技术优势。
第二个是专业领域的解决方案。
除了原有的一个基础解决方案之外，我们还有一个针对专业领域的统计模块，主要针对游戏引擎，目前我们游戏客户的需求，也是我们内外部产品改进的一个重要驱动力。据内部统计，游戏类的平均率远超普通的一倍之多，当前主流游戏引擎是与，上面有四种开发语言：、、与，我们以此为基础，为游戏领域提供移动端全面的解决方案，不仅是捕获统计，还有日活统计、时长统计、自定义事件、分群画像、接口监控等一系列功能，目前都正在灰度测试中，很快就会与更多用户见面。
第三个就是整个的系统产品形态包装。
目前，面向质量的整体解决方案还是以产品中的一个功能模块对外提供服务的，我们内部在构建一种新的产品形态，可以更好为在开发者与质量这块提供便捷的服务，相信在不久的将来就能与大家见面。
我们希望能够依托团队对数据处理多年的积累，提炼信息指纹，聚类归并相似问题，辅助开发者更快、更简单、更有效解决质量问题。
 目前规模多大，消耗了多少计算资源？
先说系统再说。系统其实是的一个子功能模块，它不像用户活跃数据这样每天都上报，只有崩溃的时候才会去报这个数据，所以相对来说它是比较少的。即使在这样的条件下我们的系统每天超过亿的数据流水。
在资源消耗方面，整个系统都做云化虚拟化技术处理，支持动态调整，支持分群部署，在我们对外开放的常规集群中，基本上维持在一个 这样的一个状态，内存的话总共使用了。计算资源作为它里面的一个核心资源，我们做了很多的性能的优化，这里我们的使用了个，然后内存使用了。
今年我们把的核心技术升级，然后对外开放。能力在我们内部其实已经有年多时间的沉淀，这两年多的宝贵的技术积累和案例实践，是我们能够快速推出能力，面向外部开发者提供优质的服务的基础。
 对于分析系统，实时化的难点在哪里？目前延迟能做到多少？
系统这一块，跟我们基础实时统计分析的处理，有相似点也有不一样的地方。主要的挑战点在于海量数据实时的还原处理、指纹智能提取合并、多维查询和性能个维度。
第一个是还原处理。我们都知道，原始的堆栈的可读性是非常差的，比如和的堆栈就是一串长长的地址，用户几乎无法从肉眼就能看到有用的信息，所有还原是每一条堆栈上来之后，必须要经过第一道工序，只有真正还原到真实的类、函数和行号，才能快速辅助定位问题。对于单一堆栈来说，其结构是非常复杂的。堆栈中既包含本身固有堆栈，也有有第三方组件，甚至还有很多系统级堆栈，所以，还原过程不仅只是涉及到本身符号表还原，还有系统库的符号表还原。同时，还原的过程中会涉及到大量的地址计算和字符串匹配，这些都是比较消耗计算资源的，我们也是做了很多优化，才保证整个处理过程控制在秒级。
第二个是指纹智能提取合并。原始堆栈还原后，通常包含大量无效的信息。因为由于版本、指令集、发布渠道等不一样，堆栈还原后，很可能会分成个，或者反过来，几个不同堆栈还原后，可能会落地在同一个特性堆栈中。因此，如何在堆栈中提取能够真正代表这个的堆栈指纹是非常关键也是非常有必要的，这能够帮助用户发现真正的问题。所以，我们要保证相同的堆栈归类到一个，而不是说每个堆栈就是一条记录，这样开发者看起来就很复杂了。同时，由于版本、指令集、发布渠道等不一样，堆栈还原后，很可能会分成个，或者反过来，几个不同堆栈还原后，可能会落地在同一个特性堆栈中。而我们从用户最关注点出发，以“到组件到系统”三个层次做分级，把用户最关注的本身相关内容优先做提取，再经过“干扰数据消除技术”，把不相关堆栈也过滤掉，保证提取出来的堆栈就是能够代表关键内容且用户也是最关注的部分。还有在堆栈的调用过程中，我们要去分析它调用链的调用情况，在这里面也有很大的一个技术挑战。
第三个是多维查询。如果一旦出现问题，其实开发者是很关心的，它还需要第一时间去找到这个问题，但是它怎么找，它有很多方法，它可以通过机型、版本，还有时间，通过用户甚至说内的用户账号，还有就是堆栈的一个模糊的搜索匹配等，这些都是用户常用且很需要的搜索功能。第四个是性能。我们回头整体看看前面提到的过程，实时是由始至终贯穿所有环节的，我们为什么要强调实时的概念？这是因为，整个大数据行业的大趋势早已完成“离线到准实时到实时”的演变，行业多数还停留在小时级别，而在实时方面的建设始终都是以业界最严格的标准来做的，所有的实时指标都控制在秒级范围内。
一方面得益于我们公司和部门在大数据这块做的非常多基础平台工作，比如统一接入网关、统一数据中间件之外，系统本身也做了大量的优化处理。为了突破系统性能瓶颈，我们不断挑战专业技术最高点，从 指令、多对称网卡驱动、网络协议栈改造、操作系统内核与配置优化、同步异步协程模型，基本上由最底层到上层，穿透了硬件到驱动到协议到架构再到逻辑层的优化技术，把性能挖掘到极限。再通过整个系统的云化处理技术，做到资源合理利用，分集群部署。
 的并发请求数多少平均和峰值，如何做到高可用？
对整个系统来说的话，我们也是全部做了一个云化处理。
我们现在后台分了好几个集群，比如手机一个、游戏一个、微信一个，以及对外的公共服务集群也有一个。再比如说高峰期的时候，我们支持一个动态资源的协调，从维度上来看的话，我们对外的公共资源的日处理量已经达到了亿的规模；并发请求我们是在一秒千万级别的；因为我们一条上报它可能包含着多条的日志的，从为用户省流量的角度考虑，处理日志时，我们做了一个合并上报，所以日处理量可以达到一秒几千万的计算能力。
从这个方面来说，我们的高可用，可以通过两个维度来衡量。
第一个维度就是我们服务的质量。
从系统服务的质量来说的话，我们系统已经做了一个云化，并且实现了；以及我们所有的服务，基于一个叫“”的云平台，在那里也可以支持我们的任务调度以及资源的协调，实现资源共享，包括伸缩性的共享性。同时对于一个单机的服务器来说，从硬件到驱动到协议栈到一个操作系统，我们都是经过深度定制优化，从头到尾的话，我们都要对它做多版本的优化。我们保证单机的性能是具备有高可吞吐量的计算能力。
第二个维度就是我们数据的质量。
从数据维度来看的话，我们数据的处理过程也是基于腾讯的大数据处理平台，这个平台在腾讯内部已经大规模的使用于我们的金融支付、社交媒体及广告服务中，非常稳定可用。拿个例子来说， 系统是一个消息中间件，这个消息中间件不仅起到消息的一个数据流转的过程，必要时，它有起到一个缓冲的削峰的作用。比如说在某个时间点，一下子大量的数据过来了，后端模块不能及时响应，在这个时候 会把这个日志给缓存起来，做数据回放，这样的操作保证我们的数据不会丢失。
然后我们可以再看一下整体。我们除了数据和系统维度，还有腾讯这样子的统一网关保证全网运营商最优接入，还有门神系统保障诸如大规模网络攻击等安全问题等系统平台，来保障我们的系统是全面可稳定运营的，所以，不管从哪个维度来看，不管是从系统服务和数据安全各方面，都可以保证的服务的稳定性，实现高并发可用。
 能否收集和分析所有层？
这肯定是可以的，这是一个的基本能力。
可以从两个维度来看：第一个是数据采集。我们现在主流的安卓、平台已经占到百分之九十八、九十九以上了，基本上就是讨论我们在这两个系统上的覆盖。安卓有两个层面：一个是，一个是的层面，而有和两种语言，这些我们已经全部覆盖了。
这里面我们想要强调一点，目前在这一块的捕获当中，其实对于安卓的捕获，业界很少有产品服务能力，因为这里面它涉及到很多的技术挑战，这里面它不仅要掌握的信号量机制，还要处理、、和本身固有的平台指令差异问题，还要兼容位版本的平台。在发生后，系统传给我们的数据非常有限，只有信号量、地址这些非常非常基础的信息，这就是说，我们必须要通过一个简单的地址，完成一个函数调用的调用链回溯、寄存器数据、子进程数据、临近地址空间，这里面也涉及到大量的技术挑战。
第二块就是在数据处理这一块。数据处理聚集在终端上报的异常的实时化处理，关键在于堆栈还原与分析，我们建设了一套完整的数据处理方案，可以让开发者通过简单上传符号表就能查看所有异常堆栈、调用链、埋点日志，精准到行号。
再加上对专业领域、专业组件的深度定制，基本上覆盖移动端绝大多数场景，开发者只要通过简单的一两行代码，便可得到一个完整的解决方案。
最后想要说的是，不管是对于系统还是整个腾讯移动分析系统来说，虽然存在前面提到的多平台覆盖、实时化计算、实时还原合并等各种挑战，但我们内部一直强调的是不管多有难度的技术，都要做到“深入浅出”，对于来讲，最直接的莫过于“一行代码，一个系统”。只要终端简单集成一行代码，不仅即刻拥有整个腾讯大数据平台资源万亿级的计算处理能力，还可通过丰富的报表管理台，实时查看指标、自定义事件、页面时长、可视化埋点指标等一系列的功能，真正让用户用的灵活方便。

文章来源：【腾讯大数据】微信号：作者：熊节

前文介绍了云计算大背景对研发环境的影响。我们已经指出，现代组织应该把研发技术栈以的形式提供给开发人员，其中的要点是：

将标准的研发环境封装为虚拟化、云化的技术栈，由技术专家管理维护；

核心业务价值与技术支撑解耦，工程师专注于业务系统的开发；

自动化研发流程，降低研发管理成本。


如何实现这样一个研发技术栈管理的平台？我们的观点是，这样一个平台应该集中管理组织中的技术栈，允许基于一个技术栈创建开发测试  和生产  两个  服务，从而支撑开发、测试、生产三种运行时环境。
一个平台
在一个典型的敏捷软件开发场景例如更具体的“用  开发微服务”的场景中，开发者需要频繁地用到下列工具：

编程框架，提供基础的结构与功能来支撑业务逻辑代码，例如   和  。

版本控制工具，例如  。

依赖软件，例如  数据库。

自动测试工具，包括单元测试工具和功能测试工具、。

自动构建工具， 或  。

持续集成工具， 或  。


所有这些工具以及它们适当的组合与配置，我们把它称为一个技术栈。我们上面的例子就是“  微服务开发技术栈”，类似的，一个组织中还可以有“   应用开发技术栈”、“  前端开发技术栈”、“  移动应用开发技术栈”等等若干个技术栈。对于一般的  组织而言，有限的几种技术栈就可以覆盖大部分软件项目的形态。体量大如有数万研发员工的某  巨头，提出的主要技术栈也只有十余种。
在传统的软件开发团队中，技术栈的组合与配置是由团队的技术领导者负责的。在云计算的大背景下，将础设施作为源代码的思想再往前推一步，我们就会很自然地得出技术栈作为源代码的想法：使用  和  等技术，将技术栈的结构以源代码的形式描述。在“基础设施作为源代码”的阶段我们已经知道，以源代码形式管理环境会带来很多好处，例如更高的自动化程度、允许版本控制等。把技术栈作为源代码以后，会带来几个重要的收益：

技术栈可以很容易地复用，因此可以把搭建技术栈的工作收拢到较少数技术领导者手中，研发团队则只需在技术栈基础上开发业务功能，降低了研发团队的技能门槛。

最佳实践可以被内嵌到技术栈中，并通过持续集成的形式对研发团队形成约束，从而使研发改进举措更容易推行。

缩短研发实践的实验和创新周期，可以对多个研发团队开展受控对比实验，团队中自发产生的优秀实践可以被快速抽取并固化到技术栈中。


技术栈管理平台作为组织级的研发管理载体，承载的是组织对研发团队的引领和治理形式。在这个平台上，技术领导者会创建并维护技术栈，项目团队则可以根据自己的需要选择适合的技术栈，跳过大部分迭代的技术准备工作，直接进入功能开发，并在整个产品生命周期中享受云化开发环境带来的收益。

两个 
基于已经定义好的技术栈，当项目团队开始研发工作时，技术栈管理平台可以为他们创建两个  服务：一个是研发过程中使用的开发测试  ，另一个是真实上线用的生产  。两个  的协作关系如下：

开发人员从开发测试  中获得一个开发环境，在这个环境中编写代码；

新编写的代码被提交到代码库中，后台的服务自动运行“提交门”测试，测试通过后，把代码构建成可运行应用；

后台服务针对可运行应用自动运行“验证门”测试，测试通过后，这个版本的可运行应用即被标记为可发布应用，并被存入构建产物仓库；

测试人员针对通过了“验证门”测试的可发布应用进行必要的手工验证；

生产环境与开发测试环境基于同一个技术栈运行时环境上有具体的差别，开发测试  中构建出的可运行应用可以直接部署到生产环境；

随不同组织的发布流程不同，构建产物仓库中的可发布应用可能直接自动或手动发布到生产环境，也可能被同步到生产  的产品仓库，以后再手动发布到生产环境。



可以注意到，这个流程、尤其是在开发测试中发生的流程，与   在《一键发布》文中介绍的持续集成流水线非常相似。我们相信：持续集成对于现代软件开发是如此重要，以至于它不应该以独立的工具形式存在因为这样人们就有可能不用或者误用。持续集成应该被内建在软件开发的工具和过程中，使它不被开发者注意、同时又不能被绕开——正如  内建了面向接口编程、  内建了编译和代码格式检查。
三个运行时环境
前面介绍的流水线已经暗示，在整个软件交付周期中，存在三个不同的运行时环境。这三个运行时环境都有同样的基础，例如操作系统、依赖软件等。同时它们也有一些重要的差异：

构建运行时：包含开发工具、构建工具和可能是部分测试工具，这是开发人员编写代码的主要环境——需要注意，“编写代码”在敏捷软件开发的上下文中意味着“编写代码并频繁进行提交门测试”，这是为什么这个运行时环境中必须包含至少部分测试工具。

验证运行时：包含全部测试工具及其他质量保障工具，这是对软件质量进行全面验证的主要环境。

应用运行时：包含运维工具，这是软件真正运行的环境。这个运行时可能被应用于生产环境，也可能仅用在组织内部例如  测试环境、培训环境、 环境等。这个运行时中的依赖软件尤其是数据库也有可能被替换为环境之外独立运行的软件。



尽管为了支持不同环节的工作要求而有这些差异的存在，底线是：构建运行时构建出来的可运行应用，可以在验证运行时中接受完整的验证，也可以被部署到应用运行时正常运行。这与持续交付中“制成件流过整个流水线”而非在各个构建步骤中分别生成制成件的理念是一致的。
制成件的形式
在前文中我们已经提到：软件包是一种对云环境不友好的交付形式，理想的研发交付物应该是容器镜像很可能是一组彼此连接的容器镜像，可以在云上直接运行。 等容器技术使我们可以把所有软件不论背后使用什么编程语言、实现什么功能都抽象为“  地址端口”的服务；再加上例如   或  之类集群工具的支持，更可以把服务进一步简化为一个端口。于是，技术栈管理的基础设施可以得到更大程度的复用：不同的技术栈不管编程平台是 、 还是  构建出的应用都是一个或一组 镜像，从而将“产物的形态”与“生产流程的结构”解耦。
小结
针对前文提出的云计算大背景下对软件研发提出的挑战，本文提议了一种解决方案：技术栈管理平台。通过实施技术栈管理平台，为研发团队提供开发测试  和生产  两个  服务、构建验证应用三个运行时环境，研发组织能够将技术栈的搭建和管理与业务系统的研发解耦，从而降低研发团队技能门槛、快速有效地推广研发最佳实践、使研发过程中的技术与流程实验和创新成为可能。本文作者： 程柳锋


前言

随着开发团队不断发展壮大，在人员增加的同时也带来了协作成本的增加；业务项目越来越多，类型也各不相同。常见的类型有基础组件、业务组件、基于的业务项目、基于的业务项目等等。如果想要对每个项目进行一些规范上的约束比如提交规范、规范简直难于登天。所有的这些，只是因为还欠缺一个好用的工程化工具，在项目创建的初期自动的将这些目录结构和文件生成、并且集成工程常见的规范来进行约束。

本文分为两部分，首先会谈谈目前团队的痛点以及基于 的设计思路；然后会详细介绍如何实现定制的，过程中遇到的问题和解决办法。
痛点一：工程创建不智能

代码目录文件手工拷贝
不同场景的工程对目录结构的要求不尽相同

痛点二：规范约束难以统一集成

难以在新的工程项目中集成新的规范，需要手动加
缺少增量机制对旧项目集成

基于 的设计思路
我们需要给每个工程类型的项目创建一个。按照目前前端技术栈的发展情况来看，一个团队一般会有个。把这些看成一个个的插件，通过工具上层的命令来暴露给开发者使用。
在之下，需要开发一系列服务和集成规范。包括和仓库打通，也就是通过脚手架初始化目录时，先对开发者鉴权。之后根据开发者输入的项目名称在远程仓库里面创建仓库并且授予开发者权限。后期功能完善之后，可以做一些锦上添花的工作，比如进行数据统计，分析各个业务仓库使用的版本信息，是否集成了最新的等等。
整体系统架构如下：

下面我准备开发一个适用于直播活动类搭建的脚手架了，名字是
自定义的目录结构
 ├───
└───
    ├───
    |   ├───
    |   |   ├─── 
    |   |   |─── _
    |   |   |─── _
    |   |   |─── _
    |   |   |─── _
    |   |   |─── _
    |   |   |─── _
    |   |   |─── 
    |   |   |─── 
    |   |  └─── 
    │   └───
    └───
扩展
在的外层文件里，通过继承来扩展我们自己的，然后模块暴露给外部。
   = 

 =    {

}
的运行周期
一个   被创建后构造函数必然是最先被调用的，会依次调用它原型上的方法，且每一个方法中的  都被绑定为  实例本身，调用的顺序如下：

  初始化一些状态之类的，通常是和用户输入的  或者  打交道，这个后面说。
  和用户交互的时候命令行问答之类的调用。
  保存配置文件如  等。
  其他方法都会在这里按顺序统一调用。
  在这里写一些模板文件。
  处理文件冲突，比如当前目录下已经有了同名文件。
  安装依赖
  结束部分

与用户交互
提供了来让和用户进行交互，直接通过函数，它的内部实现是使用了。
 
    提示用户输入配置项
     {}
   
   {

     {
       
       
       请输入活动的名称 
       
    } = {
      活动名称 
       = 
    }

  }
模板拷贝策略
对于工程目录部分直接通过深度优先算法拷贝写入。对于工程的规范类、配置的文件需要单独写入，这一类可能需要接受用户的输入，同时需要集中进行维护，因此需要和的拷贝方式进行区分。
深度优先拷贝代码如下：
  = 
  = 

     {
   =  || 
   =  || 
   =  || 

    =  
     
   
    
      
        {
            
      }
  
    

   
}

  {
    == 
}

 = {
  
}
 在外层通过提供的 方法来进行文件拷贝
  
      源代码模板
     
      =  = {
        =  
        = 
      _  = {
        
            
            
        
      }
    }
开发完之后，就可以通过 来进行使用了。
和其它工具如集成
前面提到的 的方式使用可能存在一些问题，因为这种方式要求代码必须上传到上。对于公司内部的工具，不走正常的开源流程显然是不被允许的。那么，有没有什么方法，不添加到的列表里就能够使用呢？
幸运的是，提供了来帮助我们在其它工具中集成编写好的，其实也只是暴露到上层的一个命令而已。
   = 
  = 


  方法会在本地查找已经安装过的
 
 = {
     { }  = {
        
    }
}
一些细节

为了方便本地调试看效果，在根目录下运行  
使用提供的 来打印信息，而不要使用
如果是内部工具，运行的时候命令为： 

最后
安装示例限内部
       
  
参考资料

  
    
    


原文链接：全球化在整个互联网领域仍是大势所趋，而在红海时代来临的游戏行业，“游戏全球化”已成为近年来的热点。
游戏全球化运营，对节点分布、网络稳定、网络加速、安全防护等云端基础能力提出了很高要求。腾讯云作为国内游戏行业领先的公有云，腾讯云的全球化布局一直走在快车道，更好地助力游戏厂商实现全球化运营。
本期腾讯云沙龙北京站，与来宾聚焦探讨腾讯云在全球化方面的技术布局，并邀请到了游戏全球化先行者的代表分享实践与洞察。 
演讲主题：
海外网络拓展及质量把控
嘉宾简介：

文景   腾讯网络平台部资深网络工程师
腾讯技术工程事业群网络平台部资深工程师，腾讯任职年以上，从事海外网络资源规划，互联及质量管控。
演讲概要：
全球拓展面临的各国国情差异、运营商割据等挑战，如何拓展网络满足业务拓展和突发需求？如何更有效的拓展海外运营商互联？如何管控海外用户质量？这次腾讯将介绍通过架构布局、部署模板化、运维工具化等方法，实现运营商资源互联，全球网络拓展、动态网络质量管控等方面的心得和经验。
视频回放：

下载： 
关于：
系列沙龙由腾讯云主办，旨在为游戏开发者提供一个自由的交流分享平台。沙龙将围绕游戏行业趋势、研发技术、运维和推广等热点进行探讨。每期沙龙将邀请国内外游戏领域专家，分享游戏开发及运营过程中的思考和实践。
访问沙龙官网
 ，了解最新沙龙资讯和更多往期回顾。不知什么时候， 的  从“     ”变成了“  ”。
从一个给系统管理员使用的工具变成了给所有人使用的工具。
但是，现实中，发现了解  的人，还是太少了。同时，自己断断续续学习  也有一段时间，希望拿出来和大家交流。所以就决定不定期写写一个关于  的系列。如果你觉得我写得还可以，到文末扫码请我喝杯茶。
此文为“ 简单易懂的自动化运维工具”系列文章的开篇 ——  解决了什么问题
 解决了什么问题
首先，它是一个运维工具。当然要解决运维过程中遇到的问题了。运维过程遇到了什么问题？
想像一下，你要在一台新的机器上安装 ，你会怎么样呢，条件反射的：
 
  
  
省略
好， 分钟后你愉快地完成了老板给你的任务。但是现在你需要给  台机器安装  呢？手工的重复  次？

而  能让我们只定义一次，理论上可以在无限台机器上执行。换句话：减少运维工作中的重复工作。
同时，如果是人工执行  次，那么失误是难免的！自动化运维工具会严格根据我们所给指令来执行，而不会因为失恋而手抖执行了：   。
不少人反对自动化，认为那样太危险，因为一不小心就在上百台机器删错文件。显然，他们没有注意到：自动化实现的是准确地执行指令，解决人类执行任务时存在的指令理解不正确、执行不严格的问题。而机器不会。没有达到预期效果，往往是我们人类下达的指令不正确。
所以， 还解决了人执行指令不准确的问题。
如果使用  来实现上述的运维需求，怎么做呢？你需要做三件事情：

定义目标机器的列表：一种被称为  的类  文件
定义这些机器的配置：使用  格式的文件来描述你机器的配置
执行    

以下是  文件：




而这些  的配置：

  
  
       
      _
           
           
         
      
           
           
省略
如果你想再添加  台机器，你需要做的，也只是在  文件里添加  个 ，再执行一遍  命令。
当然，写  写得不错的人，也能实现上面的功能。
但是，使用  有什么优势？模块化和标准化！ 手工写 ，甚至手工写 ，要做到模块化和标准化，太困难了。
 将大部分运维工作都抽象并标准化成一个个模块。所有的模块都以这样形式使用：
  描述说明
  模块名
  属性名 属性值
比如使用  的  模块创建文件夹，而且  模块会自行判断该文件夹是否存在：
    
  
     
     
     
     
     ==
显然，不同的人使用  或  在方法名上可能都不一样，是驼峰，还是使用下划线？是使用 ？使用 ？还是 _？
小结
我们小结一下  到底解决了什么问题？

自动化：避免运维工作中重复的工作，以及人的不确定性问题
模块化：大部分运维工作能做到模块化，直接使用  脚本或者 ，还是过于低级，比如：          
         
    
    

标准化：所有的模块的使用方式都是一样的，减少学习成本

然后，我个人认为  解决以上问题都是为了实现一个最根本的目标：自动化配置！关于自动化配置，你可以看看我写的另一篇文章： 关于自动化配置还有什么好说的呢？
最后，这篇文章存在一个假设：手工运维、非模块化、非标准是问题，需要解决。如果你觉得这些都不是问题的话，这篇文章所说的也就都不成立了。导语 出于安全考虑，一些敏感信息是需要加密存入数据库的。这样即使被黑客脱库，也能最大限度的避免损失。

数据加密并不是难事，各种现成的加密库可以轻松实现高强度的加密。对于加密标准的选择，根据实际场景需要，在《开发运维安全标准》 算法标准 中选择合适算法即可。
在实际开发中，我是在业务现成逻辑代码已经大体完成时接手，被要求将部分字段加密处理的。因此，我希望加密逻辑对业务逻辑完全不可见，做到不需要修改任何业务逻辑代码，即可接入数据加密。
要做到对业务逻辑不可见，就需要在字段入库和出库时，自动进行加密和解密。的自定义提供的一些接口，可以在数据出库后、数据入库前，做一些特定的操作。如：，就是使用了这些接口，做到了可以直接使用的进行操作，免去了与数据库类型转换的工作。
下面这个例子，选择的是对称加密算法，对进行加密处理。
 

    在数据库中加密的 
     兼容未加密数据，加密后字符串会带上
    

     ____  

        初始化
          加密串前缀
        
           
 = 
 

 = _

         = _
 ____ 

 
            =  
  = _
             = 
    

 __    

        出库后解密数据
        
           
 
 
             = 
             = 

 

 _ 

        反序列化和 时调用，解密数据
        
           
 
 
             = 
             = 

 

 __ 

        入库前加密数据
        
             
             = 
             = 
    
        

 

中使用秘钥生成加密器，用于后面的加密，这里的秘钥是写在 中的。
是标志加密后字符串的前缀，用于区分加密前和加密后数据。为了兼容已有旧数据的情况。
__是数据库返回值后，调用的函数。在此函数中，进行数据解密，需要处理的情况。
__是数据入库前调用的函数。在此函数中，加密数据，加上前缀。需要判断的情况。
_是需要在反序列化和表单时使用的，可能遇上加密后数据，也可能遇上未加密数据和，需要注意判断。
这里兼容了存在旧数据的情况，因此需要使用判断前缀是否匹配。

： 

加密算法，如果设置随机的向量，哪怕加密相同的明文，每次加密产生的密文也是不相同的，因此无法对加密后字段进行数据库查询操作，业务代码需要注意。如果需要实现数据库查询，需要固定向量，并且实现__方法。
这里的写法兼容了可能存在的旧数据，如果不对这些旧数据进行操作，这些旧数据将保持明文状态。如果需要加密旧数据，只需要进行一次取值存入操作，即可将旧数据加密。
注意_的设置。加密后的密文长度，会与明文有所出入，需要根据所选加密算法和前缀进行计算。该例子只提供了基本的加解密功能，展示了如何编写的自定义 ，用途不仅仅是加密。如果需要更加复杂的功能，参照官方文档：

下面附上可以直接拿来使用的代码
使用说明

安装依赖
将直接换成。
密文比明文长，注意修改_。的_可以计算加密后的长度，最后要加上密文前缀的长度，默认前缀_长度为。即：___
密文前缀默认为_，可以通过添加参数修改设置。 
   =  _= =

使用的是的_作为密钥，做了一次。
由于兼容明文旧记录，旧记录至少需要一次保存操作，才能将明文替换为密文。如果需要立刻加密，可以通过脚本逐条保存一遍，注意避免与用户并发操作导致数据一致性问题。
使用随机向量的加密算法，加密后的数据无法进行查询，保证业务中没有以字段作为查询条件的语句，如果需要实现数据库查询，需要固定向量，并且实现__方法。。
老版本使用做同步，需要配置的路径。具体可以参考文档   __
__ _\\  示例作者：罗皓


背景
 年  月，微信红包上线。 年春节微信红包引爆社交支付。 年春晚红包摇一摇，推动微信红包在全国迅速普及。此后，每逢节假日或特殊日子，人们都会自主的兴起发红包，使微信红包成为热点。微信红包的火热带动微信支付的迅猛发展，按当时的发展速度预估，到  年底，每天的微信支付交易记录会达到  亿。而原有的用户交易记录存储系统无法承受业务迅猛发展带来的冲击，一些瓶颈逐渐凸显出来。本文将就微信支付背后的交易记录系统的重构优化历程进行一次全面的呈现。

历年春节红包收发总量
老交易记录系统面临的问题：
由于老的交易记录存储系统是采用的方式存储用户数据，每个用户的所有交易记录存储在一个中，随着用户交易数据的不断增长，单个  数据会不断变大，最终单个  的  上限会导致用户新增数据无法写入。
老系统将交易记录的写入流程放在了支付的关键路径上，然而，从整个支付业务场景来看，交易记录应该属于用户支付后的应用场景如：查看交易详情、确认交易状态等。所以将交易记录写入流程与支付关键路径解耦合能优化提升支付的效率和体验。
老系统中交易记录的种类不全：这里的主要原因是在业务发展过程中有些场景的交易记录并没有纳入进来如：收红包记录和派奖收入等。记录不全对用户会造成体验上的损害。
记录查询方式过于简单：老的系统里把所有的交易记录按时间顺序排到一起，用户只能通过不断下拉的方式来查看。当用户想查找某种类型交易，或某条历史的交易记录是，只能通过人肉遍历，非常不方便。

老交易记录系统交互界面 
针对当时的业务背景和问题，我们需要开发一套能够支持海量数据存储、高性能、高可靠、查询灵活的交易数据存储系统。
技术方案
方案：采用关系型数据库存储需要分库分表，扩展不方便。采用简单的分布式  存储，能够解决数据水平扩展的问题，但是对单个用户的数据存储和管理存在问题老系统存在的问题，单个  过大。因此我们采用基于分布式  存储平台 ，对用户数据进行分档管理。画图示意存储结构

用户数据存储示意图
每个用户的数据由若干个  组成。其中一个  为根节点，存储用户分档数据的元信息。其余  为数据节点，存储用户实际数据。用户的数据按时间的顺序分档，根节点中保存每档数据的时间范围条数等信息，当用户按顺序翻页查询时，根据请求的数据的起始偏移和条数，能够快速查询到所需要的数据。如果要查询某一条交易记录，先通过记录的时间在根节点中查找到对应的数据节点，再从该节点快速查找到该条数据。
数据分档是为了解决数据增长后单个  大小成为瓶颈的问题。那么存储用户数据元信息的根节点随着数据的增加是否也会成为瓶颈？这里的答案是肯定的，按照业务实际的数据大小，一个根节点管理  万条用户数据时，其大小就会达到瓶颈，需要对根节点进行分档。如果我们再用一个元数据节点来管理分档的根节点，那么随着数据的增长，这个节点也需要再分，需要再增加一层节点来管理。这样数据就像一个不断增高的树一样，对读写访问的性能造成影响。
怎样来管理一个不断增长的数据，同时保证数据的访问维持在一个相对固定的深度？首先我们再来看看用户数据的特点，按时间数据写入。访问主要是近期的数据，越老的数据访问频率越低。因此，我们将根节点的分档数据按照一个链的方式串起来，最新的在链头，最老的在链尾。当用户访问新的数据时，平均只需要  次查询根节点 数据节点，访问较老数据时需要遍历根节点的链，由于这个链是有序的，所以可以采用二分查找，时间复杂度为 。

数据分档组织示意图
分类和统计功能是用户查询交易记录的一个基本需求。分类能够让用户快速定位到想要查看的交易记录；统计功能能够一目了然某月的收入和支出情况。但是采用  的存储平台不能像关系型数据库那样方便的按条件查询。根据业务的访问场景，所有的分类和统计查询都是在一定时间范围内的，而我们的数据是按时间来组织的，因此，对于分类请求，我们可以取指定时间段内的数据进行遍历。由于用户平均的数据在  条左右，一般查询时间范围在一个月左右，这样实际遍历的数据条数在几十条，因此时间延时可以满足需求。对于统计请求，是按自然月，这样我们可以将历史月的统计计算出缓存起来，而对当前月的统计实时计算。
线上运营
历史数据问题：历史数据问题是一个很繁琐很耗人力的问题。前面提到过，老的交易记录系统中用户的数据并不全，为了保证新系统中历史数据完整，需要从不同的数据源导出数据，而且每份数据都不是完整的，只有他们合在一起才是完整的。对于一条交易记录，其中部分字段要以微信支付数据源为准，部分字段要以财付通数据源为准，因此对历史数据的整合、清洗和校验需要微信支付、财付通等各团队同事的配合。最终我们用了  个月左右的时间完成了  亿条历史数据整理、校验和导入。
数据异常问题：数据的完整性和可靠性是存储系统要提供的最基本保证，因此系统在对数据的所有写和修改操作都记录了详细的流水。在最初灰度数据阶段，我们发现当底层存储平台出现大量超时的异常情况下，总会存在少量用户的数据丢失的现象。通过分析流水日志，发现超时个别用户的少量数据发生了回退的现象。进一步分析发现是因为存储层超时时间远远大于我们请求的超时时间，当业务的写请求超时后，会发起新的写请求，而这时老的写请求后到达覆盖了新请求的数据。针对这种场景，由于底层暂不支持  机制，因此我们采用全链路的排队机制，让单个用户的请求在每一层都落在指定的服务器和进程上，排队执行，避免数据覆盖。

数据覆盖示意
节假日效应：微信支付中红包占了很大的比例。而红包的节假日效应非常明显，在春节除夕这样的节假日，请求量能达到平时的  倍。还有一些提前难以预计到的特殊日子如：， 等，请求量也会突然翻倍。针对这种场景，如果用大量机器资源去扛节假日峰值，一会造成资源的浪费，此外还会加重运维扩容、缩容机器的工作。因此，我们在节假日高峰采用一些柔性策略，削弱峰值请求的影响。当请求峰值大于我们预设的阈值，就把大于这个阈值的请求先缓存到接入机的本地磁盘，当峰值过后再将这些请求按一定速度落到底层存储。在未落底层存储前，这些记录无法查询，因此那些记录能够做消峰的柔性处理，需要结合业务场景，在实际应用中，我们只会将红包的请求做消峰处理，而对其他支付请求不会做这样的处理。

 年春节请求量与平时请求量对比

数据安全：用户的交易数据是非常敏感的数据，一旦数据泄露，会对用户造成极大的损害，同时对微信支付也会是致命的打击。因此用户的数据安全问题是头等重要的问题。如何保证用户的数据安全？目前我们从三个方面来做：

访问控制：所有请求必须带票据访问，票据是用户身份的认证，保证只有该用户发起的请求才能访问该用户的数据。对于非用户发起的访问客服查询、退款请求等需要公共票据。此外，系统内部服务器访问有白名单控制，非白名单内的服务器无权进行访问

数据脱敏和加密：用户数据内的敏感字段要进行脱敏或加密，比如：用户的微信号、微信 、商户号等信息，都要进行加密处理。同时，对用户的身份  进行虚化，即使用户数据泄露，也无法跟具体的个人对应起来。

人员制度规范：在数据安全方面，出现问题往往是在人这个环节。开发人员和运维人员往往具有较高的数据操作权限，因此，对开发人员和运维人员的安全意识培养，和完备的管理制度是非常必要的。收敛数据操作权限，权限最小化。对于线上所有的运维操作和开发测试工具权限我们都接入到公司敏感权限管理系统，使得数据操作权限集中掌握在少数人手中，如果出现数据泄露问题首先从这些掌握操作权限的人问责。同时，所有的数据操作都会记录操作流水，可以用于对数据操作异常的审计，以及出现问题后的追查。


效果
通过对微信交易记录系统的重构，用户数据的完整性、准确性得到极大的提高。其中零钱明细之前因为数据不全的投诉已经没有，整体投诉率下降 。用户的活跃度得到极大的提升。当前的日交易记录数接近  亿含红包收，总数据量已破万亿。在交易记录的查询体验上也更加方便。在数据的存储和管理方面，我们遵循行业内的安全标准来要求，以保证用户的个人信息和数据安全。

新交易记录系统交互界面
总结
滴一下就可以支付的时代已经来临，微信支付，一定会是一个全球性的支付。伴随无现金生活在全球范围内的普及，我们的舞台也将越来越大。目前新的交易记录系统是基于当前支付业务的特点和需求，后续随着支付业务的发展，支付场景会更加丰富，支付的形式会更加多样化，对于交易记录的需求和挑战也会不断变化。未来我们对系统的优化方向，是提供更加方面、实时、准确、安全的用户交易记录存储和查询平台。而我们追求的是尽可能把交易系统做好，给用户带来最好的体验！一背景
之前有个包忘记密码了，网上搜的一些暴力破解的软件，要么收费，要么不好用，最关键的是，速度太慢，于是自己决定开发一个分布式的密码破解软件。软件的问题解决了，分布式执行需要的机器的问题来了。云自身的分布式组织，跟分布式软件天生契合。
二 分布式密码破解软件架构设计
    架构图

    模块设计
整体架构是模式，多个通过来调度，执行破解任务。    分为层和分发层，层是非必要的，可以做成独立客户端，也可以做成的服务，甚至命令行也是的。分发层，这是分布式的核心：调度执行破解操作，同步执行信息。这一层的实现，不能依赖操作系统，也不能依赖，这样可以保证可移植性。    调用层，也是可移植性编写的一层。分布式的实现关键就在于的分发层和的调用层之间的交互协议了。层，可以跟调用层交互，展示当前的状态信息和进度，也是非必须的。实现层，具体实现破解的操作，例如、等压缩工具只能暴力破解的可以考虑用，其他的、可以使用对应的破解工具或算法。这一层会跟具体平台相关。对于这种跨平台的软件来说，根本也不是问题
三使用腾讯云搭建系统
    购买云主机
用账号登陆后，进入控制台，选择下图中的“云服务器”。 
在界面上选择“新建”，就会有一个流程让你选择对应的配置、地区，会标明使用价格。从根本上讲，核数决定了执行的快慢，但是如果核数选择的不好，可能会导致调度成本，影响整体性能。一般来说，以核的比较好，其他的硬盘、网络等配置可以低一些，节省成本。从实现上，可以在一台核的机器上，部署个，当然也可以部署一个，然后并发个线程，将使用率最大化。个人比较推荐的是个通过不同的端口号或协议内部实现区分，避免进程内部的调度、同步，如果实现的不好，容易导致、死锁或性能消耗。
    机器配置
如果购买了多台机器，那么可能要处理机器之间的网络环境，各类云服务都提供了丰富的网络特性，以满足复杂网络需求。还有更高阶的虚拟私有网络、子网等内容，这些是针对企业级或大型应用的，暂时用不到。 
可以配置安全组用于限制自己内部子机间的访问策略，这个是动态的，类似于，相当于防火墙策略，一般使用默认的全部开放就可以了，安全级别要求高的应用可以定制自己的策略。密钥，如果你的云服务器英文通常称，  绑定了密钥，那么你在使用登录的时候，客户端会要求你提供证书，证书在创建密钥后可以下载到本地。如果没有绑定，可以指定登录账号和密码，至少会有一个账户的话。弹性公网，这个是让你的应用能够在公网使用的关键，通常来说，创建的都是内网，是无法在公网中找到的，如果绑定了弹性公网，那么就可以在公网上访问了，类似于家里路由器对应的主机，是可以被公网访问的。
    应用部署
既然放在云上面，为了能够自己用，甚至提供给别人用，当然是要做成模式的应用了应用自身内部是模式。使用，可以快速构建一个网站，并提供对应的接口，操作端，下发任务就便捷了。赶紧自己去试试，做一个分布式云应用吧！！

相关推荐
浅析海量用户的分布式系统设计
高性能服务器架构思路三——分布式系统概念
分布式云数据库  编者按： 吴林松，基础架构部运维中心负责人，年毕业后一直从事业务运维，先后供职去哪儿，百度，思科，拉手网，经历过处于不同发展时期、不同管理风格的公司，见证了运维的起步、发展到现在的繁荣，始终对运维职业保持着热情。
当我们邀请在运维日下午茶跟伙伴们聊聊运维职业成长的经验，他很爽快的答应了，又很谦虚的说希望别把兄弟们带沟里去了。事实究竟如何，来不及解释了，一起看看吧。


谈运维的职业成长，借用很多人都听过的观点，首先保证你的工作不可被别人取代，在此基础之上做到能取代任何人做好这份工作。怎么理解这两句话？如果运维只是做纯的工作，其实公司招一个应届毕业生也能够做到，为什么还需要付出更高的成本请一个高级工程师来做？如果你是公司管理者，你会怎么考虑？这是从公司用人管理成本角度来看；从运维个人来看，比如说开发做了一套运营系统，运维能做的最多只是上去写个脚本发布，其他的都干不了，然后拿人去堆效率，这样的运维工作如何让老板看到价值所在，自己累不说，也很难有什么工作成就感、价值感，更谈不上未来的职业规划与成长。
————
回顾自己这么多年做运维的经历，我想分享三点供大家参考：首先是要能耐得住寂寞。理解这句话我想先分享一个大的背景，年整个互联网发展也处于起步阶段，行业里还没有“运维”的概念，那时候叫技术支持，可能划分到项目里更有效，在整个信息部下面，会有岗位专门叫 ，系统工程师，网络工程师，存储工程师，或者是数据库，那时候谁也不会预见所谓运维将有能产生多大的价值。因为那时候公司的市值远没有现在高，行业上整体运维的投入量及产出比也没有现在这么大的规模。现在，做一个成本优化项目一年就能节省几个亿，相比之下，外部其他创业公司一年的营收都不可能达到几个亿，更没有条件去做所谓运维成本优化。所以能看到现在整个行业发展趋势对运维都还是看重的，这本身对运维人员的发展来说是非常有利的。
回到个人发展，我讲耐得住寂寞有两层含义：一是能否把前五年的精力投入在提升专业技术深度，而不受其他外界因素的影响。举例来说，在深圳大环境之下，大家很习惯聊三句话就话题转移到最近哪个小区房价又涨了，后悔没有早点买房，当然话题也可能转移到买车、炒股之类。这里申明一下不是说不应该聊这些话题，只是以此为例想对刚毕业几年的伙伴们说，在你入职场的头五年，是否能够把精力投入在关注如何提升专业技术深度，不要受环境影响，不要在意这些物质追求，而应该把眼光放得长远些，想明白自己到底追求的是什么，想办法让内心安静下来，专注于你眼前要努力提升的技术、能力短板，为实现你的长期目标做充分准备。
耐得住寂寞的另一层含义是努力拓展运维技术的广度。谈到运维与开发的区别，很多人会说运维其实没有开发有价值，但实际来看，开发的技术主要关注几方面，如精通一门编程语言，对底层容器的理解、网络交互，文件存储，内核计算的调用。而运维如果要做的很专业，其实需要涉及到安全，系统 、网络、中间件、工程语言、、应用存储、网络存储等等很多模块的内容，维度划分很广。所以很多人做运维，能力却并不被开发认可，很大程度上说明头五年是没有投入充分的时间来提升技术能力。
以我为例，很多人会觉得我的职业生涯跳槽挺频繁，面试时也问我“为什么你中途还去了一趟思科”，我的回答是，当时认识到自己的专业技术有一块短板，对网络的认知深度不够。去了思科后，我才知道思科能把划为了六个，  、、、 、。理解了思科整个网络跟计算机的五大系统是一模一样的，对应区分开的，它的 是后来基于云计算兴起，开始做整个数据中心解决方案的时候加的一个新认证。而我有幸在思科待了三年，再出来时我对网络技术的认知和理解对比之前有了明显提升，理解所有的计算机包括网络其他设备的设计，最终都会追溯于整个大的网络结构，所有网络存储实际上都会划到单机的文件存储，所有交换的策略也会划到单机的内存，是一一对应的，因为互联网整个的框架现在是没有变过的，这是我跳槽思科带来的收益。这也是人们常说，从本质来讲，如果把一门技术钻研的很深，再去投入学习其他的技术，是会触类旁通的。我举这个例子当然不是为了鼓励大家跳槽，是想说无论是跳槽还是停留在原有平台发展，你都要努力拓展自己运维技术的广度，如上面提及的运维需要学习的技术领域，时刻对标身边的技术专家，看看自己在哪些方面存在短板，寻找合适的方式方法让自己快速学习成长，即便有机会去到一个新的平台，也要清楚你去到这个新平台的目的是什么？是希望自己的视野、专业技术、管理经验等方面有哪些提升？而不仅仅是奔着所谓的物质待遇更好。
再补充一点，为什么要鼓励大家在头五年耐得住寂寞，还因为头五年你单身，年轻，熬夜什么都没有问题，精力足够旺盛，比打兴奋剂都好使。过了三十岁，精力就没法保证跟以前一样了。你熬夜连续加二十小时班，一天休整也缓不过来，而应届毕业生，加班二十四小时，一觉都不用睡，甚至一小时都不用睡，该打篮球玩王者荣耀一点都不耽误。从精力上来说你已经拼不过别人了，如果你还不在前五年牟足劲提升专业技术，还能拿什么跟小鲜肉拼。
————
我的第二点建议是保持好奇心。在整个职业生涯中，我们会遇到各种各样的问题和挑战，希望大家无论工作、生活都记住一个原则，就是保持好奇心，让自己无论是面对技术、工作、生活都多一些思考、追问。只是很多人在职场习惯这样一种做事风格，他知道老板什么风格，于是老板说这样做就这样做，从来不问为什么；也知道客户要什么，因为客户天天只要这个不要别的，所以不需要开口问为什么。实际上在专业技术成长过程中，要有足够的好奇心才会驱动你去研究这个技术，才会刨根问底到底是架构还是底层核心有问题，才会一步步去深入，既拓展视野也强化深度。如果不问为什么，比如领导安排你去做一个事情，旁边的人告诉你我觉得不太好，你说我觉得做的了，旁边的人还可能会说，我认为应该这样做，而你可能会很诧异，因为在你的理解下，已经认为这样是最好的。别人会告诉你还有更好的方法，而你不以为然，不会认为别人的提示对你来说有什么帮助，因为你没有好奇心。那你对做好这个事情的理解也就是有限的，更谈不上在技术深度上有什么拓展。好奇心是外在的，有好奇心会让你不断的往前走，然而现实中很多人是因为别人都是这样所以我也这样，主动放弃思考、追问。
再提另一点题外话，我自己也会看一些周易方面的书，周易有一个风水学方面的观点，说人一旦有一个势，势不能改。就是说，当我们刚毕业很年轻的时候，人生不能算最低谷，只能算职业生涯的最低谷，是得一直往上走。大家觉得是当=走的最快，还是=无穷走的最快呢？很多人会觉得我努力了，始终在往上去奋斗的时候发现自己一直在往上升，突然有一天安于现状，突然觉得自己舒适了，觉得自己达到了目标，那个时候整个势就不变了，这里面有个很浅显的道理，就是你的势一旦变了，做什么都回不到原位了。
————
第三点建议是保持运维的核心竞争力，比如掌握一门能够落地实现的工程化语言。现在有运营开发，行业里、讲的很火，但你会发现所有运维不受重视的本质问题是，自己没有工程实现能力。开发会把一个产品写成代码，我们运维的时候却发现，最大的挑战是需要开发帮忙写一个系统。而如果自己掌握一门开发语言，比如，可能早期是，还有最早期用。这个技能可能最开始写基于内核以上的脚本工具化的东西，做不了图形化，但是这是你整个自动化核心竞争能力的第一步。第二步是，如果开发能用一个语言写出一个产品工具化，为什么运维不行。如果你掌握这个核心技能，是谁也无法替代的。比方说现在的主流是、，有人可能还会说，也行，我记得早些年写很牛逼的人，一般在业界都被评价是神经病。因为的复杂度，它的逻辑思维跟我们的正常生活不太一样，有幸我有同事也的确写的很牛逼。因为在正则表达上面，即使现在的的正则表达上也没有强。比方说，的转发配置， 的后面的版本，都是基于的正则表达去改的。
这里面就回到一个问题，当你知道做一件事情，并且具备工程化实现能力，自然就会把周遭所有的，比如说数据化，图形化，界面化的东西就能做到水到渠成。如果没有工程化语言的能力，运维就叫，后面加个，是最不会被人所接受的，在任何一个团队任何一个公司，可替代性为百分之百。如果掌握核心的工程落地实现的语言能力，你可以追求如果这门语言学的很好，例如学的很好，加一个框架也做的很好，将来可以转运营开发，做开发。其实现在有很多公司，主程，包括运营系统全是用开发的。你也可以用技术推动运维团队向大家聊的很 的自动化，智能化，运维发展，因为现在基本上都是把开源软件一些核心框架的轮子，零件拿过来，自己修一修，把发动机重新拼装一下成为一个超级跑车。没有谁自己重新去建一个车，轮子，包括，所有大公司很牛的公司，因为业内已有很多开软软件，框架底下逻辑演变的复杂度，稳定度是需要时间衍变的，很难有一个团队去做开发，去做工程化的实现这么去做，但是做理论研究，做学术会这么去做。
————
最后跟大家一个建议是，自己保持对职业的热情，要有内驱力。前面提到好奇心是外在的，内在是取决于你是否有足够的内驱力。什么叫内驱力，内驱力就是做所有的事情包括追求人生目标，都是自己内心愿意去为之付出、努力争取的，为了达到目标，你知道遇到任何问题都会多问一个为什么。有人可能会问，你是如何坚持一直做运维？尤其运维从最开始的价值就不高。我说其实很简单，最开始我们很多人梦想说改变世界，长大后世界改变不了改变他人，他人改变不了，改变自己，最后连自己都改变不了，就混日子，逻辑是这样的。我相信如果一个有恒心的人，你愿意去做成事的人，你可以克服很多困难。你会追求先把自己做到最好，然后去影响改变他人。怎么让自己过得更好，这需要有足够定力跟驱动力，我头五年可能跟大家一样苦，曾经在去哪的时候，也有加了九十六小时班没有睡觉。大家也许关心一个问题，这么辛苦付出，老板能否看得到？其实这根本不是你需要关注。如果你能做的到，把自己做到极致了，该付出都付出了，老板是一定可以看到的，也会给予你应得的报酬。
————
：做运维的工作因为经常半夜接到告警，就会觉得心很累，也想问问怎么保持对运维工作的热情呢？
：头五年在面对告警问题时，我能做的就是尽量收紧所负责系统的告警数。但我也发现其实很多人做监控告警的策略是，只要出现问题就告警，例如只要是有事件，有信息，有异常，就都告警。而忽略去考虑一个问题，实际告警得到的信息有什么意义？我会建议设计监控系统时，告警策略应该是能确切反馈问题出在什么地方才告警，而不是只给一个告警，因为只有做到清楚了解问题，将来才能推进往所谓的运维自动化和智能化方向发展。否则即使让去学习，也只能通过常理去学习，理解你告诉它的问题是什么，基于问题给建议或者引导下一步的处理措施。
很多人也会说监控告警的过程中，一种做法是有设计，另一种做法是最开始不设计，就只是添加告警，但是就会产生很多告警，而你能够充分理解业务逻辑，当线上出问题时，才能确保快速定位问题。比如请求到底穿没穿防火墙，穿没穿安全策略，这个模块有没有被流量清洗，是旁路还是直流下来，或是中间有没有经过第三方做数据处理，你能够清晰这背后的逻辑架构是怎样的，面对面沟通时就不会还在讨论到底是你的服务器有问题还是他的监控有问题，原因一目了然。我一直坚持平台的运维往业务化去做，更多的去理解客户的想法，客户的需求，业务往平台化去做。很多人会产生这样的观点，我负责的平台量很大，每天承载几十万、几百万用户，可以选择忽略有些人的告警，因为他不是我的。我的观点是，如果你负责的平台没有区分和非客户，参考二八法则，你的非客户会决定平台的生死和将来的成长，反过来业务发展势头很好，但是你没有考虑往平台方向做，就会让自己非常吃力。
运维没有  一说，对每一个模块必须要有足够的掌控能力，如果没能掌控这个模块，你就没有资格做这个运维。如果能够做到掌控所有的点，比如告警的收敛，告警的策略就可以自己来设计，有人说这还是没有解决告警很多的问题。确实告警会多，但你可以做到，知道这一条请求数据流下来，十个节点中只有一个节点是致命点，其他节点都是关联告警。如果是关联告警，你觉得系统有容错设计，即便报关联告警，可能还可以抗五个小时或者抗两个小时，那告警无需设计成电话告警，邮件是不是也可以解决。甚至到你有足够掌控能力时，是否可以设计成十一点到第二天早上六点之内不告警，只报致命告警，其他都不报，你可以逐步调整系统告警的阈值，各种策略，足够去做收敛。我经常也会听到团队成员吐槽告警太多了，没时间干别的，我一贯的回答是，告警是太多，但你想不想未来过好日子，那就去做，你不做我找别人去做。我对他们有一句听起来很理想的话，就是希望有一天运维可以坐在这里啥事也不干，喝咖啡就行了。
我也跟团队举过这个例子，大家做运维久了都有个习惯，拿着手机有电话有告警，突然有一天十分钟没有收到告警，就看一下手机有没有信号。为什么总有这种担忧，因为你觉得自己的系统不靠谱，真正觉得系统靠谱的时候，即便没有信号，你都会相信自己的系统没有问题。所以大家说告警这个问题收敛不好，其实根本问题还是在于要把自己的专业度，对整个业务模块的掌控度逐步的提升到一个很高的水平；把告警收敛好，才有更多的时间去投入到钻研技术的深度，才有更多的时间去学习新东西，才会放眼去看整个行业或者业界有什么新技术新发展趋势，如果天天来上班看到告警，回家收到告警，半夜还被告警惊醒，我相信你就是有心想做去看业界去想学更多的东西，也没有足够的精力了。一直在互联网领域敢于创新实践的深圳，近日又率先推出了电子证件服务。深圳交管部门携手腾讯“互联网警务”联合团队，在微信城市服务推出电子行驶证和电子驾驶证， 微信证件首次实现线下应用场景。车主在遇到路面执法，或前往窗口办事等情况时， 微信证件即可完成身份认证，避免证件不在身边带来的罚款、扣车或怠误办事等情况，同时也极大提高了交管部门执法时身份认证和处理事务的效率。
电子证件的使用特别方便。深圳本地用户点击进入城市服务，在车辆服务中，就能找到驾驶证业务和机动车业务。完成“星级用户认证”后，即可申请电子证件。对注册成功的星级用户，系统自动将证件生成专属动态二维码，与注册时提交的驾驶证、行驶证图片合成为实时“手机电子证照”。在不带或忘带身份证、驾驶证和行驶证的情况下，交通警察可依靠系统数据进行人员身份、驾驶资质和车辆属性的确认。在交警窗口办事需按规定须留存复印件的，由窗口民警至后台调取打印存档。

城市服务深圳车辆服务机动车业务驾驶证业务个人中心电子证件示意图
事实上，电子证件只是此次深圳交警推出的十大便利服务升级之一。据了解，目前微信通过与深圳交警合作已经推出了交通违法查办、驾驶证业务、行驶证业务等多项服务，并在微信城市服务平台落地。
此次双方合作，恰是深圳交警推出“星级用户服务”一周年之际。作为互联网警务的深入合作案例，电子证件成为了亮点服务，在全国尚属首次，极大便利了民众办事和交警执法，除了微信城市服务平台之外，还将在微信卡包发布落地。作为互联网警务一次重要的实践探索，将与微信卡包、电子身份证、人脸识别等技术应用共同推动未来智能身份认证的实现，警务工作走向更智慧高效的模式。做开发的同学都非常熟悉代理模式，为避免代码耦合，代理模式的委托者任务交给代理执行，代理执行完毕之后再把回调告诉委托者。委托者不关心代理是怎么执行任务的，只关心结果是成功还是失败。代理模式就像是杀手与雇主的关系一样。
但是代理模式也不完美，代理多了，雇主也管不过来了，委托在处，收结果却要在处。有的时候，雇主也希望能在同一个地方既可以发配任务，也可以接收结果。闭包就能帮雇主解决这个问题了。无论是系统的，还是平时随手封装一个  的实现，都让代码的可读性有了一定的提升。
无论是代理模式，还是闭包，在处理单一任务的时候，都出色的完成了任务。可是当两种模式要相互配合，一起完成一系列任务，并且每个任务之间还要共享信息，相互衔接，雇主就要头疼了。当然可以只用一种模式来实现，代理模式就不说了，过于分散，不善于处理这种流程性的事务。那我用闭包来举一个例子：我们需要顺序执行 、、 三个任务，、、依次执行，任务完成之后都使用闭包来回调并开始下一个任务。代码如下：
   
{
    ____  {
         {
             {
                {
                     
               }
            }
        }
    }
}
上面的代码看起来挺清晰，可读性也还可。如果加上一些  的分支判断，再加上一些参数的传递，代码不知不觉的向右延伸，最终超出了屏幕的宽度，形成一个倒金字塔的形状。写  的同学会说：你已经掉进了回调陷阱，赶紧用设计模式来跳坑吧。
 设计模式的原理
设计模式把每一个异步操作都封装成一个对象，这个对象就是这个异步操作执行完毕的结果，但是这个结果是可变的，就像薛定谔的猫，只有执行了才知道。通过这种方式，就能提前获取到结果，并处理下一步骤。
 使用  作为关键字，回调最终结果。  是整个设计模式的核心，必须要被实现。另外还有其它几个关键字用来表示一个对象的状态：

  任务执行中，状态可能会进入下面的或者二者之一

 任务完成了，返回结果

 任务失败，并返回错误


更多可以参考 官方规范。

如上图所示，与的状态都是不可逆转的，保证了结果的唯一性。
除了  ，一些对  的实现还有几个关键字用来扩展，让代码可读性更强：

  任务失败，处理

  无论是遇到  还是  分支，最终都会执行的回调

  多个异步任务执行完毕之后才会回调


模式的实现
设计模式在  平台的最佳实践是由大名鼎鼎的的作者   写的一个支持 的异步编程框架 –   作者的另一个广为人知的趣事是因为没有写出反转二叉树而没有拿到的。
我们先抛出对上面改良函数使用的实现，再看原理

 
{
     {
          
    }{
          
    }{
          
    }
}
调试后，发现执行的结果与我们期待的一致，但是上面的代码对我来说有几个疑惑点：

 是怎么串起来的；

怎么实现的顺序调用；

如果传递参数，参数是怎么传递的。


带着问题，来看的源码：
   {
      {
         ___ 
    }
}
如果对不是很熟悉，可能不太理解这段代码，实际上，灵活的使用了作为函数的返回值来实现链式调用。相比原来的嵌套模式，使用将多个  串联起来，解决了 。
接着来继续看下一个问题。

  
           __     
{
    __  
    __  

    __ {
          = _
            

         = __    {

             =  

            __   = 

            ___ {
                  = _
                    

                __  
                 =      {
                     =  {
                            
                    }
                }
                _  {
                        
                }
            }

                 
        }
    }

        
}
代码有点长，不过也可以理解。这个方法是上面的调用的，接受两个参数，第一个参数是一个的，第二个参数是一个的。一个在执行完毕之后，无论状态是变成还是都通过这个方法，执行对应的 ，并返回一个对象。上面的函数中，有一个 ，是栅栏的意思，一般来说如果我们有多个异步任务，但是希望他们按照一定的顺序执行，就可以使用这个方法。在这里通过实现了的依次调用。在这个方法内部，一个是会去看当前是否已经有下一个要执行的，如果没有就生成一个新的，另一个把对应的 放到队列，依次执行。
参数传递
这里需要思考的另外一个问题是，既然多个任务之间有依次调用的关系，那么这样的一种任务流之间如何互相通信呢？用了一个比较有趣的办法来实现相邻对象的参数传递。
在万物皆消息的语言内部，每一个方法，包括在内都是有类型签名的。这个类型签名对象就是 
    {

   

     ___


那么对于，怎么获取类型签名呢自己定义了一个的结构体：
  {
      
     
     
       
     _ {
                 
                      __
         _          
         _                
                                 
    } 
}
熟悉的同学都知道，按照位保存了一些的附加信息，在 的这个可以找到是否有类型签名剩下的就是通过移动指针，找到所在的内存空间了。找到了也就获取到了参数个数与函数返回值这些信息。函数返回值的类型是经过编码的，具体的对照表可以参考官方文档
     ___    {
          = 
           = 
           = 
            =  
           ==   
                               
                               
    }
有了函数签名，就能知道的信息了。上面只截取了部分代码，简单来说， 通过动态的获取的参数个数与返回类型来决定的调用。一般来说，  在调用的时候最多只支持传递一个参数，在必要的时候，把这些参数放在一个数组里面，这个数组就是  ，当检测到这个参数是一个数组的时候，就依次取出数组内的元素作为参数传递。从而支持了多个参数的传递。
总结
至此 对的一些解释也就结束了，有的版本，也有支持了的版本。如果你非常享受这样的书写方式，可以接入很多扩展的版本，可以写出看起来优雅又舒服的代码，比如  
 {  

} {  
    …
}
还有很多的扩展与关键字的支持，这里都不再展开。
而对于我来说，设计模式能够解决我对散落在各处的代理模式产生的代码的烦恼，也让我避免了跳进回调陷阱，就值得总结了。作者：，腾讯移动客户端开发 工程师
商业转载请联系腾讯获得授权，非商业转载请注明出处。
原文链接：

 导读
随着、等优秀跨平台游戏引擎的出现，开发者可以把自己从繁重的、原生台开发中解放出来，把精力放在游戏的创作。原来做一款跨平台的游戏可能需要开发者懂得、、甚至是、，现在借助我们开发者只需要懂得很少的原生应用开发知识就能够打造一款优秀的游戏。特别是在鹅厂，有了这样的组件，原生的接入更加简单，可能每个项目组只需要有个人懂，开发就够了。但是也正因为如此，很多同事有了充足的理由不去学习、接触和的开发，等到真正需要做接入的时候才开始找人找资料，难免会踩坑。基于此，本文的目的就是通过介绍基础的开发知识以及部分的实际操作，让大家有一定的基础知识储备。又或者是当作一份接入 插件的基础教程，只要照着做，就基本上不会错了。

本文将会从大家熟悉的为出发点来介绍如何将自己写的或者第三方的插件集成到自己的游戏中。

是怎么打包文件的？
安装及配置 
开发基础以及导入到

一、是怎么打包文件的？
大家看过一些第三方组件的接入文档都知道，在里面有几个特殊的文件夹是跟打包有关的。首先我们就来了解一下，这些文件夹里面的内容是经历了哪些操作才被放到里面的呢？
在的目录下，无疑是其中的重中之重，首先我们先来看一个常见的目录是什么样子的。

后面的四个是工程的文件。前面两个文件夹是我们引用的第三方库，他们也会被打包到中。我们这个时候如果点进去前两个文件夹，我们会发现他们的目录结构跟这个目录也很像，大概是一下这个样子的。

比较上下两层的目录接口我们可以发现有很多相似的部分，如：、、文件夹以及文件。这些其实都是一个标准的项目的所需要的文件。自带的打包工具的作用就是把上述这几个文件夹里面的内容以固定的方式组织起来压缩到文件里面。接下来我们分别来看看打包工具都会做什么样的操作。
● 文件夹里面有很多文件，以及被放在固定名字的文件夹里面的文件。文件是编译器把代码编译后的文件，在打包的时候会把项目里面的所有文件进行一次合并、压缩、重新编译变成文件被放在根目录下。当应用被执行的时候系统内的虚拟机或者，会去解读里面的字节码并且执行。把众多包编译成文件是打包应用不可或缺的一步。
看到这里有人可能会想不对啊，这一步只将包打成文件，那之前的文件生成文件难道不是在这一步做吗？没错，这里用的包一般是由其他的生成完成后再拷贝过来的。本文后面的部分会涉及到怎么使用的并且生成必要的文件。
● 文件夹的文件则是可以动态的被系统加载的库文件，一般是由撰写而成然后编译成的二进制文件。要注意的是，由于实际执行这些二进制库的的架构不一样，所以同样的\代码一般会针对不同的架构生成几分不同的文件。这就是为什么文件夹里面通常都有、、等几个固定的文件夹，而且里面的文件也都是有相同的命名方式。虚拟机在加载这些动态库的时候会根据当前的架构来选择对应的文件。有时候这些文件是可以在不同的架构上执行的，只是在不对应的架构上执行速度会慢一些，所以当追求速度的时候可以给针对每个架构输出对应的文件，当追求包体大小的时候输出一个的文件就可以了。
● 文件夹，这个里面的东西最简单了，在打包的时候，这些文件里面的内容会被原封不动的被拷贝到根目录下的文件夹。这个文件夹有几个特性。
√ 里面的文件基本不会被的打包工具修改，应用里面要用的时候可以读出来。√ 打出包以后，这个文件夹是只读的，不能修改。√ 读取这个文件夹里面的内容的时候要通过特定的 来读取，参考。√ 基于上述两点，在中，要读取这部分内容要通过来进行加载。
除了内的所有文件夹里面的文件会连同目录下的文件一起被放到根目录下的文件夹。
● 文件夹里面一般放的是文件以及一些图片素材文件。文件一般来说有以下几种：
√ 布局文件，被放在中以开头的文件夹中，文件里描述的一般都是原生界面的布局信息。由于游戏的显示是直接通过指令来完成的，所以我们一般不会涉及到这些文件。√ 字符串定义文件，一般被放到文件夹下，这个里面可以定义一些字符串在里面，方便程序做国际化还有本地化用。当然有时候被放到里面的还有其他会引用到的字符串，一般常见的是的名称。√ 动画文件，一般定义的是原生界面元素的动画，对于游戏，我们一般也不会涉及他。√ 图片资源，一般放在以为开头的文件夹内。这些文件夹的后缀一般会根据手机的像素密度来来进行区分，这样我们可以往这些文件夹内放入对应像素密度的图片资源。
例如后缀为的文件夹里面的图片的尺寸一般来说会是整个系列里面最小的，因为这个文件夹的内容会被放到像素密度最低的那些手机上运行。而一般或者甚至的手机在读取图片的时候会从后缀为的文件夹里面去读，这样才可以保证应用内的图像清晰。图片资源在打包过程中会被放到的文件夹内的对应目录。
√ 还有其他一些常见的文件，这里就不一一列举了。
文件夹下的文件在被打包的时候会被转换成一种读取效率更高的一种特殊格式也是二进制的格式，命名的时候还是以为结尾被放到包里面的文件夹下，其目录结构会跟打包之前的目录结构相对应。除了转换之外，的打包工具还会把文件夹下的资源文件跟代码静态引用到的资源文件的映射给建立起来，放到根目录的文件。这一步可以确保安卓应用启动的时候可以加载出正确的界面，是打包应用不可或缺的一步。
● ，这份文件太重要了，这是一份给系统读取的指引，在系统安装、启动应用的时候，他会首先来读取这个文件的内容，分析出这个应用分别使用了那些基本的元素，以及应该从文件内读取哪一段代码来使用又或者是应该往桌面上放哪个图标，这个应用能不能被拿来等等。在后面的部分会有详细解释。打包工具在处理项目里面的文件时会将所有文件的内容合并到一起，也就是说主项目引用到的库项目里面如果也有文件，都会被合并到一起。这样就不需要手动复制粘贴。需要说明的是，这份文件在打包程序的时候是必不可少的，但是在打包的时候，他会先检查目录下有没有这份文件，如果没有就会用一个自带的来代替。此外，还会自动检查项目中里面的某些信息是不是默认值，如果是的话，会拿项目中的值来进行替换。例如，游戏的名称以及图标等。
● ，这份文件一般只有在库项目里面能看得到，里面的内容极少，就只有一句话=。但是少了这份文件的打包工具就不会认为这个文件夹里面是个的库项目，从而在打包的时候整个文件夹会被忽略。这有时候不会影响到打包的流程，打包过程中也不会报错，但是打出的包缺少资源或者代码，一跑就崩溃。关于这份文件，其实在的官方文档上并没有详细的描述因为他实际上是项目的基础知识，导致很多刚刚接触开发的开发者在这里栽坑。曾经有个很早就开始用做游戏的老前辈告诉我要搞定中的库依赖的做法是用打开文件夹，把里面的所有的项目依赖处理好就行了。殊不知这样将项目跟项目耦合在一起的做法是不太合理的，会造成项目开启的时候缓慢。
● 其他文件夹例如以及在生成这一步一般不会涉及到，这里不展开。看到了上述介绍的打包的基础知识我们知道了往目录下放什么样的文件会对包产生什么样的影响。但是实际上上述的内容只是着重的讲了是怎么打包，所以接下来会简述一下打包这个步骤到底是怎么完成的。
提供了一个叫做的工具，这个工具的全称是   ，这个工具完成了上述大部分的对资源文件处理的工作，而则是通过对提供的工具链  的一系列调用从而完成打包的操作。这里感觉有点像我们写了个脚本，这个脚本按照顺序调用提供的工具一样。在一些常见的 里面，这样的“脚本”往往是一个完整的构建系统。最早的 是，他的构建系统是，是基于配置的构建系统。后来团队推出了专用的—— 这个在文章后面会有详述，他的构建系统则是换成了，从基于的配置一下子升级到了语言   的层级，给使用 的人带来更多的弹性。
写到这里我想很多人都清楚了要怎么把的插件放到里面并且打包到里面。这时候应该有人会说，光会放这些文件不够啊，我还需要知道自己怎么写的代码并且输出相应的插件给使用啊。
本文接下来的内容将会一步一步描述怎么写代码并且输出库文件给。
二、开发基础以及导入到
一开始你的第一个程序
安装完 并且配置好代理以后我们就可以打开它，在弹出的框中选择“    ”。

在接下来弹出的界面里面输入应用名称，公司域名这个其实不怎么重要以包名 ，其中我认为最重要的是包名，毕竟看一个应用的包名可以看得出一个开发者的逼格如何。。。

接下来选择要开发什么类型的，这里勾上  就可以了。的选择一般来说根据项目的需要，最低一般不低于   ，这也是能接受的最低。如果有些插件不能运行在这么低的 环境下的话可以酌情考虑提升到   ，这个等级的一般也是可以兼容绝大多数近年的机器。

因为我们要输出的内容是给用的，这里可以先选择不带有就是承载游戏画面的基础部件，后续用到再说。

点击以后 就会开始初始化当前的这个项目。初始化会需要一段时间，因为有可能会去下载一些必要的框架或者更新工具的版本。初始化完成以后到左边按照图里面的步骤点开就可以看到整个项目目录树的情况。

通过上图我们可以知道，一个 的项目可以由许多小的模块组成，这些模块可以是带有的应用类模块，也可以是不带有的库模块等等。这些小的模块之间可以有引用关系。我们可以把一些完成基础功能或者容易被复用的模块单独拆出来。
如果要新建一个模块我们可以在上图的列表中点右键选择 ，在弹出的界面中我们可以选择要新建什么样的模块，或者从导入旧的项目也可以。一般来说给游戏开发插件最常用的就是库模块。同样的，在接下来弹出的窗口中填写好模块名称、包名以及最低运行的。简单的看一下项目的目录结构。如下图所示：

● 目录跟本文第一部分介绍的目录的功用是一样的，把依赖到的库放在这里面就可以了。● 目录也是跟本文第一部分介绍的目录的功能和结构是一样的，把对应资源放进去就可以了。● 接下来是代码所在的目录，这个目录有点特殊，他的子路径跟文件里面定义的包名 要对应的上。● 也是跟第一部分介绍的的功能是一样的。● 文件夹是 动态生成的，打出的包应用模块或者包库模块会被放到这里面的文件夹。需要注意的是这个文件夹不应该被放提交到里面，要不然会造成项目成员之间的冲突，切记。● 以及是做单元测试用的，本文不涉及。
至此，我们就可以开始动手写代码了，这里我们写一个可以弹出的提示的来替换掉默认的。
简述一下跟的关系：在系统中，打开一个应用，就是开启该应用指定的启动。里面有个默认的，他的作用就是在系统启动应用的时候加载的，这个就是就相当于是应用的“播放器”，他会执行我们在项目中创作的内容，并且通过指令渲染到指定的中，而则是被置于里面的一个特殊的。
首先，我们在 中找到如上图所示，然后点击右键，选择新建 。

在弹出的窗口中给你的取个符合代码规范的名字，然后再想个合理的包名当然，也可以直接用默认项目的包名也可以。可以参考下图的配置：

其中的  ，我们在制作给游戏用的是不需要勾上的。 勾上以后 会帮你在当前模块的中声明本是应用的入口之一。作为一个库项目我们这边其实也不需要这个选项。点击之后 就会帮我们在指定目录下创建一个很简单的。里面的内容如下：

需要注意的是这只是一个最基础的 ，他还不会去加载我们的出来，所以我们要让他继承自的而不是默认的。为此，我们要先将相应的包引入到我们的模块当中。首先找到的安装目录，然后找到以下子目录\\\\\\\\里面的，这个就是被打包成包的默认的。我们把这个包复制到当前模块的目录下可以把这个包改成你想要的名字，便于管理。这个包的源码在\\\\\\\这个目录下。感兴趣的同学可以翻阅一下源码，就可以理解播放器的加载机制。
接下来，我们可以在 左边的 中找到当前的模块以后点击右键，选择“ ”或者直接按。在弹出的窗口中我们选到最右边的页签“”，然后选择右边绿色的加号。

从项目的文件夹中找到刚刚导入的包，点击即可。接下来有一个比较关键的步骤就是，我们改变这个包的属性，因为默认的属性是会将该包里面的内容跟本模块里面代码合并到一起。这在之后打包这个模块的包的时候会报错，因为里面内置了刚刚这个包。所以我们可以参考下图把这个包的设置成。

然后删除上述列表的第一行，因为他会把所有文件夹下的包都打包到一起。跟我们刚刚做完的设置会有冲突。
搞定了这步骤以后我们就可以回到刚刚新创建出来的把他的父类改成，同时别忘记引用一下相应的，改完之后的代码是这样的：

到这一步，如果我们的如果能被运行的话，他应该能够借助他的父类里面的代码来运行。接下来，我们来给这个添加一方法，当这个方法被调用的时候会展示一个系统默认的提示。

看得出来，里面最核心的一个方法其实就只是调用里面的组件而已，没啥好解释的。相反，是外面的是值得大家注意的，在编程中，所有涉及到对的操作必须要放在线程里面来做，否则会造成其他线程修改线程里面的数据然后崩溃。由于我们写的这个方法最后会被那边调用，而来自的调用可能不是线程，所以我们要给他做适当的保护。
在中有很多种调度方法可以把某段代码放到线程里面来跑。上面这段代码的的写法是最简便的一种写法。如果遇到比较复杂的逻辑可以考虑使用或者来调度线程，感兴趣的同学可以上网查一下。
二导入到并且编译
完成的代码编写之后就可以输出这个模块到项目中去。在 中选择   或者是在左边的项目视图中选中要导出的模块然后选择   。选择完了之后就可以看到下面有个的进度条，待进度条完成了以后我们就可以到该模块的目录下去找输出的文件。打开这个文件夹，可以看到有个的文件。这个就是该模块所编译出来的结果，如果你用解压缩软件去解压缩它，你会发现他几乎就是一个完整的工程。根据本文第一部分所说的内容，我们只要在工程中的目录下新建一个文件夹，然后把这个文件解压缩以后整个丢进去，再手写一个名字叫，内容是=的文件放到新建的文件夹里面就可以了。
胜利在望，我们接下来只要把工程里面的文件的入口从默认的的改成我们刚刚写的这个就可以了。需要注意的是，如果是旧的工程，可能已经有人写过相关的文件放在了目录下，但是如果是全新的项目的话，就没有这份文件了。在打包的时候，如果发现目录下没有这份文件，他会复制一份默认的文件并且修改其中跟项目有关的内容。这里我们可以从的安装目录的\\\\文件夹内找到这份文件，把它复制一份到工程的目录下。接下来就是修改里面的内容。

这里解释一下这份文件里面的一些关键内容。
● =这里的内容如果放着不动，打包的时候会将其修改为 的 。● 以及这两部分的内容则在打包时会根据 里面的以及  的内容来进行修改。● 以及这两个对应的是应用的图标以及应用名称。如果不改的话，也会自动根据 里面的内容来进行修改。● =这个在打包的时候也会自动根据 里面的 选项自动进行修改。● 里面的，这个只的是该需要运行的哪个的的类。如果不修改，加载的就是默认的类。这篇文章需要把默认的改成刚刚我们的实现，所以，我们把刚刚写好的那个的完整名称写上去包括包名还有类名。● 里面的，这个是在桌面上图标下面写的那一行文字，也是应用的名称。不修改的话会帮你维护。● 的这一行的值是，值就是这个对应的内容。可以根据需要自定义多个，但是值不能重复，上面代码里面的应该是写给看的，让知道他自己是运行在这个上。
这里我们基本上只要修改里面的这一项。修改完成后，我们就可以通过自带功能来出包了。出包之前请检查一下 里面的 ，不能留默认的包名在这里，会造成编译失败。编译过程中，可能会出现一些错误，下面罗列几个常见的错误，可以尝试解决：

合并文件出错，一般来说是在合并所有的文件的时候出的错，常见的有重复定义了、里面的最低写错了。模块的最低不可低于项目的最低。

文件错误，当你的项目中不小心存在了一个以上的相同的文件，就会出这个错误，把重复的删掉，只留一个就好了。

找不到 里面的工具，这个一般来讲是自己的，一般不能兼容最新的 的工具，所以要手动降级才行。


除了上述这些之外，在打包项目的过程中还会出现这些那些的错误，大家看到以后不要慌张，会报错总是好的，而且一般的错误你把错误信息贴在万能的上，都能找到解决方案。
对代码的调用
文章到这里为止，说清楚了怎么把这边写成的插件打包到的项目中去。但其实并没有涉及到中怎么调用刚刚写好在的中的代码。这一部对于一个开发来说其实非常简单，只要以提供的还有来做为中介就可以在和中互传数据。这两个类的调用给人一种通过反射来调用代码的感觉。只要你能通过包名和类名拿到某个对象，就可以直接通过成员变量名称或者方法名称直接调用到那边的代码。举个例子，假如要在中调用刚刚我们写的那个类的类的话我们需要在中准备以下代码。

简单介绍一下这段代码的几个关键点：

通过可以很方便的拿到当前的对象实例。

对对象实例的方法的调用实际上很简单，只要调用就可以了。

注意用宏来区隔代码。_  _这个推荐的写法，如果不过滤掉_会在运行的时候报错。

推荐在出还有的地方用来进行保护，确保执行结束后会自动回收相应的代码。


其他的部分在这篇文章里面我们不展开。
本文到这里差不多把 的开发过程描述了一遍，如果有不清楚，欢迎留言。

针对手游的性能优化，腾讯平台的工具提供了基本所有相关指标的检测，为手游进行最高效和准确的测试服务，不断改善玩家的体验。
目前功能还在免费开放中。，欢迎点击链接： 使用。
如果对使用当中有任何疑问，欢迎联系腾讯企业：作者：闫燕飞

接上篇：《高性能消息队列  核心原理介绍上》
    技术原理
设计目的就是为业界提供一套高性能、高可靠的消息中间件，故下面将会从高性能、高可靠几个方面对的技术原理进行剖析。
    性能
    高性能的关键点

格式简单而且采用二进制编码，尤为关键的地方是和后端一致，且最终存储在文件中的格式也是一致。故生产消费时没有任何编解码操作，并且可以采用做到零拷贝进一步利用操作系统的高级特性提供性能。

批量处理，批处理是一种常用的用于提高性能的方式。对于而言批处理既减少了网络传输的开销也提高了网络传输效率，同样采用批量方式提高了数据块的大小也会提高磁盘写入效率。

基于磁盘大文件的顺序读写。设计时就充分利用了磁盘的特性，采用大文件大块顺序读写方式，极大的提高了系统的吞吐量。

对进行分区，并尽量将不同的分配到不同的，从而实现水平扩展，并且支持在线调整数量，理论上可以支持无线吞吐量，但受限于的容量和性能，个数和都会有上限，但该上限非常大以至于可以认为没有上限。 

端到端的数据压缩，并且支持批量压缩，极大的降低网络负载和磁盘负载。更妙的是端接收到消息后，可以不直接解压直接将消息以压缩的形式直接持久化到磁盘注这边其实还是会解压数据，然后对数据进行校验如果数据合法才会写入。而且针对消费消息来说，这些已经被压缩的消息，也会直接发给消费者，由消费端自己负责解压缩，不仅降低了的网络带宽，而且将解压的计算也分到消费者端，更近一步降低了的资源消耗。

简单高效的传输协议及序列化方式，协议仅采用了单字节对齐，网络字节序的二进制格式进行通信，协议编解码效率极高，资源消耗少。

充分利用系统的 ，而不采用应用内存缓存，如果采用应用内存不仅会耗费浪费更多的内存，而且会增加的负担注采用编写但也是需要运行在上，故这里有及之说，的实现者充分做到了取长补短。而使用 又有如下好处：     会将连续的小块写组装成大块的物理写从而提高性能     会尝试将一些写操作进行重新排序，从而减少磁盘头的移动时间    读操作可以直接在 中进行。如果生产消费速度相当，甚至不需要经过物理磁盘，直接通过 交换数据

支持多 ，的配置项允许配置多个目录。如果机器上还有多个 ，可以将不同的挂载到不同的目录，然后将这些目录配置到里， 会尽可能的将不同的分配到不同的从而充分利用了多优势。注：个人愚见，觉得这个功能其实不是十分有用，如果要追求高性能不如将多块磁盘做一下，更方便调度，并且使得拥有更好的伸缩性能，当然有些场景无法做使用该方式也是能够利用到多块磁盘的能力。


    格式详解
注：为支持不同的业务形态当前共存在个版本格式的
    版本包括及其之前的版本采用     版本新定义的格式，较增加了一个的字段     版本新定义的格式之前的编码格式有较大的改动，而且该版本于年月底才发布故不再本文讨论范围
、 格式详解
采用一字节对齐，且使用网络字节序大端



字段
大小
含义






消息在中的，可以理解为消息，从零开始自增




消息大小，不包含所占的字节空间，和本身的所占的字节空间，可以理解为剩下的消息大小




消息校验码，采用方式进行校验，计算时从含开始计算




消息版本号，用于区分不同版本的消息格式，正是通过该字段实现了消息格式的扩展和向前兼容




消息属性，主要用于标识消息的属性，不同版本情况下意义可能不一样，针对版本其含义如下                           


 

用于表明的大小不包含本身所占用的空间，需要注意的是对该字段的表明的意义不一样表示不存在 表示存在但的大小为 表示的长度



 
存储的内容，其大小由 字段表示。用户可以自己指定， 进行日志也会有用到该字段


 

用于表明的大小不包含本身所占用的空间



 
存储的内容，其大小由 字段表示



为了方便查看用的伪代码可以如下表示消息的格式
 
 
、  格式详解



字段
大小
含义






消息在中的，可以理解为消息，从零开始自增




消息大小，不包含所占的字节空间，和本身的所占的字节空间，可以理解为剩下的消息大小




消息校验码，采用方式进行校验，计算时从含开始计算




消息版本号，用于区分不同版本的消息格式，正是通过该字段实现了消息格式的扩展和向前兼容




消息属性，主要用于标识消息的属性，不同版本情况下意义可能不一样，针对版本其含义如下                时间戳类型 消息产生的时间由用户端指定 消息添加到 的时间，由指定     




消息生产的时间或者消息被添加到的时间，具体看的值。单位


 

用于表明的大小不包含本身所占用的空间，需要注意的是对该字段的表明的意义不一样表示不存在 表示存在但的大小为 表示的长度



 
存储的内容，其大小由 字段表示。用户可以自己指定， 进行日志也会有用到该字段


 

用于表明的大小不包含本身所占用的空间



 
存储的内容，其大小由 字段表示



可以看出比版本的消息仅多了一个字段用于表明消息的生产或添加到日志的时间，方便用户通过指定时间去获取消息。为了方便查看用的伪代码可以如下表示消息的格式
 
、批量消息及压缩详解
 
通过上图，可以看出通过消息嵌套要求消息仅能嵌套一层的方式，实现了消息的批量压缩，既保证了格式的一致，也实现了批量消息压缩用以提高整体压缩率。而不是采用单个消息压缩。较友好的实现了批量压缩。
、格式小结
    整个头部非常紧凑，格式的仅仅字节 格式的也只有字节。既节省了带宽也节省了存储。    格式定义良好，扩展方便，编码解码简单。对于客户端和后端的存储采用同一套编码方式，这样就导致了不用来回编解码和格式转换，节省了及客户端的资源，让整个消息流转及存储更加的高效。    包含了校验码，用于进行数据完整性校验，提高了数据的可靠性    可以非常简单的不改变原有格式的情况下，通过嵌套方式实现消息批量压缩，更近一步提高资源利用率。而且仅仅只用解压对消息进行一些必要的校验，而不用再次压缩，效率高。最重要的是由于整个消息格式在客户端和都是一致的，消费时不用做任何解压缩和压缩操作，直接将消息传递个消费者，效率奇高。
    存储方式详解
、文件存储机制文件存储中，同一有不同的每个为一个目录，的命名规则为名称  有序序号从零开始。具体可以参考下图。
 

注：文件是版本及之后版本才加入的一个新的索引文件主要是为了通过时间方式去查找相应的消息，实现类似于。如果要通过查找消息在的位置，其实中存的是 ，还需要在经过文件去定位消息具体在中的偏移。

、在中以目录形式存在，每个物理上由多个文件分片和与其一一对应的文件组成。每个大小类似默认配置为。的命名方式是使用其第一条消息的格式化生成，这样通过名称可以很容易查看到消息的开始，同时通过相邻的也很容易计算出中包含的消息个数。将分成，则非常方便快速删除过期的分片。
、文件采用稀疏存储用于节省空间，主要用于读取消息时快速定位所需要的消息位置。
、生产消息消息以方式添加到最新的尾部，算法复杂度为不会受到现有数据总量的影响，当写入的数据大小或消息条数达到配置的阈值则主动强制刷盘，用于保证系统崩溃时，消息的丢失量在可以接受的范围。同时当写入一定的数据后生成一条索引信息添加到文件末尾。当大小超过配置则滚动生成一个新的。可以看到消息都是顺序追加写，且大块刷，可以很好的利用系统的调度和磁盘顺序写的能力达到较高的吞吐量。
、消费消息当消费者拉取消息时会指定这时候先从 定位到所需的的文件。由于文件采用稀疏索引方式，文件较小默认配置为，故采用形式直接加载到内存，然后采用二分法查找到与所需的消息相同或相邻的位置，最后再去文件中读取到真正的数据。可以看到消费消息时，整个过程最耗时的地方就在从文件中查找时间复杂度，然文件比较小，个数也很少，基本可以全部缓存在 加之消费者基本都是顺序消费会进一步提高整个命中率，故也能提供非常高的消费性能。
、删除消息的根据应用场景不同提供两种删除方式和。

    方式使用方式的删除会保证同一个只保留最新的一条消息其实这样看来这种方式更加类似于一个系统。版本之后含可以使用__这个特殊的内置进行存储 中每个的消费状态，而这个就采用的是方式进行日志删除。该方式要求的不能为空，且比较消耗系统资源，一般用户的，非常不建议使用该方式进行日志删除。

    方式 采用的默认清除日志的方式，按照所设的最大保留时间，或所设定的最大保留大小以为最小单位进行删除。从最老的开始进行删除。由于是整个文件分片的删除，效率非常高。


    分配策略

单机性能很强，但总会有上限，之所以能够无限平行扩展，在性能上碾压其他消息中间件，都是基于其概念。由于都是以为最小服务单位，对外提供服务，当增加就有可能分配到更多的为其服务，进而提高性能，当然这一切前提都是需要有个好的均衡算法让一个的用分配到更多的为其服务。故能否均匀的分配到 集群，直接影响到扩展性和性能。

具体算法分配策略的目标有两个：使的副本能够均匀的分配至各个 用于做到负载均衡和应用更多的能力使同一个的不同副本，分配到不同的，进一步提高可用性。当然这个条件也是限制副本数不能大于的原因，因为同一个的不同副本分配到相同的毫无意义。


算法步骤：

将所有活着的，按照 进行排序
随机一个起始位置，选取一个最开始分配的这里命名为，主要用于防止如果个数少且副本为，如果不随机采用从头开始很容易导致的分配聚集在小的上导致分配不均匀
随机一个小于个数的随机数作为，该值大小需保证为   – 
将的第一副本分配给
根据计算第=个副本与第一个的偏移量，将其分配至相应
将移至下一个
如果以被轮询完一次，则增加主要为了可以更加均匀的分配副本。然后分配下一个从步骤继续开始。

算法代码从工具截取采用编写不太好看可以对照上面的步骤进行阅读：
 
注：分配算法虽然很重要，但并不是在端实现，而是在 工具包中实现。由相关工具分配好，然后写入的一个管理节点，最后触发 事件，根据相应的事件，直接从拉取到已经分配好的结果，仅仅只用选出然后通知相关而已。
    可靠性
的可靠性及可用性，都源自其版本加入的概念以及选举算法和消息机制 机制通过和来保证共同保证。只有后的消息才能被消费，不让消费者消费到未确认的消息从而提高数据的一致性。最后再配合消息生产确认方式及刷盘策略，进而达到用户需要的可靠性及可用性。
    生产确认
当向发送数据时，可以通过设置参数通过确认方式来配合后端提高可靠性级别。其主要配置项如下




含义





默认配置，仅当成功收到消息并写入日志后，就返回成功给。如果宕机，则有可能丢失数据。



无需等待来自的确认而继续发送下一批消息。该配置下，数据传输效率最高，但可靠性最低



需要等待中达到配置的该参数可以在级别或级别配置，默认值为需要注意只有=该配置才生效个都存储了该消息后才回复，可靠性最高。



意义同



    复制原理和同步方式
、消息在文件中的状态
 
： 缩写指的是能够消费到此的最大位置，取对应的的最小值为，另外每个都有 和各自负责维护自己的状态。：  的缩写，表示每个最后一条的位置。
、消息复制及和流转过程




通过该流转过程可见， 的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的都复制完，这条消息才会被，这种复制方式极大的影响了吞吐率。而异步复制方式下，异步的从复制数据，数据只要被写入就被认为已经，这种情况下如果都还没有复制完，落后于时，突然宕机，则会丢失数据。而使用的方式很好的均衡了数据可靠性及吞吐率。
    选举
选举的常用算法非常多，比如的、以及 等，这些算法其实都是采用少数服从多数的方式。在这种模式下，如果有个副本，那么在之前必须保证有  个复制完消息，同时为了保证能正确的选举出新的，失败的副本个数不能超过。这种方式有个很大的优势就是系统的延迟取决于最快的大多数机器，而且数据一致性及可靠性高。当然这种方式也有些劣势就是所能容忍的失败的个数较少，故在生产环境下为了保证较高的容错率，必须要有大量的副本，而大量的副本又会在大数据量下导致性能急剧下降。而所使用的选举算法更像是微软的算法。
在中为每一个动态的维护了一个，这个里的所有都跟上了，里的成员会优先选为=。在这种模式下，对于个副本，一个 能在保证不丢失已经消息的前提下容忍个副本的失败，在大多数使用场景下，这种模式是十分有利的。事实上，为了容忍个副本的失败，“少数服从多数”的方式和在前需要等待的副本数量是一样的，但是需要的总的副本的个数几乎是“少数服从多数”的方式的一半。在中至少有一个时，可以确保已经的数据不丢失，但如果某一个的所有都挂了，就无法保证数据不丢失了。这种情况下有两种可行的方案默认选择第二种：
等待中任意一个“活”过来，并且选它作为选择第一个“活”过来的并不一定是在中作为第一种方案会提高可用性，第二种方案则是提高数据可靠性。两种方案，用户可以根据业务形态进行相关的定制化。
    消息传递语义
常用的消息传输语义

   消息可能会丢失，但绝不会重复传输
   消息绝不丢失，但可能会重复传输
  每条消息绝不丢失而且仅被传输一次，很多时候这个是用户所需要的。

可以看出，从上到下实现的难度一次递增，当前其实可以支持到  但这个也基本上要配置成全同步才能做到比如必须配置所有都同步，并且每条消息都同步刷盘，且生产者配置=，通过这种方式可以达到同步多写进而做到数据不丢失，但配置成这种方式又会导致性能急剧下降，完全违背了标榜的高吞吐。 注 版本添加了 消息传输支持，但该版本年月底才发布，这里暂不做分析。
    优劣势
    优势

扩展性高，可以做到平行扩展。并且集群扩展时，可以做到对用户透明。
高性能，的性能远超过传统的 等消息队列。
高可用性，通过副本方式和的选举算法，使得有相当高的可用性。
社区活跃度高，当前很多大数据组件如  等等都集成了对的支持。

    劣势

依赖组件众多，导致部署的设备多，运维量大，难以维护。如果简单的用让以黑盒的方式进行运行，当然只需要部署 和即可。但如果想对运行的状态有所了解则需要部署上相关的监控软件、鉴权中心等等。虽然相关的软都有开源的实现，但学习成本高搭建部署也麻烦。
安全防护功能有限，鉴权依赖于第三方搭建组件。最初整个都没有权限相关的控制也没有用户的概念，最后为了支持，硬生生的在正常的请求前加上了相关的鉴权，但这又导致用户需要搭建相应的鉴权中心，工作量大且复杂。不利于产品化。
隔离性差，无法做到分布式资源管理及速度控制。
兼容性差，消息格式不断更改，处理逻辑不断更改，导致兼容性非常差，很多版本竟然不能保证向前兼容。
配置多，仅仅端都有一百多项配置，虽然系统默认的配置能达到不错的效果，但如果想贴合业务进行配置，则这么多的配置会让人望而生畏。

    介绍
鉴于存在以上几个无法调和的劣势，我们选择开发。
    总体架构
 

借鉴了的实现，采用进行存储和选举
对集群进行了垂直化划分，通过限制每个集群的大小，从而不仅可以减少风险而且可以更大规模的部署更多的集群，做到无限的水平扩展能力。
通过与合作，实现分布式动态流量分配。更好的隔离和平衡用户在不同节点上的流量和容量分配。

    鉴权
是以实例实例包含吞吐量、容量两个维度的形式对外提供服务，不同用户、实例间通过网络策略进行隔离，实例内部支持按照白名单鉴权，满足个性化需求。

实例： 不同租户通过不同实例访问服务，开通网络策略保证租户所在网络只能访问到自己实例。
：通过多端口提供服务，不同端口服务不同的实例，达到资源隔离。根据端口鉴权实例是否有生产消费某个的权限。还提供更细力度的鉴权，同一实例不同的鉴权，通过客户端白名单方式鉴权。
同一个上存在的不同实例可能名称一样，为解决这个问题，采用名字映射生成唯一的，当然用户对于这个是透明无感知的。

    资源隔离
由于同一个实例会分配多台为其服务，以便达到更高的可用性。这种情况下，就需要有一个分布式流量控制程序，对实例的流量进行相关的控制，防止实例使用超过允诺的流量。当前的分布式流量控制由完成，会定期上报当前流量数据到，进行汇总后，采用下面的算法进行流量分配。算法具体步骤如下：
如果实例的消息存储容量已经达到最大，则堵住生产放行消费根据实例所分配的上包含的数，计算出每个应该分配的流量，这里记为将实例当前在每个产生的流量与进行比较，如果所有当前的量都小于，则按照初始量进行分配。计算出每个的流量，计算出每个所占的流量比率记为找出最大最小流量，并计算最大最小流量，分别记为 如果   = 则根据步骤中计算出的比率进行分配如果     则流量最大的按照进行分配 其他的按照     进行分配，加上的量是为了给流量小的节点一些余量好进行流量增长，用以达到再平衡
    优化
提到大家第一反应应该都是高性能。的确做到了非常高的性能，被业内很多大数据选作中间存储或管道，便是对其高性能的认可。但追求性能的同样也对其做了一些优化，而且也取得了一定的效果。
测试场景：个 个 单机测试生产性能机型：      核 、内存、网卡

    总结
消息中间通常分为高可靠和高性能两种版本。是一款高性能消息中间，主要用于满足对性能要求极高的应用场景如网站活动追踪、运营监控、日志聚合、流式处理、事件追踪等等，并且兼容现有的协议使用户零成本迁入。当然用户如果有高可靠的要求，我们自研的则是一款金融级高可靠分布式消息中间件，其通过保证了消息的可靠不丢失，同时性能和可用性相比竞品也有显著的提高。致我挚爱的容器爱好者们：
我来自一年四季热情似火的深圳，大气爽朗；
我来自传说中福利超好的鹅厂，自带光环；
我是千千万万的程序猿之一，天生自带产品经理基因；
没错，我就是来自腾讯云的那一个正给透露给你如何获得藏宝图的神秘容器使者！
 
由知名媒体主办的全球运维技术大会即将于年月日在上海光大会展中心酒店开启。腾讯云受邀参会，并将以演讲和展位的方式，向众多技术极客们，展示腾讯云容器服务和无服务器云函数产品以及相关案例，并将现场展示最新架构和原理和实操演示环境。
腾讯云容器服务提供以容器为核心的解决方案，解决用户开发、测试及运维过程中的问题，降低企业成本，提升效率，完全兼容原生全能力， 扩展了腾讯云的、、等插件，以腾讯云私有网络为基础，实现高可靠、高性能的网络方案。华尔街见闻、小红书、三一重工、、上海掌金等各类大型企业业务模块已经在腾讯云容器平台上稳定运行，容器平台建设成功落地。
目前，腾讯云是国内最大的基于提供容器服务的公有云服务商，也是拥有国内最大规模集群的企业。
现场主题演讲：腾讯云多集群高可用运维实践 容器编排与管理专场
腾讯云基于的公有云容器服务会为每个租户提供单独的集群，现在腾讯云上已经有数百个集群持续增长中，数百个分属不同租户的集群其运维难度远大于有数百个节点的单一集群。此次演讲主要内容如下：

腾讯云基于的容器服务架构简介
运维数百个不同租户的集群有哪些难点
业界的多集群运维方案有哪些？
腾讯云是如何通过 集群化部署和多维度监控来解决这些问题的

腾讯云容器团队首次对外亮相，与你相约上海全球运维技术大会，更多惊喜等你来！藏宝线路图已经备好，就等你来挖宝！
寻宝时间：年月日寻宝地点：上海光大会展中心酒店号展位 腾讯云寻宝线索：企鹅宝宝
 
如果实在好奇，想抢先获得更多一手腾讯云容器资讯的同学们，小编就忍痛给个提示好了，看下图二维码。据新华社消息，腾讯公司  日在新加坡举行的媒体发布会上宣布，腾讯云全球化布局全面提速，今年将新增５大海外数据中心，目的是为“走出去”的中资企业和海外企业拓展全球业务提供优质云服务。
新增的５大数据中心包括美国硅谷、德国法兰克福、韩国首尔、印度孟买和俄罗斯莫斯科数据中心。此前，腾讯云已经在多伦多、新加坡等地建立数据中心。
近半年，腾讯云扩建了北京、上海、广州等地的数据中心，连同分布在亚太、欧洲、北美和南美地区的  大海外合作数据节点，目前开放的全球服务节点已达  个，腾讯云也由此成为全球云计算基础设施最广泛的中国互联网云服务商。
腾讯云副总裁曾佳欣表示，经过对海外市场多年耕耘，腾讯云已经在全球市场建立了自身的差异化优势。 这个库已经为我们提供了  分布式的队列、调度器、去重等功能，其  地址为：。
本节我们来分析一下它的源码，深入了解一下利用  怎样实现  分布式。
 获取源码
首先我们可以把源码  下来，执行如下命令：
  
核心源码在 _ 目录下。
 爬取队列
首先我们从爬取队列入手，看下它的具体实现，源码文件为 ，在这里它有三个队列的实现，首先它实现了一个父类 ，提供一些基本方法和属性：
 
       
     ____    =
           
             = 
           
                   
                             
           
                    
                             
         = 
         = 
         =   { }
         = 

     __ 
         = __ 
         

     __ _
         = _
         __ 

     ____
             
         

      
          
         

      =
          
         

     
         
        

首先看一下 __ 和 __ 方法，因为我们需要把一 个 对象存储到数据库中，但数据库无法直接存储对象，所以需要将  序列化转成字符串再存储，而这两个方法就分别是序列化和反序列化的操作，利用  库来实现，一般在调用  将  存入数据库时会调用 __ 方法进行序列化，在调用  取出  的时候会调用 __ 进行反序列化。
在父类中 、 和  方法都是未实现的，会直接抛出 ，因此这个类是不能直接被使用的，所以必须要实现一个子类来重写这三个方法，而不同的子类就会有不同的实现，也就有着不同的功能。
那么接下来就需要定义一些子类来继承  类，并重写这几个方法，那在源码中就有三个子类的实现，它们分别是 、、，我们分别来看下它们的实现原理。
首先是 ：
 
      

     ____
             
         

      
          
         __

      =
          
           
             =  
              
                 = 
        
             = 
         
             __

可以看到这个类继承了类，并重写了 、、 这三个方法，在这三个方法中都是对  对象的操作，而  对象就是一个  连接对象，我们可以直接调用其操作  的方法对数据库进行操作，可以看到这里的操作方法有 、、 等，那这就代表此爬取队列是使用的 的列表，序列化后的  会被存入列表中，就是列表的其中一个元素， 方法是获取列表的长度， 方法中调用了  操作，这代表从列表左侧存入数据， 方法中调用了  操作，这代表从列表右侧取出数据。
所以  在列表中的存取顺序是左侧进、右侧出，所以这是有序的进出，即先进先出，英文叫做    ，也被简称作 ，而此类的名称就叫做。
另外还有一个与之相反的实现类，叫做 ，实现如下：
 
      

     ____
             
         

      
          
         __

      =
          
           
             =  
              
                 = 
        
             = 

         
             __

与  不同的就是它的  方法，在这里使用的是  操作，也就是从左侧出，而  方法依然是使用的  操作，是从左侧入。那么这样达到的效果就是先进后出、后进先出，英文叫做    ，简称为 ，而此类名称就叫做 。同时这个存取方式类似栈的操作，所以其实也可以称作 。
另外在源码中还有一个子类实现，叫做 ，顾名思义，它叫做优先级队列，实现如下：
 
           

     ____
             
         

      
          
         = __
         = 
        _   

      =
        
          
              
        
         = 
        
            
          = 
         
             __

在这里我们可以看到 、、 方法中使用了  对象的 、、 操作，可以知道这里使用的存储结果是有序集合  ，在这个集合中每个元素都可以设置一个分数，那么这个分数就代表优先级。
在  方法里调用了  操作，返回的就是有序集合的大小，也就是爬取队列的长度，在  方法中调用了  操作，就是向集合中添加元素，这里的分数指定成  的优先级的相反数，因为分数低的会排在集合的前面，所以这里高优先级的  就会存在集合的最前面。 方法是首先调用了  操作取出了集合的第一个元素，因为最高优先级的  会存在集合最前面，所以第一个元素就是最高优先级的 ，然后再调用  操作将这个元素删除，这样就完成了取出并删除的操作。
此队列是默认使用的队列，也就是爬取队列默认是使用有序集合来存储的。
 去重过滤
我们在前面说过  中的去重实现就是利用集合这个数据结构，但是在  分布式中去重就需要利用一个共享的集合了，那么在这里使用的就是  中的集合数据结构，我们来看下它的去重类是怎样实现的，源码文件是 ，其内实现了一个  类，实现如下：
 
       
             
    
     = 
     ____   =
           
        
        
          
               
          
                 
           
                
        
         = 
         = 
         = 
         = 

    
     _ 
             
              ````   
        ``_``       
                 
        
        
          
        
        
        
              
        
         = ___
         = _  { }
         = _
          = =

    
     _ 
           
        
        
          
        
        
        
              
        
         _

     _ 
              
        
        
          
        
        
        
        
         = _
         =  
          == 

     _ 
              
        
        
          

        
        
        

        
         _

      =
               
        
        
           
        
        

     
          
        

       
          
        
        
          
          
        
         
             =    
             { } ={ }
         
             =    
                          
                     _    
             { } ={ }
             = 

在这里我们注意到同样实现了一个 _ 方法，和  中的 _ 方法实现极其类似，不过在这里集合使用的是  对象的  操作，也就是集合不再是简单的一个简单数据结构了，在这里直接换成了数据库的存储方式。
鉴别重复的方式还是使用指纹，而指纹的获取同样是使用 _ 方法完成的。获取指纹之后就直接尝试向集合中添加这个指纹，如果添加成功，那么就代表这个指纹原本不存在于集合中，返回值就是 ，而最后的返回结果是判定添加结果是否为 ，如果为 ，那这个判定结果就是 ，也就是不重复，否则判定为重复。
这样我们就成功利用  的集合完成了指纹的记录和重复的验证。
 调度器
 还帮我们实现了一个配合 、  使用的调度器 ，源文件名称是 。在这里指定了一些配置，如 ___ 即是否在爬取开始的时候清空爬取队列，_ 即是否在爬取结束后保持爬取队列不清除，我们可以在  里面自由配置，而此调度器很好的实现了对接。
接下来我们再看下两个核心的存取方法，实现如下：
 _ 
      _  _
         
         
     
        _ =
    
     

 _
    __ = __
     = __
       
        _ =
     

_ 就是调度器向队列中添加 ，在这里做的核心操作就是调用  的  操作，同时还有一些统计和日志操作，_ 就是从队列中取 ，核心操作就是调用  的  操作，那么此时如果队列中还有 ，则会直接取出来，接着爬取，否则当队列为空时，则会重新开始爬取。
 总结
那么到现在为止我们就把三个分布式的问题解决了，总结如下：

爬取队列的实现，在这里提供了三种队列，使用了的列表或有序集合来维护。
去重的实现，使用了  的集合来保存  的指纹来提供重复过滤。
中断后重新爬取的实现，中断后  的队列没有清空，再次启动时调度器的 _ 会从队列中取到下一个 ，继续爬取。

 结语
以上便是  的核心源码解析，另外  中还提供了 、  的实现，不过并不是必须要使用的，如有兴趣可以研究。是一款高性能的内存数据库，本文侧重描述在主从模式下遇到的一些问题以及如何调优，特别是在云环境下遇到的一些特殊问题，至于如何使用以及数据结构等，可以百度，网上有大量的资料。
主结点
在非集群环境的情况下，使用主从模式来保证业务的高可用性，因此在此种模式下，读写都在主机，要保证主机高性能必须在主机上尽量少的操作同时又要兼顾网络导致的主从断链而带来的频繁的，因此针对主机优化要点如下：
关闭主结点
关闭主比较简单，可以通过如下命令进行关闭，在主结点上执行
   
关闭主结点
关闭主上的原因是避免的规则导致的而引起业务波动，是非常消耗性能的，的默认规则为         在此规则下写入量大的情况下会导致主机频繁的而导致性能急剧下降，可以通过命令  关闭主机上因写入而触发的，数据的完整性交给备机完成，即使这样也无法完全杜绝，在从机第一连上来或者从机断开过久的情况下还是会触发
主从同步后数量不一致问题
因为只会在主上进行定期淘汰并命令传播到从机，因此在数量很多而且很多又带有过期时间的情况下，因为淘汰机制问题会导致主从同步后从机的数量和主机的数量不一致过期的不会同步到从机，而最根本原因是主机在在函数中进行淘汰的时候一次默认只会淘汰个，默认值在中 _____      定义，解决该问题的方式一是修改该数量重新编译，而是修改中的属性，加快执行频率
发送缓冲区满导致主从断开频繁问题
为每一个链接的客户端维护了一个发送缓冲区，并限定了大小有软硬之分，当发送缓冲区满后超过了设定的值即会断开该链接从而实现自我保护功能，但是问题也出现，当写入量非常大的时候而该值又设置的不合理会导致主从频繁断连，而且因为写入量巨大新连接上来的从机不能进行部分同步而触发全量同步，因此为了避免该问题可以根据实际的写入数据以及网络情况综合来修改参数，具体修改多大要结合实际写量和网络情况而定，设置方式为：
      
 表示从机链接，普通客户端为，发布订阅客户端为：
复制积压缓冲区
复制积压缓冲区缓存了最近的写命令，在有从机链接的时候创建，该缓冲区大小默认为，改值决定了从机断开在重新链接上来后是全量同步还是部分同步，如果复制偏移量在复制积压缓冲区内为部分同步，小于或者大于复制积压缓冲区那么就行全量同步，可以根据实际情况通过  命令重新设定
节点死活判定
 在高可用系统中，节点的死活检查非常重要，检测逻辑要快速发现问题并迅速切换，检测手段也是多重多样， 检测节点死活采用了进程探测加服务的方式进行，进程探测是为了确认目标进程存在，但是目标进程存在也不一定确认服务可用，所以另加了去指定服务节点的方式。
 在实际使用过程中发现某些节点会奇怪的进行切换，而去看机器的内存、网络、以及都很低，除了某些核在切换的时刻被跑满，然后分析切换节点的发现，用户在那个时间点提交了耗时高达几分钟的查询，因为是单线程处理，因为某一个耗时高的命令而导致了超时导致了切换，优化逻辑就是适当增加的耗时和增加的次数，这个过程中也要有所取舍，即要很快的发现问题，又不能因为高耗时命令而误判进行切换
从结点
从结点主要用来保证数据安全性，并在主结点死掉后快速恢复成主结点并提供服务，在作为从结点的时候需要打开和，并按照一定的时间规则把用户的放入到冷备中心，在提升为主节点后，相关设置要立刻恢复到和主节点一样的配置。

相关推荐 各个版本 集群部署与高可用经过实习过程中，和导师在思维逻辑上的指导，自己再有意识的加以训练，我觉得非常受益。就如这部分的理解，目前就加深了很多。所以说，思维决定行为、行为决定习惯、习惯决定了代码写得好不好啊以前高中数学老师经常说的一句话 ：“  这道题半夜醒来我都会做的 ”，我想他思维挺好。
扯远了，进入正题
一、过载
何为过载？ 简单来说，就是当前负载超过了系统的最大处理能力，如：
系统实际每秒能处理的请求量为个，但实际每秒的请求量却远大于个，可以判定系统过载。
究其原因，我们可以把原因归结为：请求量的上升
那么如何保护？  其实就是对请求量的控制问题
二、 过载保护
依据之前介绍的线程模型进行的分析，首先一个新的请求到达服务端先是建立一个连接，接着直到该连接被释放，期间发生的读写请求都会占用线程池的资源。因此，过载保护就是要：
其一，限定最大连接数，
其二，限定最大能够同时处理的请求量。
三、实现
 限定最大连接数
上一节已经分析过，通过管理器对连接进行管理，因此我们可以考虑在这个管理器上面做文章。仔细一想，管理器上不是可以注册监听器么？这样不就可以通过监听连接来简单实现么： 对创建和释放操作进行计数，同时在系统部署上线之前，预估好系统的处理能力，设定一个系统最大可承载的连接数阈值，一旦连接数到达阈值或是接近阈值，触发拒绝连接。
问题解决，看代码：
     {

        =  

       

       {
         = 
        =  
    }

    
         {
           

          =  {
             {
                       
                
            }
               {
                
            }

            
        }

        
    }

    
         {
           
          =    == _     {
            
        }        
    }

}
 以上就是监听器的事件处理函数实现，建立连接时触发计数器加一，释放连接时触发计数器减一，一旦计数器到达最大阈值限定，直接关闭新的连接
其中，连接的释放，每个在配置中会有一个会话超时时间，管理器的另一大作用就是不断地轮询地检查每个连接距离上次的操作发生事件时间是否超时，若超时则回收该连接，代码如下：
    
{
       

     {
        _     

          = 

         
        {
                                 
            {
                    
                {
                     = 
                    会话超时
                          {
                          =              
                                           
                          =  {
                            
                        }  {
                            _   
                        }
                        
                         
                    }
                }

                
            }
              
            {
            }
        }    
    }  
     = 
}

 更新会话的上次操作时间实现，即发生，省略无关代码
  =                 
  
{
      = 
    
       

         
      =      {
        
    }
}
那么还有问题是，最大连接数这个阈值怎么获得？设定多少为合理？
前面已经分析，多个都会对同一个监听端口复用，也就是说在服务接收到请求的时候是没有办法直接区分开是哪个的请求的，只有在后面的业务线程处理时才会分发到各个服务上处理。因此，目前目前最大连接数只能是按整个服务的总量
每个可以配置一个连接最大值，通过读取配置文件累加得到整个服务的连接数总量最大值，实现如下：
  = 
     
         {
      {
        
    }
     = 
}
  =  

 设定多少合理需要一定的经验，在系统上线之前就预估好系统的处理能力，同时根据 “动态运营” 的思想，大胆假设，小心验证，用运营数据支撑开发，验证我们的用户假设。
 限定最大请求量
服务端对请求怎么管理，由于涉及到生产消费模式，很容易地想到就是要维持一个缓存队列，请求到达时先把请求放入缓冲队列中。那么应该让系统同时从队列里取出几个请求进行处理呢？前面提到，由于请求的处理是解析之后创建任务放到业务线程池去跑，那么这个问题其实就是线程池要开多大的问题。
是的，线程池提供了一个天然的缓冲区，我的理解是： 队列相当于一个管道，请求决定了一次有多少流量流入管道，线程数大小决定了一次有多少流量从管道中流出，如果在一定的状态下取出的请求有效能稳定维持一个流入流出的平衡关系，那么就不会出现过载的问题了！但是任何平衡态都是难以维持的，总有被打破的可能，从这个理解出发，我认为过载保护的意义就在于：一方面尽可能地维持这一平衡态，另一方面，当这一平衡态被打破的时候提供保护机制，不至于搞垮整个服务乃至整个系统。
值得注意的地方是，每个服务对应各自的线程池，也即上一节提到的业务线程池，所有的请求会分发到各自的业务线程池去处理。因此在配置文件中，我们可以对每个业务线程池的大小，和缓存队列长度分别进行配置。代码如下：
      {
      =   =   = 
      = 

      ==   

     = 
     =   _  

     = 
      =   

      =   =   = 
      = 
      = 

     客户端请求错误的或时，返回默认的
      ==  {
         
    }
      = 
      ==  {
         
    }

    设定队列长度，线程数线程池大小
     = 
     = 
     = 

        ||    ||    {
         
    }

      =  
      =                
    
     

     
}
保持平衡态就是要设定合理的初始值，但和前面对连接数的管理一样，线程池大小和缓冲队列长度的设定是不那么容易的，需要服务端处理能力的准确评估。
那么，平衡态被打破，怎么来做限定保护机制？ 
简单的过载保护就相当于只要定义一个拒绝策略，当其缓存队列放不下的就根据该策略对新来的请求进行处理，在的实现上默认采用了直接丢弃的策略。某种层面来讲，这就实现了一个对请求量的限定，亦即我们说的过载保护。
当然，限定肯定不能等到队列满的时候此时系统已经满负载运行才去以丢弃的策略触发保护。 简单的这种“ 满则丢弃 ” 不就把所有新来的请求都拒绝了么？那表现出来的形式就是服务不可用了！ 此时队列中的保存的请求是不是都有效呢，要不要优先丢弃掉？ 总之问题很多，我们还需要在队列满之前就需要采取一些相关策略快速拒绝掉一些请求。
问题不单是这么简单，在队列满之前还可以采取什么策略呢？
既然前面是在空间对请求量做限定，容易想到可以考虑从时间这个切面上对请求量做限定，即：依据请求处理的时延来判断是否过载，而且这个想法应该是要比直接限定空间大小更加直观和接近真理的。回到最开始我们对过载的定义：“当前负载超过了系统的最大处理能力”， 因此过载的直接表征应该是系统出现了很多请求来不及处理！ 相反的，如果认真考虑从空间上的限定则是不那么准确的，当前缓存队列满了固然说明负载超过了系统的处理能力前提是队列长度设置合理，但是当队列没有满的时候是不是就一定说明系统没有过载呢？ 显然不是，我把队列开到接近无限大呢？
实现上，这个请求处理时延的计算就要控制好了，请求到达并解析成功后，获取系统时间记为该请求的产生时间 ，放入队列，在该请求从队列中取出后，真正发起业务处理前，获取当前系统时间计为该请求的处理时间 ，计算两个时间戳的差即为该请求处理时延 =   。可以在之前就直接设定好一个队列超时时间，处理该请求前先判断，若请求处理时延大于队列超时时间  ，我们可以判定当前服务过载且该请求失效，直接丢弃该请求。
除了以请求处理时延来判断系统是否过载，设定队列超时时间还是很有必要的，这里关系到和客户端的交互问题。设想如果请求在队列中等待了很长时间，但客户端对每个请求都设定了一个调用超时时间__ __单向调用除外，如果超过这个时间服务端再去处理这个请求显然是没有意义的，而且会带来了无用的负载！
弄清楚处理逻辑，代码实现就不难了：
接收请求处理函数
    
{
      =    = 

     {
         = 

         
        {
             

               
            {
                 =  
            }
            
            {
                 =  
            }

              =  {
                 {
                    设定请求产生时间
                    
                      
                }    {
                    
                }
            }  {
                
                 = 
                
            }
        }
    }    {
        
        
    }
}

业务线程处理函数，省略无关代码
  =  处理端请求
{   
    
    
      =  
      
}

  = 

           
  = 
 =    
    {
          
}
 以上不管是在队列长度还是队列超时时间上做限制，都隔着一个缓存队列，经过过期丢弃后实际发起业务处理的请求数是多少呢？我们考虑实现像那样直接对连接数精确计数的方式。
容易想到，由于基于容器理念，在管理上各个服务是相互独立的，因此对每个服务设定一个最大负载并维持一个调用计数器，在每次服务被调用时计数加一，服务调用结束计数减一，当计数器的值大于最大负载时可判定当前服务过载，直接丢弃该请求。
特别要注意的，服务的最大负载配置是在容器初始化是从文件中加载的。至于为什么不是和最大连接数、队列长度等参数统一在管理平台上或是配置文件中配置， 我认为可能是设计者认为最大负载量应该和服务本身结合得更紧密些吧，但是我目前认为没有必要，统一配置可能更容易管理和理解。代码实现很简单：
        {
      = 
       = 
     {
         = 
        

         =   
    }  {
          {
            
        }
    }
     
}
发起调用前计数加一
     {
      ==  {
        
    }
    
        {
               =  
    }
}
调用结束计数减一
     {
      ==  {
        
    }
    
}
综上，这就是实现的过载保护机制，从本质上出发目标都是一致的，具体实现上多种手段相结合。
 另一角度
以上都是请求量的角度展开思考，因为请求量的上升是导致系统过载的根本原因，如果换一种角度，我们很容易会产生一种设想： 系统过载的表现则为系统资源的耗尽，那么我们是不是能在服务端对，内存、等系统资源进行监控呢？比如： 设定阈值，若系统资源利用率超过阈值则触发拒绝请求机制。
认真思考后，我认为这种方式在某些场景下是可行的，但是并不通用。原因是，
资源资源数据的耗尽并不意味着出现过载，如：服务开了一个较大的内存池，看起来内存资源耗尽了，实际上负载是足够的；又如现在都是多核服务器跑着多进程多线程，单一的耗尽也不能够代表服务就出现过载。过载并一定就会出现资源耗尽，如：当前所有服务都正在等待后端处理逻辑的返回，但是并没有占用多少，内存或资源。从这里我们也应该想到，过载除了体现在内部请求消息队列之外，还可能体现在外部对接的服务如：数据库，此时过载会体现在外部连接的发送队列过长。可见思考问题的思维逻辑方式非常重要，在这里其实就是一个因果关系的确定，如果在开始的时候切入问题的角度不恰当，可能得到的结论就不那么严谨了。当然，平时在思考的时候还是要多从几个角度多想想，有意识地加强训练，共勉。
四、过载预防
除了在过载发生时进行保护，在系统设计之初，还可以考虑做一些预防措施：
 负载均衡
虽然负载均衡的出发点并不在过载，但是我认为在某种程度上说将请求量分发，降低单个服务的请求量，这就相当于起到负载保护的作用了。在具体实现上，的负载均衡主要是放在客户端实现的，之后再展开探讨。
 模块分离
在系统设计上可能各个模块的负载不尽相同，考虑将负载高的一些模块独立开来，轻重分离，按需单独部署； 这也是高内聚低耦合在系统层面的体现，使得局部的过载不至于扩散到整个系统。
 流控
同样在端，可以做限流，在实习项目中我就采用了一个令牌桶算法，往后可展开探讨一下。
 监控告警
如之前所述，系统资源耗尽在一定程度上可以说明系统过载。在服务监控中，可以将、内存等资源作为监控指标，若占用率到达阈值及时告警。在监控的实现上，确实也是这么做的。除了对请求流量和相关的业务指标做上报监控，系统资源监控，监控必不可少。
感谢阅读，有错误之处还请不吝赐教。作者：朱煌 

是一套使用给打热补丁的系统，能非常有效的解决线上的和各种问题。
从何而来
对于每一个开发，从写 开始，到使用各种语言，可能都会遇到各种。有的能快速解决，比如侧的，发个或者即可。但是在终端开发中，比如，发现的线上问题往往没那么快能解决，换包可能需要短则几天长则一周以上的审核，成本很高。有没有办法能快速解决 的线上问题？是其中一种比较好的解决方案。
特点


支持多线程使用打补丁的天然优势在于是线程安全的，虽然锁的粒度有点大，并且有些方法的锁有问题这些在都已解决。
支持中的和的有很多相似之处。有补丁中定义的，传递到，我们会转成，并且可以在和之间传递，这点补丁是很难做到。
异步机制由于是线程安全的，同时也带来另外一个问题，假如工作线程和主线程都打了补丁，工作线程的补丁耗时非常严重，这时候如果主线程补丁开始运行，就会被阻塞。引入了异步机制，能让进入的补丁快速返回，异步执行，减少补丁之间的影响。
支持在线回滚在补丁发布后，有可能通过监控发现补丁有问题，这时候用户侧的运行逻辑已经被“污染”。支持，在补丁后台设置该补丁过期后，用户侧会删掉本地有问题的补丁包，并且在线，而不是等重启后再恢复，下次重启可能得好几天。
调试方便利用的天然优势，其内部提供了接口。我们可以像调试里面的网页一样，使用下的远程调试补丁，断点、堆栈、异常等一目了然。
精准投放支持按用户、版本、业务版本和标记投放。是一个可扩展的标记，业务可以自定义，比如取一位越狱标记，或者网络标记，补丁就可以根据是否越狱和网络标记下发。

核心原理
包括补丁包后台系统和终端组件，其核心原理是补丁后台根据补丁配置，下发一段补丁给终端，终端执行这段补丁，利用 覆盖有问题的方法或者执行一段逻辑，修正运行时的逻辑，从而达到修复的目的。
打补丁流程
 在补丁后台下发补丁脚本后，首先会经过及以上系统自带的把补丁执行起来，通过调用里面的接口，调用到里面打补丁的方法，打上补丁。 当业务代码执行这段已经打了补丁的功能时，不会是原来的代码，而是一段代码。可以通过引起和引擎支持、异步执行等，并且支持在线回滚。
和其他方案对比

是使用打补丁的方案，需要集成解释器和框架接近。不过对不太完善，多线程补丁也可能有问题，也已经两年没人维护。相比之下更加轻量，对安装包影响仅，功能也更加强大。
同样使用来打补丁，和终端组件核心原理是相似的。不过在实际的海量产品中运用还有不少问题没解决，比如传递、多线程等问题，解决了这些问题，更加稳定，并且支持异步机制、动态回滚等优化特性。


文章来源公众号空间终端开发团队


相关推荐
微信热补丁实践演进之路
安卓热补丁动态修复技术介绍前言
本文首先分析协议在安全性上的不足，进而阐述实现安全通信的关键技术点和原理。然后通过抓包分析协议的握手以及通信过程。最后总结一下自己在开发过程中遇到的相关的问题，并给出当前项目中对问题的系统解决方案，以供总结和分享。如有不当之处，欢迎批评和指正。
协议的不足
在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，存在的问题如下：

通信使用明文不加密，内容可能会被窃听；

不验证通信方的身份，有可能遭遇伪装；

无法证明报文的完整性，所以有可能已遭篡改；


其实这些问题不仅在上出现，其他未加密的协议中也会存在这类问题。
 通信使用明文可能会被窃听
按协议族的工作机制，互联网上的任何角落都存在通信内容被窃听的风险。而协议本身不具备加密的功能，所传输的都是明文。即使已经经过过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。
 不验证通信方的身份可能遭遇伪装
在协议通信时，由于不存在确认通信方的处理步骤，因此任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应。因此不确认通信方，存在以下隐患：

无法确定请求发送至目标的服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的  服务器；

无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端；

无法确定正在通信的对方是否具备访问权限。因为某些服务器上保存着重要的信息，只想发给特定用户通信的权限；

无法判定请求是来自何方、出自谁手；

即使是无意义的请求也会照单全收，无法阻止海量请求下的攻击；


 无法证明报文完整性，可能已遭篡改
所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。协议无法证明通信的报文完整性，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。
比如，从某个网站下载内容，是无法确定客户端下载的文件和服务器上存放的文件是否前后一致的。文件内容在传输途中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的。像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击 ，。

 安全的版本应该具备的几个特征
由于上述的几个问题，需要一种能够提供如下功能的安全技术：
 服务器认证客户端知道它们是在与真正的而不是伪造的服务器通话；
 客户端认证服务器知道它们是在与真正的而不是伪造的客户端通话；
 完整性客户端和服务器的数据不会被修改；
 加密客户端和服务器的对话是私密的，无需担心被窃听；
 效率一个运行的足够快的算法，以便低端的客户端和服务器使用；
 普适性基本上所有的客户端和服务器都支持这些协议；
的关键技术
在这样的需求背景下，技术诞生了。协议的主要功能基本都依赖于协议，提供了身份验证、信息加密和完整性校验的功能，可以解决存在的安全问题。本节就重点探讨一下协议的几个关键技术点。

 加密技术
加密算法一般分为两种：

对称加密：加密与解密的密钥相同。以算法为代表；

非对称加密：加密与解密的密钥不相同。以算法为代表；


对称加密强度非常高，一般破解不了，但存在一个很大的问题就是无法安全地生成和保管密钥，假如客户端和服务器之间每次会话都使用固定的、相同的密钥加密和解密，肯定存在很大的安全隐患。
在非对称密钥交换算法出现以前，对称加密一个很大的问题就是不知道如何安全生成和保管密钥。非对称密钥交换过程主要就是为了解决这个问题，使密钥的生成和使用更加安全。但同时也是性能和速度严重降低的“罪魁祸首”。
采用对称加密和非对称加密两者并用的混合加密机制，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。
 身份验证—证明公开密钥正确性的证书
非对称加密最大的一个问题，就是无法证明公钥本身就是货真价实的公钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。
如果不验证公钥的可靠性，至少会存在如下的两个问题：中间人攻击和信息抵赖。

为了解决上述问题，可以使用由数字证书认证机构， 和其相关机关颁发的公开密钥证书。

使用具体的流程如下：

服务器的运营人员向数字证书认证机构提出公开密钥的申请

通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等；

如果信息审核通过，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。


证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；
签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用的私钥对信息摘要进行加密，密文即签名；

客户端在握手阶段向服务器发出请求，要求服务器返回证书文件；

客户端读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法；

客户端然后验证证书相关的域名信息、有效时间等信息；

客户端会内置信任的证书信息包含公钥，如果不被信任，则找不到对应的证书，证书也会被判定非法。


在这个过程注意几点：

申请证书不需要提供私钥，确保私钥永远只能被服务器掌握；

证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名；

内置对应的证书称为根证书；颁发者和使用者相同，自己为自己签名，叫自签名证书；

证书=公钥申请者与颁发者信息签名；


协议原理
 的历史
协议历史简介：

协议的第一个版本由公司开发，但这个版本从未发布过；

协议第二版于年月发布。第一次部署是在浏览器上，发行于年月；

 于年年底发布，虽然名称与早先的协议版本相同，但是完全重新设计的协议，该设计一直沿用到今天。

 于年月问世，与 相比，版本修改并不大；

年月，下一个版本 才问世，仅仅修复了一些关键的安全问题；

年月，发布。该版本添加了对已验证加密的支持，并且基本上删除了协议说明中所有硬编码的安全基元，使协议完全弹性化；


 协议实现
宏观上，以记录协议 实现。记录协议负责在传输连接上交换所有的底层消息，并可以配置加密。每一条记录以一个短标头起始。标头包含记录内容的类型或子协议、协议版本和长度。消息数据紧跟在标头之后，如下图所示：

的主规格说明书定义了四个核心子协议：

握手协议 ；

密钥规格变更协议   ；

应用数据协议  ；

警报协议 ；


 握手协议
握手是协议中最精密复杂的部分。在这个过程中，通信双方协商连接参数，并且完成身份验证。根据使用的功能的不同，整个过程通常需要交换条消息。根据配置和支持的协议扩展的不同，交换过程可能有许多变种。在使用中经常可以观察到以下三种流程：

完整的握手，对服务器进行身份验证单向验证，最常见；

对客户端和服务器都进行身份验证的握手双向验证；

恢复之前的会话采用的简短握手；


 单向验证的握手流程
本节以邮箱的登录过程为例，通过抓包来对单向验证的握手流程进行分析。单向验证的一次完整的握手流程如下所示：

主要分为四个步骤：

交换各自支持的功能，对需要的连接参数达成一致
验证出示的证书，或使用其他方式进行身份验证
对将用于保护会话的共享主密钥达成一致
验证握手消息是否被第三方团体修改下面对这一过程进行详细的分析。


在握手流程中，是第一条消息。这条消息将客户端的功能和首选项传送给服务器。包含客户端支持的的指定版本、加密组件 列表所使用的加密算法及密钥长度等。


消息将服务器选择的连接参数传送回客户端。这个消息的结构与类似，只是每个字段只包含一个选项。服务器的加密组件内容以及压缩方法等都是从接收到的客户端加密组件内筛选出来的。


之后服务器发送报文，报文中包含公开密钥证书，服务器必须保证它发送的证书与选择的算法套件一致。不过消息是可选的，因为并非所有套件都使用身份验证，也并非所有身份验证方法都需要证书。


消息的目的是携带密钥交换的额外数据。消息内容对于不同的协商算法套件都会存在差异。在某些场景中，服务器不需要发送任何内容，在这些场景中就不需要发送消息。


消息表明服务器已经将所有预计的握手消息发送完毕。在此之后，服务器会等待客户端发送消息。

  消息携带客户端为密钥交换提供的所有信息。这个消息受协商的密码套件的影响，内容随着不同的协商密码套件而不同。


消息表明发送端已取得用以生成连接参数的足够信息，已生成加密密钥，并且将切换到加密模式。客户端和服务器在条件成熟时都会发送这个消息。注意：不属于握手消息，它是另一种协议，只有一条消息，作为它的子协议进行实现。


消息意味着握手已经完成。消息内容将加密，以便双方可以安全地交换验证整个握手完整性所需的数据。客户端和服务器在条件成熟时都会发送这个消息。
 双向验证的握手流程
在一些对安全性要求更高的场景下，可能会出现双向验证的需求。完整的双向验证流程如下：

可以看到，同单向验证流程相比，双向验证多了如下两条消息：与，其余流程大致相同。
 
= 是规定的一个可选功能，用于服务器认证客户端的身份。通过服务器要求客户端发送一个证书实现，服务器应该在之后立即发送消息。
消息结构如下：
 {
    _ _ ____
    ______
    __
    _ __
    __ 
    
} 

  {
     _
    
      __
     _
} 
可以选择发送一份自己接受的证书颁发机构列表，这些机构都用其可分辨名称来表示

当需要做客户端认证时，客户端发送消息，来证明自己确实拥有客户端证书的私钥。这条消息仅仅在客户端证书有签名能力的情况下发送。必须紧跟在之后。消息结构如下：
 { 
 __ 
} 
 应用数据协议  
应用数据协议携带着应用消息，只以的角度考虑的话，这些就是数据缓冲区。记录层使用当前连接安全参数对这些消息进行打包、碎片整理和加密。如下图所示，可以看到传输的数据已经是经过加密之后的了。

 警报协议 
警报的目的是以简单的通知机制告知对端通信出现异常状况。它通常会携带_异常，在连接关闭时使用，报告错误。警报非常简单，只有两个字段：
 { 
      
      
} 
字段：表示警报的严重程度；
：直接表示警报代码；
在中使用的常见问题
 服务器证书验证错误
这是最常见的一种问题，通常会抛出如下类型的异常：

出现此类错误通常可能由以下的三种原因导致：

颁发服务器证书的未知；
服务器证书不是由签署的，而是自签署比较常见；
服务器配置缺少中间 ；

当服务器的不被系统信任时，就会发生 。可能是购买的证书比较新，系统还未信任，也可能是服务器使用的是自签名证书这个在测试阶段经常遇到。
解决此类问题常见的做法是：指定信任特定的集合。在本文的第部分代码实现模块，会详细的讲解如何让应用信任自签名证书集合或者跳过证书校验的环节。
 域名验证失败
连接有两个关键环节。首先是验证证书是否来自值得信任的来源，其次确保正在通信的服务器提供正确的证书。如果没有提供，通常会看到类似于下面的错误：

出现此类问题的原因通常是由于服务器证书中配置的域名和客户端请求的域名不一致所导致的。
有两种解决方案：

重新生成服务器的证书，用真实的域名信息

自定义在握手期间，如果的主机名和服务器的标识主机名不匹配，则验证机制可以回调此接口的实现程序来确定是否应该允许此连接。可以通过自定义实现一个白名单的功能。


代码如下：
 __ =   {
  
        {
     设置接受的域名集合
       {
          
    }
  }
}

__
 客户端证书验证
支持服务端通过验证客户端的证书来确认客户端的身份。这种技术与的特性相似。本文将在第部分代码实现模块，讲解如何让应用支持客户端证书验证的方式。
 上版本兼容问题
之前在接口联调的过程中，测试那边反馈过一个问题是在 以下的系统出现请求不成功而在以上的系统上却正常的问题。相应的错误如下：
        =        

    ___    _ 
  按照官方文档的描述，系统对协议的版本支持如下：
              –    –                




  









–



–























也就是说，按官方的文档显示，在 以上，和是默认开启的。但是实际上在 以上才默认开启，以下的版本是无法使用和 的，这也是系统的一个。
参照上的一些方式，比较好的一种解决方案如下：
 
 _ = _ {
     =  
}  {
     = 
}
对于以下的系统，使用自定义的，开启对和的支持，核心代码：
     {

      

         {
          = 
          
         = 
    }

          {
         = 
    }

    

    
                {
            
    }

     开启对和的支持
        {
         =      {
              { }
        }
         
    }
}
代码实现
本部分主要基于第四部分提出的应用中使用遇到的一些常见的问题，给出一个比较系统的解决方案。
 整体结构
不管是使用自签名证书，还是采取客户端身份验证，核心都是创建一个自己的然后使用这个创建一个自定义的。整体类图如下：

类图中的可以应用在的方式与服务端连接的过程中
 ____ {
      =  
      =  
    
    _ = _ {
         =  
    }  {
         = 
    }

    
    __
} {
     
    __
}
核心是通过使用自定义的校验逻辑。整体设计上使用策略模式决定采用哪种验证机制：

 单向验证方式自定义信任的证书集合

 双向验证方式自定义信任的证书集合，并使用客户端证书

 信任所有的证书，不安全，仅供测试阶段使用


 单向验证并自定义信任的证书集合
在中，把服务端证书放到资源文件下通常是目录下，因为证书对于每一个用户来说都是相同的，并且也不会经常发生改变，但是也可以放在设备的外部存储上。
     {

     在这里进行服务器正式的名称的配置
       = { }

    
       {
          =  
          =        {
             {
                 = 
            }   {

            }
        }
          = 
         {
             = 
        }   {

        }
         
    }
中定义了所信任的证书名称这些证书文件必须要放在指定的文件路径下，并其要保证名称相同，而后就可以加载服务端证书链到，通过获取到的可信任并带有服务端证书的就可以用它来初始化自定义的了：

            {
         {
             
        }   {
             {
                  = 
                  = 
                  = 
                  = 
                  =  
                
                 
            }   {
                 
            }
        }
    }
 跳过证书校验过程
和上面的过程类似，只不过这里提供的不需要提供信任的证书集合，默认接受任意客户端证书即可：
     {

    
            {
         ，接受任意客户端证书
    }

    
            {
         ，接受任意服务端证书
    }

    
       {
         
    }
而后构造相应的
     {
          =  
          = 
           {  } 

         
}
参考文献

 协议分析 协议 证书与密钥交换

深入理解

原理介绍之内容加密

       

       

 关于的官方文档

使用与来保证安全性

  安全的 通信

详解是如何确保安全的？

 图解—第七章

   

              作者：

译自                
与 也称为 相比， 是对语言规范的一个小更新。 这是由于版本现在决定将修订发布的周期变为每年更新，实际上只是已准备好的所有功能的快照。因此，大多数资源仅列出 中的两个显着变化：

添加乘幂运算符

添加方法


这些功能对开发人员具有最直接的影响，但是，还有一个常常被遗忘的重大变化。 这是我在我的书《  》中所提到的，但是，我仍然会收到关于它的问题，所以我想深挖一下这个问题。
首先，我将描述变化的内容，然后我将说明变化的内容背后的理由。
变化
 说，“ ”指令不能用于其参数具有默认值的函数的正文中，使用解构或者参数。 规范将简单参数定义为仅包含标识符的参数列表 仅支持简单参数列表。 该更改会影响所有函数类型，包括函数声明和表达式，箭头函数和简明对象字面值方法。例如：
 可以使用
   {
     

     
}

 在 中为语法错误
  = {
     

     
}

 在 中为语法错误
  = { } {
     

     
}

 在 中为语法错误
  =  = {
     

     
}

  = {

     在 中为语法错误
    { } {
         

         
    }
}

你仍可在函数之外全局使用“ ”，以便该函数在严格模式下运行，即使该函数具有非简单的参数。 例如：
 可以使用
 

  = {
     
}

在这种情况下，函数之外的“ ”指令是有效的语法。 如果你使用模块，这也不是一个问题，它以严格模式运行所有代码。
为什么要有此变化？
由于严格模式和非简单参数列表的工作方式，此更改很重要。当在 中创建严格模式时，解构和缺省参数值不存在，因此解析参数列表并查看“ ”指令没有问题。在这一点上，“ ”不能影响解析参数列表的结果，它只用于验证参数标识符不允许重复和检查禁用的标识符，如和。然而，随着在 中引入解构和默认参数值，情况已经不再是这样，因为规范指出参数列表应该按照与函数体相同的模式进行解析这意味着“ ”指令在函数体必须触发严格模式。
首先要意识到的是严格模式需要更改代码的解析和执行。作为一个非常简单的例子，模式不允许使用旧式八进制数字文字例如。如果代码在严格模式下解析，则将抛出语法错误。考虑到这一点，你认为以下代码应该做什么？
 在 中为语法错误
 = {
     

     
}

如果一个解析器试图解析此代码，参数列表将会在函数体之前被解析。这意味着被解析为有效，然后在函数体中遇到“ ”，它告诉解析器，“实际上，你应该在严格模式下解析参数列表”。 在这一点上，解析器将必须在严格模式下回溯并重新解析参数列表，所以为抛出语法错误。这可能不是一个大问题，但如果默认参数值更复杂怎么办？
 在 中为语法错误
 = {
      
} {
     

     
}

在这种情况下，使用默认参数值中使用的函数，你会有更多的问题。为了在严格模式下运行，使得必须展开的数量更多，还必须将该函数设置为默认值。 为了确保默认参数值表达式被正确解析，并理解为运行在严格模式，将变得十分复杂。
解构参数也会导致类似的问题，因为它们可以包含默认值。 例如：
 在 中为语法错误
 {=} {
     

     
}

这里，解构参数值具有在严格模式下不允许的默认值，导致与默认参数值相同的问题。
最后，决定对于这种在 中不存在问题的情景中，简单地禁止函数体使用“ ”，以避免丢失边缘情况。 这意味着具有默认参数值，解构参数或参数的函数在函数体中不能有“ ”。 这包括“ ”没有效果的情况，例如：
  {
     

     在 中为语法错误
     = {
         

         
    }
}

此示例将具有非简单参数的函数嵌套在具有“ ”的另一个函数中。 函数自动处于严格模式，但引擎仍会在的函数体中的“ ”指令上抛出语法错误。
解决方法
这种变化不太可能影响许多开发人员，这可能是为什么你不知道它。“ ”指令开始沦为的历史文物，因为模块和类都会以严格模式自动运行，而无需选择退出，这意味着在这些情况下不需要使用“ ”。 但是，在极少数情况下，你需要一个带有非简单参数的函数在严格模式下运行，你可以使用立即执行函数的形式创建函数：
  =  {
     

     = {
         
    }
}

在此代码中，在以严格模式运行的中创建函数。 这允许返回的函数在使用默认参数值的情况下以严格模式运行。 因为外部作用域以严格模式运行，所以毫无疑问可以正确解析默认参数值，并且不需要在函数体内额外添加“ ”。
总结
这个对 的小改变，不允许函数体使用非简单参数列表的函数“ ”，突显了这样一个流行语言在演进过程中的困难重重。 在这种情况下，决定通过引入一个新的语法错误消除歧义，如果这个问题早点出现，便可能是 的一部分。 添加这个语法错误是最显著有效的方式，因为它影响非常少的现有代码规范更改是在引擎实现非简单参数列表的同时进行的，并且可能不会影响很多未来代码，因为模块和类以严格模式运行。
引用

   
        
           


原文链接：


相关推荐    译 译        展示组件与容器组件英译背景
兴趣部落项目自年至今，一直都是采用的是前端渲染的模式，这种模式就是页面是一个空壳，首屏的内容需要和都加载完成后，请求获得数据后再渲染给用户。这种模式的好处是可以让后端和前端的工作完全分离，给日常的开发和维护带来很大的便利。
我们在现在的工作模式上，为了尽可能的减少首屏耗时，做了相当多的优化，包括使用离线包的机制来减少和的时间

但是这些所有的优化，仍然是基于执行后，才可以向用户交付首屏的，如果遇到上执行速度很慢的机器，就会显得耗时仍然特别长。
使用直出的页面，不再只是一个空壳，而是一个渲染良好的页面，这样用户就可以不用等待加载和执行后看到内容，大大减少用户的焦虑感。
在现有的工作模式下，使用同构直出的手段，不仅可以保留我们现有的开发模式，还可以减少很多工作量。试想，我们现在将现有的工作模式全部推翻使用普通直出，要面临多少工作重建。
同构直出，前后端完全使用同一套代码，将前端的渲染逻辑移到服务器端完成，将渲染后的结果再交给用户，得益于这套体系，我们将这样的能力应用到了兴趣部落项目中。
历程
首先我们先在一个小页面上进行全量尝试，不断解决，调整其间遇到的问题

后面，待我们的架构成熟了之后，我们把这套体系运用到兴趣部落的三大核心页面之一的帖子详情页

经过不断的灰度、解决问题，最终帖子详情页的同构直出正式全量上线

其中的机器，几乎全是虚拟机。
效果
直观感受下对比的效果，如下图

左侧为前端渲染，右侧为同构直出
可以明显看出，直出在机型下带来的优化效果是非常明显的，同时从正常的测速数据上来看，直出的首屏耗时减少了，慢速用户占比减少了个百分点
架构

前端代码的架构是传统是架构体系，使用的架构可以让我们的直出更可控

挑战
内存问题
同构直出大部分情况下都要面临此类问题，普通的前端页面极少会考虑内存泄露的原因，然而在端运行的代码都要考虑内存泄露的问题。
一次用户访问的管道中，调用完了，理论上管道产生的内存可以完全被回收，如果不可以被回收，那么就会产生内存一直增长的问题。
我们都知道，挂到 上的变量都无法回收，前端的代码太多不控的代码会导致内存泄露，我们需要一个通用的解决方案
原来的代码
  = 
虽然每个请求，每个用户都会去同构的组件，但是由于端是单例模式，所以每个用户引用的都是同一个引用，每个请求对的执行内部产生的变量声明，如果该变量连接到的引用链上的，当用户请求结束的时候是无法释放的，因为的引用是单例的，会缓存住，所以这些变量就无法回收，会产生严重的内存泄露问题。

上线时内存暴涨的问题
为了解决这个问题，可以对每个用户请求，开辟一个新的实例，这样当用户请求结束了，的引用可以被顺利回收，就不会产生内存泄露的问题
目前部落中使用的是的解决方案，为每个用户请求创建了一个沙箱环境
 {
      =  

     =   {
         
    }
}

  =   
  = {
     {}
}

  = 

   __ __

 = 
每个用户请求过来，都会重新变编译出一个 这个引用不与其他请求共享，请求结束了，也会被回收，中产生的所有垃圾内容都会被一起回收

内存得到有效控制
关于性能问题，产生的性能会带来的使用耗时增加，大约，但对内存控制是非常有效的。
关于这块的优化，同构直出本来就是一个密集型的任务，后续可以结合缓存来将密集型任务转为内存密集任务
二次
虽然解决这个问题的方案并不难，但重在我们能在详情页放量前能发现这个常常被忽略的问题。
通用的重构直出方案，到前端的代码会正常执行，这样会在前端再发一次，数据也会变成最新的。但是，实际上，服务器端已经为该用户发一次请求了，这样就导致了一个用户请求了两次。
这里的方案通常可以划为优化的角度去考虑。
在第一个小页面上线的时候，我们并没有太重视这个问题，但是详情页灰度上线的时候，我们逐渐认识到这不是一个优化问题，而是一个严重的架构问题。如果详情页直接上线，对后台带来量的冲击是非常大的，原本亿的日访问量一下子变成亿的访问量，这比变成对后台的压力要远远大的多。所以这个问题要在继续放量前必须解决的问题。
解决的方案就是使用数据将端已请求的数据同时吐到前端去，这样在前端请求的时候做一次拦截，检查是否有数据缓存，如果有的话就不再请求， 这样可以大大消除新增的量

但是遇到的问题，数据用_参数做存储的时候，往往因为前后端不一致的参数导致缓存无法匹配，比如前端使用了地理位置信息参数，这个在服务器端是无法换取到的。解决的方案就是将这些参数存到里，请求的时候端可以用缓存的位置信息数据

客户端依赖参数使用，缓存命中率大大提高
离线包
资源、资源使用离线包是比较想当然的事情，但是在部落转为直出，接入离线包也遇到一些困难。

、 值很多
用户端的离线包版本是很多的，每个离线包版本对就没的资源的又不一样，直出的页面引用的资源又该怎么知道用户本地离线包的是哪个呢？
我们使用了如下的解决方案

在前端编译离线包的时候，会把内注入一段，作用是在当前页面下种下一个代表版本号的数据，同时将此命名成发送到直出服务器，那入由该离线包发出的直出请求都会带上这个版本信息，我们根据这个版本信息将对就的做为本次直出要吐出页面的模板，这样到用户端可以匹配到用户离线包的资源。
首屏优先
首屏优先也是常常被大家忽略的体验问题，大部分前端渲染的页面都是如下的样子


   = 


   =


   =
   =


如果使用直出会变成这个样子


   = 


   =
        
         =
  

   =
   =


看起来也没什么问题，内容直接出现在里了
但是我们经常会忽略一个体验问题，这样的页面真的是会比非直出快么？
答案是否定的！也不是大部分情况并不会比非直出快！甚至体验上会比非直出更慢！
原因是要弄清楚浏览器首屏的出现时机，什么时候浏览器会执行第一次  简单来讲，大部分情况下直出的元素并不会第一时间展示出来，而是等执行完，才会展示首屏内容，如果都加载并执行完，那么我们直出的元素还有什么意义，这又回到普通的前端渲染了，空壳架子又比原来还要多了，所以难免白屏时间会更长。
所以为了解决这个问题，我们要让直出的节点可以第一时间展示出来，解决的方法也不难，可以使用懒加载，部落使用了更好方案，第一时间展示首屏内容，第一时间加载，并且不阻塞渲染，不阻塞首屏交付。

感谢内核同学的指导
关于首屏渲染时间：

会阻塞渲染 没有加载完成渲染没有意义
会阻塞文档解析，不会阻塞渲染
浏览器解析到标签时，如果资源已经准备好了，会先执行，再做渲染，如果没有执行好会先渲染
大部分线上的资源都是有强缓存的，或者有手离线包，浏览器解析到标签时资源已经准备好，会先执行，再做渲染

首屏渲染的时机涉及么很多因素，很不可控，但是内核浏览器提供给了便利的控制方法来优化首屏时机
首屏渲染时机可以自己定义，添加标签
 = =
有三种可选类型

 自动首屏探测
 首屏标签
 不做探测

首屏标签为

维稳
一个线上的后台任务，最大的问题就是讲稳定和容灾，首先任务保证用户的服务是稳定的，遇到一些突发问题时候，线上的页面仍然可以稳定的提供服务。

相比传统的直出，同构拥有更强的容灾的能力，这也同构直出的魅力所在！因为在同构直出宕掉的时候，还有前端渲染页面可以提供正常的服务，所以部落在部署页面的存在两种模式
现有的前端渲染路径：
对应的直出页面路径： 
比如这个直出页面==_== 模拟器打开，去掉就是非直出页面==_== 模拟器打开
兴趣部落直出项目在容灾策略上提供了两层容灾策略
第一层  框架层 · 超时、出错容错
框架超时、出错时候就会返回一个页面原始的非直出页面，这样到用户端就可以走正常前端渲染。
第二层  运维层 · 服务宕机容错
这一层的容错会放在服务机的前置层，简单来讲就是请求直出页面出现、的错误，就会隐式的转发路径到不含的非直出页面。
      {
        _ 
        __ 
        _         __
    }

     __ {
           
    }
即使整个直出服务完全挂掉，我们都不用担心服务的可用性
自动化测试
另个一个层次，如何保证平时开发过程的稳定性，也是整个架构体系重要的一环，不要等到有问题的代码的发到线上才发现有问题。
部落在直出的开发维稳体系上，首次引入的了自动化测试 的方案来保证提交的代码一定是不会出问题的。

其他同学提交的代码在的时候会触发本地 并进行直出页面的自动化测试，只有通过自动化测试才可以提交代码。
这个方案极大的保证了直出服务的稳定，自此方案上线以来，再无直出服务出现问题情况发生
展望
应用型技术的难点不是在克服技术问题因为大部问题都是有解决方案的，而是在于能够不断的结合自身的产品体验，发现其中存在的体验问题，不断使用更好的技术方案去优化用户的体验，为整个产品发展添砖加瓦。
做为公司最大的同构直出服务实践，在后续的方案中，我们会进一步着手优化用户的使用体验。比如使用服务器缓存等手段来进一步减少服务器端的耗时，优化直出图片的加载的体验等等，同时会更多丰富的实战经验分享给大家。郭林烁

原文地址
直出是什么？到底是怎样的性能优化？本文将结合从在浏览器输入，到展示最终页面的过程来对其进行一步步分析，并将在手  中的实际应用实践进行总结。
模式   前后分离
从用户输入 　到展示最终页面的过程，这种模式可简单的分为以下  部分：

用户输入 ，开始拉取静态页面

静态页面加载完成后，解析文档标签，并开始拉取  一般  放于头部

接着拉取  文件一般  文件放于尾部

当  加载完成，便开始执行  内容，发出请求并拿到数据

将数据与资源渲染到页面上，得到最终展示效果


具体流程图如下

这种处理形式应该占据大多数，然而也很容易发现一个问题就是请求数多，前后依赖大，如必须等待  加载完成后执行时才会发起 数据请求，等待数据回来用户才可以展示最终页面，这种强依赖的关系使得整个应用的首屏渲染耗时增加不少。
模式  数据直出

数据请求在端上提前获取，并和一同返回，页面模板和数据的渲染在浏览器端上执行

在模式  中，第  点用户输入  时  端不做其他处理直接返回  ，在第  点向  请求获取数据。那么，同样都是向  请求获取，如果在第  点中将请求数据放在  上，将拿到的数据拼接到  上一并返回，那么可减少在前端页面上的一次数据请求时间。 这就是模式   数据直出所做的事，处理方式也很简单：

用户输入  ，在  返回  前去请求获取页面需要的数据

将数据拼接到  上 并 一起返回给前端可以插入  标签将数据添加到全局变量上，或放到某个标签的  属性中，如  = {} 

在前端的代码中判断是否已在服务端拿到数据，直接拿该数据进行渲染页面，不再做数据请求


具体可下面的流程图看出这种模式下

这种模式与模式 相比，减少了这两种模式请求数据的耗时差距。这块差距有多少呢？
发起一个  的网络请求过程
解析可以缓存
         |
         |
        建立链接 三次握手 
                |
                |
              半个  
                   |
                   |
                 不确定优化空间 
注  为   缩写，表示一个数据包从发出到返回所用的时间。
 请求在前后端发出，差距有多少？
由上面对  的网络请求过程可看到建立一次完整的请求返回在耗时上明显的，特别是外网用户在进行  请求时，由于网络等因素的影响，在网络连接及传输上将花费很多时间。而在服务端进行数据拉取，即使同样是  请求，由于后端之间是处于同一个内网上的，所以传输十分高效，这是差距来源的大头，是优化的刚需。
模式   直出 服务端渲染

数据请求在端上提前获取，页面模板结合数据的渲染处理也在上完成，输出最终 

模式  中将依赖于文件加载回来才能去发起的数据请求挪到  中，数据随着  一并返回。然后等待  文件加载完成， 将服务端已给到的数据与结合处理，生成最终的页面文档。
数据请求能放到  上，对于数据与结合处理也可以在上做，从而减少等待  文件的加载时间。 这就是模式   直出 服务端渲染，主要处理如下：

 上获取数据并将数据与页面模板结合，在服务端渲染成最终的  

返回最终的  展示


可以从下图看出，页面的首屏展示不再需要等待  文件回来，优化减少了这块时间

通过以上模式，将模式   常用模式中的第  和  点耗时进行了优化，那么可以再继续优化吗？在页面文档不大情况下，可将内联到中，这是优化请求量的做法。直出稍微不同的是需要考虑的是服务端最终渲染出来的文档的大小，在范围内也可将  文件内联到  中。这样的话，便优化了  的获取时间，如下图

小结
直出能够将常用模式优化到剩下了一次  请求，加快首屏渲染时间，使用服务端渲染，还能够优化前端渲染难以克服的  问题。而不管是简单的 数据直出 或是 服务端渲染直出 都能使页面的性能优化得到较大提高，以下将从实际应用中进行说明。
以手家校群的数据直出优化为例
由于项目上线时间紧，所以在第一次优化上使用了数据直出的简单方式来优化首屏渲染时间。具体处理与 模式  数据直出方式 一致，与其不同的是这里使用了由  开发的 基于的玄武直出服务 来作为前端与服务端间的中间层。形式如下

使用这种中间层的方式，在项目的开发过程中依然可使用前后端分离的方式，开发完后再将页面请求指向这个中间层服务上。中间层服务主要做了上述 模式   数据直出中的处理：

使用前端文件及调用服务端做好的拉取数据接口

将数据与前端文件结合并返回给请求来源


由于该中间层服务与具体部署在相同的内网上，所以它们直接的数据交互是十分高效的，从而可达到 模式   数据直出 中所述的优化。
另一点，做为中间层玄武直出服务通过公司的负载均衡服务，完美兼容直出与非直出版本，即当直出服务挂掉了，也可以顺利走非直出版本，确保基本的用户体验，也能够更好的支持 。
性能数据
简单的数据方式直出同样迎来了较大的性能提升，手家校群列表页在首屏渲染完成时间上，相比于优化前的版本，数据直出有大概  的优化，提升约  的性能。

总结
在前后端没有分离时 使用后端渲染出模板的方式是与文中所述的直出方案效果是一致的，前后端分离后淡化了这种思想， 的发展让更多的前端开始做后端事情，直出的方式也越来越被重视了。
历史的车轮滚滚向前，直出方案看似回到了服务端渲染的原点，实际上是在以前的基础上盘旋上升。有了更多的能力，便可以有更多的思考。期待前端会越来越强大，这不，也让前端开始着手客户端的事儿了 
后记
手家校群使用     架构，既然是 ，肯定不可忽略  同构 服务端渲染 关于 同构直出的具体实践，我将其总结在另外一篇文章上，可点击查看 同构直出优化总结
对于文章一开始提及的前端路由，对路由的实现原理感兴趣的也可点击查看 前端路由实现与  源码分析
感谢指教！
 查看更多文章 一、简单说：集群概念
、  组织架构

要搭建一个集群，需要三种角色：
①  ： 实例，用于存储实际的数据块，实际生产环境中一个 角色可以由几台机器组成一个 承担，通过这种方式防止主机的单点故障。
 ②  ： 实例，存储了整个 ，其中包括  信息。
 ③  ：实例，前端路由，客户端由此接入，而且让整个集群看上去像单个数据库，前端应用可以透明使用。
、实例分配和配置
 根据实际的生产环境和应用的要求，摒弃了通常使用的单服务器单实例的部署方案，而是选择单机多实例的混合部署策略。

① 分别在台机器运行个实例，组织 ，作为的。② 在两台机器共运行个实例，配置个 。
【注意】
在中，支持进行副本配置，避免了以前版本中多部署时遇到的同步时出现各个中的时间戳相异而导致的集群无法启动的问题。
③ 每台机器运行个进程，用于客户端连接。
二、详细说：集群搭建
、安装软件
 ①下载最新版的的安装包
 ②解压安装包
、  配置 
①   创建数据目录以为例，路径可以按需求更改
       – 

      

      
②   编辑配置文件
=   数据目录

=  日志文件

=   日志追加

 =      端口

 =   最大连接数

 =     日志 

 =        守护进程模式

 =    刷写数据到日志的频率

 = 

 =    操作日志单位

 = 

=
③启动
      
     –=
 ④初始
 用连接其中一个，执行
       
       = {_   
                            {_    }

                            {_    }

                            {_    }

                      }

       
、  配置 
①   创建数据目录以为例，路径可以按需求更改
       – 

       

       
 ②   编辑配置文件
=  数据目录

=  日志文件

=   日志追加

 =      端口

 =        守护进程模式

=

 = 
 ③  启动
      
    –=
、  配置
①   创建数据目录
       

      
 ②   编辑配置文件
=_    日志文件

=   日志追加

 =    端口

 =    最大连接数

= 

 必须是个或则个配置
【注意】
在版本配置时个时，需要将其添加成副本形式，并在配置时候标明！！！。
 =       守护进程模式
 ③   启动
   
  –= 
、  配置分片
①   连接到，并切换到
      

     

      
②   加入
采用…这样的格式，例如本例执行：
{    }

{    }

 {    }

{    }
【注意】
用于指定每个的名字，不指定的话系统将自动分配
指定各个可使用的最大磁盘空间，单位
 ③    
  {    } 
如果列出了以上二个你加的，表示已经配置成功。
、  激活分片
① 激活数据库分片
  {  “”}
【注意】
通过执行以上命令，可以让数据库跨，如果不执行这步，数据库只会存放在一个，一旦激活数据库分片，数据库中不同的将被存放在不同的上，但一个仍旧存放在同一个上，要使单个也分片，还需单独对作些操作。
 ② 激活集合分片
要使单个也分片存储，需要给指定一个分片：
        {   “”   }
例如：
       {    {_ }}

      {       }
、关于仲裁者哨兵
 看到这里，我相信很多朋友都在纳闷，为什么在上面的配置过程中，都没有提到集群中最重要的仲裁者呢？其实关于仲裁者，最大的好处就在于当集群节点意外挂掉以后，可以帮助分片选举出新的主分片节点，使得系统能正常运行，对外界屏蔽了单点故障。同时它自身并不存储任何数据，不耗费任何的磁盘空间，是个轻量级的进程。
当我们配置分片中的节点数是奇数时，其实我们就不必担心这一类问题了，因为这时候副本的集群自带了仲裁的效果，就省去了设置仲裁者的步骤了。不过我们也可以通过下面的命令手动添加仲裁者：

三、总的来说：集群的难点
大家发现了吧，其实集群的搭建不算困难，只需要按部就班的配置，几分钟完成一个能用的集群绝对是有可能的，但是要搭建一个高可用的优质集群，那么需要研究的还远不止这些。对于配置文件中的参数选择才是需要我们根据实际生产环境和业务需求去好好琢磨的，的性能极度依赖于集群初期搭建时的参数选择，至于这一点，在之后的测评报告中会逐一向大家展示。
《 第二期：压缩与索引 》《  第三期：托管  存储服务 》项目背景
微信，，空间等用户每天上传了海量图片及视频，图片上传下载时需压缩，视频播放前需转码；热潮兴起后，围棋，游戏等对弈数据的生成需要大量的计算能力；计算成本逐步成为不可承受之重。同时由于公司业务的多样化，难以均衡用满各类资源；现网服务器主要承载在线业务，有明显的波峰波谷效应；同时设备购买，裁撤，流转形成了大量的短期空闲设备，公司整体资源利用并不充分，故架平虚拟化团队建设了弹性计算平台，致力于挖掘复用现网的空闲资源，以满足当前对海量计算能力的需求。

关键挑战
复现网的空间资源主要存在个挑战：➤易影响现网在线业务的服务质量，如下图所示：计算业务可能与在线业务共享执行单元 ，内存，磁盘，网络等，哪一个环节没控制好，都会影响在线业务的服务质量，比如仅仅 的冲突，便可能使得计算性能下降以上。➤挖掘出来的弹性资源本身难以用好，如上图所示，弹性资源非常多样，资源规格不一，可用端口不同等，且资源非常易变，比如资源份额随在线业务负载变化可能动态调整，影响了在线业务时会立即被清除，业务用好这些资源很难。
技术架构
为解决上述挑战，我们设计了弹性计算技术架构下图所示，其中：

 ➡ 接入层：负责提供服务化接口，包括服务访问，服务配置，镜像管理等； ➡ 调度层：通过名字服务屏蔽多样易变资源，实现负载均衡，扩缩容调度，故障调度，错峰调度，灰度变更等能力； ➡ 节点层：实现资源隔离，冲突检测，容器管理监控等机制，供上层使用；下面针对关键挑战详细描述技术解决方案。    
避免影响在线业务
本节主要从避免影响在线业务计算容量，计算质量计算延时，调度延时，故障率等个方面来分别阐述。
避免在线业务容量受影响
为保障在线业务的容量，首先要做好业务间合理混搭，如下图所示，消耗资源多，但网络带宽少的，尽量混搭到消耗网络带宽多但空闲的，实现混搭关键点在于提炼合理的性能模型，因为现网业务资源需求差异大，服务器硬件资源规格也不统一，性能模型要能抽象这种差异，用最简单的公式表达出性能特点，弹性计算平台首先通过相对模型来识别是否适合混搭，比如万兆服务器每核配比带宽，业务核跑满消耗，业务核跑满消耗，那与适合：混搭；在此基础上再通过规格模型来隔离计算业务，比如用，表示分配给容器业务核，内存，磁盘。分核心时会综合考虑是否通过超线程共享物理核，设置合理的软硬配额，由于当前内核协议栈对网络及磁盘的隔离并不理想，我们主要是通过业务性能模型匹配解决网络及磁盘冲突的问题。

在线业务有明显的波峰波谷效应，如下图所示，在波谷时有更多的资源容量可让出供给给计算使用，所以我们也广泛应用了错峰调度，在线业务波谷时，比如点到点，让出更多的资源给离线计算型业务使用，比如围棋的对局演绎。

避免在线业务计算延时受影响
解决在线业务资源容量保障后，业务计算延时的影响主要来源于指令执行延时：➡计算型指令由硬件执行，时间基本固定温度影响带来的差异可忽略不计；➡控制型主要跳转等指令主要由业务逻辑本身决定，业务逻辑没优化好时频繁分支预测失败可能造成延时增加；➡访存型指令：这块由于 结构，可能造成延时的波动，如下表所示，一级访问延时与内存相差了倍以上，共享时主要影响的是访存指令的延时；


















为监控业务计算延时，我们引入了监控，简单来说， = 周期数指令数，放映了业务整体的指令执行延时，如下图所示，通过历史数据可提炼合理的标准值及方差值，监控当前实际值，对比模型来判断业务计算延时是否正常。这个值与业务指令模型主要是访存指令的比例等及型号相关，故需区分业务模块及型号建模。

延时变化时，反应了真实的指令执行延时增加，但指令延时的增加不一定对业务有实际影响，所以监控的关键点在于怎么确认实际业务影响，解决误报的问题，我们主要是通过三种办法来解决：➡对接业务延时监控，但业务延时监控精度可能不一致，且可能无便捷的数据访问接口，故这种方案只能在重点业务上采用；➡增加确认值，比如监控  的次数及计算型业务的利用率，利用这些值来反推计算业务是否影响了在线业务质量；➡消除监控噪点，比如连续个点以上延时增加才真正告警处理；检测到异常时，我们会先通过本地动态调整计算业务配额减轻影响，效果不明显时，才会将计算业务调度至其它服务器，先本地调度有利于于避免瞬时的计算毛刺造成频繁的分布式调度。
避免在线业务调度延时受影响
前面通过资源隔离解决了在线业务计算容量保障问题，通过监控及调度解决了计算质量保障的问题，剩下的便是在线业务调度延时保障了，如下图所示。由于是非抢占内核，默认情况下在线业务获取时间片的时间是无保障的，混搭上计算型业务后，调度延时更不可控，为解决这个问题，我们在内核层面实现了业务优先级调度。

我们通过设置不同容器的值，将业务优先级传导至内核，指导内核调度，比如默认代表普通优先级，代表高优先级，代表低优先级，配置了的容器，可抢占配置为的容器的时间片。应用优先级调度后，在线业务的毛刺这里为平均延时倍点，对比优化前缩减了，基本与不共享时持平，某场景的优化效果如下表所示。



：
无共享
共享优化前
共享优化后
优化效果




平均延时 






最大延时 






毛刺数







避免在线业务故障率提升
，网络及磁盘是可压缩资源，共享时可能使得在线业务延时增加，内存是不可压缩资源，如果冲突，可能导致在线业务或关键系统进程被，而导致业务异常；为解决这个问题，平台与内核结合一起研发了优先级调度，如下图所示：

➡平台主要解决可预测，持续性的调度，比如平台收到内存不足预警通知时，如果近期内存一直持续上升，会立即调走计算型业务；➡内核主要解决不可预测，突发性的调度，比如计算型业务或在线业务收到异常业务请求，导致内存突然暴涨时，掉低优先级的计算型业务容器，并给平台发送事件通知，平台做清理善后。
用好弹性资源
本节主要从筛选业务提供场景式服务，封装资源的多样与易变性及更上层的服务接口三方面阐述。
筛选业务提供场景式服务
由于弹性资源的多样易变，短期难以成为通用的计算平台，故结合实际需求选择了图片压缩，视频转码，计算，日志计算个场景，该个场景总结起来的共同点是单核流量小于，且业务平台能容忍节点的变动或失效，如下图所示。

对于无计算状态的业务，比如图片压缩，弹性计算平台提供服务化接口，接管计算节点的扩缩容，对于有状态的计算，比如视频转码切片，计算中间数据缓存，日志计算模型等，则提供接口，让业务自行发起扩缩容等调度。
弹性资源由于其特殊性难以保障所有接入业务的计算质量，故我们区分优先级，提供差异化服务，优先保障在线计算型服务质量，如下表所示。



计算优先级
场景举例
资源类型




在线计算型关键路径
图片上传压缩
资源规格固定，调度少


在线计算型非关键路径
图片下载压缩视屏转码
资源规格固定，调度较多


离线计算型
日志计算
资源规格不固定，调度多



对业务屏蔽资源的多样与易变性
现网弹性资源的多样及易变主要来源于点：➡可弹性资源规格不一样，比如有些服务器可复用核，有的可复用核；➡ 硬件性能有差异，如下表所示，最好的与最差的性能可差距一倍；➡计算业务容器可用配额会随着在线业务负载变化，甚至被销毁；




性能




 



 



 








我们采用了名字服务来屏蔽弹性资源的多样易变性，如下图所示，用户只看到服务名字，无须关心背后绑定的资源及权重动态变化，扩缩容，冲突调度，错峰调度，灰度调度时修改资源的绑定，权重调度修改资源的权重，如下表所示：

权重的设置如下表所示，综合考虑资源规格核心数，资源能力性能基准值，可用配额等设置总权重，并记录单核权重作为负载均衡参考。



容器 
核数
性能

单核权重
总权重





























提供更上层的服务接口
使用好弹性资源，仍然需要业务了解弹性资源本身，并做适配处理，比如和弹性计算平台集成，协调可用端口等，使用门槛依然较高，为解决这个问题，我们提供了云函数使用接口，如下图所示，类比存储，数据以文件为载体，用户上传下载数据无须关心分布，容灾，扩容等；计算以函数为载体，用户提交函数后无须了解函数执行背后的资源调度，容灾，扩缩容等，可更专注于业务逻辑创新。从弹性计算平台孵化出了腾讯云无服务器云函数，欢迎大家试用。

实践的经验教训
在建设弹性计算平台实践过程中，我们有一些经验教训，在这里和大家分享下。
提供机制还是策略？
➡故事：业务利用率扩缩容阈值设置不合理，高峰期保留大量资源没充分利用；业务设置很合理，高峰期确没资源扩容了。让用户自身做策略，难以达到整体最优，造成业务间资源利用不均衡，老实人反而容易吃亏；➡故事：平台默认打开自动扩缩容，自动调配资源；业务对自动扩缩容机制不知情，发起了版本变更，造成现网多版本共存。平台来做策略，难以了解完整业务流程，可能影响业务的可用性；在提供机制或策略的选择上我们有过反复，对于平台方，最理想的是将策略控制起来，以达到整体资源调度的最优化，但这里需要一个前提，平台能够收拢所有业务变更入口，如果做不到闭环，只能优先保障业务可用性，平台提供机制，由业务方自身实现策略，平台方通过其它手段，比如定期公布低负载业务，推动业务方主动关注资源高效利用。
扩缩容前先要负载均衡
扩缩容的目标在于将计算型业务维持在合理的负载，以实现质量和成本的均衡，但如果业务负载不均衡，扩缩容难以达到预期的效果，如下图所示：

➡当业务不均时，同计算业务下不同实例表现为个别实例负载高，以图片压缩为例，出现此场景的一般由于收到大图，此时扩容不能缓解高负载，反而容易导致更多实例空闲；➡当资源性能不均时，同计算业务下不同实例表现为部分实例负载高，出现的原因可能由于性能或在线业务负载差异，此时如果以整体平均负载扩容容易导致部分实例高负载，以前实例平均负载扩容，容易导致另一部分实例低负载；最完美的状态是同计算业务下各实例负载波动上下波动不超过，此时在扩缩容调度下，整体能保持在较高的负载而不影响服务质量，但这个需要业务和平台方共同努力才能实现：➡对业务方来说，要实现用户请求轻重分离，发送给同业务模块的请求，后台消耗的资源需基本一致，以图片压缩为例，需要业务方做好大小图分离；➡对平台方来说，需要更综合更动态的权重，为计算实例设置权重时，需综合考虑资源规格，硬件性能基准值，动态可用配额等多方面因素。
重视底层风险及能力
弹性计算依赖底层提供资源隔离，优先级调度等机制，底层的稳定性会影响整个平台的稳定性，且修复代价很大，在弹性计算早期，如下图所示，为了避免平台建设打扰到正常业务运营，规避机房间穿越流量，在容器存储选型上，我们选择了方案，因为此方案无须格式化磁盘。使用之前已了解到社区对此方案的应用存在很多问题，所以打齐了补丁，并采用灰度部署的方式以及时发现并解决问题，在规模不大时，问题并不突出，但上台规模，经常现网出现设备  等问题，有时需重启才能修复，影响了在线业务的体验。由于机制实现比较复杂，我们对短期内完全修复信心不足，不得已花大代价重新格式化，切换至实现上更简单的方案。

从这个例子，我们得到的经验是，底层技术要选择最简单，主流，被大家广为认可的，而不是存侥幸心理选择在当前条件下最容易实现的方案。另外由于底层故障修复代价过大，在规模上线前，最好配备热补丁修复能力，以在底层故障出现时低成本的修复问题。
结束语
感谢大家参加腾讯弹性计算的分享，希望通过此分享能抛砖引玉，能引发一些大家对资源高效利用的思考和实践，当前整个行业大概的平均利用率，有较大的提升空间，怎么去提升利用效率，减少对能源的浪费，应该是我们每一位从业人员的职责，欢迎大家一起探讨，今后一起提升做到更好。导语
专职做  已经  年多的时间了，一路上，跌跌撞撞，从小公司 ，到腾讯高级 ，再到现在的金融数据库 。看同行、同事犯了太多的错误，自己也犯了非常多的错误。一路走来，感触非常深。然而绝大多数的错误其实都是很低级的错误。 一如  年前的我，刚进入  行业，缺乏经验，经常犯错误，不是我不够努力，更多的是初来咋到的我根本不知道应该在哪方面下功夫。本文就是基于这方面的考虑，根据自己在  这个职业上走过的弯路，总结一些方法给  的同行。希望本文能给同行  或者运维的朋友们带来一些改变，让大家知道作为一个  需要在哪些方面下功夫。
专职做  已经  年多的事件了，看同行、同事犯了太多的错误，自己也犯了非常多的错误。一路走来，感触非常深。然而绝大多数的错误其实都是很低级的错误。有的是因为不了解某个引擎的特性导致；有的是因为对线上环境不了解导致；有的是因为经验不足导致；一路上，跌跌撞撞，从小公司 ，到腾讯高级 ，再到现在的金融数据库 。 不由得想起  年前的我，刚进入  行业，缺乏经验，经常犯错误，不是我不够努力，更多的是初来咋到的我根本不知道应该在哪方面下功夫。本文就是基于这方面的考虑，根据自己在  这个职业上走过的弯路，总结一些方法给  的同行。希望本文能给同行  或者运维的朋友们带来一些改变，让大家知道作为一个  需要在哪些方面下功夫。下面主要从环境、数据安全、常规操作、预案、架构、心态等层面，同时也会介绍一些实用的经验。
一、环境篇
毫无疑问， 是需要综合技能最多的一个职业，需要你有网络、操作系统、文件系统、数据库、安全、编程等知识。作为 ，为了少犯错误，你首先得非常熟悉你负责的数据库环境，大到网络环境、系统环境、数据库环境这里主要以  为例。如果不熟悉环境，很容易因为自身操作考虑不周而导致线上的故障。想想就知道，有多少  因为  操作导致的线上故障？有多少  忽略了字符集的问题导致了线上的乱码？又有多少  由于迁移的时候没有备份触发器或者  导致的故障？太多的教训足以让我们所有的  认识到熟悉环境的重要性。另外  对线上环境如果足够了解，在处理故障、讨论处理方案等，都能极大地增强我们的自信，更好地提升自己的影响力。我们可以说不熟悉环境的  不是好 。下面来介绍环境部分我们  应该注意的问题：
、软件环境
 操作系统环境
针对操作系统部分，你可能需要了解的是使用的操作系统类型，  ，该系统做了哪些内核的优化，尤其是针对数据库，比如文件描述符、配置 、 的写  模式等，另外你还要对系统的运行状态有大致的了解， 使用、内存使用、 使用以及网络带宽和包量的情况。
 数据库环境
数据库环境包含的内容就非常多了，这里只介绍如果不了解比较容易造成误操作的部分：
 部署方式
对于数据库的部署，我们需要了解数据库是如何部署的，部署在了什么目录，可执行文件、数据文件、 文件、配置文件等的存放路径，数据库如何启动和停止等
 使用引擎
了解目前数据库默认使用的引擎，以及现有的表使用的引擎，提前清楚地了解各个引擎的特点和使用，避免在出现数据迁移、表损坏以及启动问题手忙脚乱导致误操作。我们的技术就像武器库，都是靠平时闲淡中的积累和打造，在出问题的时候直接从武器库拿来使用，因此要经常丰富我们的武器库
备注：虽然现在基本使用的都是  引擎，但是，你也同样可以发现有的还用了 ，甚至还有的用到了 、、、 等。
 同步方式
目前  基本都会配置同步如果没有一定要加上，除非是数据丢了或者长时间故障也没关系的库，既然涉及到同步就会有多种不同的方式。比如常见的分类：

基于  和  的同步
基于  的同步
异步
半同步
单线程同步
多线程同步

针对这些同步，都有一些不同的特点，比如出现问题了，需要跳过某个位置， 的同步和基于  的同步操作就不一样，同步方式也是你必须掌握的技巧。
 版本
在维护数据库的时候，还需要了解当前数据库使用的大版本。因为数据库的大版本的功能会有很大的差异，有很多特性是只存在某个大版本的，因此了解使用的版本能让你大致知道当前数据库支持哪些特性。在涉及到迁移、同步、数据库升级等操作的时候，能从容应对。
 存储过程、事件
了解当前数据库是否存在存储过程和事件，在数据备份、数据迁移的时候，需要将对应的存储过程和事件的参数添加进去，另外如果存在事件，在迁移的时候会有特殊的操作，在迁移的目标机器要现将事件关闭，切换后再打开。防止事件导致数据不一致。
 关键配置
 有几项非常关键的配置，需要了解清楚，避免由于配置没搞清楚导致误操作，总结关键配置如下：

___

对  生效，对性能影响非常大，一般可以设置内存的 

__

对  生效，建议修改成 

_____

 的  日志刷新方式，对  的影响会很大，一般设置为 



是否开始 ，如果没有开启，一定要开启

_

刷  的方式，一般设置为 ，如果对数据需要强一致的，可以将 _ 设置为大于  的数，兼顾安全和性能

___

采用独立表空间，建议都设置成独立表空间，不然后面磁盘空间满了，删除表空间也无法释放，必须做数据迁移

___

表明区分大小写

__

字符集在迁移、数据库变更、数据导入等都是必须要注意的，不然数据乱码了就会很麻烦

_

最大连接数不能设置太大，要计算一下  内存_ 固定内存  总内存这  用来做系统内存，留给系统的内存可以再设大一点

_

设置隔离级别，默认是  ，如果是  是  模式，也经常设置为   级别
所有上面说的参数，都需要深入了解和熟悉，当我们在做数据迁移的时候或者搭建  的时候，一定要比对一下和源实例的配置比对工具可以参考  工具，以免迁移完成后由于参数不一致，中途要重启实例的情况。在这个问题上，我见过太多的教训，希望大家能吸取教训，减少故障和问题的发生。
 数据库环境收集工具介绍
前面我们介绍了数据库的相关的环境，对于那么多的环境变量，我们如何更好的去收集，这里给大家介绍一个工具



这个工具的具体用法可以  了解，也可以访问如下链接了解，不在本文的论述范围：

、硬件
硬件相关的信息也是我们需要关注的，针对每种硬件我们都会有大致的 、 等指标，这个对于新上业务的评估以及评估现在数据库的瓶颈很有帮助，对于硬件你需要了解  核数、内存的大小、硬盘的介质？   ？ ？，最好对线上的常见机型都有详细的压测数据。了解每一种机型在  中的表现，也是体现  专业度的一个指标。
经常有  由于不了解各个机型大致能支撑的性能 ，在方案选型和设备选型讨论中，无法肯定地确认具体需要什么设备，当前的设备配置是否能抗住对应的访问量，导致领导和开发对该  的专业度大打折扣。如果大家在日常工作中有空闲的机器，不妨使用 、、 等工具捣鼓一下。
、运行状态
作为 ，我们还需要了解现在的实例的运行状态，如下几个指标都是我们需要了解的：

数据库数据量和表的数据量
数据量到多少 ，尤其是单表的数据量
实例负载情况 负载、 负载、系统负载
慢查询情况
 延迟情况
锁情况
脏页情况
访问模型

访问模型就是这数据库承担的是读多写少还是读少写多，以及是否是高并发等等
针对上述问题，可以采用  工具获取，再加以分析，也可以通过如下两个工具来实时查看




二、数据安全篇
针对数据安全，主要包含如下几个部分
、权限安全
在权限方面，我们经常会看到有很多的数据库根本就没有密码，或者给业务的用户使用完全的权限 ，或者是给某个帐号可以从任何地方登录的权限，这些都是非常致命的。建议在授予权限的时候注意如下几点：

数据库一定设置符合密码复杂度的用户密码
禁止给用户设置的登录机器
只给业务最小权限的帐号，并限制登录的机器

、数据一致性
目前一般都是主从架构，主从的数据是否一致？以上的主从架构都缺乏数据一致性校验，之前遇到主从切换后数据不一致的情况，导致线上故障。
为了保证数据的一致性，记得周期性地使用  来检查主从数据是否一致，如果不一致，可以使用  进行修复。
、数据安全
做为 ，经常要思考，如果数据被误删，在现有的环境下是否会导致数据丢失。如果会，那就是你  工作没有做到位。主要考虑的指标为：

备份策略数据库备份、 备份
这里主要考虑  件事情：

 数据备份策略是否合理
备份策略至少包含全量备份，和  增量备份，由于有从机，基本  都会比较安全
 备份数据是否安全
备份数据是否安全，比如备份机器挂掉，是否所有的备份数据都会丢失，可以采用分布式文件系统或者在服务器中交错存放来规避。
 备份数据是否可用
常常问自己，我们的备份数据都是有效的吗？周期性做备份数据还原的演练是必要的，确保备份数据的有效性。
三、常规操作篇
在操作数据库的时候，首先我们需要熟练常规的操作，常规的操作又分为两部分，一个是线上数据库的常规操作，一个是针对常见故障的预案的常规操作。熟练了操作和预案，才能在线上出问题的时候不至于手忙脚乱。
、常规操作
常规的操作一般包含如下几项

启动停止
数据库常规变更
索引优化
配置修改
数据库的备份
数据的迁移
切换

以上这些操作，包含的内容太多， 们可以自行 。总之要达到非常熟练的地步。如果命令记不住，建议将常规的操作通过关键字标记，并记录到类似印象笔记的文档中，要急用的时候可以快速搜索到。也可以写成工具脚本，随时调用。
、常见故障的预案
作为 ，经常要面对各种突发的故障。大家要先搞清楚，不是遇到了故障我们才去找解决办法，而是在没有遇到故障之前就应该想到某一部分可能会出现问题，如果出现问题，我们应该当如何来应对。比如  出现故障，我们当如何处理？当你想到某个地方可能出现问题，那么就先将解决方案写出来。然后再找环境测试解决方案的可行性。验证了方案可行性之后，最好在线上安排对应的案例演习，确保解决方案可靠的。最终达到的效果是任何团队的任何一个成员对照文档都能处理类似的故障。
、极端情况下的预案
除了常见故障的预案，我们还应当思考极端情况下可能出现的故障虽然可能永远都用不上，比如数据库主从都挂掉的情况。最好能拉上业务和开发的同学一起讨论，得出可行性的解决办法，然后找环境验证。当问题真的出现后，你会比没有预案的时候镇定很多，不至于一脸懵 。
、定期演习
预案做好以后最好能定期安排演习，开始搞互联网金融后有更深的体会，这边基本每个月都会有常规的演习。定期演习非常必要，通过演习，将演习过程中发现的问题都梳理出来，进行各个击破，确保各个预案都能正常工作。
四、架构篇
、你是一个合格  吗？
作为运维 ，肯定会接触到数据库的架构和业务架构，之前我们总监要求新入职的员工必须对你所要负责的数据库架构进行串讲，将不清楚的，不能直接上岗做线上操作。这个无疑是非常正确的，尤其是在腾讯这种公司，很多后端的逻辑都通过  进行封装，导致你能看到的只是  页面上的各个功能简单的按钮。只要轻轻一点，就能将很复杂的功能完成。这个对于后端逻辑没有好奇心的人是非常致命的。出了问题就找开发，导致自己的能力没有任何的提升，甚至还会在这种点鼠标的工作中日益退化。因此在架构篇部分其实想和大家聊的是在我们点鼠标的同时，还是要深入地去了解点鼠标背后发生的事情，知道异常如何分析和排查。甚至要再大胆一点，你也可以尝试着通过  或者  等语言去实现那些背后的逻辑，不要把自己局限在只是一个 。因此我们在做运维的时候，不妨好好的问自己几个问题：
我点了鼠标之后，后端都干了什么事情？ 需要和哪些服务交互 ？
如果点完鼠标以后，报错了，需要如何进行排查？需要到哪里看日志？需要如何处理？
问完这两个问题，更次一点的是找研发详细了解里面的运行逻辑，以及部署详情，日志存放，出现问题如何排查等。更好的办法，是找研发要代码，然后自己去看对应按钮后面代码的逻辑。有的同学会说，我编码能力差，看不懂。这个不用担心，相信我，要基本看懂研发写的代码其实并没有那么难。践行一下你就会知道。等你看完研发的代码，估计很快就可以自己写一个类似的功能出来。
、你真的了解线上的架构吗？
现在数据库高可用架构比较多，不管是单纯地使用主从架构、、、 或是集成了 、 等组件，我们都不应该仅仅停留在正常情况下会搭建、操作和使用对应的架构。更多的是，我们需要更深入的去了解里面运作的机理。就以  为例，它是如何检测某一个实例异常的？各个组件之间如何配合？当做切换的时候， 是如何保证数据的一致性？如果后端有多台 ，它是如何选择哪一台从机做切换，并且，其他从机如何处理？只有深入了解了逻辑之后，在遇到故障和问题，你就能更快速的进行定位，减少对业务的影响。此外你还能有针对性的做自动化，让自己工作更轻松。这么好的事情，为什么不践行一下？
、了解业务
还有一个问题，就是作为  要尽可能的去了解业务，了解业务的读写模型，了解业务相关架构，了解业务如何使用数据库。这样做的好处是你能针对业务的场景给出更好的优化建议，出了问题也能快速判断对业务的影响情况。
五、线上操作篇经验
 面对线上复杂的环境，尤其是面对高并发的环境，很容易导致线上故障，下面是整理的一些容易导致线上故障的操作以及规避误操作的技巧，希望能对各位  有所帮助：
、修改或删除数据前先备份，先备份，先备份重要事情说三遍、线上变更一定要有回退方案、批量操作中间添加 、 操作要谨慎，对于大表的  操作最好使用 、变更操作先在测试环境测试、重启数据库前先刷脏页、禁止批量删除大量的 、对于变更操作一定要写详细的操作步骤，并 、按  之前再进行一次环境确认、如果你的操作可能会使状况变得更糟，请停止操作、快速处理磁盘满，使用  释放文件系统保留块、连接数满先修改内存变量，而不是重启，修改方式如下：
     _= 

 是  的对应的 
六、心态篇
、心细胆大
从某种意义上讲， 是一个高危的行业，不是开玩笑，看看下面的截图就知道：

风险本身是个伪命题，对于某些人来说是风险，但是对于某些人来说其实没有风险。就像医生做手术一样，我们常人看来就是个非常危险的事情，但是对于医生来讲，其实并没有什么风险大部分的手术。因此风险在于你是否已经了解深入，并且做足了功课。这就要求我们在做线上操作之前要心细，有详细的操作步骤，有想尽的回滚方案，做完备的测试。这些做完了以后，你的胆子才能大起来，胆大是因为你心中有底，心中有自信。这些自信都是前面你做功课带给你的。
、勇于担当
出现问题本身并不可怕，可怕的是选择逃避。我们要做的就是正视问题，吸取教训，勇于担当。做好  ，防止团队在同一个地方跌倒两次。
、工匠精神
今天看到同事发的一个朋友圈很有感触，在没有人注意的地方也不懈怠、不偷懒的精神，才是真正的工匠精神。做为  也同样非常需要这种精神，对于遗留问题的跟进不能偷懒；对于备份异常的巡检不能偷懒；对于技术的积累不能偷懒；工匠精神是我们  在做日常管理工作不可缺少的精神。
有句话说的是：我们之所以经常犯错，就是因为我们做的功课不够。如果你有很多功课拉下了，请安排事件逐步补上，要坚信一切都是闲淡中求来，热闹中使用。有的事情知道了本身并没有什么了不起，了不起的是那些坚持践行的人。践行起来，你会发现你的人生从此不同。导语

作者介绍：郑建军，来自广州的微信事业群，基础平台组高级工程师。

主要分享内容：

项目介绍；
协议过程与实现；
优化与设计分析；
基于的读写。


本部分深入浅出的介绍了的定义，的五大特点，的部署情况及处理能力以及对于微信业务的支撑。

本部分将从协议出发，在明确的定义、在分布式系统中能解决的问题及协议涉及的角色后，以一个“只接受一个到达的提议”这样简单的算法出发，由浅入深的介绍了协议的推演，在遇到了故障发生数据丢失时如何继续参与协议交互；以及协议实现难题的基于原始状态{}表格化计算解决。

在了解了协议过程与实现之后，本部分首先介绍了三机架构及下的协议优化：预授权优化以及三机架构多主可写、允许空洞、三份数据副本、细粒度化、快消型的设计要点

在了解了协议过程与实现、优化与设计分析之后，本部分将着重介绍的读写操作。


本演讲整理来自“腾讯大讲堂”。导语
本演讲整理来自“软件开发者大会”且演讲文稿等已获得作者授权。
演讲主题 ：腾讯云架构设计之道
 腾讯内部有很多海量业务，在这些海量业务的设计、研发、运营中已经总结了很多非常好的理念和思想，本主题将通过腾讯云的架构及设计，来一一阐述这些理念及思想 在实际中如何落地。
本文主要使读者了解： 了解一个典型的高性能系统设计过程中 需要关注的点及对应的解决方案？ 了解腾讯云的一些架构及设计。


在了解了可用性定义、影响可用性的因素及架构设计与业务场景的关系后，我们继续思考如何在架构层面提升可用性以及腾讯典型的设计思想。



无可避免地，变更是任何软件开发过程中都一定程度上不可避免的问题，如何面对、优化这个高可用的最大敌人，减少变更带来的故障也就成为了一定要面临的挑战。



赶在客户之前按发现问题、快速处理问题、实现“能不处理的不处理、能自动处理的自动处理、最后在人工干预”在服务器端程序开发领域，性能问题一直是备受关注的重点。业界有大量的框架、组件、类库都是以性能为卖点而广为人知。然而，服务器端程序在性能问题上应该有何种基本思路，这个却很少被这些项目的文档提及。本文正式希望介绍服务器端解决性能问题的基本策略和经典实践，并分为几个部分来说明：

缓存策略的概念和实例

缓存策略的难点：不同特点的缓存数据的清理机制

分布策略的概念和实例

分布策略的难点：共享数据安全性与代码复杂度的平衡


缓存策略的概念
我们提到服务器端性能问题的时候，往往会混淆不清。因为当我们访问一个服务器时，出现服务卡住不能得到数据，就会认为是“性能问题”。但是实际上这个性能问题可能是有不同的原因，表现出来都是针对客户请求的延迟很长甚至中断。我们来看看这些原因有哪些：第一个是所谓并发数不足，也就是同时请求的客户过多，导致超过容纳能力的客户被拒绝服务，这种情况往往会因为服务器内存耗尽而导致的；第二个是处理延迟过长，也就是有一些客户的请求处理时间已经超过用户可以忍受的长度，这种情况常常表现为占用满额。
我们在服务器开发的时候，最常用到的有下面这几种硬件：、内存、磁盘、网卡。其中是代表计算机处理时间的，硬盘的空间一般很大，主要是读写磁盘会带来比较大的处理延迟，而内存、网卡则是受存储、带宽的容量限制的。所以当我们的服务器出现性能问题的时候，就是这几个硬件某一个甚至几个都出现负荷占满的情况。这四个硬件的资源一般可以抽象成两类：一类是时间资源，比如和磁盘读写；一类是空间资源，比如内存和网卡带宽。所以当我们的服务器出现性能问题，有一个最基本的思路，就是——时间空间转换。我们可以举几个例子来说明这个问题。

水坝就是用水库空间来换流量时间的例子
当我们访问一个的网站的时候，输入的地址会被服务器变成对磁盘上某个文件的读取。如果有大量的用户访问这个网站，每次的请求都会造成对磁盘的读操作，可能会让磁盘不堪重负，导致无法即时读取到文件内容。但是如果我们写的程序，会把读取过一次的文件内容，长时间的保存在内存中，当有另外一个对同样文件的读取时，就直接从内存中把数据返回给客户端，就无需去让磁盘读取了。由于用户访问的文件往往很集中，所以大量的请求可能都能从内存中找到保存的副本，这样就能大大提高服务器能承载的访问量了。这种做法，就是用内存的空间，换取了磁盘的读写时间，属于用空间换时间的策略。

方便面预先缓存了大量的烹饪操作
举另外一个例子：我们写一个网络游戏的服务器端程序，通过读写数据库来提供玩家资料存档。如果有大量玩家进入这个服务器，必定有很多玩家的数据资料变化，比如升级、获得武器等等，这些通过读写数据库来实现的操作，可能会让数据库进程负荷过重，导致玩家无法即时完成游戏操作。我们会发现游戏中的读操作，大部分都是针是对一些静态数据的，比如游戏中的关卡数据、武器道具的具体信息；而很多写操作，实际上是会覆盖的，比如我的经验值，可能每打一个怪都会增加几十点，但是最后记录的只是最终的一个经验值，而不会记录下打怪的每个过程。所以我们也可以使用时空转换的策略来提供性能：我们可以用内存，把那些游戏中的静态数据，都一次性读取并保存起来，这样每次读这些数据，都和数据库无关了；而玩家的资料数据，则不是每次变化都去写数据库，而是先在内存中保持一个玩家数据的副本，所有的写操作都先去写内存中的结构，然后定期再由服务器主动写回到数据库中，这样可以把多次的写数据库操作变成一次写操作，也能节省很多写数据库的消耗。这种做法也是用空间换时间的策略。

拼装家具很省运输空间，但是安装很费时
最后说说用时间换空间的例子：假设我们要开发一个企业通讯录的数据存储系统，客户要求我们能保存下通讯录的每次新增、修改、删除操作，也就是这个数据的所有变更历史，以便可以让数据回退到任何一个过去的时间点。那么我们最简单的做法，就是这个数据在任何变化的时候，都拷贝一份副本。但是这样会非常的浪费磁盘空间，因为这个数据本身变化的部分可能只有很小一部分，但是要拷贝的副本可能很大。这种情况下，我们就可以在每次数据变化的时候，都记下一条记录，内容就是数据变化的情况：插入了一条内容是某某的联系方法、删除了一条某某的联系方法……，这样我们记录的数据，仅仅就是变化的部分，而不需要拷贝很多份副本。当我们需要恢复到任何一个时间点的时候，只需要按这些记录依次对数据修改一遍，直到指定的时间点的记录即可。这个恢复的时间可能会有点长，但是却可以大大节省存储空间。这就是用的时间来换磁盘的存储空间的策略。我们现在常见的 日志型数据表，以及源代码存储，都是使用这种策略的。
另外，我们的服务器，在发送文件内容的时候，往往也会先用压缩，然后发送给浏览器，浏览器收到后要先解压，然后才能显示，这个也是用服务器和客户端的时间，来换取网络带宽的空间。

在我们的计算机体系中，缓存的思路几乎无处不在，比如我们的里面就有级缓存、级缓存，他们就是为了用这些快速的存储空间，换取对内存这种相对比较慢的存储空间的等待时间。我们的显示卡里面也带有大容量的缓存，他们是用来存储显示图形的运算结果的。

通往大空间的郊区路上容易交通堵塞
缓存的本质，除了让“已经处理过的数据，不需要重复处理”以外，还有“以快速的数据存储读写，代替较慢速的存储读写”的策略。我们在选择缓存策略进行时空转换的时候，必须明确我们要转换的时间和空间是否合理，是否能达到效果。比如早期有一些人会把文件缓存在分布式磁盘上例如，但是由于通过网络访问磁盘本身就是一个比较慢的操作，而且还会占用可能就不充裕的网络带宽空间，导致性能可能变得更慢。
在设计缓存机制的时候，我们还容易碰到另外一个风险，就是对缓存数据的编程处理问题。如果我们要缓存的数据，并不是完全无需处理直接读写的，而是需要读入内存后，以某种语言的结构体或者对象来处理的，这就需要涉及到“序列化”和“反序列化”的问题。如果我们采用直接拷贝内存的方式来缓存数据，当我们的这些数据需要跨进程、甚至跨语言访问的时候，会出现那些指针、、句柄数据的失效。因为在另外一个进程空间里，这些“标记型”的数据都是不存在的。因此我们需要更深入的对数据缓存的方法，我们可能会使用所谓深拷贝的方案，也就是跟着那些指针去找出目标内存的数据，一并拷贝。一些更现代的做法，则是使用所谓序列化方案来解决这个问题，也就是用一些明确定义了的“拷贝方法”来定义一个结构体，然后用户就能明确的知道这个数据会被拷贝，直接取消了指针之类的内存地址数据的存在。比如著名的 就能很方便的进行内存、磁盘、网络位置的缓存；现在我们常见的，也被一些系统用来作为缓存的数据格式。
但是我们需要注意的是，缓存的数据和我们程序真正要操作的数据，往往是需要进行一些拷贝和运算的，这就是序列化和反序列化的过程，这个过程很快，也有可能很慢。所以我们在选择数据缓存结构的时候，必须要注意其转换时间，否则你缓存的效果可能被这些数据拷贝、转换消耗去很多，严重的甚至比不缓存更差。一般来说，缓存的数据越解决使用时的内存结构，其转换速度就越快，在这点上， 采用编码，就比不上直接的一个结构体，但是比编码成纯文本的或者要来的更快。因为编解码的过程往往要进行复杂的查表映射，列表结构等操作。

相关推荐下一篇 高性能服务器架构思路：缓冲清理策略二 弹性缓存缓存系统在游戏业务中的特异性变量
计算机中变量是一个标识符或者名称。
在计算机中提供给变量两个信息

变量地址 ，操作系统给变量分配的若干内存的首地址 
变量的值 ，内存单元中存放的数据

从变量的存储位置进行区分，可分为 内存 和 的寄存器 两类
从变量的生命周期进行区分，变量分为静态、动态存储两种
静态存储 存储在内存的静态存储区，编译时就分配了存储空间，在运行期间有固定的存储单元，程序结束后，才会释放。
动态存储 存储在动态存储区中，只有变量所在的函数被调用时，才会临时分配一段，程序调用结束后，空间便会释放。
而在语言提供种存储类型
 自动 静态 寄存器 外部
外部变量和内部变量的区别 
外部、内部变量的区别十分简单，内部变量指的是函数内的变量，函数外的变量便是外部变量全局变量。外部变量可以被其他文件所使用，他的存储方式是静态存储，它的生命周期等同于整个程序 对象 ，全局变量。而内部变量仅能被作用域内访问，他存储方式是动态存储，它生命周期在超出作用域后会被回收。对象
全局变量和静态变量的区别 
在语言中，可以使用声明一个静态变量，也可以在函数外声明一个全局变量，其他文件使用对该变量进行访问。他们两者的存储方式都是使用静态存储方式，存储在内存的静态存储区。
他们之前的差别在于 全局变量的作用域是整个程序。跨文件而静态变量的作用域则是当前源文件，其他源文件不可访问。
说到这，即 不可以用来修饰 ，因为他们两者思想便是冲突的 用于跨源文件，用于限制变量在当前源文件中使用。
他们的作用正好相反。
 的作用是用于多文件数据共享
 的作则是用于数据隔离
例如如下

 
  =
   = 
 
{
       
}

 
 
  
 {
       \
     
}
 其实不是常量！
语言中经常会使用 修饰符，限定一个变量不允许被改变。防止意外的修改。但是 变量经常会被是常量，其实  变量是只读变量，不是常量。
下面的例子证明 并不是常量。运行下面代码会报错。因为指定数组大小时应该使用的是常量
     __ = 
    __ = 
既然 修饰的不是常量，那 变量能否被修改？
下面的代码访问了的指向的内存区域，并且修改了他的值
      = 
      =  
      = 
    = 
    =    =    =  \
    =   =    =  \
下面是输出的结果
 =    =    =  
 =   =    = 
可以看到三者打印的指针是一样，但打印的值依然是，其实修饰的值读取的是数据段，通过指针读取的数据保存在堆栈段。
其实提供了一种保护机制，保证变量只能从数据段中读取数据，确保了他不被改变。
表达式
表达式是由常量、变量、函数和运算符构成的。运算符大致分为算术表达式、关系表达式、逻辑表达式、赋值表达式、条件表达式和逗号表达式等。因语言表达式语法灵活，很有必要为提高程序可读性，在开发时遵循一些改善的建议。
机器上减少使用除法与求模运算
硬件上不支持除法运算，编译器调用库的函数来实现除法运算，如需要除法运算中是程序中的瓶颈所在，可以通过减少除法运行来进行优化。
避免相似的操作符混淆
避免 = 与 == 混淆
开发时，常用到 == 与整型数据进行判断，这种情况下，如果漏写一个=会容易导致逻辑出现问题
如下例子，=由于写少了一个=，导致语句永远也无法走到条件中。
   = 
 ={
    
 }{
 }
解决的办法是将对比常量提前，若少写=时，编译器便会提前报错，这样可以在一定程度上避免误写的发生。
   = 
 =={
    
 }{
 }
避免使用复杂的复合表达式
开发过程中应该避免使用复杂的表达式如下方的例子，应该尽量避免
  = 
===
\
  语句无论子语句多少，都应使用{}包括
形如如下的 语句不使用{}包含时经常会让后来的代码维护者读代码时十分头疼

     = 
      
         = 

    = 
正确做法，为每个 、 加上对应的{}。这样会让代码更加清晰。
{
     = 
      {
         = 
    }
}
{
    = 
}
循环中尽量将逻辑判断语句置于循环外层
如极限情况下例子会执行次判断
  =    
{
    
    {
        
    }{
        
    }
}
以下判断语句置于外层时，极限情况下减少次。当循环次数很大时，这样的小优化是值得的。

{
      =    
    {
        
    }
}

{
      =    
    {
        
    }
}
注意与的使用
 是一种类型的新别名， 而宏是简单字符串替换
宏定义的作用时间是在 预处理阶段
 的作用时间是在 编译阶段
在使用宏定义期望替换类型时，切记不可同一行类声明两个变量
    
    
  
  
预处理后
   
 
  
此时的类型均是此时 类型是  而 的类型是一、账号体系
想要进行开发，除了必备一台装有  的开发机  之外，还必须要有苹果开发者账号，只有拥有开发者账号，才能申请开发发布证书及相应配置文件，项目才可以发布到 上。
开发者账号分为两种类型：

个人或公司开发者账号：能够在指定的设备上进行真机调试，可以在发布项目。

个人账号和公司账号的区别：个人账号注册流程快，没有团队角色管理。只能一个用户登录操作；公司账号需要注册邓白氏码，企业营业执照，流程复杂，流程耗时长。有角色管理功能，能邀请多个分不同角色管理。

企业开发者账号：企业账号还不同于公司账号，企业账号能够进行，企业内部发布，鹅厂的发布应用，不能发布，更像是企业内测账号。

注意：第一类中的公司账号和第二类中的企业账号不是一码事，虽然听上去公司和企业是有些相似的概念。
如果我只是想本地开发练手，并不想发布到 上，也是可以不必花钱就能进行真机调试的。以后，苹果放宽了开发者的范围，只要一个真实的苹果账号在 里下载应用的或者用于的账号即可。详情请见
二、打包
 一个能在自己的手机上运行，和能放到 里被所有人下载还是不一样的。当我们开发完，肯定想要发布到 供人下载，这个过程中，我们不是直接把写好的代码发给苹果公司就完事了，而是要把自己的代码像发快递一样打个包装，发给苹果公司，由它审核通过，允许发布到 才能上线。嗯，就是说我们是淘宝卖家，苹果公司是我们的收件人，它收到货后确认收货我们才能拿到钱。
但是在这个过程中会有一个问题，如果别人冒充我的名义发给苹果公司一份恶意代码包怎么办？苹果公司岂不是要给我差评？我岂不是很冤？为了避免这样的问题，在苹果 中上线的应用都需要通过一套数字证书签名机制来确保项目代码的来源是可信任的，代码是完整的，未经他人修改的。这套机制基于非对称性加密也称为公钥加密算法，开发者用私钥对代码进行签名加密，苹果公司用包含公钥的证书进行验证。
不同的开发者账号可以打的包也不同，大体可以分为版还是版，具体打包分类如下：
个人／公司开发者

：本地调试使用



 ：可供有限个登记到开发者中心设备中的设备安装使用

 ：发布到 版本


企业开发者

：本地调试使用



 ：可供有限个登记到开发者中心设备中的设备安装使用

 ：企业内部使用，没有测试机的数量限制，我们大鹅厂的就属于 类型。用企业证书打包应用的最大好处是：应用可以安装到非越狱的设备上运行，这样很方便进行较大规模的测试、或公司范围发起内部体验，企业证书打包的应用禁止外发。


这里详细说一下 模式， 这种方式主要是为了给测试人员或者内部体验人员安装我们的程序以供测试使用的，对于大公司来说，让他们每个人都拿着手机连到开发机进行安装显然是不现实，我们需要打包我们的程序。
 方式就是在上架前最大程度的呈现出上架后的状态，它与上架到的包唯一的区别在于 的包可以在指定机器上安装，而上的包需要苹果重签名才能安装到设备上。也就是说， 模式需要用证书并以方式打包，但是它可以指定设备。
打包的过程需要申请发布证书、配置文件等，每种打包模式必须对应各自的证书和配置文件，下面就详细介绍一下这个过程以及其中涉及到的一些文件的主要功能。
  
   是一款应用的唯一标识，应用与 之间是唯一对应关系。应用新建成功后， 将不可修改，如必须修改只能创建一个新的应用。

  
开发者需要在开发者中心下图的页面点击加号来注册自己的，通过 用于标识一个或者一组，  应该是和中项目的 是一致的或者匹配的。开发者可以在下面的位置点击加号创建 。

每创建一个 ，我们都可以设置该 所使用的 ，也就是其所使用的额外服务。

下面是目前所有可选的服务和相应的配置要求。按照这个要求去配置你的以获得相应的服务。

 主要有以下两种：

  ：唯一的 ，这种 用于唯一标识一个应用程序，例如，标识 为的程序。  要与 一致。

  ：通配符 ，用于标识一组应用程序。例如可以表示所有应用程序，而可以表示以开头的所有应用程序。对于  ，只要 包含其作为即可。


在某些时候我们可以使用通配符，但是通配符无法完成推送功能。也就是说，如果要使用   ，则必须是一个  ，以便能唯一标识一个应用程序。
需要着重说明一下，是一款应用程序在苹果全平台的唯一标识。正好前两天同事们讨论一个问题： 一个的程序能不能既作调试使用又能发到？答案是可以的，在开发者中心配置的设备可供调试使用。
更进一步，、和发布到 的项目能不能是同一个？答案是否定的。因为企业账号可以发版本的项目，却不能发 ，而是全球唯一的，一个账号创建了，其他账号无法再创建。所以一般公司如果想发版本的企业内测包，通常是有两个账号，公司账号用来调试和发布，企业账号用来发布版，也就是说，和 、的肯定是不一样的，至少有两个。像大鹅厂这样的大公司，由于调试／发布的账号由专人统一管理，不能给到各个产品，所以我们必须自己购买一个专门用来调试的账号，这也就导致了我们的项目有个三个。
 证书
首先来说证书，顾名思义，证书就是为了证明某些信息真实性的凭证。不过可能不同人或者机构对真假的判断都不一样，说是真的，说是假的，证书也不过是证明签发证书的机构的态度而已，真真假假这么哲学的问题我们就不讨论了，毕竟要到苹果公司的 上线程序，苹果爸爸的态度决定一切。也就是说，我们的信任起点就是苹果公司，所以首先我们需要一个根证书  ，根证书是一切证书的合法性的来源，其含义就是“我们认苹果爸爸说的一切”。根证书一般不需要自己去申请，以及  系统在安装时将自动安装。但是根证书需要及时更新，如果过期了，其他所有证书都会失效，会报      错误。再次提醒，一切苹果公司的证书都依赖于根证书，根证书是其他所有证书的基础。
除了必须的根证书以外，我们开发、调试项目还需要证书，发布项目还需要证书。结合前文说到的账户体系和各自可以打的包，个人／公司开发者和企业开发者都有开发和真机调试程序的功能，都可以申请各自的证书。在发布项目方面，个人／公司开发者和企业开发者权限不同，证书也不同。个人／公司开发者可以给制定设备安装版本的包、可以向 发送人人都可以下载安装的包；而企业开发者账号不能在 上线程序，只能发在企业内部体验使用的包，比如咱们大鹅厂的包。
  证书就是用来调试  的证书，需要特别注意推送证书的对应关系。推送证书也分为两类：开发环境和生产环境的。的证书对应推送的开发环境证书，  的证书对应推送的生产环境证书。此外，推送的开发环境和生产环境的对应的推送环境是不一样的，需要对应苹果后台测试推送的地址环境和生产推送的地址环境 ，如果对应关系搞错都会收不到推送。

具体来说，证书就是文件，包含开发者信息和公钥信息，用于验证代码是否由该开发者的合法私钥签名过。开发者使用开发账号登陆苹果开发者网站即可申请后文有申请过程，当开发者下载并双击打开证书文件后，证书会出现在钥匙串里。它与本地钥匙串里的私钥匹配之后，开发者就可以使用它了。
 文件
一个开发者账号可以申请的证书数目有限，当我们需要多人合作开发的时候，不能每台机器都去申请证书，这种情况下正确的做法是，一台机器去申请钥匙串和证书，然后生成出文件，分发给其他开发机安装，使得其他开发机也“拥有”了证书。文件就是证书安装到本地后，与本机私钥后生成的备份文件，其中包括证书和私钥的信息，也可以称为“备份证书”，跟身份证复印件差不多。
  文件
 文件就是一份配置信息文件，后缀为。打包或者在真机上运行一个，一般要验证以下几个信息：

首先，需要证书对应的私钥来进行签名，用于标识这个是合法、安全、完整的；

其次，需要指明它的 ，并且验证 是否与其一致；

然后，如果是真机调试，需要确认这台设备是否授权运行该。


 把这些需要验证的信息全部打包在一起，方便我们在调试和发布程序打包时使用。 也分为和两类，有效期同一样。如下图在中配置好各自所需的文件，就会根据需要打出不同的包。

 作为打包必备的一份文件，其中包含以下信息：

：一个 对应一个  或  

使用了哪些证书： 决定了用哪个证书公钥私钥组合  来签名应用程序

功能授权列表

可安装的设备列表：  文件会在应用程序打包时嵌入到包里，进而安装到设备上，是设备的信任凭证，证明其中包含的设备，是个合法的测试设备。版本的主要用于提交 审核，其中不指定开发测试的。 审核通过上架后，允许所有设备上安装运行该。

苹果的签名：由于 文件是苹果签名的，我们必须从开发者中心申请，申请后也不能再随意篡改比如添加别的设备。


三、申请流程
对基础的东西有一个了解之后，我们来过一遍申请的流程。
申请钥匙串文件
我们申请一个证书之前，需要先申请一个    文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你的钥匙串中。
进入

找到

选择左上角的钥匙串访问证书助理从证书颁发机构请求证书，输入自己的邮箱，选择存储到磁盘，继续。

设置好存放钥匙串的位置，存储。


申请下来到钥匙串会出现在系统【钥匙串访问】中

申请证书
使用开发者账号登录苹果开发者中心





这样就下载到了我们需要到证书文件。
配置设备信息
在开发者账户中配置的地方点击右上角“＋”可以增加某个的设备，注册后的该设备可供调试使用。

在里可以查看注册过的所有可用于开发和测试的设备，普通个人开发账号每年累计最多只能注册个设备。用户可在网站上启用禁用已注册的。但是 一台设备也不会增加名额，只能在  开始的时候才能通过删除设备来增加名额。
申请 文件
在开发者账户中“ ”“”点击右上角“＋”

选择开发或发布证书配置文件，这里以开发为例，点击  ，继续

选择对应的 ，继续

选择要关联的证书，可多选，继续

选择之前注册过的，用于调试安装的设备最多台设备，如果是生产证书配置文件，则不会出现该页面生产证书用于发布，不能进行开发调试，继续看到以下界面

输入文件名后，点击“”，配置文件创建成功。
设置   
选择合适的 和证书对代码进行签名，打包。作者：陈星百，腾讯移动客户端开发 工程师
商业转载请联系腾讯获得授权，非商业转载请注明出处。
原文链接：
 导读
做了大概半年多应用了，由于双眼渲染的原因，对性能的优化要求比较高，在项目的进展过程中，总结了一些关于移动平台上的性能优化经验，供分享。在《移动平台 应用性能优化上》中介绍了一部分内容，本文将补充接下来部分
一、应用性能优化之
一般人说的优化占了软件优化的三分天下，那么的优化也占了三分天下。在了解优化都有哪些着手点之前，我们先了解一下在软件渲染中做了啥事：
顶点着色器
接收顶点数据作为输入传递给顶点着色器。顶点着色器的处理单元是顶点输入进来的每个顶点都会调用一次顶点着色器。顶点着色器本身不可以创建或销毁任何顶点，并无法得到顶点与顶点之间的关系。顶点着色器是完全可编程的，它主要完成的工作有：坐标变换和逐顶点光照。 坐标变换：就是对顶点的坐标进行某种变换—把顶点坐标从模型空间转换到齐次裁剪空间。顶点的多少直接决定了三角形面的多少，也直接决定了的渲染流水线的工作量，所以减少顶点数是一个比较重要的优化点。那么减少顶点怎么操作呢，又有哪些途径？、优化基本几何体软件都是从模型制作开始，在设计师建模的时候就要想到应该尽可能地减少顶点数，一些对于模型没有影响、或是肉眼非常难察觉到区别的顶点都要尽可能去掉。比如在项目中，对于用户背后的环境模型，一些树木和石头，视频背面永远无法看见的神庙，能削减的都已经削减了。
、使用  技术技术有点类似于技术，不同的是，是对模型建立了一个模型金字塔，根据摄像机距离对象的远近，选择使用不同精度的模型。它的好处是可以在适当的时候大量减少需要绘制的顶点数目。它的缺点同样是需要占用更多的内存，而且如果没有调整好距离的话，可能会造成模拟的突变。
、使用遮挡剔除 技术遮挡剔除是用来消除躲在其他物件后面看不到的物件，这代表资源不会浪费在计算那些看不到的顶点上，进而提升性能。刚才神庙后面的剔除就属于手动的遮挡剔除。
遮挡剔除是一个版才有的功能， 当一个物体被其他物体遮挡住而不在摄像机的可视范围内时不对其进行渲染。遮挡剔除在图形计算中并不是自动进行的。因为在绝大多数情况下离  最远的物体首先被渲染，靠近摄像机的物体后渲染并覆盖先前渲染的物体这被称为重复渲染 遮挡剔除不同于视锥体剔除 视锥体剔除只是不渲染摄像机视角范围外的物体而对于被其他物体遮挡但依然在视角范围内的物体，则不会被剔除 注意当你使用遮挡剔除时，视锥体剔除 依然有效。
中间操作
、曲面细分着色器：是一个可选的着色器，主要用于细分图元。
、几何着色器：是一个可选的着色器，可用于执行逐图元的着色操作，或者被用于产生更多的图元。
、裁剪：这一阶段是可配置的。目的是把那些不在视野内的顶点裁剪掉，并剔除某些三角形图元的面片。部分在视野内的图元需要做裁剪处理，在裁剪边缘产生新的顶点和三角形进行处理。
、屏幕映射：这一阶段是可配置和编程的，负责把每个图元的坐标三维坐标系转换成屏幕坐标二维坐标系。
、三角形设置：开始进入光栅化阶段，不再是数学上点了，而会把所有的点都映射到屏幕的具体像素坐标上，计算每条边上的像素坐标而得到三角形边界的表示方式即为三角形设置。
、三角形遍历：这一阶段会检查每个像素是否被一个三角风格所覆盖。如果覆盖的话，就会生成一个片元一个片元并不是真正意义上的像素，而是包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。
这些状态包括了屏幕坐标、深度信息，及从几何阶段输出的顶点信息，如法线和纹理坐标等。，这样一个查找哪些像素被三角形覆盖的过程就是三角形遍历。
片元着色器
片元着色器的输入就是上一阶段对顶点信息插值得到的结果，更具体点说，是根据从顶点着色器中输出的数据插值得到的。而这一阶段的输出是一个或者多个颜色值。这一阶段可以完成很多重要的渲染技术，如纹理采样，但是它的局限在于，它仅可以影响单个片元。片元着色器是比较花时间的，因为它是最终颜色的计算者，在某些情况下，例如复杂灯光环境下，片元着色器会出现流水线主要的拖后腿的存在。为了让片元着色器的计算更加快，我们需要从很多方面进行提前的优化：、尽量减少片元着色器最容易拖后腿的情况就是，！和 的开发一样，就是同一个像素点绘制了多次，某些情况会造成计算力的浪费，增加耗电量。前面提到的遮挡剔除有减少非常有用。在上，资源无限，为了得到最准确的渲染结果，绘制顺序可能是从后往前绘制不透明物体，然后再绘制透明物体进行混合。但是在移动平台上，对于不透明物体，我们可以设置从前往后绘制，对于有透明通道的物体很多纹理就是含有透明通道的，再设置从后往前绘制。中设置为“” 队列的对象总是从前往后绘制的，而其他固定队如“”“”等的物体，则都是从后往前绘制的。这意味这，我们可以尽量把物体的队列设置为“” 。对于，尤其要注意和设计师商量，能用不透明的设计就用不透明的，对于粒子效果，也要注意不要引入透明值，多半情况下，移动平台的粒子效果透明值没有作用。
、减少实时光照移动平台的最大敌人。一个场景里如果包含了三个逐像素的点光源，而且使用了逐像素的，那么很有可能将 提高了三倍，同时也会增加。这是因为，对于逐像素的光源来说，被这些光源照亮的物体要被再渲染一次。更糟糕的是，无论是动态批处理还是动态批处理其实文档中只提到了对动态批处理的影响，但不知道为什么实验结果对静态批处理也没有用，对于这种逐像素的都无法进行批处理，也就是说，它们会中断批处理。
所以当你需要光照效果时，可以使用，提前烘焙好，提前把场景中的光照信息存储在一张光照纹理中，然后在运行时刻只需要根据纹理采样得到光照信息即可。当你需要金属性强镜面的效果，可以使用 。当你需要一束光的时候，可以使用体积光去模拟这个效果。
、不要使用动态阴影动态阴影很酷，但是对于片元着色器来说是灾难，阴影计算是三角投影计算，非常耗性能。如果想要阴影，可以使用 、简单的使用一个带阴影的贴图 、烘焙场景，拿到 、创建投影生成器的方法 、使用的方法目前还没有研究。
、尽量使用简单的、建议尽量实用自带版本的，这些大大提高了顶点处理的性能。当然也会有一些限制。、自己写的请注意复杂操作符计算，类似等都是很耗时的计算，最多只用一次在每个像素点的计算，还有有些除法运算尽量该能乘法运算等。、避免透明度测试着色器，因为这个非常耗时，使用透明度混合的版本来代替。、浮点类型运算精度越低的浮点计算越快。、不要在中添加不必要的 
二、应用性能优化之内存
中有两类内存，一个是托管的内存相当于的内存，一个是使用的资源类类型的内存、这种。
内存
、尽量不要动态的和 ，使用 。
、不要动态的产生字符串，使用字符串的直接拼接，使用代替。
、一些东西，在里面尽量避免，如、这样的调用，可以在中预先存起来。
、尽量减少函数调用栈，用 =       代替 = 。
、定时重复处理用  函数实现。
、减少的调用，使用 或内置组件访问器会产生明显的开销。您可以通过一次获取组件的引用来避免开销，并将该引用分配给一个变量用的最多。
、使用内置数组内置数组是非常快的。或类很容易使用，你能轻易添加元件。但是他们有完全不同的速度。 内置数组有固定长度，并且大多时候你会事先知道最大长度然后填充它。内置数组最好的一点是他们直接嵌入结构数据类型在一个紧密的缓存里，而不需要任何额外 类型信息或其他开销。因此，在缓存中遍历它是非常容易的，因为每个元素都是对齐的。
类的内存
这类内存包括、 里有两种动态加载机制：一个是，另外一个通过其实两者区别不大。 就是从一个缺省打进程序包里的里加载资源，而一般文件需要你自己创建，运行时 动态加载，可以指定路径和来源的。
运行时加载：
来自文件就用注意这种方法只能用于程序，就不提了。
也可以来自用这个可以来自文件读取的缓冲，的下载或者其他可能的方式。其实的就是内部数据读取完后自动创建了一个而已，完以后，等于把硬盘或者网络的一个文件读到内存一个区域，这时候只是个内存镜像数据块，还没有的概念。
下图是的加载卸载示意图：
是如何加载的呢？用同 这才会从的内存镜像里读取并创建一个对象，创建对象同时也会分配相应内存用于存放反序列化。异步读取用，也可以一次读取多个用。
如何释放呢？
是释放文件的内存镜像，不包含创建的内存对象。
是释放那个文件内存镜像和并销毁所有用创建的内存对象。
、对于选择使用 压缩格式的，对于选择压缩格式的，纹理可以节省大量内存和读取速度快，但是会有所降低图像的质量。
纹理如果没有必要不要使用会约增加的内存开销，曾经在上吃过亏。模型的纹理一般是需要的，但是如果确定了模型距离摄像机的距离，在分析器上确定了使用的纹理，就可以保留，关闭比如项目中的。
有合并和压缩坑比较多，不建议使用。
粒子效果只要记住使用之后及时释放销毁就行。

针对手游的性能优化，腾讯平台的工具提供了基本所有相关指标的检测，为手游进行最高效和准确的测试服务，不断改善玩家的体验。
目前功能还在免费开放中。，欢迎点击链接： 使用。一、写在前面的话
作为如今托管平台最重要的服务之一，几乎所有的线上业务多多少都在使用，那么其稳定性和维护的高效性必然成为我们所关注的一个重要的问题，在【经典案例分析】这一专题中，我将与大家一起学习关于维护的相关内容，把真是业务环境中遇到的维护问题与大家分享，共同积累维护的经验，提高托管平台服务的高效和可靠性。
二、案例分析
、案例的由来
 是最早接入托管平台的业务，其使用的旧的服务机制下图左，故存在无法多自动同步数据和监控项不完善的一系列痛点，其数据只能依靠多地复写的方式，保证各个内数据的一致性，各间数据不要进行严格的一致性校验，容易造成数据一致性出错的现象。

在新的服务机制中上图右，通过改造同步机制，实现了多自动同步的机制理论上支持任何一地写入，自动多同步，使得业务在写入数据时只需要单点写，多地自动通过内置的同步自己进行同步和校验，严格的保证了数据一致性。
、出现的问题
正常来说当我们迁移一地以后，会先确定数据的一致性，接着进行其他两地的自动同步，但是在进行业务从旧架构到新架构改造过程中，当我们迁移完成一地之后，进行验证时，业务反馈其数据出现了不一致的现象，即写入的部分数据，无法获取的情况。
三、思路和方法
简单来说，问题就是在迁移完之后的架构中数据的同步出现了问题。下面来我们一起来一步一步的排查下这个问题：
、自查迁移操作出错？
可以检查下再执行搬迁操作时候的操作流程是否出错，其中特别注意在手动数据的时候各“”格子“的一一对应关系是否有错。

、同步机制机制有？
 检查一下是否迁移后的业务可以正常的进行多地同步。方法如下：
①首先分别在深圳、上海、天津的中一个，确认其不存在值为
 ②接着在深圳的上这个 ；
③分别在上海和天津两地的上刚刚写入的，如果均可以得到正确的值，即说明其同步机制并没有问题。
、中间件名字服务配置和解析？
①配置问题
在中查看名字服务读名字、写名字的关联是否已经修改，删除旧或是权重为，添加新。【数量较多时需要仔细更改和核对，避免重蹈我的覆辙，一眼花，漏改了一个，结果就悲剧了，现在心情极度低落】

 ②解析问题
关于解析名字服务的问题，这里就介绍两种常见的方式：
 第一种只能检查名字服务本身在的配置同步上出现问题：
 名字
由于名字下过多，这个命令时随机返回，应该大量多次的执行该命令，查看解析出的地址是否是配置过的，是否会出现已经删除或者不属于该业务的。
   第二种可以同时检查业务使用的解析逻辑
在旧业务上添加扩几个新的为了减小对业务的影响，数量应与原先的一致，通过调整原先所有的的权重调整为，观察业务此时的数据是否能保证一致性。
、业务源头使用不规范？
①是否有长链接【这一步应该最排查】
在旧业务机器上为了保险起见，防止原先业务直接连接的，在和上均检查，通过  |  端口 ，查看一下是否还有长链接，如果有，那么很有可能不同步的问题是由于业务此时还是用其链接将数据写在旧的机器上，造成新机器中没有此数据。
②业务写入不规范
 当你排查完操作流程、同步机制的问题以后，如果还是无法解决，那么此时就不要太难为自己了，很可能问题压根就出现在业务的写入逻辑或者代码逻辑上。
正常来说当我们迁移一地以后，会先确定数据的一致性，的业务逻辑如下：

此时正常情况，当业务向已经迁移的”深圳“写入数据时，是不存在数据不一致的现象，但如果业务的写入流程是下图这样，就会出现问题了。此时业务写入的数据由一部分将写到“上海“和“天津”中，这样就造成了数据的不一致。

四、经验分享
由于开发使用读写名字的不定性，为了防止这一种虽然看似简单，但却隐藏的十分好的原因，同时又因为在没确定数据一致性的情况下，不能轻易配置自动多同步，那么在验证一地数据一致性的时候切记，可以先将原先的读名字中其他地方的权重调为，然后进行数据一致性校验。作者：何方舟

在介绍组件化方案之前，先对  和  做一个简单介绍。
 
理想中的组件化，第一步应该就是组件的标签化， 例如有一个  组件，如下图所示

无需关注组件内部的实现，我们只需要使用一个  标签就能调用它，通过设置属性的方式，来控制它的显示的内容，和对应的事件。
    {
      {
        
             ={} ={} ={}
        
    }
}
 决定点击关注时会触发的事件 决定左侧展示的主播信息 坐定右侧展示的成员信息   
借助  语法， 已经实现上述想法。
 
在简单的应用中，上面的组件化方案是非常清晰的，因为  组件被任何其他组件使用，且没有任何副作用。
但是由于  的数据流向是单向的， 子组件的数据和方法只能由父级组件赋予，一旦组件嵌套层次变深，传递数据将会变得非常复杂。
拿上面的  组件来说， 它的内部还使用了  和  两个组件， 把它接受到的数据和方法，又需要传递给了  和  。

    {
      {
         ={} ={} 
         ={}
    }
}
当然有人会认为直接在  中申明所需要的数据和方法，不再从父级获得，这样不就解决了深层嵌套的问题吗，但是如此一来数据就和组件耦合到一起了，不同项目使用的  的数据源一般是不同的，这意味着你需要为每个项目都要写一个 ，提供不同的获取数据方式。  
另一方面在假设另一个组件下载条  中也有使用  这个数据，那么  中也需要维护这个数据。

如果两个组件内部的  发生变化，那么都需要通知另一个组件也发生变化，因为  应该是唯一的。大型应用中不同组件共享同一个数据源的情况是常见的，如果都让组件自身来维护一份的数据，很容易造成数据混乱。
 框架解决了这个问题，简单来说，它将  由父级传递数据，变为了由一个统一的数据源  单向地向各个组件传递数据。

原始的  架构 


加入了  的架构之后的

所有数据都存放在  中，组件内部不维护任何数据。  
 提供了  方法来触发改变  中数据。  传入的值被称作 。  之后，会进入到  中称为  的处理函数，这些  会依据不同的  的类型，进行不同的处理， 返回的值就会作为  中新的数据，一个  对应的是  中一个数据字段，每多一个，  中就多一个数据字段。数据发生改变后，  就会通知对应的组件重新渲染。
通过  框架提供的  高阶函数， 直接从  选取需要的数据和申明需要使用的方法传入组件中，这些申明的方法是组件事件具体的逻辑的实现，例如发送请求，上报逻辑等等，所以通常调用  的逻辑也会包含在里面。
在  作为  组件库的基础上，以  作为状态管理框架，我们定义了种类型的组件。
展示组件
 组件即为我们的展示组件。它内部不会维护任何动态的数据，除了部分只和组件本身有关的数据，例如  组件中， 播放状态，就是它内部才会拥有的状态，而 播放源 就必须从外部传入。它不会包含各种事件具体的实现，只提供对应的接口如 ，具体的实现都由外部调用者去决定。
存储中心组件
存储中心组件即为上文提到的  架构中的 。 存储中心组件中默认定义了一些  处理函数和一些 ，还包含了连接  和  的高阶函数和向  中注入新的  的方法。
数据组件
数据组件即为  架构中某个 和 对应的  的合集。数据组件提供了各种  可以去调用，并且定义了对应的  去处理，数据组件中必须引用存储中心组件，因为数据组件必须向  中注入对应的  处理函数。例如在  的数据组件中，提供了    这些  供调用者使用，且自动向  中添加了  这个数据。
数据组件中也会存在互相依赖的情况，例如  会例如  这个数据组件，因为  的  中需要对  的 也进行处理。
高阶组件
高阶组件即为经过   高阶组件中申明使用的展示组件和数据组件。  函数处理后的展示组件。通常情况下，被使用的组件一般都是高阶组件。高阶组件确定向该展示组件传入的属性和方法。高阶组件是和业务耦合的，复用性不强。高阶组件高度聚合，而展示组件和数据组件间又充分解耦。
一个高阶组件中可能包含多个数据组件，例如  这个展示组件，需要由提  和  这两个数据组件提供数据。
高阶组件可能不会引入任何数据组件的方法，只需  对应的数据组件，将 注入进 
 
接入组件

申明存储中心组件。
申明合适的高阶组件。
如果没有对应的高阶组件，则申明展示组件和数据组件，创建为新的高阶组件。
如果没有对应的展示组件，则创建一个需要的展示组件。回到
如果没有对应的数据组件，则创建一个需要的数据组件。回到
编写入口文件，引入各个高阶组件。


实际开发时我们的样子可能是这样的


我们接到了一个新的需求，其中大致布局和之前的项目完全一致，改变的点有，这个业务只在 手 中执行，而且视频的数据源由一个新的  提供。
确认我们需要的组件在这个例子中，需要用的组件有
 头部
 视频
 消息
 点赞
 工具面板

在  上查找高阶组件，发现以下高阶组件

  

  

  

其中可以直接使用的组件有

  

通过  安装对应组件

    

 定义的  事件只能在   中才能执行，所以不能使用。
 中引用的数据组件使用的  数据是一个旧版  数据，也不能使用。

在项目中自定义一个新的  高阶组件， 使用的展示组件和数据组件与  中的一样，任然是 展示组件 和 数组组件， 只是通过  链接的时候， 传入的方法 为新的方法。通过  安装对应的展示组件和数据组件 

   
创建新的  高阶组件 
    引入展示组件
    引入数据组件
   

   = {
     {
         
    } = 

     {
        
    }
}  = {
     {
          = {
            _ 手中改为调用  提供的  接口
        }
    }
}

在项目中自定义一个新的  的高阶组件，使用的展示组件为现有的  因为使用了一个新的 ， 先新建一个的数据组件 _，数据组件必须引用  中的  方法，向中注入新的字段。

_

 {
    
}  

   { 定义函数
    
}

   = {  定义 处理函数
     
}  {
    
}

{  向中注入新的数据
    
}
在新的  高阶组件中引入，这个数据组件和 通过  安装对应的展示组件

  
创建新的高阶组件 
    引入展示组件
 {}  _ 引入申明的数据组件

   = {
     {
        
    } = 

     {
         
    }
}  = {
     {
          = {
             
        }
    }
}

编写入口文件 引入现有的和刚新建的组件，组装页面。


  {  }   引入基础框架
 {   }  

    引入管理组件

    引用高阶组件
   
   
   
   

    { 创建  根组件
      {
         
             = 引用各个组件
                 

                 

                       

                 

                 
            
        
    }
}

  =   实例化管理组件

  =  {  
     
}



     ={}    
             
    
    
 渲染 
例如上面代码，需要通过  组件 将 注入进  即可。
架构的优势

组件的引用简单。
展示组件和数据组件之间的分离实现了低耦合，而连接两者的高阶组件实现了高内聚。
全部由  管理，模块管理方便。
即使使用了不同了数据管理架构，也可以直接使用展示组件。

一些待解决的问题

公用的  无法管理，需要引入新的构建工具
开发调试不方便，无法单独独立的开发一个组件
组件文档缺失。
缺乏测试用例，组件迭代后不能保证可靠性。


原文链接：作者：富途牛牛团队

富途牛牛股票是一款提供港股和美股证券开户及交易服务的产品，也是基于腾讯云快速开发的第一批小程序之一。富途牛牛股票小程序  月  日上线首日总用户数超过 ，使用总次数超过 。
富途牛牛股票小程序页面：
产品逻辑
小程序在产品设计之初，团队就秉承着，从场景出发，快速高效解决用户需求的理念。希望用户由真实场景触发，使用富途的小程序解决问题，然后离开这样一个路径。
富途牛牛本身不是一个轻量级的产品，而小程序的出发点却是轻量和效率提升，因此我们分析了，什么样的用户会在哪些的场景下，会需要使用一款股票类的轻量小程序，产品总结主要有以下两种场景：
、用户以股票关注者为主，偶尔需要关注几只股票的价格，有买入股票的需求，但非常低频，这部分用户，实在没有必要安装一个  在手机里，通过小程序即可解决。、用户有持仓，但是长期持有，偶尔关注一下持仓股票的价格，持仓盈亏等信息。
产品设计最终聚焦在「低频」、「基础服务」这两个关键词上去做产品功能规划。最终呈现的富途牛牛股票小程序的功能，简单，轻量，实用，是基础的股票服务的体验。包括大盘行情，市场行情，个股行情，资讯，账号体系，资产查询，线上开户，以及正在实现的交易功能。
开发心得
富途作为小程序的第一批开发者，痛并快乐着。
最大的感受还是，微信的同事执行力和效率。官网上  基本  天就会更新，开发者反馈的问题最晚  小时内能够得到答复。
开发过程中，遇到了非常多的问题，但是大部分微信已经解决了。如果你是第一次开发微信小程序，以下经验应该可以给你带来帮助，特别是在架构设计和交互设计上。以下是印象比较深刻的问题：

代码资源 = 
 栈只有  层，第  层的时候直接抛异常
 的并发数为 之前是 ，第  个直接抛异常
小程序不能外跳跳  等，所有的活只能在小程序内干完
没有二进制流文件读写的 
提供  形式是永久存储，限制  大小
 是单线程的

解决方案
设计的时候，把这些因素都考虑进去。例如，代码只有 ，我们就把迭代分的尽量小，避免砍代码。 栈只能  层，交互设计的时候，就只能按照这个规则来。因为是快速开发，一般来说，都是把文档读的比较细，然后再开发。遇到问题，半天解决不了的，就反馈给微信同事。写的这几点经验对第一次开发小程序的人来说，对其代码合适和交互设计是极有好处的。我见过，代码写完后，超过 ，然后砍代码，砍的那个痛苦。
腾讯云小程序解决方案使用感受
整体架构跟腾讯云官网的差别不大：

使用腾讯云的产品，主要有：

云服务器
云负载均衡
域名 
 接入
对象存储
 加速
云 
云 

下面是来自富途后台开发同学提交的真实感受：

：不用自己维护一套  服务器， 之类会整死运维啊。备案流程更清晰，   不用东找西查，节省时间；
 支持：证书就在一个地方，不用拷来拷去。腾讯云这部分相当于证书管理系统，免费管理，也不需要证书部署到每台机器；
对象存储：不用说，分布式存储实现一套成本非常高，拿来就用多爽；
 加速：集成各个运营商，全国布点，一网打尽。腾讯云已经成为  行家；
云 ：无限扩容的云 ，不用关注复杂的数据支扩容流程。页面轻轻一点，即刻扩容完成；
云数据库 ：主从同步不再烦恼，申请即成。还有异地部署，实现真正异地容灾。扩容即在一瞬间，一点即可。

小结
富途牛牛作为首批上线小程序之一，在微信小程序开发过程中踩过一些坑，使用腾讯云小程序解决方案加速了这一开发进程。整体来说，小程序对于互联网创业公司而言已经成为  外不可缺少的一环，期待看到更多开发者入坑。

相关推荐
简约而不简单——大众点评小程序开发经验谈
自选股微信小程序深度漫游指南
新增线下、、公众号多处入口，小程序会再火起来么？内有福利作者：陈航特
团队：腾讯移动品质中心

从年开始，应用宝的主体工程就开始往多进程方向发展，至版本发布时主工程已完成多进程改造，而彼时应用宝的子进程基本不涉及，自动化测试框架采用的方式，基于注入主要负责单个内的自动化测试支持跨应用的自动化测试，因此彼时应用宝的多进程改造并没有影响到自动化测试。
应用宝多进程后，就暴露了目前业界主流自动化测试框架的不足，支持自动化但仅限于注入单一进程，支持跨进程但却不支持自动化，其它的支持自动化的框架例如、等等在原理上均与相类似采用注入执行提取元素，因此也不支持跨进程的自动化。
本文介绍一种在多进程情况下支持自动化测试的方案。介绍当前自动化的简要原理、多进程后的问题、相应的解决方案及使用方法。
一、端自动化原理简介
端支持自动化的测试框架如、、等等在原理上基本类似，都是采用注入被测后，执行脚本，提取并封装成拥有元素的文本信息、或等属性、坐标信息等等的对象。
首先，进入的模式，访问例如应用宝中视频的页面。

然后，进入的控制台：    执行如下脚本：

可以看到浏览器的提示框显示了为 元素的信息。

可以看到，通过注入的方式，我们可以获取网页中的包括文字、标签、属性、坐标等等信息。
那么，如果我们也能够在上用的这种方式获取每个网页元素的信息，然后对这些信息进行封装处理，那么在自动化测试时就可以操作这些元素了。
类在中，主要用于辅助处理的对话框、提示框等等

如上图，以为例，当加载网页时，如果有调用了弹出提示框，则将会被调用，该方法中的 参数即为显示在提示框中的提示语，即如下图中的提示语将传递给参数

以下是中的实现：

获取到后，然后按一定规则对进行分解，然后封装成对象

简要原理图如下：

二、多进程后的问题
由端自动化的原理可知，核心是注入后，获取目标，对该执行以提取元素。多进程后，运行在子进程中，而注入的是主进程，且由于的沙箱机制导致在主进程中无法获取子进程中的控件对象，也就是注入后，无法获取子进程中的目标，示例图如下：

出现该问题后，解决思路主要有两个方向：
、让注入子进程而不是主进程：经尝试后发现在注入时，会判断当前进程名，即当前进程名需要与测试工程文件中申明的一致，而子进程的进程名为主进程包名加后缀的形式，即：。若直接修改，在申请时又不能带：号，因此该方向不可行。
、将测试中获取目标及执行等等模块移植到子进程执行，再通过跨进程通信将执行结果传回测试，此方向可行。
三、多进程后的支持自动化测试方案
上文第二中的第二个方向虽然可行，但结合项目实际情况还需要优化改进方案，在项目侧会有以下要求：
、应用宝严格控制安装包大小，因此支持自动化测试相关代码若移植入子进程，显然会增大不少安装包的大小。那么采用开关控制打包？
、项目正在做持续交付流程，自动化所测包即为最终希望发布的包，因此测试代码需要对外发布。
终上，最后方案确定为将测试代码采用插件化的方式，将主要实现代码在插件中实现，应用宝子进程中只实现少量的调用插件的代码，对安装包影响小、安全风险可控。方案示例图如下：

另外，由于应用宝使用了手机浏览器提供的 浏览服务，在子进程中可能出现系统或者，两者在实现元素提取时有所不同，需要区别对待，整体方案的核心逻辑流程如下图所示：

、测试发送命令：在端自动化测试中，要想完全支持的测试，除了获取的元素外，还有例如获取页面的链接、标题、进度条、上下滑动等等，因此本方案以命令字的方式来区分这些不同的操作。
、支持自动化测试的代码以插件方式实现，子进程收到命令时，需要先判断是否需要安装插件，插件采用工程进行开发，最终编译生成的是一个插件，需要安装插件时则从手机上的指定目录安装插件。
、映射：插件需要能支持 的自动化测试，因此插件工程需要引入提供的，但在编译时不打包进插件。应用宝内使用内核提供的服务时，也是用的提供的，且是以插件形式使用，因此本方案中的插件在实际运行时要找到 中的类时需要做映射。
、判断当前子进程在用的是否是 ：若是 ，则走 相应的执行、提取元素的流程；若是系统，则走系统相应的执行、提取元素的流程。
、测试解析并封装成测试发送的命令为获取元素时，插件提取到的元素是以数组转字符串形式进行存储，因此解析时该数组每个元素就对应于一个元素，可以封装成对象。若发送的命令为例如获取的链接、标题等等时，则无需解析。
获取更多测试干货，请搜索微信公众号：腾讯移动品质中心！ 浅谈
作为传说中的替代品，现在 已经被开始在一些前端项目中使用了，比如阿里的一些产品已经将的模块切换到下了。个人感觉 会渐渐替代成为主流。
什么是 呢，我们来看个例子。
、简单使用  = 
 {   } {    =    = } {      }怎么样，是不是很直观的了解了 的使用，从上例中我们可以看出两点：
、 返回的是一个对象，使用提供的特性，可以改写为  =    {   {        =          =          =        =   }  {          }}    这样看起来是不是爽多了，只是现在这个特性还只是在草案中，虽然已经可以支持了。、第一个函数里面处理的是的格式，这里的具体返回如下：

可见对象提供了多种转换格式的方式，用于将返回值的类型转换为，，也可以使用等方法，这里就不赘述了。
的状态和返回数据也可以从，，等对象中获取到，还能直接读取到返回值的信息。
、综合使用作为替换的，需要足够底层，这样，就需要支持各种场景的使用。下面是一些综合使用示例。
头部和请求构造 头部构造，使用类  =     = {                 这个很重要，当值为时才会带请求} 传参 ； 如果需要复用请求的参数和头部等对象，可以采用   =   请求参数构造 是使用通过构造部分直接进行的，可构造的类型为  {       }、使用中需要知道的兼容性

如所示，的在上全军覆没，在其他很多浏览器上也有各种问题，所以，这里推荐使用 
  
传递必须在参数里面加上  ‘’配置，才会如一样将当前带到请求中去
和的不同虽然底层，但是还是缺少一些常用有的方法，比如能够取消请求方法。
在服务器返回， 请求时是不会抛出错误的，这里需要手动通过，中的字段和字段来做判断。
、展望    盛行多年， 从写法上给前端带来了一些新的想法，这无疑是好的。同时，我也相信，前端慢慢会出现类似的包装库，方便大家使用吧
、参考 传统  已死， 永生  前言
本节为大家讲解腾讯云主机上测试编译的过程。

首先是什么？它是新出的一个布局格式，对移动端开发非常方便。
说一下我为什么要提取。有需求才有动力，首先是需求，最近在开发一个移动端适配的网站，使用了框架，基于。使用时，已经内置了许多样式，但是的一些多余样式会影响一些现有样式，而那些样式对我又没啥用。另外对于移动端布局开发非常适合，这次正好也拿来练练手。
移动端开发是趋势，随着移动端的发展，也出了新版本，不过现在还是版本，还没正式推出。
其中一个比较大的改进便是 系统。
原本最常用的布局栅格化系统在做响应式开发的时候比较方便，但是只针对于移动端开发的时候并没有多大用处了，流行的布局应用越来越广泛。
在中，看到过有了这种布局，它就是适应手机开发的框架。后来也增加了这块。
那么 系统相比之前什么改进呢？请看官方文档实例。

 别去上什么中文网，全是错误，实例结果有问题。不想吐槽，一开始我还以为是 设计不科学。
准备工作
首先下载 。
 
目前最新版还是版本，如链接失效，请移步官网。

然后你需要安装了，，自行下载即可。

开始抽取
下载之后打开源代码文件夹，找到目录，可以看到如下的结构，在这里我用打开更直观。

是一些可调用的组件，本身编译不会产生任何结果。是一些公用的包，比如我们要抽取的就在这里面。
外面的这么多是一些公用的基本组件。
通过官方文档可以发现：
 ’      —    —’         
  _      
     
  
   ’                          
如果我们想要添加组件，还需要将这个变量更改，即将改成才可以，默认是。
在源代码中我们可以发现已经有了一个的文件，然而这里面发现直接引入了的所有代码，这并不是我们想要的，它可能会复写一些基本样式，会影响我们的工程。我们想要的是单独把部分抽离出来。
所以我们自己新建一个 的空文件。
首先将变量改为
 
然后阅读源码可以发现有两个公用的文件是必须引入的。
和，我们先将他们引入。
 
 
然后观察带有的代码，只发现了在文件夹中有相关内容，跑不了了，那就是它，复制到同一路径，引入一下。
 
不过发现这个文件里的样式颇少，内容如下：
  

       

  {
      {
       
      {
      {} {   }
      {} {   }
      {} {   }
    }

        
      {
      {} {   }
      {} {   }
      {} {   }
    }

       
      {
      {}   {   }
      {} {   }
      {} {   }
    }

        
      {
      {} {   }
      {} {   }
      {} {   }
      {} {   }
      {} {   }
    }
  }
}
这才多点啊？看官方实例明明用到了，这些样式好不好。再看看。
于是乎发现这些实际上也是依赖于原始的样式的。我们必须也要把它引入进来。
找找，发现了三个相关文件，拷贝过来，引入。
 
 
 
嗯，这下应该全了。
编译代码
官方用的是自动化工具，然而我用着并不习惯。在这里我们用到来编译。
首先  初始化一个 
引入一些包
   {
     
     
     
     
     
     
     
     
     
     
     
     
  }
整体如下：
{
   
   
    
   
   {
      \   \   
  }
   
   
   {
     
     
     
     
     
     
     
     
     
     
     
     
  }
}
执行
 
安装一下 _。
然后生成一个文件，因为我们要用的语法，内容。
{
   
    
  
}

         
   
   
   
   
   
  = 
  = 

  = {
     
    
    
    { } 
    
    {
           
         
         
    }
    
}

  

  

  = {
     
}

   = {
    
}
最后执行下
    
   
  
     
  
  
  
     
     
     
  
     μ
这样就编译好了
测试
恩接下来我们来测试一下官方实例是否正常。
新建一个内容如下
 
 =

     =
    
     = =


 =
     =
         =
              
        
         =
              
        
    
     =
         =
              
        
         =
              
        
         =
              
        
    


 =
     =
         =
              
        
         =
               
        
         =
              
        
    
     =
         =
              
        
         =
               
        
         =
              
        
    

 =
     =
         =
              
        
         =
               
        
         =
              
        
    
     =
         =
              
        
         =
               
        
         =
              
        
    

 =
     = 
         =
               
        
         =
               
        
         =
               
        
    
     = 
         =
               
        
         =
               
        
         =
               
        
    
     = 
         =
               
        
         =
               
        
         =
               
        
    

 =
     = 
         =
               
        
         =
               
        
    
     = 
         =
               
        
         =
               
        
    
     = 
         =
               
        
         =
               
        
    
     = 
         =
               
        
         =
               
        
    
     = 
         =
               
        
         =
               
        
    

 =
     =
         = 
              
        
         = 
              
        
         = 
              
        
    


     {
         
    }
      = {
         
         
            
              
    }
      {
         
            
    }




结果如下：

恩，完美！
至于这个布局的用法，那就去官方文档领悟吧，和之前的栅格化布局有比较大的不同。
不过如果你看了实例之后，就会豁然开朗了。
代码
本用例代码已上传到 。

有兴趣的小伙伴可以下载测试。
相关推荐如何在腾讯云上搭建一个人力资源腾讯云主机环境安装爬虫框架过程导语
之前写的测试平台的时候，里面有一个机器管理列表信息，使用表格来展示的，数据量大概有多条，需要用到分页。之前没有接触 ，而是网上随便找了一个表格样式，嵌套了进去。后面做分页又使用了 。做好之后发现，其实 也不完全适用我的场景，稍微心里好受点。。
如果想要看 做表格以及分页的就网上找资料吧，挺多的。
 也是，现在我主要是再次分享一下我的使用经验。
使用简单，就两步操作如下：
后台页面文件引用了三个 的包，然后主要逻辑按照如下格式对     _变量做一下分页处理打包成变量
   
   
   

                  前台页面访问的时候调用此方法
    _=                               这里默认查询_=第一页的数据
       
        _= 

                                        省略逻辑计算查询结果_

     = _       默认每页展示条数据
    
         = _
     
         = 
     
         = _

       
  渲染页面的时候，参数是，里面包含的信息。循环展示表格内容之后，按照如下格式，对变量做一下分页判断

{     }
        
        {{  }}
        {{  }}    这里是渲染表格的内容
        {{  }}
        
{  }


 {  _ }            这个是分页的判断
  = =上一页 =={{ __ }}
 {  }
 {    _ }
         {   ==  }
                  =_ =当前页{{  }}{{  }}
         {  }
                  = =={{  }} ={{  }}{{  }}
         {  }
 {  }
 {  _ }
          = =下一页 =={{ __ }}
 {  }
两步就结束了因为是测试工具，功能就可以了。当然如果想要做更加好看点，可以上网找点其他资料，或者可以使用做分页每当重构页面的时候，除了设计师精致的设计稿，还需要在页面这个蛋糕上放上一个樱桃，无论蛋糕多么美味，但樱桃的点缀却更容易吸引住顾客的目光，对，就是那些细微的动画——金币蹦出后飞入钱袋、树叶随风飘落、流星划天而过……
以上种种效果都涉及一个无法回避的难题，曲线——该如何用技术手段去实现有曲线的动画，常用的办法有，，等，但各自都有技术局限性。



技术
设备兼容性
其他问题





兼容
需要脚本，调试难，需要额外标签，不适合做辅助动画



部分不兼容
需要额外标签，调试难


 
不兼容
调试难



兼容
无法做曲线效果



这是一份尴尬的分析表，因为做动画谨当细细打磨，但以上几种都需要不停地定位元素、调试效果，其中的工作量投入产出比偏低。花太多的时间在看似简单的效果上，就如精心地在蛋糕上放一颗樱桃，一口就没了。
于是我开始考虑如何把这颗樱桃，咳咳，这动画可以更轻快地点在页面上。
需求确定
一句话描述关键需求—— 重构中，可以快速的在重构界面中绘画出曲线的运动路径，并让元素在路径上运动，最终输出重构内容。
这句话中还包含了一些隐藏的场景：
、方案具有兼容性
、移动端重构中可以使用，，等单位；
、动画的相对位置可以基于界面中的某个坐标，而不是左上角；
通过这些要求，我们可以开始去找是否有合适的工具
工具分析

 是前端重构的调试利器， 在板块中，我们可以通过调整属性值时间／形变／过程，实时地看到动画的变化。

然而，面对沿曲线移动的动画难题，暂时无能为力。
  是其中最接近需求的工具：

通过上图其实可以看到，界面简洁直接，包含了“实时动画”，“路径编辑”，“关键帧属性”，“输出”等等核心等功能，实操后发现，绘制曲线动画路径需要依靠多段线段模拟，而且路径中的整体动画速度是非匀速的。
至此不得不着手考虑自己做一个工具。
需求提炼
重构中，可以快速的在重构界面中绘画出曲线的运动路径，并让元素在路径上运动，最终输出重构内容。
通过需求，从中提取关键字并分析开发工具所需要的具体功能，结合自己前端能力，列出详细方案



工具承载
等现代浏览器




重构中
工具使用用户：开发，交互设计；工具使用场景：开发过程，交互创意动画设计过程；


重构界面
解析：即参照物，能在真实或模拟的重构界面如界面，直观地看到元素在界面上的动画效果；实现方式：在工具页插入动画元素图及界面背景图


绘制曲线
解析：模拟钢笔工具的操作模式，达到快速绘制曲线的效果实现方式：钢笔工具即多段的三次贝塞尔曲线，工具页面中用技术实现曲线绘制和调整，支持按键快捷操作


路径上运动
解析：元素沿路径按属性运动实现方式：要按属性运动的前提，是需通过函数将三次贝塞尔曲线转为连续的点，根据时间线均匀返回该点坐标


输出重构内容
解析：能够替代重构中繁琐或重复的工作内容实现方式：考虑到兼容性和应用场景，排除及输出，通过工具替代脚本操作成本，输出代码片段 


拓展功能
、输出内容兼容、、多个动画同页面制作



得出界面如下

工具开发过程
钢笔工具的操作设计
路径操作的设计中，由于中钢笔工具的操作较为复杂，同时结合多个快捷键辅助操作，故将钢笔工具的功能分解成如下表：       



模式
操作




钢笔工具模式
点击空白添加锚点，点击锚点移除锚点，点击线段插入锚点


控制点模式
点击拖拽空白处添加锚点并调整控制点，点击拖拽控制点调整控制点，点击拖拽锚点重置并调整控制点，点击线段插入锚点并调整控制点


移动模式
点击锚点选中锚点，显示操控点，拖拽锚点调整曲线，拖拽操作点调整曲线，



拖拽线段移动操控点调整曲线|
考虑路径动画工具是“所见即所得”，应该以动画可视化为主，同时避免太多误操作，于是把以上模式和功能重新简化组合，再新增默认模式，如下表：



模式
操作




默认
不显示曲线，路径列表选择曲线路径


锚点模式
点击空白处添加锚点，拖拽锚点调整曲线


操控点模式
拖拽操控点调整曲线


拖动模式
拖动任意处调整完整曲线位置


移除模式
点击锚点移除锚点、点击操控点重置操控点



如此，通过点击／拖拽快捷键实现三种元素的操作。
贝塞尔曲线上匀速运动的函数设计
要在曲线上匀速运动，须知任意时刻中曲线上的点坐标。获取一段三次贝塞尔曲线中点坐标的公式如下：

由于工具采用的是多段三次贝塞尔曲线，不同线段的取值范围并不是，而是该线段在整个曲线中的比例。如下图，是两段贝塞尔曲线，弧长比值约，故当=时，坐标点应近似位于处，公式参数应为“弧”，=；当=时，公式参数应为“弧”，=。

获取线段比例须获取每一段曲线的弧长，以弧长相较。用微积分公式可以算处弧长，如下：

具体函数就不在此详解。通过以上公式，将曲线的点与中的百分比一一对应，从而得到均等时间内点的位移，实现曲线上的匀速运动。同理，通过三次贝塞尔曲线公式计算模拟出中属性影响的运动速度。
成品
附上工具试用链接：
效果制作过程
效果

感想
当碰到痛点时，千头万绪，有许多想法从脑袋里蹦出，该如何梳理，通过这次工具的制作总结： “用一句话描述痛点 → 提取关键词，解析潜在需求 → 寻找合适的方案” 的逻辑顺序，或许会是不错的思路。
在开发的过程中，随着功能的实现，不断有更多念头冒出，例如：是否需要做成“可以代替大量页面动画的重构工作的工具”，最终还是否定了这个念头——这是一个快速解决一段代码的轻度工具，而不是一个替代整个开发流程的重度工具——抓稳核心和初衷。一、实验简介
本实验通过调用腾讯云对象存储接口，实现将图片上传到指定的  功能；同时封装图片上传接口，用于上传商品图片。
二、实验目标

掌握   接口调用和调试方法

掌握   封装方法


三、实验步骤
 添加云应用
第一步：   项目
    
    
第二步：修改远程仓库地址，提交到远程仓库
    
     
    
 调用  ，实现文件上传功能
第一步：编写    
 
  \\  
  \\  
  \\  
  \\  
  \\  
  \\  
  \\\  
 
  对象存储 
   {
  __ =  {
  =     
  =     
  =     
  =     
 }
 
  签名
     
    
 
   =  {
 = 
  =     
  =     
  =     
  =     
  =     
  =     
  = 
  = 
  = 
  = 
  = 
  = 
  = 
  =
 
  拼接字符串
  = ={}={}={}={}={}={}={}
  = _      
  = _
  
 }

 
  文件转字符串
     
     
    
 
    =  {
  = __  
     
 }

 
  文件上传     
     
    
 
    = {
  生成随机数
第二步： 编写测试用控制器  
 
  \\\  
  \\  
  \\  
  \\  
  \\  

    \\\ {

  __ {
 }

   {

  = 
 =
 = 
 = 
 = 
 = 
 
  = 
  =__
  =   = 
= 
 
 }

 }
第三步： 提交代码并更新线上
   
      {{}}  {{}}  指令更新线上代码
  
第四步： 安装  应用
访问   安装应用

第五步： 登录云主机，运行测试
       进入容器
       运行测试

 封装图片上传接口
第一步：创建配置文件  
 
 _ = 
 =
 =
 = 
 = 
 = 
 = 
 
 
第二步：修改控制器  
 
 _____  
  \\\  
  \\  
  \\  
  \\  
  \\  

    \\\ {

  __ {
 }

 
  上传文件接口
    
 
   {

  = _  _  
  =  _  
  = 

    ==   {
   未接收到文件  _=_
  
 }

  = _
  = 
  {
  =   =  = 
 }    {
  = 
     错误  = =
 
 }
    ==  {
 
 
 }
     错误  =
 

 }
 }
第三步： 提交代码更新
   
      {{}}  {{}}  指令更新线上代码
  
第四步： 登录云主机，运行测试
       进入容器
  
  
      ={} 

四、实验结果
通过调用  接口，掌握   调用和调试的方法；通过封装图片上传接口，掌握  的封装方法。
如果你看了以上的文章觉得不过瘾。想要系统性学习如何在腾讯云上开发微信小程序，建议报名参加我们的微信开发课程培训：

相关推荐如何用快速在腾讯云上开发小程序之系列：搭建开发管理平台如何用快速在腾讯云上开发小程序之系列：实现客户侧商品列表、商品详情页程序杨凯，腾讯用户体验部成都设计中心高级交互设计师。负责腾讯云大数据相关设计，目前专注大数据可视化方向的研究。

近日星巴克与微信推出的社交礼品功能“用星说”，可以说刷遍了朋友圈。无论你爱不爱喝咖啡，星巴克似乎都成为了一种文化象征。上班族青睐，小清新喜欢，基本上大家看到绿色的人鱼标志就能马上认出它来。
虽然一直也有喝咖啡的习惯，但至今不知道星巴克菜单版上列的【摩卡】、【拿铁】、【美式】、【卡布奇诺】等等有什么区别。直到看到下列图，才很直观的了解到每个咖啡类别的区别是什么。

类似上图示，针对内容复制，难以形象表达的信息，通过图形简单清晰地向受众呈现出来，这种图称之为信息图。
信息图
信息图本身是一个合成词，由信息和图两个词组成多称之为或 ，在年代的时候就开始出现，使用在报纸及新闻类杂志方面，其中杰出的代表阿根廷的信息图先驱 ，在年西班牙设立了以他为名的主要针对信息图表设计的奖。
在报纸、杂志等纸质媒体中，为了让读者感到新奇且直观容易的理解，运用了大量的信息图解的表现。
如下图所示：


信息图早已融入我们的日常生活中，目的为了创造方便舒适的生活环境，使人们的生活变得更加更加安全舒适。
为什么人们会对信息图的传播内容更有效呢？主要原因是因为视觉是人类最强的信息输入方式，人类感知周围世界最强的方式，在 《大脑法则》一书中，发展分子生物学家 写道：“视觉是迄今我们最主要的感官，占用了我们大脑中一半的资源。”信息图提供了一种语境的方法  ，通过展示多个维度数值并且相互比较来为受众提供语境，使我们更高效的把内容反射到大脑中。
后来随着技术的发展，除了传统的纸质媒体出现了以互联网为主的电脑，电视，手机，大屏终端等更多类型的电子媒体。信息图的分类也逐步划分为：图解 、图表 、 表格 、统计图 、 地图和图形符号这几部分。
图解 – 主要运用插图对事物进行说明
图表   运用图形、线条及插图等，阐明事物的相互关系 
表格  – 根据特定信息标准进行区分，设置纵轴与横轴
统计图  – 通过数值来表现变化趋势或进行比较
地图  – 描述在特定区域和空间里的位置关系
图形符号  – 不使用文字，运用图画直接传达信息 

在以纸质媒体为主的报刊杂志的传统行业中信息图是对实际事物的描述， 而在互联网行业中侧更多的是对数据的描述。将数据图形化的过程又称之为数据可视化。把数据，包括测量获得的数值、图像或是计算中涉及、产生的数字信息变为直观的、以图形图像信息表示的、随时间和空间变化的物理现象或物理量呈现出来。
我们来看一组简单的数据，比较下图形和数据对于人脑感观的差异。

这组数据包括、、、，一共四组，每组有和两个维度。数据很简单，但从数据上来看，你能说出这四组数据的区别吗？
从数据上很难看出有什么区别，因为每组数据看上去都十分的相近。下面我们把这四组数据转换成图表来进行对比下。

通过图表的比较，我们很容易就能找出这四组数据的区别了。组数据呈现整体离散向上的趋势。组数据呈现弧度上升，然后再下降的趋势。组数据呈现线性上涨的趋势，但有一个点突出。组数据呈现坐标不变上升的趋势，但有一点突出。
将数据图形化后，大脑天然的会对图形的不同点做出反应，从而更高效的理解数据带来的意义。
我们再来看下其他例子：

将当前的在线人数，通过可视化的方式展示给用户。把数据置于视觉控件中，这样用户就能很直观的了解到当前使用的人群分布在中国是怎么样的，那里的人群分布多，那里的人群少。

 针对 发短消息的位置和 拍照片的位置为数据源做的名为“看图或说话”   的大数据可视化展示，通过简单但大量的数据，做出非常美的数据图展示。
这种用图形化对数据进行描述设计的过程，我们通常称为【数据可视化】。有时候，可视化的结果可能只是一个条形图表，但大多数的时候可视化的过程会很复杂的，因为数据本身可能会很复杂的。一般流程包括【数据收集】【数据分析清理】【可视化设计】，从抽象的原始数据到可视化图像。

要做出好的【数据可视化】，拆分出来核心要先了解什么是【数据】
数据
数据是可视化的基础，它不仅仅是数字，要想把数据可视化，就必须知道它表达的是什么。根据 的分类，信息可视化的数据分为以下几类：
一维数据：轴一个维度如果、、、 •••
二维数据：，两个二维度、，、，、，、•••
三维数据：，，三个维度、、，、、，、、 •••
多维数据：，，，•••多个维度、、、、•••，、、、、•••
时态数据：具有数据属性的数据集合。
层次数据：具有等级或层次关系数据集合。
数据种类划分是十分多的，但是这些数据都描述了现实的世界中的一部分，是现实世界的一个快照。除了类型，数据的数量级也影响这数据的表达结果。

小数据量小于展示一下静态结果，中数据量呈现数据反映的事实，大数据量大于用于研究分析，推测结果。
我们来看一个数据：【年月号，成都值】，从这个数据里能看出什么，可能只是会觉得当天成都空气质量不好，我们可能会联想到这个样一个画面。

好像就不能得出什么了。其实从单个数据上，我们很难得到什么有价值的信息。所以要想发挥出数据可视化的作用，首先我们需要大量真实的数据，知道数据的来龙去脉，把它作为一个整体来理解，关注全貌对原始数据了解得越多，打造的基础就越坚实，也就越可能制作出令人信服的数据图表。
，我们继续丰富我们的原始数据，在中国环境监测总站 的网站获取到成都年整个月份的的数据。
中国环境监测总站作为空气质量公开的数据来源，它提供了获取数据的接口。通过接口我们可以获取到原始数据。

原始数据一般包含的信息都比较多，什么、空气质量指数、、一氧化碳、二氧化碳、臭氧、二氧化硫等等。我们只需要的，所以清理数据，把其他不必要的内容去掉。然后导入到表中，可以得到我们最终需要的数据。

有了【数据】下一步就可以开始做数据的【可视化】。
可视化
通俗地说，可视化设计的目的是“让数据说话”，用图形去讲述数据的故事。可视化是一种表达数据的方式，是现实世界的抽象表达。它像文字一样，为我们讲述各种各样的故事。作为一种媒介，可视化已经发展成为一种很好的故事讲述方式。
我们把成都的数据，按照日期和当天的指数做出最简单图形来，我们可以得到下面这类的图表来。

这类的图用很简单就能得到。我们可去修改下柱状图的配色，但它依然只是一个简单的图表，而不是好的可视化作品。
那什么是好的可视化作品呢？
好的可视化设计需要具备统计和设计方面的知识。没有前者，可视化只是插图和美术练习；没有后者，可视化就只是研究分析结果。统计和设计的知识都只能帮助你完成数据图形的一部分。
我们需要去讲述数据的故事。那代表的是什么，是当天天气的情况，所以我们可以用天气的维度去讲述这个故事。

我们把成都年月份的天气照片的到，天气好的时候天是蓝色，超标的时候是灰色。把它图形化我们可以得到这样一个展示，可以看出对于成都来说一个月中天气好的时间是十分少的。
好的可视化设计能让你有一见钟情的感觉，你知道眼前的东西就是你想看到的。既可以是艺术的，同时又是真实的。而不是直接把数据转换成图表，找到数据和它所代表事物之间的关系按照“数字化叙事”去做设计，这是全面分析数据的关键，同样还是深层次理解数据的关键。

我们在网上可以看到大量的优秀的数据可视化图，这些优秀的作品都会以这种“数字化叙事”的方式，告诉用户数据的意义。

这是哈佛做的一个数据可视化项目，将全球价万亿美元的大宗交易表现在这里。地图上的每个点都代表  亿美元的进出口商品，十分的形象和震撼。
当然好的数据可视化图都是不断迭代优化出来的，判断是不是一个好的数据可视化可以按照以下的步骤去考虑。【你有什么数据】  【关于数据你想知道什么】  【数据可视化的表现方式】  【你看到了什么？有意义吗？】。每一个问题的答案都取决于前一个答案，不断的去问自己，每个环节有没有问题，这样才能做出最好的设计。

我们一直在讲数据可视化的目的是有两个：一个是更好地分享和传达数据信息，二个是通过设计之美有效地缩短信息的传达。这是可视化的最根本的目的，可视化的定义在不同人眼中是不一样的。作为一个整体，可视化的广度每天都在变化，但是这是一个新的领域，我们可以用一种全新的方式去认识世界的过程，数据可视化，改变对数据的呈现和思考方式。
参考资料
《图解力》 – 木村博之
《数据之美》 – 邱南森
《可视化沟通》 –  
《信息设计》 –  
      – 演讲
信息可视化研究综述  河北科技大学学报


阁主点评：光有数据，有什么用？只有靠形象的可视化展示，才能提取出数据背后的东西。本文是大数据可视化团队的系列文章，将分享如何实现数据可视化的经验与技巧。另外，腾讯云还提供了专门的可视化平台，可以帮助企业、开发者制作出高端大气的可视化作品。

相关推荐
概览：可视化前端测试：雅虎推出的云数据库基准测试套件爬虫中常用处理，对于类似百度这样的搜索引擎，则需要配合使用，步骤如下
获取链接信息
在浏览器中打开，使用抓取，如下图

双击中的捕获链接，获取整个连接信息
然后在后加入捕获的链接信息
即
__=__=__=__=__=======
同理也可以获取下一页链接
__=__=__=__=__=
=====
这里需要注意的是，下一页链接需要填入查询页
代码如下

          {
          =  
         {
              =  
            __
            
              =  
              =  
            
              = 
              = 
                 {
                 
            }

        }    {

            

        }
         
    }
使用的时候，调用即可，其中是查找页
处理
思路是把链接保存到中，然后通过解析这里需要的包是
保存需要下边两个工具类

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

   {
     文件操作类 
         =  

    {  }

          
               {
          = 
          = \\
          = \\\\
           =  
           =  

        =========分割线===========  \ 
          = 
          {
               =   
                    
              = 
              = 
              =  {
                      
                         \ 
            }
        }

        =========分割线===========  \ 
          = 
          {
               =   
                    
              = 
              = 
              =  {
                     
                           \ 
            }
        }
    }


         =   

           {

          = 
               
                 
         {
             =  
                 {
                
                  =  
                  = 
                  =  {
                    
                    
                    
                }
                
            }
            合并成功 
        }    {
            
        }  {
             {
                  =  {
                    
                }
            }    {
            }
        }
    }

          {


          = 
          =  


          {
            
        } 
        
        去重结果保存在中  \
        词数统计成功，结果保存在    中
        
        

        
        
          =  
        是否统计词性出现次数是 否\
          = 
          ==  {
             

            词数统计成功，结果保存在    中
        }
    }


           
             {
          =  
          =     
          =      
          =  
          = 
          =  {
             =   
        }

          =    =        
                    
          =  {
             
               =      {
                  =     
                开始提取第      个文件……
                
            }
        }  {
            
        }
             {
            正在写入     \
               \
                    
        }
    }

         {
          =  
          = 
          = 
           =      {
             = 
              {
                }
            }
        }
    }


    {  }
          
                {
          = 
          = \\
           =  

          = 
          {
               =   
                    
              = 
              = 
              =  {
                    ==  {
                               \
                            
                }
            }

        }
    }

        
               {
          =  
          =  
          =  
          =  
          = 
          =  =  {
            
        }
         
    }


             {
          = 
          = 
          = 
            {
              = 
              = 
              {
                 
            }
        }
         
    }

         
              {
          = 
          = 
          = 
           =   
          = 
          = 
          {
             = 
              {
                 = 
                   
            }  {
                 
            }
        }
         

    }


          
             {
          =  
          = 
          =  
          = 
          {
              = 
              {
                
            }  {
                
            }
        }

             {
            

        }
         

    }


             {
          =  
          ||  {
              指定文件不存在！
        }

          = 
          =  {
             =   
        }

          =    =        
                    

          =  

          =  

          = 
          = 

           =      {

              =       

              =  

             = 
             =       

                  {
                
            }
            
             = 
            第      个子文件生成……

        }
        
    }


           {
          =  
          =  
          =  

        
          =   
                     
          = 


          =  =  {



              =  
            

        }
         
    }



           {

         {
              =  
              {
                
            }
              =   
              =  
            
            

        }    {
            
        }
    }


         {
          =  
          {


             
        }
          {
             =   
        }
          {

             
        }  {

             
        }
    }


         {

          {
             =   
        }
          =  

          ||  {
             
        }
          = 

          = 
           =      {

              {
                 = 
                 
                    
            } 
             {
                 = 
                 
                    
            }
        }
         
             

          {
             
        }  {
             
        }
    }

         {
          = 
          =  

            {
            
             = 
        }
         
    }

        {
        
        
        
        
    }
}

 

 
 
 
 
 
 
 
 
 

抓取保存到本地 

   {

             {

          = 
         {
             =  
        }    {
            
        }

          = 
         _ = 
         {
             _ = 
            _
            _  _
            _
                          
             _ = _

             _ = _ 
             _

        }    {
            
        }
    }

           {

         {
              =  
                       
            
            
        }    {
            
        }
    }

        _  
              {
          =   _
                
          =  
          = 
          =  =  {
            
        }
         
    }

}
主程序如下，由于网址限制短时间访问次数，写一个定时器，每隔爬取一次，代码如下

 

 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 

使用方法 

   {
        = 
        = 

           {

        

          =   {
              = 
              = 

            
               {

                 {
                      {
                          =    {
                            
                            
                        }  {
                            
                            
                        }
                    }

                }    {

                    
                }
            }
        }
          =  
          = 

          =     
        每隔        分钟爬取下一个词
                 \
          

    }


          {
          =  
         {
              =  
            __
            
              =  
              =  
            
              = 
              = 
                 {
                 
            }

        }    {

            

        }
         
    }



          
              {

           =  
           = 
           =   

           =     

           = 
                 __=
                 __=
                 __=
                 =
                 
                 ====
        
                正在爬取  词      首页数据⋯⋯  \

          
          =  
          =   
          = 
                =宋体


           = =
          

          {

             = 
            对不起，关键词    
                     未被索引，请使用模糊检索方式查询  \
        }  {
             = 
                 {
                  \ 
                  \ 
            }
            词      首页数据爬取成功  \
        }

           = __=__=__=__=__=
                 =
                 
                 ====

        
          =   {
            
               {

                 {

                    
                      =  {

                        正在爬取  词    
                                 第    页数据⋯⋯  \

                          =     
                                 

                          
                          =  
                          =   
                          = 
                                =宋体
                        词      第
                                   页据爬取成功  \
                             {
                              \ 
                              \ 
                        }
                    }      {
                         = 
                          =  {
                            词    
                                     标注语料已经抓取完成，结果保存在中
                                     \
                             
                                    
                        }
                        
                    }

                }    {

                    
                }

            }
        }
          =  
          = 
          =   
          

    }
}
运行结果
抓取的在和文件夹下，结果保存在中个人介绍：微软最具价值专家、认证讲师、无界工程师、场景式学习倡导者，曾在阿里仓储解决方案公司担任系统架构师一职，目前就职于互联网企业担任系统运维工程师，致力于改善生活的实践之路。

在上一篇文章中我们介绍了如何在  标准化的搭建一套域环境，并介绍了如何在生产过程中如何避免一些坑，今天，我们来介绍此次中真正需要注意的一些细节及实现技术手段，主要为了让大家理解群集环境的隔离如何在  上实现，先来看看以下两个  ：
： 提供了虚拟机多个网卡的技术，但是如何确保它们在物理上是隔离的呢？
：不可能完全隔离，因为不单单是  ，大部分的公有云包括国际底层都是采用多个网卡做  来进行多卡容灾，如果要多个  拆分对应多个物理网卡无非是增加服务器硬件成本，不过目前为止貌似也没有哪个公有云厂商敢宣称做了完全的    意味着屏蔽了硬件， 可随机落在某个宿主机的某个网卡上，这一点至少我们已经在日程上了，如果有兄弟知道这方面的资源欢迎纠偏指正。
：既然无法完全物理隔离难道没办法解决线路分离问题吗？
：完全物理分离的完美方案几乎不可能，对国内公有云来说也的确有点为难，所以尽可能的去避免单点故障还是有可能的，有这么一种方案，现在  的虚拟机投放策略是尽可能打散在不同宿主机，那就意味着同一台宿主机多个虚拟机同一个物理网卡的可能性是微乎其微的，为了确保这个信息，可以提交工单来确保这个问题：
 
，回答了上述问题后，我们开始进入正题，以下是今天需要的服务器信息本例中会开通外网流量主要为了方便 ，但是生产环境中不建议使用外网带宽：



编号
服务器名称
生产 
存储 
心跳 
对外 







无
无







无






    







    





关于 ，是用来作为   共享存储，存储作用一共分为三块，一块作为仲裁盘，一块作为生产数据，一块作为备用未启用预留空间。
涉及架构如下：
，开始动手：

创建多个网卡作为辅助网卡添加到对应的中，这里暂时不支持从控制台直接新建已经快上线的功能



所以咱们通过来进行添加即可，可以参考这两篇文章：创建私有网络和内通过搭建高可用主备集群记得先申请授权哟。
 

创建完成后得使用遍历网卡使用创建的网卡不会在界面显示

进行网卡改绑定目前也仅能通过：注意是不是，且成功后也不会在控制台上体现，但是在系统内部可以看到。

使用同样的方式创建网卡，确认两个子机都可以获得网卡后分别有三块，块生产、块心跳、块存储，这里偷了下懒用内部系统看了下对应关系是正确的：存储网络，两个节点，一个存储节点心跳网络，两个节点

确保心跳网络、存储网络两两之间是通的。


附录，本篇槽点：
一 创建弹性网卡到绑定主机这个流程太考验运维实力了，运维童鞋的代码能力直接决定了这个架构是否搭建成功，因为创建弹性网卡需要调用，查看弹性网卡需要调用，绑定弹性网卡也需要调用这一点博主已经直接怼了研发童鞋跟产品童鞋进行双向整改。
二 这里其实有更加优化的方案去做网络隔离，那就是私有网络也用不同的，但是这是博主之后想到，创建网卡也需要指定子网，就意味着要修改网卡重，根据槽点这是致命的，所以博主按照规范及架构考虑，强烈建议分离，操作如下：

创建私有网络

以同样的方式创建存储心跳效果如下：

接下来将、根据正文中的步骤重新创建网卡并做绑定无法直接进行修改，见槽点三


三修改弹性网卡的 竟然只能修改网卡名称跟网卡描述，如果要更改网卡，要经过 解绑主机网卡 —— 删除弹性网卡 —— 创建新弹性网卡 —— 绑定主机。。而这一切，是的还是得通过来做见槽点二。

相关推荐
【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群
【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群
【腾讯云的种玩法】在腾讯云上创建您的  故障转移集群

使用最大的瓶颈在于数据库，维护好的数据存储，告警，就能很好地应用去构建监控系统。目前的数据主要存储在和的个表中，随着时间的推移，这两个表变得非常大，性能会非常差，影响监控的使用。对进行调优，能够极大的提升的性能，本文采用对进行分区的方法进行调优。
原理
对中的和等表进行分区，按日期进行分区，每天一个，共保留天分区。
操作详细步骤
操作影响： 可以在线操作，的读写变慢，性能变慢，影响时间根据数据的小而变化，一般在个小时左右。
第一步
登录 的数据库，统一的配置
  

=
=
 = 
 = __
 =   
 = 
=
_=
___=
__ = 
__=
__=  
__ =    
__ =     
_ = 
__=
_____ = 

__ = 
 =  

_
=
=


=

       

 

注意：一定要修改___=物理内存的
第二步
先确认的版本，本操作的版本一定要大于。小于的版本不能安装此操作，线上默认是。
 、 导入存储过程
  
 
  `_`      

       
           =        
           =       
           =       
       
       
                 
       

         
          
        _
        _ =   _ =  _ = 

         =  
               
                           
                         
                        
               
                 _         
                 =                    
                  
                
                 
        

 

 
  `_`   ___ 

       
            =       
           =       
          ___ =            
        
           
        __ 

       
                      
           ___     
                    
       
          
                _
                _
                _ =   _ =  _     ___
               = 

       
                       
          _         
            
       
        _ =         
        _ = 

       
                   
       
        
       _ 
                  __
                 
                         _
                
                _ = _ = __ _  __
        
        _ =  
                
                           
                         
                          
               
                _ = _ _ 
                  _
                
                 

                    ``_  `_`
       
               
                              
                       
               
                    ``  `_`
        

 


 
 `_`_  _ __  _  __ 

        ___ 
        _ 
        __ 
        __ 
        _ 

         ___ _
        _ = __  

        __ = 
       _ 
                __  __ 
                         _
                

                __ = _  _  __ 
                _ = __  _ __     
               _ = __ 
                        __ _ _ __
                
                __=__
                __ = _
        

        ___=__ __  
        __ _ ___


 

 
  `_`    

        _ 
         
        _ 

       
                 
        
          
        _
        _ =   _ =  _  

       
                   
        
         =  
               
                                     
                                     
                                    
                               
                
                _ =     
                _ = _ 

                   
                ___ =         ``
                ___ = ___  _     __ 

                   
                  ___
                
                 
        

 

 
 `__`_ 

                __    
                __ _   
                __ _   
                __ _   
                __ _   
                __    
                __ _   

 
上面内容包含了创建分区的存储过程，将上面内容复制到中然后执行如下：
       
、 添加每天执行点分执行，如下：
     
   
 _
            __ 

  |
注意： 的用户的密码部分按照实际环境配置
、首先执行一次由于首次执行的时间较长，请使用执行，如下：
        __  
注意：观察的输出
、 查看结果
登录查看等表 如下：
    
|  |   `` 
 ``    
  ``    
  ``    
  ``    
  `_` ````
 =  =
    ``
      = 
       = 
       = 
       = 
       = 
       = 
       = 
       = 
       = 
       = 
       = 
       = 
       = 
       = 
       =   |
发现了大量字段，说明配置正确。注意观察的 一般到执行操作的第二天， 几乎就会有了，此时的响应速度应该非常流畅了。如今，多样的交易模式以及大众消费观念的改变使得数据库应用领域不断扩大，现代的大型分布式应用系统的数据膨胀也对数据库的海量数据处理能力和并行处理能力提出了更高的要求，如何在数据呈现海量扩张的同时提高处理速度和应用系统的可用性，使客户能同时得到更高的处理速度、更高的数据可用性和更大的数据集，是数据库系统面临的一个挑战。
通过基准测试，可获得数据库单位时间内的性能处理能力，为评估数据库系统的现有性能服务水平提供有效依据，通过横向对比促进数据库系统的整体质量提升，能更好地在重大信息化工程中实现推广。
一 原理简介
是由   事务处理性能委员会公布的一套针对数据库决策支持能力的测试基准，通过模拟数据库中与业务相关的复杂查询和并行的数据修改操作考察数据库的综合处理能力，获取数据库操作的响应时间和每小时执行的查询数指标。
基准模型中定义了一个数据库模型，容量可以在的个级别中进行选择。数据库模型包括、、、、、、和 张数据表，涉及条复杂的查询流语句和条带有和程序段的更新流语句。
二目的
比较在同等资源条件下具有分布式属性的与单机版在进行类测试的性能区别。
分析两种造成性能区别的原因。
三测试环境与配置信息
测试环境：腾讯云
测试对象：、，两者的配置信息统计如下：




指标
参数




文本
文本


操作系统
  位



      核


内存



公网带宽







版本




表  服务器
四测试数据量统计



表名称
数据条数





































表  各测试表数据量统计
五执行时间统计



执行的
执行时间单位：秒
执行时间单位：秒














































小时



















小时
























小时









小时




小时








表  条执行时间统计
六性能对比分析
根据执行时间的统计，我们可以看出两种数据库在进行类测试有着较大差异，下面我们将选取两个典型的事例，分析与在执行该类的性能差异原因。
示例一
我们选取，从执行时间统计可以看出的执行速度大概是的倍左右。首先，查看下语句，如下图所示。

图 语句
然后，下，得到结果分别如图和图。

图 执行 的结果

图 执行 的结果
从以上的执行过程解释可以看出，上的执行步骤主要有：

在所有这里为个同时进行条件查询；

两表做关联时，会进行数据广播，每个将查询到的结果广播到其他所有，每个得到该表后的所有结果全量数据，后会进行一次；

在所有上同时做 ，因为还要和其他表做，会继续将结果广播到所有上；

进行 聚合操作。首先在所有上根据 条件进行一次聚合目的是减少重分布的数据量，然后将结果数据按 字段进行重分布，最后，每个再按条件聚合一次得到最终结果；

根据 条件，在所有上同时进行，根据条件选取数据，这里是 ，每个都选取条数据汇总到上，由再选取前条；

进行，所有将结果发给，由进行一次归并，根据条件选取结果的前条数据，返回。


整个过程耗时的点主要有：

做了两次广播，总量为=万条；

根据 的条件一次，数量约为万条；

 两次，都是在两个表之间进行的 ，在单个上，两表之间的 量分别大约是万与万、万与万；

一次，单个的从万条数据中取出前条记录。


的执行过程比较简单，首先是在表做一次过滤，获取结果计算出值，由于 的值是，因此，需要一次非关键字排序，排序的量为约万，这里非常耗时。然后在表和表做一些过滤。
从以上执行过程可以看出，主要的耗时点应该在操作上，是在所有上同时进行一次万条记录的，而则是直接进行一次万记录的。由于是在单个服务器上搭建的，该服务器的性能核、内存远高于的单个核、内存，因此，如果充分利用服务器的性能，两者的时间应该相差不大，可是事实如此吗？接下来我们查看下所在服务器的使用情况，得到执行前后的结果如图所示：

图 执行前后其所在服务器的使用时间情况
可以看出，执行前后，只有的使用时间有较大变化，变化时间大概为即秒，与总的执行时间秒基本吻合，因此，执行    过程中，所在的服务器只使用了一个来进行计算。
综上，和的耗时区别主要体现在操作上，对万条记录做了一次，但只能使用单个计算，没有发挥服务器本身多核的性能优势，整体执行时间较长。而由于采用了分布式的结构，每个对应一个，数据均匀分布到各个，在各节点并行执行、 、 ，等操作，充分利用了每个的计算能力，然后将结果进行广播，或对整体数据进行重分布再进行计算，最后由归并各的结果数据。在进行广播或者重分布时，会在节点间进行数据传输，消耗了一定的时间，但由于对的优化更好，以及并行计算的能力，因此，相比于，总的执行时间更短。
示例二
我们再选取一个典型的事例——，根据执行时间统计，的执行时间是的万倍，这是一个相当大的差距！究竟是什么原因会导致如此大的区别，我们首先查看的语句如下图所示。

图 语句
与不同的是涉及到了子查询，依旧，我们在和上下，得到的结果如图、图所示。

图 执行 的结果

图 执行 的结果
子查询 _  _   _   _     _里面涉及 ，我们来看一下两者在聚合上的区别：
：由于 的是非索引关键字，所以直接进行了 万条记录。
：首先在每个有该表万条记录做一次  _，采用了更高效的聚合方式。为了所有可以并行做，会将表的数据做一次重分布万条记录，每个得到的是分布到自身的记录。
可以看出，在聚合上的效率要明显低于。
然后，子查询结果会与现表做操作，我们来继续看下两者在上的区别：
：把子查询结果作为临时表万条记录与现表万条记录直接做了，将产生万×万=万亿的数据量
：首先对进行了优化，先执行了条件，减少了表的数据到条单个的量，总量为×条，接下来的数据量都为单个的。
采用了更高效的方式 。
如果使用临时表与表直接 ，会产生万左右的数据量，但并没有这么做，而是利用表来进行，因为表经过过滤后数据量非常小，和表做 ，数据量也相对较小。总共做了两次 ：

表与临时表_，产生数据量条；

表与表，产生数据量条；


八其他事项

由于原生的的测试用例不直接支持和，因此需要修改测试脚本，生成新的建表语句如《附录一》所示，测试如《附录二》。

各节点间的带宽要尽可能大，一般查询中会涉及到广播或者重分布动作，需要在节点间传输数据，如果带宽过小，易在此造成性能瓶颈。

测试语句不要过于简单，并且测试数据量不要太少，否则在做数据传输的时间会远高于计算时间。


更多数据库文章，请关注腾讯云数据库公众号 

相关推荐 下一篇   简单性能测试与分析— 续  性能测试报告  数据库的高可用性分析国内数据库技术盛会——第八届中国数据库技术大会于年月日召开，大会吸引多位技术专家分享、多名人士参会，在月日的大会中，腾讯云数据库高级工程师，数据库专家许中清做了腾讯云数据治理经验分享。
从微信支付在实际案例中，许中清介绍了腾讯云分布数据库  在数据治理过程中面临的数据倾斜、成本优化、数据迁移等能力，以及在解决这些问题的过程中的一系列优化和内核优化，包括映射关系表、虚拟节点组、多维分片策略、不停机数据搬迁等功能。

腾讯云分布式数据库系列产品，对内支持腾讯内部业务的发展，对外为企业提供强有力的服务，已经赢得广泛客户的信任与口碑，积极推动了腾讯云的快速发展。
一、简介
是腾讯自研的，基于架构分布式关系型数据库集群，内部代号为。是面向应用，兼容协议，支持分布式事务和跨节点复杂查询的一款分布式数据库。目前已经在微信支付商户系统中运行近年，管理超过个节点和的数据量，也是全球最大的集群之一。
的架构如下图，其中负责分布式事务管理，负责存储数据，负责对数据进行分发、聚合等操作，本身不负责保存业务数据。通过将分布上值进行路由到各个上。

另外，引入了逻辑路由层，在上实现映射关系表。数据分布关键字 先被出，然后用查询表找到数据对应的。路由过程如下图：

二、防数据倾斜
但凡是分布式集群，数据分布不均衡和负载分布不均衡就天然存在，这叫做数据倾斜；数据倾斜导致会负载和数据集中在一两个节点，进而严重影响集群的扩展甚至正常运行。 解决数据倾斜，是数据治理的最主要目标之一。
通过分析，我们发现数据倾斜的主要原因：分片关键字 本身引入的倾斜：因为业务数据本身的特征，导致在某个分布值的记录数特别多，例如交易类业务，以账户作为关键字，然而某账户交易量特别大，也会导致数据倾斜。
首先，通过管理，确保数据均匀的写入。同时，通过的动态管理， 可以动态将部分数据从负载较高的节点迁移到负载较低的节点，进而保证进一步的均衡。当然，这里的分片策略不仅仅是来解决倾斜。
某些特殊情况，例如大多数业务存在原则，即前商户可能产生超过的交易和数据，银行业务、社保业务、电商业务都存在类似情况，我们实际应用中也发现，微信支付系统中的京东账户，采用动态迁移数据本身已经无法解决数据倾斜的问题了，因为京东账户的数据量和负载要求甚至超出一个物理上限。为了解决这种问题，引入了虚拟节点组技术，即由多个组成一个或多个虚拟的组，来承载那仅有商户产生的的交易和数据如下图  。

三、冷热数据分离
在数据治理过程中，成本一直是我们关注的地方。由于分布式集群本身设备采用服务器，相对于某些方案，成本已经很低了。但并不满足，因为腾讯内部集群规模还在快速增长，我们可以预见突破台设备之日可待；而这么大规模，全部采用高端设备，成本也是非常恐怖的；因此，我们提出了在数据库层的冷热数据分离，降低存储成本的方案。
在大部分数据库系统中，数据有明显的冷热特征。显然当前的订单被访问的概率比半年前的订单要高的多。根据经验来讲，越是数据量增长快的系统，这种冷热特征越明显。将冷数据存储到带有大容量磁盘的服务器上，将热数据放在价格更昂贵的上明显更合理。传统方案是通过拆解系统，但通过将冷热数据分布存储到  来大幅度降低硬件成本。

以下图架构是一套完整的架构举例，我们将将从冷热、大小 两个维度分成四个：
：  ：存储小、热数据；
  ：存储小、冷数据；
  ：存储大、热数据；
  ：存储大、冷数据

每一个 都有独立的空间到的映射表；每一个 都有不同的策略。比如，对于每一个，首先会根据和 判断该路由到哪一个。然后采用这个内的策略、并查找这个的进一步路由到某一个。

首先根据的 判断是冷数据还是热数据，然后查询  也提供接口由用户指定判断是属于  还是   。最后在指定的里面通过和查找找到对应的。
为什么每个采用不同的策略？最直接的原因就是原则让关键字 本身引入的严重的分布不均匀。因此在  我们通过   复合列将大商户的数据到不同的，保证超大商户能够存储到集群中。那么，为什么小商户不统一使用这种多列的策略呢？因为对于数据量小的商户，路由到一个可以避免对单个账户写操作时的分布式事务和读操作时的跨接点查询。最后，  的策略完全一样，  的策略也完全一样，只是他们各自属于不同的空间。
四、在线迁移能力
解决了倾斜问题，我们看看看自动扩容缩容，越是发展快的业务，越是重视如果不影响业务运行快速扩容缩容。当集群规模不足以支撑业务量的增长时，需要增加新的节点，会自动将一部分从原来的无缝迁移到新节点上。或者当节点数据出现倾斜时，系统自动将从负载较高的节点迁移到负载较低的节点。那这是怎么做到的呢？
通过以上描述了集群中的数据分布策略，我们分析可得到在中，有三种类型的数据迁移：
热数据变冷，迁移到 。这是跨迁移 小账户变大，签到   。这也是跨迁移 扩容或者因为均衡的原因，在一个内部的节点之间进行迁移。
而对数据迁移的目标是：
不影响业务。 保证数据完全一致。
综合上述要求，提出了一系列解决方案。对于扩容来说，加节点操作很简单，但真正的难点和重点是，再保证高可用和数据一致性的基础上，不停机就能完成数据的迁移。的解决方案是根据迁移目标，设定一系列任务  关键点，并对这些关键点进行拆解分析并加以实现。
一个分布式迁移任务  由一个三元组源 目标 分片来定义：从源节点迁移分片中的数据到目标节点。整个流程一共分成个大步骤：迁移存量数据、迁移增量数据、数据检验、切换路由、清理如下图：

迁移存量：顾名思义，就是将需要搬迁的分片的存量数据从源节点搬迁到目标节点。此时业务依然在写，为保证二者存量数据迁移不会存在重复或遗漏的数据？的方案是是将开始导出存量数据和开始记录增量这两个动作使用同一个数据库快照。这里要说明下，在路由切换之前，这些目标节点中的数据对外不可见。

追增量：为确保重做增量数据的同时，新的增量数据写入顺利，采取多轮迭代的方式来追增量数据。每一轮的增量数据会越来越少搬迁的速度比新增的速度快，因此每一轮迭代的重做时间逐轮收敛，直到收敛到某一个可配置的阈值，我们就进入下一个步骤数据校验。

数据校验：支持严格的数据校验，要求迁移后，不仅数据条数一要致，而且内容也必须完全一致。但是传统的校验需要花费很多的时间，而且，为了保证源节点数据不再新增，必须有一个加锁只读的过程。的方案是，不是等到源节点统计完成之后才解除阻塞，而是统计校验语句获取快照解除阻塞；因此，所以这个加锁的时间并不长，通常在以内
再追变更：如果数据校验的时间较长，这段时间源节点上又会产生较多增量数据，因此流程需要再次追变更，过程与第二步中的追变更完全一样，在某一轮迭代的重做时间达到某个阈值时，开始进入下一步：切换路由。
切换路由：切换路由需要加锁，也就是阻塞源节点上对这些迁移的分片的写操作，业务在这些分片上的写操作会失败。在路由切换完之后再解除源上的写阻塞。需要注意的是，在阻塞写的这段时间，切换路由之前，还有最后一轮增量迭代需要在目标节点上重做。根据我们在现网中经验，这段阻塞部分上写的时间绝大部分情况在以内，通常可以做到小于。，而且由于扩容时，并非所有节点数据都去做迁移，因此这个影响也有限。
清理：解锁、停止源节点上的记录增量数据的过程，清理源节点上的重复数据。
最后根据我们在微信支付多次扩容操作中的统计，主要关注每次迁移锁读写的时间，我们一共进行了个迁移任务。每一次切换路由时锁业务的时间主要分布在之前，平均阻塞时间时。总的来说，大家感受到的微信支付等一系列服务几乎是全年无休的持续服务的，也注意证明，我们的迁移等运维操作，几乎是对业务没有影响的。

根据我们的经验来看，在一个分布式机器的运维过程中，除了日常巡检和故障排除以外，大部分的自动运维工作都在数据迁移上；比如扩容搬迁、冷热数据搬迁等等；因此，如果能使用云服务，例如腾讯云的关系型数据库，分布式数据库等，这类工作极大的简化，不仅提升每一个业务的效率，还能让大家更加专注于业务开发，提升业务价值。
以上就是数据治理策略的主要内容。作者：王少鸣 

  版本在情侣空间涉水 ，以动态插件方式将情侣空间进行 的改造。在情侣空间基础上，  版本以融合的方式将话题圈进行 改造。本文主要讲述话题圈的开发改造流程，相关数据对比及性能优化，本次改造基于。
一侧项目整体开发流程

二改造后话题圈整体流程

三性能优化之路
本次版本开发周期较赶，加上视频组件本身相对复杂，融入耗时较多，部分优化规划在二期实施。
包精简
版本对比：    情侣独立插件。    话题圈本次框架移植入整体仅加大了。    主要优化点：        去除了小平台库。        复用  。    二期规划：        在与中间加，使适配本身网络库及图片库，可以废弃框架的库及库，减少包大小。
首屏加速与启动速度
版本对比：        改造后话题圈在及缓存优化下，首屏相比快约 ，并且由于缓存到本地，并且可以实现离线访问。    话题圈数据主要优化点：        更改源码，新增预初始化接口，在 渲染完成预加载上下文。        首屏数据需要等前端走网络请求拉取存本地，优先采用本地数据渲染。    优化前后流程对比：二期规划：        目前为控制内存预加载仅是上下文，打开仍有一部分耗时，这里可以尝试缓存，在打开时直接，达到秒开。        数据预拉取走的为通道，可以使用 加速。

版本对比：        话题圈=        话题圈=主要优化点：        层使控件渲染数据，废弃使用控件。        元素设置透明背景。二期规划：        目前官方暂提供的未采用复用逻辑，仅在不可见时置空，仍是控件只支持横向滚动。性能仍需提高，下版本规划实现高可用。
内存
版本对比：        情侣空间：无内存泄漏及浪费内存情况，比版本多约。        话题圈：无内存泄漏及浪费内存情况，与版本基本持平。    话题圈详细数据主要优化点：        层使控件渲染数据，废弃使用控件。        视频拆分，交由实现，对应管理，由实现。二期规划：目前官方暂提供的未采用复用逻辑，仅在不可见时置空，仍是控件只支持横向滚动。性能仍需提高，下版本规划实现高可用。
四话题圈与话题圈整体数据对比
目前在与通信耗时明显优于的方式，在高中端机上如及上表现优于，但是从全局来看，目前，内存，，首屏等均有优化空间，下面是整体对比数据。    

五写在最后
 因你参与会更精彩，希望年能将更多的开发者加入 阵营，让更多的业务都是 Ｗ的版本节奏，的流畅顺滑。

文章来源公众号空间终端开发团队


相关推荐
    架构初探的单实例模式下，一个进程为一个实例，一个实例中包含若干，每个包含若干张表。
通过一张特殊的表存储，该表的特点是：固定大小，满了会删除最旧记录插入新记录，而且只支持操作，因此可以理解为一个持久化的。是复制集的核心功能点。
复制集是指实例通过复制并应用其他实例的达到数据冗余的技术。
常用的复制集构成一般有下图两种方式 注意，可以使用 手工指定复制源，但不保证这个指定是持久的，下文会讲到在某些情况下，会自动进行复制源切换。

的复制集技术并不少见，很类似的异步复制模式，这种模式主要有几个技术点：

新节点加入，正常同步前的初始化

节点挂掉后，剩余的节点如何提供服务

如何保证主节点挂掉后数据不丢失主节点挂掉后丢失数据的处理


作为一个成熟的数据库产品，较好的解决了上述问题，一个完整的复制集包含如下几点功能：
 数据同步





异常数据回滚


  集群心跳与选举
一数据同步
_
当一个节点刚加入集群时，它需要初始化数据使得 自身与集群中其它节点的数据量差距尽量少，这个过程称为。
一个 包括六步阅读__函数的逻辑。

删除本地除库以外的所有

选取一个源节点，将源节点中的所有导入到本地注意，此处只导入数据，不导入索引

将开始执行到执行结束中源产生的 应用到本地

将开始执行到执行结束中源产生的 应用到本地

从源将所有的索引在本地重建导入索引

将开始执行到执行结束中源产生的 应用到本地


当第步结束后，源和本地的差距足够小，进入从节点状态。
第步要拷贝所有数据，因此一般第步消耗时间最长，第与第步是一个连续逼近的过程，这里做了两次。
是因为第步一般耗时太长，导致第步数据量变多，间接受到影响。然而这么做并不是必须的，_： 开始的建议使用的方式将数据一次性读回来以及的行为与原理如果不熟悉请看官方文档。


当节点初始化完成后，会进入状态，顾名思义，正常情况下，这是一个稳定静默运行于后台的，从复制源不断同步新的过程。该过程一般会出现这两种问题：

复制源写入过快或者相对的，本地写入速度过慢，复制源的覆盖了 本地用于同步源而维持在源的游标。

本节点在宕机之前是，在重启后本地有和当前不一致的。


这两种情况分别如下图所示：


这两种情况在_函数中，虽然这两种情况很不一样，但是最终都会进入 _函数处理。
对于第二种情况，处理过程在_中，具体步骤为：

维持本地与远程的两个反向游标，以线性的时间复杂度找到最近公共祖先，上中为  该过程与经典的两个有序链表找公共节点的过程类似，具体实现在___中，读者可以自行思考这一过程如何以线性时间复杂度实现。

针对本地每个冲突的，枚举该的类型，推断出回滚该需要的逆操作并记录，如下：
    _  _
    _  重新同步该表
    _  重新同步并构建索引
    _  放弃，改由用户手工_
    _  针对_ 中的每一条子，递归执行 这一过程
    _  _
    普通文档的操作  从重新读取真实值并替换。相关函数为：_

针对中分析出的每条的处理方式，执行处理，相关函数为 _，此处操作主要是对步骤的实践，实际处理过程相当繁琐。

掉本地冲突的。


上面我们说到，对于本地失速的情况，也是走_ 流程统一处理的，对于失速，走_时会在找这步失败，之后会尝试更换复制源，方法为：从当前存活的所有和节点中找一个使自己“不处于失速”的节点。
这里有必要解释一下，是一个有限大小的 失速的唯一判断条件为：本地维护在复制源的游标被复制源的写覆盖想象一下你和同学同时开始绕着操场跑步，当你被同学超过一圈时，你和同学相遇了。因此如果某些节点的设置的比较大，绕完一圈的时间就更长，利用这样的节点作为复制源，失速的可能性会更小。
对的集群数据同步的描述暂告段落。我们利用一张流程图来做总结：

的线程模型与  指令乱序加速
与相关的代码有 ， _。上面我们介绍过，过程从复制源读取新产生的，并应用到本地，这样的过程脱不离是一个模型。由于需要保证顺序性，只能单线程实现。
对于端，是否有并发提速机制呢

首先，不相干的文档之间无需保证 的顺序，因此可以对 按照 哈希分组。每一组内必须保证严格的写入顺序性。

   
                          
                           {
           {
           
          _  = 
 
                 _         
                          
                       
           
                 {
                = 
               _  = 
              __   
          }
            =   
           
                     
          _
      }
  }

其次对于命令，会对表或者库有全局性的影响，因此命令必须在当前的完成工作之后单独处理，而且在处理 时，不能有其他命令同时执行。这里可以类比体系结构下的。

                
        ||             
           ==  ||   
                         
                           
             ==  {
            ==  {
                 
              _
          }  {
                               
                             
                   
              _
          }
  从库和主库的 顺序必须完全一致，因此不管、步写入用户数据的顺序如何，的必须保证顺序性。对于引擎的，只能以顺序插入来保证，因此对的插入是单线程进行的。对于引擎的，可以在时间戳字段上加上索引，从而保证读取的顺序与插入的顺序无关。
                    
                  
                      
         
        ||
           {
 
           
           
      }
 的类依赖与线程模型总结如下图：

二心跳与选举机制
的主节点选举由心跳触发。一个复制集个节点中的任意两个节点维持心跳，每个节点维护其他个节点的状态该状态仅是该节点的，比如因为网络分区，在同一时刻观察处于状态，观察处于状态
以任意一个节点的，在每一次心跳后会企图将主节点降级  ___，主节点降级的理由如下：

心跳检测到有其他节点的优先级高于当前主节点，则尝试将主节点降级 为， 值的动态变更提供给了运维一个可以热变更主节点的方式

本节点若是主节点，但是无法通集群中超过半数的节点原则则将自身降级为


选举主节点
节点检测到当前集群没有存活的主节点，则尝试将自身选举为。主节点选举是一个二阶段过程多数派协议。
第一阶段
以自身，检测自身是否有被选举的资格：

能通集群的过半数节点

必须大于

不能是节点


如果检测通过，向集群中所有存活节点发送询问其他节点关于“我”是否有被选举的资格
同僚仲裁
选举第一阶段中，某节点收到其他节点的选举请求后，会执行更严格的同僚仲裁

集群中有其他节点的比发起者高 

不能是节点

必须大于

以冲裁者的，发起者的 必须是集群存活节点中最新的可以有相等的情况，大家都是最新的


第二阶段
发起者向集群中存活节点发送请求，仲裁者收到请求的节点会执行一系列合法性检查，如果检查通过，则仲裁者给发起者投一票，并获得秒钟“选举锁”，选举锁的作用是：在持有锁的时间内不得给其他发起者投票。
发起者如果或者超过半数的投票，则选举通过，自身成为节点。获得低于半数选票的原因，除了常见的网络问题外，相同优先级的节点同时通过第一阶段的同僚仲裁并进入第二阶段也是一个原因。因此，当选票不足时，会秒内的随机时间，之后再次尝试选举。

相关推荐云数据库  如何计算价格 引擎分析与集群均衡接《 腾讯云  集群版配置管理揭秘  上 》
接收心跳
​配置客户端会通过上报角色，，这样的结构信息，该模块会根据上报信息，更新服务器上的客户端状态列表，以便让服务器及时知道配置客户端的存活与配置情况。筛选机器模块会比对客户端状态与服务器配置的，如果不同，将会把相应机器列为待推送的机器。​
​
  = 
  = 
  = 
 
​​注意：如果是上报的心跳，因为没有的概念，则只会更新最后心跳时间为当前时间，优先级，值等信息。​配置中心也会给配置客户端回包，表示收到了这个心跳，回包构造过程中有可能有如下异常上报。​ 构造状态回应包，序列化错误 构造状态回应包，包长不够 构造状态回包错误 发送状态回应错误 状态回包正确量 这个是与相反的上报，表示回包成功，是正常上报​处理上报过程中，这些异常也得关注。​ 上报状态，但该不在数据库中机往配置中心上报心跳，但配置中心并未记录该的，这很可能是已被移出集群，但上的进程还在，导致心跳一直在上报。​ 根据获取信息失败一个很底层公共函数，根据，在保存所有的服务器配置信息的数组中，寻找该的配置信息。如果寻找不到，就会上报。根据，在保存所有的客户端配置信息的数组中，寻找不到该的配置信息，也会进行相应的上报。​ 记录上报信息，为一般是刚初始化，从中，该_才会出现还配置为的情况。​ 记录上报信息，找到该上报心跳时，服务器上记录上报更新信息的列表中也恰好能找到该，进行该上报。属于正常情况。​ 不在中的上报了心跳与相反，上报的不在中，这很可能是下线的机器进程未清理，依然在上报心跳信息。​ 处理状态上报错误配置中心处理配置客户端的心跳上报过程中出现了错误，会有这个上报。​ 更新状态，耗时在对配置客户端上报的心跳包进行解包，更新客户端状态列表，以及回包的整个操作耗时多久，单位毫秒。下面几项与此相似。​ 更新状态，耗时在 更新状态，耗时在 更新状态，耗时在 更新状态，耗时在 更新状态，耗时在 更新状态，耗时在以上​
初始化
​  程序启动时必须跟一个配置文件路径参数路径可以是相对或绝对路径​
​
   = 
 {
 \ \
   \
  
 }

   =  绝对路径
 {
  ={}
    ==  
 {
   \
  
 }
 _ _   
 }
 
 {
 _ _  
 }
  \_
 _  _
​  变身守护程序​

​  使用信号量集，来避免 ___ 程序重复启动​
____ = 
____ = ____  
 = _______ 
 ____     返回代表没问题返回其他值代表有重复启动
{
  
   
         
  如果获取不成功
 =  _|_   
 {
        
  尝试创建这个信号量
 =  _ | _ | _ |
 _ | _ | _ = 创建成功
 {
     
 
​
 _ = 
 _ =  
 _ = 
​
      操作失败
 {
  _  
  ____
 }
 }
    ==  创建失败但是本来就存在
 {
 既然说本来就存在，那么再次尝试获取共享
 =  _|_  再次尝试可能是临界状态
 {
  _   
  ____
 }
 }
  创建失败
 {
  _
  ____
 }
}
​ 读取配置文件信息，如服务器地址信息等​
___
  _ _ 
  _ _ 
   _  _ 
   _  _ 
  _ _  _ 
   _  _ 
   _  _ 
  _ _ 
 _ _ _  _
 _ _ _ 
 _ _ _  _
 _ _ _ _ _
  _ _ ____
  _ _  
  _ _ 
  _ _ 
  _ _ 
  _ _ 
 
​摘取一个配置文件示例以及配上说明​
   服务器端口
   客户端端口
   日志级别
  
 __ 日志文件路径
  单日志文件最大大小
  保留最近的多少个文件
  
_  这个以及下面项，是配置中心的 连接
_  
_  
_  
  集群编号
  
  心跳上报的间隔秒
   配置中心间隔多少次都没有收到客户端的心跳上报，就认为其死机。
  推送配置的线程数
  推送配置的间隔秒
​ 获取本地内网​会按照，，的顺序，尝试获取本地网络接口的地址。​
  _ 
{
  
   
 _ = 
 _ = 
   = _ _ 
   
 {
  
 }
      
 {
 
  
 }
    =  
 _  = _     
 {
 _ == _
 {
   _  == 
 {
      __   _
 }
    _  == 
 {
      __   _
 }
    _  == 
 {
      __   _
 }
 }
 
 }
 
    
  
 
  
}
​​到目前为止，看我们大概取得什么关键信息？​_ 通过取得。​_ 通过配置文件取得​_ 日志详细级别，通过配置文件取得​_ 通过配置文件取得​_日志文件路径，通过配置文件取得​__通过配置文件取得​_ 如果该值大于，那么我们将设定为，以免推送线程太多。​ 如果该值小于，我们会让其等于，意味着这个配置不能小于秒，以免推送得太频繁。​ 创建推送配置信息的消息队列​创建消息队列 
 =_|​创建保存配置信息的服务端共享内存​创建共享内存=
___ 大概_ 指向这块共享内存​创建共享内存= _____，这块内存用于更新时的比对。​创建共享内存 _____ ​创建共享内存 ____ ​ 按照配置文件的地址连接，会带上名去连接，以尝试的连通性以及数据库是否已建立。​ 初始化各个线程互斥锁​
 ____
 ____
 ____
 ____
 ____
 ____
 ____
 ____
​ 信号注册
     这个是置_ = 
     这个是置_ = 
     这个是置_ = 作者：郑桂涛 

     

从开始，提供了两种省电延长电池寿命的功能：和 ；

表现形式：当设备没有连接到电源，设备进入模式时，系统将通过延迟最近用户没有使用的应用程序的后台运作及网络活动，让应用程序处于 状态，以此来减少电池消耗。谷歌表示，在和上测试，当屏幕处于关闭状态，平均续航时间提高；

版本要求：  及其更高版本；

开发者影响：为了保证用户的最佳体验，开发者有必要在和 模式下测试应用程序，及其对代码进行相应的调整。


 
设备进入睡眠模式时机：

用户不操作设备一段时间

屏幕关闭

设备未连接电源充电


模式下应用程序有什么变化：

系统试图通过限制应用程序访问网络和密集型服务节省电池；

防止应用程序访问网络，推延应用程序的工作，同步，和标准的警报；

系统定期提供一个短暂的时间让应用程序完成延迟的工作活动，在这个时间片里，系统将提供维持性窗口应用程序访问网络，运行在等待的同步，工作，和报警等活动。


模式的五种状态，分别如下：
：手机设备处于激活活动状态
：屏幕关闭进入非活动状态
_：每隔分钟让进入等待空闲预备状态
：空闲状态
_：处理挂起任务
如下图所示，期间提供间隔一小段时间供应用程序使用网络和处理挂起的活动。
从这张图我们可以看到，系统进入模式后，系统会隔一段时间处理正在挂起的任务，随着时间推移，后面间隔的时间会越来越长，以此来减少电量消耗。
退出模式系统退出休眠，所有的应用程序恢复正常活动：

用户唤醒装置移动，打开屏幕

或者设备连接电源


有哪些限制？

网络连接会被禁止

 会被屏蔽

定时任务延迟到下一个 进行处理，除非使用提供的方法： 或者

系统将不扫描热点

同步工作将被禁止

不允许进行任务调度


适配模式有什么方法？

影响到闹钟和定时器管理活动，在引入了两个新方法： 和，调用两个方法可以在模式下让系统响应定时任务

模式下限制了网络的连接，如果应用程序依赖于实时信息，那么这个将影响的体验。那么你需要使用   谷歌云消息后面详细讲解


测试和 模式的方法命令
测试模式

首先确保你的硬件或虚拟设备是或更高版本系统；

连接设备到开发机上并安装你的；

运行并让其运行活动；

关闭设备的屏幕；

运行以下命令使系统进入模式：
     
     

观察你的表现行为是否有需优化改进的地方。


测试 模式
步骤同测试模式

运行以下命令迫使系统进入 模式：
     
      

模拟唤醒你的应用程序使用以下命令：
      
     

观察你的，确保应用程序恢复正常从待机模式过程中，的通知及其背部活动能达到预期结果。


  
当用户不触摸使用应用程序一段时间时，该应用程序处于 状态，系统将把该标志为空闲状态。除非触发以下任意条件，应用程序将退出 状态：

用户主动启动该

该当前有一个前台进程或包含一个活动的前台服务，或被另一个或前台使用

生成一个用户所能在锁屏或通知托盘看到的 而当用户设备插入电源时，系统将会释放的待机状态，允许他们自由的连接网络及其执行未完成的工作和同步。如果设备空闲很长一段时间，系统将允许空闲一天一次访问网络。


和 的区别：
模式需要屏幕关闭通常晚上睡觉或长时间屏幕关闭才会进入，而 不需要屏幕关闭，进入后台一段时间也会受到连接网络等限制。
           
 什么是
  是一个云到设备的服务，可以让你支持实时在云端服务和设备上应用程序之间的消息传递。
提供了一个持久连接到云端的链接，让所有需要实时消息传递应用程序可以共享此链接。这个共享链接显著优化电池消耗，使其不必让多个应用程序各位维护自己单独的持久链接而使电池迅速耗尽。
由于这个原因，官方建议：如果你的应用需要消息传递与后端服务集成，我们强烈建议尽可能的使用，而不是单独维护自己的网络链接。
消息拥有高优先级，不影响模式，且不会不影响其他应用程序的状态。这意味着你的应用程序可以使用它们进行通信，同时最大限度地减少电池在整个系统和设备的影响。
以下来自官方解释：
一个实现包括谷歌连接服务器，在你的环境中通过或协议的连接服务器进行交互的应用程序服务器和客户端应用程序。
生命周期流程

注册启用： 客户端应用程序注册为接收消息。

发送和接收下行消息：


发送一个消息，该应用程序服务器发送信息到客户端应用程序：
．该应用程序服务器发送消息给连接服务器；
．当设备处于脱机状态，该连接服务器入队并存储消息；
．当设备联机时，连接服务器将邮件发送到该设备；
．在设备上，所述客户端应用程序根据该特定平台实现接收该消息。
接收消息，客户端应用程序收到一条消息从连接服务器。
发送和接收上游的消息： 如果您使用的是此功能只提供连接服务器 。
发送一个消息，客户端应用程序将消息发送到应用服务器：
．在设备上，客户端应用程序将消息发送到连接；
．如果该服务器已断开连接，该服务器连接入队并存储信息；
．当应用程序服务器重新连接后，连接服务器将邮件发送到应用程序服务器。
接收消息，一个应用服务器从连接服务器接收邮件，然后执行以下操作：
、解析消息头，以验证客户端应用程序发送的信息；
、发送“确认”的连接服务器以确认收到该消息；
、任选解析该消息有效载荷，由客户端应用程序所定义的。
除了，及更高版本还提供了模式白名单列表，通过设置应用程序进入白名单列表可逃脱模式的各种限制。
检测应用程序是否存在白名单里面，可使用的方法。
用户也可手动设置应用程序进入白名单列表里面，路径为：设置电池电池优化白名单：
客户端使用方法：

程序可发送为____的引导用户进入设置界面将应用程序设置进白名单列表里。

应用程序还可以使用___ 权限来触发一个系统对话来让用户添加到白名单里，而无需进入设置界面去设置。


当然，官方也提供用户把你的移除电池优化白名单的选项。这个白名单也会被 的另一个新特性  使用，所以用户只能简单的进行控制，也就是说设备并不会完全相信这个白名单。
官方举了一下白名单例子：
      
    
总结：
模式的推出本身是为了减少电池的消耗，且希望统一使用来传递消息进行通讯，而对于国内开发来讲，确实带来了很大的麻烦：

国内开发的一些消息推送机制将受到影响；

若使用，在国内使用延迟高，对于即时通讯产品来说选择还需勇气啊；

国内第三方手机厂商如华为、小米、三星，定制的也将使用定制的推送消息机制。这让同一款如何选择哪种推送机制才能兼容呢？


解决方法：

用户添加应用程序到电池优化白名单列表；

开发者使用提供的____意图和___权限设置以此忽略推荐；

使用提供的；

通过绕过模式。



文章来源于公众号：空间终端开发团队


相关推荐
深度了解  ，你准备好了吗？
  那点事前言
 是开源的容器集群管理系统，基于构建一个容器的调度服务，提供资源调度、均衡容灾、服务注册、动态扩缩容等功能套件，目前最新版本为。本文介绍如何基于构建平台，在正式介绍之前，大家有必要先理解几个核心概念及其承担的功能。以下为的架构设计图：

 
在系统中，调度的最小颗粒不是单纯的容器，而是抽象成一个，是一个可以被创建、销毁、调度、管理的最小的部署单元。比如一个或一组容器。
  
 是系统中最有用的功能，实现复制多个副本，往往一个应用需要多个来支撑，并且可以保证其复制的副本数，即使副本所调度分配的主宿机出现异常，通过 可以保证在其它主宿机启用同等数量的。 可以通过模板来创建多个副本，同样也可以直接复制已存在，需要通过 来关联。
、
是最外围的单元，通过虚拟一个访问及服务端口，可以访问我们定义好的资源，目前的版本是通过的转发来实现，转发的目标端口为_生成的随机端口，目前只提供云上的访问调度，如。如果与我们自建的平台进行整合？请关注下篇《与架构的整合》文章。
、
是用于区分、、 的键值对，仅使用在、、  之间的关系识别，但对这些单元本身进行操作时得使用标签。
、
不但解决了同一主宿机相同服务端口冲突的问题，还提供了转发服务端口对外提供服务的能力，后端使用了随机、轮循负载均衡算法。
一、环境部署
、平台版本说明
      
、平台环境说明

、环境安装
系统初始化工作所有主机
系统安装选择最小化安装
          
      _
      
  默认使用的是作为防火墙，这里改为防火墙熟悉度更高，非必须。
、关闭：
        停止
        禁止开机启动
、安装防火墙
        安装
        最后重启防火墙使配置生效
        设置防火墙开机启动
 安装主机
            
        
         
        
         
        
      
启动服务服务，如有提供第三方管理需求，另需在启动参数中添加“=”参数。
       
                  
配置服务防火墙，其中为服务端口，为集群数据交互端口。
               
               
安装涉及所有、主机
通过源方式安装，默认将安装   相关包。
        
       
升级至，覆盖文件即可，方法如下：
          
      
       
       
       
校验安装结果，出版以下信息说明安装正常。
       
      {    }
      {    }
配置仅主机
运行三个组件包括、、，相关配置项也只涉及这三块。
、【】 
           

  __=_=  

               

  _==  

          

  __==      

             

 __=_=
、【】
           

 __==  

            

 __==  

            

 _==  

       

 _=_=  

         

 __=_=  

      

 __=
、【】
        

 _==   

      

 ___=
、【】
      

 __=
启动侧相关服务  
      
         
         
配置仅主机
 运行两个组件包括、，相关配置项也只涉及这两块。
启动脚本更新
   
添加： ，最终配置如下，以便以后提供远程维护。
=    
修改防火墙配置，通常找不到主机多半是由于端口没有连通。
          
修改 端配置，以主机为例，其它主机同理。
、【】
           

 __=_=  

              

 _==  

         

 __==  

             

 __=_=
、【】
   

       

                   

 _==  

            

 _==  

             

 _=_=  

      

 _=
 、【】
 __=
启动服务
  
     
     
 、校验安装在主机操作，或可访问主机端口的 主机
   常用命令    
       查查看主机
       查看清单
    或         查看清单
       查看清单
    `  |  | { }`          删除所有
或者通过   方式推荐，及时性更高：
     |      查看版本
     |      查看清单
     |      查看清单
     |       查查看主机
     |       查看清单
注：在新版中，所有的操作命令都整合至，包括、、等
创建测试单元
      
  {  

       

       

       

     {  

       {  

           

           

         {  

            

            

          {  

              

              

         }  

       }  

     }  

   }  

    {  

        

   }  

 }
    
   
                                                           

                     =   
启动浏览器访问，对应的服务端口切记在中已添加。效果图如下：

观察在中的数据存储结构

观察单个的数据存储结构，以的格式存储。

二、实战操作
任务：通过创建一个架构的服务集群，以及观察其负载均衡，涉及镜像“”已经至，大家可以通过“  ”下载。     

           
      
、 创建一个 ，本例直接在模板中创建并复制，也可独立创建再通过来复制。
【】
  {  

       

       

       

     { }  

     {  

         

       { _}  

       {  

        {  

           {  

               

               

               

              { {{}}}  

              { {{}}}  

              { {{}}}  

               

             {  

                 

                 

                     

                 

                { }  

                { }  

                { }  

                 

                 

                 

               {  

                   

              }{  

                   

             }  

            }  

          }  

        }  

         { _}  

       }  

   }  

 }
执行创建命令
    
观察生成的副本清单：
    
                                                                              

              =_   
              =_   
              =_   
              =_   
              =_   
              =_   
、创建一个，通过指定  _与关联。
【】

 {  

      

      

      

    {  

      _  

   }  

      

      

      

}
执行创建命令：
   
登录主机，查询主宿机生成的转发规则最后一行
   
   

                                           
                                                      
                                                         
                                                         
访问测试，，刷新浏览器发现后端的变化，默认为随机轮循算法。


三、测试过程
 、自动复制、销毁测试，观察自动保持副本数份
删除中一个副本
     
            


    
                                                                             
                =   
                =   
                =   
                =   
                =   
自动生成出一个副本，保持份的效果
     
                                                                             
                =   
                =   
                =   
                =   
                =   
                =   
 、测试不同角色模块中的
中为空，而为指定端口，则异常；两侧都指定端口，相同或不同时都异常；的为指定，另为空，则正常；的为空，另为空，则正常；结论是在场景不能指定，否则异常，待持续测试。
 结论：在中， { _}要与 { _}以及中的 { _｝保持一致；
请关注下篇《与架构的整合》，近期推出。
参考文献： __  近日，被称为“ 之父”的   在  上回答网友提问。在问答环节中， 不仅介绍了谷歌大脑 目前正在进行的工作，还详细阐述了  目前碰到的各种问题，以及未来的发展方向。作为《 》的作者之一， 也对深度学习的未来发表了自己的见解。此外，作为“机器学习大师”   曾经的学生，对于一些大学生、独立开发者的困惑， 甚至给出了诸如如何选课之类的建议。
在科技大本营公众号会话回复“”，即可获得《 》电子书。

作者 |  翻译 | 科技大本营参与 | 彭硕，大琦
以下为  的回答：
 目前存在的问题及未来
问：谷歌大脑”年在做些什么？
 “谷歌大脑”团队相当庞大，每位研究人员都有很大的自由来决定自己想做的工作，实现自己的想法，因此很难对我们的工作做一个总结。
你可以在我们的网站上查看我们所做的研究：  
我们会做基础研究，改进机器学习算法；开发计算机系统，驱动机器学习比如；运用机器学习解决医疗保健、机器人技术以及音乐艺术创作等领域的问题。
我现在所在的基础研究团队致力于研究对抗式机器学习。
问： 能够生成漂亮的名人脸部以及卧室图片，为什么它们在其他上千种的类别上不能做到如此完美呢？
我们其实也不知道。我们曾经以为是类似  离散定理小值损失函数使然。对于生成模型来说，如果这个模型足够大，很多损失函数都能够精确复制训练分布。
那么问题是，当模型不够大的时候，发生了什么呢？是不是模型只处理那些实际的样本，却放弃了生成类似训练中的某些类的样本？还是说模型会尽量包括所有的类别，但有时候一些分类聚在一起会产生模糊、不切实际的样本 根据  离散定理，是前者。
这个问题我们考虑了很长时间，就是这个原因导致了模型崩溃。之后，我又发现了少数不同的损失函数能够被利用在生成式对抗网络中，比如在数据和模型中间的离散值就会更倾向选择后者。这些损失函数一般不会导致模型崩溃，但问题仍然发生了
在这之后，我认为模型崩溃是由于学习算法中的非收敛性。这也就意味着在生成对抗网络中的  均衡能够覆盖所有模型，但学习算法可能找不到  均衡。我当时认为有必要设计一个更好的能够找到  均衡的可靠学习算法。在后来的几个月里，推理结果显示，有几个理由让我们可以相信现有的算法本应该能够找到  均衡的：                      
把这些理论结果阐释清楚是很重要的，因为我们在实际操作过程中的生成式对抗网络，未必和理论中的假设是相对应的，理论中的那些断言并没有“生成式对抗网络一定会达到  均衡状态”来的直接，等等。但是把这些理论成果放在一起，确实会降低我对模型崩溃来自于非收敛性上的自信。
最近我在考虑，模型崩溃可能来自我们利用的神经网络的架构。如果我训练一个自编码器重新构建  图片，然后随机从一个高斯分布中抽取编码值并对其进行解码，所有生成的图像在语义上都是相似的。我本来以为会生成各种各样的完全不像是训练数据的不尽人意的图片。相反，它的模型也崩溃了，尽管根本就没有进行过任何的  训练。
这让我想到了生成器网络的体系结构，这种结构使它更容易表达包含模式崩溃的函数，而不是对应各种不同样本的函数。我怀疑我们是否看到了类似于幂函数的东西，在这个方法中，通过矩阵的变换，不停地将一个向量与矩阵的主特征向量相乘。显然，生成器网络并没有像幂函数那样做，因为每一层都有不同的参数，但是我想知道我们是否忽略了一些相关的影响。
问：什么情况下， 能够从任意  类别中生成高质量图片不仅仅是名人或者卧室？
也许，最好的能生成多样的  分类的  是辅助分类的：         
一定要记住，在训练流程中利用分类标记来把数据划分成不同类别的小组，因此，它更像是几个能够生成不同种类图片的 ，而不是一个巨大的 ，这样可以避免模型崩溃的问题。
问：一般情况下，对抗性训练能否有效针对对抗样本？
通常来讲，不是。
一般在训练中，如果你用优化算法  来创建对抗样本，那么模型会适应算法 ，但在鉴别由算法  产生的对抗样本的时候会出现失败。我和通过观察各种各样的算法发现了这个影响。
我也听说有人利用很强大的优化算法，发现在一些案例中，模型根本无法适应训练中的对抗样本。  告诉我，在他进行上千次的迭代的   训练中，发生了这个情况。
最近，  发现，在通过随机重启进行的梯度上升的对抗训练中，他遇到了无法打破的一个模型。无论在  数据集，还是在  上，我认为还存在很大的缺陷。
如果你想尝试打破  模型，请看网址：_ _
问： 会被用于制造签名和破坏识别软件的恶行吗系统安全专家如何防范这一问题？
所有的工具都能用来做好事或者坏事。锤子可以用来建造一所房子，不幸的是锤子也可以用来当武器。会有人利用  来做一些坏事。举个例子，下面就有一个通过  来生成恶意软件的论文：           
问：对抗学习与强化学习有何不同他们能像  卷积神经网络强化学习一样一起工作吗？
在传统的机器学习中，有两个概念：成本和参数，训练算法会通过修改参数以降低成本。在对抗式机器学习中，有不止一个“玩家”，每个玩家都有不同的成本和不同的参数。每个玩家只能修改自己的参数，但成本取决于所有玩家。使用对抗性的方法来强化学习是可能的。例如，你可以在对抗样本中训练  代理，以便使它的鲁棒性更强       
问：对抗式机器学习研究有哪些新的、有趣的研究方向？
防御对抗样本是一个非常热门的课题。如果你想研究这个课题，你可以看看我们的  竞赛     

  等人发现：使用随机重启迭代算法生成的对抗样本，对机器学习模型进行对抗训练，所得模型在和 上的防御效果非常好。
还有一个热门课题：如何在不同模型之间更好地转移对抗样本，如何让对抗样本骗过应用在现实世界中的模型        ，用相机从不同的距离和角度观察对抗样本    。
我个人的很多工作主要是让  更加稳定、可靠且易于使用。
很多人对于如何将用于文本非常有兴趣。
隐藏信息的对抗技术      
半监督学习的对抗方法                   

当然，还有很多其他的研究正在紧锣密鼓地进行，这里就不列出所有研究内容了。
问：您最喜欢用哪些方法来进行超参数优化？
随机搜索——同时利用随机超参数运行个工作，选择其中的最好的个，接着收紧随机分布，花更多的时间在最好的工作上。然后再运行新的一组个工作。
差不多每年我都会尝试最新流行的超参数优化器，看看它们是否比随机搜索更优秀。目前为止，我还没有发现能够哪个优化器真正打败上文提到的随机搜索程序。我意识到别人会有不同的体验，相比大多数人，我倾向使用更多的超参数，因为我正在研究环境中使用超参数优化器。
深度学习的未来
问：深度学习会往哪个方向走？
 深度学习接下来还有很多工作要完成。我们要做的是朝多个方向向外扩展研究工作，而不是只朝一个方向前进：

更好的强化学习、整合深度学习和强化学习。能够可靠地学习如何控制机器人的强化学习算法等。
更好的生成式模型。能够可靠地学习如何生成人眼无法分辨的图像、语音和文本的算法。
学习如何学习以及无处不在的深度学习：能实现重新设计自身架构、调整自身超参数等功能的算法。目前仍然需要人类专家来运行“学习如何学习”的算法，但是未来这种算法将更容易部署，各种非专门研究的企业都将能够运用深度学习。
安全之于机器学习，机器学习之于安全：将有更多网络攻击利用机器学习来生成自主性更强的恶意软件，造成欺骗性更强的漏洞等。也将有更多的网络防御利用机器学习做出比人类响应更快的响应，检测出更隐秘的入侵等。攻守两方的机器学习算法将互相欺骗，以实施攻击或防御。
活动的动态路由 将促使人类构建更大的模型，这种模型处理单一样本所需的计算可能比当前的模型少。但总体而言，超大量的计算仍将是的关键；每当我们构建出某个计算量更少的模型时，我们就会想通过并行运行数千个模型来学习如何学习这些模型。
半监督学习和一次性学习将减少训练多种模型时所需的数据量，并使的应用范围更加广泛。
未来的研究将侧重于构建几乎从不出错的超稳健模型，这些模型可应用于安全性至关重要的程序中。
深度学习将不断融入到大众文化中，我们将会看到艺术家和流行文化创造者使用它来完成一些我们从未想到的事情。我认为 的实验室和之类的项目正是这股潮流的开端。

问： 未来哪些机器学习领域将会取代深度学习？
深度学习的定义非常广泛，我不确定它是否会被替代。
深度学习意味着学习好几步的处理方法，而不是仅学习一步。从这点上讲，相对于浅显的算法，深度算法的数量未来会激增。
在年至年间，深度学习非常流行，但深度学习通常意味着要把无监督的学习算法堆积起来，以此来为监督式学习来定义复杂的特征。
从年开始，深度学习通常意味着通过反向传播来优化具有可微分函数的深度计算图表中的所有参数。
从目前来看，我们很快就会拥有更具有贝叶斯特性的算法而不是建立在对最好参数的一个点估计值，这些算法会运用更多不可微分的操作，等等。当我们停下来思考这还算不算的上“深度”的时候，我们可能仍然认为这就是“深度”。我认为我们将来不会太重视“深度学习”和其他学习算法的区别，深度学习早已经被大家接受了。
问：在未来的 年内，您最期待看到  领域发生哪些变化？
不同的人期待的也不一样，我个人更渴望看到：

能产生对抗式样本的一个有力的防御，能够在像一样的真正的数据集里起作用。
对抗式样本能够理论化，类似于我们目前知道的关于一般监督式学习的知识。比如 原理、 理论，等等
生成式的模型能够起到真正的作用。
高效的样本学习算法能够像人类一样，可以从很少的标记样本中学习。

给大学生和独立研究人员的建议
问：大二学生该如何学习人工智能？
如果你有志向，可以试着动手学习并参加我们的对抗样本竞赛：    。

参加线性代数和概率论课程。
参加教你如何编写适合现有硬件运行的的课程。这些课程多为硬件设计课程，而不是编程课。如果找不到这类课程，你可以向你的学业导师寻求帮助。
参加教你如何编写高性能、实时多线程的代码的课程。有时这个课题会被归在另一课程中，如操作系统开发或游戏开发。
阅读《 》。
选择一个你感兴趣的简单深度学习项目。如果你对在自身爱好或课程项目中应用深度学习没什么想法，你可以选择一些普通的项目，例如在中从零开始构建分类器。在完成这个项目的过程中，如果你对读过的关于深度学习的材料有疑问，试着在你的项目数据集中运行试验，通过这种方法来弄清楚这些问题。
如果你的大学开设有机器学习、计算机视觉、自然语言处理和机器人学等课程，一定要参加。
申请“谷歌大脑”项目实习。

问：你会鼓励其他领域的人比如机械工程来学习  机器学习吗？
是的，当然会。
比如我崇拜的英雄之一—— ，他的博士学位就是实验心理学。在我看来，在机械工程学中，你会学习很多在机器学习中经常用到的数学工具，因此你不会从零开始。
总之，我们经常发现当一个人带着从其他领域产生的新的想法来到这个领域的时候，这个领域会发生革命性的变化。
问：没有任何技术背景的人如何学习 ？
掌握一些基础知识还是很重要的，比如线性代数、概率论和编程。
但你也不需要知道所有线性代数的知识出了校园以后，我再也没用过分解，所有的概率论的知识关于组合学、深度学习中的序列重排序我们用的也不多，或者所有的编程知识很多比较晦涩的语言特征实际上被许多公司禁用了。
想要入门，最好先学习足够的线性代数、概率论和编程，只用和，你就可以自己进行逻辑回归。
我认为如果你能读懂《 》的章，你就能够学会那个工程中除了编程之外的所有知识。这是否可行，我也不是很清楚，因为我很难从一个没有任何技术知识的角度去想这件事。很明显，想要从零开始吸收那么多的知识，你需要很大的耐心和付出，但我们会尽量在书中提供更多的细节让你达到这个目的。
问：您最想推荐哪本书？
首先我会推荐我、 和  合著的《 》。  的《    》  和  的《  》  和  的《   》   的《  》  的《   》  等人合著的《       》          事业的社会面也极其重要！  和   的《        》如果你对生成式模型或计算机视觉感兴趣：          的《 》
问：独立学习者或研究人员如何与 、 或  等大公司、大机构在深度学习领域一较高下？
在“谷歌大脑” ，我们经常思考如何选择与他人不同、真正值得做的项目。我在 任职期间，这家公司也将选题作为自身战略的重要部分。
全世界对  的广泛关注，意味着研究已从优化转为博弈论。过去，研究人员可以选择研究他们所认为的好课题。现在，重要的是预测其他研究人员会研究什么，并选择一个可以带来独特优势的课题。

原文地址
文章来源：科技大本营美国东部时间月日，全球知名非营利性组织    在全球开源盛会“ 峰会”上宣布，腾讯云作为金牌会员正式加入基金会。 
按照规则，基于企业会员对代码的贡献、贡献的标准和规范、为开源组织提供的支持等综合标准，基金会授予腾讯云金牌会员身份，同时基于腾讯云在领域的积极贡献，腾讯云获基金会邀请加入基金会。
 
腾讯云是国内最大的基于提供容器服务的公有云服务商，也是拥有国内最大规模集群的企业。腾讯云加入和基金会，标志腾讯云深度参与全球开源技术生态圈，在容器服务、虚拟化等重大开源项目的实力已经得到全球核心开源组织和业界的认可，将为腾讯云进一步参与全球开源社区技术交流、参与开源项目开发等领域开拓全新局面。
及基金会
据悉，基金会是由 基金会发起的，致力于管理和运转原生云项目，吸纳开源社区和合作伙伴，共同推动以及容器计算发展的非营利组织，其成员包括、、、 、等国际知名科技公司。
基金会是全球知名的非营利性的联盟，致力于促进的发展，推动行业产生原创性技术研究和内容，以促进的发展。
腾讯云加入基金会的用户价值
基金会的执行董事 对腾讯云的加入表示欢迎，他表示，“建立在开源技术上的容器服务正在以难以置信的速度，让公司实现向云计算的迁移，这印证了目前大环境对开源技术的热情和信任。同时，对容器服务的积极采用将助燃一个新兴市场的产生，并让我们的用户立于不败之地。热烈欢迎新成员加入，我们希望大家可以从基金会和社区中获得帮助和指导，这将进一步夯实作为提供行业最优实践和云原生生态系统的第三方的重要价值。”
腾讯云专家工程师刘颖表示，容器技术的发展在为中国的云计算提供新思路，对云计算领域产生积极深远的影响，腾讯云在国内提供的容器技术已经帮助大量互联网和传统企业快速构建云原生应用，使企业系统组件化、微服务化，实现持续集成和交付，加快应用迭代，降低开发成本，同时也是实现的重要支撑。  
腾讯云在与领域的贡献
在实际的产品设计中，腾讯云的容器技术不仅拥抱开源、支持用户直接调用 ，还基于打造了、等产品插件，并在容器网络上以腾讯云私有网络为基础，实现高可靠、高性能的网络方案。三一重工、华尔街见闻在面对原系统拆分后微服务架构部署、开发测试应用部署等需求时，均选择使用腾讯云容器服务。
在加入基金会后，腾讯云将从产品出发，基于大量用户在产品使用中的感受和腾讯云的服务实践，将有价值的特性推送和反馈给社区，与社区一起完善相关特性，同时又从社区中获得广泛的用户反馈，再次回到产品，提升腾讯云的产品体验。比如腾讯云将在未来推送自身的相关特性进入开源社区，并继续通过的， 及 等方式更多地参与到社区特性开发的工作当中。在这个过程中，腾讯云紧密服务社区，并进一步拓宽技术视野，更深地加入到全球技术交流中 。
与此同时，腾讯云多年来一直与开源社区互动，与专注系统底层、高性能加速、解决方案的各类社区保持稳定良性的交流，不断反馈技术成果。腾讯云在云计算基础关键技术——虚拟机热迁移和稳定方面已经取得了重大成果，设计热迁移过程中内存的快速写保护算法，解决了虚拟机热迁移过程中如虚拟机磁盘性能下降、迁移后镜像零页写操作等难题，还重构了的计时框架，让虚拟机的时钟系统在时钟频率频繁调整的情况下保持精准。 
腾讯云在与社区的计划
过去，这些成果都由腾讯云以核心的方式回馈给和社区，而加入和基金会后，基于腾讯云在容器服务的实践，将给予原生云建设回馈；同时腾讯云基于庞大的用户规模，在虚拟机方面有丰富的研究与实践，将给予社区以巨大的回馈。 
刘颖表示，希望能成为全球开源社区的新力量，推动和的发展，分享腾讯云的经验，为和的项目做出贡献，腾讯云将与社区紧密联系在一起，为全球用户提供高品质、全能力的技术服务。
在数字经济时代，云计算正在改变整体商业的运作模式，而开源技术也在加速企业向云计算迁移的步伐，以及改变云计算领域部署和管理应用的方式。自建立以来，和基金会始终在推动合作伙伴在社区共同贡献更多的开源技术，腾讯云的加入将有望加速全球技术的发展进程。 马晓宇 杨哲轩
 是  推出的为了解决用户复杂  需求的产品。借助  平台本身的优势，同时融合  分布式集群的优势，和  一起为用户一站式解决    需求。  依赖  集群和  的存在。当然， 也需要你搭建一个  集群。本文简单介绍如何部署和使用 。本文假设你对  有基本认知。你可以参阅   官网 了解  相关信息。
一、概述
 是将   直接运行在  存储引擎  上的  解决方案。 架构图如下：


 深度整合了   引擎 可以对计算提供精确的控制，使  能够高效的读取  中的数据，提供索引支持以实现高速的点查；

通过多种计算下推减少   需要处理的数据大小，以加速查询；利用  的内建的统计信息选择更优的查询计划。

从数据集群的角度看，   可以让用户无需进行脆弱和难以维护的 ，直接在同一个平台进行事务和分析两种工作，简化了系统架构和运维。

除此之外，用户借助  项目可以在  上使用  生态圈提供的多种工具进行数据处理。例如使用  进行数据分析和 ；使用  作为机器学习的数据源；借助调度系统产生定时报表等等。


二、环境准备
现有  版本支持  ，对于   及   还没有经过良好的测试验证。对于更低版本暂时无法支持。
 需要   以及   默认  版本。
 可以在 ，， 等任意  模式下运行。
三 、推荐配置
 部署  和  集群
  集群部署配置
对于  和  分开部署的场景，建议参考如下建议

硬件配置建议

普通场景可以参考  和  硬件配置建议，但是如果是偏重分析的场景，可以将  节点增加到至少  内存，如果是机械硬盘，则推荐  块。

 参数建议


 =    如果使用场景偏向分析，则可以考虑扩大这个参数

 = 


 = 
 = 


 = 


 = 


 = 


 = 


 = 
    集群独立部署配置
关于  的详细硬件推荐配置请参考官网，如下是根据  场景的简单阐述。
 推荐  内存以上配额。请在配置中预留  的内存给操作系统。
 推荐每台计算节点配备  累计  到  核以上。你可以初始设定分配所有  核给 。
 的具体配置方式也请参考官方说明。下面给出的是根据  配置的范例：
    __=
     __=
     __=
  与  集群混合部署配置
对于 、 混合部署场景，请在原有  预留资源之外累加  所需部分并分配  的内存作为系统本身占用。
四、部署 
 的  包可以在这里下载。
 已有  集群的部署方式
在已有  集群上运行  无需重启集群。可以使用  的  参数将  作为依赖引入
  
如果想将  作为默认组件部署，只需要将  的  包放进  集群每个节点的  路径并重启  集群：
{__}
这样无论你是使用  还是  都可以直接使用 。
 没有  集群的部署方式
如果你没有使用中的  集群，我们推荐   方式部署。我们在这里简单介绍下  部署方式。如果遇到问题，你可以去官网寻找帮助；也欢迎在我们的  上提 。
 下载安装包并安装
你可以在这里下载  。
对于  模式且无需  支持，请选择   且带有  依赖的      任意版本。如你有需要配合使用的  集群，请选择对应的  版本号。你也可以选择从源代码自行构建以配合官方   之前的版本。请注意目前  仅支持   版本。
假设你已经有了  二进制文件，并且当前  为 。
请将   包拷贝到 {} 目录下。
 启动 
在选中的   节点执行如下命令：
 

在这步完成以后，屏幕上会打印出一个  文件。检查  文件确认  是否启动成功。 你可以打开  查看集群信息如果你没有改动  默认  。在启动  的时候，你也可以通过这个面板来确认  是否已经加入集群。 
 启动  
类似地，可以用如下命令启动 节点：
 
命令返回以后，你就可以通过刚才的面板查看这个  是否已经正确的加入了  集群。 在所有  节点重复刚才的命令。在确认所有的  都可以正确连接 ，这样之后你就拥有了一个  模式的  集群。 
五、一个使用范例
假设你已经按照上述步骤成功启动了  集群， 下面简单介绍如何使用   来做  分析。这里我们用名为  数据库中的  表作为范例。
在  里输入下面的命令  假设你的  节点位于 ，端口 ：
 

  =   


之后你可以直接调用   
       
结果为：

|    |

|   |

六、
 是独立部署还是和现有 ／ 集群共用资源？
 你可以利用现有  集群无需单独部署，但是如果现有集群繁忙， 将无法达到理想速度。 
 是否可以和  混合部署？
 如果  以及  负载较高且运行关键的线上任务，请考虑单独部署 ；并且考虑使用不同的网卡保证  的网络资源不被侵占而影响线上业务。如果线上业务要求不高或者机器负载不大，可以考虑与  混合部署。前言
大家有没有发现之前我们写的爬虫都有一个共性，就是只能爬取单纯的代码，如果页面是渲染的该怎么办呢？如果我们单纯去分析一个个后台的请求，手动去摸索渲染的到的一些结果，那简直没天理了。所以，我们需要有一些好用的工具来帮助我们像浏览器一样渲染处理的页面。
其中有一个比较常用的工具，那就是


                               是一个无界面的可脚本编程的浏览器引擎。它原生支持多种 标准： 操作，选择器，， 以及。

好，接下来我们就一起来了解一下这个神奇好用的库的用法吧。
：服务器是腾讯云

安装
安装方法有两种，一种是下载源码之后自己来编译，另一种是直接下载编译好的二进制文件。然而自己编译需要的时间太长，而且需要挺多的磁盘空间。官方推荐直接下载二进制文件然后安装。
大家可以依照自己的开发平台选择不同的包进行下载

下载地址

当然如果你不嫌麻烦，可以选择

下载源码

然后自己编译。
目前最新发行版本是 ，
安装完成之后命令行输入
 
如果正常显示版本号，那么证明安装成功了。如果提示错误，那么请重新安装。
本文介绍大部分内容来自于官方文档，博主对其进行了整理，学习更多请参考

官方文档

快速开始

 第一个程序

第一个程序当然是 ，新建一个  文件。命名为 
 

命令行输入
 
程序输出了 ，！程序第二句话终止了  的执行。
注意：这句话非常重要，否则程序将永远不会终止。

页面加载

可以利用  来实现页面的加载，下面的例子实现了页面的加载并将页面保存为一张图片。
  = 
   {
       
      ===  {
        
    }
    
}
首先创建了一个对象，然后加载本站点主页，判断响应状态，如果成功，那么保存截图为
以上代码命名为 ，命令行
 
发现执行成功，然后目录下多了一张图片，

因为这个  方法， 经常会用到网页截图的功能。

测试页面加载速度

下面这个例子计算了一个页面的加载速度，同时还用到了命令行传参的特性。新建文件保存为
  = 
   = 
   

  ===  {
     
  
}

 = 
 = 
  {
    ==  {
        
  }  {
     =   
       
           
  }
  
}
程序判断了参数的多少，如果参数不够，那么终止运行。然后记录了打开页面的时间，请求页面之后，再纪录当前时间，二者之差就是页面加载速度。
  
运行结果
 
   
这个时间包括渲染的时间，当然和网速也有关。

 代码评估
                 “”                                   ’    

利用  方法我们可以获取网页的源代码。这个执行是“沙盒式”的，它不会去执行网页外的  代码。 方法可以返回一个对象，然而返回值仅限于对象，不能包含函数或闭包
  = 
  = 
  {
    =  {
     
  }
       
  
}
以上代码获取了百度的网站标题。
   百度一下，你就知道
任何来自于网页并且包括来自内部代码的控制台信息，默认不会显示。
需要重写这个行为，使用  回调函数，示例可以改写成
  = 
  = 
 =   {
    
}
   {
      {
        
    }
    
}
这样的话，如果你用浏览器打开百度首页，打开调试工具的，可以看到控制台输出信息。
重写了  方法之后，可以发现控制台输出的结果和我们需要输出的标题都打印出来了。
一张网页，要经历怎样的过程，才能抵达用户面前？
一位新人，要经历怎样的成长，才能站在技术之巅？
探寻这里的秘密；
体验这里的挑战；
成为这里的主人；
加入百度，加入网页搜索，你，可以影响世界。

请将简历发送至  _ 邮件标题请以“姓名应聘职位来自”命名 
职位介绍：
百度一下，你就知道
啊，我没有在为百度打广告！
屏幕捕获

                                              

因为  使用了 内核，是一个真正的布局和渲染引擎，它可以像屏幕截图一样捕获一个界面。因为它可以渲染网页中的人和元素，所以它不仅用到，的内容转化，还用在，。可见其功能是相当强大的。
下面的例子就捕获了网页的截图。上文有类似内容，不再演示。
  = 
  {
  
  
}
除了  格式的转换，还支持 ，，等格式。

测试样例

其中最重要的方法便是  和  属性。
 是视区的大小，你可以理解为你打开了一个浏览器，然后把浏览器窗口拖到了多大。
 是裁切矩形的大小，需要四个参数，前两个是基准点，后两个参数是宽高。
通过下面的小例子感受一下。
  = 
        
 = {     }
             
 = {         }
           
  {
  
  
}
运行结果

就相当于把浏览器窗口拖到了 × 大小，然后从左上角裁切出了 × 的页面。
网络监听

                    

因为  有网络通信的检查功能，它也很适合用来做网络行为的分析。

                       

当接受到请求时，可以通过改写和回调函数来实现接收到资源请求和资源接受完毕的监听。例如
  = 
  = 
 =  {
       
}
 =  {
       
}

运行结果会打印出所有资源的请求和接收状态，以格式输出。
页面自动化处理

                 

因为  可以加载和操作一个页面，所以用来自动化处理也是非常适合的。

操作
                      

脚本都是像在浏览器中运行的，所以标准的  的  操作和  选择器也是生效的。
例如下面的例子就修改了 ，然后还返回了页面中某元素的内容。
  = 
       
 = 
  {
    ==  {
       
  }  {
      =  {
       
    }
    
  }
  
}
运行结果

                
      

首先打印出了默认的 ，然后通过修改它，请求验证  的一个站点，通过选择器得到了修改后的 。

使用附加库

在版本之后允许添加外部的库，比如下面的例子添加了，然后执行了代码。
  = 
  {
    {
     {
      
    }
    
  }
}
引用了  之后，我们便可以在下面写一些  代码了。
对象
在前面我们介绍了  对象的几个方法和属性，其实它本身还有其它很多的属性。具体的内容可以参考


用例

里面介绍了 的所有属性，方法，回调。

命令行

 
提供的命令行选项有：


–                  ［帮助列表］

–                   ［查看版本］

–=          ［指定存放的路径］

–=|               | ［硬盘缓存开关，默认为关］

–=|                | ［忽略错误，默认不忽略］

–=|          | ［加载图片，默认为加载］

–=         ［本地存储路径，如本地文件和文件等］

–=       ［本地文件最大大小］

–=|             | ［是否允许远程加载文件，默认不允许］

–=         ［最大缓存空间］

–=           ［默认输出编码，默认］

–              ［远程调试端口］

–        ‘’  ‘’  ［在调试环境下是否立即执行脚本，默认否］

–=        –= ［代理］

–=||           ［代理类型，默认］

–         –= ［代理认证］

–=            ［脚本编码，默认］

–=|||’           ［协议，默认］

–=              ［证书路径，默认系统默认路径］

–=|             | ［是否开启安全保护和禁止异站，默认开启保护］

–   ‘  ’   ‘’  ‘’ ［以远程模式启动］

–       ‘’  ‘’      ‘–’ ［接口］

–=                 ［所有的命令行配置从中读取］



注：文件配置格式
{
     = 
   

     = 
   

     = 
   

    
}

        

   = 
   = 
   = 
   = 
   = 
   = 
以上是命令行的基本配置
实例
在此提供官方文档实例，多对照实例练习，使用起来会更得心应手。

官方实例

结语
以上是博主对  官方文档的基本总结和翻译，如有差错，希望大家可以指正。另外可能有的小伙伴觉得这个工具和  有什么关系？不要急，后面会有  和  的综合使用的。

相关推荐
腾讯云上用法示例腾讯云主机环境安装爬虫框架过程接《  技术快报》：计算机视觉篇上
           
原文链接：________
项目主页：
结果视频：=
【摘要】
本文来自伦敦大学学院和爱丁堡大学的研究人员。作者提出了一个高效、统一的基于多阶段深度学习的框架来解决单幅图像中维关节估计和维姿态估计问题。
【问题】
以往的方法在解决维关节估计和维姿态估计问题时，往往是分步骤进行的，第一个过程的结果是第二个过程的输入，这样分步骤会造成信息损失，同时最终的估计结果也并不是最优的。
【解决方法】
提出一个统一的基于多阶段深度学习的框架来解决维关节估计和维姿态估计问题。
该框架提出了一个新的架构，可以将基于图像外观特征提取的标志点位置信息与用预训练好的姿态模型提取的几何骨骼信息结合起来统一学习，最终提高姿态和姿态的估计精度。

基于多阶段深度卷积神经网络的人体姿态估计流程图
【结果分析】
●     优势：在数据集上分别进行和姿态估计，与当前最好的方法相比，估计准确性分别要高于对比方法。
●     不足：计算效率上还打不到实时。
●     手势
              
原文链接：
项目主页：
【摘要】
本文来自新加坡南洋理工大学和新加坡 高性能计算研究所。作者提出了一种简单有效、实时的手部姿态估计的方法。对于深度图像利用一种三维数据体的表示方法，并有效利用数据的空间结构信息，提升算法性能。
【问题】
●     由维提取的基于图像的特征由于缺少空间信息，并不完全适用于手部姿态估计。
●     多视图仍然无法完全充分利用深度图像中的空间信息
【解决方法】
从深度图像分割出手的部分，提取手的点云并编码为维数据体，这一个数据作为维的输入，输出为一组手在维数据体中的关节相对位置。最后利用简单的坐标变换来获得手在相机系统下的关节位置。
 
方法整体流程图
【结果分析】
●     优势：
❖   在和数据集上进行实验，并与当前最好的方法——层次回归方法——进行比较。当误差阈值维时，提出的方法要由于当前最好方法。实验环境为块：      ，： 
❖   实时运行，超过
❖   对于手部尺寸变化和整体方向变化比较鲁棒
              
原文链接：
结果链接：=
【摘要】
文章由瑞士苏黎世联邦理工学院、波恩大学和荷兰语天主教鲁汶大学的研究人员共同发表在上。作者创新性地结合了生成式对抗网络和半监督学习，充分利用了没有标签的深度图，从而改进了泛化性能。同时方法具有非常高的计算效率。
【问题】
●     从单一的深度图像估计手部姿态需要大量的标注训练数据，成本很高
●     以往基于图像合成的方法得到的结果真实感比较差
【解决方法】
结合生成式对抗网络和半监督学习进行结构预测：基于变分自编码器估计姿态估计，利用生成高质量深度图用来训练模型，在一个多任务学习的框架下统一处理姿态估计问题。
 
整体处理流程图
【结果分析】
●     优势：
❖   在、和三个公开数据集上与分别与该数据集的当前种 方法进行对比。结果显示提出的方法在估计误差上要优于对比方法。
❖   更好的泛化性
❖   对于大视角的姿态变化的估计更加鲁棒
❖   可以更好地利用无标记的数据
❖   在上可以达到实时估计
视觉跟踪   
视觉跟踪一般也被称为目标跟踪，就是在连续的视频序列中，建立所要跟踪物体的位置关系，得到物体完整的运动轨迹。具体的，在第一帧图像给定目标的状态，一般是目标的 信息，然后预测之后每帧图像中目标的状态，对应的也是目标的 信息。
        
原文链接：________
项目主页：
【摘要】
本文来自韩国首尔国立大学的研究人员。作者创新性地将强化学习与目标跟踪结合起来，讲目标跟踪问题转化为一系列决策行为。提高了跟踪系统的准确率和计算效率。下图是文章核心思想的一个示意图。
预测跟踪目标未来的位置对应为一系列动作决策
【问题】
目前基于卷机神经网络的方法虽然获得了比传统方法更好的性能，但是也面临着以下问题：探索感兴趣区域的和选择最佳候选目标的搜索算法比较低效；需要大量带标记的视频序列用来训练模型
【解决方法】
提出了一个行为决策网络结构，在新的一帧图像中，产生一系列动作来找到目标的位置和尺度。
目的在于学习一个策略来根据当前位置这一状态去选择最优的行为决策去跟踪目标。这个策略网络是一个深度卷积神经网络，输入是从前一帧图像中抠出来的图像块，输出包括在下一帧中的决策概率分布。
学习算法包括两部分：监督学习和强化学习。监督学习部分：使用从训练视频集提取的样本来训练网络。这一过程没有序列信息。强化学习部分：将监督学习得到的网络作为初始值，使用跟踪序列采样状态、决策行为和奖励信号来训练策略网络。

技术路线示意图
【结果分析】
●     优势：
❖   不需要  等后处理操作
❖   计算高效：和方法和方法相比，在准确率和成功率接近的情况下，标准算法版本要快要比两种方法快倍；快速算法版本在降低性能的情况下，可以达到 。
●     不足：提出的决策行为对于目标突然大幅度移动和目标比例大幅度改变这两种情况无法很好地适应，跟踪失败。
    
原文链接：________
【摘要】
本文来自荷兰阿姆斯特丹大学的研究者。本文创新性地没有采用目标跟踪传统的给定 的设置方法，而是采用了自然语言描述来指定感兴趣的目标。提出的方法被证明非常有效，并且以往的目标跟踪方法都可以嵌入到这个流程当中。下图是文章方法的结果示意图。
 
基于自然语言描述目标的视觉跟踪
【问题】
对于跟踪在真实场景的应用中，比如机器人和无人驾驶，使用自然语言来定义“目标”更加自然合理
【解决方法】
和以往做视觉跟踪的基本假设和处理流程不同，没有采用基于 初始的 ，而是根据自然语言描述来跟踪目标。
给定视频中的一帧图像和一句自然语言描述来作为查询，目的是跟踪视频中由语言所指定的目标。
【结果分析】
在最常用的目标跟踪数据集和 的基础上，为每个视频中的每个目标扩展了一句语言描述。加上，在以上三个数据集上进行对比实验。
●     优势：
在目标跟踪中引入了一种创新的人机交互方式，并证明了其有效性。
●     不足：
缺乏和基于 的方法的对比实验


技术快报：快速扫描学术／技术前沿进展，做出必要的分析归纳，寻找它们在产品中落地的可能性。希望能帮助大家了解前沿，拓宽视野，提高决策效率。作者：熊彪
团队：腾讯移动品质中心

引言
单元测试的目的是什么呢？就是完整检测代码单元的功能逻辑，找出代码单元本身的所有功能逻辑错误，具体来说，就是检测对数据的各种分支是否考虑全面，处理是否正确。形象地说，单元测试的目的就是验证：无论别人怎么样，我总是对的。“别人”，是指相关代码或环境，“我”，是指正在编写或测试的代码单元。
单元测试为啥能提高代码质量呢由于每个单元有独立的逻辑，做单元测试时需要隔离外部依赖，确保这些依赖不影响验证逻辑。因为要把各种依赖分离，单元测试会促进工程进行组件拆分，整理工程依赖关系，更大程度减少代码耦合。这样写出来的代码，更好维护，更好扩展，从而提高代码质量。
那么我们应该如何编写单元测试的代码？当遇到被测代码可测性差时如何解决？本文试着从个人实践出发来阐述这两个问题。
姿势 原则组织单元测试
单元测试都有相同的流程。首先需要设置好合适的条件，然后执行代表要验证的行为的代码，最后验证结果是否和预期的一样。
测试应当尽可能地直接反映其测试意图。这就意味着阅读测试代码的人不需要细细品读代码中的每一行，就能很容易的理解测试的基本构成：单元测试的初始化、测试的行为、以及怎样验证测试结果。
、、提醒你直观地去组织单元测试以便能够快速的阅读代码。 
、初始化
单元测试中的初始化工作，是为了解决被测函数中必要的前置依赖的问题。如下例所示：

上述代码均对测试类进行初始化添加数据的工作，方才可以验证对应成员函数的功能是否符合预期。大多数单元测试工具都支持将逻辑上的相关的测试分组。在 ，可以使用所谓的测试用例名称来将相关的测试分组。如果测试用例中的所有测试需要一条或更多的相同初始化语句，那么可以将他们写在类的初始化函数中。在 中必须将此函数命名为它覆写了基类中的虚函数。如下所示：

将重复的初始化工作，放到同一个类中，让测试用例目的更突出。
、行为动作
单元测试主要对模块的五个基本特性进行行为的评价

模块接口测试从以下几点考虑行为手段：
调用本模块的输入参数是否正确；
全局数据结构是否有问题，保证系统数据的正确性；
模块的误差积累起来是否会放大从而达到不可接受的程度确保误差不影响系统功   能及性能。
模块内部数据测试从以下几点考虑行为手段：
变量是否有正确初始化；
数组越界；
非法指针。
错误异常处理从以下几点考虑行为手段：
 是否检查错误出现；
出现错误，是否进行错误处理。抛出错误、通知用户、进行记录；
 错误处理是否有效；
边界条件测试从以下几点考虑行为手段：
普通合法数据是否正确处理；
普通非法数据是否正确处理；
 边界内最接近边界的合法数据是否正确处理；
边界外最接近边界的非法数据是否正确处理。
独立执行路径测试从以下几点考虑行为手段：
死代码；
精度错误比较运算错误、赋值错误；
表达式的不正确符号。
单元测试从上述五个行为出发，来验证代码所对应的目的与预期。
、断言
断言可以将一个普通的测试转变成自动化的测试。如果没有断言，那么单测只是执行了一段代码而已。如果想要验证一段代码是否正确工作，则需要人工查看结果。人工验证测试结果是耗时的。断言可以帮助我们自动化的验证结果。
当测试框架运行单个测试时，它会从头到尾执行测试代码段中的语句。每遇到一个断言，都意味着要去验证一些期待的结果。如果断言的条件不满足，那么测试框架就会终止测试。测试框架会保存测试失败的信息，运行逻辑，然后接着运行下一个测试。
断言让单元测试拥有了自动化测试的能力。
姿势：干掉单元测试的天敌—可测性
单元测试效益特别高，方法看起来也很简单，但却尝试的多，成功实施的少，为什么呢？主要原因在于难于突破可测性问题。“可测”这个词，意思已经很明白了，如果不“可测”的话，那就是不能测，没法测，就是做不下去；或者困难太多，成本太重，热情被逐渐消磨，最后做不下去。所以可测性问题是单元测试的关键，是我们首先要解决的。

为什么代码会不可测呢？一般来说，这些原因导致了代码的可测性差：项目很复杂，开发流程不规范，耦合度很高。耦合是指代码之间的互相依赖，例如一个函数调用另一个函数，就是耦合。
流行的说法是改进开发流程，提高代码可测性，但从实践来看，这是不现实的。可测性差在项目中普遍存在，有其客观原因，很难改变：
首先，项目本身就大多是很复杂的，这由需求决定，改不了。
其次，程序并不是虚无的，程序是客观事物的反映，客观事物本身是互相关联，互相纠缠的，必然形成代码间的耦合。
第三，流程改进是一个长期的、渐进、困难的过程，不可能短期内实现飞跃，更不是引进几个工具或者规范就可以做到的。
如何解决可测性问题？可以从测试技术的角度来考虑。要解决问题，首先要对问题有充分的了解。一个函数要“可测”，要做到两方面：第一是能够独立运行，第二是要能够覆盖输入分类。为什么要覆盖输入分类呢？因为单元测试的目标是覆盖代码单元的功能逻辑，要做到覆盖功能逻辑，就要覆盖输入的所有分类。
、独立运行隔离、解依赖；
要进行单元测试，首先就是要将被测试的单元，与所有外部依赖进行隔离。隔离独立运行包括两点：一是与其他代码隔离，二是与依赖系统隔离。
与其他代码隔离的一般方式是，就用简单代码代替实际的代码，例如函数调用了函数，函数又调用了函数和函数，如果函数用来代替，那么，函数就可以完全切断与函数和函数的关系。与依赖系统隔离常见于跨平台测试，例如在上测试嵌入式项目。这要解决两个问题：编译差异和平台差异。编译差异主要是语法上的差别，例如，有些开发环境定义了非标准的关键字。平台差异主要表现在个别数据长度在不同平台上的不一致。
为了方便实现隔离，对软件设计和开发的一个潜在的激励是，软件模块的设计人员和开发人员，不得不时时思考，在当前语言支持的各种特性的条件下，如何使得所写的代码，能够被方便的被隔离。虽然这看起来很像是一种限制，但是和软件设计的原则面向对象设计和编程中几个重要编码原则 的首字母缩写，其实是不谋而合的，因此，也就未尝不是一个优点。
、覆盖输入分类
一个函数，输入会有哪些呢？输入包括两方面：外部输入，内部输入。外部输入容易理解，就是函数外部可以设定的输入，包括参数，全局变量，成员变量。关键是内部输入。什么是内部输入？

一个函数，对于调用底层函数获得的数据，是如何处理的呢？跟参数一样，也是分类处理。所以，测试时也要分类检测，这与参数没什么区别，这就是内部输入。内部输入就是函数内部取得的数据，除调用底层函数取得的内部输入外，常见的还有局变静态变量。
、可测性梳理
针对代码的耦合依赖、分类进行覆盖测试，遇到的各种代码可测性的坑，本质上是代码自身产生的原因。那么如何提高代码的可测性高质量代码，并可以覆盖所有输入分类呢？下面列出的点是经过过滤总结相对简单易接受的可提供代码可测性的规则：

总结
单元测试保障工程各个“零件”按“规格”需求执行，从而保证整个“机器”项目运行正确，最大限度减少。
按照的原则可以让我们单元测试的代码组织简单易懂，直接反映出测试意图。代码做不到单元测试，可测性差时，多思考如何改进，而不是放弃。
当单元测试成为我们自身的时，任何关于单元测试的负面因素都已经不是问题。为啥？因为这已经深入灵魂，成为一个标准的程序员每天需要的常态工作。
获取更多测试干货，请搜索微信公众号：腾讯移动品质中心！网络安全隐患无处不在。近来，勒索病毒“永恒之蓝”和“必加”在全球大规模爆发，再次敲响了警钟。有攻就有防，面对网络世界的安全隐患，面对黑客攻击及其布下的陷阱，“白帽子”黑客是我们的第一道屏障。
目前网络安全人才不足，既有供不应求的原因，也和人才培养模式相关。“白帽子”黑客们的工作究竟有哪些神秘之处？如何让他们更好地发挥专长，守护网络使用安全？小编带您走近这群“网络游侠”。

图：国家网络安全宣传周首届网络安全技能大赛
　
任务不轻：应对病毒攻击、发现安全隐患、保障重大活动
不久前，一个名为“暗云”的木马强势来袭，数百万台计算机被感染。“白帽子”黑客董志强随即和团队进行监测，对攻击进行了溯源分析，查清了“暗云”的攻击途径和方式。这一发现能帮助安全软件有针对性地查杀“暗云”，有效遏制它的传播力和破坏力。
“白帽子”黑客是指网络安全从业人员，他们是网络世界的卫士。与利用漏洞、制作木马病毒去牟利的不法分子不同，“白帽子”们是为了让网络系统更加安全。
方家弘也是一名“白帽子”黑客，他是腾讯科恩实验室的骨干成员，擅长寻找网络世界无处不在的漏洞。“攻击，是为了防御”，他通过尝试攻击，找到埋藏很深的漏洞，“逮”住它们，并上报给相关企业或组织，以便及时修补，保障安全。
“从手机、路由器，到机器人，再到汽车，任何智能设备本身或使用环节中都可能存在隐患，任何一个漏洞被黑客利用，都可能造成隐私泄露甚至财产损失。”方家弘说。
年初，方家弘和团队完成了一件很有成就感的工作。“我们发现内核中一个漏洞，利用它可以获得安卓手机的最高权限。比如，黑客可在你手机中安装任意软件，而你可能完全不知情。”方家弘和团队上报漏洞后，因为危险等级高，天之内便得到响应，的作者林纳斯·托瓦兹立即进行了修复。
杭州安恒安全研究院安全专家王欣也是挖掘漏洞的高手。在杭州峰会和历届世界互联网大会等重大活动网络安全保障工作中，他面对的是一个个没有硝烟的战场。
“重大活动的网络基础设施容易成为攻击点，从一些攻击手法分析，它们是有策略、有组织地攻击，不像是普通黑客练手。”王欣说。杭州峰会期间，安恒作为峰会的网络安保技术支撑单位，承担了包括官网、注册网、重要工业控制系统等多个网络安保重点单位的安全保障任务。从接到任务到系统安全上线，仅有短短天，王欣和团队需要为酒店在线预订系统搭建起一堵安全防护墙。那段时间，他每天工作至凌晨两三点，在临时办公室，团队小时轮流值守，确保了安全事件零发生。
行规不少：靠本事挣钱，不许触犯法律
中国互联网协会发布的《中国网民权益保护调查报告》显示，去年我国网民仅仅因垃圾信息、诈骗信息、个人信息泄露等遭受的经济损失就高达亿元。
国家互联网应急中心运营部主任严寒冰认为，在产业软硬件核心技术和代码等自主研发能力不足、安全防护手段滞后、地下黑客业务已形成产业链的背景下，我国网络安全正面临日益严峻的挑战。目前，“白帽子”黑客在保障网络安全中的作用无可替代。
比如，他们不断上报发现的漏洞，预警风险，给网络安全树立了第一道屏障。而随着互联网时代向物联网时代过渡，安全隐患更复杂，“白帽子”黑客也需不断“进化”。
董志强的兴趣从最初的传统反病毒转向云安全研究，方家弘则从端转向移动端漏洞的研究，王欣从安全转向物联网安全研究，并开始关注工业自动化控制安全领域风险。他们还要研究前沿技术，做好技术储备。
与一行行代码打交道，在“”和“”的世界中寻找风险……从事这项工作，除兴趣之外，“白帽子”黑客通常还要有点天分——他们大多不是科班出身，而是“江湖派”，属于怪才、偏才。
在网络安全圈，董志强更响亮的名号是“杀手”。他的专业是汉语言文学，研究古代汉语和影视文学。大学期间“邂逅”计算机后，他开始自学逆向工程。让董志强声名鹊起的，是他创建的“超级巡警”在年截杀“熊猫烧香”病毒时立下了赫赫战功，甚至因其迅速响应和高效处理能力，招致非议。而今，他已成为云安全领域的“大咖”，在云网领域开展更多关于安全的研究。
王欣学应用化学出身，他说从事安全行业，之前纯粹是因为爱好，当参加完多次网络安保任务后，感受到的是这项工作的荣誉感和使命感。
不录用有前科的人，是“白帽子”圈的行规。他们有明确的是非观：要靠自己的本事光明正大地赚钱，不许触犯法律。
成长不易：培养模式滞后，“黑产”利诱无处不在
“白帽子”黑客的作用，以往并不受重视，舍得投入的企业并不多。直到近几年安全事件频发，网络安全人才的生存和成长环境才逐渐改善。不过，人才缺口依旧很大。
国家互联网信息办公室年公布的数据显示，截至年底，我国重要行业信息系统和信息基础设施所需网络安全人才缺口达万人左右，预计到年，需要各类网络安全人才约万人。可见，光靠高校培养远远不能满足需求。
“网络安全的本质，是智慧的对抗；网络空间的竞争，归根到底是人才的竞争。”天融信总裁于海波说，建设网络强国，就要打造出一支强大的网络安全人才队伍。
网络安全人才供不应求，与人才培养模式滞后于网络发展速度相关。严寒冰说，传统高校的学科课程，强调基础理论，忽视培养学生在计算机上的应用能力建设，没有相关专业设置，大多数“白帽子”黑客都是靠兴趣“自学成才”。
“高校在专业设计上还存在与企业需求脱节的问题，学校闭门造车，学生缺乏实际操作经验，难以扛起维护网络安全的重任。”于海波说。
社会对网络安全的“后知后觉”，也影响了早期一批安全人才的成长。方家弘是上海交通大学信息安全专业的第一批毕业生。他回忆，年，安全专业比较边缘，毕业后多数同学进了金融行业，同学中还留在安全行业的人已经非常少了。
掌握安全技术的人才还面临黑产巨额收益的诱惑。天融信的信息安全教育专家李跃忠说，黑客通过非法倒卖个人信息、倒卖游戏账号、刷流量、制作网络病毒等，几个月甚至几天就能获得上百万元的收入。“‘网络黑产’一夜暴富的情形，也不利于引导安全人才健康成长。”
“过去，由于网络安全法律法规不完善，从事‘黑产’的违法成本极低，使得很多人铤而走险。”安恒信息副总裁冯旭杭说。直到现在，安全圈子的人，有时还会收到黑产的报价，比如万元黑掉竞争对手的网站，万元攻击一家游戏的私人服务器，万元告知一款常用服务器软件的漏洞……
待遇不高：增加“白帽子”黑客收入，强化归属感荣誉感，明确其合法地位
在培养“白帽子”黑客这一特殊群体方面，我国做出了一些有益探索。年，教育部增设“网络空间安全”一级学科，要求加快网络安全学科专业和院系建设，量身定制适应网络安全人才成长的系统性培养方案。
安全企业也参与到人才培育中。比如，杭州安恒信息与高校合作进行学科共建，开发具有实际教学意义的攻防实验室，帮助高校提升教学水平。方家弘所在的科恩实验室尝试将前沿的安全研究成果推向大学课堂，目前已受邀在上海交大和浙江大学开设讲座，并将在复旦大学等高校推广。
于海波建议，国家可拿出部分资源扶持专业的安全企业，整合社会教育力量，通过国家、教育机构、安全企业的努力，加强网络安全人才培养。
要切实提高“白帽子”黑客的收入。“虽然‘白帽子’收入已有较大改善，但和‘黑产’收益相比还有非常大的差距。要想办法提高报酬，激发他们担当网络‘侠客’、除暴安良的热情。”李跃忠说。
此外，还要强化“白帽子”黑客的归属感、荣誉感，明确他们合法的社会地位。
采访中，专家指出，政府和安全圈应更多组织一些安全会议、论坛、竞赛等活动，为网络安全人才搭起与政府、企业沟通互动的平台。
今年月日，我国互联网领域的首部基础性法律《中华人民共和国网络安全法》以下简称《网络安全法》正式实施。严寒冰表示，《网络安全法》从法律层面明确了网络安全从业人员应该承担的责任和义务。“包括哪些事情可以做、哪些事情不能做以及做到什么程度可受法律保护。它在为打击网络违法行为提供明确法律依据的同时，也为网络安全从业人员提供了合法的社会地位。”
法律专家表示，《网络安全法》为网络安全人员行为边界做出了规范。比如规定任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动。“白帽子”们一定要注意边界，坚守法律底线。
冯旭杭认为，让“白帽子”黑客们远离黑产，还有必要调整现有的评价体系。“比如，职称评定能加强安全从业者的责任心和荣誉感，但很多安全人才是实战型的，学历并不高，按传统方式评定，连资格都没有。”他建议将网络安全人才的评定资格下放到企业，由企业的信誉做背书，参考同行评议制度，让业内同行来评价。“这个圈子很小，你有几斤几两，大家都清楚。”

转自人民日报前言
今年月，由腾讯云主办，联合国内直播行业巨头参与的“云视界”大会在北京举行。大会上视频直播行业一众巨擘齐聚现场，聚焦视频直播行业的新趋势，共话直播生态与视界未来。来自腾讯技术工程事业群架构平台部高级总监，分享了直播云在云端的技术架构。本文由其及演讲稿编辑整理。
演讲主题：点亮视界——直播云端技术架构

我今天为大家分享一下直播云在云端的技术架构，年我们总共直播场比赛，场演唱会，场赛事直播；另外还有数十万的主播在我们直播平台上每天发起直播，从年开始，我们进入了视界的一个新时代。

高并发是整个直播平台一个最大的挑战， 我们直播平台目前最高峰值可以达到两千万同时在线。挑战在于不仅要支持这么高的在线人数，同时还要保障直播用户的体验，比如要高清晰度、低卡顿、低延时，还要保证开屏速度非常快。我们整个系统在资源覆盖、调度、突发保障、快速流量迁移等等做了一系列优化措施。

以为例，简单介绍一下后台支持的情况。去年在腾讯视频进行独播的时候，最高在线数字非常高，对这么一场大型直播，最关键的就是信号源一定要保证非常安全可靠，从美国的赛场传递到中国，这么长的距离，怎么保障直播信号的稳定，怎么保障在国内的观众能够非常流畅地看到每一场赛事？
通过两条光纤，把信号传播到国内，同时还有备份卫星直播； 对两条光纤传过来的数据进行一个双发选收的操作，选择数据质量最好的进行实时播放。另外， 在国内建设了三大处理中心，保证每一条从美国过来的信号，任何一个环节出现问题都能进行秒级的切换，这样就能保证在网络出现抖动或者服务器出现异常的情况下，能够让用户看到直播的信号是无感知，非常流畅的。

要支持这么大的带宽，最关键的问题就是资源的问题， 能够使用整个平台多个资源池，能够保证任何一场直播有以上的带宽突发能力；  同时由于每一场直播，尤其像赛事这样热门的直播，最高突发的时间每秒可以达到上百带宽的瞬间增加，需要有秒级调度的能力。
同时，为了满足非常热门的赛事直播，尤其是总决赛、阅兵之类的非常大型的直播，直播平台要能够提供柔性的能力， 当发现资源已经处于一种不足的情况下，自动采用柔性调度服务，对高码率的直播进行动态降码率的调整，或者对前端用户进行排队处理。
这是对内部业务的处理情况，我们的目的是希望尽快将内部支持能力开放给合作伙伴

第一点是对直播全链路进行加速，年的直播除了传统的电视直播模式，还有一种新的模式，就是主播；每天都有数十万主播在整个平台上进行直播，这些主播分布在全国各地，怎么保证这些主播的直播信号非常流畅的传递到后台
对主播采用就近推流的模式，在离主播最近的地方把直播流接入到直播平台，观众观看的时候也能够就近观看，我们在主播接入点和观众接入点之间，建设了一条高速互联专线。
第二点，现在的直播形态是越来越多样化，比如在平台运行的直播产品，它可能是同城直播，或者是附近的人直播，这种直播场景的特点，就给我们带来一个非常好的优化方向，如果是这种同城直播，或者附近人直播的时候，我们直播平台会支持本地分流。
第三点，现在直播的终端非常多样化，有盒子、手机等等，每一路直播流在不同终端播放需要不同的直播格式，我们现在采用的方式是把这路流推送到离用户最近的地方，在边缘的节点上对这个直播流进行实时的转封装，这样做有一个好处，当用户播放的时候，可以有效地节省整个直播链路的穿越带宽，在保证用户体验的情况下，能够合理地降低直播平台的成本。

去年开始到今年，直播不仅在国内蓬勃地发展，很多直播业务也在往国外扩展，我们也加速海外直播的建设，目前我们有个节点，覆盖个国家，而且这种直播大部分情况会按国家去推，我们也支持直播的最小模型，如果部署上最小模型，本地直播就可以快速上线，跨国的主播进行播放的时候，可以支持智能选路，包括专线互联的模式。

提到直播的成本问题，从去年开始，我们就尝试在内部使用更高压缩率的算法，包括点播也会应用到，我们也希望将这种能力开放出去。

同时伴随着、更高码率直播的诉求，内部也在进一步地研发，比如将现在这套代码进行重构，算法方面进行优化，同时采用汇编，更高性能的访问模式，在同等质量下，压缩效率相对现在的开源能够进一步提升，这是我们的一个目标。

云端优化的技术不可能面面俱到，整体上看，从推流加速、专线互联、边缘计算到本地分流，到快速的流量调度，我们的平台会提供一整套的能力，保证整个直播的流畅和高体验。
注：本篇内容来自”腾讯技术工程官方号“，公众号：作者 | 赵建春编辑 | 毕宏飞

作者简介
赵建春
腾讯社交网络运营部助理总经理、技术运营通道会长、专家工程师。年加入腾讯，先后从事过研发、运维、大数据方面的建设和管理工作。

前言
在过去三年多时间里，我因为工作的原因负责了一些和机器学习、推荐、自然语言处理相关的工作，系统性的学习了这块的知识。之前可能做了多年开发和运维的关系，我非常希望能把这两个东西结合在一起，所以有一些自己的感受和想法，希望把这块跟大家分享一下。
其次，因为  在这两年发展非常迅猛火爆，尤其咱们这个社区。但是也看到里面有一些紧张或者是忧虑的成分，这一块也可以讲讲，在智能化、自动化的大背景下，我们的同事应该怎么样来发展，也有自己的一点小观点跟大家分享。
运维团队的践行之路“致简”
织云  是腾讯的企业级运维管理平台，为了更好的运维管理我们设计了这个系统，这个系统里面非常重要的一个设计理念点：“简”，化繁为简。做产品要简单，解决这么复杂的用户环境、场景的情况下，其实“简”是非常重要的。
通向致简研发结构分析

由于各个公司的组织架构不同，研发架构也不同。比如有些公司是中心型的，整个公司里非常强的中央研发机构，可以把整个公司架构都解决。有些公司是不同的小的技术团队，做一些不同的产品，可能是分散型的结构。也有一些公司整个就是散的，没有特别明显的中心化。
但是对于大多数公司来讲，研发一般都是先行于运维的，系统上线之后才会考虑运维的事情，上线之后发现好多运维的工作跟不上。
不同公司的结构不同，运维团队的影响力也不一样，你有很多好的想法但是苦于你的团队推动力不行或者团队技术能力储备不够，所以无法推动。
通向致简管理方式分析

可能的管理方式：

第一种，全局设计整体考虑这个公司有很强的研发结构，可以从全局设计一个非常强大的研发体系，它在这个研发体系里就可以把整个运维环境里所要面对的扩展性、一致性、调度等等这样一些东西全部考虑进去。

第二种，灵活适配效率优先公司已经发现了非常分散，针对每种情况做适配的工具，短期效率可能非常高；

第三种，标准规范持续改进通过强制的规范和约束，以及通过模块化的规范和标准，让业务变得逐渐统一，短期可能效率低，但长远来看可能会带来长期的收益。

工具可以带来效率提升，而标准和规范有时候很难感受到或者能够衡量带来的效率。兼顾全局目标与短期需求，短期可以开发满足需求的高效工具，长远可以进行系统的模块化和标准化。
通向致简环境分析

上面的图是以我们团队的案例给大家做一个介绍。
我们团队在年的时候发布，年秀上线，年音乐上线，空间是在年月正式发布，在年我们才做了分离。
上面几个产品都是海量的服务，每一个都是不同的团队研发的，在不同的年代全部上线了，而且每个产品都有大量的用户群体、大量的服务器，研发结构可能也会有差异，这时候运维再接过去改进它、管理它，其实有很大的挑战。
年农场上线，这是一个全民的游戏，短期内我们几个月时间布了四五千台服务器上去。
多中心型研发组织，规模大、增长快、研发架构不统一、变更频繁、持续、没有维护时间，较强的系统耦合，这些都是的东西，对平台的服务都有一些依赖。
最后是长生命周期，上线之后，除了农场这样游戏类的东西可能慢慢淡化了，但是其他业务是多年运营的，需要长期维护它。
通向致简需求分析

这两年在个性化推荐这一块有个观点，从千人一面到千人千面，这块我们的做法是从千人千面到千人一面，要让运维同事全部掌握，难度是非常高的。
我们做的是把这个框架全部独立出来，把  通信协议里的网络层和性能相关的东西全部脱离出来，做成一个框架，包括稳定性、空中海量连接等全部放在框架里。
使用的方式编写，这样的方式让我们编写的代码基本上都是一样的。
程序编写出来之后，你要上线可能会涉及到配置文件、启动命令、启动参数、保存路径，我们全部用包的思想把它装在包里面，对安装路径写到这个的格式，写到的大小，还有启动、关闭、安装、删除等等全部进行了约束，做到了程序交付千人一面，对我的环境来讲逐渐进行规范和约束。
通向致简确定目标

从架构及分工上简化，历史原因，不可能说之前就有非常好的名字服务，所以我们做了一个系统，希望我们的程序出故障以后，我们不像硬件厂商提供给我们的服务一样，两周之后再来给你处理。
当时的目的就是希望做到这个程度，基本原理是我们有一个中心的服务器，服务器，上面包含所有的名字服务的注册，在每个机器上都会有一个  ，就是本地的共享内存。从服务器上拉下来一个名字，然后地址，拉下来以后就可以了，如果网络中断，只影响下发，不影响历史数据。
我们每一次请求都会把成功、失败、延迟上传到服务器，这样可以做到判断哪个机器的成功率、失败率多少，延迟多少，可以做一个负载均衡的设置，从而达到负载均衡和名字服务的作用，做完这个以后就可以把架构从上到下进行统一。
接入层刚才没仔细讲，我们叫  的接入组件，把进入层全部进行标准容错。我们中间加了一层  层，记录之后，由和  进行容错，  层对下面的数据层进行容错。
刚才说的千人一面的组件全部在组件运维组维护，接入运维组现在个人，组件运维组是个人，存储运维组是个人，我们总共是万台级别的服务器，以上的是这三个组维护的，标准化之后大家的效率提升非常明显。
我们做了一个基于的虚拟镜像。
通向致简建立标准仓库

我们把一个模块要提供完整服务的时候，通常是多组进程，加一些基础服务，甚至装一些脚本，会依赖一些命令一些权限。
这个用户有没有开通会员、开通游戏，这个是需要权限的，我们把它也当做一种资源，我们把它登记到这个模块以来运行的二级  里。
镜像包、配置、文件、权限、脚本、测试工具，全部记录在中间，类似于  镜像一样，通过这样的方式，我们形成了一个运维和开发的交付界面，拿到以后，运维开发我们可以共同维护这个交付页面，从而达到非常高效的运维过程。
通向致简梳理流程

我画了一个简单的图，我们把一个进程需要的相关资源打到一个包了，把包放在资源仓库里，资源仓库里的东西如果有模块要运转，需要哪些资源在我们的记录下来，包括权限。
在我们的监控系统中，发现某个模块需要扩容，或者我们日常决策需要扩容的时候，通过流程进行调度下发，调度运行把它从资源仓库里放到我们业务模块上去，然后进行注册，注册之后我们就可以通过灰度的方式进行上线，上线之后还会有一些自动化测试。
通向致简注重规律
很多人会讲，规范推动起来非常困难，确实是，但是没有大家想象的那么困难。
运维环境中的法则，规范这东西对整个团队是有帮助的，但是短期是有困难的，你最重要的是保持耐心去推，推的时候有一个法则，你推过以后，剩下的就慢慢靠过来了。
我们也花了很多天把我们可信的东西做了推广，一般是一年时间推，推完之后一年时间到，慢慢到、。
约束趋于规范，灵活带来效率。你可能做了很多工具改进它，一个规范，其实这些问题都不存在了。
腾讯运维实力案例


红米空间首发织云效果还是不错的，比如说我们在红米空间首发的时候，虽然小米这两年势头没有那么猛了，但是早期他们上线的时候还是非常猛的。在红米空间首发，单秒有万抢购，秒卖了万台，超过亿点赞。

天津大爆炸亿调度大家都知道两地三中心做多地分布，但是真正发生过地震或者掉电、火灾这样的事情在国内没怎么听说过，但是我们遇到一次，天津大爆炸，爆炸过程中这么厚的钢板被打成了字型，很多墙都倒了，都停电了，只有机房有保障。平时我们调一个，天津有好几个，全部要调会深圳和上海，我们做了大量的扩容工作。

春节红包春节红包这块我们也做了好多次的支持，春节红包对用户量的拉动，大家会带动消息量，整个链条，这么多模块同时需要扩展，这也显示了我们千人一面或者按层来管理的优势。


最近几年流行的一些工具和方案

运维组件级服务这两年修改很多开源的系统，譬如  、  、  ，这些是运维组件级的服务。

类似于  镜像管理这方面不是很完善，同时安全性方面可能也会有一些小问题，比如用通道下发同时建很多互信关系。


轻量级整体解决方案整体解决方案有  、  ，这个是轻量级的运维解决方案。

重量级整体解决方案重量级整体解决方案中比较好的，如：  和 。


即使有这样的开源工具，标准规范一样不能少。比如说把  和  做比，  更偏向于文件级，  更偏向大的集装箱级，实际过程中也发现很多公司把它作为类似于虚拟机一样的，把整个的服务全放在里面，包可能更小一点。
如果只是把运维和开发的界面寄托于  来解决，就好比把开发的所有东西都装进  里，线是乱七八糟的，但出问题的时候，受力的还是运维。因为这个线是无数的开发在里面布的，找一个人过来解决不了这个问题，但是运维把它布得很清晰的时候，出了问题一样可以解决的。
包及规范

织云系统早年一直是服务于我们内部，也受制于我们的人力，所以一直没有开发出一个对外的版本。
在去年底我们也下决心把它做成一个可以独立部署的第三方部署版本，我们最近也把它交付给了几个互联网金融公司和在云上支持房地产公司的客户。
月份我们刚刚出了第二个版本，做了很多改进，特点是基于规范化、标准化理念。
第二是长期让业务趋于一致，其实里面还有很多细致的东西，然后较少的定制开发。大家互相知道你的模块之间怎么维护怎么管理，大家都是同一个理念，会更加标准更加高效一点。
运维团队的践行之路“致智”
接下来我们分享一下浪潮下的运维：智
我负责这块工作也做了很多实践，我们在推荐这个领域也做到每天亿次的推荐量，做的是通用推荐场景，多个业务，多个场景，用了大量的机器学习的算法和支持。
另外做了一些文本处理的东西，社群和自然语言处理的东西，所以这一块天然有我们的责任感，把运维的工作解决一下，做了一些思考。
机器学习我们先看一下机器学习，十大机器学习算法。

做分类用的；主要是聚类；做分类用的；是频繁项类；最大似然估计；做搜索用的；分类用的；分类用的；贝叶斯：分类用的；分类和回归；

里面有七个是和分类相关的。
推荐类如逻辑回归、决策树、矩阵分解、、、强化学习等。大多数情况下也都是一种分类问题、二分类问题，最多是多分类，多分类问题也可以转化为二分类问题。
深度学习，、、，里面有一个叫卷积和池化，卷积就是用一个窗口去提取一些图片里小的特征，比如线条或者编译，池化就是把这个东西再进行一个最大值或者是平均值。
简单来讲，加入一个图片以，这么大的像素点，这个像素点就是特征，这个像素点其实没什么意义，都是一个的，通过这样的方式把它大量汇聚。比如车的轮子、方向盘或者灯，说白了就是提取一些特征，通过人为的标注，判断是不是车、是不是人、是不是你。
分类算法的应用
分类算法本质上是通过大量数据的“线索”找到分类依据，“线索”就是特征，分类算法大多数对特征有较强的依赖。比如指证分解和隐含特征，他不需要把特征明确提取出来，但是大多数对它都比较有强的依赖。
其实我们运维环境中有大量的数据，只要这些数据你能记录下来，我们就能通过我们的技术和累计的经验，知道哪些特征对这个问题进行一个分类有帮助。
其实我们在过程中就应该把这些数据想办法记录下来，把这个特征尽量保证得更加清晰，不要放在一个连续的字符串里，应该隔断。
可能有些人有误解，我们把数据交给深度学习网络，它就可以把这个东西分析出来，其实不是这样，如果把一个图片的连续的数据分享给神经网络，他也分不出来。
运维和可能结合的点
和运维的结合，某种程度上讲有点像无人驾驶，可以服务大家，但是短期内还是比较困难的。我们在很多决策，虽然里面叫做机器学习，但是在这个里面有个问题，他有很多场外信息你可能并没有纳入到这个角色里，这个场外地区是很难补齐的，有很长的路要走。
做得更加智能和化，是短期内可以挖掘很多实践的。对数据的特征建设和归档中走向智能，解放自己的双手。
运维和可能的结合点：智能告警、网络异常分析、程序异常分析、关联异常分析、变更体验报告、硬件故障预测、投诉文本聚类、咨询客服机器人。
有很多的数据场景，我们通过一个归类统计数，再和异常进行标注，异常行为有什么样的特征？正常情况下有什么样的特征？这种数据就可以采集下来进行一个分类。
对于网络异常，各种不同的网络异常，表现状态不一样，可以把这个东西进行一个分类。
关联异常分析，发现异常以后，哪个最终是导致异常最根本的原因，底层的故障会导致上面多处告警，如果能够最终定位出来，当然我们可能有一个故障单，这个故障单定位出来以后，你就知道哪里是。然后你把这个长期的关系，以后的工作就会变成一种类似于标注，标注出来这是一个什么异常，是一个分类。
因为分类算法都要进行样本集，日常的故障单处理就可以变成样本集。变更体验报类似的及遇见故障预测，很多谈对已经在研究，通过系统，判断这个硬盘会不会出现一些故障。
文本聚类投诉，咨询服务机器人，这是我们最近刚刚做出来的，运维团队来讲有非常大的咨询服务，咨询量很大，但是内容很固定。
针对一个系统的，其实可以提升我们效率的，或者说我们运维的构成进入到一个新的不同的领域里去。
运维团队的践行之路“致深”

还有一个选择，你成为每一个细分的领域最顶尖的人。我也在我的团队里经常说你能不能做到在我们团队里任何一个领域出现故障的时候，所有的人都第一时间想到你，找你来解决这个问题。
第二个感受，大学里的课程，我们运维同事很多都是对计算机行业对行业有很大的热诚，但是很多人都是相关专业的，他很多基础知识是有缺失的。想做  ，我觉得有些基础知识是确实需要的，学习起来也并没有那么困难。
在大学里面和你相关的课并不多，相关的课就那么几门，一门课一年就二十个学时。你要对它进行深度的学习，给自己一个定位标签，在这个团队里你就扎准一个方向，深度学习、深度原因，做到让团队所有人遇到这个地方的问题肯定就找你。
同时你可以把一个东西做好以后做第二个，第二个做好以后做第三个，把整个课程体系全部摸一遍，基础非常牢靠，这时候你再去做   。
第一你在技术上有影响力，第二你对所有的细节非常清楚，第三你有这个资历和影响力，别人也信任你，你有这个眼界可以达到这个程度。作者 | 陈泽钦编辑 | 京露

陈泽钦，腾讯移动客户端工程师，目前就职于腾讯移动互联网事业群，负责腾讯浏览服务的内核业务。

 网页渲染的基础
在前面整理的官方的渲染性能优化文章中，讲述到了网页生成过程中，主要包含如下几个步骤：

 。一般来说，我们会使用来实现一些视觉变化的效果。比如用的函数做一个动画、对一个数据集进行排序、或者往页面里添加一些元素等。当然，除了，还有其他一些常用方法也可以实现视觉变化效果，比如：  和  。
 计算样式。这个过程是根据选择器，比如或  _，对每个元素匹配对应的样式。这一步结束之后，就确定了每个元素上该应用什么样式规则。
 布局。上一步确定了每个元素的样式规则，这一步就是具体计算每个元素最终在屏幕上显示的大小和位置。页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。比如，元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响。因此对于浏览器来说，布局过程是经常发生的。
 绘制。绘制，本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。
 渲染层合并。由上一步可知，对页面中元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。
参考在的入门篇中所整理的框图，更清晰地展示了页面生成的流程。

网页中的重绘过程是影响整体性能下降的关键点之一，因而网站开发者应该更多地去避免在站点中进行不必要以及不适时的重绘步骤，借助中的面板可以很好地剖析这一些存在的问题。

 实例讲解
在此，本文将通过一个简单的网页来讲述的常用技巧
页面，具体如下：


  
     = ===
     
     =
         {   }
         {   }
         {   }
          {   }
         {     }
    

    
       _ {
          = 
         =          
         =      
      }
    
  

  
       
     = =_
    
        = 
       =      
       =      
                  
        = 
       =       
       = 
      
    
  

这是一个很简单的网页，展示了一行文字和图片，而在中有一段对个别元素进行样式和内容的调整；此外还有一个点击事件，即点击图片后，会再次执行一段修改元素内容和样式的脚本。
 操作流程：

 开始录制

刷新页面

点击图片，执行事件

 结束录制


操作完毕后，在中记录了这一过程中，与页面相关的各项信息。

可以看到下图中上方的两个红色框位置，该区域是面板的整体预览区，分了三部分、、来展示，具体可查看使用详情。首个红色框位置，记录了首次加载页面时，所经历的      流程。而右边的红色框区域中，可见中首先显示了黄色代表的峰形区域，随后显示了紫色代表的峰形区域，表示了页面在响应点击事件后所进行的流程。
 事件详解：
通过滚轮在框图中，可以对页面中的事件进行缩放，可已清晰地观察到在首次加载过程中，所经历的         等流程。

并且，在点击了各个事件之后，下方的中会罗列出更加具体的信息。比如，点击 事件后，可以查看总共的耗时，并且可以链接到具体的源代码：

而在网页加载完毕后，对图片进行了点击操作，触发了 标签的事件，开发者能够在框图中查看到点击事件中各个流程，其展现了所有的调用栈：
系统 ==  绑定的事件中第行 ==  _ 中第行：

 综合分析

由此可见，当在页面已经得到生成了之后，利用去更改个别元素的内容结构变化，或者是调整元素属性属性变化，都会引起页面重新进行  流程。如果这些是不必要的操作，则必定会导致网页性能降低。

因此，对于开发者来说，应该要知道如何去定位网页中发生重绘的区域。
 定位网页中发生重绘的区域
开启方式：在控制栏的右上角属性按钮中，选择  —  ，然后在弹出的面板中选择  。

如下图中的操作，在勾选了 后，还是在页面中，点击图片触发事件，进而会标签的内容以及颜色，而在页面预览区域中，可以观察到该行文本在刷新内容过程中，有绿色的方框进行高亮包围，说明了这一部分区域发生了重新绘制。
另外一个重要的现象是，虽然点击后的事件仅修改了的内容，但是重绘却发生在整一个标签中，说明了个别元素的重新绘制，一般会影响到父元素或者是周围的元素，造成区域性重绘，因此在页面中避免不必要的重绘显得至关重要。

小技巧： 当发现页面中，如果存在一些不必要的重绘现象，而又不能够定位到具体的原因，可以对该区域中的各个元素，依次进行隐藏在面板中设置，观察效果来定位。
 显示 的边界
在  —  中，还可以开启  ，观察页面中的各个区域绘制情况。通过这一项功能，开发者能够发现页面中发生动画或者是 等发生了形状或位置变化的元素，进而优化其渲染时间。
页面比较简单所以效果不明显，利用官方图片来展示 的效果：

 在 中查看绘制细节
当在框图中点击了 一个事件，则会在详情面板中出现一个专有标签： 

通过 面板，开发者可以知道该次事件的绘制时间、绘制位置和大小等信息，并且能够具体到某一个元素的绘制耗时：当拖动标尺，直至内容框中仅有目标元素的绘制时，即可观察到其耗时，以及图片区域的大小、位置等等信息。


相关推荐
让页面滑动流畅得飞起的新特性：  作者 | 郑宇编辑 | 京露

郑宇，高级工程师， 曾在东方梦工厂担任软件工程师。目前就职于腾讯上海 ，目前主要专注于强化学习和图像方面。

今年大会上，演示了基于当下热门的神经网络技术生成式对抗网络来做图片编辑的技术，用户可以在图片库中选择一张人脸的照片，对其进行局部的更改，神经网络会自动在更改区域以外的部分进行适配性修改。
比如，在额头中间部分涂黑，那么神经网络会自动在整个额头部分添加头发，再比如，在紧闭的嘴中间涂白，那么会自动变成露牙齿嘴张开的模样。理论上可以极大的提升美术编辑的速度，因为修改图片不再是在像素层面，而是根据用户的修改进行整体的调整，只需简单几笔就可以完成。
但是该技术还存在一些不成熟的地方，所以目前实际应用价值有限参见本文后面的缺陷部分。
效果展示

左侧图为原始图片，中间图片为在嘴唇处涂白后的效果，右侧图片为在额头中间区域涂黑的效果。
效果展示

左上图为原始图片，右上图为点击按钮选取涂抹的颜色白色，下左图为涂白后去除胡须的效果。
原理
作者结合两种生成式神经网络模型，和，构建了一种新的网络  ，基本原理是训练模型比较稳定，但是会丢失低频信号，模型训练中不稳定，但是细节保持较好，所以作者用中的辨别网络来提取特征，然后输入模型的部分，最后将编码 输入模型中的生成网络。如下图所示。
安装和运行
   
   
       
  
然后下载_ =_ ，替换掉 中的同名文件。
将  中第行代码从
 

改为
   

执行操作：
_==  
常用操作：在打开的窗口，在左下角输入数字来选取原始的图片，点击按钮可以恢复到原始图片，点击按钮选择涂抹的颜色，滑动最下方的，可以涂抹影响的范围。主要修改是在图片上完成，尽量不要在图片下方的 上修改，否则结果是无法预期的。
缺陷

没法对细节进行修改。使用上和传统的图片编辑不同，可能会有不适应的地方，比如要修掉图片上的一个噪点，那么涂白会影响到图片的其他部分，造成较大的修改。

修改存在路径或历史依赖。因为的特点，比如在修改时如果不先把脸部模型变宽就直接在眼睛周围涂黑，实际上会生成头发，而不是画出墨镜。

目前处理的脸部照片还是分辨率较低的模型，比如技术演示时使用的是分辨率的照片，这是因为训练时使用的数据库中的照片分辨率就不高提高分辨率会造成训练时间和难度增大。

理论上用户可以对任意输入的图片进行修改，但是对于特定的照片，可能效果不明显，因为相对用户添加的个性化照片，之前的数据库太庞大了，不会针对用户输入的图片进行特定的优化处理。


参考

      





相关推荐
谷歌开源图片压缩算法实测体验报告需求： 之前使用  做开发，近年来有点火，且不需要、、做容器，想在不影响之前开发环境下，也能体验玩法。国内搜索了很多也没有发现有关的具体部署教程，于是踩了很多坑，终于配出了     。
一、购买服务器
选择服务器配置
因为  异步、非阻塞的特性，所以多核  对  算比较浪费吧，所以主要提高内存的大小，所以选了腾讯云核、 内存的服务器。

选择镜像
这个比较重要，镜像要是选得好，配置起来各种高效率。这里我推荐的系统是   主要是因为 使用的是 ，各种坑，想升级成 坑还多。
镜像选择 运行环境 位  | 多版本，腾讯云里的服务提供商上海微柳这家提供的 太强大了，工具和文档都很详细，并且和其它的镜像不一样的是，连接时，会有暗红高亮，相当好用。然后直接买、买、买就行了较其它主机提供商，腾讯云的学生机相当给力。

然后就配好了，访问服务器端口，下载镜像的文档超级方便的各种脚本：

二、基本配置
注意：有些服务器需要在腾讯云的控制台上设置安全组，不然端口将无法开放，就会导致才买的服务器通过连不上。

首先开启，方便传文件：
开启服务器
  开启，这样就可以配置了。  首先进入目录  运行_  添加一个用户。

更改密码
目录下，运行 ___，输入数据库密码。

三、配置
更新
执行：                     ，主要的目的是为了当安装比较娇气的模块时不报错。

安装
这里采用来安装，是因为对进行版本管理，这就方便多了，比如我博客的版本只能是 || 。而一般用的，是了。所以非常有必要。  

首先   ；

 ；

将中的命令加到或 或 中，这样的话，下次上去时，才不会发现未安装；

然后就是的使用了，  版本，参考的。



安装完  后，最好更换一下 源，这样  比较快些。
    

 配置后可通过下面方式来验证是否成功
   
 或
  
安装模块，永久运行
    

四、配置
虚拟主机的配置
新建后，会在产生个重要文件以我的域名为例。
虚拟主机的配置文件到时候运行时，需要更改成反向代理             
项目目录项目，可以通过传上去                 

防火墙设置
这里我生成了一个项目，端口为，但是并不能访问到端口。

需要防火墙忽略端口，所以执行以下命令：
                   允许  端口
     保存  规则
就可以端口访问了：

将服务和域名进行绑定
直接 ，修改配置：中间的都删了，直接加这个。
     
    {
        _ 
        __               _
        __     ____
        __                      _
        __       
        __    
        __ 
        _        
    }
然后重启   。
然后用域名访问成功！！！

需要 直接用 ，可以进行的管理。
五、安装可选
首先将源添加到中。 编辑添加以下内容：
如果是位 系统

= 
=_
=
=

如果是位系统

= 
=
=
=
先更新  ，然后安装    
运行默认端口
 {||} 

注意：从“赎金事件”中，建议一定要使用和更改用户名和密码。
六、常见问题
如果重装系统，上去时，出现以下错误，用  地址 来解决


有时候开启服务时，提示某个端口被占用。此时要用命令查看端口   端口号，或查看服务  |  服务名，掉  进程号。如果大型访问量时，优雅软重启的使用  进程号。



相关推荐三种  运行环境的性能对比腾讯云从零部署站点写在前面的话
上世纪  年代， 发明了关系型数据库。但是随着现在移动互联网的发展，接入设备越来越多，数据量越来越大，业务越来越复杂，传统的数据库显然已经不能满足海量数据存储的需求。虽然目前市场上也不乏分布式数据库模型，但没有品位的文艺青年不是好工程师，我们觉得，不，这些方案都不是我们想要的，它们不够美，鲜少能够把分布式事务与弹性扩展做到完美。
受   的启发，一款从一开始就选择了开源道路的  诞生了。 它是一款代表未来的新型分布式  数据库，它可以随着数据增长而无缝水平扩展，只需要通过增加更多的机器来满足业务增长需求，应用层可以不用关心存储的容量和吞吐，用东旭的话说就是「他自己会生长」。
在开源的世界里， 和  吸引了更多的具有极客气质的开发者，目前已经拥有超过  个  和  个 ，这已然是一个世界顶级开源项目的水准。而成就了这一切的，则是来自社区的力量。
最近我们收到了很多封这样的邮件和留言，大家说：

谢谢你们，使得旁人也能接触大型开源项目。本身自己是，对数据库方面较干兴趣，也希望自己能逐步深入数据库领域，深入，为  社区贡献更多、更有价值的力量。

我是一个在校学生，刚刚收到邮件说我成为了  的 ，这让我觉得当初没听父母的话坚持了自己喜欢的计算机技术，是个正确的选择，但我还需要更多的历练，直到能完整地展现、表达我的思维。


这让我感触颇多，因为，应该是我们感谢你们才是啊，没有社区，一个开源项目就成不了一股清泉甚至一汪海洋。公司的小姑娘说，她觉得还有很多的人想要参与进来的，可工程师团队欠缺平易近人的表达，这个得改。
于是便有了这篇文章以及未来的多篇文章和活动，我们欢迎所有的具有气质的开发者能和  一起成长，一起见证数据库领域的革新，改变世界这事儿有时候也不那么难。
我要重点感谢今天这篇文章的作者，来自社区的朱武  、小卢  和杨文  ，当在    里提到想要做这件事的时候，是他们踊跃地加入了    的队伍，高效又专业地完成了下文的编辑，谢谢你们。
一个典型的开源项目是由什么组成的
 社区

一个项目经常会有一个围绕着它的社区，这个社区由各个承担不同角色的用户组成。

项目的拥有者：在他们账号中创建项目并拥有它的用户或者组织。

维护者和合作者：主要做项目相关的工作和推动项目发展，通常情况下拥有者和维护者是同一个人，他们拥有仓库的写入权限。

贡献者：发起拉取请求   并且被合并到项目里面的人。

社区成员：对项目非常关心，并且在关于项目的特性以及   的讨论中非常活跃的人。


 文档
项目中经常出现的文件有：

：几乎所有的  项目都包含一个  文件， 文件提供了一些项目的详细信息，包括如何使用，如何构建。有时候也会告诉你如何成为贡献者。

  


：项目以及项目的维护者各式各样，所以参与贡献的最佳方式也不尽相同。如果你想成为贡献者的话，那么你要先阅读那些有  标签的文档。 文档会详细介绍了项目的维护者希望得到哪些补丁或者是新增的特性。  文件里也可以包含需要写哪些测试，代码风格，或者是哪些地方需要增加补丁之类的内容。

  文档 


： 文件就是这个开源项目的许可证。一个开源项目会告知用户他们可以做什么，不可做什么比如：使用，修改，重新分发，以及贡献者允许其他人做哪些事。开源许可证有多种，你可以在认识各种开源协议及其关系了解更多关于开源许可证的信息。

 遵循  
 遵循   


：许多大型项目不会只通过自述文件去引导用户如何使用。在这些项目中你经常可以找到通往其他文件的超链接，或者是在仓库中找到一个叫做  的文件夹

   





齐步走成为 
  
如果你在使用项目中发现了一个 ，而且你不知道怎么解决这个 。或者使用文档时遇到了麻烦。或者有关于这个项目的问题。你可以创建一个 。不管你有什么 ，你提出  后，会对那些和你有同样  的人提供帮助。更多关于  如何工作的信息，请点击  。
  

检查你的问题是否已经存在  重复的问题会浪费大家的时间，所以请先搜索打开和已经关闭的问题，来确认你的问题是否已经提交过了。
清楚描述你的问题 

  模版如下
  模版如下

给出你的代码链接 使用像  或者  等工具，贴出你的代码，好帮助别人复现你的问题
详细的系统环境介绍 例如使用什么版本的浏览器，什么版本的库，什么版本的操作系统等其他你运行环境的介绍。 版本：   版本：  

详细的错误输出或者日志 使用  贴出你的错误日志。如果你在  中附带错误日志，请使用``` 来标记你的日志。以便更好的显示。


 
如果你能解决这个 ，或者你能够添加其他的功能。并且知道如何成为贡献者，理解 ，已经签过    后，请发起  。这样维护人员可以将你的分支与现有分支进行比较，来决定是否合并你的更改。
   

 代码并且  到你本地 通过将项目的地址添加为一个 ，并且经常从  合并更改来保持你的代码最新，以便在提交你的  请求时，尽可能少的发生冲突。详情请参阅这里
创建  来修改你的代码，目前  相关的项目默认的  命名规则是 。例如 ，简单明确，一目了然。
描述清楚你的问题 方便其他人能够复现。或者说明你添加的功能有什么作用，并且清楚描述你做了哪些更改。
注意测试 如果项目中包含逻辑修改，那么必须包含相应的测试，在  中会包含测试覆盖率的检测，如果测试覆盖率下降，那么是不可以合并到  的。
包含截图 如果您的更改包含  中的差异，请添加前后的屏幕截图。将图像拖放到您的   的正文中。
保持良好的代码风格这意味着使用与你自己的代码风格中不同的缩进，分号或注释，但是使维护者更容易合并，其他人将来更容易理解和维护。目前  项目的  检测包含代码风格的检查，如果代码风格不符合要求，那么是不可以合并到  的。

  
一旦你新增一个  ，讨论将围绕你的更改开始。其他贡献者和用户可能会进入讨论，但最终决定是由维护者决定的。你可能会被要求对你的   进行一些更改，如果是这样，请向你的  添加更多代码并推送它们，它们将自动进入现有的  。

如果你的   被合并，这会非常棒。如果没有被合并，不要灰心。也许你的更改不是项目维护者需要的。或者更改已经存在了。发生这种情况时，我们建议你根据收到的任何反馈来修改代码，并再次提出  。或创建自己的开源项目。
 合并流程
 提交之后，请耐心等待维护者进行 。目前一般在一到两个工作日内都会进行 ，如果当前的  堆积数量较多可能回复会比较慢。代码提交后  会执行我们内部的测试，你需要保证所有的单元测试是可以通过的。期间可能有其它的提交会与当前  冲突，这时需要修复冲突。维护者在  过程中可能会提出一些修改意见。修改完成之后如果  认为没问题了，你会收到     的回复。当收到两个及以上的  后，该  将会被合并。
标注：本文「一个典型的开源项目是由什么组成的」及「齐步走为 」参考自英文  ，由社区成员朱武  、小卢 着手翻译并替换部分原文中的截图。 ：如何参与一个  开源项目英文原文地址： 

 加入   
为更好地促进  间的交流，便于随时提出好的想法和反馈，我们创建了一个   微信群，对成为   有兴趣的同学可以添加   微信号：，它会在后台和你打招呼，并积极招募你成为开源社区的一员。

 源码地址：技术咨询：作者 | 庄涵编辑 | 迷鹿

庄涵，目前就职于腾讯，热衷于前沿技术的研究与实践，对大数据、机器学习领域有着浓厚兴趣。

导语
于正式发布，伴随着更简单、更快速、更智慧的新特性， 已经逐步替代  在大数据中的地位，成为大数据处理的主流标准。本文主要以代码和绘图的方式结合，对运行架构、 的实现、 作业原理、  的存储原理、  模式  机制进行解析。
、运行架构
支持多种运行模式。单机部署下，既可以用本地模式运行，也可以使用伪分布式模式来运行；当以分布式集群部署的时候，可以根据实际情况选择自带的独立运行模式、运行模式或者模式。虽然模式多，但是的运行架构基本由三部分组成，包括驱动程序、集群资源管理器和任务执行进程。　

、提交作业，向申请资源；
、会根据当前集群的资源使用情况，进行有条件的策略：先分配的应用程序尽可能多地获取资源，后分配的应用程序则在剩余资源中筛选，没有合适资源的应用程序只能等待其他应用程序释放资源；
、默认情况下会将应用程序分布在尽可能多的上，这种分配算法有利于充分利用集群资源，适合内存使用多的场景，以便更好地做到数据处理的本地性；另一种则是分布在尽可能少的上，这种适合密集型且内存使用较少的场景；
、创建后与保持通讯，分配任务集给，按照一定的调度策略执行任务集。
、
弹性分布式数据集  ，作为的编程模型，相比模型有着更好的扩展和延伸：　

提供了抽象层次更高的　

高效的数据共享　

高效的容错性　


、 的操作类型　
大致可以包括四种操作类型：

创建操作：从内存集合和外部存储系统创建，或者是通过转换操作生成

转换操作：转换操作是惰性操作，只是定义一个并记录依赖关系，没有立即执行　

控制操作：进行的持久化，通过设定不同级别对进行缓存

行动操作：触发任务提交、运行的操作，操作的结果是获取到结果集或者保存至外部存储系统　


、 的实现
、 的分区　
的分区是一个逻辑概念，转换操作前后的分区在物理上可能是同一块内存或者存储。在操作中用户可以设定和获取分区数目，默认分区数目为该程序所分配到的核数，如果是从文件创建，默认为文件的分片数。
、 的“血统”和依赖关系　
　　　“血统”和依赖关系： 的容错机制是通过记录更新来实现的，且记录的是粗粒度的转换操作。我们将记录的信息称为血统关系，而到了源码级别，  记录的则是  之间的依赖关系。如上所示，每次转换操作产生一个新的子，子会记录其父的信息以及相关的依赖关系。　
、依赖关系

依赖关系划分为两种：窄依赖 和 宽依赖源码中为 。
窄依赖指的是父  中的一个分区最多只会被子  中的一个分区使用，意味着父的一个分区内的数据是不能被分割的，子的任务可以跟父在同一个一起执行，不需要经过  阶段去重组数据。
窄依赖包括两种：一对一依赖和范围依赖　
一对一依赖：　　
范围依赖仅方法：　　
宽依赖指的是父  中的分区可能会被多个子  分区使用。因为父  中一个分区内的数据会被分割，发送给子  的所有分区，因此宽依赖也意味着父  与子  之间存在着  过程。
宽依赖只有一种：依赖　

、作业执行原理

作业：每一个行动操作都会生成一个或者多个调度阶段　　调度阶段：每个都会根据依赖关系，以过程作为划分，分为  和 。每个包含多个任务集，的数量与分区数相同。　
任务：分发到上的工作任务，是的最小执行单元　　　：是面向调度阶段的任务调度器，负责划分调度阶段并提交给　
：是面向任务的调度器，它负责将任务分发到节点，由进行执行　
、提交作业及作业调度策略适用于调度阶段　

每一次行动操作都会触发的方法进行作业的提交。
这些作业之间可以没有任何依赖关系，对于多个作业之间的调度，共有两种：一种是默认的模式，另一种则是模式，该模式的调度可以通过设定最小任务数和任务的权重来决定执行的优先级。　
调度策略：优先比较作业优先级作业编号越小优先级越高，再比较调度阶段优先级调度阶段编号越小优先级越高　
调度策略：先获取两个调度的饥饿程度，是否处于饥饿状态由当前正在运行的任务是否小于最小任务决定，获取后进行如下比较：

优先满足处于饥饿状态的调度　

同处于饥饿状态，优先满足资源比小的调度　

同处于非饥饿状态，优先满足权重比小的调度
　

以上情况均相同的情况下，根据调度名称进行排序　

、划分调度阶段构建　
构建图：　　　　的构建：主要是通过对最后一个进行递归，使用广度优先遍历每个跟父的依赖关系前面提到子会记录依赖关系，碰到的则进行切割。切割后形成传递给进行执行。　
的作用：让窄依赖的操作合并为同一个，将多个任务进行合并，有利于任务执行效率的提高。　
结构图：假设数据有两个时，是一组关联的，但相互之间没有依赖关系的集合，的数量跟个数相关，主要包含的集合，中的信息等等。会被序列化和压缩　
、存储原理 分析
、过程解析实例

 数据处理：文件在中以多个切片形式存储，读取时每一个切片会被分配给一个进行处理；
 端操作：端对文件数据进行处理，格式化为键值对，每个都可能包含等多个字母，如果在端使用了，则数据会被压缩，值会被合并；注意：这个过程的使用需要保证对最终结果没有影响，有利于减少过程的数据传输；
端操作：过程中，假设和，和在同一个端，需要将端被分配在同一个端的数据进行洗牌合并，这个过程被称之为。
、端的写操作
　　端处理数据的时候，先判断这个过程是否使用了，如果使用了则采用数据结构作为内存缓冲区进行数据存储，对于相同的数据每次都会进行更新合并；如果没有使用，则采用数据结构，把每次处理的数据追加到队列末尾；
写入数据的过程中如果出现内存不够用的情况则会发生溢写，溢写；使用的则会将数据按照分区和数据进行排序，做到分区有序，区中按排序，其实就是将和数据的作为进行排序；没有使用的则只是分区有序；
按照排序后的数据溢写文件，文件分为文件和文件，文件作为索引文件索引文件的数据，有利于端的读取；注意：每次溢写都会形成一个和文件，在完全处理完后会将多个和文件为一个和文件
、端的读操作
有了端的处理，端只需要根据文件就可以很好地获取到数据并进行相关的处理操作。这里主要讲端读操作时对数据读取的策略：
如果在本地有，那么可以直接从中获取数据；如果需要从其他的节点上获取，由于过程的数据量可能会很大，为了减少请求数据的时间并且充分利用带宽，因此这里的网络读有以下的策略：　
每次最多启动个线程去最多个节点上读取数据；
每次请求的数据大小不会超过默认值为
、的机制模式
、异常
当发生异常退出的情况，会尝试获取可用的节点并启动，这个很可能是失败之前运行的节点。这个过程系统会尝试次，限定失败次数是为了避免因为应用程序存在而反复提交，占用集群宝贵的资源。
、异常
会定时发送心跳给，也会定时检测注册的是否超时，如果异常，会告知，并且同时将这些从其应用程序列表中删除。
、异常
、：将集群元数据持久化到，由通过选举机制选举出新的，新的从中获取集群信息并恢复集群状态；
、：集群元数据持久化到本地文件系统中，当出现异常只需要重启即可；
、：通过对抽象类进行实现并配置到系统中，由用户自定义恢复方式。

相关推荐
集群部署与高可用【教程】核心概念想让代码运行快倍，同时不改变复杂度，正如标题所说的，使用反射机制，可以让代码运行得更快。
首先来解释一下为什么会首先使用反射机制。
有一个接口表示一个树节点和一个实现这个接口的大量类。诀窍在于，树是异构的，每个节点类型可以有不同数量的子节点，或者以不同的方式存储它们。
我需要让代码能够在这样的组合树上运行起来。简单的方法是简单地向接口添加一个方法，并在每个节点中实现它。当然，这很繁琐，也很乏味。
相反，我注意到所有的子节点都是直接的字段，或者聚集在包含节点集合的字段中。所以可以用反射的方式写一小段代码，这也对每一个节点都适用
我已经在上放了一个简化版的代码。我会把相关的部分联系起来。
初始化代码
这是我提出的第一版本代码：。
它相当简单：获取节点类的方法，过滤掉那些不是的方法，然后只考虑返回节点或节点集合。调用这些方法，并在子节点上递归地调用方法。
如果我说这样的进展很慢，有人会感到惊讶吗？
缓存
有一个简单的调整，可以使它更快使用缓存方法查找。
下面是缓存版本：
这和每个实现节点的类都是一样的，创建一个对象来缓存所有相关的方法，所以只需要查找一次，这会产生一个令人满意的倍加速。
 奇迹
不幸的是，这仍然太慢了。所以我向谷歌寻求帮助，发现了一个很有用的社区。
有答案建议使用，这是一个标准的库类，它支持语法调用。
细节在我看来有些模糊，但似乎通过使用这些工具，可以在代码中“打开编译器”，并优化反射机制来进行本机调用。这就是一种假设。
这是代码：
现在，我的代码可以做到倍的加速。然而，在写这篇文章的时候，想用一些代码片段来演示这个效果，但是没有成功。我试着给接口实现个子类，并使用一些伪方法进行过滤，但还是没有效果。第二版和第三版的代码运行速度差不多。
我重新检查了原来的代码，一切看起来都很好。在原始代码中，树是通过解析一些源文件得到的抽象语法树。如果限制了前个源文件的输入，我发现会得到不同的结果。
这些文件相对较短几乎没有行，语法简单。但仅仅有这些，第二和第三版代码仍会以同样的速度运行。但是在第个文件中进行输入少于行，那么第二个版本的代码会花费秒，而第三个版本代码会在秒内完成，这是倍的差异。
我的假设是，如果场景足够简单，优化器会注意到正在运行的代码并选择离开。在更复杂的情况下，它会耗尽优化预算，然后回到未优化的版本以及糟糕的性能状态。但是，优化器已经足够灵活，如果有一个能击败它的示例，那似乎是非常成功的。
可能性
我有点好奇会有什么样的可能性。在我的示例中，它会产生奇迹，因为反射调用比简单的缓存查找要昂贵得多。但它是否也能对常规代码进行优化处理呢这似乎不太可能让  提供帮助，因为编译的方法必须以某种方式检索，而查找的成本将使收益相形见绌。
但是，如何在运行组合代码时进行优化呢可以提供数据结构，或者为数据结构提供解释器，并使用“编译”它们。这是否足够智能呢，可以对给定数据结构的代码进行部分评估，从而将解释器转换成等价的“”代码？
顺便说一下，这正是框架所采用的方法，它在 上运行，所以这个想法肯定有一定的意义。可能暂时无法使用当前的，因此需要修改。
在任何情况下，都会尽量使一些功能成为一个库，可以在“常规程序”非编译器中使用。编写简单的解释器通常是解决一些问题的最简单方法。
文章出自导语：关于  使用踩过的一些坑。

、  和  速览
 和  都是一个可以看成有很多行，每一行有若干列的数据集姑且先按照记录和字段的概念来理解 
在  中可以这样表示一个 ： 每条记录是字符串构成的数组  … 每条记录是多个不同类型的数据构成的元组 

 是分布式的  对象的集合， 中每个字段的数据都是强类型的

当在程序中处理数据的时候，遍历每条记录，每个值，往往通过索引读取
  = 
     = {
          = 
        ==  =  ={
                 = 
        }
        
    }

这种方式在  程序中也常常见到。 
 则是一个每列有命名的数据集，类似于关系数据库中的表，读取某一列数据的时候可以通过列名读取。所以相对于 ， 提供了更详细的数据的结构信息 。
在   中，  的概念已经弱化了，将它视为  的一种实现

       ==

除了  这种类型之外，还可以是一些其他自定义的类。 
  属于用于处理结构化数据的   模块这个模块还有  ，通过比  多的数据的结构信息，  在计算的时候可以进行额外的优化。     。通过列名，在处理数据的时候就可以通过列名操作。 
、 和  的区别中介绍了  的优势， 里也加大了对  的支持，并且提到           。所以未来推荐使用 。
、使用介绍
 加载数据
目前  提供了读取  表生成  或  的 。

  =  
  =  
  =      



  = 
  =      
这个返回的是 带有  的 数据， 即 

   =      
或者直接读取 
 ==
  = 

这个生成的是 一个  每一行是一个字符串，需要用户自己去分割读取
 转换操作
、选择指定列
查看表的 

                
                 | __   = 
                 |    = 
                 |    = 
                 |    = 
                 |    = 

选取指定列 方法 

 函数说明                            在整个  期间创建一次就好，如果同一个创建了两次车，会报错
  =     


选取指定列 方法 
   =     
说明：     用列名构成  类型，并且可以用  指定别名。

   = _

如果是 
   = 
         = {
                   =  
                
        }



   = 
        __  
          
          
          

   = 
   =  
、 
  = 
         = {
                  = 
                 || {
                         = 
                }
                
        }



这里 有两个地方需要说明  首先要判断要选取的列的值是否为空， 如果是空，直接读取数据会抛异常。 本来是要指定具体的类型的，如 ，但因为  的  已知，包括各个字段的类型，如  是 ， 这样如果按  有可能会发生类型转换异常。
转换加工某些字段，即将原来的   操作转换成另外一个 。最开始的想法是用  的 一些列表类型封装数据，当每个列的类型相同的时候，用数组 如 ，但一般情况下是不同的，就用元组  …，但这个方法有个局限，我们以  的操作为例，但在  中也是一样的
  =  
         = 
                                
         



语法错误：       
编译报错：        。  
当生成的  是一个超过  个字段的记录时，如果用 元组  就会报错，  是  
不使用 数组和元组，而使用     
   = 

  = 
         = {
                  =  
                  = 
                  = 
                
                
        }

  = 
  =  
、聚合分组统计
指定列，分组统计
  = 

 说明，上面的操作有两步，
   
     

注意 
 _

  =   
最后返回的是分组字段，和计算字段
即： 
分组字段，需要特别提一下的是，可以不指定，即分组字段为空
计算字段，可以用  写法，跟  很类似
  
  
  
   



由于  这个函数，必须要传两个参数，所以自己写了一个函数来封装原始的
      = {
          {
              = 
             _ =   _
        }
    }

 所以在标准化编程的时候，可以把维度字段，计算的字段封装成数组，然后计算。



  = 
、
  = 
处理空值，将空值替换为 

、 数据中存在数据丢失
，如果数据中存在 不是  那么一些统计函数算出来的数据就会变成 ，如 。所以要对数据进行过滤或者转换。
 

 {
        
}
或者直接过滤掉
、 语句里一些不支持的函数或写法
不支持的函数：_ 
不支持的写法 支持 ，所以在写正则的时候可以取反如   \  要求不能数字开头，数字结尾，全是数字就可以写成  \ \ 里面至少有一个不是数字的字符
  一些基础功能
  =    
表是否存在

分区是否存在
 

     = {
         
            
            
            
            
            _
            
    }


创建表，会自动创建默认分区，不用再单独创建  


创建分区
  

清空分区，其实可以在写数据的时候，指定是否覆盖写
 

  
  =     
  


判断  路径是否有数据
  = {
          = 
         
         
        
}

  =  
 == {
        没有数据
}

判断表的分区类型 小时还是天分区
     = {
         {
              = 
                 = {
                     = 
                }
            
            {
                  = 
                {
                    
                }{
                    
                }
            }{
                
            }
        }{
            
        }
    }
 本地测试  
由于  程序，需要由客户端提交给集群执行，但在程序调试阶段，想快速验证代码逻辑，通过每次提交集群执行程序太费力了，可以在本地测试一下。但其实没必要用 ，但有工具何乐而不用。
 
 
  {

           = 
        准备 进行测试需要的数据、环境
        
          {
                 里这个字符串 表示方法跟  一样
                 = 
  
  _=
  =
  
  
  _=
                
        }

        执行测试逻辑
        
          {
                  = 

                然后就可以用上面模拟的数据对象，调试代码逻辑了
        }

        可以封装一些其他的函数，被  调用 不是必须的
            {
                  =         
                  =   {  =    }    
                  = 
                         = {
                                   =  {  =  }
                                  =  {  =  }
                                
                                  =   
                                
                                            
                        }
                
                
        }
   参数
   设置值
    统计的时候，需要 ，目前  的  默认  的个数是  如果数据量过大，或者  的时候数据膨胀，就要适时调大这个参数。因为一个  对应一个任务，增加  个数，会增加并行的任务数，提高运行效率。
 
这个参数好有同样的效果，不过好像应用的场景是  的  操作。
 写 
  = ==
  =  
 
 
 
 

  
  连接 ，操作 

  = 

查询指定表是否存在
  = 
  = 
 _  _  _=


  = 
{ 有相应的表

}

  = 
         =       

  = 
    删除的数据记录数：    
发送  请求
 
 _

  = 
  =  
将结果  解析成  
  =  
参考
【】     【】、 和  的区别【】 【】  —介绍 【】 介绍【】  是公司研发的一个强大的基于浏览器的开源自动化测试工具，它通常用来编写应用的自动化测试。早期也即时期主要使用   进来自动化测试。集成了和的功能。
一、 
  的组成
下图所示为 的工作原理：

 
 负责控制浏览器行为，总的来说， 主要包括个部分：、 、 。其中 是被 注入到浏览器页面中的，它其实就是一堆函数的集合。自动化测试的过程是： 启动一个 ，将操作元素的调用转化为一段段，在内核启动浏览器之后注入这段函数即 ，通过这些函数，我们才可以实现用程序对浏览器进行操作。可以获取并调用页面的任何元素，自如的进行操作
 
写测试用例时用来控制 的库。测试用例通过调用 来编写相关的代码。
  与的关系
工作流程如下图所示：

具体过程为：
测试用例通过 的接口向 发送请求，要求和 建立连接
 的启动浏览器，把 加载入浏览器页面中，并发浏览器的代理设置为 的 。
测试用例通过 的接口向 发送请求， 对请求进行解析，然后通过 发送命令通知 执行操作浏览器的动作。
 接收到指令后，执行操作
浏览器收到新的页面请求信息，于是发送请求，请求新的页面。 会接收到所有由它启动的浏览器发动的请求。
 接收到浏览器发送的请求后，自己重组请求，获取对应的页面
 的 把接收的页面返回给浏览器
  的缺点
 不能处理本机键盘和鼠标事件
 不能处理弹出框、对话框基本身份认证、文件上传下载事件
 使用注入技术，速度不够理想，稳定性大大依赖于内核对翻译成的质量高低。
二、
提供了另外一种方式与浏览器进行交互。那就是利用浏览器原生的，封装成一套更加面向对象的  ，直接操作浏览器页面里的元素，甚至操作浏览器本身截屏，窗口大小，启动，关闭，安装插件，配置证书之类的。由于使用的是浏览器的原生，速度大大提高，而且调用的稳定性交给了浏览器厂商本身，显然是更加科学。然而带来的一些副作用就是，不同的浏览器厂商，对元素的操作和呈现存在不同程度的差异，这就要求 要分浏览器厂商的不同，提供不同的实现，例如有专门的，有等等。
 协议是通用的，也就是说不管是还是，启动之后都会在某一个端口启动基于这套协议的 。例如初始化成功之后，默认会从开始，而从开始。后续我们调用的任何，都需要借助一个发送一个命令，实际上是一个 给监听端口上的 。在我们的 的中，会以 协议规定的格式的字符串来告诉我们希望浏览器接下来做什么事情。
工作流程如下图所示：

具体过程如下：
实例化，首先会确认浏览器的 是否存在可用而且版本匹配。若匹配则在目标浏览器里启动一整套 。这套 使用了自己设计定义的协议，名字叫做   。这套协议非常之强大，几乎可以操作浏览器做任何事情，包括打开、关闭、最大化、最小化、元素定位、元素点击、文件上传等等
发送请求时，用的类将命令转换为作为，命令作为一起存入作为，同时会在的中存放相应的 、、。实际发送的都是相对路径，后缀多以开头，这也意味着每次启动浏览器都会分配一个独立的，多线程并行的时候彼此之间不会有冲突和干扰。比如我们常用到的____这个接口，会转化为这个，然后在发出  内再附上具体的参数，比如 的值。比如我们要访问某一个网站，请求地址为：，请求内容：{}。比如查找一个为的元素，请求地址后缀为，内容{_}。
收到并执行了这个操作之后，也会回复一个 。内容也是，会返回找到的的各种细节，比如、 、 、 等等。比如：
{
{}}当前浏览器不能支持视频播放，请采用或以上浏览器
序言
本文是 【十分钟轻松搞定云架构】的第一节课：从上云开始，从这节课开始，我们来一起学习云端架构。
在这节课，我们主要讲两个知识点：

云计算和本地托管的区别

云端最简架构


云计算和本地托管的区别
云计算和本地托管最大的区别，就是弹性，而云计算最大的优势也是弹性。

在安全性上，云计算主机相比于本地托管的独立主机依然有一定的弱势，云计算的虚拟化的模式导致你可能会被你的邻居所影响，而独立租用的主机一般是独享线路和服务器。不用担心邻居的问题。不过目前来说，云计算服务商大多已经把这个问题处理的非常好。我们已经无需担心。。
不过从另外的方面看，云计算的安全性要强于本地托管主机，因为本地托管的主机是无法提供附加的安全服务的。而云计算主机商大多有附加的安全服务，可以为我们提供软件、网络层面更多的安全能力。
在稳定性上，云计算主机要优于本地托管的独立主机。云计算数据中心的大规模投入保证了相应的基础设施的完善。而这些完备的基础设施，将为我们的应用保驾护航。本地托管的主机大多没有这样的投入，对于故障的响应和对应的解决方案准备大多不足。容易出现故障无法恢复的问题。
在弹性上，云计算资源的分配基于虚拟化，存在资源池的性质。各种资源都可以通过对参数的调整来实现应用的配置的调整。而本地托管的物理机就没这么方便，可能需要你关机、重启服务器来去配置你的应用，而服务器的启动周期较长，会有一个较长的停止服务的周期，这样对于大多数应用来说，都是不可接受的。其他相关的配置的变化也是比较耗时的。大批量的变更可能耗费大量时间。
投入方面，由于云计算具备强大的弹性，我们可以在业务发展的初期，使用一个较低的配置，来跑我们的业务，随着业务的不断发展来提升我们的配置，这样你的支出就会以一个比较低的起点，不断的提升；而传统的本地托管模式，需要你在开始部署应用前，就计划好可能用到的资源的数目，一次性投入大量的资金购买基础设施，如果前期的投入不足，会导致你在后期需要不断的重启、提升配置，可能会造成更大的损失，这样来说，本地托管的投入是更高的。
云端最简架构

大部分中低端用户和对云计算不了解的开发者，都在使用这种云端最简架构。
这种架构的优势在于他的学习成本较低，维护和操作也要简单一些单机总是要比集群操作起来简单一些，使用的成本也相对较低只需要支付一台云主机的价格。
但是这种架构存在很多问题：容易爆发单点故障关于单点还是多点，可以看本课程的知识点课：单电和多点、性能受主机影响较大单机的性能存在上限、业务拓展的难度高应用性能受主机的性能限制。
如何优化最简架构？

想要优化架构，就要找到薄弱的点在哪里。一开始， 比较容易考虑到的是，在业务层面，拆分计算能力和存储能力，也就是在代码层面，使用合理的设计，将我们的业务的重点和难点，拆分出来，进行强化。另一个方面，就是拆分数据库：我们的文件读写是占用硬盘的，数据库的读写也是要占用硬盘的，当两者都在同一台机子上时，就会出现 不够用的情况，我们可以将数据库拆分出去，来降低我们的硬盘 的压力。
关于如何上云，这次课程，我们就讲到这里，下节课我们为大家揭秘更多云计算的知识。

相关推荐
直播回看：高可用架构入门 —— 腾讯云架构演变及经验作者：潘佳宇

只想先把这件事做到极致这只是自己在最后一个暑假的折腾做出来我已经很心满意足了 书签长什么样子，直接看图吧
设计图
实物效果图

之所以做书签其实是因为自己看书的时候老是忘记之前看到哪我又不想把书页折一下当标记就想买书签逛了大半天的淘宝又发现没有自己喜欢的那么？我不如自己设计个书签出来自己用吧设计书签的时候，我担心书签不够用怎么办？能不能通过一张书签就能知道自己最近在读哪本书？那么能不能通过微信二维码，一扫就知道自己在读哪本书？
如何在腾讯云中从到实现这款作品的呢？
一申请一个云服务器，我申请的配置是

二搭建即可视化管理系统
 的具体操作过程地址。腾讯云的  里面有很多大神，也有很多教程可以让我们小白也能轻松上手，至于为什么要搭建一个  ，其实这个是一个后台管理系统，相当于在服务器中搭建一个系统，方便后期可视化操作因为直接进入后台就能设置相应的东西，打开相应的文件，而不是利用代码来实现。
三学习开发经验
我学习  语言，建议学习韩顺平老师的，或者是兄弟连  的视频教学。当然还有很多免费优质的教材，比如慕课，网易云课堂，极客学院……
四运行的环境
实施步骤

微信开发签名认证，从微信公众后台下载微信开发文档，上传至腾讯云。

微信公众后台开发者模式中，填入  和  进行认证。

认证完成之后，编写  关键字回复代码。

 关键字回复功能实现之后，搭建  数据库。

编写数据库连接代码。

数据库完成之后，可使用  语句进行插入，删除，修改等功能。


五踩过的坑
每个云有每个云连接数据库的代码，比如 ，  连接数据库的代码是不一样的。新浪  的是
     =__数据库名
     =__数据库账号
     =__数据库密码
     =___主机名
     =__
百度  的是：
 =  数据库名
             = _____ 主机名
             = _____
             = ___ 数据库账号
             = ___ 数据库密码
但是腾讯云连接数据库的代码比较简单 = _这段代码就能实现
检查  代码是否有问题，可以重新建立一个  来对相应的代码进行测试

检查  语句是否有问题，可以在  里面的  进行检查，有时候检查错误花费的时间甚至比重新再写一次代码还久。所以我们可以利用我们所能利用的资源来快速查找出我们代码中的  。
比如说变量的定义，有人定义   ，也有人定义   符号的使用，数据库里面的符号是这个，不是 ’ 。
培养良好的代码注释习惯，方便自己和他人在以后重新查看代码的时候，能更加高效快捷，比如我那时候在学习的时候，一开始看到源码的时候，我有点摸不着头脑，所以我就边学边注释，希望自己下次，或是别人看到源码的时候能知道里面是在说什么功能

微信验证成功之后，把方法注释掉，这样可以避免之后的开发，曾经因为这个原因，导致我的代码一直都跑不起来


相关推荐
解决方案
如何创建属于你自己的域名邮箱
如何在腾讯云上搭建一个自动播放的服务器 发布了两个月了，中间经历了很多版本更新，也慢慢开始有一些用户选择  作为开发框架来开发小程序，比如一些线上小程序。

以及一些来自网上的  的相关资源：
源码： ，图书管理系统
组件：图表控件
因此我也将手机充值小程序在开发过程中  的应用心得分享出来，可以参照对比与传统小程序开发上的差异。
说明：本文不涉及到  的使用与说明，如果需要请参看我的另一篇文章 ”打造小程序组件化开发框架” 或直接参看 项目地址
组件化
开发时期望逻辑代码按照业务模块划分，从视觉图上来看，首页可以分为五个模块，分别是：

输入框：

下拉历史记录：

充话费：

充流量：

右下角菜单：


如下图：

在原生小程序中，可以使用小程序的模板特性来达到模块化区别的目地，如下：
  
 =
 = 
 = 
 = 
 = 

 =
     = ={{}} 
     = ={{}} 
     = ={{}} 
     =

 
  = 
  = 
  = 
  = 
  = 

  = {
     
     
     
     
     
}
 

如此，便可以业务模块去组织自己的代码。
小程序的模块与模块并无直接关联，在数据或是事件的命名上需要使用前缀或者是命名空间的方式区分，以防冲突。
比如在模块中有一个商品列表，并且每个商品都有一个点击下单事件。因此在开发时需要使用，或者，以防止与模块冲突，代码如下：

 ={{}}
     =  = ={{}} ={{}} ={{}}
        {{}}
    

使用  直接让小程序能够支持组件化开发。让小程序开发能够像 ， 一样使用自定义组件开发。因此首页 中可以写成这样：


     =
         = 
         
         
         
    


       
       
       
       
       

          {

         = {
             
             
             
             
        }

         = {
             
        }
    }

在充话费组件中关键代码如下：


    
     ={{}}
         =  ={{}} {{}} {{}}
            {{}}
        
    
    


       

          {
         = {
             
        }
         = {
                {

            }
        }
          {
              
        }
    }

对比于之间的代码，我们不用再关心是还是。无论是组件还是组件，都有自己的和方法。保证了组件与组件之间数据的隔离。
 混合
混合是对组件的复用性的一种补充，使用可以很灵活的复用不同组件中的相同部分。
比如，为了做好用户体验细节的优化，在面额列表的滚动时加入了阴影控制。当滚到最左边时，左边无阴影，滚动到最右边时，右边无阴影，滚动到中间时两边都出现阴影。如下图：

阴影由两个透明渐变效果的样式决定：，。
对于组件和组件来说，这一功能是两者共有特性，因此可以使用来实现。
创建文件：
   

      {

     = {
         
    }
     = {
           {
             =  
        }
           {
             = 
        }
           {
             = 
        }
    }
}
然后在和中分别引用当前即可让两个组件同时拥有该功能，参考代码如下：

    
      ={{}} = = =
         ={{}}
             =  ={{}} {{}} {{}}
                {{}}
            
        
    
    


       
       

          {
         = 
        
    }

登录态维护
小程序提供  接口可以方便的获取到用户的 ，通过  置换出  作为应用态。 可以储存在  中或者是内存当中，详情可参照官方文档。
参照官方文档整理出我们小程序获取登录态的步骤以及应当具备的能力：

服务器提供一个使用  转换登录态  的接口。

进入应用时，调用  获取 。

调用接口将  转换为 ，并且储存到内存或者中。

发请  请求时自动带上  字段。

因为某些原因导致  失效时，可以自动再次获取新的  并且发送请求。


画出流程图如下：

实现代码如下：
创建公用模块  用于存储全局变量。
  {
     
}
在应用启动时登录，并且置换 ，并且利用  的  功能让每个  都带上 。
   
   
   

 

     {
     {
        
             = 
             = {
                 = 

                 {   的拦截器，在每次发送请求时都会加上
                      {
                         = 
                         
                    }
                }
            }
    }
}
定义  模块，封装  方法，使其在  失效时能再次更新  并且发送请求。
 
   
   

  {
    
       置换登录态  接口
     
      {
         {
             
             {
                 
            }
        }
    }
    
      封装  方法，在第一次登陆态失效后自动登录并转换  后重发请求
     
       {
             = {
             =  {
                  ===  {  登录态验证失败
                      {
                             置换  后依然返回登录态验证失败
                        
                    }
                       可能是过期等原因，获取最新 
                         =   使用最新置换 
                         = {
                             = 
                                重发请求
                        }
                }  {
                    
                }
            }
        }
    }，
      {
          = { }
         
    }
}
因此，在开发时，就不用去关心何时应该登录的问题，直接调用接口既可。比如在  中获取列表并渲染：
      {
       {
         =  
    }
}
上面解释的是原始的登录态维护的一种方式，在手机充值小程序里，每个后端接口都有封装  置换  的能力，后端接口会优先判断请求中是否有 ，如果有  优先使用 ，如果没有，使用请求参数中的  去置换 ，然后处理请求，再将  返回到  当中。因此前端流程有些许改变，如下图：

 文件改动如下：
   
   

  {
       {
            = {
              {
                 = {
                      ===  {  登录态验证失败
                          {
                                 置换  后依然返回登录态验证失败
                            
                        }
                         = 
                          
                    }  {
                        
                    }
                }
            }  {
                  可能是过期等原因，获取最新 
                     = {
                         = 
                           使用  发送  请求
                    } 
                     = {
                         =   返回结果中 设置 
                        
                    }
            }
        }
    }
}
第三方组件
小程序中并不能像一样直接使用弹出消息提示，因此可以选择使用  的进行消息提示，但是官方只支持 和  两种样式。重新写一个  组件成本略高，因此考虑直接使用现成的  组件。使用方法如下：
  安装组件
   
 无缓存编译
  
 需要的组件中引入  组件

  


    
    

       {
      = {
          
     }
 }

 调用
  {
  系统繁忙
  
}
实现效果如下图：

数据上报
是腾讯自家的数据分析平台，在小程序发布后平台很快的就支持了小程序的数据上报。因此手机充值选择做为数据上报平台，具体步骤如下：
 在官网注册应用。
 在平台，小程序开发设置中，将 添加为可信域名。
 安装  模块：   
 在  中添加初始化代码。
   
   

     {
     {
        {
             注册后得到的
             注册后得到的
             使用分析下来刷新次数人数，必须先开通自定义事件，并配置了合法的
             使用分析分享次数人数，必须先开通自定义事件，并配置了合法的
             使用分析页面触底次数人数，必须先开通自定义事件，并配置了合法的
        }
    }
}
这样就完成了的初始化工作，在每个页面的  事件中加入  事件完成页面的上报。
      {
      {
        
    }
}
在  中加入报错上报。
     {
      {
        {}
    }
}
以及在其它业务逻辑代码上加入一些自定义事件上报，比如下单上报，支持上报等等。
{}
结束语
至此，基本介绍完了  在手机充值项目的应用了，剩下的就是业务代码的开发了。 通过不停的版本更新迭代去吸收一些传统框架优秀特性融入其中，比如：组件通讯、传值、、、拦截器等等。也希望在以后能有更多的小程序开发者使用  进行开发。首先，感谢腾讯云通过了我的入驻申请，感谢给我一个在这里发文的机会。
近日总有朋友问我的网站是怎么搞得，其实很简单，但对于没搞过，没有经过各种测试的菜鸟来说，确实也是一桩麻烦事。所以在此写一篇我按照腾讯云官方教程实现的方式，如有问题或发现错误之处，还请留言之处，毕竟我也不是很精，只是会搞，来分享一下。
在说之前，先描述一下我的服务器环境：

一台 云服务器

集成环境

部署好的一个站点，可以通过域名直接访问


下图是我站点的初始化样子，可以看到只是输出一个字符串，啥也没有，并且没有。这无所谓，因为我们的重点是，而不是网站内容

接下来就是配置的关键步骤了，其实只需要三步而已：

申请证书

修改的配置文件

重启



，申请证书步骤如下腾讯云申请证书是很快的，这要给个大大的赞

登录腾讯云进入管理中心，出现下图

然后鼠标放到红色框的地方，会出现下拉框，点击上图中箭头指的位置证书管理出现下图：

如果您还没有使用过，列表应该是空的，然后点击上图中红色框中的申请证书按钮，出现下图：

我们可以直接使用默认的免费版证书，点击上图中确定按钮，出现下图：

在这个页面，在通用名称一栏输入域名，在申请邮箱一栏输入有限，其他可选，下图以我的为例：

然后点击下一步，会让你验证，直接选择  自动验证

然后点击上图中确认申请，会弹框提示已提交，然后到列表中就能看到类似的下图：

在这个列表中，状态一列，我这里显示的已颁发，实际上这里应该是审核中，因为我这个域名之前已经申请过了，所以你们操作完回到这一步，显示的是审核中，然后腾讯审核的效率还是挺快的，几分钟后就颁发下来了。
证书颁发下来之后，然后点击下载，把这个证书下载下来，下载下来是个压缩包，解压之后，打开目录，出现下图：

上图中内置了四种服务环境，选择自己对应的服务环境，如果没有您的环境，可联系腾讯云，我这里是，打开目录，出现下图：

然后把上图中这两个文件上传到服务器的配置文件目录，我个人是上传到但是我有个强迫症，所以我在这个目录创建了一个目录，然后在目录中，存放了一堆目录，每个目录都代表的是一个域名，每个目录中存放的就是该域名对应的这两个和文件，上传方式多种，我用的是命令上传，挺方便，如下图：

上传完了之后，就开始配置域名对应的文件了，完整配置如下：

下面是上图中完整的核心代码
 {
         
        _ 换成你的域名
          __
}
 {
         
        _ 换成你的域名
         
        _ __证书文件
        __ _秘钥文件
        __ 
        _   
        _  
        ___   
}

解释一下，第二个，大家肯定能明白，这是官方给的实例，具体可参考文末给的链接。
第一个，是为了把端口给重定向到也就是把的访问重定向到，不然，直接访问是没问题，但是用户访问时，可能就直接输入域名啥的，这个时候默认走的是端口，所以我们通过这一步直接重定向，就做到了全站。
配置中有个注意的地方：

_和__，后面的引入的路径，要么是绝对路径，从开始，要么就像我这样，要么直接在当前目录下开始找，不要写或者啥的，不支持这种路径，会报错，会报错，会报错！！！

配置完成之后，重启以下命令重启：
  

然后，再次刷新页面，就会发现，直接变成，成功的界面如下图：

到这里，基本上网站开启就结束了，其实这些内容，在腾讯云官方已有说明，但缺少一个傻瓜式的教程，毕竟倘若不太了解服务器，折腾这玩意，还是有些困难，所以在此分享一下经验。
参考链接：官方文档
如有错误，还请留言之处，也可直接联系本人，谢谢。
：
邮箱：  换成
个人博客：赛冷思官方博客
：赛冷思

相关推荐
借助腾讯云开启全站及问题解决分享【腾讯云的种玩法】实现全站访问作者简介：王鹤，高级前端工程师，隶属于腾讯增值产品部。主要负责个性化业务的功能开发及技术优化。目前专注于框架的研究，致力于提升效能，解放生产力。

一、框架的选型
没有什么框架是全能的，都有其适用场景。我们的最初的定位一定要围绕我们的业务来选择。我们个性化业务是基于移动端的多页面应用。我们综合考虑之后，决定使用来作为现在和将来的核心主框架，未来的演变也基于此基础。
、为什么使用
早些年，前端的框架呈现爆发式的增长，比如，，，，。对比过这些框架，最终选择了作为我们业务的「核心引擎」。原因如下：
和虽然火爆，但是学习曲线还是太陡了，需要理解很多东西，上手不易。上手非常容易，语法简单。我们试验过，一个有前端基础但没有接触过的同学，基本上一天就可以上手开发简单应用。几天之内学会模块组件的概念基本就可以完成中等复杂的业务。这是其它框架无法相比的。
的文档是非常友好的，当然现在其它框架的文档建设也在加强。这也告诉我们一个东西是否能普及开，核心有两点，一是本身足够好用，二是足够方便理解。做到了这点，所以它火了。
体积小适合移动端业务，在压缩后的代码是的一半。而且移动端基本没啥兼容性问题。的话兼容。如果是业务，其实我们现在也只是兼容。把时间浪费在兼容性问题上完全是浪费生命。所以现在的前端开发者，感谢这个时代吧。
最新的版本中也逐步借鉴学习了一些其它框架的优秀的思想，能学习和使用一种框架用到深处，我想是足够满足我们的业务需求的。
、为什么使用
数据流结构规范化的重要性
在业务需求的中级阶段，我们意识到数据流结构规范化的重要性。因为本质是框架，引入了数据流的概念。但是弱类型语言，数据流本身比较随意，比如一个的属性，基本属性有按钮文字，按钮状态，按钮进度等三个基本数据属性。但是团队中不同人可能有自己的想法，关于一个的定义命名都有可能不一样。长期看来，注定无法维护。这时候数据结构的规范接口，强类型显得非常重要。引入这些概念，对基本组件的定义和规范在代码编写阶段自然就形成了约定不遵守规范，编译都通不过，这比文档规范约束有效和方便得多。
恰好就是为此类需求而诞生的，而且充分考虑到兼容性。对之前的代码完全兼容。
使用特性，具有优秀的自编译能力
很多项目的编译都是通过进行处理的，不熟悉的朋友可能整配置都要搞半天，而且还有和的区别，两者也并不太兼容。
具有自编译的能力，不需要额外引入。只依赖，将此文件放到项目的根目录，即可全局配置。
不仅能满足的编译的功能，而且比做得更好。比如很重要的语法，在使用的时候会引入相当大的一个文件：

则非常干净利落，就几十行代码：

引入了，系统性地解决了绝大部分公共库的类型定义问题
迟迟没有在生产项目中使用的一个很大的原因就是类型定义实在是太麻烦了。从到，最后是。微软自己也发现有这么个问题，所以也在一直演进。目前来看，算是一个不错的方案。充分利用进行管理和维护，且绝大多数公共库都已经支持，比如、等。更先进一些，直接本身模块即支持的类型定义。不需要额外的。也就是  即可在中正常使用。
、为什么使用
使用最核心的地方就是使用特性，是大势所趋，符合代码极简主义，提高代码使用率。对于代码的精简还是挺高的，大概可以优化的代码体积。
要使用的，前提条件就是使用的，这是核心根本。所以意味着所有的代码要基于的来写。建议从新项目入手，代价较小。

阶段性小结：
、使用，从数据驱动的角度来处理逻辑，操作，可以完全抛弃
、由于使用数据驱动，数据本身的结构由为重要，再加上方便优雅地使用，我们引入了作为主要开发语言
、利用的的重构代码，通过的来达到简化代码体积，提高代码利用率的目的。

二、项目实践
从本章节起开始结合线上项目来讲讲框架的使用和细节。本次介绍的项目名叫「个性化体验卡」。基本上借助此项目从头搭建了一套基础底层，项目本身是多页面项目。
、项目结构
首先是项目结构，基本上只需要一个公共库目录和项目本身目录即可。

公共库目前搭基础，包含和两个即可，这里特别指出的是的库被重写后，从原先的行，减少到行。去除了相当多的无用代码，极简风格。
项目本身目录也很好理解：
——项目的公共方法目录，比如之类的——项目的组件目录，核心目录。以后各个业务都是组件复用——目录，发布时会到中——入口文件目录，基本就是一个框架，如下图所示：

由于的因素，我们的首屏业务逻辑代码可以直接到页面当中，复杂的次屏逻辑可以以动态组件的形式加载。形成直出主内嵌异步动态组件的优雅的加载模式。

细节提示：
这里有个开发细节和大家讲解一下，我们在上图中，我把并没有以模块的形式打入到里，因为一是额外增加了的体积，二是我们的项目是多页面的项目，公共是可以也有必要进行缓存和复用的。
这里采用外链离线包强缓存的形式是比较合理的。

、配置文件
初学者在做配置的时候一般比较蒙逼，所以有脚手架这么个东西来帮助初学者快速搭好环境，但实际上每个人从事的项目不完全一样。脚手架并不能完全满足需求。所以了解一下配置的基本原理还是有相当必要的。
本文是基于、、的框架，用进行把几个东西串起来。
因为文中的脚手架结合了一些项目本身的各种功能，这里先讲几个核心需要注意的点。
  几个最重要的模块
、、、、、、、
这几个装了以后，基本上项目用到的最核心模块都有了。
配置

这个配置非常非常关键，建议初学者直接，每个配置都有用，我也写了注解，不要随意删减。
配置


细节提示：
注意红框部分的地方，一定不要配置错。
这样写的目的是不要把打包进来，一定要注意大小写。大小写不对就容易出错。不理解的初学者直接。
就只配这一个就可以了，其实就是对于模板文件的处理。由于我们的代码自带的特性在编写的时候就转换成了，所以不需要加。但最理想的状态就是编译过程交给或进行，不自动编译文件，这样源代码比较纯粹。

、的组件写法
其实是一个很灵活的框架，可以有很多种写法。的组件看官方文档也有很多写法。但在中，写法和之前有很大变化但其实和、很像了。如果不这么写，你会发现你的编辑器到处报错。。，目前我们线上项目中的组件大概长这个样子：

这就是一个组件，如何使用呢，我们看入口文件的。

更多细节可以参考官方：

这种写法是很优雅和可维护的，以及配合的特性，感觉非常的愉快！
、编辑器的选择
我们项目组的同学基本就两种编辑器，一种是，一种是。其实除了卡，其它都比好用。
这两种编辑器，自带编译功能，所见即所得。配置好，剩下都省心。略复杂，需要建立一个，然后在跑项目的时候执行。也可以达到类似的效果。
、环境搭建的坑
其实如果初学者前面不按照我说的一些细节来操作的话，很容易在搭环境上一堆编译报错，编辑器语法报错。会影响初学者的学习热情。所以这里会尽量在抽离一个相对普适的脚手架给各位使用，尽请期待。
其实初学者按照我上述的配置操作的话，一般问题也不是太大。有遇到任何编译报错或者语法报错，欢迎和交流，我也作下记录。我的微信号是：
、兼容性问题
项目实践过程中，有些兼容性问题这里提出来。避免大家再踩。
首先关于的兼容性实践证明如果你是基于手或微信的移动端业务，可以不需要引入。端还是建议需要。对文件大小不敏感，所以加下无所谓。移动端没有必要，主流都支持。目前线上业务也没有收到什么反馈页面功能由兼容性异常的。
有些写法尽量不要用，已知的就是不要使用的模板字符串。
首先虽然我们配置了，但是并不是所有的语法都转成了，模板字符串就没有完全转义。在的系统里面兼容性有问题，模板会报错，程序会出问题。
不要使用，这个也不会转义，在系统也有兼容问题。而且也不是很优雅。找到一个优雅的写法，就是使用的三点解构符，虽然这两者并不完全相同，且三点解构符其实也并不是用在这里的。只是结合我们的使用场景，比较巧妙。
我们使用最多的无非就是两个对象参数的合并。如果有兼容性问题，又不想写诸如_。那么就试试这种写法，如下所示：

我们看看如何翻译变成这里的，对应的如下：

我们注意到__方法，其实就是翻译了三点解构符。果然如此：

、数据接口
这个是项目实践过程中的细节了。这里指的是数据接口，也就是我们熟知的层。之前过于灵活，现在有辅助，数据结构的定义会更加清晰和规范。不符合规范会报错的。

、中的操作

 = 

这么写是会报错的：

原因是返回的是对象，对象并没有方法，只有继承的对象才有方法，所以这里要写为：

 = 

、采用事件来处理中等复杂程序的组件通信问题
中等复杂的组件通信建议直接使用的和，复杂的就使用。这里组件虽然是用事件进行信息传递，我们还是可以在模板中进行显示的声明，符合模板显示声明一贯的做法。如下图所示：

组件声明，，表示事件名称，后面是传递参数，非常直观。组件的具体监听是：
所有的事件触发和监听都挂载在上面，名为「事件总线」，其实本质就是一个的实例而已
   


      
 
   

   
、其它问题
标签不能用驼峰法，比如在模板中是不会被正确识别的，应该写成
不能用关键字，可能是本身的。使用腾讯云容器服务来构建简单  
本文将介绍使用和来构建简单 ，核心在于如何配置的，使得能够与后端服务通信。我们的 包含两个服务，分别是和，服务收到用户请求后，根据配置，如果用户请求的是文件，则将请求转给后端的服务来处理。
为了方便，容器和容器使用同一个镜像，这个镜像右下面的仓库而来。其中，目录是我们的核心目录，用于存放代码文件。目录用来存放配置，它包含了服务的配置，以及服务的配置。
一、配置说明
| 
| 
|   | 
|   ` 
` 
    | 
    |   | 
    |   ` 
    |       ` 
    ` 
        | 
        ` 
            ` 
我们来看下的核心配置文件 
 {
         

          {
                _  _
        }

          \ {
                ___ \
                _ 
                _ 
                 _
    }
}
通过指定了代码的访问路径，我们项目的文件都位于目录下。
 
并且定义了如果用户请求的是文件，则将请求转发给后端的服务，该服务监听了端口目录的文件中定义。
_ 
通过以上的配置可以看出需要将文件转发给后端的服务，而服务访问服务的方式是通过服务名来访问。在我们的容器集群中，服务之间访问不需要知道服务的或者实例的，只需要指定服务名，集群会自动根据服务名做解析，如果一个服务有多个实例，解析的结果是等概率随机的，由于是等概率的，通过服务名来访问可以实现负载均衡。
二、实验
下面开始我们的实验。在项目目录执行以下命令，将项目成镜像，并上传到镜像仓库中请把镜像仓库空间请换成自己的空间
    
   
  
镜像上传完毕后，我们可以使用这个镜像分别创建两个服务，和，由于两个服务使用的是同一个镜像，在创建服务时注意：

服务名分别为 和，其中服务名您可以改成其他名称比如，但是这个服务名不能改成其它名称，因为我们的配置指定了访问服务，如果没有这个服务，转发时会解析服务出错。
服务指定运行命令为。
服务指定运行命令为。
服务的访问方式为提供公网访问，绑定容器和服务的端口均为。
服务的访问方式为仅在集群内访问，绑定容器和服务的端口为。

和服务创建成功后，我们可以根据服务的外网来访问我们的项目的和。
本文实验的项目源码下载前言
自年春节以来，春节红包经历了企业红包年、刷一刷红包年和红包年几个阶段，通过不断创新玩法，活跃度节节攀升，成为春节一大玩点，给火红的春节带来一抹亮色。年除夕，红包、刷一刷红包再创新高，抢红包用户数达  亿，共刷出红包  亿个。
那么，红包的技术方案究竟是怎样的？其整体架构如何？重要的系统是如何设计的？为了保证用户的体验，手终端做了哪些优化？今年的红包又做了哪些新的尝试，遇到的问题是如何解决的呢？本文将从架构开始，到手终端优化，再到个性化红包和新玩法，为大家全面解密红包技术方案。
一、红包整体架构及重要系统
春节红包以一个又一个的整点刷红包活动贯穿年三十，在除夕夜达到顶峰，是典型的海量用户秒杀场景，如何应对海量的用户刷红包洪流，保证刷得爽，红包安全到账，是红包设计要解决的关键技术难点。另外，红包项目涉及手终端、手后台、钱包财付通系统、礼券系统、公众号等诸多业务系统，流程长且多，各系统性能吞吐量差异很大，如何保证各系统形成一个有机整体，协调高效提供服务，也是难点之一。
下图为简化后红包的架构，包括接入层、抽奖系统、存储系统、发货系统、公众号消息通知和资源等几部分，请大家先有一个整体的认知，便于阅读下文。

本文将重点讲解接入层、抽奖系统和发货系统。
接入层
接入层是红包后台服务的大门，负责抽奖请求预处理，确保有效的请求才透传给后端服务。为保证自身高可用、高稳定，接入层还可实时控制手请求频率，避免海量请求压垮接入层，出现不可控局面。
在海量服务场景下，为避免网络开销，方便后端服务使用提升性能，接入层采用了一致性寻址，保证同一个用户的请求只会落在同一台红包抽奖逻辑机器处理。
抽奖系统
抽奖系统作为红包的核心系统，在承接用户抽奖请求，按设计合理的几率完成抽奖操作，将抽奖结果安全落地保存，并顺利发货等过程中，起到了关键作用。面对海量抽奖请求，如何及时作出响应，是抽奖系统面临的难题。
为了解决这些问题，我们采用了一些设计方法：

在接入层采用一致性算法，同一用户的抽奖请求只会转发到相同的抽奖系统处理

抽奖系统采用缓存机制，在加快抽奖过程的同时也减少了对存储层的访问压力； 奖品配额机制，平滑抽奖过程，各类奖品按比例有序抽中；


流水和对账机制，保证抽奖数据最终无差错发放到用户账户中；
抽奖系统的架构如下图所示：

缓存机制
业务要求在每个刷一刷的活动中，能对用户中奖次数、参与时间秒进行限制。如果用户的每个抽奖请求到来时，先到存储层获取用户的中奖历史信息，再判定用户是否还有抽奖资格，在海量高并发的请求场景下，势必会对存储层造成巨大的压力。所以这里我们引入了本地内存缓存层，用于保存用户的中奖历史信息，每次请求到来时，会先到缓存层获取用户的中奖历史信息，如果在缓存层没找到，才会到存储层获取，这样就不会对存储层造成太大的压力，同时也能实现业务的需求。缓存层我们采用开源组件实现。
一致性寻址
红包抽奖系统是一个分布式的系统，因此为了使缓存机制生效，我们在手接入层使用了一致性的路由算法进行寻址，保证同一个用户的请求总会落在同一台逻辑机器进行处理。

协议处理模块
由于手后台既要处理客户端的二进制请求，也要处理其他系统的请求，所以协议处理模块的首要任务就是兼容各种格式的协议，给后端模块一个最简单的结构。为此我们制定了格式的交互协议兼容格式，会统一转换成处理，传给后端模块。
配额管理模块
手春节红包是通过很多场定时“活动”来发放红包的。每场活动里面能发放多少现金，能发放多少虚拟物品，发放的比例如何，这些都是配额数据。
更进一步，我们要做到精确控制现金和虚拟物品的发放速度，使得无论何时用户来参加活动，都有机会获得红包，而不是所有红包在前几分钟就被用户横扫一空。

配额信息由配额管理工具负责检查和修改，每次修改都会生成新的。一旦配额发现发生变化，则会更新本地共享内存。由于采用双设计，所以更新完成前不会影响当前业务进程。
抽奖模块
聚焦到抽奖，红包的抽奖算法其实并不复杂，但是能否满足产品需要非常重要。我们的设计思路是至少需要满足如下需求：

可以在秒级别控制现金和每种物品的发放速度；
可以方便调整现金和每种物品的发放比例；
尽量保证红包全部发放出去。

为此，我们设计了如下的抽奖流程算法：

需要说明的是，只要是因为配额限制发放红包失败，我们都会继续尝试给用户发放其他奖品的红包，直到没有奖品可以发放，这样我们就能保证把奖品尽可能发放出去。
流水系统设计
流水系统用于保存活动过程中的抽奖流水记录，在活动后对奖品发放和领用进行统计和对账。该系统还定时对领用失败的请求进行重做和对账，确保奖品发放到用户账户里。
流水系统架构如下：

由于流水需要记录用户中奖的信息和领用的的情况，数据量巨大，所以抽奖逻辑层本地采用顺序写文件的方式进行记录。抽奖逻辑层会定期的把本地的流水文件同步到远程流水系统进行汇总和备份，同时，流水系统会对领用失败的流水进行重做，发送请求到抽奖逻辑层，抽奖逻辑层会调用发货系统的接口完成发货操作。
存储层选型
存储层的设计向来都是后台架构设计中的重点和难点。目前腾讯公司内部较成熟的存储系统有、，经过一番对比我们选择使用，主要原因有以下几点：
强大的带条件判断的分布式原子算数运算
抽奖逻辑里需要对每个奖品进行计数，避免多发少发，所以一个高效可靠的分布式原子加计数器显得格外重要，支持带条件判断的原子加计数器，调用一次接口就能完成奖品计数值与配额的判断以及奖品计数值的增加；
灵活的数据类型
支持类型的数据存储格式，可以灵活的存储用户的红包中奖信息，为获取用户单个红包或者红包列表提供了丰富的接口；
部署、扩容方便
有专门的团队支持，易于部署和扩容。
平滑限频设计
每一种奖品，对应的业务都有他们自己的容量能力，且各业务的能力也不尽相同如黄钻，京东等。为保证红包活动持续进行，抽奖系统必须严格按业务控制派发峰值。派发峰值支持实时可调，避免由于业务方评估不足引起过载。

考虑这样一种场景，如果请求是在秒的最开始全部涌到业务方，受限于业务方不同的架构实现，有可能会触发业务方的频率限制或者是过载保护。为此，我们将频限粒度调整到百毫秒，这样奖品就会在秒内相对平均的发放，从而解决了上述问题。
红包发货系统
红包奖品包括现金和礼券两类，现金对接财付通，礼券又分腾讯公司内部虚拟物品和第三方礼券。最终礼品落地到用户的账户钱包余额、卡券或第三方系统账户中。虽然抽奖系统有作平滑处理，但持续长时间的大流量发货，也可能导致业务系统不能正常提供峰值下的服务能力。如何承上启下，既预防抽奖系统不能平滑地发货导致压跨发货系统自身，又能保护后端业务系统的情况下，以较快的速度将奖品安全发放到账，是发货系统的设计要点。发货系统设计遵循以下策略：

快慢分离
异步削峰
柔性处理
保护业务系统
最终一致性

发货系统架构如下图所示：

快慢分离
现金和礼券后端的系统完全不同，现金通过钱包系统发放入财付通账户，要求实时到账不能延迟。而礼券对接的后端业务千差万别，服务容量和性能各不相同。为了不让慢速的礼券发放影响快速的现金发放，将现金通道与礼券通道分离，互不干扰。
异步削峰
由于用户来抽奖的时机完全是随机的，抽奖系统并不能做到绝对平滑发货。任由抽奖系统将发货请求直接透传到业务系统，将出现不可预知的问题，严重时可能会导致业务系统雪崩，这是不能接受的。另外象游戏礼包类、滴滴券等第三方礼券，可能用户账户并不存在用户并不玩该款游戏，或用户并没有第三方账户，需要先引导用户创建账户才能发货，这就要求发货系统有暂存奖品信息，具备延后发货的能力。
发货系统采用开源的消息中间件作为异步消息队列，暂存发货请求，再由礼券发货模块根据各业务的限速配置均匀地调用业务接口进行发货。
柔性处理
礼券类奖品通过异步方式发放到用户账户，在除夕高峰值可能发放速度跟不上抽奖速度，会延后一些时间才能到账，这对不明真相用户可能会造成困扰。因此在用户中奖信息页面中，会提示用户小时或小时到账。发货过程的每个步骤，都有可以异常失败，导致发货不成功，因此在物品详细页面的按钮支持多次发起发货，在“礼券发货”模块根据发货状态，可以多次尝试发货，并保证一个奖品只发放一次。
保护业务系统
前面已经提过，发货系统通过异步消息队列，将抽奖系统与业务开发隔离开，抽奖洪峰不会直接影响业务系统，对业务系统起来隔离保护作用。
礼券发货模块针对每个业务单独配置限速阈值，对各业务的发货严格以不超过限速阈值的速度发放奖品，如果业务有超时或提示超速，再按一定比较再减速。
礼券发货模块首先会到存储系统检查奖品是否真实有效，再到发货状态存储检查状态是否正常，只有真正需要的发货的奖品才向业务系统发起发货请求，确保发货的有效性，避免错发和多发。
最终一致性
由于采用异步发货，抽奖时刻奖品不能保证立即发放到用户账户中。但用户的奖品不会丢失，通过在异步队列中暂存，礼券发货模块逐步以合适的速度将奖品发放到用户账户中。
如果发货过程中有延时或失败，用户可以通过多次领取提起发货请求，系统支持多次提交。
如果多次发货仍然失败，对账工具第天会从流水系统中将用户抽奖数据与发货数据进行对账，对发货异常用户再次发起发货。如果对账仍然失败，则提醒管理人员介入处理。
二、手终端的优化策略
普通用户不会关心红包的后台有多复杂，他们在手终端抢红包时的体验直接决定着用户对红包的评价。对用户来说，看到红包后能否顺畅的抢和刷，是最直接的体验痛点，因此需要尽可能降低延迟以消除卡顿体验，甚至在弱网环境下，也要能有较好的体验。为了实现该目标，手终端采取了以下优化策略：
资源预加载
红包中用到的不经常变化的静态资源，如页面，图片，等，会分发到各地以提高访问速度，只有动态变化的内容，才实时从后台拉取。然而即使所有的静态资源都采用了分发，如果按实际流量评估，的压力仍然无法绝对削峰。因为同时访问红包页面的人数比较多，按万秒的峰值，一个页面按评估，约需要的带宽，会给带来瞬间很大的压力。为减轻压力，红包使用了手离线包机制提前把红包相关静态资源预加载到手终端，这样可大大降低压力。
目前手离线包有两种预加载方式：

将静态资源放入预加载列表，用户重新登录手时监测离线包是否有更新并按需加载天能覆盖，天能覆盖，适合预热放量情况。

主动推送离线包，向当前在线用户推送离线包。个小时可以完成推送，覆盖总量的左右，适合紧急情况通过离线包预加载后，除夕当天的流量并没有出现异常峰值，比较平稳。


缓存和延时
 亿用户同时在线，用户刷一刷时的峰值高达万秒，如果这些用户的操作请求全部同时拥向后台，即使后台能抗得住，需要的带宽、设备资源成本也是天文数字。为了尽可能减轻后台服务器压力，根据用户刷一刷的体验，用户每次刷的操作都向后台发起请求是没有必要的，因此手在终端对用户刷一刷的操作进行计数，定时秒异步将汇总数据提交到后台抽奖，再将抽奖结果回传到手终端显示。这样既保证了“刷”的畅快体验，也大大减轻后台压力，抽奖结果也在不经意间生产，用户体验完全无损。
错峰
对用户进行分组，不同组的用户刷一刷红包企业明星红包、红包等的开始时间并不相同，而是错开一段时间分钟，这样通过错开每一轮刷红包的开始时间，可以有效平滑用户刷一刷的请求峰值。
动态调整
手终端和后台并不是两个孤立的系统，而是一个整体。手系统搭建有一整套的负载监控体系，当后台负载升高到警戒线时，手终端可以根据后台负载情况，动态减少发向后台的请求，以防止后台出现超载而雪崩。
总量限制和清理
在刷一刷红包和红包过程中，当用户已经抽中的奖品数达到一个限值例如个，用户不能再中奖，这时用户的抽奖请求不再向后台发送，而是终端直接告知用户“未中奖，请稍后再试”，和清除红包地图中的红包显示。
接下文《 红包技术方案全解密 二》尽管基于划分的聚类算法能够实现把数据集划分成指定数量的簇，但是在某些情况下，需要把数据集划分成不同层上的簇：比如，作为一家公司的人力资源部经理，你可以把所有的雇员组织成较大的簇，如主管、经理和职员；然后你可以进一步划分为较小的簇，例如，职员簇可以进一步划分为子簇：高级职员，一般职员和实习人员。所有的这些簇形成了层次结构，可以很容易地对各层次上的数据进行汇总或者特征化。
另外，使用基于划分的聚类算法，等的一个问题是，需要指定一个划分簇的数量。然而在实践中，簇的数量往往没有办法提前确定，或者随着关注的数据特征不同，想要的值也随之变化。对于分布如下的数据：

直观来看，上图中展示的数据划分为个簇或个簇都是合理的，甚至，如果上面每一个圈的内部包含的是大量数据形成的数据集，那么也许分成个簇才是所需要的。
所以，讨论数据集应该聚类成多少个簇，通常是在讨论我们在什么尺度上关注这个数据集。层次聚类算法相比划分聚类算法的优点之一是可以在不同的尺度上层次展示数据集的聚类情况。
基于层次的聚类算法 可以是凝聚的或者分裂的，取决于层次的划分是“自底向上”还是“自顶向下”。

自顶向下： 它把所有对象至于一个簇中开始，该簇是层次结构的根。然后，它把根上的簇划分为多个较小的子簇，并且递归地把这次簇划分成更小的簇，直到满足终止条件。常见的自顶向下的算法有层次聚类算法。


自底向上：把数据集中的每个对象最为一个簇开始，迭代地把簇合并成为更大的簇，直到最终形成一个大簇，或者满足某个终止条件。基于自底向上算法有凝聚算法、算法、算法、变色龙算法等。

自顶向下算法
 算法
 算法是“自顶向下”的层次聚类算法，用到了基于划分的聚类算法那，算法思路如下：

首先，把原始数据集放到一个簇，这个簇形成了层次结构的最顶层；

使用算法把簇划分成指定的个子簇_， = …，形成一个新的层；

对于步骤所生成的个簇，递归使用算法划分成更小的子簇，直到每个簇不能再划分只包含一个数据对象或者满足设定的终止条件。


如下图，展示了一组数据进行了二次算法的过程

 算法一个很大的问题是，一旦两个点在最开始被划分到了不同的簇，即使这两个点距离很近，在后面的过程中也不会被聚类到一起。
 
对于以上的例子，红色椭圆框中的对象聚类成一个簇可能是更优的聚类结果，但是由于橙色对象和绿色对象在第一次就被划分到不同的簇，之后也不再可能被聚类到同一个簇。
自底向上算法
 算法
相比于 算法存在的问题， 算法能够保证距离近的对象能够被聚类到一个簇中，该算法采用的“自底向上”聚类的思路。
算法思路，对于数据集，={__…_}：

将数据集中的每个对象生成一个簇，得到簇列表，={__…_}
 每个簇只包含一个数据对象：_={_}；

重复如下步骤，直到中只有一个簇：
 从中的簇中找到两个“距离”最近的两个簇：⁡〖__〗；
 合并簇_和，形成新的簇；
 从中删除簇_和，添加簇


簇间距离计算
在上面描述的算法中涉及到计算两个簇之间的距离，对于簇_和_，计算〖_〗_，有以下几种计算方式：
单连锁 


两个簇之间最近的两个点的距离作为簇之间的距离，该方式的缺陷是受噪点影响大，容易产生长条状的簇。
全连锁 


两个簇之间最远的两个点的距离作为簇之间的距离，采用该距离计算方式得到的聚类比较紧凑。
平均连锁 
 

两个簇之间两两点之间距离的平均值，该方式可以有效地排除噪点的影响。
算法示例
对于如下数据：


将到六个点，分别生成个簇；

找到当前簇中距离最短的两个点，这里我们使用单连锁的方式来计算距离，发现点和点距离最短，将和组成一个新的簇，此时簇列表中包含五个簇，分别是{，}，{}，{}，{}，{}，如下图所示；

     找到当前簇中距离最短的两个点，这里我们使用单连锁的方式来计算距离，发现点和点距离最短，将和组成一个新的簇，此时簇列表中包含五个簇，分别是{，}，{}，{}，{}，{}，如下图所示；
  重复步骤二、发现{}和{}的距离最短，连接之，然后是簇{}和簇{}距离最短，依次类推，直到最后只剩下一个簇，得到如下所示的示意图：

 此时原始数据的聚类关系是按照层次来组织的，选取一个簇间距离的阈值，可以得到一个聚类结果，比如在如下红色虚线的阈值下，数据被划分为两个簇：簇{，，，，}和簇{}

聚类算法的优点是能够根据需要在不同的尺度上展示对应的聚类结果，缺点同 算法一样，一旦两个距离相近的点被划分到不同的簇，之后也不再可能被聚类到同一个簇，即无法撤销先前步骤的工作。另外，性能较低，并且因为聚类层次信息需要存储在内存中，内存消耗大，不适用于大量级的数据聚类，下面介绍一种针对大数据量级的聚类算法。
算法
算法的全称是      ，它使用聚类特征来表示一个簇，使用聚类特征树树来表示聚类的层次结构，算法思路也是“自底向上”的。
算法相比凝聚算法具有如下特点：

解决了算法不能撤销先前步骤的工作的缺陷；

树只存储原始数据的特征信息，并不需要存储原始数据信息，内存开销上更优；

算法只需要遍历一遍原始数据，而算法在每次迭代都需要遍历一遍数据，所以在性能也优于；

支持对流数据的聚类，一开始并不需要所有的数据；


首先介绍几个基本的概念，给定簇={ 〖…〗_}，其中_代表一个数据点，可以是一维、二维或者多维数据，下面公式中_的计算均为向量计算。
质心，代表这个簇的中心：

簇半径，簇中所有点到质心的平均距离：

簇直径，簇中所有数据点之间的平均距离；

算法的核心是构建树  ，而树种每个节点代表一个簇的抽象特征，包含三个数据：


表示簇中数据个数；

是个点的线性和即；

是个数据点的平方和即；


聚类特征是可加的，也就是说，对于两个不想交的簇_和_，其聚类特征分别为〖〗_=_〖〗_〖〗_和〖〗_=_〖〗_〖〗_，合并_和_后的簇的聚类特征是：
〖〗_〖〗_=__〖〗_ 〖〗_〖〗_〖〗_
树的结构类似于一棵树，它有两个参数：内部节点平衡因子即每个节点允许的子节点数，叶节点平衡因子即最终叶子节点允许的最大叶子数，簇半径阈值。树中每个节点最多包含个孩子节点，记为_，_，其中≤≤，例如，一棵高度为，为，为的一棵树的例子如图所示：

构造树的步骤如下：

从根节点开始，自上而下选择最近的孩子节点；

到达叶子节点后，检查距离其最近的能否吸收此数据点： 是，更新值    否，创建一个新的节点，检查该节点能否加入到当前叶子节点      能，添加到当前叶子节点；      否，分裂最远的一对节点，按最近距离重新分配其它节点；

更新每个非叶子节点的信息，如果分裂节点，在父节点中插入新的节点，直到；


对于上图所示的树，假设现在添加一个新的簇_，这个簇距离_最近，但是不满足被吸收的条件_和_之间的距离大于了阈值，加入过程如下：
①用_跟_和_比较距离，发现离_更近；找到_的子节点_和_；
②同步骤，找到_的子节点，发现为叶子节点：{ ___}；
③尝试把_加入到叶子节点，此时节点的数量为，超过了我们设定的值，所以现在需要分离节点，将_和_分到一个新的叶子节点，然后剩下_和_；
④同时在节点中加入一个新的非叶子节点，此时节点的数量为，大于我们设定的值，进一步拆分节点为两个新的非叶子节点；
⑤同步骤，知道所有的节点都满足树种=，=的约束；
⑥更新所有节点对应的特征值，得到如下的新树：

算法的主流程如下：

算法
  是一种针对大型数据库的高效的聚类算法。基于划分的传统的聚类算法得到的是球状的，相等大小的聚类，对异常数据比较脆弱。采用了用多个点代表一个簇的方法，可以较好的处理以上问题。并且在处理大数据量的时候采用了随机取样，分区的方法，来提高其效率，使得其可以高效的处理大量数据。
我们先看一下基于划分聚类算法的缺陷：

如上图所示，基于划分的聚类算法比如 聚类算法，不能够很好地区分尺寸差距大的簇，原因是算法基于“质心”加一定“半径”对数据进行划分，导致最后聚类的簇近似“圆形”。
再看一下其他聚类算法在聚类结果上可能存在的问题：

上面图使用的是基于“平均连锁”或者基于“质心”的簇间距离计算方式得到的聚类结果，可以看出，聚类结果同基于划分的聚类算法相似、最后聚类的结果呈“圆形”，不能够准确地识别条形的数据；图使用的是基于“单连锁”的簇间距离计算策略，由“单连锁”的定义可知，对于图中最左边两个由一条细线相连的两个簇，会被聚类成一个簇，这也不是我们想要的。
算法核心的思想是使用一定数量的“分散的”点 来代表一个簇，而不像是其他层次聚类算法中，只使用一个点，使得算法有如下优势：

准确地识别任意形状的簇；

准确地识别尺寸差距大的簇；

很好地处理“噪点”


所以，算法很好地解决了上面提到的聚类结果的缺陷，算法主流程如下：
 

从总数据中随机选取一个样本；

利用层次聚类算法把这个样本聚类，形成最初的簇_=…；

选取“代表点” 


①对于每个簇，选取代表点比如个，这些点尽量分散
②按照固定的比例α比如，把每个样本点向簇的“质心”收缩，生成代表点
 
重新扫描所有的数据， 把它放到 “最近的簇”对于点，使用如下公式，找到距离最近的簇：


简单来讲，点到簇_的距离为点到簇_的四个“代表点中最近的点之间的距离。
收缩系数α的取值不同，聚类结果也相应不同。当α趋于时，所有的“代表点”都汇聚到质心，算法退化为基于“质心”的聚类；当α趋于时，“代表点”完全没有收缩，算法退化为基于“全连接”的聚类，因此α值需要要根据数据特征灵活选取，才能得到更好的聚类结果：

变色龙算法
图算法，参数=… 。以为为例，一次处理每一个点，每个点找一个最近的邻居链接起来，得到一个图。

整体算法步骤为：
    创建图；
    使用最大流算法或者最小割算法，将图分隔成小图；
 将小簇进行和并，合并条件是大于某个值，和的一个基本思想是，点之间的链接越多，这些点越可能连接成一个簇，表示一个簇，是点的集合，｜Ｃ｜是集合的大小，即点的个数表示两个簇之间的边的数量。
 
层次聚类算法对比

参考文献：
        数据挖掘概念与技术第三版，，
          数据挖掘使用机器学习工具与技术，
                  ，
                ，作者：何方舟

已经是成为我们解决回调炼狱的常用方案，而且已经得到官方标准支持，如果你刚刚开始使用，本文将帮助你了解几个常见的几个的使用场景
使用可以让程序的可读性变得更好。如下面这样的代码：
  = 
      
       
       
       

 {

    
     ={
       ={
              = {
                  
            }
            
             
       }
   }
}

 {
    
     ={
       ={
            
              = {
                  
            }
             
            
       }
   }
}

 {
    
     ={
       ={
          = {
              
        }
         
        
       }
   }
}

 输出结果 
  
  
  
  
  
  


如上面代码所示，我们可以很清楚的理解到程序执行的顺序是  

得到
得到
得到

这样的代码在许多示例中都可见，但这里有一点需要特别注意一下每次调用都会返回一个新的，如果中的申明的方法没有返回一个，那么会默认返回一个新的处于的之后添加的中的方法都会立即执行如下面代码所示，如果在上面的代码中没有返回一个，输出的结果就变成      了。当要在使用链式时，请在传入的方法中返回一个新的。
  = 
      
       
       
       

 {
   
    ={
       ={
        
        
       }
   }
}

 {
   
    ={
       ={
        
        
       }
   }
}

 {
   
    ={
       ={
        
        
       }
   }
}

 输出结果 
  
  
  
  
  
  


另外一个需要注意的是，传递给下个方法的值只能有一个，上面 方法中是无法获取到的值，所以如果有多个值需要放在一个数据集合中传入下个方法。
 {  为 
     {   }
      
}

原生函数的化
大部分原生的函数并不支持，还是基于回调来使用的，所以需要把一些方法化，类似化。下面一个例子把原生中的定时器 进行化。
 {
     {
           ={
            {
                
                
            }
        }
    }
}

    
          {
            
        } 
    
     = {
        
    }

化本质上都属于一种化。化是指，把需要传递多参数的函数生成一个新的函数，如上代码 先通过执行 得到一个新的函数，该函数会返回一个，这样就完成了化。
   {
    
 } 


原文链接：导读：在线性回归问题中，我们定义了损失函数，但是为什么用最小二乘而不是三次方等作为损失函数？ 

我们来尝试解决一个完整的线性回归问题：
设：
训练样本，其中是输入特征，是目标变量
回归方程的形式是：
   
我们假设误差项：服从独立同分布的高斯分布，即
这里对误差项服从的分布的假设，直观地理解，就是误差在越接近的地方出现的概率越大，越远离的地方出现的概率越小，在两边出现的概率对称，并且误差服从的分布总是让多次测量的均值成为对真值最好的估计。至于为什么符合这些直观感受的误差的概率密度函数恰好是式？敬请期待下一篇文章
接下来我们对似然函数进行极大似然估计
                                  
对两边取对数
 
对取对数后，单调性不变，所以让取得最大值，等价于令中损失函数
                                
取最小值。
到这里，最小二乘法就得到了解释。并且这个结论与我们假设的没有关系。
接下来，我们继续我们的目标，寻找使损失函数最小的：
寻找通常有两种方法，一种是求解析解，求解过程这里暂不做展开。
我们重点说明第二种方法：梯度下降法。
梯度下降的过程是：
  给定的初始值，计算；
  在的基础上减去在该点的梯度，得到新的，计算；
  重复以上步骤，直到取到局部最小值；
  再次选择的初始值，重复以上步骤，直到取到的所有局部最小值。
梯度方向是
    
的反方向，因此用梯度下降法迭代的过程可以写为： 
观察用梯度下降法迭代的过程，迭代效果的好坏对初始值的选择、迭代步长有很高的依赖，在工程上对线性回归的优化通常是基于这两点展开。背景介绍
用户也许会经常碰到以下的问题：应用后台开着，手机很快没电了——应用耗电大；首次非首次启动应用，进入应用特别慢——应用启动慢；应用使用过程中，越来越卡——能力不足内存泄露；应用页面卡顿——帧率较低、页面卡顿。因此，对开发的应用，必须对其进行性能测试，不然将会直接影响用户体验。
应用性能测试通常包括：启动时间、内存、、耗电量、流量、流畅度等。本次先介绍启动时间的测试方法。
启动时间对于的性能测试，启动时间是个重要指标，启动时间分为两种情况，一种是冷启动时间通常是系统重启，即在启动前没有该进程的情况，另一种是热启动，即从被切换到前台点退出后再点击图标启动。测试时，一般关注冷启动的启动时间。以下介绍三种测试启动时间的方法，供大家参考，可以有针对性的使用。
 使用命令
 测试方法输入    命令，计算启动时间。如下图：
图应用第一次启动也就是我们常说的冷启动这时候你的应用程序的进程是没有创建的 这也是大部分应用的使用场景用户在桌面上点击你应用的  之后首先要创建进程然后才启动 这时候     返回的结果就是标准的应用程序的启动时间。注意  之前的手机是没有这个值的。关于的区别下面是其解释。=

记录的刚准备调用的时间点
记录的是函数调用返回的时间点
 = 调用耗时。

 就是总的耗时，包括前一个应用  的时间和新应用启动的时间； 表示一连串启动 的最后一个  的启动耗时；表示新应用启动的耗时，包括新进程的启动和  的启动，但不包括前一个应用  的耗时。也就是说，开发者一般只要关心  即可，这个时间才是自己应用真正启动的耗时。
总结一下，如果只关心某个应用自身启动耗时，参考；如果关心系统启动应用耗时，参考；如果关心应用有界面启动耗时，参考。
 总结
该方法算出的时间是系统从开始处理启动的时间到完成运行和函数的时间，简单的理解就是启动这个的时间，并不包括点击到系统接收到消息的时间。显然，这个时间并不能完整的模拟用户操作场景的启动时间。其次该方法只计算一个的整体启动时间，没有分别统计其中每个函数的时间，不便于定位问题。针对这两个问题，我们接下来看一下下面两个方法是怎样解决的。
我们在测试中关注的其实是用户体验的启动时间，那么上面的时间就不能满足我们的需求了。既然是用户体验我们可以用更直观的方式，使用进行屏幕录制然后分析视频。
 使用进行屏幕录制
 测试方法输入命令        参数会使视频输出一些时间信息和帧信息便于我们分析启动时间。点击收集图标，完全启动后，使用结束视频录制。使用命令  ，导出视频导出视频到电脑，使用可以按帧播放的视频软件打开上就可以，下可以用，并按帧播放。如下图所示：图按帧播放视频，视频左上角会显示每一帧的时间精确到和帧数。如图，表示时分秒，=是帧数。在视频中会看到会变暗然后高亮，高亮时就是系统开始处理本次点击事件了。可以把这里作为点击时间，然后根据体验要求，看到启动页完全绘制完作为终止时间，这个时间减去点击时间就是的启动时间。
 总结该方法虽然可以模拟用户的操作场景，但是操作成本较高且无法准确清晰明了的知道哪些函数调用时间过长。以上两种方法，单从启动时间看，是无法定位出具体哪个函数耗时多一些，遇到启动时间大于预定的启动时间阀值时，需一步步的打，分析查明原因。下面的方法是贴吧目前计算启动时间的办法，可以很清晰的看到每个函数的调用时间。 
 代码埋点，查看输出日志
 测试方法    在代码中打点，输出日志查看。拿贴吧举例，下图是整个启动要经历的操作。图具体每步做了哪些，可以参照下表。图这样通过打点输出日志来测试启动时间，就可以很方便的查看到具体每个模块的耗时时间了，如下图。

 总结这样打点，可以清晰明了的看出的总耗时及各个函数的耗时情况，这样在测试过程中，如果遇到问题可以很容易的定位到具体的函数。在测试过程中也有针对点，比如贴吧直播后续会以插件的形式整合到贴吧里，测试时，可以多关注初始化的时间。
针对启动时间这一性能指标，个人觉得打点输出日志的方式较为理想，在测试过程中发现有疑似问题后，可以给出具体的函数耗时时间。

相关推荐
【专项测试】—冲突测试
【腾讯】移动自动化测试框架对比
快速定位手游内存占用过高问题
移动开发一站式解决方案作者：马彬

导语
一则新闻“  又曝新漏洞，播放特定视频导致自动关机 ”在媒体上广泛传播，实际上玄武实验室在月日就发现了该视频样本，在深入分析后，我们在微信后台对能够触发这种漏洞的恶意视频进行检测和拦截，保护了大量用户免遭攻击。
一、 概述
 月日，一则新闻“又曝新漏洞，播放特定视频导致自动关机”在媒体上广泛传播。任何苹果设备在播放某个视频后，就会在几秒内卡死，无法响应任何操作，持续分钟后整个系统自动重启。由于从 到最新的 系统都会受到影响，且部分媒体贴出了恶意视频样本，一时间这个恶意视频被通过各种渠道大范围传播。
我们实验室在月日捕获了该恶意视频样本。经过深入分析，我们写出了针对该漏洞的检测工具，并通过我们实验室和微信安全中心的相关合作项目，在微信后台对该恶意视频进行检测和拦截，保护了大量用户免遭攻击。
苹果在刚刚发布的 中除修复我们实验室报告的个漏洞之外，也已经修复了该漏洞，因此在这里分享一下我们对这个问题的研究。
二、 分析
    排查原因
我们拿到的样本是一段秒拍的视频，自然首先想到可能是秒拍的问题或者人为的利用 构造传播。考虑到视频中嵌有作者信息，因此我们找到视频的作者，用该作者的其他视频进行播放测试。在作者发布的仅有的个视频中，均使用同样的视频模版，视频长度也几近相同。我们进行对比播放后，发现只有样本视频会，其他视频均播放正常。考虑到视频样本在秒拍上的转发量较小，因此排除人为构造的情况。
  
进一步的使用对比两个文件，除了字段和编码后的视频数据区内容区别外，其他文件头字段内容均相同。因此排除了视频文件格式的问题，我们基本确定问题出在的硬解码处理上。
    分析原因
为了分析清楚问题原因，我们对的文档进行了非常艰苦的学习。
在中，图像以为单位进行组织，即我们平时所说的“帧”。每一个的数据可以分为多个片，片分为片、片、片， 和通过进行封装。一个序列的第一个图像叫做  图像立即刷新图像， 图像都是  帧图像， 引入  图像是为了解码的重同步，当解码器解码到  图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。每一个又由多个宏块组成，一个宏块由一个×亮度像素和附加的一个× 和一个× 彩色像素块组成。如下图所示，视频数据经过层层编码成为了文件中的数据，因此的解码也要经过 、 、 、 等等，中间还会有熵解码、帧内预测等各种复杂的流程，会导致非视频行业人员理解起来非常抽象和困难。

在熟悉了编码相关知识后，我们发现问题可能出在视频样本的第帧，对应的数据如下图。其中”   “代表了单元的长度，”“代表了第一个 为 ，之后的数据为 。

解码时会进行宏块预测，在宏块预测的时候需要用到当前宏块左边、上左、上边，上右位置的宏块有关的信息，因此在预测前需要先填充这些信息。如果填充完成后没有对宏块是否可用检测，在不可用的上进行帧预测，就会发生错误。
而该视频的第帧数据的偏移和两个字节恰好会导致解码过程出现上述错误。采用哥伦布编码方式对其进行解码运算后，对按照特定方式进行填充，进而导致 不可用。通过把和改为和后， 我们将修改后的视频用设备测试发现并不会，因此确认问题出现在和这两个字节。
    将任意畸形化
上述视频样本是由于和两个字节导致的，那么是不是在任意帧内加入和两个字节就会触发漏洞呢？
 答案是否定的。由上述分析可知，根本原因是中的 或 不可用才导致的，因此必须在熵解码时候对应的字节处修改，而且不一定必须修改为和两个字节。
将恶意视频的那一帧直接拷贝到一个正常的视频中也是不可行的，这是因为视频解码部分还会对帧的长度进行判断，最重要的是解码过程中还要受和影响，当两个视频的和不同时，解码时就会有差异。
 在研究中，我们写了一个自动化的工具，能够很快的将一个任意变成攻击视频，而且不影响视频的播放画面。考虑到 刚刚推出，还有很多人未更新，这种危险的东西就不分享出来了。
 
三、 检测
基于上述分析，开发出检测率的工具并不困难。但由于恶意字节可能出现在视频的任意一帧中，因此检测工具需要逐帧解析，因而理论上如果要确保的检测率，就不可能实现很高的检测效率。于是我们基于实际运营中遇到的情况，针对流行样本变异规律，开发出了既能应对各种变种样本，又有极高检测效率的轻量型的检测工具，平衡了准确率和检测效率，取得了较好的效果。在开发机上基于个文件作测试，平均每个检测时间秒。以最大视频为例微信最大支持，检测只需要秒。